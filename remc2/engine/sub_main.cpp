#include "sub_main.h";

//#define debug_hide_graphics

/*
bool localDrive::TestDir(const char * dir) {
if (nocachedir) EmptyCache();
sub_2D190
char newdir[CROSS_LEN];
strcpy(newdir,basedir);
strcat(newdir,dir);
CROSS_FILENAME(newdir);
dirCache.ExpandName(newdir);

// guest to host code page translation
host_cnv_char_t *host_name = CodePageGuestToHost(newdir);
if (host_name == NULL) {
LOG_MSG("%s: Filename '%s' from guest is non-representable on the host filesystem through code page conversion",__FUNCTION__,newdir);
return false;
}

// Skip directory test, if "\"
size_t len = strlen(newdir);
if (len && (newdir[len-1]!='\\')) {
// It has to be a directory !
ht_stat_t test;
if (ht_stat(host_name,&test))		return false;
if ((test.st_mode & S_IFDIR)==0)	return false;
};
int temp=ht_access(host_name,F_OK);
return (temp==0);
}

Bit8u DOS_FindDevice(char const * name) {
// should only check for the names before the dot and spacepadded
char fullname[DOS_PATHLENGTH];Bit8u drive;
//	if(!name || !(*name)) return DOS_DEVICES; //important, but makename does it
if (!DOS_MakeName(name, fullname, &drive)) return DOS_DEVICES;

char* name_part = strrchr(fullname, '\\');
if (name_part) {
	*name_part++ = 0;
	//Check validity of leading directory.
	if (!Drives[drive]->TestDir(fullname)) return DOS_DEVICES;
}
else name_part = fullname;

char* dot = strrchr(name_part, '.');
if (dot) *dot = 0; //no ext checking

static char com[5] = { 'C','O','M','1',0 };
static char lpt[5] = { 'L','P','T','1',0 };
// AUX is alias for COM1 and PRN for LPT1
// A bit of a hack. (but less then before).
// no need for casecmp as makename returns uppercase
if (strcmp(name_part, "AUX") == 0) name_part = com;
if (strcmp(name_part, "PRN") == 0) name_part = lpt;

// loop through devices
for (Bit8u index = 0;index < DOS_DEVICES;index++) {
	if (Devices[index]) {
		if (WildFileCmp(name_part, Devices[index]->name)) return index;
	}
}
return DOS_DEVICES;
}

bool DOS_OpenFile(char const * name,Bit8u flags,Bit16u * entry) {
#if defined(WIN32) && !defined(__MINGW32__)
if(Network_IsNetworkResource(const_cast<char *>(name)))
return Network_OpenFile(const_cast<char *>(name),flags,entry);
#endif
// First check for devices
if (flags>2) LOG(LOG_FILES, LOG_NORMAL)("Special file open command %X file %s", flags, name); // FIXME: Why? Is there something about special opens DOSBox doesn't handle properly?
else LOG(LOG_FILES, LOG_NORMAL)("file open command %X file %s", flags, name);

DOS_PSP psp(dos.psp());
Bit16u attr = 0;
Bit8u devnum = DOS_FindDevice(name);
bool device = (devnum != DOS_DEVICES);
if (!device && DOS_GetFileAttr(name, &attr)) {
	//DON'T ALLOW directories to be openened.(skip test if file is device).
	if ((attr & DOS_ATTR_DIRECTORY) || (attr & DOS_ATTR_VOLUME)) {
		DOS_SetError(DOSERR_ACCESS_DENIED);
		return false;
	}
}

char fullname[DOS_PATHLENGTH];Bit8u drive;Bit8u i;
// First check if the name is correct
if (!DOS_MakeName(name, fullname, &drive)) return false;
Bit8u handle = 255;
// Check for a free file handle
for (i = 0;i<DOS_FILES;i++) {
	if (!Files[i]) {
		handle = i;
		break;
	}
}
if (handle == 255) {
	DOS_SetError(DOSERR_TOO_MANY_OPEN_FILES);
	return false;
}
// We have a position in the main table now find one in the psp table
*entry = psp.FindFreeFileEntry();

if (*entry == 0xff) {
	DOS_SetError(DOSERR_TOO_MANY_OPEN_FILES);
	return false;
}
bool exists = false;
if (device) {
	Files[handle] = new DOS_Device(*Devices[devnum]);
}
else {
	exists = Drives[drive]->FileOpen(&Files[handle], fullname, flags);
	if (exists) Files[handle]->SetDrive(drive);
}
if (exists || device) {
	Files[handle]->AddRef();
	psp.SetFileHandle(*entry, handle);
	Files[handle]->drive = drive;
	return true;
}
else {
	//Test if file exists, but opened in read-write mode (and writeprotected)
	if (((flags & 3) != OPEN_READ) && Drives[drive]->FileExists(fullname))
		DOS_SetError(DOSERR_ACCESS_DENIED);
	else {
		if (!PathExists(name)) DOS_SetError(DOSERR_PATH_NOT_FOUND);
		else DOS_SetError(DOSERR_FILE_NOT_FOUND);
	}
	return false;
}
}

bool localDrive::FileOpen(DOS_File * * file,const char * name,Bit32u flags) {
if (nocachedir) EmptyCache();

if (readonly) {
if ((flags&0xf) == OPEN_WRITE || (flags&0xf) == OPEN_READWRITE) {
DOS_SetError(DOSERR_WRITE_PROTECTED);
return false;
}
}

const host_cnv_char_t * type;
switch (flags&0xf) {
case OPEN_READ:        type = _HT("rb");  break;
case OPEN_WRITE:       type = _HT("rb+"); break;
case OPEN_READWRITE:   type = _HT("rb+"); break;
case OPEN_READ_NO_MOD: type = _HT("rb");  break; //No modification of dates. LORD4.07 uses this
default:
DOS_SetError(DOSERR_ACCESS_CODE_INVALID);
return false;
}
char newname[CROSS_LEN];
strcpy(newname,basedir);
strcat(newname,name);
CROSS_FILENAME(newname);
dirCache.ExpandName(newname);

//Flush the buffer of handles for the same file. (Betrayal in Antara)
Bit8u i,drive=DOS_DRIVES;
localFile *lfp;
for (i=0;i<DOS_DRIVES;i++) {
if (Drives[i]==this) {
drive=i;
break;
}
}
for (i=0;i<DOS_FILES;i++) {
if (Files[i] && Files[i]->IsOpen() && Files[i]->GetDrive()==drive && Files[i]->IsName(name)) {
lfp=dynamic_cast<localFile*>(Files[i]);
if (lfp) lfp->Flush();
}
}

// guest to host code page translation
host_cnv_char_t *host_name = CodePageGuestToHost(newname);
if (host_name == NULL) {
LOG_MSG("%s: Filename '%s' from guest is non-representable on the host filesystem through code page conversion",__FUNCTION__,newname);
DOS_SetError(DOSERR_FILE_NOT_FOUND);
return false;
}

#ifdef host_cnv_use_wchar
FILE * hand=_wfopen(host_name,type);
#else
FILE * hand=fopen(host_name,type);
#endif
//	Bit32u err=errno;
if (!hand) {
if((flags&0xf) != OPEN_READ) {
#ifdef host_cnv_use_wchar
FILE * hmm=_wfopen(host_name,L"rb");
#else
FILE * hmm=fopen(host_name,"rb");
#endif
if (hmm) {
fclose(hmm);
#ifdef host_cnv_use_wchar
LOG_MSG("Warning: file %ls exists and failed to open in write mode.\nPlease Remove write-protection",host_name);
#else
LOG_MSG("Warning: file %s exists and failed to open in write mode.\nPlease Remove write-protection",host_name);
#endif
}
}
return false;
}

*file=new localFile(name,hand);
(*file)->flags=flags;  //for the inheritance flag and maybe check for others.
//	(*file)->SetFileName(host_name);
return true;
}
*/

//posistruct var_2BB3E0_x_DWORD_EA3D4_14[0x3e9];

Bit8u* SEARCH_BEGIN_BUFFER = 0;
Bit8u* SEARCH_END_BUFFER = 0;
Bit8u* FONTS0DAT_BEGIN_BUFFER = 0;
Bit8u* FONTS0TAB_BEGIN_BUFFER = 0;
Bit8u* FONTS0TAB_END_BUFFER = 0;
Bit8u* FONTS1DAT_BEGIN_BUFFER = 0;//2baa94
Bit8u* FONTS1TAB_BEGIN_BUFFER = 0;//2bab24
Bit8u* FONTS1TAB_END_BUFFER = 0;//2bab04
Bit8u* TMAPS00TAB_BEGIN_BUFFER = 0;//2c7ed0
Bit8u* PALDATA_BEGIN_BUFFER = 0;//2bb3c8
Bit8u* PALMEM_BEGIN_BUFFER = 0;//6d654d
Bit8u* POINTERSDAT_BEGIN_BUFFER = 0;//2bc390
Bit8u* POINTERSTAB_BEGIN_BUFFER = 0;//2bc394
Bit8u* POINTERSTAB_END_BUFFER = 0;//2bc388*/

Bit8u* BUILD00DAT_BEGIN_BUFFER = 0;
Bit8u* BUILD00TAB_BEGIN_BUFFER = 0;
Bit8u* BUILD00TAB_END_BUFFER = 0;

Bit8u* ETEXT_BEGIN_BUFFER = 0;
Bit8u* FTEXT_BEGIN_BUFFER = 0;
Bit8u* GTEXT_BEGIN_BUFFER = 0;
Bit8u* ITEXT_BEGIN_BUFFER = 0;

Bit8u* BLOCK16DAT_BEGIN_BUFFER = 0;
Bit8u* BLOCK32DAT_BEGIN_BUFFER = 0;

Bit8u* BSCREEN_BEGIN_BUFFER = 0;
Bit8u* BSCREEN_END_BUFFER = 0;

Bit8u* PALD0DAT_BEGIN_BUFFER = 0;
Bit8u* PALD0DAT2_BEGIN_BUFFER = 0;

Bit8u* WSCREEN_BEGIN_BUFFER = 0;
Bit8u* WSCREEN_END_BUFFER = 0;

Bit8u* BSCREEN2_BEGIN_BUFFER = 0;
Bit8u* BSCREEN2_END_BUFFER = 0;

Bit8u* MSPRD00DAT_BEGIN_BUFFER = 0;
Bit8u* MSPRD00TAB_BEGIN_BUFFER = 0;
Bit8u* MSPRD00TAB_END_BUFFER = 0;

Bit8u* HSPRD00DAT_BEGIN_BUFFER = 0;
Bit8u* HSPRD00TAB_BEGIN_BUFFER = 0;
Bit8u* HSPRD00TAB_END_BUFFER = 0;

Bit8u* HFONT3DAT_BEGIN_BUFFER = 0;
Bit8u* HFONT3TAB_BEGIN_BUFFER = 0;
Bit8u* HFONT3TAB_END_BUFFER = 0;

Bit8u* CLRD0DAT_BEGIN_BUFFER = 0;
Bit8u* SPELLS_BEGIN_BUFFER = 0;

Bit8u* LANG_BEGIN_BUFFER = 0;



Bit8u* ZERO_BUFFER = 0;





typedef struct {
	Bit8u** begin_buffer;
	Bit8u** end_buffer;
	Bit8u** dat_buffer;
	posistruct* posistruct;
} filearray_struct;

posistruct posistruct1[1700];//fix it
posistruct posistruct2[1700];//fix it
posistruct posistruct3[1700];//fix it
posistruct posistruct4[1700];//fix it
posistruct posistruct5[1700];//fix it
posistruct posistruct6[1700];//fix it
posistruct posistruct7[1700];//fix it
posistruct posistruct8[1700];//fix it
posistruct posistruct9[1700];//fix it
posistruct posistruct10[1700];//fix it
posistruct posistruct11[1700];//fix it
posistruct posistruct12[1700];//fix it
posistruct posistruct13[1700];//fix it
posistruct posistruct14[1700];//fix it
posistruct posistruct15[1700];//fix it
posistruct posistruct16[1700];//fix it
posistruct posistruct17[1700];//fix it
posistruct posistruct18[1700];//fix it
posistruct posistruct19[1700];//fix it
posistruct posistruct20[1700];//fix it
posistruct posistruct21[1700];//fix it
posistruct posistruct22[1700];//fix it
posistruct posistruct23[1700];//fix it
posistruct posistruct24[1700];//fix it
posistruct posistruct25[1700];//fix it
posistruct posistruct26[1700];//fix it
posistruct posistruct27[1700];//fix it
posistruct posistruct28[1700];//fix it
posistruct posistruct29[1700];//fix it
posistruct posistruct30[1700];//fix it
posistruct posistruct31[1700];//fix it
posistruct posistruct32[1700];//fix it
posistruct posistruct33[1700];//fix it
posistruct posistruct34[1700];//fix it
posistruct posistruct35[1700];//fix it
posistruct posistruct36[1700];//fix it
posistruct posistruct37[1700];//fix it
posistruct posistruct38[1700];//fix it
posistruct posistruct39[1700];//fix it
posistruct posistruct40[1700];//fix it
posistruct posistruct41[1700];//fix it
posistruct posistruct42[1700];//fix it
posistruct posistruct43[1700];//fix it
posistruct posistruct44[1700];//fix it
posistruct posistruct45[1700];//fix it
posistruct posistruct46[1700];//fix it
posistruct posistruct47[1700];//fix it
posistruct posistruct48[1700];//fix it
posistruct posistruct49[1700];//fix it
posistruct posistruct50[1700];//fix it

filearray_struct filearray_2aa18c[] = {
	{ &POINTERSTAB_BEGIN_BUFFER,&POINTERSTAB_END_BUFFER,&POINTERSDAT_BEGIN_BUFFER,posistruct1 },
{ &FONTS0TAB_BEGIN_BUFFER,&FONTS0TAB_END_BUFFER,&FONTS0DAT_BEGIN_BUFFER,posistruct2 },
{ &FONTS1TAB_BEGIN_BUFFER,&FONTS1TAB_END_BUFFER,&FONTS1DAT_BEGIN_BUFFER,posistruct3 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct4 },
{ &MSPRD00TAB_BEGIN_BUFFER,&MSPRD00TAB_END_BUFFER,&MSPRD00DAT_BEGIN_BUFFER,posistruct5 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct6 },
{ &HFONT3TAB_BEGIN_BUFFER,&HFONT3TAB_BEGIN_BUFFER,&HFONT3TAB_END_BUFFER,posistruct7 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct8 },
{ &BUILD00TAB_BEGIN_BUFFER,&BUILD00TAB_END_BUFFER,&BUILD00DAT_BEGIN_BUFFER,posistruct9 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct10 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct11 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct12 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct13 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct14 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct15 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct16 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct17 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct18 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct19 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct20 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct21 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct22 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct23 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct24 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct25 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct26 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct27 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct28 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct29 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct30 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct41 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct42 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct43 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct44 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct45 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct46 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct47 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct48 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct49 },
{ &ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,posistruct50 },
};
/*
Bit8u** filearray_2aa18c[] = {//misto *filearray_2aa18c - 2aa18c
&POINTERSTAB_BEGIN_BUFFER,&POINTERSTAB_END_BUFFER,&POINTERSDAT_BEGIN_BUFFER,
&FONTS0TAB_BEGIN_BUFFER,&FONTS0TAB_END_BUFFER,&FONTS0DAT_BEGIN_BUFFER,
&ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,
&MSPRD00TAB_BEGIN_BUFFER,&MSPRD00TAB_END_BUFFER,&MSPRD00DAT_BEGIN_BUFFER,
&ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,
&ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,
&ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,
&ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,
&ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,
&ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,
&ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,
&ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,
&ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,
&ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER,
&ZERO_BUFFER,&ZERO_BUFFER,&ZERO_BUFFER
};
*/
int filearrayindex_POINTERSDATTAB = 0;
int filearrayindex_FONTS0DATTAB = 1;
int filearrayindex_MSPRDDATTAB = 2;
int filearrayindex_ZERO1 = 3;
int filearrayindex_MSPRD00DATTAB = 4;
int filearrayindex_ZERO2 = 5;
int filearrayindex_HFONT3DATTAB = 6;
int filearrayindex_ZERO3 = 7;
int filearrayindex_BUILD00DATTAB = 8;
int filearrayindex_ZERO4 = 9;


typedef struct {
	char path[0x1c];
	Bit8u** var28_begin_buffer;//1C // asi buffer
	Bit8u** var32_end_buffer;//20 // asi buffer
	Bit32u var36_size_buffer;//24 //asi file size
	Bit32u var40_alloc_type;//28
} Pathstruct;

Bit8u* x_DWORD_D41BC_langbuffer; // fix it

Pathstruct xasearchd = { "*SearchD\0",&SEARCH_BEGIN_BUFFER,&SEARCH_END_BUFFER,0x1000,NULL };
#define psxasearchd 0
Pathstruct xafonts0dat = { "data/font0.dat\0",&FONTS0DAT_BEGIN_BUFFER,NULL,NULL,NULL };
#define psxafonts0dat 1
Pathstruct xafonts0tab = { "data/font0.tab\0",&FONTS0TAB_BEGIN_BUFFER,&FONTS0TAB_END_BUFFER,NULL,NULL };
#define psxafonts0tab 2
Pathstruct xafonts1dat = { "data/font1.dat\0",&FONTS1DAT_BEGIN_BUFFER,NULL,NULL,NULL };
#define psxafonts1dat 3
Pathstruct xafonts1tab = { "data/font1.tab\0",&FONTS1TAB_BEGIN_BUFFER,&FONTS1TAB_END_BUFFER,NULL,NULL };
#define psxafonts1tab 4
Pathstruct xadatatmaps00tab = { "data/tmaps0-0.tab",&TMAPS00TAB_BEGIN_BUFFER,NULL,NULL,NULL };
#define psxadatatmaps00tab 5
Pathstruct xapaldata = { "*PalData\0",&PALDATA_BEGIN_BUFFER,NULL,0x400,NULL };
#define psxapaldata 6
Pathstruct xapalmem = { "*PalMem\0",&PALMEM_BEGIN_BUFFER,NULL,NULL,NULL };
#define psxapalmem 7
Pathstruct xadatapointersdat = { "data/pointers.dat\0",&POINTERSDAT_BEGIN_BUFFER,NULL,NULL,NULL };
#define psxadatapointersdat 8
Pathstruct xadatapointerstab = { "data/pointers.tab\0",&POINTERSTAB_BEGIN_BUFFER,&POINTERSTAB_END_BUFFER,NULL,NULL };
#define psxadatapointerstab 9
Pathstruct xazero = { "\0",NULL,NULL,NULL,NULL };
#define psxazero0 10
Pathstruct xadatabuild00dat = { "data/build0-0.dat\0",&BUILD00DAT_BEGIN_BUFFER,NULL,NULL,NULL };
#define psxadatabuild00dat 11
Pathstruct xadatabuild00tab = { "data/build0-0.tab\0",&BUILD00TAB_BEGIN_BUFFER,&BUILD00TAB_END_BUFFER,NULL,NULL };
#define psxadatabuild00tab 12
//zero
#define psxazero1 13
Pathstruct xadataetextdat = { "data/etext.dat\0",&ETEXT_BEGIN_BUFFER,NULL,NULL,NULL };
#define psxadataetextdat 14
//zero
#define psxazero2 15
Pathstruct xadataftextdat = { "data/ftext.dat\0",&FTEXT_BEGIN_BUFFER,NULL,NULL,NULL };
#define psxadataftextdat 16
//zero
#define psxazero3 17
Pathstruct xadatagtextdat = { "data/gtext.dat\0",&GTEXT_BEGIN_BUFFER,NULL,NULL,NULL };
#define psxadatagtextdat 18
//zero
#define psxazero4 19
Pathstruct xadataitextdat = { "data/itext.dat\0",&ITEXT_BEGIN_BUFFER,NULL,NULL,NULL };
#define psxadataitextdat 20
//zero
#define psxazero5 21
Pathstruct xadatablock16dat = { "data/block16.dat\0",&BLOCK16DAT_BEGIN_BUFFER,NULL,NULL,NULL };
#define psxadatablock16dat 22
Pathstruct xadatablock32dat = { "data/block32.dat\0",&BLOCK32DAT_BEGIN_BUFFER,NULL,NULL,NULL };
#define psxadatablock32dat 23
//zero
#define psxazero6 24
Pathstruct xabscreen = { "*BScreen\0",&BSCREEN_BEGIN_BUFFER,&BSCREEN_END_BUFFER,0x011508,NULL };
#define psxabscreen 25
Pathstruct xadatapald0dat = { "data/pald-0.dat\0",&PALD0DAT_BEGIN_BUFFER,NULL,NULL,NULL };
#define psxadatapald0dat 26
//zero
#define psxazero7 27
Pathstruct xawscreen = { "*WScreen\0",&WSCREEN_BEGIN_BUFFER,&WSCREEN_END_BUFFER,0x04b100,NULL };
#define psxawscreen 28
Pathstruct xabscreen2 = { "*BScreen\0",&BSCREEN2_BEGIN_BUFFER,&BSCREEN2_END_BUFFER,0x011508,NULL };
#define psxabscreen2 29

Pathstruct xadatapald0dat2 = { "data/pald-0.dat\0",&PALD0DAT2_BEGIN_BUFFER,NULL,NULL,NULL };
#define psxadatapald0dat2 30
//zero
#define psxazero8 31
Pathstruct xadatamsprd00dat = { "data/msprd0-0.dat\0",&MSPRD00DAT_BEGIN_BUFFER,NULL,NULL,NULL };
#define psxadatamsprd00dat 32
Pathstruct xadatamsprd00tab = { "data/msprd0-0.tab\0",&MSPRD00TAB_BEGIN_BUFFER,&MSPRD00TAB_END_BUFFER,NULL,NULL };
#define psxadatamsprd00tab 33
//zero
#define psxazero9 34
Pathstruct xadatahsprd00dat = { "data/hsprd0-0.dat\0",&HSPRD00DAT_BEGIN_BUFFER,NULL,NULL,NULL };
#define psxadatahsprd00dat 35
Pathstruct xadatahsprd00tab = { "data/hsprd0-0.tab\0",&HSPRD00TAB_BEGIN_BUFFER,&HSPRD00TAB_END_BUFFER,NULL,NULL };
#define psxadatahsprd00tab 36
Pathstruct xadatahfont3dat = { "data/hfont3.dat\0",&HFONT3DAT_BEGIN_BUFFER,NULL,NULL,NULL };
#define psxadatahfont3dat 37
Pathstruct xadatahfont3tab = { "data/hfont3.tab\0",&HFONT3TAB_BEGIN_BUFFER,&HFONT3TAB_END_BUFFER,NULL,NULL };
#define psxadatahfont3tab 38
//zero
#define psxazero10 39
Pathstruct xadataclrd0dat = { "data/clrd-0.dat\0",&CLRD0DAT_BEGIN_BUFFER,NULL,NULL,NULL };
#define psxadatahfont3tab 40
//zero
#define psxazero11 41
Pathstruct xadataspellsdat = { "data/spells.dat\0",&SPELLS_BEGIN_BUFFER,NULL,NULL,NULL };
#define psxadatahfont3tab 42
//zero
#define psxazero12 43
Pathstruct xadatalang = { "",&x_DWORD_D41BC_langbuffer,&LANG_BEGIN_BUFFER,NULL,NULL };
#define psxadatahfont3tab 44
//zero
#define psxazero13 45
Pathstruct xadatatables = { "",&x_DWORD_D41BC_langbuffer,&LANG_BEGIN_BUFFER,NULL,NULL };
#define psxadatahfont3tab 46
//zero
#define psxazero14 47

Pathstruct pstr[100] = { xasearchd ,//00
xafonts0dat,//01
xafonts0tab,//02
xafonts1dat,//03
xafonts1tab,//04
xadatatmaps00tab,//05
xapaldata,//06
xapalmem,//07
xadatapointersdat,//08
xadatapointerstab,//09
xazero,//10
xadatabuild00dat,//11
xadatabuild00tab,//12
xazero,//13
xadataetextdat,//14
xazero,//15
xadataftextdat,//16
xazero,//05
xadatagtextdat,//17
xazero,//18
xadataitextdat,//19
xazero,//20
xadatablock16dat,//21
xadatablock32dat,//22
xazero,//23
xabscreen,//24
xadatapald0dat,//25
xazero,//26
xawscreen,//27
xabscreen2,//28
xadatapald0dat2,//29
xazero,//30
xadatamsprd00dat,//31
xadatamsprd00tab,//32
xazero,//33
xadatahsprd00dat,//34
xadatahsprd00tab,//35
xadatahfont3dat,//36
xadatahfont3tab,//37
xazero,//38
xadataclrd0dat,//39
xazero,//40
xadataspellsdat,//41
xazero };//42

/*typedef struct {
	Bit8u* pointer;
	Bit32u size;
} SpriteStr;*/



x_DWORD loc_1B2E6;
x_DWORD loc_55CB2;
x_DWORD loc_5B1BA;
x_DWORD loc_A4459;
x_DWORD loc_608FD;
x_DWORD loc_75779;
x_DWORD loc_79404;
x_DWORD loc_79463;
x_DWORD loc_88FD9;
x_DWORD loc_9B94B;
x_DWORD unk_17A6E8;
x_DWORD unk_D5621;
x_DWORD unk_140186;
x_DWORD unk_160001;
x_DWORD unk_110003;
x_DWORD loc_B0004;
x_DWORD unk_160010;
x_DWORD unk_160015;
x_DWORD unk_160018;
x_DWORD unk_16001B;
x_DWORD unk_160026;
x_DWORD unk_160029;
x_DWORD unk_16002A;
x_DWORD unk_16002C;
x_DWORD loc_5002E;
x_DWORD unk_11002F;
//int x_DWORD_EB394;
//int x_DWORD_EA3DC;
//Bit32s x_DWORD_EA3E0_copyto_x_DWORD_EA3E0[1001];//fix it
//x_DWORD unk_E9B2C;
//int x_DWORD_EA3BC;
x_DWORD unk_E1328;
x_DWORD unk_FFFFA;
x_WORD __CS__;
x_WORD __GS__;
x_WORD __DS__;
x_DWORD _EAX;
x_DWORD _EBX;
x_DWORD _ECX;
x_DWORD _EDX;
x_WORD __FS__;
x_WORD __ES__;
x_WORD __SS__;
x_WORD _CF;
x_WORD _ZF;
x_WORD _SF;
x_DWORD _EBP;
Bit16s x_WORD_E3760_mousex;
Bit16s x_WORD_E3762_mousey;

const char* dword_E4CC4[7] = { "PATH=Z:\\",
"COMSPEC=Z:\\COMMAND.COM",
"PROMPT=$P$G",
"BLASTER=A220 I7 D1 H5 T6",
"AIL_DEBUG=sound.dbg",//debug
"AIL_SYS_DEBUG=soundd.dbg",//debug
NULL };



long unknown_libname_2_findfirst(char*, Bit16u, _finddata_t* c_file);// weak
long unknown_libname_3_findnext(_finddata_t* c_file, long hFile);// weak
int unknown_libname_4_find_close(_finddata_t* c_file, long hFile);// weak
x_DWORD _GETDS;
unsigned char MEMORY[0x1000000];

Bit8u loc_A0000_vga_buffer[307200];

void stub_fix_it() {};
int sub_5FA96() { stub_fix_it();return 0; };
int sub_5FBB1() { stub_fix_it();return 0; };
int sub_5FB09() { stub_fix_it();return 0; };
int sub_5FB22() { stub_fix_it();return 0; };
int sub_5FB3A() { stub_fix_it();return 0; };
int sub_5FB8C() { stub_fix_it();return 0; };
int sub_AEF40() { stub_fix_it();return 0; };
int sub_AEF51() { stub_fix_it();return 0; };
int sub_AFB7E() { stub_fix_it();return 0; };
int sub_AFB9F() { stub_fix_it();return 0; };
//int loc_A0000_vga_buffer() { stub_fix_it();return 0; };
int sub_B1EB6() { stub_fix_it();return 0; };
int sub_B1EBC() { stub_fix_it();return 0; };
int sub_B1EC2() { stub_fix_it();return 0; };
int sub_B1EC8() { stub_fix_it();return 0; };
int sub_B1F78() { stub_fix_it();return 0; };
int sub_B1ED6() { stub_fix_it();return 0; };
int sub_B1EDC() { stub_fix_it();return 0; };
int sub_B1EE2() { stub_fix_it();return 0; };
int sub_B1EE8() { stub_fix_it();return 0; };
int sub_B1EF0() { stub_fix_it();return 0; };
int sub_B1EF8() { stub_fix_it();return 0; };
int sub_B1F00() { stub_fix_it();return 0; };
int sub_B1F12() { stub_fix_it();return 0; };
int sub_B1F1C() { stub_fix_it();return 0; };
int sub_B1F24() { stub_fix_it();return 0; };
int sub_B1F2C() { stub_fix_it();return 0; };
int sub_B1F35() { stub_fix_it();return 0; };
int sub_B1F3E() { stub_fix_it();return 0; };
int sub_B1F47() { stub_fix_it();return 0; };
int sub_B1F5B() { stub_fix_it();return 0; };
int sub_B1F66() { stub_fix_it();return 0; };
int sub_B1F6F() { stub_fix_it();return 0; };
int sub_B1ECE() { stub_fix_it();return 0; };
int sub_B1F08() { stub_fix_it();return 0; };
int sub_B1F50() { stub_fix_it();return 0; };
int sub_B1FB5() { stub_fix_it();return 0; };
int sub_B20A7() { stub_fix_it();return 0; };
int sub_B2183() { stub_fix_it();return 0; };
int sub_B2275() { stub_fix_it();return 0; };
int sub_B230F() { stub_fix_it();return 0; };
int sub_B2468() { stub_fix_it();return 0; };
int sub_B256E() { stub_fix_it();return 0; };
int sub_B2670() { stub_fix_it();return 0; };
int sub_B1FD4() { stub_fix_it();return 0; };
int sub_B278C(short a, short b, int c, int d, int e, int f, int g, int h, int i, int j, int k, int l, int m, int n, short o) { stub_fix_it();return 0; };
int _null_int23_exit() { stub_fix_it();return 0; };
int x_free(void* ptr) { free(ptr);return 0; };
//int malloc(x_DWORD size) { stub_fix_it();return 0; };
void sub_A0EEC_s_plus2();

void sub_9BA00() { stub_fix_it(); };
int nullsub_3(x_DWORD number) { stub_fix_it();return 0; };
int _no_support_loaded(x_DWORD number1, x_DWORD number2) { stub_fix_it();return 0; };



struct space_info
{
	// all values are byte counts
	unsigned long capacity;
	unsigned long free;      // <= capacity
	unsigned long available; // <= free
};
//BOOST_FILESYSTEM_DECL
space_info space(char* path, int* ec)
{
#   ifdef BOOST_POSIX_API
	struct BOOST_STATVFS vfs;
	space_info info;
	if (!error(::BOOST_STATVFS(path, &vfs) ? BOOST_ERRNO : 0,
		p, ec, "boost::filesystem::space"))
	{
		info.capacity
			= static_cast<boost::uintmax_t>(vfs.f_blocks)* BOOST_STATVFS_F_FRSIZE;
		info.free
			= static_cast<boost::uintmax_t>(vfs.f_bfree)* BOOST_STATVFS_F_FRSIZE;
		info.available
			= static_cast<boost::uintmax_t>(vfs.f_bavail)* BOOST_STATVFS_F_FRSIZE;
	}

#   else
	ULARGE_INTEGER avail, total, free;
	space_info info;

	//std::string charstring = "hello, world";

	std::wstring widestring;

	for (int i = 0; i < strlen(path); i++)
		widestring += (wchar_t)path[i];

	LPCWSTR lpcwpath = widestring.c_str();


	if (GetDiskFreeSpaceExW(lpcwpath, &avail, &total, &free) != 0)
	{
		info.capacity
			= ((total.HighPart) << 32)
			+ total.LowPart;
		info.free
			= ((free.HighPart) << 32)
			+ free.LowPart;
		info.available
			= ((avail.HighPart) << 32)
			+ avail.LowPart;
	}

#   endif

	else
	{
		info.capacity = info.free = info.available = 0;
	}
	return info;
}

unsigned __int64 dos_getdiskfree(__int16 a1, __int16 a2, Bit8u a, short* b) {
	unsigned long wanted_size = 0;//fix it
	char drivename[10];
	sprintf(drivename, "%c:", (Bit8u)(a + 64));
	int ec;
	space_info myspaceinfo = space(drivename, &ec);
	if (ec)
		if (myspaceinfo.free > wanted_size)return 0;
		else return 1;
	else return 1;
	/*
	if ( (_WORD)b == -1 )
	return _set_EINVAL(b, a3);
	a4[0] = a;
	a4[1] = a2;
	a4[2] = b;
	a4[3] = a1;
	*/
};


//-------------------------------------------------------------------------

char x_BYTE_E4CB2 = '\0'; // weak
// Function declarations -weak
int /*__noreturn*/ sub_10000() { stub_fix_it();return 0; }; // weak
void sub_9A1B6(int a1, void *a2, void *a3)
{
	if (x_BYTE_E4CB2 == 9)
	{
		//__asm { int     21h; DOS - GET DISK TRANSFER AREA ADDRESS }
		qmemcpy(a2, a3, 0x2Bu);
	}
}

long unknown_libname_2_findfirst(char* path, Bit16u a2, _finddata_t* c_file) {//findfirst
	long hFile;
	//char path2[2048] = "\0";
	//pathfix(path, path2);//only for DOSBOX version

	//struct _finddata_t c_file;
	if ((hFile = my_findfirst(path, c_file)) == -1L)
		return(-1);//file not found
	//strcmp(filename, c_file.name);
	return(hFile);
	/*
if ((hFile = _findfirst(path2, &c_file)) == -1L)
	printf("file not found");
else
{
	do
	{
		printf("%s\n", c_file.name);
	} while (_findnext(hFile, &c_file) == 0);
		_findclose(hFile);
}
return 0;*/
/*char* v3; // eax //language/l.txt

//ecx dfc628 c3cd34c3cd35c3cd36
//eax //language/l.txt
//edx 78651a 0b0005a1a1a1a10005a1b413aaa100
//mov edx,ebx

int result; // eax

v3 = a1;
//__asm { int     21h; DOS - SET DISK TRANSFER AREA ADDRESS }// fix it
BYTE1(v3) = 78;
//__asm { int     21h; DOS - 2 + -FIND FIRST ASCIZ(FINDFIRST) }// fix it
result = 0;//_doserror(v3, a1); // fix it
sub_9A1B6(result, (void*)a3, (void*)a3);
return result;*/
};// weak
long unknown_libname_3_findnext(_finddata_t* c_file, long hFile) {//258193
	//char path[100];//fix
	//char filename[100];//fix it

	/*char path2[2048] = "\0";
	pathfix(path, path2);//only for DOSBOX version
	*/
	//struct _finddata_t c_file;
	//long hFile;
	if ((hFile = my_findnext(hFile, c_file)) == -1L)
	{
		return(-1);//file not found
	}
	//strcmp(filename, c_file.name);
	//_findclose(hFile);
	return(hFile);
	/*

	if ((hFile = _findfirst(path2, &c_file)) == -1L)
	printf("file not found");
	else
	{
	do
	{
	printf("%s\n", c_file.name);
	} while (_findnext(hFile, &c_file) == 0);
	_findclose(hFile);
	}

	*/
	/*int v2; // eax
	int v3; // eax
	int v4; // edx
	int result; // eax
	void *v6; // edx

	v2 = a2;
	BYTE1(v2) = 26;
	__asm { int     21h; DOS - SET DISK TRANSFER AREA ADDRESS }
	v3 = sub_9A1D9(v2, a2);
	BYTE1(v3) = 79;
	__asm { int     21h; DOS - 2 + -FIND NEXT ASCIZ(FINDNEXT) }
	result = _doserror(v3, v4);
	sub_9A1B6(result, v6, a1);
	return result;*/
	return 0;
};// weak
int unknown_libname_4_find_close(struct _finddata_t *c_file, long hFile) {//27b1b3
	my_findclose(hFile);
	return 0;
};// weak
int _wcpp_1_unwind_leave__120(x_DWORD a, x_DWORD b, x_DWORD c) { stub_fix_it();return 0; };// weak
void JUMPOUT(int* adr) { stub_fix_it(); };
void JUMPOUT(x_WORD cs, int* adr) { stub_fix_it(); };
void JUMPOUT(x_WORD cs, int a, int* adr) { stub_fix_it(); };
void qmemcpy(void* a, void* b, size_t c) {
	memcpy(a, b, c);
};
int _wcpp_1_unwind_leave__62(void) { stub_fix_it();return 0; }; //weak
//void __outx_WORD(unsigned short Port, unsigned short Data) { stub_fix_it(); };
//void __outx_BYTE(unsigned short Port, unsigned char Data) { stub_fix_it(); };
unsigned char __inx_BYTE(unsigned short Port) { stub_fix_it();return 0; };
char x_toupper(char inputchar) {
	return toupper(inputchar);
}; //weak
long x_filelength(FILE* decriptor) {
	long size;
	myfseek(decriptor, 0, SEEK_END); // seek to end of file
	size = myftell(decriptor); // get current file pointer
	myfseek(decriptor, 0, SEEK_SET); // seek back to beginning of file
	return size;
};

void gotoxy(int x, int y) //positions text cursor at (x, y) screen position 
{
	VGA_GotoXY(x, y);
	/*CONSOLE_SCREEN_BUFFER_INFO csbiInfo; //variable declarations
	HANDLE hConsoleOut;
	hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE);
	GetConsoleScreenBufferInfo(hConsoleOut,&csbiInfo);
	csbiInfo.dwCursorPosition.X = x; //cursor position X coordinate
	csbiInfo.dwCursorPosition.Y = y; //cursor position Y coordinate
	SetConsoleCursorPosition(hConsoleOut,csbiInfo.dwCursorPosition); //set cursor at the given screen coordinate */
}
/*-------------------------wherex()------------------------------------*/
int wherex() //returns current text cursor (x) coordinate 
{
	return VGA_WhereX();
	/*CONSOLE_SCREEN_BUFFER_INFO csbiInfo;
	GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbiInfo);
	return csbiInfo.dwCursorPosition.X;*/
}
/*-------------------------wherey()----------------------------------*/
int wherey() //returns current text cursor (y) coordinate 
{
	return VGA_WhereY();
	/*CONSOLE_SCREEN_BUFFER_INFO csbiInfo;
	GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbiInfo);
	return csbiInfo.dwCursorPosition.Y;*/
}


x_DWORD settextposition(x_DWORD x, x_DWORD y) {
	gotoxy(x, y);
	//printf("\033[%d;%dH%s\n", x, y, "R");
	/*#ifndef USE_DOSBOX
		COORD coord;
		coord.X = x;
		coord.Y = y;

		// Obtain a handle to the console screen buffer.
		// (You're just using the standard console, so you can use STD_OUTPUT_HANDLE
		// in conjunction with the GetStdHandle() to retrieve the handle.)
		// Note that because it is a standard handle, we don't need to close it.
		HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);

		// Finally, call the SetConsoleCursorPosition function.
		if (!SetConsoleCursorPosition(hConsole, coord))
		{
			// Uh-oh! The function call failed, so you need to handle the error.
			// You can call GetLastError() to get a more specific error code.
			// ...
			return 1;
		}
	#endif*/
	return 0;
};// weak
x_DWORD outtext(char* text) { myWriteOut(text);return 0; };// weak
//x_DWORD int386(x_DWORD, x_DWORD, x_DWORD) { stub_fix_it();return 0; };// weak
int int386(int intno, REGS *inregs, REGS *outregs)
{
	struct SREGS    segregs;

	segread(&segregs);//160:0027ADE6
	return(int386x(intno, inregs, outregs, &segregs));
}
POSITION gettextposition(/*x_DWORD, x_DWORD, x_DWORD*/) {
	return VGA_WhereXY();
};// weak
x_DWORD signal(x_DWORD, x_DWORD) { stub_fix_it();return 0; };// weak
//x_DWORD unknown_libname_1_atoi(x_DWORD) { stub_fix_it();return 0; };// weak
/*int __cdecl unknown_libname_1_atoi(char *a1)
{
	char *i; // eax
	char v2; // cl
	int v3; // ebx
	int v4; // ebx

	for (i = a1; IsTable[(unsigned __int8)(*i + 1)] & 2; ++i)
		;
	v2 = *i;
	if (*i == '+' || v2 == '-')
		++i;
	v3 = 0;
	while (IsTable[(unsigned __int8)(*i + 1)] & 0x20)
	{
		v4 = (unsigned __int8)*i++ + 10 * v3;
		v3 = v4 - 48;
	}
	if (v2 == '-')
		v3 = -v3;
	return v3;
}*/
void _disable() { stub_fix_it(); };
void _enable() { stub_fix_it(); };
int /*__fastcall*/ _wcpp_1_unwind_leave__93(x_DWORD, x_DWORD, x_DWORD, x_DWORD, x_DWORD, x_DWORD) { stub_fix_it();return 0; };// weak
int _wcpp_1_unwind_leave__100(x_DWORD, x_DWORD) { stub_fix_it();return 0; };// weak
long x_InterlockedExchange(long volatile * Target, long Value) { stub_fix_it();return 0; };
int _wcpp_1_unwind_leave__98(x_DWORD) { stub_fix_it();return 0; };// weak
x_DWORD dos_getvect(x_DWORD) { stub_fix_it();return 0; };// weak
x_DWORD dos_setvect(x_DWORD, x_DWORD, x_DWORD) { stub_fix_it();return 0; };// weak
int /*__fastcall*/ _wcpp_1_unwind_leave__130(x_DWORD) { stub_fix_it();return 0; };// weak
unsigned char x_BitScanReverse(unsigned long * Index, unsigned long Mask) { stub_fix_it();return 0; };

x_DWORD segread(SREGS* a1) {
	int result; // eax
	a1->cs = __CS__;
	//a1[1] = __CS__;
	a1->ds = __DS__;
	//a1[3] = __DS__;
	a1->es = __ES__;
	//*a1 = __ES__;
	a1->ss = __SS__;
	//a1[2] = __SS__;
	a1->fs = __FS__;
	//a1[4] = __FS__;
	result = __GS__;
	a1->gs = __GS__;
	//a1[5] = __GS__;
	return result;
}; //weak

//Bit8u** pointersdat_buffer; // ebx

//x_DWORD int386x(x_DWORD, x_DWORD, x_DWORD, x_DWORD) { stub_fix_it();return 0; };// weak
uint32 sub_AB59E(SREGS* a1, REGS* a2, int intvar)
{
	uint32 v2; // bp
	uint32 result; // eax
	uint32 v4; // ebx
	uint32 v5; // ecx
	uint32 v6; // edx
	uint32 v7; // esi
	uint32 v8; // edi

	// fix it:__ES__ = *a1;
	v2 = a1->gs;
	result = a2->eax;
	v4 = a2->ebx;
	v5 = a2->ecx;
	v6 = a2->edx;
	v7 = a2->edi;
	v8 = a2->eax;
	//esi je typ 21
	return result;
}
int _int386x(REGS* a1, SREGS* a2, REGS* a3, int a4) {
	REGS* v4; // ST00_4
	REGS* v5; // edi
	uint32 v6; // ecx
	uint32 v7; // edx
	unsigned __int8 v8; // cf
	int result; // eax
	SREGS v10; // [esp-8h] [ebp-Ch]

	//fix it
	v6 = 0;
	v7 = 0;
	v8 = 0;

	//fix it

	v4 = a3;
	v5 = a1;
	a1->eax = sub_AB59E(a2, a3, a4);
	v5->ebx = a2->cs;
	v5->ecx = v6;
	v5->edx = v7;
	v5->esi = a4;
	v5->edi = v4->eax;
	v5->cflag = v8;
	result = (unsigned __int16)__DS__;
	v10.ds = __DS__;
	v10.es = __ES__;
	return result;
};
int int386x(int a2, REGS* a3, REGS* a4, struct SREGS* a5) {
	_int386x(a4, a5, a3, a2);
	return *(x_DWORD *)a4;
};
unsigned char __readgsx_BYTE(unsigned long Offset) { stub_fix_it();return 0; };
unsigned short __readgsx_WORD(unsigned long Offset) { stub_fix_it();return 0; };
void /*__fastcall*/ _wcpp_1_unwind_leave__131() {//257d00
	stub_fix_it();
};// weak
unsigned     int x__readeflags(void) { stub_fix_it();return 0; };
void x__writeeflags(unsigned Value) { stub_fix_it(); };
x_DWORD gets(x_DWORD) { stub_fix_it();return 0; };// weak
//x_DWORD tell(x_DWORD) { stub_fix_it();return 0; };// weak
void* x_expand(void* memblock, size_t size) {
	return realloc(memblock, size * sizeof(Bit8u));
};
int /*__fastcall*/ _wcpp_1_unwind_leave__132(x_DWORD) { stub_fix_it();return 0; };// weak
double /*__fastcall*/ _CHP(x_DWORD) { stub_fix_it();return 0; };// weak
size_t x_read(FILE* descriptor, Bit8u* data, Bit32u size) {
	size_t result = fread(data, 1, size, descriptor);
	return result;
};
double IF_DPOW(double, double) { stub_fix_it();return 0; };// weak
x_DWORD x_dos_setdrive(Bit32s a, Bit32s* b) {
	*b = 0x1a;
	return 0;
};// weak
x_DWORD x_outp(x_DWORD, char) { stub_fix_it();return 0; };// weak
x_DWORD x_inp(x_DWORD) { stub_fix_it();return 0; };// weak
FILE* x_creat(char* path, Bit32u flags) {
	return mycreate(path, flags);
	/*FILE *fp;
	char path2[512] = "\0";
	pathfix(path, path2);//only for DOSBOX version
	fp = fopen(path2, "wb+");
	return fp;*/
};// weak

x_DWORD x_setmode(FILE* path, int mode) { stub_fix_it();return 0; };// weak
FILE* x_sopen(char* path, int pmode, Bit32u flags) {
	return myopen(path, pmode, flags);
};
int x_close(FILE* descriptor) {
	return myclose(descriptor);
};
x_DWORD x_lseek(FILE* filedesc, x_DWORD position, char type) {
	return mylseek(filedesc, position, type);
};
unsigned __CFRCR__(__int16 a, unsigned __int8 b) { stub_fix_it();return 0; };
unsigned __CFRCL__(__int16 a, unsigned __int8 b) { stub_fix_it();return 0; };
size_t x_write(FILE* descriptor, Bit8u* buffer, Bit32u size_t) {
	return fwrite(buffer, 1, size_t, descriptor);
};// weak
x_DWORD x_tolower(x_DWORD) { stub_fix_it();return 0; };// weak
FILE* x_open(char* path, int pmodex) {
	return myopent(path, (char*)"rb");
};
void __writegsx_WORD(unsigned long Offset, unsigned short Data) { stub_fix_it(); };
void __writegsx_DWORD(unsigned long Offset, unsigned long Data) { stub_fix_it(); };
x_DWORD dos_read(FILE*, char, x_DWORD, x_DWORD, x_DWORD) { stub_fix_it();return 0; };// weak
unsigned long __readgsx_DWORD(unsigned long Offset) { stub_fix_it();return 0; };
void __inx_BYTEstring(unsigned short Port, unsigned char* Buffer, unsigned long Count) { stub_fix_it(); };
int* MK_FP(unsigned int segment, unsigned int offset) { stub_fix_it();return 0; };
unsigned int x__getcallerseflags(void) { stub_fix_it();return 0; };
int /*__fastcall*/ _hook387(x_DWORD, x_DWORD, x_DWORD) { stub_fix_it();return 0; };// weak
void x__sidt(void *Destination) { stub_fix_it(); };
unsigned long x__readcr0(void) { stub_fix_it();return 0; };
void x__writecr0(unsigned __int32 Data) { stub_fix_it(); };
int _FDFS(void) { stub_fix_it();return 0; };// weak
int _sigfpe_handler() { stub_fix_it();return 0; };// weak
int _DOS4G_hook_init(void) { stub_fix_it();return 0; };// weak
int _Phar_hook_init(void) { stub_fix_it();return 0; };// weak
int _Ergo_hook_init(x_DWORD, x_DWORD) { stub_fix_it();return 0; };// weak
int _Intel_hook_init(void) { stub_fix_it();return 0; };// weak
int _DOS4G_hook_fini(void) { stub_fix_it();return 0; };// weak
int _Intel_hook_fini(void) { stub_fix_it();return 0; };// weak
int _Phar_hook_fini(void) { stub_fix_it();return 0; };// weak
int _Ergo_hook_fini(x_DWORD) { stub_fix_it();return 0; };// weak

int _nmemneed(x_DWORD) { stub_fix_it();return 0; };// weak
int _nmemneed_0(x_DWORD) { stub_fix_it();return 0; };// weak
int /*__fastcall*/ nullsub_1(x_DWORD) { stub_fix_it();return 0; }; // weak
int sub_365F8() { stub_fix_it();return 0; }; // weak
int sub_48930() { stub_fix_it();return 0; }; // weak
int _wcpp_1_unwind_leave__99(x_DWORD) { stub_fix_it();return 0; };// weak
int sub_6FD30() { stub_fix_it();return 0; }; // weak
int sub_752C0() { stub_fix_it();return 0; }; // weak
int sub_76F40() { stub_fix_it();return 0; }; // weak
int sub_8E0D0() { stub_fix_it();return 0; }; // weak
void sub_8F4B0(HMDIDRIVER user) { stub_fix_it(); }; // weak
int dword_1820E0 = 0;
long clock_value()
{
	return mygethundredths();
	//return clock()*0.1;
	/*
	int v1; // [esp+0h] [ebp-1Ch]
	char v2; // [esp+1h] [ebp-1Bh]
	unsigned __int8 v3; // [esp+8h] [ebp-14h]//hour
	unsigned __int8 v4; // [esp+9h] [ebp-13h]//minutes
	unsigned __int8 v5; // [esp+Ch] [ebp-10h]//hundredths
	unsigned __int8 v6; // [esp+Dh] [ebp-Fh]//seconds
	// fix it
	v6=0;
	v4=0;
	v5=0;
	v3=0;
	// fix it
	v2 = 44;
	//intdos(&v1, &v1); //fix it
	return 100 * (v6 + 60 * (60 * v4 + v3)) + v5;*/
}
long _clock()
{
	return clock_value();
	/*unsigned int v0; // eax

	v0 = clock_value();
	if (v0 < dword_1820E0)
		v0 += 8640000;
	return v0 - dword_1820E0;*/
}
long /*__fastcall*/ j___clock() {
	return _clock();
}; // weak
void sub_99830(HMDIDRIVER user) { stub_fix_it(); }; // weak
x_DWORD j___delay(x_DWORD x) { mydelay(x);return 0; }; // weak
int /*__fastcall*/ j_j___clock(x_DWORD, x_DWORD, x_DWORD) { stub_fix_it();return 0; }; // weak
int x_DWORD_E3E38 = 0; // weak
int x_DWORD_181DA8; // weak
unsigned int sub_91F20();
Bit32s sub_91F70_AIL_call_driver(AIL_DRIVER* drvr, Bit32s fn, VDI_CALL* in, VDI_CALL* out);//AIL_call_driver
void sub_91F50(unsigned int a1);
void sub_9E250(HMDIDRIVER mdidrv) {
	if (!x_DWORD_E3E38)
	{
		x_DWORD_E3E38 = 1;
		x_DWORD_181DA8 = sub_91F20();
		sub_91F70_AIL_call_driver(mdidrv->drvr_0, 770, 0, 0);
		sub_91F50(x_DWORD_181DA8);
		x_DWORD_E3E38 = 0;
	}
}; // weak
void sub_A2450(HMDIDRIVER user) { stub_fix_it(); }; // weak
int sub_A2DE0() { stub_fix_it();return 0; }; // weak
int sub_A47A0() { stub_fix_it();return 0; }; // weak
int sub_A4920() { stub_fix_it();return 0; }; // weak
//void sub_A6530(Bit32u user) { stub_fix_it();}; // weak
int sub_A9C00() { stub_fix_it();return 0; }; // weak
int sub_A9C50() { stub_fix_it();return 0; }; // weak
void sub_A6F30(void* a/*HDIGDRIVER a*/) { stub_fix_it();/*return 0; */ }; // weak
int sub_B1DC8() { stub_fix_it();return 0; }; // weak
int sub_B46F0() { stub_fix_it();return 0; }; // weak
int /*__far*/ sub_C0000() { stub_fix_it();return 0; }; // weak





//char sounddir[512];



// Function declarations
/*void __noreturn sub_10000(); // weak*/
signed __int16 sub_10010();
unsigned int sub_10080(int a1, int a2);
void sub_10100(int a1);
signed int sub_10130(int a1, x_DWORD *a2, x_DWORD *a3);
void sub_101C0();
int sub_102D0(int a1, __int16 *a2, char a3);
signed int sub_104A0(int a1);
int(*sub_104D0(signed __int16 *a1))();
int(*sub_10590(char a1))();
bool sub_10630(x_WORD *a1, signed __int16 *a2, x_WORD *a3, signed __int16 *a4);
bool sub_106C0(int a1, int a2);
bool sub_106F0(x_WORD *a1, int a2, x_WORD *a3, int a4);
bool sub_10750(int a1, int a2);
int sub_10780(int a1);
int sub_108B0(int a1);
int sub_10A50(int a1);
signed int sub_10B70(unsigned __int16 *a1, char a2, char a3);
int sub_10C40(__int16 *a1);
int sub_10C60(__int16 *a1);
int sub_10C80(int a1, unsigned __int8 a2, unsigned __int16 a3);
int sub_112D0(int a1, unsigned __int16 a2);
char sub_11400(int a1, char a2, unsigned __int16 a3);
int sub_116A0(int a1, char a2, unsigned __int16 a3);
int sub_11900(int a1, int a2, unsigned __int8 a3, unsigned __int16 a4);
unsigned int sub_11960(x_WORD *a1);
char sub_11A10(x_WORD *a1);
char sub_11C80(unsigned __int16 a1);
bool sub_11CB0(__int16 *a1);
bool sub_11E20(int a1, __int16 *a2);
bool sub_11E70(int a1, __int16 *a2);
signed int sub_11EE0(Bit8u* a1);
__int16 sub_12100(int a1, int a2, char a3);
int sub_122A0(int a1);
char *sub_122C0(__int16 a1);
int sub_12330(int a1, __int16 a2);
char sub_12410(int a1, char a2);
int sub_12470(int a1, char a2);
char sub_12500(int a1);
char *sub_12780();
char *sub_12870();
signed int sub_12910(unsigned int a1);
signed int sub_12A70(unsigned int a1);
signed int sub_12E70(int a1);
signed int sub_12FF0(int a1);
int _nmemneed(x_DWORD);// weak
signed int sub_13100(int a1);
signed int sub_131F0(x_WORD *a1);
signed int sub_13270(int a1);
signed int sub_133B0(int a1);
int _nmemneed_0(x_DWORD);// weak
signed int sub_135C0(int a1);
signed int sub_13710(int a1);
signed int sub_13830(int a1);
signed int sub_13850(int a1);
int sub_13870(int a1);
int /*__fastcall*/ nullsub_1(x_DWORD); // weak
signed int sub_13890(int a1);
signed int sub_13B00(int a1);
signed int sub_13C50(int a1);
unsigned int sub_13CE0(int a1);
signed int sub_13DC0(int a1);
signed int sub_13E40(int a1);
signed int sub_14030(int a1);
signed int sub_14250(int a1);
signed int sub_14530(int a1);
signed int sub_14630(int a1);
unsigned int sub_146C0(int a1, unsigned __int8 a2);
signed int sub_146F0(int a1);
unsigned int sub_148E0(int a1);
unsigned int sub_14B10(int a1, unsigned __int8 a2);
unsigned int sub_14BD0(int a1, int a2);
__int16 sub_14C40(int a1);
bool sub_14C60(int a1, int a2);
signed int sub_14C90(int a1, int a2, signed int a3, signed int a4);
signed int sub_14E10(int a1, unsigned __int8 a2);
unsigned int sub_15170(int a1, unsigned __int8 a2);
signed int sub_155E0(int a1);
bool sub_156F0(int a1, unsigned __int8 a2);
bool sub_15730(int a1, unsigned __int8 a2);
unsigned int sub_15760(int a1, unsigned __int8 a2);
char sub_15790(int a1);
char sub_15910(x_DWORD *a1);
void sub_159E0();
// unsigned int sub_15CB0(unsigned int a1, int a2);
int sub_15D20(int a1);
// char sub_15D40(__int16 a1, int a2, int a3);
bool sub_15E60(int a1);
char sub_15EE0();
signed int sub_15F20(int a1, signed __int16 a2, signed int a3);
signed int sub_15FC0(x_WORD *a1);
signed int sub_161A0(int a1);
bool sub_164B0(int a1);
signed int sub_16580(int a1);
// int sub_16730(int a1, int a2, char a3);
char sub_169C0(int a1);
// int sub_16CA0(int a1, int *a2, __int16 a3, char a4);
int sub_16E70(unsigned __int8 *a1, unsigned __int8 *a2);
unsigned int sub_16FC0(int a1, int a2);
__int16 sub_17060(__int16 a1, __int16 a2);
char sub_17190();
// char sub_17A00(x_BYTE *a1, signed int a2, __int16 a3);
int sub_18AA0();
char sub_18B30();
int sub_18BB0();
char sub_18DA0(int a1, char a2, char a3);
char sub_18F80(int a1);
char sub_191B0(__int16 a1, char a2);
int sub_19760(const char *a1, unsigned __int8 a2, __int16 a3);
int sub_197F0();
__int64 sub_19A50();
char sub_19A70();
__int64 sub_19AB0();
void sub_19CA0_sound_proc5(unsigned __int8 a1);
// int sub_19D60(signed int a1, int a2);
char sub_19E00();
int sub_1A030();
// void sub_1A070(signed int a1, __int16 a2);
int sub_1A280();
int sub_1A4A0();
int sub_1A5B0(int a1, int *a2, int *a3);
int sub_1A7A0();
int sub_1A8A0();
char sub_1A970(char a1, int a2, int a3);
void sub_1B280_draw_intro_text(Bit8u* a1);
int sub_1B5F0();
void sub_1B6B0(int a1);
int sub_1B7A0(signed __int16 *a1);
int sub_1B830(x_WORD *a1);
signed int sub_1B8C0(int a1);
signed int sub_1BD90(int a1, char a2);
void sub_1BF90(int a1, char a2);
signed int sub_1C310(int a1, char a2, unsigned __int16(*a3)(int, int));
char sub_1C560(int a1, unsigned __int16 a2);
int sub_1C890(int a1, char a2);
void sub_1C930(int a1);
int sub_1C980(int a1, char a2);
signed int sub_1CC20(x_WORD *a1, unsigned int a2);
signed int sub_1CCE0(x_WORD *a1, unsigned int a2);
signed int sub_1CDA0(x_WORD *a1, unsigned int a2);
signed int sub_1CE80(int a1, int a2);
signed int sub_1CED0(int a1, int a2);
signed int sub_1CF20(int a1, int a2);
signed int sub_1D0E0(x_WORD *a1, unsigned int a2);
signed int sub_1D1A0(x_WORD *a1, unsigned int a2);
signed int sub_1D260(int a1, unsigned int a2);
signed int sub_1D460(x_WORD *a1, int a2);
void sub_1D5D0(int a1, __int16 a2);
void sub_1D700(int a1, __int16 a2);
void sub_1D7C0(int a1, __int16 a2);
char sub_1D880(int a1, __int16 a2);
char sub_1D8A0(int a1, __int16 a2);
void sub_1D8C0(int a1, __int16 a2);
int sub_1DBF0(int a1, unsigned __int16 a2);
char sub_1DDA0(int a1, __int16 a2);
char sub_1E000(int a1, __int16 a2);
char sub_1E020(int a1, __int16 a2);
int sub_1E040(int a1, char a2);
char sub_1E1C0(int a1, __int16 a2);
void sub_1E320(int a1);
int sub_1E3E0(int a1);
int sub_1E4D0(int a1);
void sub_1E580(int a1, __int16 a2);
void sub_1E700(int a1, char a2);
void sub_1E9C0(int a1, __int16 a2);
int sub_1ED30(int a1, int a2);
signed int sub_1EEE0(int a1);
signed int sub_1EF20(int a1);
// int sub_1EF40(int a1, x_WORD *a2);
// int sub_1EF70(int a1, x_WORD *a2);
// int sub_1EFD0(int a1, x_WORD *a2);
int sub_1F000(int a1);
void sub_1F020(int a1);
int sub_1F040(x_WORD *a1);
// void sub_1F0C0(int a1, int a2);
// int sub_1F300(int a1, int a2);
void sub_1F340(int a1);
void sub_1F3C0(int a1);
void sub_1F440(int a1);
void sub_1F470(int a1);
int sub_1F4F0(int a1);
void sub_1F510(int a1);
void sub_1F530(int a1);
__int16 sub_1F5B0(int a1);
signed int sub_1F630(int a1);
void sub_1F660(int a1);
void sub_1F6D0(int a1);
char sub_1F800(int a1);
int sub_1F830(int a1);
void sub_1F850(int a1);
void sub_1F8A0(int a1);
signed int sub_1F950(int a1);
void sub_1F970(int a1);
void sub_1F990(int a1);
char sub_1F9E0(int a1);
int sub_1FA00(int a1);
void sub_1FA20(int a1);
void sub_1FA50(int a1);
char sub_1FA70(int a1);
char sub_1FAA0(int a1);
unsigned int sub_1FF40(int a1);
void sub_1FFE0(int a1);
void sub_20010(int a1);
void sub_20040(int a1);
char sub_20060(int a1);
x_WORD *sub_200F0(int a1);
void sub_20140(int a1);
int sub_20370(int a1);
void sub_203D0(int a1);
void sub_20940(int a1);
void sub_20C50(int a1);
char sub_20E50(int a1);
int sub_20E80(int a1);
void sub_20EA0(int a1);
char sub_20EC0(int a1);
int sub_20F20(int a1);
int sub_20F60(int a1);
int sub_20F80(int a1);
void sub_20FC0(int a1);
__int16 sub_21030(int a1);
char sub_21490(int a1);
void sub_21850(int a1);
void sub_21AB0(int a1);
char sub_21F60(int a1);
char sub_22190(int a1);
char sub_221F0(int a1, __int16 a2);
__int16 sub_22270(int a1);
__int16 sub_222B0(int a1);
unsigned int sub_223E0();
char sub_22490(unsigned __int16 *a1);
int sub_22530(int a1);
int sub_22540(int a1);
int sub_22550(int a1);
int sub_22560(int a1);
void sub_22580(int a1);
int sub_225A0(int a1);
int sub_225B0(int a1);
bool sub_22640(x_WORD *a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4);
x_WORD *sub_226D0(unsigned __int16 a1, x_WORD *a2, x_WORD *a3);
char sub_22760(int a1);
char sub_22C80(int a1);
char sub_22E60(int a1);
char sub_23020(int a1);
int sub_231E0(int a1);
void sub_23200(int a1);
__int16 sub_23260(int a1);
char sub_232A0(int a1);
char sub_232C0();
char sub_23320(int a1);
char sub_23340(int a1);
char sub_23640(int a1);
char sub_23660(int a1);
int sub_23680(int a1);
void sub_236F0(int a1);
__int16 sub_23710(int a1);
__int16 sub_23750(int a1);
char sub_23790(int a1);
char sub_237B0(int a1);
char sub_23AC0(int a1);
char sub_23AE0(int a1);
void sub_23B00(int a1);
void sub_23B30(int a1);
__int16 sub_23B90(int a1);
__int16 sub_23BD0(int a1);
signed int sub_23C20(int a1);
void sub_23C40(int a1);
void sub_23E60(int a1);
char sub_240A0(int a1);
int sub_240C0(int a1);
void sub_240E0(int a1);
int sub_24100(x_WORD *a1);
int sub_24150(x_WORD *a1);
signed int sub_24190(int a1);
void sub_24400(int a1);
signed int sub_24420(int a1);
void sub_24440(int a1);
__int16 sub_24510(int a1);
char sub_247D0(int a1);
int sub_247F0(int a1);
void sub_24810(int a1);
void sub_24840(int a1);
unsigned int sub_24860(int a1);
void sub_248C0(int a1);
__int16 sub_24930(int a1);
char sub_24D40(int a1);
int sub_24DA0(int a1);
void sub_24DC0(int a1);
void sub_24DF0(int a1);
int sub_24E20(int a1);
int sub_25050(int a1);
__int16 sub_250B0(int a1);
// int sub_25280(int a1, int a2);
int sub_252A0(int a1);
void sub_252C0(int a1);
unsigned int sub_252E0(int a1);
// int sub_253B0(int result, int a2, unsigned __int8 a3, unsigned __int8 a4);
int sub_254E0(int a1, int a2, unsigned __int8 a3);
int sub_25550(int a1);
signed int sub_25590(int a1);
void sub_255C0(int a1);
void sub_25610(int a1);
char sub_25CD0(int a1);
int sub_25D00(int a1);
void sub_25D20(int a1);
void sub_25D50(int a1);
unsigned int sub_25D80(int a1);
void sub_25DE0(int a1);
void sub_25E40(int a1);
char sub_25F70(int a1);
int sub_25FD0(int a1);
void sub_25FF0(int a1);
void sub_26020(int a1);
int sub_26050(int a1);
char sub_26070(int a1);
// unsigned int sub_26220(unsigned int a1, int a2);
int sub_263C0(int a1);
int sub_263E0(int a1);
void sub_26400(int a1);
int sub_26470(x_BYTE *a1);
// int sub_26500(int result, int a2);
int sub_265A0(int a1);
signed int sub_26830(int a1);
int sub_268F0(int a1, unsigned __int8 a2);
char sub_26930(int a1);
void sub_26960(int a1);
int sub_26990(int a1);
void sub_26AA0(int a1);
void sub_26BD0(int a1);
int sub_26CA0(int a1);
int sub_26CC0(int a1);
int sub_26D20(int a1);
int sub_26F10(int a1);
__int16 sub_26FF0(int a1);
int sub_27120(int a1);
signed int sub_271D0(int a1);
char sub_272C0(int a1);
int sub_273C0(__int16 a1, char a2, __int16 a3, __int16 a4);
int sub_27430(int a1);
int sub_27470(int a1, __int16 a2);
int sub_274C0(int a1, int a2, x_WORD *a3, __int16 a4);
// int sub_27590(signed int a1, int a2);
// int sub_27610(signed int a1, int a2);
signed int sub_276E0(signed int a1);
void sub_27720(int a1, signed __int16 a2);
void sub_27880(int a1);
int sub_278F0(int a1, __int16 a2, __int16 a3);
void sub_27930(int a1);
char sub_27950(int a1);
char sub_27B20(int a1);
char sub_27C10(int a1);
char sub_27E00(int a1);
int sub_27FA0(int a1);
void sub_27FC0(int a1);
int sub_27FE0(int a1, char a2, char a3, int a4);
unsigned int sub_28000(int a1);
char sub_28060(int a1);
char sub_28110(int a1);
unsigned int sub_282D0(int a1);
char sub_28390(x_WORD *a1, int a2);
int sub_28420(int a1);
void sub_28470(int a1);
int sub_28490(int a1);
int sub_28500(int a1);
int sub_28570(int a1);
signed int sub_285D0(int a1);
int sub_285F0(int a1);
void sub_28610(int a1);
int sub_28630(int a1);
int sub_28660(int a1);
void sub_28690(int a1);
int sub_287B0(int a1);
__int16 sub_28860(int a1);
int sub_28C30(int a1);
signed int sub_28C60(int a1);
int sub_28CC0(int a1);
int sub_28CE0(int a1);
void sub_28EC0(int a1);
void sub_28F50(int a1);
int sub_28F90(int a1);
int sub_28FC0(int a1);
int sub_28FF0(int a1);
int sub_29300(int a1);
int sub_29330(int a1);
void sub_29350(int a1);
int sub_29380(int a1);
int sub_293B0(int a1);
int sub_293D0(int a1);
__int16 sub_29400(int a1);
__int16 sub_29670(int a1);
__int16 sub_29710(int a1);
__int16 sub_29890(int a1);
int sub_298B0(int a1);
int sub_298D0(unsigned int a1);
__int16 sub_29930(int a1);
__int16 sub_29A90(int a1);
// char sub_2A340(int a1, int a2, int a3, int a4, int a5, int a6);
signed int sub_2A5B0(int a1, int a2, __int16 a3);
int sub_2A660(int a1, int a2);
signed int sub_2A6B0(int a1);
unsigned int sub_2A6F0(int a1);
int sub_2A7B0(int a1);
void sub_2A7F0(int a1, int a2, char a3);
signed int sub_2A940(signed int a1, int a2);
signed int sub_2A9F0(int a1, int a2);
// unsigned __int16 sub_2AA90(int a1, int a2, int a3);
x_WORD *sub_2AC50(int a1);
unsigned __int16 sub_2AD40(signed int a1);
int sub_2AE30(int a1);
void sub_2AE80(unsigned int a1);
char sub_2AED0(int a1, int a2);
char sub_2AF10(int a1, char a2);
signed int sub_2B1D0(int a1);
void sub_2B200(int a1);
char sub_2B260(int a1);
int sub_2B750(int a1);
int sub_2B760(int a1);
void sub_2B780(int a1);
void sub_2B7B0(int a1);
char sub_2B7E0(int a1);
int sub_2B840(int a1);
char sub_2B860(int a1, unsigned __int8 a2);
signed int sub_2B9A0(int a1);
unsigned __int8 sub_2BA50(int a1, unsigned __int8 a2);
// int _wcpp_1_unwind_leave__62(void); weak
void sub_2BB40_draw_bitmap(Bit16s posx, Bit16s posy, posistruct temposstr);
int sub_2BBB0(__int16 a1, __int16 a2, int a3);
void sub_2BC10_draw_text(Bit8u* a1, __int16 a2, __int16 a3, unsigned __int8 a4);
void sub_2BC80(Bit16u a1, Bit16u a2, Bit16u a3, Bit16u a4, Bit8u a5);
void sub_2BD10(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int8 a5);
int sub_2BE30();
int sub_2CA60(__int16 a1, __int16 a2, __int16 a3, __int16 a4);
int sub_2CA90(__int16 a1);
__int16 sub_2CB30(x_DWORD *a1, __int16 a2, int a3, __int16 a4);
int sub_2CE30(int a1, int a2);
void sub_2D190(__int16 a1, __int16 a2, int a3, __int16 a4, int a5, unsigned __int8 a6);
int sub_2D1D0();
void sub_2D710(int a1);
char sub_2DE80(__int16 a1, __int16 a2, Bit8u** a3);
char sub_2DFD0(__int16 a1, __int16 a2, int a3, unsigned __int8 a4);
void sub_2E260(__int16 a1, __int16 a2, unsigned int a3, char a4);
int sub_2E790(__int16 a1, int a2, int a3, int a4, unsigned __int8 a5);
int sub_2E850(__int16 a1, int a2, int a3, int a4, unsigned __int8 a5);
void sub_2EB40();
void sub_2EB60();
void sub_2EBB0_draw_text_with_border_630x340(Bit8u* a1);
void sub_2EC30_clear_img_mem();
void sub_2EC60();
void sub_2EC90(char a1);
__int16 sub_2ECC0();
int sub_2F6B0();
char sub_2FD90();
int *sub_2FFE0(int *a1, int *a2, x_DWORD *a3, x_DWORD *a4);
void sub_30050();
// int sub_303D0(signed int a1);
int sub_30630();
char sub_30870();
int sub_30A60(__int16 a1, __int16 a2);
x_DWORD *sub_30BE0(x_DWORD *a1, x_DWORD *a2);
void sub_30D50(int a1);
void sub_30F60(int a1);
void sub_31100(int a1);
void sub_31120(int a1);
void sub_311E0(int a1);
char sub_31760(int a1);
void sub_31870(int a1);
void sub_31890(int a1);
void sub_318B0(int a1);
int sub_31920(int a1);
char sub_31940(int a1);
int sub_31E90(signed __int16 *a1);
void sub_31F00(signed __int16 *a1, __int16 a2, __int16 a3);
void sub_31FB0(int a1);
int sub_320E0(int a1);
int sub_32120(int a1);
int sub_32160(int a1);
int sub_322A0(int a1);
char sub_323E0(int a1);
char sub_32400(int a1);
char sub_32420(int a1);
int sub_32530(int a1);
void sub_32600(int a1);
int sub_32880(int a1);
void sub_32A70(int a1);
void sub_32CF0(int a1);
int sub_32F40(int a1);
void sub_33110(unsigned int a1);
x_WORD *sub_331A0(int a1);
void sub_33340(x_WORD *a1);
void sub_33710(int a1);
char sub_33810(int a1, int a2);
void sub_338D0(unsigned int a1);
char sub_339B0(int a1);
int sub_33AD0(int a1);
__int16 sub_33B20(int a1);
int sub_33C00(int a1);
int sub_33C70(int a1);
int sub_33D40(int a1);
void sub_33D80(int a1);
void sub_33E20(int a1);
int sub_33E80(int a1);
bool sub_33F70(unsigned __int16 a1);
int sub_34000(int a1);
int sub_34110(x_WORD *a1);
int sub_34210(x_WORD *a1);
int sub_34330(int a1);
int sub_34350(int a1);
int sub_34390(int a1);
int sub_343C0(int a1);
int sub_343F0(x_WORD *a1);
int sub_34480(int a1);
x_WORD *sub_344A0(int a1);
int sub_34520(int a1);
int sub_34540(int a1);
int sub_34910(int a1);
int sub_34B00(char a1, char a2, __int16 a3, __int16 a4);
char sub_34C40(int a1);
// void sub_34EE0(signed int a1, int a2, int a3);
int sub_352A0(int a1);
x_WORD *sub_352C0(int a1);
void sub_35390(int a1);
unsigned int sub_35530(int a1);
int sub_35600(int a1);
void sub_35640(int a1);
int sub_357C0(int a1);
void sub_35940(int a1);
int sub_365F8(); // weak
char sub_36680(int a1);
void sub_36770(x_WORD *a1);
char sub_36850(int a1);
// char sub_36920(signed __int16 a1, int a2);
// signed int sub_369F0(signed int a1, __int16 a2);
// signed int sub_36A50(signed int a1, char a2);
void sub_36AE0(__int16 *a1);
void sub_36BA0(int a1, char a2);
int sub_36D50(int a1, int a2);
int sub_36F30(int a1, int a2);
char sub_36FC0(int a1);
void sub_37240(int a1);
char sub_37740(int a1);
void sub_377A0(int a1);
void sub_377F0(int a1);
void sub_37BC0(int a1);
int sub_38270(int a1);
int sub_38330(int a1);
int sub_385C0(int a1);
int sub_389F0(int a1);
signed int sub_38B00(int a1);
int sub_38B90(int a1);
unsigned int sub_38D80(int a1);
int sub_38E20(int a1);
int sub_38E40(int a1);
int sub_38E70(int a1);
int sub_38F70(x_WORD *a1);
char sub_39040(int a1);
int sub_396A0(int a1);
unsigned __int8 sub_396D0(int a1);
int sub_39B60(int a1);
char sub_39E40(int a1);
char sub_39FA0(int a1, int a2);
void sub_3A090(unsigned __int16 *a1);
void sub_3A200(int a1, int a2);
void sub_3A2D0(int a1);
void sub_3A5B0(int a1);
void sub_3A630(int a1);
int sub_3A650(int a1);
char sub_3A7F0(x_BYTE *a1);
char sub_3A8B0(int a1);
int sub_3AF00(int a1);
Bit32u* sub_3B4D0_fill_unk_D4350_256(int a1);
x_DWORD* sub_3B560(__int16 a1);
// char sub_3C080(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, signed int a6, int a7, __int16 a8, int a9);
// unsigned __int16 sub_3E360(int a1, int a2);
// unsigned __int16 sub_3FD60(int a1, int a2);
__int16 sub_40950(__int16 a1);
int sub_40BF0(int a1, int a2, int a3, int a4);
int sub_40C50(int a1);
int /*__fastcall*/ sub_40D10(int a1);
void sub_40F80();
char sub_411A0(int a1, int a2, int a3, __int16 a4, signed int a5, int a6, __int16 a7, int a8);
__int16 sub_417A0_install_pal_and_mouse_minmax();
__int16 sub_417D0_install_pal_and_mouse_minmax2();
void sub_41A90_VGA_pallette_install(Bit8u* a1);
void sub_41AF0();
char sub_41B60();
__int64 sub_41BC0();
__int16 sub_41BD3(unsigned int a1);
// int sub_43830_generate_level_map(unsigned int a1, int a2);
// unsigned int sub_43970(unsigned int a1);
// unsigned int sub_439A0(unsigned int a1, unsigned __int16 a2);
__int16 sub_43B40();
__int16 sub_43BB0();
void sub_43C60(unsigned __int8 a1, char a2, int a3, int a4);
unsigned __int16 sub_43D50();
unsigned __int16 sub_43EE0();
unsigned __int16 sub_43FC0();
void sub_440D0(unsigned __int16 a1);
unsigned __int16 sub_44320();
__int16 sub_44580();
int sub_44D00();
void sub_44DB0();
void sub_44E40(int a1, unsigned __int8 a2);
// unsigned __int16 sub_44EE0(int a1, int a2);
unsigned __int8 sub_45060(unsigned __int8 a1, unsigned __int8 a2);
char sub_45210(unsigned __int8 a1, unsigned __int8 a2);
unsigned __int16 sub_454F0(unsigned __int8 a1, unsigned __int8 a2);
unsigned __int16 sub_45600(unsigned __int8 a1);
unsigned __int16 sub_45AA0();
// char sub_45BE0(char a1, char a2, unsigned __int16 a3);
// char sub_45DC0(char a1, char a2, unsigned __int16 a3, unsigned __int8 a4);
unsigned __int16 sub_46180(unsigned __int16 a1, char a2);
char sub_462A0(unsigned __int16 a1, __int16 a2);
char sub_46570(unsigned __int16 a1, __int16 a2);
void sub_46820_simple_timer(Bit32u user);
// int sub_46830_main_loop(signed __int16 *a1, signed int a2, unsigned __int16 a3);
void sub_46B40();
void /*__fastcall*/ sub_46DD0_init_sound_and_music(/*int a1, int a2, char* a3*/);
void sub_46F50_sound_proc7();
void sub_46F80();
void sub_47130();
void sub_47160();
// int sub_47320(signed int a1);
void sub_473B0();
int sub_473E0();
// void sub_47560(int a1, int a2, x_BYTE *a3, signed int a4, __int16 a5);
int /*__fastcall*/ sub_47650(int a1, int a2);
char /*__fastcall*/ sub_47760(/*int a1,*/Bit32u user/* int a2, int a3*/);
int sub_47FC0(char a1);
unsigned __int8 /*__fastcall*/ sub_480A0(int a1, int a2, int a3);
unsigned __int8 sub_48120();
void sub_48350();
int sub_48370(__int16 a1, __int16 a2, __int16 a3);
int sub_483A0(__int16 a1, int a2, char a3, char a4);
int sub_48400(int a1, int a2, int a3, int a4);
int sub_48690(__int16 a1, __int16 a2, __int16 a3, __int16 a4);
int sub_487D0(unsigned __int16 a1, unsigned __int16 a2, __int16 a3, __int16 a4, char a5);
int sub_48880(unsigned __int16 a1, unsigned __int16 a2, __int16 a3, __int16 a4);
int sub_48930(); // weak
int sub_48990(char a1, char a2, char a3, char a4);
// __int16 sub_48A20(int a1, char a2, char a3, int a4, int a5, unsigned __int8 a6);
__int16 sub_48B50(unsigned __int8 a1, char a2, int a3, int a4);
__int16 sub_48B90(int a1);
__int16 sub_48D20(int a1, unsigned __int16 a2);
__int16 sub_48DF0(char a1, char a2, char a3, char a4);
signed int sub_48E60(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4);
signed int sub_48E90(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4);
signed int sub_48EC0(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4);
signed int sub_48EF0(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4);
signed int sub_48F20(char a1, char a2, __int16 a3, unsigned __int16 a4, int a5);
signed int sub_48FD0(char a1, char a2, __int16 a3, unsigned __int16 a4, int a5);
void sub_49090(int a1, x_WORD *a2);
void sub_49270_generate_level_features(Bit8u* a1);
int sub_49290(int a1, char a2);
void sub_49540(int a1, int a2);
int sub_49830(int a1);
int sub_498A0();
int sub_49A20(int a1);
__int16 sub_49A30(int a1, unsigned __int16 a2);
int sub_49C70(int a1);
char sub_49C90(int a1, __int16 a2);
int sub_49CD0(x_WORD *a1, __int16 a2);
int sub_49D50(int a1, __int16 a2);
int sub_49DA0(x_WORD *a1, __int16 a2);
int sub_49E10(x_WORD *a1, __int16 a2);
x_WORD *sub_49EA0(x_WORD *a1, __int16 a2, __int16 a3);
unsigned int sub_49EC0(x_WORD *a1, __int16 a2);
signed int sub_49F30();
int sub_49F90();
int sub_4A050();
int sub_4A190(int a1, int a2, int a3);
int sub_4A1E0(int a1, char a2);
int sub_4A310(unsigned __int16 *a1);
int sub_4A810();
int sub_4A820(int a1);
int sub_4A840(int a1);
int sub_4A860(int a1);
int sub_4A880(int a1);
int sub_4A8A0(int a1);
int sub_4A8C0(int a1);
int sub_4A8E0(int a1);
int sub_4A900(int a1);
x_WORD *sub_4A920(int a1);
x_WORD *sub_4A9C0(int a1);
int sub_4AA40(int a1);
int sub_4ABA0(int a1);
int sub_4AC40(int a1);
x_WORD *sub_4AD70(int a1);
x_WORD *sub_4ADF0(int a1);
x_WORD *sub_4AE80(int a1);
x_WORD *sub_4AF00(int a1);
x_WORD *sub_4AF70(int a1);
int sub_4AFE0(int a1);
int sub_4B0F0(int a1);
int sub_4B120(int a1);
int sub_4B150(int a1, char a2, char a3, __int16 a4);
x_DWORD *sub_4B240(int a1);
int sub_4B490(int a1);
int sub_4B590(int a1);
int sub_4B6F0(int a1);
int sub_4BA10(int a1);
int sub_4BBB0(int a1);
int sub_4BD00(int a1);
int sub_4BDF0(int a1);
x_WORD *sub_4BF40(int a1);
int sub_4C0B0(int a1);
int sub_4C1E0(int a1);
int sub_4C310(int a1);
int sub_4C460(int a1);
int sub_4C590(int a1);
int sub_4C6B0(int a1);
int sub_4C7F0(int a1);
int sub_4C8F0(int a1);
int sub_4CA00(int a1);
signed int sub_4CB60(int a1);
int sub_4CBF0(int a1);
int sub_4CCF0(int a1);
int sub_4CE00(int a1);
int sub_4CF00(int a1);
// unsigned int sub_4D000(unsigned int a1, int a2);
int sub_4D1D0(int a1);
int sub_4D2E0(int a1);
int sub_4D380(int a1);
int sub_4D3B0(int a1);
int sub_4D470(int a1);
int sub_4D500(int a1);
int sub_4D590(int a1);
int sub_4D620(int a1);
int sub_4D6B0(int a1);
int sub_4D740(int a1);
int sub_4D7D0(int a1);
int sub_4D860(int a1);
int sub_4D900(int a1);
int sub_4D990(int a1);
int sub_4DA20(int a1);
x_WORD *sub_4DAB0(int a1);
x_WORD *sub_4DBC0(int a1);
x_WORD *sub_4DC40(int a1);
x_WORD *sub_4DCC0(int a1);
x_WORD *sub_4DD50(int a1);
int sub_4DDD0(int a1);
int sub_4DEA0(int a1);
int sub_4DF30(int a1);
int sub_4DFC0(int a1);
int sub_4E050(int a1);
int sub_4E0F0(int a1);
int sub_4E180(int a1);
int sub_4E210(int a1);
int sub_4E2A0(int a1);
x_WORD *sub_4E320(int a1);
x_WORD *sub_4E3B0(int a1);
int sub_4E430(int a1);
int sub_4E490(int a1);
int sub_4E500(int a1);
int sub_4E570(int a1);
int sub_4E5F0(__int16 *a1);
int sub_4E6A0(__int16 *a1);
int sub_4E760(int a1);
x_WORD *sub_4E7D0(int a1);
int sub_4E840(int a1);
int sub_4E8C0(int a1);
int sub_4E950(int a1);
int sub_4E9E0(int a1);
int sub_4EA20(int a1);
int sub_4EA60(int a1);
int sub_4EAA0(int a1, char a2, char a3, __int16 a4, int a5);
int sub_4EB50(int a1);
int sub_4EC10(int a1);
int sub_4ECD0(int a1);
int sub_4ED70(int a1);
int sub_4EDC0(__int16 *a1);
int sub_4EED0(int a1);
int sub_4EF30(int a1);
int sub_4EF90(int a1);
x_WORD *sub_4F040(int a1);
unsigned __int16 sub_4F1C0(x_WORD *a1);
x_WORD *sub_4F2A0(int a1);
__int16 sub_4F440(int a1);
int sub_4F5F0(int a1);
x_WORD *sub_4F6A0(int a1);
x_WORD *sub_4F720(int a1);
int sub_4F7A0(int a1);
int sub_4F800(int a1);
int sub_4F860(int a1);
int sub_4F8B0(int a1);
int sub_4F900(int a1);
int sub_4F950(int a1);
int sub_4F9A0(int a1);
int sub_4FA00(int a1);
int sub_4FA60(int a1);
int sub_4FAC0(int a1);
int sub_4FB20(int a1);
int sub_4FB80(int a1);
int sub_4FBE0(int a1);
int sub_4FC30(int a1);
int sub_4FCA0(int a1);
int sub_4FCD0(int a1);
int sub_4FD00(int a1);
int sub_4FD70(int a1);
int sub_4FDE0(int a1);
x_WORD *sub_4FE40(int a1);
int sub_4FF20();
x_WORD *sub_4FF30(int a1);
int sub_4FFB0(int a1);
x_WORD *sub_50020(int a1);
int sub_50080(int a1);
int sub_500A0(int a1);
int sub_500C0(int a1, __int16 a2);
int sub_50130(int a1);
x_WORD *sub_501D0(int a1);
x_WORD *sub_50250(int a1);
x_WORD *sub_502B0(int a1);
int sub_50320(int a1);
int sub_50370(int a1);
x_WORD *sub_503D0(int a1);
x_WORD *sub_50430(int a1);
int sub_504B0(int a1);
int sub_50500(int a1);
int sub_505A0(int a1);
int sub_505E0(int a1);
int sub_50640(int a1);
int sub_506E0(int a1);
int sub_50780(int a1);
int sub_507C0(int a1);
x_BYTE *sub_50800();
x_WORD *sub_50840(int a1);
int sub_508E0(int a1);
int sub_50960(int a1);
int sub_50A20(int a1);
int sub_50A90(int a1, char a2, char a3);
int sub_50AE0(int a1);
int sub_50B00(int a1);
int sub_50B20(int a1);
int sub_50B40(int a1);
int sub_50B60(int a1);
int sub_50B80(int a1);
int sub_50C10(int a1);
int sub_50C30(int a1);
int sub_50C50(int a1);
int sub_50C70(int a1);
int sub_50C90(int a1);
int sub_50CB0(int a1);
int sub_50CD0(int a1);
int sub_50CF0(int a1);
int sub_50D10(int a1);
int sub_50D30(int a1);
int sub_50D50(int a1);
int sub_50D70(int a1);
int sub_50D90(int a1);
int sub_50DB0(int a1);
int sub_50DD0(int a1);
int sub_50DF0(int a1);
int sub_50E10(int a1);
int sub_50E30(int a1);
int sub_50E50(int a1);
int sub_50E70(int a1);
int sub_50E90(int a1);
int sub_50EB0(int a1);
int sub_50ED0(int a1);
int sub_50EF0(int a1);
int sub_50F10(int a1);
int sub_50F30(int a1);
int sub_50F50(int a1);
int sub_50F70(int a1);
int sub_50F90(int a1);
int sub_50FB0(int a1);
int sub_50FD0(int a1);
int sub_50FF0(int a1);
int sub_51120(int a1, char a2, char a3);
int sub_511A0(int a1);
int sub_511C0(int a1);
int sub_511E0(int a1);
int sub_51200(int a1);
int sub_51220(int a1);
int sub_51240(int a1);
int sub_51260(int a1);
int sub_51280(int a1);
int sub_512A0(int a1);
int sub_512C0(int a1);
int sub_512E0(int a1);
int sub_51300(int a1);
int sub_51320(int a1);
int sub_51340(int a1);
int sub_51360(int a1);
int sub_51380(int a1);
int sub_513A0(int a1);
int sub_513C0(int a1);
int sub_513E0(int a1);
int sub_51400(int a1);
int sub_51420(int a1);
int sub_51440(int a1);
int sub_51460(int a1);
int sub_51480(int a1);
int sub_514A0(int a1);
int sub_514C0(int a1);
int sub_514E0(int a1, char a2, char a3, __int16 a4);
x_WORD *sub_51530(int a1);
int sub_51570(int a1);
int sub_515C0(int a1);
x_WORD *sub_51610(int a1);
int sub_51660(int a1);
int sub_516C0(int a1);
int sub_51730(int a1);
x_BYTE *sub_51790(int a1);
x_WORD *sub_51800(int a1);
x_BYTE *sub_51A00(int a1);
// int sub_51BB0(int a1);
char sub_52D70(unsigned __int16 a1, char *a2);
char sub_52E90(int a1, signed int a2, char a3);
char sub_53120();
int sub_53160();
char sub_533B0_decompress_levels(__int16 a1, void *a2);
int sub_53590(int a1);
char sub_53770_test_open_moviegam(Bit16u a1);
char sub_53950_test_open_moviemap(Bit16u a1);
void sub_539A0_load_bldgprm();
void sub_53A40(char *a1);
int sub_53C70();
int sub_53CA0();
int sub_53CC0();
int sub_53CF0_access(char* a1);
Bit8u sub_53D10_create_nether_subdir(Bit8u a1, Bit8u* a2, Bit8u* a3);
int sub_53E60_readfile_and_decompress(const char* path, Bit8u** a2);
bool sub_53EF0_fileexist(char* path, char* path2);
bool sub_53F60(char* a1);
char sub_53F80(char* a1, char* a2, char* a3);

void sub_54600_mouse_reset();
void sub_54630_load_psxblock(__int16 a1);
int sub_54660_read_and_decompress_sky_and_blocks(Bit8u a1, Bit8u a2);
void sub_54800_read_and_decompress_tables(Bit8u a1);
__int16 sub_548B0(__int16 *a1);
x_WORD *sub_548F0(x_WORD *a1);
int sub_54960();
signed int sub_549A0(int a1, int a2);
int sub_54A50(unsigned __int16 a1, int a2);
char sub_54D30(__int16 a1);
char sub_54F00(__int16 a1);
char sub_55080(unsigned __int8 a1, int a2);
int sub_55100(char a1);
char sub_55250(unsigned __int8 a1);
bool sub_55320(unsigned __int8 a1);
char sub_55450(unsigned __int8 a1, int a2);
char sub_555D0(unsigned __int8 a1, int a2);
Bit8u sub_55750(unsigned __int8 a1, int a2);
bool sub_558E0(unsigned __int8 a1);
char sub_55A10(unsigned __int8 a1);
int sub_55AB0(int a1, int a2);
char sub_55C00(__int16 a1);
// unsigned int sub_55C60(int a1, int a2, int a3);
unsigned int sub_55EB0(__int16 a1);
//int sub_main(int argc, const char **argv, const char **envp);
void sub_560D0_create_sound_dir();
void sub_56210_process_command_line(int a1, char** a2);
int sub_56730_clean_memory();
int sub_567C0();
// char sub_56A30_init_game_level(unsigned int a1);
int sub_56C00_sound_proc2(int a1);
// char sub_56D60(unsigned int a1, char a2);
bool sub_56EE0(unsigned __int16 a1);
char sub_56F10(__int16 a1, __int16 a2, __int16 a3, char a4);
char sub_570F0(__int16 a1, __int16 a2, signed __int16 a3, char a4, char a5, char a6);
char sub_572C0(signed __int16 *a1, __int16 a2, __int16 a3, __int16 a4, char a5);
unsigned __int8 sub_57390(unsigned __int16 a1, unsigned __int16 a2);
char sub_57450(unsigned __int8 a1);
x_WORD *sub_574A0();
int sub_57570();
char sub_575C0();
char sub_57640();
unsigned int sub_57680();
char sub_57730();
char sub_57B20(int a1, int a2);
signed int sub_57CF0(int a1, int a2);
signed int sub_57D40(int a1, int a2);
int sub_57D70(int a1, int a2);
__int16 sub_57E50(int a1);
void sub_57F10(int a1);
int sub_57F20(int a1);
x_WORD *sub_57FA0(x_WORD *a1, unsigned __int16 a2, __int16 a3, __int16 a4);
x_WORD *sub_58030(int a1, x_WORD *a2);
signed int sub_580E0(int a1, signed int a2, int a3, int a4, __int16 a5);
__int16 sub_581E0(Bit16u *a1, Bit16u *a2);
__int16 sub_58210(x_WORD *a1, x_WORD *a2);
int sub_582B0(__int16 a1, __int16 a2);
int sub_582F0(int a1, __int16 a2);
int sub_58350(unsigned __int16 a1, __int16 a2, int a3, unsigned __int16 a4);
int sub_583B0(x_WORD *a1, x_WORD *a2);
unsigned int sub_583F0(x_WORD *a1, x_WORD *a2);
int sub_58440(x_WORD *a1, x_WORD *a2);
unsigned int sub_58490(x_WORD *a1, x_WORD *a2);
int sub_584D0(x_WORD *a1, x_WORD *a2);
signed int sub_585A0(int a1);
void sub_585D0();
char sub_58630();
int sub_58940(Bit8u* a1);
int sub_58DA0(int a1, int a2);
int sub_58F00();
char sub_595C0(__int16 a1);
char sub_59610(int *a1, __int16 a2);
char sub_596C0(x_WORD *a1, __int16 a2);
int sub_59760(int a1, int a2);
void sub_59820();
int sub_59A50_sound_proc8();
int sub_59AF0_sound_proc9();
void sub_59B50_sound_proc10(HMDIDRIVER user);
void sub_59BF0_sound_proc11_volume();
int sub_59C40(int a1);
int sub_59C60(int a1);
int sub_59C80(int a1);
char sub_59DC0(x_WORD *a1);
void sub_59F60(int a1);
unsigned int sub_5B070(int a1);
void sub_5B100(int a1);
void sub_5B7A0_prepare_pallette();
// int /*__fastcall*/ _wcpp_1_unwind_leave__93(x_DWORD, x_DWORD, x_DWORD, x_DWORD, x_DWORD, x_DWORD); weak
void sub_5B840_load_pallette_and_help_pallette();
void sub_5B870(Bit8u *langbuffer, Bit8u** langindexbuffer, Bit32u count);
//char sub_5B8D0_initialize();
void sub_5BC20();
void sub_5BCC0_set_any_variables1();
int sub_5BDC0_set_mouse_position(__int16 a1, __int16 a2);
Bit8u sub_5BE80_test_pallette(Bit8u *a1, Bit8u a2, Bit8u a3, Bit8u a4);
char sub_5BF10();
signed int sub_5BF50_load_psxdata();
signed int sub_5C060();
int sub_5C0A0();
signed int sub_5C1B0_set_any_variables2();
void sub_5C330();
bool sub_5C380_test_vga_driver_header(Bit16u testlenght);
signed int sub_5C3D0_file_decompress(Bit8u* a1, Bit8u* a2);
int sub_5C430_multi_allocation();
void sub_5C450();
int sub_5C490_testers_info();
int sub_5C530();
__int16 sub_5C800(int a1, char a2);
__int16 sub_5C830(int a1, char a2, __int16 a3);
signed int sub_5C870(int a1);
signed int sub_5C8D0(int a1);
int sub_5C950(int a1, int a2);
x_WORD *sub_5CF40(int a1, char a2);
int sub_5D0A0(int a1);
// int _wcpp_1_unwind_leave__98(x_DWORD); weak
void sub_5D530(int a1);
signed int sub_5DD50(int a1);
void sub_5DE30(int a1);
int _wcpp_1_unwind_leave__99(x_DWORD);// weak
void sub_5E010(unsigned int a1);
int sub_5E310(int a1);
int sub_5E660(int a1);
__int16 sub_5E6C0(int a1);
char sub_5E7C0(int a1);
signed int sub_5E8C0(int a1);
unsigned int sub_5EF70(unsigned int a1);
signed int sub_5EFA0(unsigned int a1);
char sub_5F380(int a1);
char sub_5F660(int a1, unsigned int a2, int a3);
unsigned __int8 sub_5F7B0(int a1, int a2, int a3);
unsigned __int8 sub_5F7E0(int a1, int a2);
unsigned int sub_5F810(int a1, int a2, int a3);
char sub_5F890(int a1, __int16 a2);
void sub_5F8F0(int a1);
void sub_5FA70(int a1);
unsigned int sub_5FBD0(__int16 *a1);
int sub_5FC40(int a1);
int sub_5FCA0(int a1);
// int _wcpp_1_unwind_leave__100(x_DWORD, x_DWORD); weak
int sub_5FD00(int a1);
int sub_5FF50(int a1);
x_WORD *sub_60400(__int16 a1, x_WORD *a2, x_WORD *a3);
char sub_60480(int a1);
void sub_605E0(int a1);
int sub_60780(x_DWORD *a1, int a2, int a3, int a4);
unsigned int sub_60810(int a1);
signed int sub_609E0(int a1);
signed int sub_60AB0(int a1);
signed int sub_60D50(__int16 *a1, int a2);
signed int sub_60EA0(int a1);
void sub_60F00();
__int16 sub_61000(int a1);
unsigned int sub_61050(unsigned int a1);
__int16 sub_613D0(int a1);
char sub_61620(int a1, int a2);
signed int sub_616D0(signed int a1);
signed int sub_61790(signed int a1);
signed int sub_61810(int a1, int a2);
char *sub_61880(int a1, int a2, __int16 a3, __int16 a4, int a5, int a6, __int16 a7, int a8);
char *sub_61A00(int a1, int a2, __int16 a3, __int16 a4, int a5, int a6, __int16 a7, int a8);
char *sub_627F0(int a1, int a2, __int16 a3, __int16 a4, int a5, int a6, __int16 a7, int a8);
char sub_63570(int a1, int a2);
int sub_63600(int a1, int a2, int a3, int a4, int a5, int a6, __int16 a7, int a8, int a9, int a10);
int sub_63670(int a1, int a2, int a3, int a4, int a5, int a6, __int16 a7, int a8, int a9, int a10);
int sub_63C90(int a1, int a2, int a3, int a4, int a5, int a6, __int16 a7, int a8, int a9, int a10);
char sub_644F0(int a1, int a2, __int16 a3, __int16 a4, int a5, int a6, __int16 a7, int a8);
char sub_64CE0(int a1);
int(*sub_64E20(int a1))();
int(*sub_64F60(int a1))();
int(*sub_64FF0(x_WORD *a1))();
int sub_65040(int a1);
int sub_65080(int a1);
int sub_65110(int a1);
int(*sub_651B0(int a1))();
int(*sub_65240(int a1))();
void sub_65280(int a1);
void sub_652A0(int a1);
void sub_652C0(int a1);
int sub_654B0(signed __int16 *a1, int a2);
int sub_65580(int a1);
int sub_655A0(int a1);
int sub_655C0(x_WORD *a1, int a2);
int sub_65610(int a1, int a2);
__int16 sub_656D0(int a1, int a2);
char sub_65780(int a1, unsigned int a2, unsigned int a3);
int sub_65820(int a1);
void sub_65B30(int a1);
void sub_65B50(int a1);
int sub_65C20(int a1);
void sub_65F60(int a1);
int sub_66160(int a1);
int sub_66180(int a1);
int sub_66250(int a1);
int sub_66280(int a1);
int sub_662A0(int a1);
char sub_662C0(int a1);
char sub_662E0(int a1);
void sub_66610(int a1);
__int16 sub_66750(unsigned int a1);
char sub_66B30(int a1);
char sub_66D00(int a1);
int sub_66FB0(int a1);
char sub_66FD0(int a1);
char sub_672E0(int a1);
void sub_67410(int a1);
int sub_67430(int a1);
int sub_67450(int a1);
int sub_67470(int a1);
void sub_674C0(int a1);
x_WORD *sub_676F0(int a1);
int sub_67740(int a1);
int sub_67760(int a1);
int sub_67780(int a1);
int sub_677A0(int a1);
int sub_677D0(int a1);
int sub_67800(int a1);
unsigned int sub_67890(int a1);
int sub_678E0(int a1);
int sub_67910(int a1);
int sub_67940(int a1);
// int sub_67960(unsigned int a1, int a2);
signed int sub_67CB0(int a1);
int sub_68490(__int16 *a1, int a2, unsigned __int16 a3, unsigned __int16 a4);
int sub_685D0(__int16 *a1, int a2, unsigned __int16 a3, unsigned __int16 a4);
int sub_686D0(int a1, unsigned int a2);
char sub_68740(int a1, int a2, unsigned __int16 a3, __int16 a4);
char sub_68940(int a1);
char sub_68AC0(int a1, int a2);
char sub_68BD0(int a1, x_BYTE *a2);
int sub_68BF0();
int sub_68C70(int a1);
signed int sub_68D50(int a1, x_DWORD *a2);
signed int sub_68DE0(int a1, int a2);
signed int sub_68E50(int a1, int a2, int a3);
signed int sub_68FF0(int a1, char a2, char a3);
signed int sub_69250(int a1);
signed int sub_692A0(int a1);
char sub_692C0(int a1);
void sub_69300(int a1, int a2);
int sub_693F0(int a1);
signed int sub_69600(int a1);
signed int sub_69620(int a1);
void sub_69640(int a1);
void sub_69900(int a1, int a2);
signed int sub_69A70(int a1);
signed int sub_69A90(int a1);
int sub_69AB0(int a1);
signed int sub_69D70(int a1);
signed int sub_69D90(int a1);
void sub_69DB0(int a1);
signed int sub_69FF0(int a1);
signed int sub_6A010(int a1);
char sub_6A030(int a1);
signed int sub_6A2C0(int a1);
signed int sub_6A2E0(int a1);
void sub_6A300(int a1);
signed int sub_6A440(int a1);
signed int sub_6A460(int a1);
char sub_6A480(int a1);
signed int sub_6A580(int a1);
signed int sub_6A5A0(int a1);
int sub_6A5C0(int a1);
signed int sub_6A9C0(int a1);
signed int sub_6A9E0(int a1);
__int16 sub_6AA00(int a1);
signed int sub_6AAC0(int a1);
signed int sub_6AAE0(int a1);
int sub_6AB00(int a1);
signed int sub_6AD00(int a1);
signed int sub_6AD20(int a1);
void sub_6AD60(int a1);
signed int sub_6B180(int a1);
signed int sub_6B1A0(int a1);
void sub_6B1C0(int a1);
signed int sub_6B2D0(int a1);
signed int sub_6B2F0(int a1);
__int16 sub_6B310(x_WORD *a1);
signed int sub_6B3A0(int a1);
signed int sub_6B3C0(int a1);
int sub_6B3E0(int a1);
signed int sub_6B5D0(int a1);
signed int sub_6B5F0(int a1);
__int16 sub_6B610(int a1);
signed int sub_6B830(int a1);
signed int sub_6B850(int a1);
int sub_6B870(int a1);
signed int sub_6BA70(int a1);
signed int sub_6BA90(int a1);
int sub_6BAB0(int a1);
signed int sub_6BCB0(int a1);
signed int sub_6BCD0(int a1);
int sub_6BCF0(int a1);
signed int sub_6BEF0(int a1);
signed int sub_6BF10(int a1);
int sub_6BF30(int a1);
signed int sub_6C130(int a1);
signed int sub_6C150(int a1);
__int16 sub_6C170(int a1);
signed int sub_6C3A0(int a1);
signed int sub_6C3C0(int a1);
int sub_6C3E0(int a1);
signed int sub_6C5E0(int a1);
signed int sub_6C600(int a1);
int sub_6C620(int a1);
signed int sub_6C830(int a1);
signed int sub_6C850(int a1);
__int16 sub_6C870(int a1);
signed int sub_6CA80(int a1);
signed int sub_6CAA0(int a1);
int sub_6CAC0(int a1);
signed int sub_6CCE0(int a1);
signed int sub_6CD00(int a1);
int sub_6CD20(int a1);
signed int sub_6CF60(int a1);
signed int sub_6CF80(int a1);
int sub_6CFA0(int a1);
signed int sub_6D1C0(int a1);
signed int sub_6D1E0(int a1);
__int16 sub_6D200(int a1);
int sub_6D420(__int16 a1, __int16 a2);
char sub_6D4C0(int a1);
int sub_6D4F0(int a1, __int16 a2);
// int /*__fastcall*/ _wcpp_1_unwind_leave__120(x_DWORD, x_DWORD, x_DWORD); weak
char sub_6D5E0(int a1, char a2);
int sub_6D710(unsigned int a1, unsigned __int8 a2, unsigned __int8 a3);
char sub_6D830(int a1, char a2);
char sub_6D880(int a1);
void sub_6D8B0(unsigned __int16 a1, unsigned __int16 a2, __int16 a3);
int sub_6D9C0(int a1, unsigned __int8 *a2, __int16 a3, char a4, char a5);
void sub_6DAD0(int a1, unsigned __int8 *a2, __int16 a3);
int sub_6DB50(char a1, char a2);
void sub_6DBD0();
void sub_6DC40(unsigned __int8 a1);
int sub_6DCA0(int a1, int a2, unsigned __int16 a3, __int16 *a4, __int16 a5, char a6);
signed int sub_6E020(unsigned __int16 a1);
int sub_6E090(int a1, int a2);
int sub_6E0D0();
void sub_6E150();
void sub_6E450(__int16 a1, __int16 a2, __int16 a3);
bool sub_6EA90(int a1, int a2);
void sub_6EAB0(int a1, __int16 a2, __int16 a3);
void sub_6EB90(filearray_struct* a1);
void sub_6EBF0(filearray_struct* a1);
int sub_6EDB0_set_mouse_position_by_res();
int sub_6EDE0_set_mouse_position2(signed __int16 a1, signed __int16 a2);
__int16 sub_6EF10_set_mouse_minmax(__int16 a1, signed __int16 a2, __int16 a3, signed __int16 a4);
unsigned int sub_6F030(int a1);
unsigned int sub_6F070(int a1);
unsigned int sub_6F0B0(int a1);
unsigned int sub_6F100(int a1);
unsigned int sub_6F150(int a1);
int sub_6F1C0(int a1);
x_BYTE *sub_6F2B0(int a1);
unsigned int sub_6F300(int a1, unsigned int a2);
unsigned int sub_6F420(int a1);
unsigned int sub_6F440(int a1);
unsigned int sub_6F460(int a1);
unsigned int sub_6F480(int a1);
unsigned int sub_6F4A0(int a1);
unsigned int sub_6F4C0(int a1);
unsigned int sub_6F4E0(int a1);
unsigned int sub_6F500(int a1);
unsigned int sub_6F520(int a1);
unsigned int sub_6F540(int a1);
unsigned int sub_6F560(int a1);
unsigned int sub_6F580(int a1);
unsigned int sub_6F5A0(int a1);
unsigned int sub_6F5C0(int a1);
unsigned int sub_6F5E0(int a1);
unsigned int sub_6F600(int a1);
unsigned int sub_6F620(int a1);
unsigned int sub_6F640(int a1);
unsigned int sub_6F660(int a1);
unsigned int sub_6F680(int a1);
unsigned int sub_6F6A0(int a1);
unsigned int sub_6F6C0(int a1);
unsigned int sub_6F6E0(int a1);
unsigned int sub_6F700(int a1);
unsigned int sub_6F720(int a1);
unsigned int sub_6F740(int a1);
unsigned int sub_6F760(int a1);
unsigned int sub_6F780(int a1);
unsigned int sub_6F7A0(int a1);
unsigned int sub_6F7C0(int a1);
x_BYTE *sub_6F7E0(int a1);
unsigned int sub_6F850(int a1, int a2);
int sub_6F8E0(int a1, int a2);
void sub_6F940_sub_draw_text(Bit8u* a1, int a2, int a3, Bit8u color);
Bit8u sub_6FC10_letter_width();
Bit8u sub_6FC30_get34_sizey();
void sub_6FC50(__int16 a1);
unsigned int sub_6FC80_pre_draw_text(char *a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int8 a5);
int sub_6FD30(); // weak
int sub_6FDA0();
void sub_6FE20();
// int /*__fastcall*/ _wcpp_1_unwind_leave__130(x_DWORD); weak
int sub_6FE90(unsigned __int8 *a1, unsigned int a2);
int sub_6FEC0();
void sub_70890_print_header();
char* sub_70910_print_string(char* a1);
unsigned int sub_70940();
void sub_70A60_open_tmaps();
void sub_70BF0_close_tmaps();
int sub_70C60_decompress_tmap(unsigned __int16 a1, Bit8u* a2);
char sub_70D20(unsigned __int16 a1);
char sub_70E10(unsigned __int16 a1);
int sub_70EF0(unsigned __int16 a1);
int sub_70F50(unsigned __int16 a1);
unsigned int sub_71090(unsigned int a1);
__int16 sub_712F0();
void sub_713A0();
//int sub_71410_process_tmaps_process_tmaps();
bool sub_71520(unsigned __int16 a1);
int sub_715B0();
int sub_716A0();
signed __int16 *sub_716C0(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3);
int sub_71730(unsigned __int16 a1);
char sub_71780();
char sub_71890();
__int16 sub_718F0();
int sub_71930();
char sub_71990();
unsigned __int8 sub_71A70(unsigned __int8 a1);
__int16 sub_71AB0(__int16 a1, char a2);
int sub_71B40(int a1, unsigned __int16 a2, int a3);
signed int sub_71CD0(int a1);
int sub_71E60(int a1);
int sub_71E70(int a1, unsigned int a2, __int16 a3);
__int16 sub_71F20(int a1, int a2);
void sub_720C0(int *a1);
int sub_72120(unsigned __int16 a1);
int sub_721C0(unsigned __int16 *a1, int *a2, __int16 a3);
int sub_72350(int a1);
unsigned __int16 sub_723B0(int a1, char a2);
x_DWORD *sub_72410(x_DWORD *a1);
int sub_724F0(int a1, __int16 a2);
void sub_72550(int *a1);
Bit16u /*__spoils<>*/ sub_72633(Bit16s a1, Bit16s a2);
unsigned int sub_7277A(unsigned int a1);
void sub_727F0(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
// void /*__spoils<ecx>*/ sub_72883_clear_text_mode(int a1, void *a2, unsigned __int16 a3, char a4);
// void /*__spoils<ecx>*/ sub_728A9_clear_graphics_mode(int a1, void *a2, unsigned __int16 a3, char a4);
void sub_72C40_draw_bitmap_640_setcolor(__int16 a1, __int16 a2, posistruct a3, unsigned __int8 a4);
int sub_72CB0(unsigned __int8 *a1, int a2);
void sub_72D04();
// int sub_72DDE(signed __int16 *a1, int a2);
int /*__fastcall*/ sub_72E70(int a1, int a2, signed __int16 *a3);
signed int /*__fastcall*/ sub_72FBB(int a1, int a2, signed __int16 *a3);
signed int sub_7302E();
// int sub_7308F(signed __int16 *a1, int a2, __int16 a3);
int sub_73669(__int16 a1);
int sub_7373D(__int16 a1);
__int16 sub_739AD(__int16 a1);
__int16 sub_73AA1(__int16 a1);
__int16 sub_73D11(__int16 a1);
unsigned __int16 sub_74006(unsigned __int16 a1, int a2, unsigned int a3);
unsigned __int16 sub_7404E(unsigned __int16 a1, int a2, unsigned int a3);
__int16 sub_74374();
unsigned __int16 sub_7438A(int a1, unsigned int a2);
__int16 sub_7449C();
int sub_74515();
int sub_74536();
Bit8u sub_74556();
// signed int sub_74767(signed __int16 *a1, x_BYTE *a2, int a3);
int sub_74809(__int16 a1);
signed int sub_748F7(__int16 a1);
signed int sub_74A11();
int sub_74A86(x_BYTE *a1, Bit8u* a2);
int sub_74B19(x_BYTE *a1);
signed int sub_74B75(__int16 a1);
int sub_74C9D(unsigned int a1, int a2);
int sub_74D41(unsigned int a1, int a2, unsigned int a3);
signed int sub_74DD4(unsigned int a1, int a2, unsigned __int16 a3);
int sub_74E6D(unsigned int a1, int a2, int a3);
int sub_74EF1(unsigned int a1, int a2, unsigned int a3);
__int16 sub_74F76();
signed int sub_74FE1(__int16 a1);
int sub_75044(unsigned int a1);
HSAMPLE* sub_75110(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4, __int16 a5);
HSAMPLE* sub_75160(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4, __int16 a5);
HSAMPLE* sub_751B0(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4, __int16 a5);
void sub_75200_VGA_Blit640(Bit16u height);
int sub_752C0(); // weak
void sub_753D0();
int sub_75420();
int sub_75440();
int sub_754C0(int a1, x_DWORD *a2, int a3);
int sub_75540(int a1, int a2);
int sub_755B0(int a1, x_DWORD *a2, int a3);
signed int sub_75650();
int sub_75900();
signed int sub_75910();
int sub_759B0_set_mouse_minmax_vert();
unsigned __int8 sub_75A10(int a1, unsigned __int8 *a2);
int sub_75AB0();
int sub_75AE0(int a1);
int sub_75B50(__int16 a1);
int sub_75B80_alloc_mem_block(int a1, x_WORD *a2, x_WORD *a3);
void sub_75C50();
void sub_75CB0();
//void sub_75D70(void *a1, unsigned int a2);
void sub_75D70(Bit8u* a1, Bit32u a2);
void sub_75DB0();
void /*__fastcall*/ sub_75E70();
void sub_76160_play_intro(__int16 a1, __int16 a2, Bit8u* a3);
void sub_76260_read_intro_pallette(Bit8u a1);
void sub_76300();
int sub_76430();
int sub_76540();
void sub_765FC(__int16 a1, __int16 a2);
int sub_76619(int a1, int a2);
__int16 sub_766A4();
__int16 sub_76752();
int sub_7677C();
__int16 sub_7678D();
int sub_76840();
signed int /*__fastcall*/ sub_76930_menus_and_intros(int a2, Bit16u a3);
void sub_76A40_lang_setting();
void sub_76CF0();
// int /*__fastcall*/ _wcpp_1_unwind_leave__131(x_DWORD); weak
void sub_76D10_intros(char a1);
int sub_76F40(); // weak
void /*__fastcall*/ sub_76FA0_main_menu(/*int a1,*/ int a2, Bit16u a3);
char sub_77350_new_game_dialog(Bit8u* a1);
char /*__fastcall*/ sub_77680(int a1, int a2, signed __int16 *a3);
char sub_77980_exit_dialog(Bit8u* a1);
char sub_779E0_lang_setting_dialog(Bit8u* a1);
char sub_780F0_load_game_dialog(Bit8u* a1);
char sub_78730_save_game_dialog(x_WORD *a1);
// char sub_78E00_set_player_name_dialog(int a1, int a2, signed __int16 *a3);
char sub_79160_set_joystick_dialog(Bit8u* a1);
char sub_79610_set_keys_dialog();
signed int sub_79E10(char *a1, char a2);
char sub_7A060_get_mouse_and_keyboard_events();
void sub_7A110_load_hscreen(char a1, char a2);
void sub_7AA70_load_and_decompres_dat_file(char* a1, Bit8u* a2, int a3, int a4);
// int (**sub_7AB00_draw_menu_animations(__int16 a1, int a2, signed __int16 *a3, unsigned __int8 a4))(int);
int sub_7AC00_load_and_set_graphics_and_pallette();
int sub_7ADE0(char a1);
bool sub_7B200_in_region(Bit16s* a1, Bit16s testx, Bit16s testy);
char /*__fastcall*/ sub_7B250(/*int a1, int a2*//*, __int16 a3*/);
void sub_7B5A0_disable_enable();
void sub_7B5D0();
int sub_7B660_draw_scroll_dialog2(int a1, int a2, __int16 a3, x_WORD *a4, Bit8u* a5, char a6);
void sub_7BEC0();
int sub_7BF20_draw_scroll_dialog(signed __int16 *a1);
void sub_7C020(x_WORD *a1);
signed int /*__fastcall*/ sub_7C050_get_keyboard_keys1();
void sub_7C120_draw_bitmap_640(Bit16s posx, Bit16s posy, posistruct tempstr);
void sub_7C140_draw_text_background(Bit16s a1, Bit16s a2, Bit16s a3, Bit16s a4, Bit8u a5);
Bit32s sub_A7C20_AIL_API_init_sequence(HSEQUENCE S, void* start, Bit32s sequence_num, Bit32u track);
int /*__fastcall*/ sub_7C230(int a1, int a2, signed __int16 *a3);
signed int sub_7C390();
void sub_7C710();
int sub_7C720(unsigned __int8 a1, x_BYTE *a2);
int sub_7C7C0(int a1, int a2);
void sub_7C800(signed __int16 a1);
void sub_7C9D0(signed __int16 a1);
int sub_7CB10();
char sub_7CBF0();
char sub_7CC40();
int sub_7CCA0();
int sub_7CCF0();
int sub_7CD30();
int sub_7CDA0();
int sub_7CDC0(unsigned __int8 a1, unsigned __int8 a2);
signed int sub_7CE50();
int sub_7D1F0();
signed int sub_7D230(char a1, unsigned __int8 a2, unsigned __int8 a3);
int sub_7D310();
unsigned int sub_7D380();
// int sub_7D400_draw_texts_and_play_sounds(int a1, __int16 a2, __int16 a3, char a4);
void sub_7DA70(__int16 a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6);
int sub_7DD70();
// char sub_7DE80(int a1, int a2);
signed int sub_7E0E0_mouse_events();
Bit16s sub_7E1F0_test_mouse_regions();
// signed int sub_7E320_draw_bitmaps_and_play_sounds(__int16 a1, int a2);
// signed int sub_7E5A0_pre_draw(int a1, int a2, __int16 a3, __int16 a4, int a5, __int16 a6, __int16 a7);
signed int sub_7E620(int a1);
signed int sub_7E640(int a1);
char sub_7E800(x_WORD *a1);
char sub_7E820(int a1);
void sub_7E840_draw_textbox_with_line(Bit16u* a1, __int16 a2, __int16 a3);
void sub_7E8D0(x_WORD *a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7);
signed int sub_7E9D0(x_WORD *a1, x_WORD *a2, x_WORD *a3);
int sub_7EAE0_new_game_draw(__int16 *a1, __int16 *a2, __int16 *a3, __int16 *a4, char *a5, x_WORD *a6);
// int sub_7F6A0(int a1, int a2, __int16 a3, __int16 a4, char *a5, x_BYTE *a6, unsigned __int8 a7);
//int sub_7F7D0(Bit8u** a1, Bit8u** a2, Bit8u* a3, char* a4);
int sub_7F7D0(Bit8u** a1, Bit8u** a2, Bit8u* a3, char* langfilename, posistruct* a3dattabindex);//2607d0
//int sub_7F960(Bit8u* a1, Bit8u* a2, unsigned int a3, Bit8u* a4);
int sub_7F960(Bit8u* a1, Bit8u* a2, Bit8u* a3, char* langcountstring, posistruct* a3dattabindex);
Bit32u sub_7FAE0_draw_text(char* a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int8 a5);
void sub_7FB90_draw_text(char* a1, Bit16s a2, Bit16s a3, Bit8u a4);
// int sub_7FCB0_draw_text_with_border(int a1, x_BYTE *a2, int a3, int a4, int a5, char a6, unsigned __int8 a7, __int16 a8);
void sub_80C30_draw_texts(__int16 a1, __int16 a2, __int16 a3);
// signed int sub_80D40_move_graphics_and_play_sounds(__int16 a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6);
// int sub_81260(int a1, int a2, int a3, __int16 a4, __int16 a5);
int sub_812D0(__int16 a1, __int16 a2);
void sub_81360_draw_bitmap_line(Bit16s a1, Bit16s a2, Bit16s a3, Bit16s a4, __int16 a5);
void sub_81760_new_game_subdraw(Bit8u* a1);
// unsigned int sub_81CA0(int a1, int a2, __int16 a3, __int16 a4, int a5);
signed int sub_81DB0_read_config();
void sub_81EE0_draw_and_sound_dragon_and_fire(int a1, int a2, int a3, signed __int16 a4, __int16 a5, __int16 a6);
x_WORD *sub_824B0(__int16 a1);
x_WORD *sub_824E0(__int16 a1);
// int sub_82510(__int16 a1, int *a2);
__int16 sub_82670();
int sub_82AB0(unsigned __int8 a1);
void sub_82C20(__int16 a1);
void sub_83250_play_intros(char a1);
void sub_833C0();
int sub_83850_show_welcome_screen();
void sub_83B50();
void sub_83CC0(char a1);
void* sub_83CD0_malloc2(size_t a1);
void* sub_83D70_malloc1(int a1);
char sub_83E00(int a1, int a2);
void sub_83E80_sound_proc_99(Bit8u* a1);
int sub_84000(int a1);
int sub_84050();
// void sub_840B8(char a1, bool a2, char a3, char a4);
// __int16 sub_840D3(char _CF, bool _ZF, char _SF, char _OF);
// void /*__spoils<st0>*/ sub_841CE(__int16 a1);
bool sub_84250_load_file_array(int psindex);
Bit32s sub_84300_load_sound(Bit8u a1);
void sub_844A0_sound_proc5();
char sub_844F0_read_and_decompress_sound(FILE* a1, unsigned __int8 a2);
int sub_84790();
char sub_847D0(int a1, char a2, char a3, char a4);
int sub_84880(x_BYTE *a1);
char sub_848A0();
int sub_84B80();
int sub_84EA0(unsigned __int16 a1, int a2, char a3, __int16 a4);
int sub_84FB0(signed __int16 *a1, signed __int16 *a2);
int sub_85060(int a1);
void sub_85070();
//int *sub_85350(); //fix
void* sub_85450_allocate_mem_pool(unsigned int a1);
__int16 sub_856D0(int a1, int a2, __int16 a3, int a4);
unsigned int *sub_85AF0(int a1);
int sub_85B20(x_BYTE *a1, x_WORD *a2, unsigned __int16 a3);
int sub_85BF5(x_BYTE *a1, int a2, int a3, int a4, int a5, int a6);
int sub_85C42(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6);
void sub_85C8B_draw_new_game_map_background(Bit8u* a1, Bit8u* a2, int a3, int a4, int a5, int a6);
// void /*__spoils<ecx>*/ sub_85CC3_draw_round_frame(unsigned int a1, int a2, unsigned __int16 *a3);
int sub_85E40();
__int16 sub_85EB0_alloc_memory(__int16 a1);
__int16 sub_85F00_free_memory(__int16 a1);
int sub_85F60(int a1);
bool sub_85FD0();
int sub_86010();
__int16 sub_86180(unsigned __int16 a1);
__int16 sub_86270(unsigned __int16 a1);
__int16 sub_86370(unsigned __int16 a1, char a2);
void sub_86460(Bit16u a1);
int sub_86550();
char sub_86780(unsigned __int16 a1, int a2, int a3);
char sub_86860(unsigned __int16 a1);
char sub_86930(unsigned __int16 a1);
void sub_86A00_some_allocs();
bool sub_86BD0_freemem1();
void sub_86EA0(/*int a1, int a2, int a3*/Bit32u user);
void sub_86EB0(unsigned __int8 a1, unsigned __int8 a2, char a3);
void sub_86F20(char a1);
void sub_86F70_sound_proc12(unsigned __int8 a1, __int16 a2, __int16 a3);
void sub_86FF0(unsigned __int8 a1, __int16 a2, __int16 a3);
Bit8u* sub_87090();
char sub_871E0();
int sub_871F0();
int sub_872A0();
void sub_87580();
char sub_87610();
int sub_87860();
int sub_87970();
int sub_87A30();
int sub_87B30();
Bit8u* sub_87B70();
// int /*__fastcall*/ _wcpp_1_unwind_leave__132(x_DWORD); weak
Bit8u* sub_87BE0();
int sub_87C10();
int sub_87CF0();
int sub_88450();
void sub_884D0(int a1, __int16 a2, int a3, char a4, char a5);
Bit8u* sub_88580();
char sub_885E0(int a1, int a2, int a3, unsigned __int16 a4);
void sub_88740(int a1, int a2, int a3);
int sub_889F0(int a1);
Bit8u* sub_88B20();
int sub_88B60();
char sub_88BA0();
int sub_88D00();
char sub_88D40();
char sub_89360();
int sub_89420(x_WORD *a1, const char *a2);
int sub_89520(signed __int16 *a1);
int sub_895D0(int a1, const char *a2);
int sub_89690(signed __int16 *a1);
int sub_89830(x_WORD *a1);
x_WORD *sub_898A0(x_WORD *a1);
int sub_89920(x_WORD *a1, __int16 a2, int a3);
int sub_89980(signed __int16 *a1);
void sub_89A30(x_WORD *a1);
int sub_89AC0(x_BYTE *a1, int a2);
Bit16s sub_89B60_aplicate_setting(Bit8u a1);
int sub_89D10();
int sub_8B5A0();
signed int sub_8B600(int a1);
int sub_8B770();
signed int sub_8B790(x_DWORD *a1);
char sub_8B880(int *a1, char a2, signed int a3, int a4);
// char sub_8B980(int a1, int a2, x_DWORD **a3, int a4);
// char sub_8BA10(int a1, int a2, int *a3, char *a4, int a5);
int sub_8BB10(int a1);
int sub_8BB40(int a1, char a2);
signed int sub_8BBE0(int a1);
void sub_8C0E0(unsigned __int8(/*__fastcall*/ *a1)(signed int));
char sub_8C140(unsigned __int16 a1, int a2);
// x_DWORD dos_getdrive(x_DWORD); weak
// x_DWORD dos_setdrive(x_DWORD, x_DWORD); weak
// x_DWORD dos_getdiskfree(x_DWORD, x_DWORD); weak
int sub_8C21F_any_graphics_command();
// x_DWORD memset(x_DWORD, x_DWORD, x_DWORD); weak
// int rand(void); weak
// x_DWORD printf(x_DWORD);
void sub_8C2CD();
void sub_8C2DE();
int sub_8C329();
void sub_8C635_draw_cursor();
int sub_8C839();
int sub_8CA16();
void sub_8CACD_draw_cursor2();
void sub_8CB1F();
void sub_8CB3A(Bit32u a1, Bit32s a2, int a3, Bit32s a4);
void sub_8CD27_set_cursor(posistruct a2);
signed int sub_8CEDF_install_mouse();
int sub_8D12F_set_mouse_viewport();
void /*__fastcall*/ sub_8D290_init_sound(char* a1/*, int a2, int a3*/);
void sub_8D800_sound_proc2();
void sub_8D8F0_sound_proc3_endsample();
void /*__fastcall*/ sub_8D970_init_music(char* a1/*int a1, int a2, char* a3*/);
void sub_8E020_sound_proc14_stopsequence();
int sub_8E0D0(); // weak
void sub_8E160_sound_proc15_startsequence(__int16 a1, unsigned __int8 a2);
// x_DWORD sprintf_s(x_DWORD, const char *, ...); weak
void sub_8E410_sound_proc16_xmidivolume(Bit32s master_volume);
int sub_8E470_sound_proc17_volume(int a1);
__int16 sub_8E673();
__int16 sub_8E736();
int sub_8E799();
int sub_8E7B7();
int sub_8E7D5();
void sub_8E7FC();
__int16 sub_8E871();
int sub_8E948();
char sub_8E9EF();
void /*__fastcall*/ sub_8EA7B(int a1, unsigned __int16 a2);
signed int sub_8EAD0_load_music(int a1);
void sub_8EC90_get_music_sequence_count();
char sub_8ED00_load_music_track(FILE* a1, unsigned __int8 a2);
int sub_8F023(int a1, int a2, unsigned int a3);
int sub_8F0AB(FILE* a1, int a2, int a3);
HSAMPLE* sub_8F100_sound_proc19(Bit32u a1, __int16 a2, int a3, int a4, unsigned __int16 a5, char a6, unsigned __int8 a7);
void sub_8F420_sound_proc20(int a1, __int16 a2);
int sub_8F4B0(); // weak
void sub_8F710_sound_proc21(int a1, __int16 a2, signed int a3, unsigned __int8 a4, char a5);
void sub_8F850_sound_proc22();
void sub_8F8B0_draw_bitmap320(Bit16s posx, Bit16s posy, posistruct temppstr);
void sub_8F8E8_draw_bitmap640(Bit16s posx, Bit16s posy, posistruct temppstr);
// void sub_8F920(__int16 a1, signed int a2, int a3, char *a4, unsigned __int8 a5, char a6);
// void sub_8F935_bitmap_draw_final(__int16 a1, signed int a2, int a3, char *a4, unsigned __int8 a5, char a6);
void sub_90164(Bit16u a1, Bit16u a2, Bit16u a3, Bit16u a4, Bit8u a5);
void sub_901E4(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, unsigned __int16 a5);
int sub_9025C(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int16 a5, __int16 a6);
int sub_90374(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int16 a5, __int16 a6);
void sub_90478_VGA_Blit320();
char sub_904C0(float a1);
unsigned __int8 sub_90530(int a1, int a2, float a3);
int sub_905EC_any_graphics_command2(char a1);
signed int sub_90668(int a1);
int sub_906B4();
int sub_90810();
void sub_90B27_VGA_pal_fadein_fadeout(Bit8u* a1, Bit8u shadow_levels, bool a3);
void sub_90D27();
char* sub_90D3F_unload_file_array(int a1);
void sub_90D6E_VGA_set_video_mode_320x200_and_pallette(Bit8u* pallette);
void sub_90E07_VGA_set_video_mode_640x480_and_pallette(Bit8u* pallette);
int sub_90EA0(int a1, char* a2);
int sub_90EE0();
int sub_90F20_restore_old_directory();
int sub_90F60();
__int16 /*__fastcall*/ sub_90FD0(char* a1/*, int a2, char* a3*/);
__int16 sub_91010();
int sub_91420();
void sub_915A0_sound_proc23();
signed int sub_916F0_sound_proc24();
signed int sub_919C0();
int sub_91A80_AIL_set_preference(Bit32u number, Bit32s value);
void sub_91BD0_s_plus();
void sub_91BF0_s_minus();
Bit16u sub_A121D_AIL_API_get_real_vect(Bit32u vectnum/*int a1, __int16 a2, int a3, int a4*/);
// int sub_91C10_AIL_get_real_vect(__int16 a1, int a2, int a3, int a4);
void sub_91D50_AIL_set_real_vect(Bit32u vectnum, Bit16u real_ptr);
void sub_91E90_AIL_restore_USE16_ISR(Bit32s a1);


//int sub_91F70_AIL_call_driver(Bit32s* a1, int a2, x_WORD *a3, x_WORD *a4);
void sub_920D0_AIL_delay(int a1);
int sub_92160();
int sub_92190_AIL_read_INI(AIL_INI* INI, char* filename/*, char* a8, IO_PARMS IO*/);
HTIMER sub_92600_AIL_register_timer(AILTIMERCB callback_fn);
signed __int32 sub_92740_AIL_set_timer_user(int a1, signed __int32 a2);
//void sub_92890_AIL_set_timer_period(int a1, int a2);
void sub_92890_AIL_set_timer_period(HTIMER timer, Bit32u microseconds);
//void sub_92930_AIL_set_timer_frequency(int a1, unsigned int a2);
void sub_92930_AIL_set_timer_frequency(HTIMER timer, Bit32u hertz);
void sub_92BA0_AIL_start_timer(HTIMER a1);
void sub_92CB0_AIL_stop_timer(HTIMER a1);
void sub_92DC0_AIL_release_timer_handle(Bit32s a1);
void sub_92E50_AIL_release_all_timers();
IO_PARMS* sub_92ED0_AIL_get_IO_environment(AIL_DRIVER* drvr);
// x_DWORD *sub_93010_AIL_install_driver(int a1, int a2, int a3);
int sub_93160_AIL_uninstall_driver(AIL_DRIVER* a1);
// int sub_931F0_AIL_install_DIG_INI(int a1, int **a2);
// int *sub_93330_AIL_install_DIG_driver_file_AIL_install_DIG_driver_file(int a1, int a2, const void *a3);
int sub_93480_AIL_uninstall_DIG_driver(unsigned int *a1);
HSAMPLE sub_93510_AIL_allocate_sample_handle(HDIGDRIVER a1);
int sub_937A0_AIL_release_sample_handle(int a1);
void sub_93830_AIL_init_sample(HSAMPLE a1);
//signed int sub_938C0_AIL_set_sample_file(x_DWORD *a1, int a2, int a3);
Bit32s sub_938C0_AIL_set_sample_file(HSAMPLE S, Bit8u* file_image, Bit32s block);
void sub_93A10_AIL_set_sample_address(HSAMPLE S, Bit8u* start, Bit32u len);
void sub_93AB0_AIL_set_sample_type(x_DWORD *a1, int a2, int a3);
void sub_93B50_AIL_start_sample(HSAMPLE S);
void sub_93D00_AIL_end_sample(HSAMPLE S);
void sub_93D90_AIL_set_sample_playback_rate(HSAMPLE S, Bit32s playback_rate);
void sub_93E30_AIL_set_sample_volume(HSAMPLE S, Bit32s volume);
void sub_93ED0_AIL_set_sample_volume_pan(HSAMPLE S, Bit32s volume);
void sub_93F70_AIL_set_sample_loop_count(HSAMPLE S, int loop_count);
Bit32u sub_94010_AIL_sample_status(HSAMPLE S);
void sub_94650_AIL_set_digital_master_volume(x_DWORD *a1, int a2);
EOS_callback_type sub_95140_AIL_register_EOS_callback(HSAMPLE a1, EOS_callback_type a2);
void sub_953E0_AIL_set_sample_user_data(HSAMPLE S, int a2, int a3);
int sub_95480_AIL_sample_user_data(HSAMPLE S, int a2);
// int sub_95710_AIL_install_MDI_INI(int a1, int **a2);
// int *sub_95850_AIL_install_MDI_driver_file(int a1, int a2, const void *a3);
int sub_959A0_AIL_uninstall_MDI_driver(HMDIDRIVER  mdi);
HSEQUENCE sub_95A30_AIL_allocate_sequence_handle(HMDIDRIVER mdi);
Bit32s sub_95C00_AIL_init_sequence(HSEQUENCE S, Bit8u* start, Bit32s sequence_num, Bit32u track);
void sub_95D50_AIL_start_sequence(HSEQUENCE S, Bit32u track);
void sub_95DE0_AIL_stop_sequence(HSEQUENCE S);
void sub_95E70_AIL_resume_sequence(HSEQUENCE S);
void sub_95F00_AIL_end_sequence(HSEQUENCE S);
void sub_96030_AIL_set_sequence_volume(HSEQUENCE S, Bit32s volume, Bit32s milliseconds);
int sub_96170_AIL_sequence_status(HSEQUENCE S);
void sub_96670_AIL_set_XMIDI_master_volume(HMDIDRIVER mdi, Bit32s master_volume);
Bit32s sub_969A0_AIL_MDI_driver_type(HMDIDRIVER mdi);
void sub_96AE0_AIL_set_GTL_filename_prefix(Bit8u* a1);
int sub_97330_AIL_sequence_position(x_DWORD *a1, x_DWORD *a2, x_DWORD *a3);
x_DWORD *sub_97480_AIL_branch_index(HSEQUENCE S, int a2);
xCALLBACK sub_97670_AIL_register_trigger_callback(HSEQUENCE S, xCALLBACK a2);
int sub_97A60_AIL_register_event_callback(int a1, int a2);
int sub_97BB0_AIL_register_timbre_callback(int a1, int a2);
int sub_97F90_AIL_lock_channel(x_DWORD *a1);
int sub_980D0_AIL_release_channel(x_DWORD *a1, int a2);
int sub_98170_AIL_map_sequence_channel(x_DWORD *a1, int a2, int a3);
void sub_98360_AIL_send_channel_voice_message(HMDIDRIVER mdi, HSEQUENCE S, Bit32s status, Bit32s data_1, Bit32s data_2);
bool sub_986A0_unlock_linear_region();
void sub_986E0();
void sub_98709_create_index_dattab_power(Bit8u* a1, Bit8u* a2, Bit8u* a3, posistruct* a4);
void sub_9874D_create_index_dattab(Bit8u* a1, Bit8u* a2, Bit8u* a3, posistruct* a4);
long j___clock(); // weak
void sub_98790(unsigned __int16 a1, unsigned __int8 a2);
// x_DWORD x_toupper(x_DWORD); weak
FILE* sub_98817_open(char* path, int __pmode);
int sub_98882_close(FILE* a1);
size_t sub_988A7_read(FILE* a1, Bit8u* a2, int a3);
// x_DWORD filelength(x_DWORD); weak
int sub_9891E_seek(FILE* filedesc, int position, char type);
int sub_9894C_decompress(Bit8u* a1, Bit8u* a2);
// char sub_98AE0_blong(int *a1);
// __int16 sub_98AE9(__int16 *a1, int a2);
// __int16 sub_98B2C(unsigned __int8 a1, int a2);
// char sub_98BAF_read_huftable(int a1);
signed int sub_98C48_open_nwrite_close(char* file, Bit8u* buffer, Bit32u count);
size_t sub_98CAA_write(FILE* a1, Bit8u* a2, Bit32u a3);
// x_DWORD access(x_DWORD, x_DWORD); weak
// x_DWORD mkdir(x_DWORD); weak
// x_DWORD int386(x_DWORD, x_DWORD, x_DWORD); weak
// int _sigfpe_handler(); weak
// x_DWORD signal(x_DWORD, x_DWORD); weak
// x_DWORD stricmp(x_DWORD, x_DWORD); weak
// x_DWORD unknown_libname_1_atoi(x_DWORD); weak
//int sub_98FF5_atoi(char *a1);
// void /*__noreturn*/ exit(int status); idb
void sub_99080(char a1);
int sub_9937E_set_video_mode(__int16 a1);
int sub_994BA_cursor_move(__int16 a1);
signed int sub_9951B(__int16 a1);
int sub_995B0_test_vga_driver();
// x_DWORD strncmp(x_DWORD, x_DWORD, x_DWORD); weak
// x_DWORD fgetc(x_DWORD); weak
void sub_99830(Bit32u user); // weak
void sub_99970(char a1, unsigned __int8 a2);
void sub_99A77_create_index_dattab_div(Bit8u* a1, Bit8u* a2, Bit8u* a3, posistruct* a4);
void sub_99AEB_create_index_dattab_minus(Bit8u* a1, Bit8u* a2, Bit8u* a3, posistruct* a4);
// x_DWORD strnicmp(x_DWORD, x_DWORD, x_DWORD); weak
// x_DWORD dos_getvect(x_DWORD); weak
// x_DWORD dos_setvect(x_DWORD, x_DWORD, x_DWORD); weak
void sub_99C10_sound_proc4();
void sub_99C90();
// x_DWORD strcpy(x_DWORD, x_DWORD); weak
// x_DWORD strlen(x_DWORD); weak
// x_DWORD strcat(x_DWORD, x_DWORD); weak
// x_DWORD memcpy(x_DWORD, x_DWORD, x_DWORD); weak
// x_DWORD segread(x_DWORD); weak
// x_DWORD int386x(x_DWORD, x_DWORD, x_DWORD, x_DWORD); weak
// x_DWORD getenv(x_DWORD); weak
signed int sub_99E8E(unsigned __int8 *a1, unsigned __int8 **a2, signed int a3, int a4);
signed int sub_99FF0(char* a1, unsigned __int8 **a2, signed int a3);
int sub_99FF5(unsigned __int8 a1);
// x_DWORD strcmp(x_DWORD, x_DWORD); weak
void sub_9A0FC_wait_to_screen_beam();
signed int /*__fastcall*/ sub_9A10A_check_keyboard();
x_DWORD j___delay(x_DWORD); // weak
void sub_9A128_copy_screen_320(void* source, void* desc, Bit16u countlines);
void sub_9A144_copy_screen_640(void* source, void* desc, Bit16u countlines);
// x_DWORD unknown_libname_2_findfirst(x_DWORD, x_DWORD, x_DWORD); weak
// x_DWORD unknown_libname_3(x_DWORD); weak
// int unknown_libname_4(x_DWORD); weak
// x_DWORD _strupr_s(x_DWORD); weak
int sub_9A230_set_x_WORD_E37B4(int a1);
Bit8u* sub_9A2F5(Pathstruct path);
signed int sub_9A32D_malloc_open_unpack(Pathstruct a1);
// x_DWORD gets(x_DWORD); weak
// x_DWORD tell(x_DWORD); weak
// x_DWORD malloc(x_DWORD); weak
// x_DWORD expand(x_DWORD, x_DWORD); weak
// x_DWORD qsort(x_DWORD, x_DWORD, x_DWORD, x_DWORD); weak
int sub_9AD16_free_mem_pool(void* a1);
int sub_9AD9C(int a1);
int sub_9ADB4(int a1);
int /*__fastcall*/ j_j___clock(x_DWORD, x_DWORD, x_DWORD); // weak
// bool sub_9AE04(int eax0, int edx0, int a3, int a1, int a2);
// char sub_9AE90(int eax0, int edx0, int ebx0, int *a1, x_BYTE *a2, int a3, int a4);
void sub_9AEEC(x_DWORD **a1, char *a2);
// char sub_9AFC4(int a1, int a2, int a3, int *a4, int a5);
char sub_9B038(int *a1, char *a2, int a3);
int sub_9B234(int *a1);
signed int sub_9B260(x_DWORD **a1);
char sub_9B274(int *a1, int a2);
char *sub_9B498(char a1);
// double /*__fastcall*/ _CHP(x_DWORD); weak
// x_DWORD calloc(x_DWORD, x_DWORD); weak
bool sub_9B540_lock_linear_mem_region(unsigned int a1, unsigned int a2);
bool sub_9B5B4_unlock_mem_region(unsigned int a1, unsigned int a2);
void sub_9B628();
int sub_9B63C(int a1);
x_WORD *sub_9B688(int a1);
int sub_9B7E8(int a1);
// void /*__noreturn*/ sub_9BA00(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
// void /*__noreturn*/ sub_9BA2C(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
// void /*__noreturn*/ sub_9BA58(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
// void /*__noreturn*/ sub_9BA84(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void sub_9BAB0();
int sub_9BAC4(int a1, signed int a2);
int sub_9BBFC_unlock_and_free_memory(int a1);
signed int sub_9BC68_allocate_and_lock_memory(x_WORD *a1, int a2, unsigned int a3);
signed int sub_9BD28_allocate_and_lock_memory2(int a1);
int sub_9BE18(int a1, int a2, char a3, unsigned int a4, unsigned int a5);
int sub_9C58C(int a1);
signed int sub_9C810(x_DWORD *a1, char a2);
signed int sub_9C938(x_DWORD *a1);
bool sub_9C9D0(int a1);
void sub_9CBBC(x_DWORD *a1);
int sub_9CCB4(int a1, int a2);
int sub_9CCF8(int a1, int a2);
int sub_9CD9C(int a1, int a2);
// x_DWORD strtod(x_DWORD, x_DWORD); weak
// x_DWORD _set_errno(x_DWORD); weak
__int16 /*__fastcall*/ sub_9D31C(__int16 result);
int sub_9D380(int a1, int a2, char a3, int a4, int a5);
//void (*sub_9D3F0_set_malloc_type(void* (*a1)(size_t size)))(size_t);
//void* (*sub_9D3F0_set_malloc_type(void* (*a1)(size_t size)))(size_t);
//int (*sub_9D420(int (*a1)(int)))(int);
//int(*sub_9D420(int(*a1)(void*)))(void*);
Bit8u* sub_9D450_malloc4(int a1);
int sub_9D490_free4(void* a1, int a2);
signed int sub_9D4D0(int a1, Bit8u* a2, Bit32u* a3, Bit32u* a4);
void sub_9D560(Bit8u* a1);
void sub_9D590_lock_linear_region(Bit8u* a1, unsigned int a2);
bool sub_9D650(unsigned int a1, unsigned int a2);
void sub_9D710(Bit8u* a1, int a2);
bool sub_9D740(unsigned int a1, int a2);
int sub_9D770(char* a1, char a2);
signed int sub_9DE20_get_file_lenght(char* a1);
Bit8u* sub_9DEA0_read_file(char* a1, Bit8u* a2);
// x_DWORD sscanf(x_DWORD, x_DWORD, char); weak
void sub_9E1B0();
void sub_9E250(Bit32u user); // weak
int sub_9E2B0(char* a1, int a2, x_DWORD *a3);
//int sub_9E3A0_AIL_API_read_INI(Bit8u* a1, char* a2);
int sub_9E3A0_AIL_API_read_INI(AIL_INI* INI, char* filename/*, char* a8, IO_PARMS* IO*/);
int sub_9E6E0_set_preference(Bit32u number, Bit32s value);
// x_DWORD *sub_9E720_AIL_API_install_driver(int a1, int a2, int a3);
AIL_DRIVER* sub_9E720_AIL_API_install_driver(/*int a1, */Bit8u* driver_image, Bit32s n_bytes);//27f720
int sub_9EA60_AIL_API_uninstall_driver(AIL_DRIVER* a1);
IO_PARMS* sub_9EB60_AIL_API_get_IO_environment(AIL_DRIVER *drvr);
void sub_9EC30();
signed int sub_9ED70();
bool sub_9EDD0();
int sub_9EE70(); // weak
void sub_9F040();
signed __int64 sub_9F110(int a1);
int sub_9F170(int a1, unsigned __int16 a2);
int sub_9F1D0(int a1);
int sub_9F220(int a1);
int sub_9F280(int *a1);
VDI_CALL sub_9F2E0(int *a1, int a2, unsigned __int16 a3, unsigned __int16 a4);
__int64 sub_9F3D0(int *a1, int a2, unsigned __int16 a3, unsigned __int16 a4);
VDI_CALL sub_9F4F0(int *a1, int a2, unsigned __int16 a3, unsigned __int16 a4);
VDI_CALL sub_9F5E0(int *a1, int a2, unsigned __int16 a3, unsigned __int16 a4);
VDI_CALL sub_9F6D0(int *a1, __int16 a2);
void sub_9F740(char* a1);
void sub_9FA80();
// x_DWORD open(x_DWORD, x_DWORD);
// x_DWORD sopen(x_DWORD, x_DWORD, char);
// x_DWORD close(x_DWORD); weak
// x_DWORD read(x_DWORD, x_DWORD, x_DWORD); weak
// double IF_DPOW(double, double); weak
int sub_A0B24(int a1);
int sub_A0BB0(int *a1, int a2);
// x_DWORD abs(x_DWORD); weak
void sub_A0D2C_VGA_get_pallette(Bit8u* a1);
void sub_A0D50_set_viewport(__int16 a1, __int16 a2, __int16 a3, __int16 a4);
// x_DWORD chdir(x_DWORD); weak
// x_DWORD getcwd(x_DWORD, x_DWORD); weak
// x_DWORD free(x_DWORD); weak
// x_DWORD outp(x_DWORD, char); weak
// x_DWORD inp(x_DWORD); weak
void sub_A0EF9_s_minus2();
// int sub_A0F06(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
char sub_A102C(int a1);
char sub_A105C(unsigned int a1);
void sub_A108F();
void sub_A10F4_sound_proc_irq();
signed int sub_A11E2();
void sub_A1249_AIL_API_set_real_vect(Bit32u vectnum, Bit16u real_ptr);
signed int sub_A12C5_sound_proc_irq(int a1, int a2, __int16 a3);
void sub_A14DB_AIL_API_restore_USE16_ISR(int a1);
unsigned int sub_A1520();
void sub_A1524(unsigned int a1);
//int sub_A158B_AIL_API_call_driver(Bit32s* drvr, __int16 a2, x_WORD *a3, x_WORD *a4);
Bit32s sub_A158B_AIL_API_call_driver(AIL_DRIVER* drvr, Bit32s fn, VDI_CALL* in, VDI_CALL* out);
void sub_A1665_AIL_API_delay(int a1);
int sub_A16A2();
//unsigned int sub_A16AE_register_timer(int a1);
HTIMER sub_A16AE_register_timer(AILTIMERCB callback_fn);
signed __int32 sub_A16F5_AIL_API_set_timer_user(int a1, signed __int32 a2);
void sub_A171D_release_timer_handle(Bit32s a1);
void sub_A1744_AIL_API_release_all_timers();
void sub_A1768_start_timer(HTIMER timer);
void sub_A1798();
void sub_A17BC_stop_timer(HTIMER timer);
void sub_A17EC();
//void sub_A1810_set_timer_period(int a1, int a2);
void sub_A1810_set_timer_period(HTIMER timer, Bit32u microseconds);
//void sub_A1840_AIL_API_set_timer_frequency(int a1, unsigned int a2);
void sub_A1840_AIL_API_set_timer_frequency(HTIMER timer, Bit32u hertz);
void sub_A1870(int a1, unsigned int a2);
int sub_A18B2();
void sub_A18BE();
// x_DWORD fprintf(x_DWORD, const char *, ...); weak
// x_DWORD fopen(x_DWORD, x_DWORD); weak
// x_DWORD fclose(x_DWORD); weak
void sub_A1F90();
void sub_A2070(HDIGDRIVER a1);
void sub_A20D0(HDIGDRIVER a1);
void sub_A2110(HSAMPLE S);
void sub_A2450(Bit32u user); // weak
int sub_A2650(HDIGDRIVER a1);
int sub_A2C80(HDIGDRIVER a1, IO_PARMS* a2);
int sub_A2DE0(); // weak
HDIGDRIVER sub_A2EA0(AIL_DRIVER* a1, IO_PARMS IO);
// int *sub_A3600_AIL_API_install_DIG_driver_file(int a1, int a2, const void *a3);
// int *sub_A36B0(int a1, int a2, int a3, const void *a4);
// int sub_A3720_AIL_API_install_DIG_INI(int a1, int **a2);
int sub_A37A0(unsigned int *a1);
int sub_A37C0(int a1);
HSAMPLE sub_A3820_allocate_sample_handle(HDIGDRIVER dig);
int sub_A38C0_AIL_API_release_sample_handle(int a1);
void sub_A38E0_init_sample(HSAMPLE S);
Bit32u sub_A3A00_sample_status(HSAMPLE S);
void sub_A3A30_set_sample_address(HSAMPLE S, Bit8u* start, Bit32u len);
void sub_A3A70_set_sample_type(HSAMPLE S, Bit32s a2, Bit32u a3);
int sub_A3AC0(int a1);
void sub_A3AF0_set_sample_playback_rate(HSAMPLE S, Bit32s playback_rate);
Bit32s sub_A3B10_get_sample_volume(HSAMPLE S);
void sub_A3B40_set_sample_volume(HSAMPLE S, Bit32s volume);
Bit32s sub_A3B80_get_sample_volume_pan(HSAMPLE S);
void sub_A3BB0_set_sample_volume_pan(HSAMPLE S, Bit32s volume);
int sub_A3BF0(HSAMPLE S);
int sub_A3C30(HSAMPLE S, int a2);
signed int sub_A3C60_get_sample_loop_count(HSAMPLE S);
void sub_A3C90_set_sample_loop_count(HSAMPLE S, Bit32s loop_count);
void sub_A3CB0_API_AIL_start_sample(HSAMPLE S);
void sub_A3D30(HSAMPLE S);
void sub_A3D60(HSAMPLE S);
void sub_A3DA0__API_AIL_end_sample(HSAMPLE S);
int sub_A3E10(HSAMPLE S, int a2);
int sub_A3E60(HSAMPLE S, int a2);
EOS_callback_type sub_A3EB0_register_EOS_callback(HSAMPLE S, EOS_callback_type EOS);
void sub_A3F00_set_sample_user_data(HSAMPLE S, int a2, int a3);
int sub_A3F30_sample_user_data(HSAMPLE S, int index);
void sub_A3F70_set_digital_master_volume(x_DWORD *a1, int a2);
int sub_A3FE0(int a1);
char sub_A4000(x_DWORD *a1, int a2, unsigned int a3);
void sub_A4100(int *a1, int a2, int a3, int a4);
signed int sub_A41B0(x_DWORD *a1);
bool sub_A4260();
void sub_A4330();
int sub_A4370(x_DWORD *a1);
int sub_A4390(int a1);
void sub_A43E0(int a1);
int sub_A47A0(); // weak
void sub_A47C0_sub_set_sample_file(Bit8u* file_image, HSAMPLE S);
int sub_A4920(); // weak
HSAMPLE sub_A4970(int a1, Bit8u* a2, int a3);
Bit32s sub_A4B20_set_sample_file(HSAMPLE S, Bit8u* file_image, Bit32s block);
int sub_A4C60(int a1, int a2);
bool sub_A4CB0();
void sub_A4CF0();
signed int sub_A4E10(char a1);
void sub_A4EB0(HMDIDRIVER a1);
void sub_A4F10(HMDIDRIVER a1, char a2, char a3, char a4);
void sub_A4FD0(int a1, int a2, unsigned int a3);
int sub_A5040(x_DWORD *a1);
unsigned int sub_A50A0(int a1);
Bit8u* sub_A50F0(Bit8u* a1, int a2);
int sub_A5210(int a1, char a2, unsigned int a3);
x_DWORD *sub_A5530(int a1, char a2, unsigned int a3, unsigned __int8 a4);
void sub_A5850(HSEQUENCE S, char a2, unsigned int a3, signed int a4, int a5);
void sub_A5E50(HSEQUENCE S);
void sub_A5F30(int *a1, int a2);
void sub_A5FD0(int a1, int a2);
void sub_A6370(HSEQUENCE S);
void sub_A6490(HSEQUENCE S);
void sub_A64C0(HSEQUENCE S);
//void sub_A6530(Bit32u user); // weak
int sub_A6E00_sound_proc25(HMDIDRIVER a1, IO_PARMS* a2);
int sub_A6F30(); // weak
HMDIDRIVER sub_A6FB0_sound_proc26(AIL_DRIVER* a1, IO_PARMS *a2);
// int *sub_A77D0_AIL_API_install_MDI_INI(int a1, int a2, const void *a3);
// int *sub_A7880_sound_proc27(int a1, int a2, int a3, const void *a4);
// int sub_A78F0_AIL_API_install_MDI_INI(int a1, int **a2);
int sub_A7970_AIL_API_uninstall_MDI_driver(HMDIDRIVER mdi);
Bit32s sub_A7990_AIL_API_MDI_driver_type(HMDIDRIVER mdi);
void sub_A7AA0_AIL_API_set_GTL_filename_prefix(Bit8u* a1);
HSEQUENCE sub_A7B30_AIL_API_allocate_sequence_handle(HMDIDRIVER mdi);
void sub_A7BF0_sound_proc33(HSEQUENCE S);
int sub_A7C20_AIL_API_init_sequence(HSEQUENCE S, int a2, int a3);
void sub_A8010_AIL_API_start_sequence(HSEQUENCE S, Bit32u track);
void sub_A8050_AIL_API_stop_sequence(HSEQUENCE S);
void sub_A8180_AIL_API_resume_sequence(HSEQUENCE S);
void sub_A8250_AIL_API_end_sequence(HSEQUENCE S);
int sub_A82A0(int a1, int a2);
void sub_A82C0(x_DWORD *a1, int a2, int a3);
void sub_A8360_AIL_API_set_sequence_volume(HSEQUENCE S, Bit32s volume, Bit32s milliseconds);
int sub_A8410_AIL_API_sequence_status(HSEQUENCE S);
signed int sub_A8440(int a1);
int sub_A8470(int a1);
int sub_A84A0(int a1);
void sub_A84D0_AIL_API_set_XMIDI_master_volume(HMDIDRIVER mdi, Bit32s master_volume);
int sub_A8550(int a1);
int sub_A8570_sound_proc39(int *a1, __int16 a2, __int16 a3);
VDI_CALL sub_A85B0_sound_proc40(int *a1, int a2, int a3);
int sub_A8690_sound_proc41(int *a1, __int16 a2, __int16 a3);
int sub_A86D0_sound_proc42(int *a1, __int16 a2, __int16 a3);
int sub_A8710(int a1);
int sub_A8770(int a1, char a2, unsigned int a3);
int sub_A87C0(int a1, int a2);
int sub_A8830(x_DWORD *a1, x_DWORD *a2, x_DWORD *a3);
x_DWORD *sub_A8900(HSEQUENCE S, int a2);
int sub_A89E0(int a1, int a2);
xCALLBACK sub_A8A20_AIL_API_trigger_callback(HSEQUENCE S, xCALLBACK a2);
int sub_A8A60(int a1, int a2);
int sub_A8AA0(int a1, int a2);
int sub_A8AE0(int a1, int a2);
int sub_A8B20(int a1, int a2);
int sub_A8B60(int a1, int a2, int a3);
int sub_A8B90(int a1, int a2);
int sub_A8BD0(int a1, int a2);
int sub_A8BF0(x_DWORD *a1);
int sub_A8EA0(x_DWORD *a1, int a2);
int sub_A9080(x_DWORD *a1, int a2, int a3);
int sub_A9100(int a1, int a2);
void sub_A9140_AIL_API_send_channel_voice_message(HMDIDRIVER mdi, HSEQUENCE S, Bit32s status, Bit32s data_1, Bit32s data_2);
int sub_A9230(int a1, int a2);
bool sub_A9280();
void sub_A9590();
x_DWORD *sub_A95D0(int a1, char a2, unsigned int a3, unsigned __int8 a4);
x_DWORD *sub_A98D0(x_DWORD *a1, int a2, int a3);
void sub_A9950(int a1, int a2);
void sub_A9A30(int a1, int a2);
int sub_A9C00(); // weak
int sub_A9C50(); // weak
x_DWORD *sub_AA310(int a1, int a2, int a3, signed int a4);
int sub_AA590(int *a1);
bool sub_AA620();
// x_DWORD creat(x_DWORD, x_DWORD); weak
// x_DWORD setmode(x_DWORD, x_DWORD); weak
// x_DWORD lseek(x_DWORD, x_DWORD, char); weak
// x_DWORD write(x_DWORD, x_DWORD, x_DWORD); weak
int /*__fastcall*/ sub_AB610(int a1, x_DWORD *a2);
// x_DWORD x_tolower(x_DWORD); weak
signed int sub_AB9E1_get_file_unpack_size(char* a1);
int sub_AC24B();
signed int sub_AC250(int a1, int a2, int a3, int a4, int a5, x_DWORD *a6, x_DWORD *a7, signed int *a8);
void sub_AC449();
void sub_AC44B();
__int16 sub_AC70E();
void sub_AC7D9();
signed __int16 /*__fastcall*/ sub_AC7F6(int a1, int a2, int a3);
signed __int16 sub_AC843();
signed __int16 sub_AC8DD();
signed __int16 sub_AC918();
void *sub_AC9C3();
void *sub_AC9C9();
// x_DWORD fputc(x_DWORD, x_DWORD); weak
signed int sub_ACB61(int a1, unsigned __int8 *a2, int *a3);
unsigned __int8 *sub_ACD79(unsigned __int8 *a1, int a2);
int sub_ACE56(int a1);
// int sub_ACE8D(x_WORD *a1, int a2, int *a3);
// void sub_ACF1A(x_BYTE *a1, int a2, int *a3);
int *sub_AD033(int a1, int *a2, int a3);
x_BYTE *sub_AD09E(x_BYTE *a1, int a2);
// void sub_AD0E2(x_BYTE *a1, int a2, int *a3, x_BYTE **a4);
void sub_AD1E8(int a1, int *a2);
void sub_AD52B(int a1, int *a2, signed int a3, int a4);
int sub_AD754(signed int a1);
int sub_AD783(int a1);
// x_DWORD fgets(x_DWORD, x_DWORD, x_DWORD); weak
// x_DWORD memmove(x_DWORD, x_DWORD, x_DWORD); weak
// x_DWORD strncpy(x_DWORD, x_DWORD, x_DWORD); weak
// x_DWORD dos_read(x_DWORD, char, x_DWORD, x_DWORD, x_DWORD); weak
int sub_ADC52(x_BYTE *a1);
int sub_AEAF5();
// int sub_AEF40(int a1, x_BYTE *a2, int *a3);
// int sub_AEF51(int a1, x_BYTE *a2, int *a3);
// int sub_AEF5D(int a1, x_WORD *a2, int *a3);
// int sub_AEF7C(int a1, x_WORD *a2, int *a3);
// char sub_AEF90(int a1, x_WORD *a2, int *a3);
// char sub_AEFAF(int a1, x_WORD *a2, int *a3);
// int sub_AEFC3(int a1, x_BYTE *a2, x_BYTE *a3, int *a4);
// int sub_AEFE0(int a1, x_BYTE *a2, x_BYTE *a3, int *a4);
// int sub_AEFF2(int a1, x_BYTE *a2, x_BYTE *a3, int *a4);
// int sub_AF00F(int a1, x_BYTE *a2, x_BYTE *a3, int *a4);
// int sub_AF021(int a1, x_WORD *a2, int *a3);
// int sub_AF035(int a1, x_WORD *a2, int *a3);
// __int16 sub_AF044(int a1, x_WORD *a2, int *a3);
// __int16 sub_AF05A(int a1, x_WORD *a2, int *a3);
// int sub_AF06B(int a1, x_WORD *a2, int *a3);
// int sub_AF08C(int a1, x_WORD *a2, int *a3);
// int sub_AF0A2(int a1, x_WORD *a2, int *a3);
// int sub_AF0C3(int a1, x_WORD *a2, int *a3);
// int sub_AF0D9(int a1, x_WORD *a2, int *a3);
// int sub_AF0FE(int a1, x_WORD *a2, int *a3);
// int sub_AF118(int a1, x_WORD *a2, int *a3);
// int sub_AF13D(int a1, x_WORD *a2, int *a3);
// int sub_AF157(int a1, x_WORD *a2, x_WORD *a3, int *a4);
// int sub_AF17A(int a1, x_WORD *a2, x_WORD *a3, int *a4);
// int sub_AF192(int a1, x_WORD *a2, x_WORD *a3, int *a4);
// int sub_AF1B5(int a1, x_WORD *a2, x_WORD *a3, int *a4);
// int sub_AF1CD(int a1, x_WORD *a2, x_WORD *a3, int *a4);
// int sub_AF1F4(int a1, x_WORD *a2, x_WORD *a3, int *a4);
// int sub_AF210(int a1, x_WORD *a2, x_WORD *a3, int *a4);
// int sub_AF237(int a1, x_WORD *a2, x_WORD *a3, int *a4);
// int sub_AF253(int a1, x_BYTE *a2, signed int *a3);
// signed int sub_AF280(int a1, x_BYTE *a2, signed int *a3);
// int sub_AF2A8(int a1, x_WORD *a2, signed int *a3);
// signed int sub_AF301(int a1, x_WORD *a2, signed int *a3);
// char sub_AF34F(int a1, x_WORD *a2, signed int *a3);
// char sub_AF3A8(int a1, x_WORD *a2, signed int *a3);
// int sub_AF3F6(int a1, x_BYTE *a2, x_BYTE *a3, signed int *a4);
// signed int sub_AF44D(int a1, x_BYTE *a2, x_BYTE *a3, signed int *a4);
// int sub_AF499(int a1, x_BYTE *a2, x_BYTE *a3, signed int *a4);
// signed int sub_AF4F0(int a1, x_BYTE *a2, x_BYTE *a3, signed int *a4);
// int sub_AF53C(int a1, x_WORD *a2, signed int *a3);
// signed int sub_AF56C(int a1, x_WORD *a2, signed int *a3);
// __int16 sub_AF597(int a1, x_WORD *a2, signed int *a3);
// __int16 sub_AF5C9(int a1, x_WORD *a2, signed int *a3);
// int sub_AF5F6(int a1, x_WORD *a2, signed int *a3);
// signed int sub_AF651(int a1, x_WORD *a2, signed int *a3);
// int sub_AF6A1(int a1, x_WORD *a2, signed int *a3);
// signed int sub_AF6FC(int a1, x_WORD *a2, signed int *a3);
// int sub_AF74C(int a1, x_WORD *a2, signed int *a3);
// __int16 sub_AF7AB(int a1, x_WORD *a2, signed int *a3);
// int sub_AF7FF(int a1, x_WORD *a2, signed int *a3);
// __int16 sub_AF85E(int a1, x_WORD *a2, signed int *a3);
// int sub_AF8B2(int a1, x_WORD *a2, x_WORD *a3, signed int *a4);
// signed int sub_AF90F(int a1, x_WORD *a2, x_WORD *a3, signed int *a4);
// int sub_AF961(int a1, x_WORD *a2, x_WORD *a3, signed int *a4);
// signed int sub_AF9BE(int a1, x_WORD *a2, x_WORD *a3, signed int *a4);
// int sub_AFA10(int a1, x_WORD *a2, x_WORD *a3, signed int *a4);
// __int16 sub_AFA71(int a1, x_WORD *a2, x_WORD *a3, signed int *a4);
// int sub_AFAC7(int a1, x_WORD *a2, x_WORD *a3, signed int *a4);
// __int16 sub_AFB28(int a1, x_WORD *a2, x_WORD *a3, signed int *a4);
// int sub_AFB7E(int result, x_DWORD *a2, x_BYTE *a3);
// int sub_AFB9F(int result, x_DWORD *a2, x_BYTE *a3);
// int sub_AFBC3(int result, __int16 a2, x_DWORD *a3, x_BYTE *a4);
// int sub_AFBF5(int result, __int16 a2, x_DWORD *a3, x_BYTE *a4);
// __int16 sub_AFC27(x_DWORD *a1, x_WORD *a2);
// __int16 sub_AFC4B(x_DWORD *a1, x_WORD *a2);
// __int16 sub_AFC72(x_DWORD *a1, x_WORD *a2);
// __int16 sub_AFCA6(x_DWORD *a1, x_WORD *a2);
// __int16 sub_AFCDA(__int16 result, x_DWORD *a2, x_BYTE *a3);
// __int16 sub_AFCF6(__int16 result, x_DWORD *a2, x_BYTE *a3);
// __int16 sub_AFD15(__int16 result, __int16 a2, x_DWORD *a3, x_BYTE *a4);
// __int16 sub_AFD3C(__int16 result, __int16 a2, x_DWORD *a3, x_BYTE *a4);
// __int16 sub_AFD63(x_DWORD *a1, __int16 *a2);
// __int16 sub_AFD82(x_DWORD *a1, __int16 *a2);
// __int16 sub_AFDA4(x_DWORD *a1, __int16 *a2);
// __int16 sub_AFDCD(x_DWORD *a1, __int16 *a2);
// int sub_AFDF6(int result, unsigned int a2, x_DWORD *a3, x_BYTE *a4);
// int sub_AFE22(int result, unsigned int a2, x_DWORD *a3, x_BYTE *a4);
// int sub_AFE51(int result, unsigned int a2, __int16 a3, x_DWORD *a4, x_BYTE *a5);
// int sub_AFE91(int result, unsigned int a2, __int16 a3, x_DWORD *a4, x_BYTE *a5);
// __int16 sub_AFED1(unsigned int a1, x_DWORD *a2, x_WORD *a3);
// __int16 sub_AFF03(unsigned int a1, x_DWORD *a2, x_WORD *a3);
// __int16 sub_AFF38(unsigned int a1, x_DWORD *a2, x_WORD *a3);
// __int16 sub_AFF7A(unsigned int a1, x_DWORD *a2, x_WORD *a3);
// __int16 sub_AFFBC(__int16 result, unsigned int a2, x_DWORD *a3, x_BYTE *a4);
// __int16 sub_AFFE3(__int16 result, unsigned int a2, x_DWORD *a3, x_BYTE *a4);
// __int16 sub_B000D(__int16 result, unsigned int a2, __int16 a3, x_DWORD *a4, x_BYTE *a5);
// __int16 sub_B0042(__int16 result, unsigned int a2, __int16 a3, x_DWORD *a4, x_BYTE *a5);
// __int16 sub_B0077(unsigned int a1, x_DWORD *a2, __int16 *a3);
// __int16 sub_B00A4(unsigned int a1, x_DWORD *a2, __int16 *a3);
// __int16 sub_B00D4(unsigned int a1, x_DWORD *a2, __int16 *a3);
// __int16 sub_B010B(unsigned int a1, x_DWORD *a2, __int16 *a3);
// char sub_B0142(int a1, int a2, x_DWORD *a3, x_BYTE *a4);
// char sub_B015E(int a1, int a2, x_DWORD *a3, x_BYTE *a4);
// char sub_B0184(int a1, int a2, int a3, x_DWORD *a4, x_BYTE *a5);
// char sub_B01AE(int a1, int a2, int a3, x_DWORD *a4, x_BYTE *a5);
// char sub_B01D9(int a1, int a2, int a3, x_DWORD *a4, x_BYTE *a5);
// char sub_B0203(int a1, int a2, int a3, x_DWORD *a4, x_BYTE *a5);
// int sub_B022E(int result, x_DWORD *a2, x_DWORD *a3, x_WORD *a4);
// int sub_B0258(int result, x_DWORD *a2, x_DWORD *a3, x_WORD *a4);
// int sub_B0292(int result, x_DWORD *a2, x_DWORD *a3, x_WORD *a4);
// int sub_B02D5(int result, x_DWORD *a2, x_DWORD *a3, x_WORD *a4);
// int sub_B0319(int result, x_DWORD *a2, x_DWORD *a3, x_WORD *a4);
// int sub_B035C(int result, x_DWORD *a2, x_DWORD *a3, x_WORD *a4);
// __int16 sub_B03A0(x_DWORD *a1, x_DWORD *a2, __int16 *a3);
// __int16 sub_B03C5(x_DWORD *a1, x_DWORD *a2, __int16 *a3);
// __int16 sub_B03FA(x_DWORD *a1, x_DWORD *a2, __int16 *a3);
// __int16 sub_B0432(x_DWORD *a1, x_DWORD *a2, __int16 *a3);
// __int16 sub_B046B(x_DWORD *a1, x_DWORD *a2, __int16 *a3);
// __int16 sub_B04A3(x_DWORD *a1, x_DWORD *a2, __int16 *a3);
// char sub_B04DC(int a1, int a2, unsigned int a3, x_DWORD *a4, x_BYTE *a5);
// char sub_B0503(int a1, int a2, unsigned int a3, x_DWORD *a4, x_BYTE *a5);
// char sub_B0534(int a1, int a2, unsigned int a3, int a4, x_DWORD *a5, x_BYTE *a6);
// char sub_B056C(int a1, int a2, unsigned int a3, int a4, x_DWORD *a5, x_BYTE *a6);
// char sub_B05A5(int a1, int a2, unsigned int a3, int a4, x_DWORD *a5, x_BYTE *a6);
// char sub_B05DD(int a1, int a2, unsigned int a3, int a4, x_DWORD *a5, x_BYTE *a6);
// int sub_B0616(int result, x_DWORD *a2, unsigned int a3, x_DWORD *a4, x_WORD *a5);
// int sub_B064E(int result, x_DWORD *a2, unsigned int a3, x_DWORD *a4, x_WORD *a5);
// int sub_B0696(int result, x_DWORD *a2, unsigned int a3, x_DWORD *a4, x_WORD *a5);
// int sub_B06E7(int result, x_DWORD *a2, unsigned int a3, x_DWORD *a4, x_WORD *a5);
// int sub_B0739(int result, x_DWORD *a2, unsigned int a3, x_DWORD *a4, x_WORD *a5);
// int sub_B078A(int result, x_DWORD *a2, unsigned int a3, x_DWORD *a4, x_WORD *a5);
// __int16 sub_B07DC(x_DWORD *a1, unsigned int a2, x_DWORD *a3, __int16 *a4);
// __int16 sub_B080F(x_DWORD *a1, unsigned int a2, x_DWORD *a3, __int16 *a4);
// __int16 sub_B0852(x_DWORD *a1, unsigned int a2, x_DWORD *a3, __int16 *a4);
// __int16 sub_B0898(x_DWORD *a1, unsigned int a2, x_DWORD *a3, __int16 *a4);
// __int16 sub_B08DF(x_DWORD *a1, unsigned int a2, x_DWORD *a3, __int16 *a4);
// __int16 sub_B0925(x_DWORD *a1, unsigned int a2, x_DWORD *a3, __int16 *a4);
int sub_B096C(int *a1);
int sub_B0B87(HDIGDRIVER a1, int a2);
void sub_B0C1A(HDIGDRIVER a1);
void sub_B0C46();
char *sub_B0CC8();
void sub_B0CD2();
void sub_B0D52();
void sub_B0D80();
signed int sub_B1138(signed int *a1, signed int a2);
int sub_B11E8(x_DWORD *a1, int a2);
int sub_B12A4(int a1);
int sub_B1304(int a1, int a2);
int sub_B1414(int a1);
int sub_B148C(int a1);
int sub_B14F8(int *a1, int a2);
// char sub_B1C58(__int16 a1, int a2, __int16 a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, __int16 a16);
// char sub_B1D8C(int a1, int a2, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
int sub_B1DC8(); // weak
// char sub_B1E11(int a1, int a2, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// int sub_B1E68(int result, int a2, x_BYTE *a3);
// void sub_B1EB6(int a1);
// void sub_B1EBC(int a1);
// void sub_B1EC2(int a1);
// void sub_B1EC8(int a1);
// void sub_B1ECE(int a1);
// void sub_B1ED6(int *a1);
// void sub_B1EDC(int a1);
// void sub_B1EE2(int a1);
// void sub_B1EE8(int a1, char *a2);
// void sub_B1EF0(int a1, char *a2);
// void sub_B1EF8(int a1, char *a2);
// void sub_B1F00(int a1, char *a2);
// void sub_B1F08(int a1, char *a2);
// void sub_B1F12(int a1, char *a2);
// void sub_B1F1C(int a1, char *a2);
// void sub_B1F24(int a1, char *a2);
// void sub_B1F2C(int a1, x_DWORD *a2);
// void sub_B1F35(int a1, x_DWORD *a2);
// void sub_B1F3E(int a1, x_DWORD *a2);
// void sub_B1F47(int a1, x_DWORD *a2);
// void sub_B1F50(int a1, x_DWORD *a2);
// void sub_B1F5B(int a1, x_DWORD *a2);
// void sub_B1F66(int a1, x_DWORD *a2);
// void sub_B1F6F(int a1, x_DWORD *a2);
// int sub_B1F78(unsigned __int8 a1, unsigned int a2, int a3, x_BYTE *a4);
// int sub_B1FB5(int a1, int a2, signed int *a3);
// int sub_B1FD4(int a1, int a2, signed int *a3);
// char sub_B1FF3(int a1, int a2, signed int *a3, __int16 bx0, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char sub_B200F(int a1, int a2, signed int *a3, int _4, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// int sub_B202B(int a1, int a2, signed int *a3);
// int sub_B204A(int a1, int a2, signed int *a3);
// int sub_B2069(int a1, int a2, signed int *a3);
// int sub_B2088(int a1, int a2, signed int *a3);
// char sub_B20A7(int a1, int a2, signed int *a3, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char sub_B20E1(int a1, int a2, int *a3, __int16 bx0, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char sub_B20F2(int a1, int a2, int *esi0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// char sub_B2103(void *a1, const void *a2, __int16 bx0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// char sub_B2121(int a1, __int16 *a2, __int16 bx0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// char sub_B2161(const void *a1, void *a2, __int16 di0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// char sub_B2175(x_WORD *a1, x_WORD *a2, __int16 bx0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// int sub_B2183(int a1, int a2, int *a3);
// int sub_B21A2(int a1, int a2, int *a3);
// char sub_B21C1(int a1, int a2, int *a3, __int16 bx0, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char sub_B21DD(int a1, int a2, int *esi0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// int sub_B21F9(int a1, int a2, int *a3);
// int sub_B2218(int a1, int a2, int *a3);
// int sub_B2237(int a1, int a2, int *a3);
// int sub_B2256(int a1, int a2, int *a3);
// char sub_B2275(int a1, int a2, int *a3, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char sub_B22AF(x_WORD *a1, int a2, x_DWORD *a3, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char sub_B22EB(int a1, int a2, x_DWORD *esi0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// int sub_B230F(int a1, int a2, __int64 *a3);
// int sub_B2332(int a1, int a2, __int64 *a3);
// char sub_B2355(int a1, int a2, __int64 *a3, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char sub_B2375(int a1, int a2, __int64 *esi0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// int sub_B2395(int a1, int a2, __int64 *a3);
// int sub_B23B8(int a1, int a2, __int64 *a3);
// int sub_B23DB(int a1, int a2, __int64 *a3);
// int sub_B23FE(int a1, int a2, __int64 *a3);
// char sub_B2421(int a1, int a2, int a3, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char sub_B2468(int a1, int a2, __int64 *a3, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char sub_B24A6(x_BYTE *a1, int a2, int *a3, __int16 bx0, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char sub_B24BB(int a1, int a2, int esi0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// char sub_B24D9(int a1, int a2, int *esi0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// char sub_B24EE(x_DWORD *a1, x_DWORD *a2, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// void sub_B2535(char *a1, int a2, x_DWORD *a3);
// char sub_B2560(int a1, x_WORD *a2, __int16 bx0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// int sub_B256E(int a1, int a2, signed __int16 *a3);
// int sub_B258F(int a1, int a2, signed __int16 *a3);
// char sub_B25B0(int a1, int a2, signed __int16 *a3, __int16 bx0, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char sub_B25CE(int a1, int a2, signed __int16 *esi0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// int sub_B25EC(int a1, int a2, signed __int16 *a3);
// int sub_B260D(int a1, int a2, signed __int16 *a3);
// int sub_B262E(int a1, int a2, signed __int16 *a3);
// int sub_B264F(int a1, int a2, signed __int16 *a3);
// char sub_B2670(int a1, int a2, signed __int16 *a3, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char sub_B26AC(x_WORD *a1, int a2, x_WORD *a3, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char sub_B26F4(int a1, int a2, x_WORD *esi0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// char sub_B2729(int a1, int a2, unsigned int *a3, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char sub_B2768(int a1, int a2, int *esi0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
void sub_B2791();
// int sub_B27BE(int a1, int a2, int a3);
// int sub_B27D3(int a1, int a2, int a3);
// char sub_B27E8(int a1, int a2, int a3, __int16 bx0, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char sub_B27FA(int a1, int a2, int esi0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// int sub_B280C(int a1, int a2, int a3);
// int sub_B2821(int a1, int a2, int a3);
// int sub_B2836(int a1, int a2, int a3);
// int sub_B284B(int a1, int a2, int a3);
// char sub_B2860(int a1, int a2, int a3, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char sub_B28A8(int a1, int a2, int a3, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char sub_B2912(int a1, int a2, __int16 bx0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// char sub_B2951(int a1, int a2, int a3, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char sub_B2B6C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, __int16 a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, __int16 a21);
void /*__fastcall*/ sub_B2D8E(int a1, int a2, int a3);
void /*__fastcall*/ sub_B2E17(int a1, int a2, int a3);
// int sub_B2E71(int a1, int a2, int a3);
// int sub_B2E86(int a1, int a2, int a3);
// int sub_B2E9B(int a1, int a2, int a3);
// int sub_B2EB0(int a1, int a2, int a3);
// int sub_B2EC5(int a1, int a2, int a3);
// int sub_B2EDA(int a1, int a2, int a3);
// char sub_B2EEF(int a1, int a2, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// char sub_B2F0E(int a1, int a2, int a3, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char sub_B2F3A(int a1, int a2, int a3, __int16 bx0, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// char sub_B2F4C(int a1, int a2, int esi0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// char sub_B2F5E(int a1, int a2, int esi0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// int sub_B2F8A(int a1, int a2, int a3);
// int sub_B2FD5(int a1, int a2, int a3);
void /*__fastcall*/ sub_B3020(int a1, int a2, int a3);
// int sub_B30A9(int a1, int a2, int a3);
// int sub_B30F4(int a1, int a2, int a3);
// int sub_B313F(int a1, int a2, int a3);
// int sub_B318A(int a1, int a2, int a3);
void sub_B31D5();
void /*__fastcall*/ sub_B336E(int a1, int a2);
// int sub_B337C(int a1, int a2, int a3);
// int /*__userpurge*/ sub_B33A6(int a1, int a2, int a3, int a4, __int16 a5);
// int sub_B33D6(unsigned __int64 a1, int a2, int a3, int a4);
int /*__fastcall*/ sub_B3542(int a1, int a2);
// int sub_B35DB(int a1, int a2, x_BYTE *a3, int a4);
// int sub_B3605(unsigned __int64 a1, int a2, unsigned int a3, x_BYTE *a4, int a5);
// int sub_B37B0(int a1, int a2, int a3);
// int sub_B37DA(unsigned __int64 a1, unsigned int a2, unsigned int a3, int a4);
void sub_B392B();
int /*__fastcall*/ sub_B3930(int *a1);
int /*__fastcall*/ sub_B399A(int a1, int a2);
int /*__fastcall*/ sub_B39AB(unsigned int a1, int a2);
// int sub_B39E0(__int64 a1, int a2, x_BYTE *a3);
int /*__fastcall*/ sub_B3A60(int a1);
// int sub_B3ADF(__int64 *a1, x_BYTE *a2);
signed int /*__fastcall*/ sub_B3BA6(signed int result, int a2);
unsigned int /*__fastcall*/ sub_B3C6B(unsigned int result, signed __int16 a2);
// __int16 sub_B3DF8(int a1, int a2, int a3, x_BYTE *a4, int a5);
// __int16 /*__spoils<ecx>*/ sub_B3EAE(int a1, x_BYTE *a2, int a3);
// int sub_B4011(int a1, int a2, int a3);
// int sub_B4077(__int64 a1, unsigned int a2, unsigned int a3, __int16 a4, __int16 a5);
// int sub_B41E0(int a1, x_BYTE *a2, int a3);
// int sub_B41F9(int a1, x_BYTE *a2, int a3);
// int sub_B423C(int a1, x_BYTE *a2);
// int sub_B44D4(int a1, int a2);
int /*__fastcall*/ sub_B46CB(int a1);
int /*__fastcall*/ sub_B46D5(int a1);
int /*__fastcall*/ sub_B46E2(int a1);
int sub_B46F0(); // weak
int /*__fastcall*/ sub_B4718(int a1, int a2, int a3, int a4);
int /*__fastcall*/ sub_B48EC(unsigned __int64 a1);
// void sub_B49D8(int a1, int a2);
// int sub_B4A2A(int *a1, int a2, int a3);
// int /*__fastcall*/ _hook387(x_DWORD, x_DWORD, x_DWORD); weak
// int _FDFS(void); weak
// x_DWORD fputs(x_DWORD, x_DWORD); weak
// x_DWORD strerror(x_DWORD); weak
void /*__spoils<edx,ecx>*/ sub_B4F46();
void /*__spoils<edx,ecx>*/ sub_B4FA3();
void sub_B5000();
void /*__noreturn*/ sub_B5015();
void /*__noreturn*/ sub_B5022();
// void sub_B5128(__int16 a1, int a2, double *a3, double a4);
// void sub_B51B3(__int16 a1, int a2, double *a3, __int16 a4, double a5);
// double sub_B5205(char a1, int a2, __int16 a3, double a4);
// __int64 sub_B522B(int a1, __int16 a2, int _ESI);
// double sub_B5250(char a1, double *a2, double result);
// int _Phar_hook_init(void); weak
// int _Phar_hook_fini(void); weak
// int _DOS4G_hook_init(void); weak
// int _DOS4G_hook_fini(void); weak
// int _Ergo_hook_init(x_DWORD, x_DWORD); weak
// int _Ergo_hook_fini(x_DWORD); weak
// int _Intel_hook_init(void); weak
// int _Intel_hook_fini(void); weak
int sub_B5C5B();
int sub_B5C60(__int16 a1, __int16 a2);
int sub_B5D68(__int16 a1, __int16 a2);
void /*__spoils<ecx>*/ sub_B5E70_decompress_terrain_map_level(__int16 a1, unsigned __int16 a2, __int16 a3, Bit32s a4);
// __int16 sub_B5EFA(__int16 a1, int a2, int a3, __int16 a4);
// __int16 sub_B5F8F(__int16 a1, int a2, int a3, __int16 a4);
void /*__spoils<ecx>*/ sub_B6253(x_DWORD *a1, x_DWORD *a2, x_DWORD *a3);
void /*__spoils<>*/ sub_BCD45(int a1, int a2, int a3, int a4, int a5);
void /*__spoils<ecx>*/ sub_BD1B6(int a1);
void /*__spoils<ecx>*/ sub_BD2CB(int a1);
// int sub_BD320(int result, x_BYTE *a2, x_BYTE *a3, int a4, int a5, int a6);
void sub_BD3DD();
void sub_BD524(__int16 a1, __int16 a2, __int16 a3, __int16 a4);
void /*__spoils<ecx>*/ sub_BD542(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4, char a5);
// int /*__fastcall*/ gettextposition(x_DWORD, x_DWORD, x_DWORD); weak
// x_DWORD settextposition(x_DWORD, x_DWORD); weak
// x_DWORD outtext(x_DWORD); weak
int sub_BF123();
int /*__far*/ sub_C0000(); // weak

/*
//only for tests
void testopen() {
	sprintf_s(printbuffer, 512, "%c%s", x_D41A0_BYTEARRAY_4_struct.harddisk_number, ":/NETHERW/CONFIG.DAT");
	sub_98817_open(printbuffer, 512);
}
//only for tests
*/
//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_10001; // weak
void *off_1B190 = &loc_1B2E6; // weak
_UNKNOWN loc_20000; // weak
_UNKNOWN loc_2FED1; // weak
_UNKNOWN loc_2FED5; // weak
_UNKNOWN loc_3030E; // weak
_UNKNOWN loc_30325; // weak
_UNKNOWN loc_36479; // weak
_UNKNOWN loc_364D1; // weak
_UNKNOWN loc_3653D; // weak
_UNKNOWN loc_36541; // weak
_UNKNOWN loc_36543; // weak
_UNKNOWN loc_36546; // weak
_UNKNOWN loc_3654B; // weak
_UNKNOWN loc_3654E; // weak
_UNKNOWN loc_36550; // weak
char x_BYTE_3659C[] = { 'f' }; // weak
char x_BYTE_3659D[] = { '\x89' }; // weak
char x_BYTE_3659F[] = { ',' }; // weak
_UNKNOWN loc_365F2; // weak
_UNKNOWN loc_36CAA; // weak
_UNKNOWN loc_36DE9; // weak
_UNKNOWN loc_36DEC; // weak
_UNKNOWN loc_36DFC; // weak
_UNKNOWN loc_36E03; // weak
_UNKNOWN loc_36E09; // weak
_UNKNOWN loc_36F44; // weak
_UNKNOWN loc_3A013; // weak
_UNKNOWN loc_40000; // weak
//_UNKNOWN loc_42471; // weak
_UNKNOWN loc_4AFFE; // weak
Bit8u algn_4BB85[11] = { '\x8D', '\x80', '\0', '\0', '\0', '\0', '\x8D', 'R', '\0', '\x8B', '\0' }; // weak
//Bit8u loc_4D54A[1600000]; // weak
void *off_55C38 = &loc_55CB2; // weak
//_UNKNOWN loc_568AA; // weak
void *off_5B0E4 = &loc_5B1BA; // weak
int(*off_5FA4C[7])() =
{
  &sub_5FA96,
  &sub_5FBB1,
  &sub_5FB09,
  &sub_5FB22,
  &sub_5FB3A,
  &sub_5FB8C,
  &sub_5FBB1
}; // weak
_UNKNOWN loc_5FBBE; // weak
void *off_607E8 = &loc_608FD; // weak
_UNKNOWN loc_64000; // weak
_UNKNOWN loc_712C2; // weak
__int16 x_WORD_727B0[] = { 1 }; // weak
void *off_75628 = &loc_75779; // weak
//_UNKNOWN loc_783BD; // weak
void *off_790E4 = &loc_79404; // weak
void *off_79118 = &loc_79463; // weak
_UNKNOWN loc_7FFFF; // weak
_UNKNOWN loc_87D80; // weak
void *off_88D1C = &loc_88FD9; // weak
//_UNKNOWN loc_917D0; // weak //free
//void *off_91856 = (void *)0x152E9; // weak
//_UNKNOWN loc_91C54; // weak
// extern _UNKNOWN _GETDS; weak
_UNKNOWN loc_9AEE8; // weak
void *off_9B844 = &loc_9B94B; // weak
// extern _UNKNOWN loc_A0000_vga_buffer; weak
int x_DWORD_A1270 = 1397753374; // weak
__int16 x_WORD_A1277 = 39321; // weak
__int16 x_WORD_A1286 = 39321; // weak
int x_DWORD_A128C = 2576980377; // weak
__int16 x_WORD_A12A2 = 39321; // weak
__int16 x_WORD_A12AC = 39321; // weak
__int16 x_WORD_A12B3 = 39321; // weak
void *off_A4400 = &loc_A4459; // weak
int x_DWORD_A9390[] = { 8 }; // weak
_UNKNOWN loc_ACF14; // weak
int(*off_AEB40[2])() = { &sub_AEF40, &sub_AEF51 }; // weak
int(*off_AED40[2])() = { &sub_AFB7E, &sub_AFB9F }; // weak
_UNKNOWN loc_AFFFE; // weak
int x_DWORD_B184C[2] = { 0, 0 }; // weak
void *off_B1854 = &loc_A0000_vga_buffer; // weak
int x_DWORD_B1858[2] = { 70, 0 }; // weak
int x_DWORD_B1860[41] =
{
  20,
  67584,
  1966080,
  268435466,
  2,
  1310760,
  202752,
  3276800,
  536870942,
  4,
  2621500,
  337920,
  4587520,
  805306418,
  6,
  3932160,
  473088,
  4294705152,
  1,
  196610,
  327667,
  524288,
  4291756044,
  16,
  3145760,
  4259647,
  8388608,
  4244570304,
  256,
  50332160,
  67171327,
  134217728,
  3489598464,
  4096,
  805314560,
  1073758207,
  2147483648,
  1073856512,
  33572096,
  50414144,
  3683074881
}; // weak
int(*off_B1904[57])() =
{
  &sub_B1EB6,
  &sub_B1EBC,
  &sub_B1EC2,
  &sub_B1EC8,
  &sub_B1F78,
  &sub_B1ED6,
  &sub_B1EDC,
  &sub_B1EE2,
  &sub_B1EE8,
  &sub_B1EF0,
  &sub_B1EF8,
  &sub_B1F00,
  &sub_B1F78,
  &sub_B1F12,
  &sub_B1F1C,
  &sub_B1F24,
  &sub_B1F2C,
  &sub_B1F35,
  &sub_B1F3E,
  &sub_B1F47,
  &sub_B1F78,
  &sub_B1F5B,
  &sub_B1F66,
  &sub_B1F6F,
  &sub_B1EB6,
  &sub_B1EBC,
  &sub_B1EC2,
  &sub_B1EC8,
  &sub_B1ECE,
  &sub_B1ED6,
  &sub_B1EDC,
  &sub_B1EE2,
  &sub_B1EE8,
  &sub_B1EF0,
  &sub_B1EF8,
  &sub_B1F00,
  &sub_B1F08,
  &sub_B1F12,
  &sub_B1F1C,
  &sub_B1F24,
  &sub_B1F2C,
  &sub_B1F35,
  &sub_B1F3E,
  &sub_B1F47,
  &sub_B1F50,
  &sub_B1F5B,
  &sub_B1F66,
  &sub_B1F6F,
  &sub_B1FB5,
  &sub_B20A7,
  &sub_B2183,
  &sub_B2275,
  &sub_B230F,
  &sub_B2468,
  &sub_B256E,
  &sub_B2670,
  &sub_B1FD4
}; // weak
int(*off_B1964[33])() =
{
  &sub_B1EB6,
  &sub_B1EBC,
  &sub_B1EC2,
  &sub_B1EC8,
  &sub_B1ECE,
  &sub_B1ED6,
  &sub_B1EDC,
  &sub_B1EE2,
  &sub_B1EE8,
  &sub_B1EF0,
  &sub_B1EF8,
  &sub_B1F00,
  &sub_B1F08,
  &sub_B1F12,
  &sub_B1F1C,
  &sub_B1F24,
  &sub_B1F2C,
  &sub_B1F35,
  &sub_B1F3E,
  &sub_B1F47,
  &sub_B1F50,
  &sub_B1F5B,
  &sub_B1F66,
  &sub_B1F6F,
  &sub_B1FB5,
  &sub_B20A7,
  &sub_B2183,
  &sub_B2275,
  &sub_B230F,
  &sub_B2468,
  &sub_B256E,
  &sub_B2670,
  &sub_B1FD4
}; // weak
_UNKNOWN loc_B27B9; // weak
//void *off_B2947 = &unk_17A6E8; // weak
_UNKNOWN loc_B2C44; // weak
int(*off_B2D96)(__int16, __int16, int, int, int, int, int, int, int, int, int, int, int, int, __int16) = &sub_B278C; // weak
int(*off_B2E1F[2])(__int16, __int16, int, int, int, int, int, int, int, int, int, int, int, int, __int16) = { &sub_B278C, &sub_B278C }; // weak
_UNKNOWN loc_B2E4B; // weak
int(*off_B3028)(__int16, __int16, int, int, int, int, int, int, int, int, int, int, int, int, __int16) = &sub_B278C; // weak
_UNKNOWN loc_B335E; // weak
_UNKNOWN loc_B3383; // weak
_UNKNOWN loc_B3933; // weak
_UNKNOWN loc_B39B3; // weak
int x_DWORD_B3BEB[] = { 2147483647 }; // weak
__int16 x_WORD_B3D9E = 6222; // weak
__int16 x_WORD_B419A = 18153; // weak
int x_DWORD_B41B8 = 0; // weak
__int16 x_WORD_B440E[] = { 21337 }; // weak
int x_DWORD_B4468[19] =
{
  2646669455,
  3611270969,
  3909435346,
  2772829156,
  3218786763,
  3334782378,
  2406926207,
  3818340322,
  2109457658,
  3219756018,
  218157069,
  3490513104,
  3054190575,
  1622543200,
  3220551179,
  2863311530,
  2863311530,
  16378,
  0
}; // weak
__int16 x_WORD_B44C2[] = { 0 }; // weak
int x_DWORD_B8845[] = { 0 }; // weak
_UNKNOWN loc_BD550; // weak
char x_BYTE_C0134[3788] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
//char aDataSearchDat[16] = "data/search.dat"; // weak
//char aNoHelpData[13] = "No Help Data"; // weak
//char aOk[4] = "@OK"; // weak
//char aSS[7] = "%s:%s."; // weak
//char aSS_0[8] = "%s. %s."; // weak
//char aSS_1[6] = "%s %s"; // weak
//char aYS[5] = "y_%s"; // weak
//char aSS_2[8] = "[%s] %s"; // weak
//char aD[3] = "%d"; // weak
//char a03d[5] = "%03d"; // weak
//char aOk_0[6] = " * OK"; // weak
//char aNS[5] = "n%s?"; // weak
//char aSound[6] = "sound"; // weak
//char aNetherw[9] = "/netherw"; // weak
//char aSS_3[6] = "%s/%s"; // weak
//char aErrorNotEnough[37] = "ERROR: NOT ENOUGH MEMORY FOR SOUNDS\n"; // weak
//char aDataMwebd00Tab[18] = "data/mwebd0-0.tab"; // weak
//char aDataHwebd00Tab[18] = "data/hwebd0-0.tab"; // weak
//char aDataMwebn00Tab[18] = "data/mwebn0-0.tab"; // weak
//char aDataHwebn00Tab[18] = "data/hwebn0-0.tab"; // weak
//char aDataMwebc00Tab[18] = "data/mwebc0-0.tab"; // weak
//char aDataHwebc00Tab[18] = "data/hwebc0-0.tab"; // weak
//char aDataMsprd00Dat_0[18] = "data/msprd0-0.dat"; // weak
//char aS[3] = "%s"; // weak
//char aDataMsprd00Tab[18] = "data/msprd0-0.tab"; // weak
//char aDataHsprd00Dat_0[18] = "data/hsprd0-0.dat"; // weak
//char aDataHsprd00Tab[18] = "data/hsprd0-0.tab"; // weak
//char aDataMsprn00Dat[18] = "data/msprn0-0.dat"; // weak
//char aDataMsprn00Tab[18] = "data/msprn0-0.tab"; // weak
//char aDataHsprn00Dat[18] = "data/hsprn0-0.dat"; // weak
//char aDataHsprn00Tab[18] = "data/hsprn0-0.tab"; // weak
//char aDataMsprc00Dat[18] = "data/msprc0-0.dat"; // weak
//char aDataMsprc00Tab[18] = "data/msprc0-0.tab"; // weak
//char aDataHsprc00Dat[18] = "data/hsprc0-0.dat"; // weak
//char aDataHsprc00Tab[18] = "data/hsprc0-0.tab"; // weak
//char aDataPald0Dat[16] = "data/pald-0.dat"; // weak
//char aDataClrd0Dat[16] = "data/clrd-0.dat"; // weak
//char aDataPalf0Dat[16] = "data/palf-0.dat"; // weak
//char aDataPaln0Dat[16] = "data/paln-0.dat"; // weak
//char aDataClrn0Dat[16] = "data/clrn-0.dat"; // weak
//char aDataPalc0Dat[16] = "data/palc-0.dat"; // weak
//char aDataClrc0Dat[16] = "data/clrc-0.dat"; // weak
//char aDataSmatitleDa[18] = "data/smatitle.dat"; // weak
//char aDataSmatitl2Da[18] = "data/smatitl2.dat"; // weak
//char aDataSmatitlePa[18] = "data/smatitle.pal"; // weak
//char aDataSmatitl2Pa[18] = "data/smatitl2.pal"; // weak
//char aC[3] = "%c"; // weak
//char aCheatAccessAll[28] = ".. CHEAT: access all spells"; // weak
//char aCheatMoreMana[20] = ".. CHEAT: more mana"; // weak
//char aCheatDestroyAl[30] = ".. CHEAT: destroy all players"; // weak
//char aCheatDestroyAl_0[30] = ".. CHEAT: destroy all castles"; // weak
//char aCheatDestroyAl_1[31] = ".. CHEAT: destroy all balloons"; // weak
//char aCheatHeal[15] = ".. CHEAT: heal"; // weak
//char aCheatKillAllCr[29] = ".. CHEAT: Kill all creatures"; // weak
//char aCheatMoreSpell[39] = ".. CHEAT: More Spell Experience Points"; // weak
//char aCheatFreeSpell[31] = ".. CHEAT: Free Spell Usage OFF"; // weak
//char aCheatFreeSpell_0[30] = ".. CHEAT: Free Spell Usage ON"; // weak
//char aCheatInvincabi[27] = ".. CHEAT: Invincability ON"; // weak
//char aCheatInvincabi_0[28] = ".. CHEAT: Invincability OFF"; // weak
//char aClevels[8] = "clevels"; // weak
//char aNetherw_0[9] = "/netherw"; // weak
//char aCSSLevelsDat[20] = "%c:%s/%s/levels.dat"; // weak
//char aLevelsLevelsDa[18] = "levels/levels.dat"; // weak
//char aCSSLevelsTab[20] = "%c:%s/%s/levels.tab"; // weak
//char aLevelsLevelsTa[18] = "levels/levels.tab"; // weak
//char aErrorDecompres[32] = "ERROR decompressing levels.dat\n"; // weak
//char aMovie[6] = "movie"; // weak
//char aSGam05dDat[15] = "%s/gam%05d.dat"; // weak
//char aSMap05dDat[15] = "%s/map%05d.dat"; // weak
//char aDataBldgprmDat[17] = "data/bldgprm.dat"; // weak
//char aSMvi05dDat[15] = "%s/mvi%05d.dat"; // weak
//char aCS[6] = "%c:%s"; // weak
//char aVe[4] = "ve/"; // weak
//char aErrorDecompres_0[24] = "ERROR decompressing %s\n"; // weak
//char aSSTab[10] = "%s/%s.tab"; // weak
//char aSSDat[10] = "%s/%s.dat"; // weak
//char aDC[5] = "%d%c"; // weak
//char aCheckingSetupV[26] = "Checking Setup Version .."; // weak
//char aVersionDat[12] = "version.dat"; // weak
//char aCdata[6] = "cdata"; // weak
//char aCSSS[12] = "%c:%s/%s/%s"; // weak
//char asc_D0650[2] = "\n"; // weak
//char aTmaps00[9] = "tmaps0-0"; // weak
//char aCSSSDat[16] = "%c:%s/%s/%s.dat"; // weak
//char aDataSDat[12] = "data/%s.dat"; // weak
//char aCreatingSetupD[32] = "Creating Setup Directories 1 .."; // weak
//char aCSS[9] = "%c:%s/%s"; // weak
//char aData[5] = "data"; // weak
//char aTmaps10[9] = "tmaps1-0"; // weak
//char aCreatingSetupD_0[32] = "Creating Setup Directories 2 .."; // weak
//char aTmaps20[9] = "tmaps2-0"; // weak
//char aCreatingSetupD_1[32] = "Creating Setup Directories 3 .."; // weak
//char aSettingUpLevel[21] = "Setting Up Levels .."; // weak
//char aLevels[7] = "levels"; // weak
//char aDataBlock16Dat_0[17] = "data/block16.dat"; // weak
//char aDataSkyd00Dat[17] = "data/skyd0-0.dat"; // weak
//char aDataBlock32Dat_0[17] = "data/block32.dat"; // weak
//char aDataTmaps00Tab[18] = "data/tmaps0-0.tab"; // weak
//char aDataBl16f00Dat[18] = "data/bl16f0-0.dat"; // weak
//char aDataBl16n00Dat[18] = "data/bl16n0-0.dat"; // weak
//char aDataSkyn00Dat[17] = "data/skyn0-0.dat"; // weak
//char aDataBl32f00Dat[18] = "data/bl32f0-0.dat"; // weak
//char aDataBl32n00Dat[18] = "data/bl32n0-0.dat"; // weak
//char aDataTmaps10Tab[18] = "data/tmaps1-0.tab"; // weak
//char aDataBl16c00Dat[18] = "data/bl16c0-0.dat"; // weak
//char aDataBl32c00Dat[18] = "data/bl32c0-0.dat"; // weak
//char aDataTmaps20Tab[18] = "data/tmaps2-0.tab"; // weak
//char aDataTablesdDat[17] = "data/tablesd.dat"; // weak
//char aDataTablesnDat[17] = "data/tablesn.dat"; // weak
//char aDataTablescDat[17] = "data/tablesc.dat"; // weak
//char aSmap[5] = "SMAP"; // weak
//char aSS03dDat[14] = "%s/%s%03d.dat"; // weak
//char aSlev[5] = "SLEV"; // weak
//char aSave[5] = "save"; // weak
//char aCSSSDDat[18] = "%c:%s/%s/%s%d.dat"; // weak
//char aSver[5] = "SVER"; // weak
//char aDeviceNoneDriv[82] = "DEVICE\t\tNone\r\nDRIVER\t\tNone\r\nIO_ADDR\t\t-1\r\nIRQ\t\t-1\r\nDMA_8_BIT\t\t-1\r\nDMA_16_BIT\t\t-1\r\n"; // weak
//char aSound_0[6] = "sound"; // weak
//char aNetherw_1[9] = "/netherw"; // weak
//char aCSSDigIni[17] = "%c:%s/%s/dig.ini"; // weak
//char aCSSMdiIni[17] = "%c:%s/%s/mdi.ini"; // weak
//char aNetwork[8] = "network"; // weak
//char aLevel[6] = "level"; // weak
//char aHarddrive[10] = "harddrive"; // weak
//char aSkipscreens[12] = "skipscreens"; // weak
//char aNocd[5] = "nocd"; // weak
//char aShowversion[12] = "showversion"; // weak
//char aShowversion2[13] = "showversion2"; // weak
//char aDetectoff[10] = "detectoff"; // weak
//char aLangcheck[10] = "langcheck"; // weak
//char aMavio[6] = "MAvio"; // weak
//char aExtern[7] = "extern"; // weak
//char aExternalCtrlAt[22] = "External ctrl at %ul\n"; // weak
//char aVfx1[5] = "VFX1"; // weak
//char aScc[6] = "/%scc"; // weak
//char aSpellsedit[11] = "spellsedit"; // weak
//char aMusic2[7] = "music2"; // weak
//char aErrorCantAlloc[31] = "ERROR: CANT ALLOC TAPE MEMORY."; // weak
//char aErrorCantAlloc_0[33] = "ERROR: CANT ALLOC CARPET MEMORY."; // weak
//char aDataPald0Dat_0[16] = "data/pald-0.dat"; // weak
//char aDataClrd0Dat_0[16] = "data/clrd-0.dat"; // weak
//char aSave_0[5] = "save"; // weak
//char aNetherw_2[9] = "/netherw"; // weak
//char aCdata_0[6] = "cdata"; // weak
//char aClevels_0[8] = "clevels"; // weak
//char aSound_1[6] = "sound"; // weak
//char aLanguage[9] = "language"; // weak
//char aShots[6] = "shots"; // weak
//char aDataSpellsDat[16] = "data/spells.dat"; // weak
//char aErrorMouseDriv[36] = "ERROR : MOUSE DRIVER NOT INSTALLED\n"; // weak
//char aErrorCopyingDa[42] = "ERROR COPYING DATA FILES TO LOCAL DRIVE \n"; // weak
//char aErrorCreatingS[35] = "Error creating setup directories.\n"; // weak
//char aNoVesaDriverDe[25] = "NO VESA DRIVER DETECTED\n"; // weak
//char aNotEnoughMemor[19] = "NOT ENOUGH MEMORY\n"; // weak
//char x_BYTE_D0C18 = '\0'; // weak
//char aTa[5] = "ta/\n"; // weak
//char asc_D0C20[61] = "***********************************************************\n"; // weak
//char aTestersWriteDo[61] = "*   TESTERS: WRITE DOWN THE ABOVE VERSION DATE AND TIME.  *\n"; // weak
//char aPressReturnToC[61] = "*   Press RETURN to continue...                           *\n"; // weak
//char asc_D0CE0[61] = "***********************************************************\n"; // weak
//char aDataGtd2Dat[14] = "data/gtd2.dat"; // weak
//char aProductName[13] = "Product name"; // weak
//char aMagicCarpet2Ne[30] = "Magic Carpet 2 (Netherworlds)"; // weak
//char aVersionNumber[15] = "Version number"; // weak
//char aBeta[5] = "Beta"; // weak
//char aVersionDate[13] = "Version date"; // weak
//char aSep061995[12] = "Sep 06 1995"; // weak
//char a034213[9] = "03:42:13"; // weak
//char aSS_4[6] = "%s %s"; // weak
//char aProgrammer[11] = "Programmer"; // weak
//char aBullfrogAlanWr[23] = "Bullfrog, Alan Wright."; // weak
//char aSuppliedTo[12] = "Supplied to"; // weak
//char aPublic[7] = "PUBLIC"; // weak
//char aLevelNumber[13] = "Level Number"; // weak
//char aApD[6] = "_AP%d"; // weak
//char aTransferRate[15] = "Transfer rate:"; // weak
//char aHfps[5] = "hFPS"; // weak
//char aSoundNumber[13] = "Sound Number"; // weak
//char aGameTurn[10] = "Game turn"; // weak
//char aDD[6] = "%d %d"; // weak
//char aThing[6] = "Thing"; // weak
//char aThingDActiveD[20] = "Thing %d, Active %d"; // weak
//char aCarpetD[10] = "Carpet %d"; // weak
//char aTapeD[8] = "Tape %d"; // weak
//char aHeapD[8] = "Heap %d"; // weak
//char aMemoryUsedFree[19] = "Memory (Used/Free)"; // weak
//char aDD_0[6] = "%d/%d"; // weak
//char aS77dU01d[13] = "s%7.7d,u%01d"; // weak
//char aThing_0[6] = "THING"; // weak
//char aLdLd[10] = "%ld / %ld"; // weak
//char aClassModelStat[22] = "CLASS / MODEL / STATE"; // weak
//char aLdLdLd[16] = "%ld / %ld / %ld"; // weak
//char aLifeMaxLife[16] = "LIFE / MAX LIFE"; // weak
//char aSpeedActualMin[33] = "SPEED ACTUAL / MINIMUM / MAXIMUM"; // weak
//char aActualXYZ[17] = "ACTUAL X / Y / Z"; // weak
//char aIdWhoOwnsMe[17] = "ID / WHO OWNS ME"; // weak
//char aManaActualMaxi[22] = "MANA ACTUAL / MAXIMUM"; // weak
//char aCopyrightC1995[46] = "Copyright (c) 1995 Bullfrog Productions Ltd.\n"; // weak
//char aAllRightsReser[22] = "All rights reserved.\n"; // weak
//char aMagicCarpet2Ne_0[30] = "Magic Carpet 2 (Netherworlds)"; // weak
//char aS_0[5] = "%s \n"; // weak
//void *off_D189C = "%s\n"; // weak // 25730a %s\n
//char aTmaps00_0[9] = "tmaps0-0"; // weak
//char aCdata_1[6] = "cdata"; // weak
//char aNetherw_4[9] = "/netherw"; // weak
//char aCSSSDat_0[16] = "%c:%s/%s/%s.dat"; // weak
//char aDataSDat_0[12] = "data/%s.dat"; // weak
//char aTmaps10_0[9] = "tmaps1-0"; // weak
//char aTmaps20_0[9] = "tmaps2-0"; // weak
//char aErrorDecompres_1[30] = "ERROR decompressing tmap%03d\n"; // weak
//char aSD[5] = "%s%d"; // weak
//char aErrorCodeListe[25] = "Error code (LISTEN) : %d"; // weak
//char aErrorCodeCallD[23] = "Error code (CALL) : %d"; // weak
//char asc_D1949[2] = " "; // weak
//char aVipport[8] = "VIPPORT"; // weak
//char aErrorUnknownFr[26] = "ERROR UNKNOWN FRAME TYPE\n"; // weak
//char aColour256[11] = "COLOUR256 "; // weak
//char aSs2[5] = "SS2 "; // weak
//char aColour[8] = "COLOUR "; // weak
//char aLc[4] = "LC "; // weak
//char aBlack[7] = "BLACK "; // weak
//char aBrun[6] = "BRUN "; // weak
//char aCopy[6] = "COPY "; // weak
//char aPstamp[8] = "PSTAMP "; // weak
//char aNetherwConfigD[21] = ":/NETHERW/CONFIG.DAT"; // weak
//char aCS_0[5] = "%c%s"; // weak
//char aNetherwLanguag[19] = ":/NETHERW/LANGUAGE"; // weak
//char aCSLDTxt[13] = "%c%s/L%d.txt"; // weak
//char aLanguageLDTxt[17] = "LANGUAGE/L%d.txt"; // weak
//char aDataScreensHsc[26] = "DATA/SCREENS/HSCREEN0.DAT"; // weak
//char aIntroIntroDat[16] = "intro\\intro.dat"; // weak
//char aIntroIntro2Dat[17] = "intro\\intro2.dat"; // weak
//char aNethD[7] = "NETH%d"; // weak
//char aLanguageLTxt[16] = "LANGUAGE/L*.TXT"; // weak
//char aLanguageDTxt[16] = "LANGUAGE/D*.TXT"; // weak
//char aLDTxt[8] = "L%d.TXT"; // weak
//char aNetherw_5[9] = "/netherw"; // weak
//char aCSSaveSaveDGam[22] = "%c:%s/save/save%d.gam"; // weak
//char aDD_1[6] = "%d%d."; // weak
//char aC_0[3] = "%c"; // weak
//char asc_D1AB3[3] = "/_"; // weak
//int x_DWORD_D1AE4 = 0x746C41; // weak
//__int16 x_WORD_D1B00 = 65; // weak
//__int16 x_WORD_D1B04 = 66; // weak
//__int16 x_WORD_D1B08 = 69; // weak
//__int16 x_WORD_D1B0C = 70; // weak
//__int16 x_WORD_D1B10 = 71; // weak
//__int16 x_WORD_D1B14 = 72; // weak
//__int16 x_WORD_D1B18 = 74; // weak
//__int16 x_WORD_D1B1C = 75; // weak
//__int16 x_WORD_D1B20 = 78; // weak
//__int16 x_WORD_D1B24 = 81; // weak
//__int16 x_WORD_D1B28 = 84; // weak
//__int16 x_WORD_D1B2C = 85; // weak
//__int16 x_WORD_D1B30 = 87; // weak
//__int16 x_WORD_D1B34 = 88; // weak
//__int16 x_WORD_D1B38 = 89; // weak
//__int16 x_WORD_D1B3C = 90; // weak
//__int16 x_WORD_D1B40 = 45; // weak
//__int16 x_WORD_D1B44 = 59; // weak
//__int16 x_WORD_D1B48 = 35; // weak
//__int16 x_WORD_D1B4C = 44; // weak
//__int16 x_WORD_D1B50 = 46; // weak
//__int16 x_WORD_D1B54 = 47; // weak
//char aDD_2[5] = "%d%d"; // weak
//char aDS[7] = "%d. %s"; // weak
//char aGD[4] = "G%d"; // weak
//char aCSS_0[8] = "%c%s/%s"; // weak
//char aLanguageS[12] = "LANGUAGE/%s"; // weak
//char aIntroCutDDat[16] = "intro\\cut%d.dat"; // weak
//char aHitAccuracy[13] = "Hit Accuracy"; // weak
//char aManaCollected[15] = "Mana Collected"; // weak
//char a3d[6] = "%3d%%"; // weak
//char a02d02d02d[15] = "%02d:%02d:%02d"; // weak
//char aE[3] = "E!"; // weak
//char aError1NotEnoug[41] = "ERROR 1: NOT ENOUGH MEMORY. (%ld / %ld)\n"; // weak
//char aErrorAllocatio[23] = "ERROR: Allocation %s.\n"; // weak
//char aPressReturnToC_0[26] = "Press return to continue\n"; // weak
//char aErrorFileS[17] = "ERROR: File %s.\n"; // weak
//char aSoundSoundDat[16] = "SOUND/SOUND.DAT"; // weak
//char aFdmErrorFreein[23] = "fdm:error freeing %lx\n"; // weak
//char aF1S[8] = "[F1] %s"; // weak
//char aVfxInitialised[17] = "VFX INITIALISED\n"; // weak
//char aS_1[5] = "%s.\n"; // weak
_UNKNOWN unk_D1F0C; // weak
void *off_D1F10 = (void *)0xD5221; // weak
//char aM1PB[9] = "!M1,P,B\r"; // weak
//char aCouldNotSendIn[32] = "Could not send Info to Tracker\n"; // weak
float flt_D1F40 = 0.000061035156; // weak
//char aNoMemoryForSer[28] = "No memory for serial data.\n"; // weak
//char aNoSerial[11] = "NO SERIAL\n"; // weak
//char aNoMemory[11] = "NO MEMORY\n"; // weak
void *off_D1F78 = &unk_D5621; // weak
double dbl_D1F7C = 1.003; // weak
//char aCouldNotLoadAn[37] = "\nCould not load any digital samples\n"; // weak
//char aMdsound[8] = "MDSOUND"; // weak
//char aSXDDD[15] = "%s %x %d %d %d"; // weak
//char aS_2[3] = "%s"; // weak
//char aDigIni[8] = "DIG.INI"; // weak
//char aNone[5] = "None"; // weak
//char aCouldNotLoadAn_0[37] = "\nCould not load any digital samples\n"; // weak
//char aCouldNotLoadAn_1[37] = "\nCould not load any digital samples\n"; // weak
//char aSbawe32Mdi[12] = "SBAWE32.MDI"; // weak
//char aSbpro2Mdi[11] = "SBPRO2.MDI"; // weak
//char aSbpro1Mdi[11] = "SBPRO1.MDI"; // weak
//char aMpu401Mdi[11] = "MPU401.MDI"; // weak
//char aMt32mpuMdi[12] = "MT32MPU.MDI"; // weak
//char aSndscapeMdi[13] = "SNDSCAPE.MDI"; // weak
//char aAdlibgMdi[11] = "ADLIBG.MDI"; // weak
//char aPasMdi[8] = "PAS.MDI"; // weak
//char aPasplusMdi[12] = "PASPLUS.MDI"; // weak
//char aSblasterMdi[13] = "SBLASTER.MDI"; // weak
//char aOpl3Mdi[9] = "OPL3.MDI"; // weak
//char aAdlibMdi[10] = "ADLIB.MDI"; // weak
//char aD_2[4] = "d \\"; // weak
//char aCSsoundSample[18] = "%c:%sSOUND/SAMPLE"; // weak
//char aCSSoundSample[19] = "%c:%s/SOUND/SAMPLE"; // weak
//char aMdmusic[8] = "MDMUSIC"; // weak
//char aSXDDD_0[15] = "%s %x %d %d %d"; // weak
//char aMS[4] = "M%s"; // weak
//char aMdiIni[8] = "MDI.INI"; // weak
//char aNone_0[5] = "None"; // weak
//char aT32f[5] = "T32f"; // weak
//char aEsfmMdi[9] = "ESFM.MDI"; // weak
//char aApew[5] = "APEw"; // weak
//char aDig[4] = "DIg"; // weak
//char aOpr[4] = "opr"; // weak
//char aErrorDriverNot[29] = "\nError driver not supported\n"; // weak
//char aErrorOpeningMu[28] = "\nError opening music files\n"; // weak
//char aSoundMusicDat[16] = "SOUND/MUSIC.DAT"; // weak
//char aNullWav[9] = "null.wav"; // weak
double dbl_D220C = 0.01; // weak
double dbl_D2218 = 63.0; // weak
double dbl_D2220 = 0.5; // weak
//_UNKNOWN unk_D2228=""; // weak
//char aSb16Dig[9] = "SB16.DIG"; // weak
//char aSbawe32Mdi_0[12] = "SBAWE32.MDI"; // weak
//char aMpu401Mdi_0[11] = "MPU401.MDI"; // weak
//char a02u02u02u02u[27] = "[%.02u:%.02u:%.02u.%.02u] "; // weak
const char* unk_D226C = " \0"; // weak
const char* unk_D2270 = "\0xfa\0"; // weak
//char aAilShutdown[16] = "AIL_shutdown()\n"; // weak
//char aAilSetPreferen[27] = "AIL_set_preference(%d,%d)\n"; // weak
//char aResultD[13] = "Result = %d\n"; // weak
//char aAilGetRealVect[25] = "AIL_get_real_vect(0x%X)\n"; // weak
//char aResult0xX[15] = "Result = 0x%X\n"; // weak
//char aAilSetRealVect[30] = "AIL_set_real_vect(0x%X,0x%X)\n"; // weak
//char aAilRestoreUse1[27] = "AIL_restore_USE16_ISR(%d)\n"; // weak
//char aAilCallDriver0[38] = "AIL_call_driver(0x%X,0x%X,0x%X,0x%X)\n"; // weak
//char aAilDelayD[15] = "AIL_delay(%d)\n"; // weak
//char aAilApiReadIni0[27] = "AIL_API_read_INI(0x%X,%s)\n"; // weak
//char aDriverS[13] = "Driver = %s\n"; // weak
//char aDeviceS[13] = "Device = %s\n"; // weak
//char aIoX[13] = "IO     = %X\n"; // weak
//char aIrqD[13] = "IRQ    = %d\n"; // weak
//char aDma8D[13] = "DMA_8  = %d\n"; // weak
//char aDma16D[13] = "DMA_16 = %d\n"; // weak
//char aResultU[13] = "Result = %u\n"; // weak
//char aAilRegisterTim[26] = "AIL_register_timer(0x%X)\n"; // weak
//char aAilSetTimerUse[27] = "AIL_set_timer_user(%u,%u)\n"; // weak
//char aAilSetTimerPer[29] = "AIL_set_timer_period(%u,%u)\n"; // weak
//char aAilSetTimerFre[32] = "AIL_set_timer_frequency(%u,%u)\n"; // weak
//char aAilStartTimerU[21] = "AIL_start_timer(%u)\n"; // weak
//char aAilStopTimerU[20] = "AIL_stop_timer(%u)\n"; // weak
//char aAilReleaseTime[30] = "AIL_release_timer_handle(%u)\n"; // weak
//char aAilReleaseAllT[26] = "AIL_release_all_timers()\n"; // weak
//char aAilGetIoEnviro[30] = "AIL_get_IO_environment(0x%X)\n"; // weak
//char aAilInstallDriv[29] = "AIL_install_driver(0x%X,%u)\n"; // weak
//char aAilUninstallDr[28] = "AIL_uninstall_driver(0x%X)\n"; // weak
//char aAilInstallDigI[27] = "AIL_install_DIG_INI(0x%X)\n"; // weak
//char aAilInstallDigD[38] = "AIL_install_DIG_driver_file(%s,0x%X)\n"; // weak
//char aAilUninstallDi[32] = "AIL_uninstall_DIG_driver(0x%X)\n"; // weak
//char aAilAllocateSam[34] = "AIL_allocate_sample_handle(0x%X)\n"; // weak
//char aAilReleaseSamp[33] = "AIL_release_sample_handle(0x%X)\n"; // weak
//char aAilInitSample0[23] = "AIL_init_sample(0x%X)\n"; // weak
//char aAilSetSampleFi[35] = "AIL_set_sample_file(0x%X,0x%X,%d)\n"; // weak
//char aAilSetSampleAd[38] = "AIL_set_sample_address(0x%X,0x%X,%u)\n"; // weak
//char aAilSetSampleTy[33] = "AIL_set_sample_type(0x%X,%d,%u)\n"; // weak
//char aAilStartSample[24] = "AIL_start_sample(0x%X)\n"; // weak
//char aAilEndSample0x[22] = "AIL_end_sample(0x%X)\n"; // weak
//char aAilSetSamplePl[39] = "AIL_set_sample_playback_rate(0x%X,%d)\n"; // weak
//char aAilSetSampleVo[32] = "AIL_set_sample_volume(0x%X,%d)\n"; // weak
//char aAilSetSamplePa[29] = "AIL_set_sample_pan(0x%X,%d)\n"; // weak
//char aAilSetSampleLo[36] = "AIL_set_sample_loop_count(0x%X,%d)\n"; // weak
//char aAilSampleStatu[25] = "AIL_sample_status(0x%X)\n"; // weak
//char aAilSetDigitalM[40] = "AIL_set_digital_master_volume(0x%X,%d)\n"; // weak
//char aAilRegisterEos[38] = "AIL_register_EOS_callback(0x%X,0x%X)\n"; // weak
//char aAilSetSampleUs[38] = "AIL_set_sample_user_data(0x%X,%u,%d)\n"; // weak
//char aAilSampleUserD[31] = "AIL_sample_user_data(0x%X,%u)\n"; // weak
//char aAilInstallMdiI[27] = "AIL_install_MDI_INI(0x%X)\n"; // weak
//char aAilInstallMdiD[38] = "AIL_install_MDI_driver_file(%s,0x%X)\n"; // weak
//char aAilUninstallMd[32] = "AIL_uninstall_MDI_driver(0x%X)\n"; // weak
//char aAilAllocateSeq[36] = "AIL_allocate_sequence_handle(0x%X)\n"; // weak
//char aAilInitSequenc[33] = "AIL_init_sequence(0x%X,0x%X,%d)\n"; // weak
//char aAilStartSequen[26] = "AIL_start_sequence(0x%X)\n"; // weak
//char aAilStopSequenc[25] = "AIL_stop_sequence(0x%X)\n"; // weak
//char aAilResumeSeque[27] = "AIL_resume_sequence(0x%X)\n"; // weak
//char aAilEndSequence[24] = "AIL_end_sequence(0x%X)\n"; // weak
//char aAilSetSequence_0[37] = "AIL_set_sequence_volume(0x%X,%d,%d)\n"; // weak
//char aAilSequenceSta[27] = "AIL_sequence_status(0x%X)\n"; // weak
//char aAilSetXmidiMas[38] = "AIL_set_XMIDI_master_volume(0x%X,%d)\n"; // weak
//char aAilMdiDriverTy[27] = "AIL_MDI_driver_type(0x%X)\n"; // weak
//char aAilSetGtlFilen[33] = "AIL_set_GTL_filename_prefix(%s)\n"; // weak
//char aAilSequencePos[39] = "AIL_sequence_position(0x%X,0x%X,0x%X)\n"; // weak
//char aResultDD[16] = "Result = %d:%d\n"; // weak
//char aAilBranchIndex[27] = "AIL_branch_index(0x%X,%u)\n"; // weak
//char aAilRegisterTri[42] = "AIL_register_trigger_callback(0x%X,0x%X)\n"; // weak
//char aAilRegisterEve[40] = "AIL_register_event_callback(0x%X,0x%X)\n"; // weak
//char aAilRegisterTim_0[41] = "AIL_register_timbre_callback(0x%X,0x%X)\n"; // weak
//char aAilLockChannel[24] = "AIL_lock_channel(0x%X)\n"; // weak
//char aAilReleaseChan[30] = "AIL_release_channel(0x%X,%d)\n"; // weak
//char aAilMapSequence[38] = "AIL_map_sequence_channel(0x%X,%d,%d)\n"; // weak
//char aAilSendChannel[58] = "AIL_send_channel_voice_message(0x%X,0x%X,0x%X,0x%X,0x%X)\n"; // weak
//char aVesa[5] = "VESA"; // weak
//char aWritingS[12] = "Writing %s\n"; // weak
//char aResponseC[14] = "Response: %c\n"; // weak
//char aTrackerInitial[23] = "Tracker initialized ok"; // weak
//char aNoSerialPort[15] = "No serial port"; // weak
//char aTrackerNotPres[20] = "Tracker not present"; // weak
//char aTrackerIsNotRe[26] = "Tracker is not responding"; // weak
//char aTrackerDataIsI[24] = "Tracker data is invalid"; // weak
//char aTrackerHeaderD[31] = "Tracker header data is invalid"; // weak
//char aAVerifiedWrite[42] = "A verified write to tracker memory failed"; // weak
//char aInvalidParamet[18] = "Invalid parameter"; // weak
//char aTrackerCommand[34] = "Tracker command returned an error"; // weak
//char aAMemoryAllocat[27] = "A memory allocation failed"; // weak
//char aTrackerVersion[34] = "Tracker version string is invalid"; // weak
//char aUndefined[10] = "Undefined"; // weak
//char aLx[3] = "LX"; // weak
char x_BYTE_D3450[17] = { '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F',0 }; // weak
//char aRt[4] = ",rt"; // weak
//char aDriver[7] = "DRIVER"; // weak
//char aDevice[7] = "DEVICE"; // weak
//char aIoAddr[8] = "IO_ADDR"; // weak
//char aIrq[4] = "IRQ"; // weak
//char aDma8Bit[10] = "DMA_8_bit"; // weak
//char aDma16Bit[11] = "DMA_16_bit"; // weak
//char aCorruptedIniFi[21] = "Corrupted .INI file\n"; // weak
//char aInsufficientLo[25] = "Insufficient low memory\n"; // weak
//char aAil3dig[8] = "AIL3DIG"; // weak
//char aAil3mdi[8] = "AIL3MDI"; // weak
//char aInvalidDriverT[21] = "Invalid driver type\n"; // weak
//char aOutOfDriverHan[23] = "Out of driver handles\n"; // weak
//char aOutOfTimerHand[22] = "Out of timer handles\n"; // weak
//char aSbawe32Mdi_1[12] = "SBAWE32.MDI"; // weak
//char aW[2] = "w"; // weak
//char aSoundSSbk[14] = "sound//%s.sbk"; // weak
//char aCouldNotAlloca[38] = "Could not allocate memory for driver\n"; // weak
//char aDigDriverRequi[22] = ".DIG driver required\n"; // weak
//char aDigitalSoundHa[34] = "Digital sound hardware not found\n"; // weak
//char aCouldNotAlloca_0[32] = "Could not allocate DMA buffers\n"; // weak
//char aCouldNotAlloca_1[33] = "Could not allocate build buffer\n"; // weak
//char aCouldNotAlloca_2[38] = "Could not allocate SAMPLE structures\n"; // weak
//char aOutOfTimerHand_0[22] = "Out of timer handles\n"; // weak
//char aDigIni_0[8] = "DIG.INI"; // weak
//char aUnableToOpenFi[29] = "Unable to open file DIG.INI\n"; // weak
//char aOutOfSampleHan[23] = "Out of sample handles\n"; // weak
//char aFmt[5] = "fmt "; // weak
//char aData_0[5] = "data"; // weak
//char aCreative[9] = "Creative"; // weak
//char aWave[5] = "WAVE"; // weak
//char aUnrecognizedDi[38] = "Unrecognized digital audio file type\n"; // weak
//char aUnrecognizedDi_0[38] = "Unrecognized digital audio file type\n"; // weak
//char aForm[5] = "FORM"; // weak
//char aCat[5] = "CAT "; // weak
//char aXmid[5] = "XMID"; // weak
//char aCouldNotAlloca_3[38] = "Could not allocate memory for driver\n"; // weak
//char aMdiDriverRequi[22] = ".MDI driver required\n"; // weak
//char aXmidiSoundHard[32] = "XMIDI sound hardware not found\n"; // weak
//char aCouldNotInitia[41] = "Could not initialize instrument manager\n"; // weak
//char aCouldNotAlloca_4[40] = "Could not allocate SEQUENCE structures\n"; // weak
//char aOutOfTimerHand_1[22] = "Out of timer handles\n"; // weak
//char aMdiIni_0[8] = "MDI.INI"; // weak
//char aUnableToOpenFi_0[29] = "Unable to open file MDI.INI\n"; // weak
//char aTandy3VoiceMus[20] = "Tandy 3-voice music"; // weak
//char aIbmInternalSpe[27] = "IBM internal speaker music"; // weak
//char aMAd[5] = "m.AD"; // weak
//char aOpl[5] = ".OPL"; // weak
//char aOutOfSequenceH[25] = "Out of sequence handles\n"; // weak
//char aInvalidXmidiSe[24] = "Invalid XMIDI sequence\n"; // weak
//char aTimb[5] = "TIMB"; // weak
//char aRbrn[5] = "RBRN"; // weak
//char aEvnt[5] = "EVNT"; // weak
//char aDriverCouldNot[51] = "Driver could not install timbre bank %u, patch %u\n"; // weak
//char aDriverCouldNot_0[51] = "Driver could not install timbre bank %u, patch %u\n"; // weak
//char aInsufficientMe_0[42] = "Insufficient memory for HWAVE descriptor\n"; // weak
//char asc_D3A8C[3] = ": "; // weak
char IsTable[256] =
{
  '\x00','\x01','\x01','\x01','\x01','\x01','\x01','\x01',
  '\x01','\x01','\x03','\x03','\x03','\x03','\x03','\x01',
  '\x01','\x01','\x01','\x01','\x01','\x01','\x01','\x01',
  '\x01','\x01','\x01','\x01','\x01','\x01','\x01','\x01',
  '\x01','\n','\f','\f','\f','\f','\f','\f',
  '\f','\f','\f','\f','\f','\f','\f','\f',
  '\f','8','8','8','8','8','8','8',
  '8','8','8','\f','\f','\f','\f','\f',
  '\f','\f','X','X','X','X','X','X',
  'H','H','H','H','H','H','H','H',
  'H','H','H','H','H','H','H','H',
  'H','H','H','H','\f','\f','\f',
  '\f','\f','\f','\x98','\x98','\x98',
  '\x98','\x98','\x98','\x88','\x88','\x88',
  '\x88','\x88','\x88','\x88','\x88',
  '\x88','\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\f',
  '\f',
  '\f',
  '\f',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char x_BYTE_D3EA0[6] = { '\x01', '\x02', '\x04', '\b', '\x10', ' ' }; // idb
char x_BYTE_D3F48 = '\0'; // weak
__int16 x_WORD_D3F4C[26] =
{
  2,
  10,
  40,
  32,
  300,
  1,
  1,
  1,
  1,
  4,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  400,
  600,
  600,
  400,
  400,
  0,
  0,
  0
}; // idb
_UNKNOWN unk_D3F80; // weak
_UNKNOWN unk_D3F89; // weak
_UNKNOWN unk_D3F91; // weak
char x_BYTE_D3F96[14] =
{
  '\0',
  '\xFF',
  '\0',
  '\xFF',
  '\x01',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\0',
  '\0',
  '\0'
}; // idb
char x_BYTE_D3FA4[] = { '\0' }; // weak
char x_BYTE_D3FB2[14] =
{
  '\0',
  '\x01',
  '\0',
  '\0',
  '\xFF',
  '\x01',
  '\xFF',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0'
}; // idb
char x_BYTE_D3FC0[] = { '\0' }; // weak
__int16 x_WORD_D3FCE[13] = { 0, 1536, 0, 1536, 512, 1536, 0, 0, 1024, 1024, 1536, 1024, 512 }; // idb
__int16 x_WORD_D3FE8[14] = { 1024, 512, 1024, 1024, 1536, 512, 1536, 1024, 0, 512, 512, 1024, 0, 0 }; // idb
__int16 x_WORD_D4004 = 0; // weak
char x_BYTE_D400C[64] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x02',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x03',
  '\x02',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x04',
  '\x03',
  '\x02',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\x04',
  '\x03',
  '\x03',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\x06',
  '\x05',
  '\x04',
  '\x03',
  '\x02',
  '\x01',
  '\0',
  '\0',
  '\a',
  '\x06',
  '\x05',
  '\x04',
  '\x03',
  '\x02',
  '\x01',
  '\0'
}; // idb
void *off_D404C = &unk_140186; // weak
int x_DWORD_D40BC[] = { 0 }; // weak
int x_DWORD_D40C0[] = { 0 }; // weak
Bit8u* x_DWORD_D4188 = 0; // weak
int x_DWORD_D418C = 0; // weak
int x_DWORD_D4190 = 0; // weak
Bit8u* x_DWORD_D4198 = 0; // weak
char x_BYTE_D419C_level_num = '\xFF'; // weak
char x_BYTE_D419D = '\x01'; // weak
char x_BYTE_D419E = '\0'; // weak


//x_DWORD x_DWORD_D41A4 = 0;
x_DWORD x_DWORD_D41A4_4 = 0;
x_DWORD x_DWORD_D41A4_6 = 127;
x_DWORD x_DWORD_D41A4_8 = 127;
x_BYTE x_BYTE_D41A4_10 = 1;
x_BYTE x_BYTE_D41A4_11 = 0;
x_BYTE x_BYTE_D41A4_12 = 0;
x_BYTE x_BYTE_D41A4_13 = 0;


char x_BYTE_D41AD_skip_screen = '\0'; // weak
char x_BYTE_D41B4_vesa_driver_finded = '\0'; // weak
char x_BYTE_D41B5 = ' '; // weak
char x_BYTE_D41B6 = '\x01'; // weak
char x_BYTE_D41B7 = ','; // weak

char x_BYTE_D41C0 = '\0'; // weak
char x_BYTE_D41C1 = '\0'; // weak
char x_BYTE_D41C4 = 'c'; // weak
char x_BYTE_D41C6 = '('; // weak
int x_DWORD_D41C8 = 0; // weak
char x_BYTE_D41CE = '\0'; // weak
Bit8u* x_DWORD_D41D0 = 0; // weak
__int16 x_WORD_D41D4 = 1; // weak
char x_BYTE_D41D8[] = { '\0' }; // weak
char x_BYTE_D427C[164] =
{
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char x_BYTE_D4320 = '\0'; // weak
int x_DWORD_D4324 = 0; // weak
_UNKNOWN unk_D4328; // weak
Bit32u unk_D4350[256]; // weak //fix
char x_BYTE_D4750[] = { '\0' }; // weak
char x_BYTE_D4756[] = { '\x01' }; // weak
char x_BYTE_D475C[16] =
{
  '\0',
  '\x01',
  '\x01',
  '\x02',
  '\x02',
  '\x03',
  '\x03',
  '\x04',
  '\x04',
  '\x03',
  '\x03',
  '\x02',
  '\x02',
  '\x01',
  '\x01',
  '\0'
}; // idb
char x_BYTE_D476C[16] =
{
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0'
}; // idb
char x_BYTE_D477C[16] =
{
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\n',
  '\v',
  '\f',
  '\f',
  '\f',
  '\f'
}; // idb
char x_BYTE_D478C = '\0'; // weak
int x_DWORD_D4790 = 20; // weak
int x_DWORD_D4794 = 0; // weak
int x_DWORD_D4798 = 0; // weak
char x_BYTE_D47D8 = '\0'; // weak
char x_BYTE_D47D9 = '\0'; // weak
int x_DWORD_D47DC = 1; // weak
_UNKNOWN unk_D47E0; // weak
_UNKNOWN unk_D4A30; // weak
_UNKNOWN unk_D4A40; // weak
_UNKNOWN unk_D4A70; // weak
_UNKNOWN unk_D4A80; // weak
_UNKNOWN unk_D4AB0; // weak
char x_BYTE_D4B50 = '\0'; // weak
char x_BYTE_D4B51 = '\0'; // weak
char x_BYTE_D4B78 = '\0'; // weak
char x_BYTE_D4B79 = '\0'; // weak
char x_BYTE_D4B7A = '\0'; // weak
__int16 x_WORD_D4B7C = 254; // weak
__int16 x_WORD_D4B7E = 0; // weak
char x_BYTE_D4B80 = '\0'; // weak
int x_DWORD_D4B84 = 16; // weak
int x_DWORD_D4B88 = 4294967216; // weak
int x_DWORD_D4B8C = 80; // weak
int x_DWORD_D4B90 = 4294967292; // weak
__int16 x_WORD_D4BA4 = 16; // weak
int x_DWORD_D4BA8 = 4294967216; // weak
int x_DWORD_D4BAC = 80; // weak
__int16 x_WORD_D4BB0 = 65532; // weak
int x_DWORD_D4C52 = 0; // weak
int x_DWORD_D4C56 = 0; // weak
int(*off_D697E)(int) = (int(*)(int))&sub_4E320; // weak
int(*off_D781E)(int) = &sub_511A0; // weak
int(*off_D7B7A)(int) = (int(*)(int))&sub_51530; // weak
_UNKNOWN unk_D7BD6; // weak
_UNKNOWN unk_D83AC; // weak
void *off_D83CE = &unk_160001; // weak
_UNKNOWN unk_D83F0; // weak
void *off_D8412 = &unk_110003; // weak
void *off_D8434 = &loc_B0004; // weak
void *off_D8456 = (void *)0x50005; // weak
_UNKNOWN unk_D8478; // weak
_UNKNOWN unk_D849A; // weak
__int16 x_WORD_D84A6 = 256; // weak
_UNKNOWN unk_D84BC; // weak
_UNKNOWN unk_D84DE; // weak
_UNKNOWN unk_D8544; // weak
_UNKNOWN unk_D8588; // weak
_UNKNOWN unk_D85AA; // weak
void *off_D85CC = &unk_160010; // weak
void *off_D8676 = &unk_160015; // weak
void *off_D86DC = &unk_160018; // weak
_UNKNOWN unk_D86FE; // weak
_UNKNOWN unk_D8720; // weak
void *off_D8742 = &unk_16001B; // weak
_UNKNOWN unk_D8764; // weak
_UNKNOWN unk_D8786; // weak
_UNKNOWN unk_D87A8; // weak
_UNKNOWN unk_D87CA; // weak
_UNKNOWN unk_D87EC; // weak
_UNKNOWN unk_D880E; // weak
_UNKNOWN unk_D8830; // weak
_UNKNOWN unk_D8852; // weak
_UNKNOWN unk_D8874; // weak
_UNKNOWN unk_D8896; // weak
void *off_D88B8 = &unk_160026; // weak
_UNKNOWN unk_D88DA; // weak
_UNKNOWN unk_D88FC; // weak
void *off_D891E = &unk_160029; // weak
void *off_D8940 = &unk_16002A; // weak
_UNKNOWN unk_D8962; // weak
void *off_D8984 = &unk_16002C; // weak
_UNKNOWN unk_D89A6; // weak
void *off_D89C8 = &loc_5002E; // weak
void *off_D89EA = &unk_11002F; // weak
char x_BYTE_D8A2E[38] =
{
  '\x01',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\0'
}; // idb
//char aSearchd[9] = "*SearchD"; // weak
//char aDataBuild00Dat[18] = "data/build0-0.dat"; // weak
//char aDataBlock16Dat[17] = "data/block16.dat"; // weak
//char aDataBlock32Dat[17] = "data/block32.dat"; // weak
//char aWscreen[9] = "*WScreen"; // weak
//char aDataMsprd00Dat[18] = "data/msprd0-0.dat"; // weak
//char aDataMsprd00Tab_0[18] = "data/msprd0-0.tab"; // weak
//char aDataHsprd00Dat[18] = "data/hsprd0-0.dat"; // weak
//char aDataHsprd00Tab_0[18] = "data/hsprd0-0.tab"; // weak

//int **filearray_2aa18c = &x_DWORD_EB394; // weak -

//int *off_D91BC[2] = { &x_DWORD_EA3DC, (int*)&x_DWORD_EA3E0_copyto_x_DWORD_EA3E0 }; // weak
//[6]
//void *off_D91D4 = &unk_E9B2C; // weak
//[18]
//int *off_D91EC; // weak
//[24]

//const char *off_D9204_wizards_names1[5] = { "1.Jahwl","2.Kopahk","3.Myrnan","4. Arachnium","5. T'Klom na"}; // weak //dseg03:000D0E50 v IDA rozdil 83b4

const char *off_D9204_wizards_names1[56] = { "1. Jahwl","2. Kopahk","3. Myrnan Gor","4. Arachnium","5. T'Klom","6. Phyrydia","7. Perilium",
"8. Ul Buthnen","9. Evirith Gor","10. Cymmeria ","11. Tropolos ","12. Jaleen ","13. Galiphur ","14. Tunuk ","15. Zyggogg "
"16. Darklava ","17. C'lannesh ","18. Gleph ","19. Baraghan ","20. Ammyridia ","21. Cresidan ","22. Hodor ","23. Jathnar "
"24. Malak ","25. Uluth ","26. ","27. ","28. ","29. ","30. ","Karakir ","Ymbul","Pav Durivium","Beleem","Ommosyth"
"36. ","37. ","38. ","40. ","41. ","42. ","43. ","44. ","45. ","46. ","47. ","48. ","49. ","50. ","Thrull",
"Keevur","Braak","Trapox","Hibren Zhor","Jinople","Dethrem","Canquin","Zephulum","Verune" };

//const char *off_D9208 = "2. Kopahk"; // weak
const char *off_D93A0_wizards_names2[8] = { "Zanzamar","Nyphur","Rahn","Belix","Jark","Elyssia","Yragore","Prish" };

Bit8u x_WORD_D93C0_bldgprmbuffer[304];
char x_BYTE_D93C2[] = { '\x03' }; // weak
char x_BYTE_D93C3[] = { '\0' }; // weak
char x_BYTE_D94F0[] = { '\xAA' }; // weak
char x_BYTE_D94F1[] = { '\0' }; // weak
char x_BYTE_D94F2[] = { 'c' }; // weak
char x_BYTE_D94F3[12] = { '\r', '\0', '3', '\0', '\x11', ';', '\0', '3', '\0', '\x88', ';', '\0' }; // idb
char x_BYTE_D94FF[29] =
{
  '\0',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\x11',
  '\x12',
  '\x13',
  '\x14',
  '\x15',
  '\x16',
  '\x17',
  '\x18',
  '\x19',
  '\0',
  '\x03',
  '\0'
}; // idb
//__int16 x_WORD_D951C[] = { 8 }; // weak //fix it
Bit16u x_WORD_D951C[1500]; //fix it
__int16 x_WORD_D9522[] = { 0 }; // weak
__int16 x_WORD_D9524[] = { 250 }; // weak
char x_BYTE_D9528[] = { '\0' }; // weak
__int16 x_WORD_D99F2 = 0; // weak
__int16 x_WORD_D99F4 = 180; // weak
int x_DWORD_D9F50[] = { 16777356 }; // weak
__int16 x_WORD_DA076 = 1500; // weak
__int16 x_WORD_DA506 = 311; // weak
int x_DWORD_DA750[] = { 27918336 }; // weak
__int16 x_WORD_DA7CA = 1200; // weak
//char *xadataspellsdat.var28_begin_buffer[] = { '\x03' }; // weak
//char *xadataspellsdat.var28_begin_buffer[10000]; // weak  //fix it
char x_BYTE_DA819[] = { '\0' }; // weak
int x_DWORD_DA81E = 100; // weak
int x_DWORD_DA822 = 0; // weak
__int16 x_WORD_DA82E[] = { 186 }; // weak
int x_DWORD_DA85A[60] =
{
  5000,
  750,
  983228,
  196610,
  10,
  100,
  0,
  0,
  0,
  196797,
  983040,
  16384000,
  0,
  19660800,
  3276800,
  12451840,
  65577,
  20,
  1000,
  1000,
  900,
  150,
  3342527,
  196610,
  0,
  1000,
  0,
  0,
  0,
  6619328,
  0,
  81920000,
  0,
  1638400,
  262144,
  12648448,
  65637,
  1,
  2000,
  0,
  125,
  6,
  6619330,
  67305474,
  2,
  1000,
  0,
  0,
  0,
  19726531,
  196608,
  163840000,
  0,
  9175040,
  983040,
  12845056,
  451,
  4,
  5000,
  0
}; // idb
__int16 x_WORD_DA96E = 198; // weak
char x_BYTE_DA972[] = { '\x13' }; // weak
_UNKNOWN unk_DAB3A; // weak
x_BYTE x_BYTE_DAC2A[26] =
{
  208,
  7,
  0,
  0,
  244,
  1,
  0,
  0,
  16,
  39,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  226,
  0,
  5,
  0,
  0,
  0
}; // idb
_UNKNOWN unk_DAC44; // weak
_UNKNOWN unk_DAC7A; // weak
__int16 x_WORD_DAE1E = 244; // weak
char x_BYTE_DAE22 = '\x13'; // weak
_UNKNOWN unk_DAF4A; // weak
int x_DWORD_DAF50[58] =
{
  1310720000,
  0,
  0,
  16842752,
  47,
  5000,
  12000,
  20000,
  120,
  30,
  4391170,
  655360001,
  1572864000,
  3932160000,
  15728640,
  3932160,
  16973824,
  131159,
  39976963,
  655360000,
  1310720000,
  0,
  0,
  17039360,
  1048619,
  1100,
  18000,
  36000,
  90,
  30,
  2162949,
  177602586,
  1966080000,
  1603272704,
  18350081,
  4587520,
  17170432,
  2097185,
  6553603,
  720896000,
  1245184000,
  0,
  0,
  17235968,
  31,
  130,
  13000,
  38000,
  200,
  40,
  2687240,
  25559041,
  1703936000,
  3670016000,
  26214400,
  7864320,
  17367040,
  131123
}; // idb
char x_BYTE_DB038[] = { '\0' }; // weak
char x_BYTE_DB039[16] =
{
  '\0',
  '\x01',
  '\0',
  '\x04',
  '\x01',
  '\x04',
  '\x01',
  '\x04',
  '\x05',
  '\x04',
  '\x05',
  '\b',
  '\t',
  '\b',
  '\t',
  '\0'
}; // idb
_UNKNOWN unk_DB04A; // weak
void *off_DB06C = (void *)0xD1130; // weak
char x_BYTE_DB080[] = { '\x02' }; // weak
__int16 x_WORD_DB082[] = { 0 }; // weak
__int16 x_WORD_DB084[] = { 750 }; // weak
int x_DWORD_DB350[103] =
{
  29492775,
  19662900,
  29493675,
  24579000,
  0,
  0,
  0,
  0,
  19664250,
  20,
  39322125,
  300,
  0,
  0,
  0,
  0,
  0,
  0,
  63897600,
  1376481,
  54067200,
  34407300,
  34407900,
  0,
  0,
  0,
  0,
  0,
  0,
  29493300,
  22,
  58983225,
  93389250,
  122880375,
  525,
  0,
  0,
  0,
  0,
  162201600,
  1507703,
  73728000,
  14746800,
  34407900,
  0,
  0,
  0,
  0,
  0,
  0,
  29493300,
  24,
  68813775,
  93389100,
  122880375,
  162202125,
  186777900,
  211353900,
  245760450,
  375,
  275251200,
  1638700,
  54067200,
  24576900,
  34407750,
  19662750,
  19663125,
  19663500,
  0,
  0,
  0,
  24579075,
  26,
  1200,
  83558400,
  675,
  0,
  0,
  0,
  0,
  0,
  132710400,
  1771047,
  24576000,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  28,
  375,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
char x_BYTE_DB4EE[25] =
{
  '0',
  '6',
  '<',
  'B',
  'E',
  'H',
  'M',
  'O',
  'V',
  '\\',
  'a',
  'f',
  'i',
  'n',
  's',
  'v',
  '|',
  '~',
  '\x83',
  '\x85',
  '\x88',
  '\x8C',
  '\x8F',
  '\x97',
  '\x9C'
}; // idb
char x_BYTE_DB507[10] = { '5', ';', 'A', 'D', 'G', 'L', 'N', 'U', '[', '`' }; // idb
char x_BYTE_DB511 = 'e'; // weak
char x_BYTE_DB520[6] = { '0', '3', '?', '=', '\x92', 'q' }; // idb
char x_BYTE_DB526 = 'N'; // weak
int x_DWORD_DB538[8] = { 256, 512, 1024, 2048, 4096, 9192, 18384, 36768 }; // idb
const char *off_DB558[3] = { "Designed By", "Bullfrog Productions Ltd", "!" }; // weak
char x_BYTE_DB734 = '\0'; // weak
char x_BYTE_DB738 = '\0'; // weak
//int x_DWORD_DB73C_tmapsfile = 4294967295; // weak
FILE* x_DWORD_DB73C_tmapsfile;
//int x_DWORD_DB740_tmaps00file = 4294967295; // weak
FILE* x_DWORD_DB740_tmaps00file;
//int x_DWORD_DB744_tmaps10file = 4294967295; // weak
FILE* x_DWORD_DB744_tmaps10file;
//int x_DWORD_DB748_tmaps20file = 4294967295; // weak
FILE* x_DWORD_DB748_tmaps20file;
char x_BYTE_DB74C = '\x01'; // weak
int x_DWORD_DB750[256] =
{
  0,
  201,
  402,
  603,
  804,
  1005,
  1206,
  1407,
  1608,
  1809,
  2010,
  2211,
  2412,
  2613,
  2814,
  3015,
  3216,
  3417,
  3617,
  3818,
  4019,
  4219,
  4420,
  4621,
  4821,
  5022,
  5222,
  5422,
  5623,
  5823,
  6023,
  6224,
  6424,
  6624,
  6824,
  7024,
  7224,
  7423,
  7623,
  7823,
  8022,
  8222,
  8421,
  8621,
  8820,
  9019,
  9218,
  9417,
  9616,
  9815,
  10014,
  10212,
  10411,
  10609,
  10808,
  11006,
  11204,
  11402,
  11600,
  11798,
  11996,
  12193,
  12391,
  12588,
  12785,
  12983,
  13180,
  13376,
  13573,
  13770,
  13966,
  14163,
  14359,
  14555,
  14751,
  14947,
  15143,
  15338,
  15534,
  15729,
  15924,
  16119,
  16314,
  16508,
  16703,
  16897,
  17091,
  17285,
  17479,
  17673,
  17867,
  18060,
  18253,
  18446,
  18639,
  18832,
  19024,
  19216,
  19409,
  19600,
  19792,
  19984,
  20175,
  20366,
  20557,
  20748,
  20939,
  21129,
  21320,
  21510,
  21699,
  21889,
  22078,
  22268,
  22457,
  22645,
  22834,
  23022,
  23210,
  23398,
  23586,
  23774,
  23961,
  24148,
  24335,
  24521,
  24708,
  24894,
  25080,
  25265,
  25451,
  25636,
  25821,
  26005,
  26190,
  26374,
  26558,
  26742,
  26925,
  27108,
  27291,
  27474,
  27656,
  27838,
  28020,
  28202,
  28383,
  28564,
  28745,
  28926,
  29106,
  29286,
  29466,
  29645,
  29824,
  30003,
  30182,
  30360,
  30538,
  30716,
  30893,
  31071,
  31248,
  31424,
  31600,
  31776,
  31952,
  32127,
  32303,
  32477,
  32652,
  32826,
  33000,
  33173,
  33347,
  33520,
  33692,
  33865,
  34037,
  34208,
  34380,
  34551,
  34721,
  34892,
  35062,
  35231,
  35401,
  35570,
  35738,
  35907,
  36075,
  36243,
  36410,
  36577,
  36744,
  36910,
  37076,
  37241,
  37407,
  37572,
  37736,
  37900,
  38064,
  38228,
  38391,
  38554,
  38716,
  38878,
  39040,
  39201,
  39362,
  39523,
  39683,
  39843,
  40002,
  40161,
  40320,
  40478,
  40636,
  40794,
  40951,
  41108,
  41264,
  41420,
  41576,
  41731,
  41886,
  42040,
  42194,
  42348,
  42501,
  42654,
  42806,
  42958,
  43110,
  43261,
  43412,
  43562,
  43713,
  43862,
  44011,
  44160,
  44308,
  44456,
  44604,
  44751,
  44898,
  45044,
  45190,
  45335,
  45480,
  45625,
  45769,
  45912,
  46056,
  46199
}; // idb
int x_DWORD_DBB50[256] =
{
  46341,
  46483,
  46624,
  46765,
  46906,
  47046,
  47186,
  47325,
  47464,
  47603,
  47741,
  47878,
  48015,
  48152,
  48288,
  48424,
  48559,
  48694,
  48828,
  48962,
  49095,
  49228,
  49361,
  49493,
  49624,
  49756,
  49886,
  50016,
  50146,
  50275,
  50404,
  50532,
  50660,
  50787,
  50914,
  51041,
  51166,
  51292,
  51417,
  51541,
  51665,
  51789,
  51911,
  52034,
  52156,
  52277,
  52398,
  52519,
  52639,
  52759,
  52878,
  52996,
  53114,
  53232,
  53349,
  53465,
  53581,
  53697,
  53812,
  53926,
  54040,
  54154,
  54267,
  54379,
  54491,
  54603,
  54714,
  54824,
  54934,
  55043,
  55152,
  55260,
  55368,
  55476,
  55582,
  55689,
  55794,
  55900,
  56004,
  56108,
  56212,
  56315,
  56418,
  56520,
  56621,
  56722,
  56823,
  56923,
  57022,
  57121,
  57219,
  57317,
  57414,
  57511,
  57607,
  57703,
  57798,
  57892,
  57986,
  58079,
  58172,
  58265,
  58356,
  58448,
  58538,
  58628,
  58718,
  58807,
  58896,
  58983,
  59071,
  59158,
  59244,
  59330,
  59415,
  59499,
  59583,
  59667,
  59750,
  59832,
  59914,
  59995,
  60075,
  60156,
  60235,
  60314,
  60392,
  60470,
  60547,
  60624,
  60700,
  60776,
  60851,
  60925,
  60999,
  61072,
  61145,
  61217,
  61288,
  61359,
  61429,
  61499,
  61568,
  61637,
  61705,
  61772,
  61839,
  61906,
  61971,
  62036,
  62101,
  62165,
  62228,
  62291,
  62353,
  62415,
  62476,
  62536,
  62596,
  62655,
  62714,
  62772,
  62830,
  62886,
  62943,
  62998,
  63054,
  63108,
  63162,
  63215,
  63268,
  63320,
  63372,
  63423,
  63473,
  63523,
  63572,
  63621,
  63668,
  63716,
  63763,
  63809,
  63854,
  63899,
  63944,
  63987,
  64031,
  64073,
  64115,
  64156,
  64197,
  64237,
  64277,
  64316,
  64354,
  64392,
  64429,
  64465,
  64501,
  64536,
  64571,
  64605,
  64639,
  64672,
  64704,
  64735,
  64766,
  64797,
  64827,
  64856,
  64884,
  64912,
  64940,
  64967,
  64993,
  65018,
  65043,
  65067,
  65091,
  65114,
  65137,
  65159,
  65180,
  65200,
  65220,
  65240,
  65259,
  65277,
  65294,
  65311,
  65328,
  65343,
  65358,
  65373,
  65387,
  65400,
  65413,
  65425,
  65436,
  65447,
  65457,
  65467,
  65476,
  65484,
  65492,
  65499,
  65505,
  65511,
  65516,
  65521,
  65525,
  65528,
  65531,
  65533,
  65535,
  65536
}; // idb
void(/*__noreturn*/ *off_DBF50[2])() = { (void(*)())&sub_10000, (void(*)())&sub_10000 }; // weak
int x_DWORD_DDF50[] = { 0 }; // weak
int x_DWORD_DDF54 = 32; // weak
Bit16u x_WORD_DE350[0x100] = {
	0x0000,0x0001,0x0002,0x0003,0x0005,0x0006,0x0007,0x0008,
0x000A,0x000B,0x000C,0x000D,0x000F,0x0010,0x0011,0x0013,
0x0014,0x0015,0x0016,0x0018,0x0019,0x001A,0x001B,0x001D,
0x001E,0x001F,0x0020,0x0022,0x0023,0x0024,0x0026,0x0027,
0x0028,0x0029,0x002B,0x002C,0x002D,0x002E,0x0030,0x0031,
0x0032,0x0033,0x0035,0x0036,0x0037,0x0038,0x0039,0x003B,
0x003C,0x003D,0x003E,0x0040,0x0041,0x0042,0x0043,0x0044,
0x0046,0x0047,0x0048,0x0049,0x004B,0x004C,0x004D,0x004E,
0x004F,0x0051,0x0052,0x0053,0x0054,0x0055,0x0057,0x0058,
0x0059,0x005A,0x005B,0x005C,0x005E,0x005F,0x0060,0x0061,
0x0062,0x0063,0x0065,0x0066,0x0067,0x0068,0x0069,0x006A,
0x006B,0x006D,0x006E,0x006F,0x0070,0x0071,0x0072,0x0073,
0x0074,0x0076,0x0077,0x0078,0x0079,0x007A,0x007B,0x007C,
0x007D,0x007E,0x007F,0x0081,0x0082,0x0083,0x0084,0x0085,
0x0086,0x0087,0x0088,0x0089,0x008A,0x008B,0x008C,0x008D,
0x008E,0x008F,0x0090,0x0091,0x0093,0x0094,0x0095,0x0096,
0x0097,0x0098,0x0099,0x009A,0x009B,0x009C,0x009D,0x009E,
0x009F,0x00A0,0x00A1,0x00A2,0x00A3,0x00A4,0x00A5,0x00A6,
0x00A7,0x00A7,0x00A8,0x00A9,0x00AA,0x00AB,0x00AC,0x00AD,
0x00AE,0x00AF,0x00B0,0x00B1,0x00B2,0x00B3,0x00B4,0x00B5,
0x00B6,0x00B6,0x00B7,0x00B8,0x00B9,0x00BA,0x00BB,0x00BC,
0x00BD,0x00BE,0x00BF,0x00BF,0x00C0,0x00C1,0x00C2,0x00C3,
0x00C4,0x00C5,0x00C6,0x00C6,0x00C7,0x00C8,0x00C9,0x00CA,
0x00CB,0x00CB,0x00CC,0x00CD,0x00CE,0x00CF,0x00D0,0x00D0,
0x00D1,0x00D2,0x00D3,0x00D4,0x00D4,0x00D5,0x00D6,0x00D7,
0x00D8,0x00D8,0x00D9,0x00DA,0x00DB,0x00DC,0x00DC,0x00DD,
0x00DE,0x00DF,0x00DF,0x00E0,0x00E1,0x00E2,0x00E2,0x00E3,
0x00E4,0x00E5,0x00E5,0x00E6,0x00E7,0x00E8,0x00E8,0x00E9,
0x00EA,0x00EB,0x00EB,0x00EC,0x00ED,0x00ED,0x00EE,0x00EF,
0x00EF,0x00F0,0x00F1,0x00F2,0x00F2,0x00F3,0x00F4,0x00F4,
0x00F5,0x00F6,0x00F6,0x00F7,0x00F8,0x00F8,0x00F9,0x00FA,
0x00FA,0x00FB,0x00FC,0x00FC,0x00FD,0x00FE,0x00FE,0x00FF,

}; // weak
int x_DWORD_DE554 = 0; // weak
int x_DWORD_DE558 = 0; // weak
int x_DWORD_DE55C = 0; // weak
int x_DWORD_DE560 = 0; // weak
int x_DWORD_DE564 = 0; // weak
int x_DWORD_DE568 = 0; // weak
_UNKNOWN unk_DE56C; // weak
char x_BYTE_E126C = 'p'; // weak
char x_BYTE_E126D = '\0'; // weak
char x_BYTE_E1274 = '\0'; // weak
char x_BYTE_E1275 = '\0'; // weak
__int16 x_WORD_E1276 = 65535; // weak
__int16 x_WORD_E1278 = 0; // weak
__int16 x_WORD_E127A = 8; // weak
Bit8u* x_DWORD_E127E = 0; // weak
Bit8u* x_DWORD_E1282 = 0; // weak
Bit8u* x_DWORD_E1286[8] = { 0, 0, 0, 0, 0, 0, 0, 0 }; // idb
__int16 x_WORD_E12A6 = 0; // weak
__int16 x_WORD_E12A8 = 0; // weak
Bit8u* x_DWORD_E12AA = 0; // weak
Bit8u* x_DWORD_E12AE[8] = { 0, 0, 0, 0, 0, 0, 0, 0 }; // idb
char x_BYTE_E12CE[8] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // idb
//char aTester[7] = "TESTER"; // weak
char x_BYTE_E12EC = '\0'; // weak
char x_BYTE_E12ED = '\0'; // weak
Bit8u* x_DWORD_E12F4 = 0; // weak
__int16 x_WORD_E12FC = 1; // weak
__int16 x_WORD_E12FE = 0; // weak
int x_DWORD_E1300 = 0; // weak
int x_DWORD_E1304 = 0; // weak
int x_DWORD_E1308 = 0; // weak
__int16 x_WORD_E130C = 0; // weak
__int16 x_WORD_E130E = 0; // weak
__int16 x_WORD_E1310 = 0; // weak
__int16 x_WORD_E1312 = 0; // weak
__int16 x_WORD_E1316 = 0; // weak
__int16 x_WORD_E131A = 0; // weak
char x_BYTE_E131C[8] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // idb
char x_BYTE_E1324 = '2'; // weak
void *off_E16E0 = &unk_E1328; // weak
char x_BYTE_E1711[] = { '6' }; // weak
char x_BYTE_E1712[] = { '6' }; // weak
char x_BYTE_E1713[25] =
{
  '6',
  '\0',
  '&',
  '\0',
  '-',
  '\0',
  '\0',
  '#',
  '\0',
  '!',
  '?',
  '\x0F',
  '(',
  '\x16',
  '\x0F',
  '\0',
  '\0',
  '\0',
  '\x17',
  '?',
  '\x1F',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char x_BYTE_E172C[] = { '\"' }; // weak
char x_BYTE_E172D[] = { '\"' }; // weak
char x_BYTE_E172E[] = { '\"' }; // weak
Bit8u unk_E1748[0x100] = {//2b2748
0x00,0x00,0x00,0x00,0x11,0x00,0x9F,0x00,0x01,0x00,0x01,0x08,0x00,0x00,0x00,0x00,
0x13,0x02,0x9C,0x00,0x09,0x00,0x09,0x10,0x00,0x00,0x00,0x00,0x9A,0x00,0x34,0x01,
0x11,0x00,0x11,0x19,0x00,0x00,0x00,0x00,0xE2,0x01,0x34,0x01,0x1A,0x00,0x1A,0x22,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x2B,0x01,0x32,0x01,0x01,0x00,0x01,0x08,0x00,0x00,0x00,0x00,0x5C,0x01,0x76,0x00,
0x09,0x00,0x09,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x41,0x0A,0x00,0x00,0x00,0x00,0x00,0x45,0x03,0x00,0x00,0x00,0x01,0x00,
0x53,0x01,0x00,0x00,0x00,0x01,0x00,0x30,0x01,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0x28,0x00,0x00,0x45,0x04,0x00,0x00,0x00,0x00,0x00,0x56,0x00,0x00,
0x00,0x00,0x00,0x00,0x57,0x00,0x00,0x00,0x00,0x00,0x00,0x55,0x10,0x00,0x00,0x00,
0x00,0x00,0x41,0x0A,0x00,0x00,0x00,0x02,0x00,0x44,0x05,0x00,0x00,0x00,0x05,0x00,
0x53,0x03,0x00,0x00,0x00,0x48,0x00,0x57,0x00,0x00,0x00,0x00,0x48,0x00,0x55,0x11,
0x00,0x00,0x00,0x87,0x00,0x57,0x00,0x00,0x00,0x00,0x87,0x00,0x55,0x12,0x00,0x00,
0x00,0xBD,0x00,0x41,0xF0,0x00,0x00,0x00,0xBE,0x00,0x41,0x05,0x00,0x00,0x00,0xBE,
0x00,0x48,0x01,0x00,0x00,0x00,0xBE,0x00,0x50,0x01,0x00,0x00,0x00,0x04,0x01,0x53,
0x02,0x00,0x00,0x00,0x5E,0x01,0x53,0x0B,0x00,0x00,0x00,0x6D,0x01,0x53,0x0D,0x00
}; // weak
Bit8u unk_E1784[0x100] = {//2b2784
0x8A,0x43,0x0A,0x66,0x89,0x43,0x08,0x8B,0x45,0xFC,0x89,0x03,0x83,0xC3,0x0C,0x66,
0x83,0x7B,0x04,0x00,0x75,0x97,0x80,0x7D,0x14,0x04,0x75,0x49,0xBB,0xAC,0x2B,0x2B,
0x00,0xEB,0x3B,0x80,0x7B,0x17,0x00,0x74,0x32,0x80,0x7B,0x18,0x00,0x74,0x2C,0x0F,
0xB6,0x73,0x15,0x8D,0x04,0xB5,0x00,0x00,0x00,0x00,0x29,0xF0,0x8B,0x15,0xD4,0xEE,
0x34,0x00,0x01,0xC0,0x01,0xD0,0x50,0x0F,0xBF,0x43,0x0C,0x50,0x0F,0xBF,0x43,0x0A,
0x50,0x89,0xDE,0xE8,0x64,0x0F,0xFB,0xFF,0x83,0xC4,0x0C,0x83,0xC3,0x2C,0x66,0x83,
0x7B,0x0A,0x00,0x75,0xBE,0x89,0xF0,0x89,0xEC,0x5D,0x5F,0x5E,0x5B,0xC3,0x8D,0x80,
0x00,0x00,0x00,0x00,0x8D,0x92,0x00,0x00,0x00,0x00,0x8B,0xC0,0x53,0x56,0x57,0x55,
0x89,0xE5,0xF6,0x05,0x60,0x16,0x35,0x00,0x08,0x0F,0x85,0xB4,0x01,0x00,0x00,0x8B,
0x15,0x3C,0xAC,0x2B,0x00,0x85,0xD2,0x74,0x11,0x52,0xE8,0x5D,0x92,0x00,0x00,0x31,
0xC9,0x83,0xC4,0x04,0x89,0x0D,0x3C,0xAC,0x2B,0x00,0xE8,0xCD,0x99,0xFD,0xFF,0x68,
0x8C,0xA1,0x2A,0x00,0xE8,0xB3,0x3F,0xFF,0xFF,0x66,0x8B,0x15,0x60,0x16,0x35,0x00,
0x83,0xC4,0x04,0x66,0x83,0xFA,0x01,0x0F,0x85,0x76,0x01,0x00,0x00,0xBB,0x08,0x00,
0x00,0x00,0x68,0x00,0xB0,0x04,0x00,0x66,0x89,0x15,0xDA,0x39,0x2B,0x00,0x66,0x89,
0x1D,0x60,0x16,0x35,0x00,0xE8,0x62,0x90,0x00,0x00,0x83,0xC4,0x04,0x68,0x8C,0xA1,
0x2A,0x00,0xA3,0x3C,0xAC,0x2B,0x00,0xE8,0x10,0x3F,0xFF,0xFF,0x83,0xC4,0x04,0x68
}; // weak
Bit8u unk_E17CC[0x1000] = {
0x00,0x00,0x45,0x04,0x00,0x00,0x00,
0x00,0x00,0x56,0x00,0x00,0x00,0x00,
0x00,0x00,0x57,0x00,0x00,0x00,0x00,
0x00,0x00,0x55,0x10,0x00,0x00,0x00,
0x00,0x00,0x41,0x0A,0x00,0x00,0x00,
0x02,0x00,0x44,0x05,0x00,0x00,0x00,
0x05,0x00,0x53,0x03,0x00,0x00,0x00,
0x48,0x00,0x57,0x00,0x00,0x00,0x00,
0x48,0x00,0x55,0x11,0x00,0x00,0x00,
0x87,0x00,0x57,0x00,0x00,0x00,0x00,
0x87,0x00,0x55,0x12,0x00,0x00,0x00,
0xBD,0x00,0x41,0xF0,0x00,0x00,0x00,
0xBE,0x00,0x41,0x05,0x00,0x00,0x00,
0xBE,0x00,0x48,0x01,0x00,0x00,0x00,
0xBE,0x00,0x50,0x01,0x00,0x00,0x00,
0x04,0x01,0x53,0x02,0x00,0x00,0x00,
0x5E,0x01,0x53,0x0B,0x00,0x00,0x00,
0x6D,0x01,0x53,0x0D,0x00,0x00,0x00,
0x90,0x01,0x46,0x01,0x00,0x00,0x00,
0x94,0x01,0x41,0x07,0x00,0x00,0x00,
0x9A,0x01,0x53,0x06,0x00,0x00,0x00,
0x9A,0x01,0x57,0x00,0x00,0x00,0x00,
0x9A,0x01,0x55,0x13,0x00,0x00,0x00,
0xFE,0x01,0x53,0x04,0x00,0x00,0x00,
0xFE,0x01,0x57,0x00,0x00,0x00,0x00,
0xFE,0x01,0x55,0x14,0x00,0x00,0x00,
0x46,0x02,0x53,0x09,0x00,0x00,0x00,
0x4D,0x02,0x41,0x05,0x00,0x00,0x00,
0x67,0x02,0x53,0x0A,0x00,0x00,0x00,
0xBC,0x02,0x53,0x08,0x00,0x00,0x00,
0xBC,0x02,0x57,0x00,0x00,0x00,0x00,
0xBC,0x02,0x55,0x15,0x00,0x00,0x00,
0xCD,0x02,0x53,0x0C,0x00,0x00,0x00,
0x22,0x03,0x48,0x0E,0x00,0x00,0x00,
0x22,0x03,0x4F,0x0E,0x00,0x00,0x00,
0x8E,0x03,0x41,0x09,0x00,0x00,0x00,
0xFD,0x03,0x41,0x05,0x00,0x00,0x00,
0xFD,0x03,0x46,0x0E,0x00,0x00,0x00,
0xFF,0x03,0x53,0x07,0x00,0x00,0x00,
0x10,0x04,0x57,0x00,0x00,0x00,0x00,
0x10,0x04,0x55,0x16,0x00,0x00,0x00,
0x17,0x04,0x41,0x0A,0x00,0x00,0x00,
0x17,0x04,0x53,0x05,0x00,0x00,0x00,
0x50,0x04,0x41,0x05,0x00,0x00,0x00,
0x60,0x04,0x53,0x0F,0x00,0x00,0x00,
0xC9,0x04,0x53,0x10,0x00,0x00,0x00,
0xCE,0x04,0x53,0x11,0x00,0x00,0x00,
0xFC,0x04,0x41,0x03,0x00,0x00,0x00,
0xFC,0x04,0x59,0x00,0x00,0x00,0x00,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFE,0x01,
//unk_E192C - 0x160
0x00,0x00,0x41,0x03,0x00,0x00,0x00,
0x00,0x00,0x59,0x00,0x00,0x00,0x00,
0x00,0x00,0x45,0x04,0x00,0x00,0x00,
0x01,0x00,0x53,0x12,0x00,0x00,0x00,
0x01,0x00,0x58,0x05,0x00,0x00,0x00,
0x0A,0x00,0x53,0x13,0x00,0x00,0x00,
0x60,0x00,0x41,0x64,0x00,0x00,0x00,
0x00,0x00,0x22,
//unk_E1960 - 0x194
/*
struct s0 {
	signed char[4] pad4;//4-0
	int16_t f4;//2-4
	int16_t f6;//2-6
	signed char[4] pad18;//4-8
	int16_t f12;//2-12
	signed char[6] pad19;//6-14
	signed char f18;//1-20
	//21
};

*/

0x00,0x00,0x00,0x00,0x74,0x00,0xDE,0x01,0x28,0x00,0x28,0x00,0xA4,0x01,0x34,0x03,0x21,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x70,0x01,0xDE,0x01,0x28,0x00,0x28,0x00,0x9A,0x02,0x25,0x03,0x21,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x40,0x02,0xDE,0x01,0x28,0x00,0x28,0x00,0x71,0x03,0xDE,0x02,0x21,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x04,0x01,0x92,0x01,0x28,0x00,0x28,0x00,0x25,0x02,0x72,0x02,0x21,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x04,0x01,0x92,0x01,0x28,0x00,0x28,0x00,0xC2,0x01,0x8C,0x02,0x21,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x30,0x01,0x92,0x01,0x28,0x00,0x28,0x00,0x62,0x02,0x9A,0x02,0x21,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x30,0x01,0x92,0x01,0x28,0x00,0x28,0x00,0xFB,0x02,0x8C,0x02,0x21,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x30,0x01,0x92,0x01,0x28,0x00,0x28,0x00,0xDC,0x02,0x2E,0x02,0x21,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x30,0x01,0x92,0x01,0x28,0x00,0x28,0x00,0x84,0x02,0x2A,0x02,0x21,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x30,0x01,0x92,0x01,0x28,0x00,0x28,0x00,0x18,0x02,0x1C,0x02,0x21,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x02,0x32,0x01,0x28,0x00,0x28,0x00,0x36,0x03,0xC2,0x01,0x21,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x7E,0x02,0xBE,0x00,0x28,0x00,0x28,0x00,0xF1,0x03,0x9C,0x01,0x21,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x7E,0x02,0x5C,0x00,0x28,0x00,0x28,0x00,0x22,0x04,0x0C,0x01,0x21,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xDE,0x01,0x5C,0x00,0x28,0x00,0x28,0x00,0x85,0x03,0x30,0x01,0x21,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xDE,0x01,0x5C,0x00,0x28,0x00,0x28,0x00,0x31,0x03,0xCA,0x00,0x21,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xDE,0x01,0x5C,0x00,0x28,0x00,0x28,0x00,0xAC,0x02,0x06,0x01,0x21,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x7A,0x00,0x60,0x00,0x28,0x00,0x28,0x00,0x12,0x02,0x3C,0x01,0x21,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x7A,0x00,0x60,0x00,0x28,0x00,0x28,0x00,0xAB,0x01,0xCE,0x00,0x21,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x7A,0x00,0x60,0x00,0x28,0x00,0x28,0x00,0x42,0x01,0xFE,0x00,0x21,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x32,0x01,0xC4,0x00,0x28,0x00,0x28,0x00,0x73,0x02,0xA0,0x01,0x21,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x01,0x00,0x44,0x00,0x28,0x00,0x28,0x00,0xB4,0x00,0x16,0x01,0x21,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x28,0x01,0x44,0x00,0x28,0x00,0x28,0x00,0x61,0x02,0xDA,0x00,0x21,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xE0,0x01,0x00,0x00,0x28,0x00,0x28,0x00,0x46,0x03,0x60,0x00,0x21,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x34,0x01,0x00,0x00,0x28,0x00,0x28,0x00,0xA7,0x02,0x7E,0x00,0x21,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x34,0x01,0x00,0x00,0x28,0x00,0x28,0x00,0x5D,0x02,0x78,0x00,0x21,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x83,0x25,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xCE,0x00,0x43,0x00,0x50,0x00,0x50,0x00,0x9A,0x01,0x3B,0x33,0x06,0x01,0x00,0x00,0x4E,0x00,
0x4E,0x00,0x00,0x00,
0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x9E,0x25,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x19,0x01,0x41,0x00,0x50,0x00,0x50,0x00,0x94,0x01,
0x3C,0x34,0x0A,0x01,0x00,0x00,0x64,0x01,0x70,0x00,0x00,0x00,0x00,0x00,0x50,0x00,
0x00,0x00,0xA4,0x01,0x00,0x00,0x03,0x00,0x80,0xEE,0x25,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x6A,0x01,0x48,0x00,0x50,0x00,0x50,0x00,0x99,0x01,0x3D,0x35,0x07,0x01,
0x00,0x00,0xAE,0x01,0x4E,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x9C,0x01,
0x00,0x00,0x03,0x00,0x30,0x97,0x25,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x00,
0x9D,0x00,0x50,0x00,0x50,0x00,0x96,0x01,0x3E,0x36,0x09,0x01,0x00,0x00,0x4E,0x00,
0xA0,0x00,0x00,0x00,0x00,0x00,0xC8,0x00,0x00,0x00,0xA6,0x01,0x00,0x00,0x03,0x00,
0x10,0xA6,0x25,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x95,0x01,0xE7,0x00,0x3C,0x00,
0x2C,0x00,0xCF,0x01,0x6A,0x6A,0x0F,0x01,0x00,0x00,0x60,0x01,0xAE,0x00,0x00,0x00,
0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0xF0,0x90,0x25,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x87,0x01,0x9E,0x00,0x50,0x00,0x50,0x00,0x95,0x01,
0x3F,0x37,0x08,0x01,0x00,0x00,0xC0,0x01,0xA0,0x00,0x00,0x00,0x00,0x00,0xC8,0x00,
0x00,0x00,0xA5,0x01,0x00,0x00,0x03,0x00,0x80,0x89,0x25,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x26,0x01,0x19,0x00,0x34,0x00,0x2C,0x00,0x97,0x01,0x40,0x38,0x0B,0x01,
0x00,0x00,0x60,0x01,0x1A,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x97,0x01,
0x00,0x00,0x03,0x00,0xE0,0x89,0x25,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x21,0x01,
0x9B,0x00,0x3C,0x00,0x2C,0x00,0x98,0x01,0x41,0x39,0x0C,0x01,0x00,0x00,0x60,0x01,
0xAE,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,
0x60,0xA1,0x25,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xB9,0x00,0xE8,0x00,0x3C,0x00,
0x2C,0x00,0x9B,0x01,0x42,0x3A,0x0D,0x01,0x00,0x00,0x4A,0x00,0xF6,0x00,0x00,0x00,
0x00,0x00,0x64,0x00,0x00,0x00,0x9B,0x01,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0xDC,0x25,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x1C,0x01,0x02,0x00,0x1E,0x00,0x0A,0x00,0x00,0x00,0x0B,0x04,0x00,0x01,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x03,0x00,0x30,0xDD,0x25,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1A,0x01,
0x22,0x00,0x1E,0x00,0x0A,0x00,0x00,0x00,0x0C,0x05,0x00,0x01,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,
0xA0,0xDC,0x25,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6F,0x00,0x65,0x00,0x28,0x00,
0x28,0x00,0x00,0x00,0x08,0x01,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0xA0,0xDD,0x25,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0xC1,0x01,0x64,0x00,0x28,0x00,0x28,0x00,0x00,0x00,
0x09,0x02,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0xF0,0xDB,0x25,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x9A,0x00,0x03,0x01,0x50,0x00,0x96,0x00,0x00,0x00,0x0D,0x06,0x00,0x01,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x03,0x00,0x40,0xDC,0x25,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x8F,0x01,
0x02,0x01,0x50,0x00,0x96,0x00,0x00,0x00,0x0E,0x07,0x00,0x01,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x1E,0xBC,0x05,0x00,
0xD0,0x32,0x00,0x00,0xBD,0x6B,0x07,0x00,0x00,0x03,0x00,0x00,0xF4,0x00,0x85,0x00,
0x88,0x00,0x5C,0x01,0xEE,0xEE,0x05,0x00,0x82,0x32,0x00,0x00,0xBD,0x6E,0x07,0x00,
0x00,0x03,0x00,0x00,0xD0,0x00,0x81,0x00,0xB4,0x00,0x60,0x01,0x70,0x21,0x06,0x00,
0xE3,0x3B,0x00,0x00,0xBD,0x71,0x07,0x00,0x00,0x03,0x00,0x00,0xE2,0x00,0x90,0x00,
0x96,0x00,0x51,0x01,0x53,0x5D,0x06,0x00,0xB6,0x42,0x00,0x00,0xBD,0x74,0x07,0x00,
0x00,0x03,0x00,0x00,0xE0,0x00,0x6F,0x00,0xA4,0x00,0x72,0x01,0x09,0xA0,0x06,0x00,
0x29,0x30,0x00,0x00,0xBD,0x77,0x07,0x00,0x00,0x03,0x00,0x00,0xEC,0x00,0x70,0x00,
0x9C,0x00,0x71,0x01,0x32,0xD0,0x06,0x00,0x89,0x2E,0x00,0x00,0xBD,0x7A,0x07,0x00,
0x00,0x03,0x00,0x00,0xE0,0x00,0x87,0x00,0xB4,0x00,0x60,0x01,0xBB,0xFE,0x06,0x00,
0xDC,0x3B,0x00,0x00,0xBD,0x7D,0x07,0x00,0x00,0x03,0x00,0x00,0xDD,0x00,0x84,0x00,
0xA5,0x00,0x5D,0x01,0x97,0x3A,0x07,0x00,0x26,0x31,0x00,0x00,0xBD,0x80,0x07,0x00,
0x00,0x03,0x00,0x00,0xF0,0x00,0x8B,0x00,0x8C,0x00,0x56,0x01,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xAE,0x01,0x4E,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,
0x9D,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x23,0x01,0xCD,0x00,0x3C,0x00,0x3C,0x00,0x00,0x00,0x24,0x23,0x01,0x01,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x01,
0x63,0x00,0x3C,0x00,0x3C,0x00,0x00,0x00,0x4C,0x4D,0x02,0x01,0x01,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x11,0x01,0x0A,0x00,0x3C,0x00,0x3C,0x00,0x00,0x00,
0x00,0x6D,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x1B,0x01,0x7D,0x01,0x3C,0x00,0x3C,0x00,0x00,0x00,0x00,0x6C,0x02,0x01,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x00,0x28,0x31,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x31,0x00,0x31,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x01,0x00,0x25,0x00,0x02,0x00,0x25,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x80,0x01,
0x00,0x00,0x1F,0x02,0xC0,0x03,0x8C,0x00,0x91,0x00,0x8C,0x00,0x8C,0x00,0x91,0x00,
0x32,0x00,0x01,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x25,0x00,0x02,0x00,0x25,0x00,0x03,0x00,0x00,
0x00,0x00,0x00,0x8B,0x01,0x0A,0x00,0x26,0x02,0xCA,0x03,0x8C,0x00,0x91,0x00,0x8C,
0x00,0x8C,0x00,0x91,0x00,0x32,0x00,0x01,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x25,0x00,0x02,0x00,
0x25,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x90,0x01,0x06,0x00,0x2B,0x02,0xD4,0x03,
0x8C,0x00,0x91,0x00,0x8C,0x00,0x8C,0x00,0x91,0x00,0x32,0x00,0x01,0x00,0x03,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
0x00,0x27,0x00,0x02,0x00,0x27,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0xBE,
0x00,0xFC,0x04,0x34,0x01,0xCE,0x00,0xD3,0x00,0xCE,0x00,0xCE,0x00,0xD3,0x00,0x28,
0x00,0x01,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x01,0x00,0x25,0x00,0x02,0x00,0x25,0x00,0x03,0x00,0x00,0x00,
0x00,0x00,0xCB,0x01,0x00,0x00,0xFE,0x04,0xC0,0x03,0x92,0x00,0x97,0x00,0x92,0x00,
0x92,0x00,0x97,0x00,0x14,0x00,0x01,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x09,0x00,0x02,0x00,0x03,
0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x53,0x02,0x00,0x00,0x3A,0x02,0x7C,0x02,0x15,
0x01,0x1C,0x01,0x15,0x01,0x5D,0x00,0x67,0x00,0x00,0x00,0x02,0x00,0x03,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
0x09,0x00,0x02,0x00,0x03,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x62,0x02,0x72,0x00,
0x62,0x02,0x72,0x00,0x29,0x01,0x30,0x01,0x29,0x01,0x29,0x01,0x30,0x01,0x00,0x00,
0x03,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x01,0x00,0x09,0x00,0x02,0x00,0x03,0x00,0x03,0x00,0x00,0x00,0x00,
0x00,0x65,0x01,0x00,0x00,0x1F,0x01,0x90,0x02,0x6B,0x00,0x72,0x00,0x6B,0x00,0x5D,
0x00,0x67,0x00,0x0F,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x09,0x00,0x02,0x00,0x03,0x00,
0x03,0x00,0x00,0x00,0x00,0x00,0xAB,0x03,0x00,0x00,0x6F,0x03,0x66,0x02,0x6B,0x00,
0x72,0x00,0x6B,0x00,0x5D,0x00,0x67,0x00,0x0F,0x00,0x01,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x09,
0x00,0x02,0x00,0x03,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0xAF,0x01,0x00,0x00,0x69,
0x01,0x00,0x02,0x6B,0x00,0x72,0x00,0x6B,0x00,0x5D,0x00,0x67,0x00,0x0B,0x00,0x01,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x04,0x00,0x09,0x00,0x02,0x00,0x03,0x00,0x03,0x00,0x00,0x00,0x00,0x00,
0xC7,0x01,0x00,0x00,0x8B,0x01,0x72,0x00,0x6B,0x00,0x72,0x00,0x6B,0x00,0x5D,0x00,
0x67,0x00,0x12,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x20,0xF6,0x25,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x45,0x02,
0xAB,0x01,0x28,0x00,0x46,0x00,0x00,0x00,0xF7,0xF6,0x0B,0x01,0x00,0x01,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,
0x40,0xF6,0x25,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0xAB,0x01,0x28,0x00,
0x46,0x00,0x00,0x00,0xF9,0xF8,0x10,0x01,0x00,0x01,0x25,0x00,0x5C,0x01,0x00,0x00,
0x00,0x00,0x3C,0x00,0x00,0x00,0xD3,0x01,0x00,0x00,0x03,0x00,0x00,0xF8,0x25,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x00,0x46,0x00,0x96,0x01,
0xFB,0xFA,0x09,0x01,0x00,0x01,0x1D,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,0xC8,0x00,
0x00,0x00,0xA6,0x01,0x00,0x00,0x03,0x00,0x20,0xF8,0x25,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x45,0x02,0x00,0x00,0x28,0x00,0x46,0x00,0x95,0x01,0xFD,0xFC,0x08,0x01,
0x00,0x01,0xFE,0x01,0x3C,0x00,0x00,0x00,0x00,0x00,0xC8,0x00,0x00,0x00,0xA5,0x01,
0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xC7,0x01,0x28,0x00,0x31,0x00,0xC4,0x00,0x26,0x00,0x00,0x00,0x1B,0x01,0x6A,0x00,
0x02,0x00,0xC6,0x01,0x2A,0x01,0x2C,0x01,0x8D,0x01,0x2A,0x01,0x00,0x00,0x41,0x01,
0xEC,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0xD1,0x01,0x03,0x01,0x20,0x03,0x5D,0x01,0x20,0x03,
0x00,0x00,0x53,0x01,0x20,0x03,0x02,0x0B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xD2,0x01,0x2F,0x01,0x69,0x01,
0xDC,0x01,0x6A,0x01,0x00,0x00,0x3C,0x02,0xB8,0x01,0x02,0x0B,0x95,0x01,0x5E,0x01,
0x41,0x00,0x11,0x02,0x52,0x00,0x00,0x00,0x54,0x02,0x1C,0x00,0x08,0x08,0x96,0x01,
0x7E,0x00,0x41,0x00,0x7B,0x00,0x52,0x00,0x00,0x00,0x37,0x00,0x1C,0x00,0x08,0x09,
0xD3,0x01,0x7F,0x00,0x68,0x01,0x7B,0x00,0x76,0x01,0x00,0x00,0x34,0x00,0xB0,0x01,
0x08,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xC9,0x01,0x04,0x00,0xB8,0x00,0x42,0x00,0xB6,0x00,0x00,0x00,
0x7E,0x00,0x82,0x00,0x00,0x00,0xCB,0x01,0x05,0x00,0x68,0x01,0x4D,0x00,0x68,0x01,
0x00,0x00,0x95,0x00,0x30,0x01,0x00,0x00,0xCA,0x01,0xBC,0x01,0x6A,0x01,0x27,0x02,
0x6A,0x01,0x00,0x00,0xC6,0x01,0x22,0x01,0x00,0x00,0xC8,0x01,0xBC,0x01,0xA8,0x00,
0x28,0x02,0xA8,0x00,0x00,0x00,0xE8,0x01,0x74,0x00,0x00,0x00,0xCC,0x01,0xA3,0x01,
0x0D,0x00,0xD7,0x01,0x19,0x00,0x00,0x00,0x48,0x01,0x18,0x00,0x08,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x9F,0x01,0x02,0x00,0x4D,0x00,0x7D,0x00,0x5A,0x00,0x3B,0x00,0xDE,0x00,0x5A,0x00,
0x02,0x06,0xA0,0x01,0x13,0x00,0x74,0x00,0xAC,0x00,0x7C,0x00,0x01,0x00,0x19,0x01,
0x7C,0x00,0x02,0x0A,0x96,0x01,0x11,0x00,0xF6,0x00,0x5F,0x00,0xF6,0x00,0x3E,0x00,
0xC0,0x00,0xAA,0x00,0x00,0x09,0x9B,0x01,0x11,0x00,0x68,0x01,0x5F,0x00,0x68,0x01,
0x3E,0x00,0xC1,0x00,0x1C,0x01,0x00,0x0D,0xA3,0x01,0xDC,0x00,0x55,0x01,0x3E,0x01,
0x55,0x01,0x41,0x00,0x3C,0x01,0xD0,0x00,0x00,0x0C,0xCF,0x01,0x9A,0x01,0x48,0x01,
0x03,0x02,0x61,0x01,0x3F,0x00,0xB5,0x01,0x22,0x01,0x08,0x0F,0xA2,0x01,0x84,0x01,
0xED,0x00,0xE5,0x01,0xEC,0x00,0x3F,0x00,0xB0,0x01,0xC4,0x00,0x08,0x08,0xA1,0x01,
0x96,0x01,0x9D,0x00,0xFC,0x01,0xA6,0x00,0x3D,0x00,0xA8,0x01,0x62,0x00,0x08,0x07,
0x97,0x01,0x9B,0x01,0x1F,0x00,0xE8,0x01,0x29,0x00,0x40,0x00,0x5A,0x01,0x28,0x00,
0x08,0x0B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xB5,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xB6,0x01,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x68,0x01,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xBF,0x01,0x74,0x02,0x73,0x00,0x8A,0x00,0x73,0x00,0x04,0x00,
0x00,0x01,0x07,0x00,0x26,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x6C,0x03,0x16,0x02,0x73,0x00,0x8A,0x00,0x75,0x00,0x08,0x00,0x00,0x01,
0x08,0x00,0x26,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x21,0x02,0x36,0x00,0x55,0x00,0x55,0x00,0x55,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x8F,0x02,
0x3A,0x00,0x55,0x00,0x55,0x00,0x57,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x34,0x02,0x58,0x00,
0x55,0x00,0x55,0x00,0x58,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x66,0x02,0x7B,0x00,0x55,0x00,
0x55,0x00,0x59,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x21,0x02,0x36,0x00,0x56,0x00,0x5C,0x00,
0x56,0x00,0x08,0x00,0x00,0x01,0x09,0x00,0x17,0x00,0x03,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x8F,0x02,0x3A,0x00,0x56,0x00,0x5C,0x00,0x58,0x00,
0x04,0x00,0x00,0x01,0xFF,0xFF,0x17,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x34,0x02,0x58,0x00,0x56,0x00,0x5C,0x00,0x59,0x00,0x16,0x00
};
//_UNKNOWN unk_E192C; // weak
//_UNKNOWN unk_E1960; // weak
__int16 x_WORD_E1964[] = { 116 }; // weak
__int16 x_WORD_E1966[] = { 478 }; // weak
__int16 x_WORD_E196C[] = { 420 }; // weak
__int16 x_WORD_E196E[] = { 820 }; // weak
__int16 x_WORD_E1970 = 33; // weak
char x_BYTE_E1972[484] =
{
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'p',
  '\x01',
  '\0',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  '\x9A',
  '\x02',
  '%',
  '\x03',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '@',
  '\x02',
  '\0',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  'q',
  '\x03',
  '\0',
  '\x02',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x04',
  '\x01',
  '\x92',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  '%',
  '\x02',
  'r',
  '\x02',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x04',
  '\x01',
  '\x92',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  '\0',
  '\x01',
  '\x8C',
  '\x02',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '\x01',
  '\x92',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  'b',
  '\x02',
  '\x9A',
  '\x02',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '\x01',
  '\x92',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  '\xFB',
  '\x02',
  '\x8C',
  '\x02',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '\x01',
  '\x92',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  '\0',
  '\x02',
  '.',
  '\x02',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '\x01',
  '\x92',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  '\x84',
  '\x02',
  '*',
  '\x02',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '\x01',
  '\x92',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  '\x18',
  '\x02',
  '\x1C',
  '\x02',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x02',
  '2',
  '\x01',
  '(',
  '\0',
  '(',
  '\0',
  '6',
  '\x03',
  '\0',
  '\x01',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '~',
  '\x02',
  '\xBE',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  '\0',
  '\x03',
  '\x9C',
  '\x01',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '~',
  '\x02',
  '\\',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  '\"',
  '\x04',
  '\f',
  '\x01',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\\',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  '\x85',
  '\x03',
  '0',
  '\x01',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\\',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  '1',
  '\x03',
  '\0',
  '\0',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\\',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  '\xAC',
  '\x02',
  '\x06',
  '\x01',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'z',
  '\0',
  '`',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  '\x12',
  '\x02',
  '<',
  '\x01',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'z',
  '\0',
  '`',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  '\xAB',
  '\x01',
  '\0',
  '\0',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'z',
  '\0',
  '`',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  'B',
  '\x01',
  '\xFE',
  '\0',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '2',
  '\x01',
  '\0',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  's',
  '\x02',
  '\xA0',
  '\x01',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  'D',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  '\xB4',
  '\0',
  '\x16',
  '\x01',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '(',
  '\x01',
  'D',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  'a',
  '\x02',
  '\0',
  '\0',
  '!',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '(',
  '\0',
  '(',
  '\0',
  'F',
  '\x03',
  '`',
  '\0',
  '!',
  '\0'
}; // idb
__int16 x_WORD_E1B66 = 679; // weak
__int16 x_WORD_E1B68 = 126; // weak
char x_BYTE_E1B82 = '\x02'; // weak
char x_BYTE_E1B9C[8] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // idb
char x_BYTE_E1BA4[8] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // idb
Bit8u off_E1BAC[4096] =
{
	//adress                          //var1  //var4       //var5                                                                          //var 26(13) //var 28(14)                      //var26+4(17) //var 26+5(18)
	0x50,0x83,0x25,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00, 0xCE,0x00, 0x43,0x00,0x50,0x00,0x50,0x00,0x9A,0x01,0x3B,0x33,0x06,0x01,0x00,0x00, 0x4E,0x00,  0x4E,0x00,    0x00,0x00,0x00,0x00, 0x50,0x00,    0x00,0x00,    0x00,0x00,0x00,0x00,0x03,0x00,
	0x00,0x9E,0x25,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00, 0x19,0x01, 0x41,0x00,0x50,0x00,0x50,0x00,0x94,0x01,0x3C,0x34,0x0A,0x01,0x00,0x00, 0x64,0x01,  0x70,0x00,    0x00,0x00,0x00,0x00, 0x50,0x00,    0x00,0x00,    0xA4,0x01,0x00,0x00,0x03,0x00,
	0x80,0xEE,0x25,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00, 0x6A,0x01, 0x48,0x00,0x50,0x00,0x50,0x00,0x99,0x01,0x3D,0x35,0x07,0x01,0x00,0x00, 0xAE,0x01,  0x4E,0x00,    0x00,0x00,0x00,0x00, 0x50,0x00,    0x00,0x00,    0x9C,0x01,0x00,0x00,0x03,0x00,
	0x30,0x97,0x25,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00, 0xC8,0x00, 0x9D,0x00,0x50,0x00,0x50,0x00,0x96,0x01,0x3E,0x36,0x09,0x01,0x00,0x00, 0x4E,0x00,  0xA0,0x00,    0x00,0x00,0x00,0x00, 0xC8,0x00,    0x00,0x00,    0xA6,0x01,0x00,0x00,0x03,0x00,
	0x10,0xA6,0x25,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00, 0x95,0x01, 0xE7,0x00,0x3C,0x00,0x2C,0x00,0xCF,0x01,0x6A,0x6A,0x0F,0x01,0x00,0x00, 0x60,0x01,  0xAE,0x00,    0x00,0x00,0x00,0x00, 0x50,0x00,    0x00,0x00,    0x00,0x00,0x00,0x00,0x03,0x00,
	0xF0,0x90,0x25,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00, 0x87,0x01, 0x9E,0x00,0x50,0x00,0x50,0x00,0x95,0x01,0x3F,0x37,0x08,0x01,0x00,0x00, 0xC0,0x01,  0xA0,0x00,    0x00,0x00,0x00,0x00, 0xC8,0x00,    0x00,0x00,    0xA5,0x01,0x00,0x00,0x03,0x00,
	0x80,0x89,0x25,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00, 0x26,0x01, 0x19,0x00,0x34,0x00,0x2C,0x00,0x97,0x01,0x40,0x38,0x0B,0x01,0x00,0x00, 0x60,0x01,  0x1A,0x00,    0x00,0x00,0x00,0x00, 0x50,0x00,    0x00,0x00,    0x97,0x01,0x00,0x00,0x03,0x00,
	0xE0,0x89,0x25,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00, 0x21,0x01, 0x9B,0x00,0x3C,0x00,0x2C,0x00,0x98,0x01,0x41,0x39,0x0C,0x01,0x00,0x00, 0x60,0x01,  0xAE,0x00,    0x00,0x00,0x00,0x00, 0x50,0x00,    0x00,0x00,    0x00,0x00,0x00,0x00,0x03,0x00,
	0x60,0xA1,0x25,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00, 0xB9,0x00, 0xE8,0x00,0x3C,0x00,0x2C,0x00,0x9B,0x01,0x42,0x3A,0x0D,0x01,0x00,0x00, 0x4A,0x00,  0xF6,0x00,    0x00,0x00,0x00,0x00, 0x64,0x00,    0x00,0x00,    0x9B,0x01,0x00,0x00,0x03,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,  0x00,0x00,    0x00,0x00,0x00,0x00, 0x00,0x00,    0x00,0x00,    0x00,0x00,0x00,0x00,0x00,0x00,
	0xF0,0xDC,0x25,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00, 0x1C,0x01, 0x02,0x00,0x1E,0x00,0x0A,0x00,0x00,0x00,0x0B,0x04,0x00,0x01,0x00,0x00, 0x00,0x00,  0x00,0x00,    0x00,0x00,0x00,0x00, 0x00,0x00,    0x00,0x00,    0x00,0x00,0x00,0x00,0x03,0x00,
	0x30,0xDD,0x25,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00, 0x1A,0x01, 0x22,0x00,0x1E,0x00,0x0A,0x00,0x00,0x00,0x0C,0x05,0x00,0x01,0x00,0x00, 0x00,0x00,  0x00,0x00,    0x00,0x00,0x00,0x00, 0x00,0x00,    0x00,0x00,    0x00,0x00,0x00,0x00,0x03,0x00,
	0xA0,0xDC,0x25,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00, 0x6F,0x00, 0x65,0x00,0x28,0x00,0x28,0x00,0x00,0x00,0x08,0x01,0x00,0x01,0x00,0x00, 0x00,0x00,  0x00,0x00,    0x00,0x00,0x00,0x00, 0x00,0x00,    0x00,0x00,    0x00,0x00,0x00,0x00,0x03,0x00,
	0xA0,0xDD,0x25,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00, 0xC1,0x01, 0x64,0x00,0x28,0x00,0x28,0x00,0x00,0x00,0x09,0x02,0x00,0x01,0x00,0x00, 0x00,0x00,  0x00,0x00,    0x00,0x00,0x00,0x00, 0x00,0x00,    0x00,0x00,    0x00,0x00,0x00,0x00,0x03,0x00,
	0xF0,0xDB,0x25,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00, 0x9A,0x00, 0x03,0x01,0x50,0x00,0x96,0x00,0x00,0x00,0x0D,0x06,0x00,0x01,0x00,0x00, 0x00,0x00,  0x00,0x00,    0x00,0x00,0x00,0x00, 0x00,0x00,    0x00,0x00,    0x00,0x00,0x00,0x00,0x03,0x00,
	0x40,0xDC,0x25,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00, 0x8F,0x01, 0x02,0x01,0x50,0x00,0x96,0x00,0x00,0x00,0x0E,0x07,0x00,0x01,0x00,0x00, 0x00,0x00,  0x00,0x00,    0x00,0x00,0x00,0x00, 0x00,0x00,    0x00,0x00,    0x00,0x00,0x00,0x00,0x03,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00, 0x00,0x00,     0x00,0x00,0x00,0x00, 0x00,0x00,    0x00,0x00,    0x00,0x00,0x00,0x00,0x03,0x00,
	0x1E,0xBC,0x05,0x00, 0xD0,0x32,0x00,0x00, 0xBD,0x6B, 0x07,0x00, 0x00,0x03,0x00,0x00,0xF4,0x00,0x85,0x00,0x88,0x00,0x5C,0x01,0xEE,0xEE, 0x05,0x00, 0x82,0x32,     0x00,0x00,0xBD,0x6E, 0x07,0x00,    0x00,0x03,    0x00,0x00,0xD0,0x00,0x81,0x00,
	0xB4,0x00,0x60,0x01, 0x70,0x21,0x06,0x00, 0xE3,0x3B, 0x00,0x00, 0xBD,0x71,0x07,0x00,0x00,0x03,0x00,0x00,0xE2,0x00,0x90,0x00,0x96,0x00, 0x51,0x01, 0x53,0x5D,     0x06,0x00,0xB6,0x42, 0x00,0x00,    0xBD,0x74,    0x07,0x00,0x00,0x03,0x00,0x00,
	0xE0,0x00,0x6F,0x00,0xA4,0x00,0x72,0x01,0x09,0xA0,0x06,0x00,
	0x29,0x30,0x00,0x00,0xBD,0x77,0x07,0x00,0x00,0x03,0x00,0x00,0xEC,0x00,0x70,0x00,
	0x9C,0x00,0x71,0x01,0x32,0xD0,0x06,0x00,0x89,0x2E,0x00,0x00,0xBD,0x7A,0x07,0x00,
	0x00,0x03,0x00,0x00,0xE0,0x00,0x87,0x00,0xB4,0x00,0x60,0x01,0xBB,0xFE,0x06,0x00,
	0xDC,0x3B,0x00,0x00,0xBD,0x7D,0x07,0x00,0x00,0x03,0x00,0x00,0xDD,0x00,0x84,0x00,
	0xA5,0x00,0x5D,0x01,0x97,0x3A,0x07,0x00,0x26,0x31,0x00,0x00,0xBD,0x80,0x07,0x00,
	0x00,0x03,0x00,0x00,0xF0,0x00,0x8B,0x00,0x8C,0x00,0x56,0x01,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0xAE,0x01,0x4E,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,
	0x9D,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x23,0x01,0xCD,0x00,0x3C,0x00,0x3C,0x00,0x00,0x00,0x24,0x23,0x01,0x01,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x01,
	0x63,0x00,0x3C,0x00,0x3C,0x00,0x00,0x00,0x4C,0x4D,0x02,0x01,0x01,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x11,0x01,0x0A,0x00,0x3C,0x00,0x3C,0x00,0x00,0x00,
	0x00,0x6D,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x1B,0x01,0x7D,0x01,0x3C,0x00,0x3C,0x00,0x00,0x00,0x00,0x6C,0x02,0x01,
	0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x00,0x28,0x31,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x31,0x00,0x31,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x01,0x00,0x25,0x00,0x02,0x00,0x25,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x80,0x01,
	0x00,0x00,0x1F,0x02,0xC0,0x03,0x8C,0x00,0x91,0x00,0x8C,0x00,0x8C,0x00,0x91,0x00,
	0x32,0x00,0x01,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x25,0x00,0x02,0x00,0x25,0x00,0x03,0x00,0x00,
	0x00,0x00,0x00,0x8B,0x01,0x0A,0x00,0x26,0x02,0xCA,0x03,0x8C,0x00,0x91,0x00,0x8C,
	0x00,0x8C,0x00,0x91,0x00,0x32,0x00,0x01,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x25,0x00,0x02,0x00,
	0x25,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x90,0x01,0x06,0x00,0x2B,0x02,0xD4,0x03,
	0x8C,0x00,0x91,0x00,0x8C,0x00,0x8C,0x00,0x91,0x00,0x32,0x00,0x01,0x00,0x03,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
	0x00,0x27,0x00,0x02,0x00,0x27,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0xBE,
	0x00,0xFC,0x04,0x34,0x01,0xCE,0x00,0xD3,0x00,0xCE,0x00,0xCE,0x00,0xD3,0x00,0x28,
	0x00,0x01,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x01,0x00,0x25,0x00,0x02,0x00,0x25,0x00,0x03,0x00,0x00,0x00,
	0x00,0x00,0xCB,0x01,0x00,0x00,0xFE,0x04,0xC0,0x03,0x92,0x00,0x97,0x00,0x92,0x00,
	0x92,0x00,0x97,0x00,0x14,0x00,0x01,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x09,0x00,0x02,0x00,0x03,
	0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x53,0x02,0x00,0x00,0x3A,0x02,0x7C,0x02,0x15,
	0x01,0x1C,0x01,0x15,0x01,0x5D,0x00,0x67,0x00,0x00,0x00,0x02,0x00,0x03,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
	0x09,0x00,0x02,0x00,0x03,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x62,0x02,0x72,0x00,
	0x62,0x02,0x72,0x00,0x29,0x01,0x30,0x01,0x29,0x01,0x29,0x01,0x30,0x01,0x00,0x00,
	0x03,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x00,0x09,0x00,0x02,0x00,0x03,0x00,0x03,0x00,0x00,0x00,0x00,
	0x00,0x65,0x01,0x00,0x00,0x1F,0x01,0x90,0x02,0x6B,0x00,0x72,0x00,0x6B,0x00,0x5D,
	0x00,0x67,0x00,0x0F,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x09,0x00,0x02,0x00,0x03,0x00,
	0x03,0x00,0x00,0x00,0x00,0x00,0xAB,0x03,0x00,0x00,0x6F,0x03,0x66,0x02,0x6B,0x00,
	0x72,0x00,0x6B,0x00,0x5D,0x00,0x67,0x00,0x0F,0x00,0x01,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x09,
	0x00,0x02,0x00,0x03,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0xAF,0x01,0x00,0x00,0x69,
	0x01,0x00,0x02,0x6B,0x00,0x72,0x00,0x6B,0x00,0x5D,0x00,0x67,0x00,0x0B,0x00,0x01,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x04,0x00,0x09,0x00,0x02,0x00,0x03,0x00,0x03,0x00,0x00,0x00,0x00,0x00,
	0xC7,0x01,0x00,0x00,0x8B,0x01,0x72,0x00,0x6B,0x00,0x72,0x00,0x6B,0x00,0x5D,0x00,
	0x67,0x00,0x12,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x20,0xF6,0x25,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x45,0x02,
	0xAB,0x01,0x28,0x00,0x46,0x00,0x00,0x00,0xF7,0xF6,0x0B,0x01,0x00,0x01,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,
	0x40,0xF6,0x25,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0xAB,0x01,0x28,0x00,
	0x46,0x00,0x00,0x00,0xF9,0xF8,0x10,0x01,0x00,0x01,0x25,0x00,0x5C,0x01,0x00,0x00,
	0x00,0x00,0x3C,0x00,0x00,0x00,0xD3,0x01,0x00,0x00,0x03,0x00,0x00,0xF8,0x25,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x00,0x46,0x00,0x96,0x01,
	0xFB,0xFA,0x09,0x01,0x00,0x01,0x1D,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,0xC8,0x00,
	0x00,0x00,0xA6,0x01,0x00,0x00,0x03,0x00,0x20,0xF8,0x25,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x45,0x02,0x00,0x00,0x28,0x00,0x46,0x00,0x95,0x01,0xFD,0xFC,0x08,0x01,
	0x00,0x01,0xFE,0x01,0x3C,0x00,0x00,0x00,0x00,0x00,0xC8,0x00,0x00,0x00,0xA5,0x01,
	0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0xC7,0x01,0x28,0x00,0x31,0x00,0xC4,0x00,0x26,0x00,0x00,0x00,0x1B,0x01,0x6A,0x00,
	0x02,0x00,0xC6,0x01,0x2A,0x01,0x2C,0x01,0x8D,0x01,0x2A,0x01,0x00,0x00,0x41,0x01,
	0xEC,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0xD1,0x01,0x03,0x01,0x20,0x03,0x5D,0x01,0x20,0x03,
	0x00,0x00,0x53,0x01,0x20,0x03,0x02,0x0B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xD2,0x01,0x2F,0x01,0x69,0x01,
	0xDC,0x01,0x6A,0x01,0x00,0x00,0x3C,0x02,0xB8,0x01,0x02,0x0B,0x95,0x01,0x5E,0x01,
	0x41,0x00,0x11,0x02,0x52,0x00,0x00,0x00,0x54,0x02,0x1C,0x00,0x08,0x08,0x96,0x01,
	0x7E,0x00,0x41,0x00,0x7B,0x00,0x52,0x00,0x00,0x00,0x37,0x00,0x1C,0x00,0x08,0x09,
	0xD3,0x01,0x7F,0x00,0x68,0x01,0x7B,0x00,0x76,0x01,0x00,0x00,0x34,0x00,0xB0,0x01,
	0x08,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0xC9,0x01,0x04,0x00,0xB8,0x00,0x42,0x00,0xB6,0x00,0x00,0x00,
	0x7E,0x00,0x82,0x00,0x00,0x00,0xCB,0x01,0x05,0x00,0x68,0x01,0x4D,0x00,0x68,0x01,
	0x00,0x00,0x95,0x00,0x30,0x01,0x00,0x00,0xCA,0x01,0xBC,0x01,0x6A,0x01,0x27,0x02,
	0x6A,0x01,0x00,0x00,0xC6,0x01,0x22,0x01,0x00,0x00,0xC8,0x01,0xBC,0x01,0xA8,0x00,
	0x28,0x02,0xA8,0x00,0x00,0x00,0xE8,0x01,0x74,0x00,0x00,0x00,0xCC,0x01,0xA3,0x01,
	0x0D,0x00,0xD7,0x01,0x19,0x00,0x00,0x00,0x48,0x01,0x18,0x00,0x08,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x9F,0x01,0x02,0x00,0x4D,0x00,0x7D,0x00,0x5A,0x00,0x3B,0x00,0xDE,0x00,0x5A,0x00,
	0x02,0x06,0xA0,0x01,0x13,0x00,0x74,0x00,0xAC,0x00,0x7C,0x00,0x01,0x00,0x19,0x01,
	0x7C,0x00,0x02,0x0A,0x96,0x01,0x11,0x00,0xF6,0x00,0x5F,0x00,0xF6,0x00,0x3E,0x00,
	0xC0,0x00,0xAA,0x00,0x00,0x09,0x9B,0x01,0x11,0x00,0x68,0x01,0x5F,0x00,0x68,0x01,
	0x3E,0x00,0xC1,0x00,0x1C,0x01,0x00,0x0D,0xA3,0x01,0xDC,0x00,0x55,0x01,0x3E,0x01,
	0x55,0x01,0x41,0x00,0x3C,0x01,0xD0,0x00,0x00,0x0C,0xCF,0x01,0x9A,0x01,0x48,0x01,
	0x03,0x02,0x61,0x01,0x3F,0x00,0xB5,0x01,0x22,0x01,0x08,0x0F,0xA2,0x01,0x84,0x01,
	0xED,0x00,0xE5,0x01,0xEC,0x00,0x3F,0x00,0xB0,0x01,0xC4,0x00,0x08,0x08,0xA1,0x01,
	0x96,0x01,0x9D,0x00,0xFC,0x01,0xA6,0x00,0x3D,0x00,0xA8,0x01,0x62,0x00,0x08,0x07,
	0x97,0x01,0x9B,0x01,0x1F,0x00,0xE8,0x01,0x29,0x00,0x40,0x00,0x5A,0x01,0x28,0x00,
	0x08,0x0B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0xB5,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0xB6,0x01,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x68,0x01,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0xBF,0x01,0x74,0x02,0x73,0x00,0x8A,0x00,0x73,0x00,0x04,0x00,
	0x00,0x01,0x07,0x00,0x26,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x6C,0x03,0x16,0x02,0x73,0x00,0x8A,0x00,0x75,0x00,0x08,0x00,0x00,0x01,
	0x08,0x00,0x26,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x21,0x02,0x36,0x00,0x55,0x00,0x55,0x00,0x55,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x8F,0x02,
	0x3A,0x00,0x55,0x00,0x55,0x00,0x57,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x34,0x02,0x58,0x00,
	0x55,0x00,0x55,0x00,0x58,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x66,0x02,0x7B,0x00,0x55,0x00,
	0x55,0x00,0x59,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x21,0x02,0x36,0x00,0x56,0x00,0x5C,0x00,
	0x56,0x00,0x08,0x00,0x00,0x01,0x09,0x00,0x17,0x00,0x03,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x8F,0x02,0x3A,0x00,0x56,0x00,0x5C,0x00,0x58,0x00,
	0x04,0x00,0x00,0x01,0xFF,0xFF,0x17,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x34,0x02,0x58,0x00,0x56,0x00,0x5C,0x00,0x59,0x00,0x16,0x00,
	0x00,0x01,0xFF,0xFF,0x17,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x66,0x02,0x7B,0x00,0x56,0x00,0x5C,0x00,0x5A,0x00,0x15,0x00,0x00,0x01,
	0xFF,0xFF,0x17,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x3F,0x03,0xF5,0x00,0x2E,0x00,0x3A,0x00,0x31,0x00,0x00,0x00,0x01,0x00,0x0A,0x00,
	0x05,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0x03,
	0xF5,0x00,0x2E,0x00,0x3A,0x00,0x31,0x00,0x00,0x00,0x01,0x01,0x0A,0x00,0x05,0x00,
	0x02,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5F,0x03,0x49,0x01,
	0x2E,0x00,0x3A,0x00,0x2E,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,0x05,0x00,0x02,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x76,0x02,0x5F,0x02,0x2E,0x00,
	0x3A,0x00,0x34,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,0x05,0x00,0x02,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF4,0x00,0x78,0x02,0x2E,0x00,0x3A,0x00,
	0x38,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,0x05,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xD4,0x00,0x32,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xBC,0x01,0x01,0x00,0x00,0x00,0xD4,0x00,
	0x53,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xBD,0x01,0x00,0x00,0x00,0x00,
	0xD4,0x00,0x74,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xBE,0x01,0x00,0x00,
	0x00,0x00,0xD4,0x00,0x95,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xBF,0x01,
	0x00,0x00,0x00,0x00,0xD4,0x00,0xB6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0xC0,0x01,0x00,0x00,0x00,0x00,0xD4,0x00,0xD7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0xC1,0x01,0x00,0x00,0x00,0x00,0xD4,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0xC2,0x01,0x00,0x00,0x00,0x00,0xD4,0x00,0x19,0x01,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0xC3,0x01,0x00,0x00,0x00,0x00,0xD4,0x00,0x3A,0x01,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC4,0x01,0x00,0x00,0x00,0x00,0xD4,0x00,
	0x5B,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC5,0x01,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x1E,0x00,0x1F,0x01,0x90,0x02,
	0x03,0x00,0x0E,0x01,0x00,0x00,0x00,0x00,0x00,0x07,0x00,0x1F,0x00,0x6F,0x03,0x66,
	0x02,0x03,0x00,0x0E,0x01,0x00,0x00,0x00,0x00,0x00,0x0B,0x00,0x20,0x00,0x56,0x03,
	0x90,0x01,0x03,0x00,0x0E,0x01,0x00,0x00,0x00,0x00,0x00,0x11,0x00,0x21,0x00,0x8B,
	0x01,0x72,0x00,0x03,0x00,0x0E,0x01,0x00,0x00,0x00,0x00,0x00,0x13,0x00,0x22,0x00,
	0x6D,0x01,0xF8,0x01,0x03,0x00,0x0E,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x15,0x00,0x00,0x00,
	0x04,0x01,0x00,0x02,0x01,0x00,0x00,0x00,0x7F,0x03,0x02,0x04,0x00,0x00,0x47,0x65,
	0x6E,0x75,0x69,0x6E,0x65,0x49,0x6E,0x74,0x65,0x6C,0x01,0x00,0x47,0x65,0x6E,0x75,
	0x69,0x6E,0x65,0x49,0x6E,0x74,0x65,0x6C,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x0A,0x00,0x00,0x00,0x03,0x01,0x00,
	0x64,0x2C,0x2A,0x00,0x7C,0x2C,0x2A,0x00,0x8C,0x2C,0x2A,0x00,0x9C,0x2C,0x2A,0x00,
	0xAC,0x2C,0x2A,0x00,0xB8,0x2C,0x2A,0x00,0xDC,0x2C,0x2A,0x00,0xE8,0x2C,0x2A,0x00,
	0xF8,0x2C,0x2A,0x00,0x0C,0x2D,0x2A,0x00,0x24,0x2D,0x2A,0x00,0x30,0x2D,0x2A,0x00,
	0x3C,0x2D,0x2A,0x00,0x4C,0x2D,0x2A,0x00,0x4C,0x2D,0x2A,0x00,0x58,0x2D,0x2A,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x04,0x00,0x1E,0x01,0x32,0x00,0x40,0x01,
	0x50,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,
	0x00,0x00,0x02,0x02,0x01,0x00,0x00,0x02,0x1F,0x01,0x32,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,
	0x02,0x02,0x01,0x00,0x04,0x00,0x20,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,
	0x00,0x00,0x58,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x06,0x06,
	0x01,0x00,0x24,0x00,0x21,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,
	0x2C,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x2C,0x01,0x00,0x00,0x04,0x04,0x01,0x00,
	0x20,0x02,0x22,0x01,0x32,0x00,0xD6,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x58,0x02,
	0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x02,0x02,0x01,0x00,0x04,0x04,
	0x23,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,
	0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x02,0x02,0x01,0x00,0x04,0x00,0x24,0x01,
	0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x00,0x00,
	0x00,0x00,0x58,0x02,0x00,0x00,0x02,0x02,0x01,0x00,0x04,0x00,0x25,0x01,0x32,0x00,
	0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x00,0x00,0x00,0x00,
	0x58,0x02,0x00,0x00,0x02,0x02,0x01,0x00,0x04,0x00,0x26,0x01,0x32,0x00,0x40,0x01,
	0x50,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,
	0x00,0x00,0x02,0x02,0x01,0x00,0x24,0x06,0x27,0x01,0x32,0x00,0x40,0x01,0x50,0x00

}; // idb
x_WORD off_E1D64[22] =
{
  52464,
  7,
  0,
  0,
  0,
  284,
  2,
  30,
  10,
  0,
  1035,
  256,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  3
}; // idb
void *off_E1E98 = (void *)0x5BC1E; // weak
signed __int16 x_WORD_E1F70[10] = { 430, 78, 0, 0, 80, 0, 413, 0, 0, 0 }; // idb
Bit16s x_WORD_E1F84[68] =
{
	//                                   xmin  ymin   sizex	 sizey        type?
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0123,0x00CD,0x003C,0x003C,0x0000,0x2324,
	//11      12    13     14     15    16       17   18     19     click  noncl
	0x0101,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0003,

	0x0000,0x0000,0x0000,0x0000,0x0000,0x0120,0x0063,0x003C,0x003C,0x0000,0x4D4C,
	0x0102,0x0001,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0003,

	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,

	0x0000,0x0000
}; // idb
x_WORD x_WORD_E2008[66] =//2b3008 zmena 2b3008
{
0x0000,0x0000,0x0000,0x0000,0x0000,0x0111,0x000A,0x003C,0x003C,0x0000,0x6D00,0x0101,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0003,
0x0000,0x0000,0x0000,0x0000,0x0000,0x011B,0x017D,0x003C,0x003C,0x0000,0x6C00,0x0102,0x0001,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0003,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000

}; // idb
int x_DWORD_E208C = 0; // weak
__int16 x_WORD_E2094 = 40; // weak
char x_BYTE_E2096 = '('; // weak
char x_BYTE_E2097 = '1'; // weak
Bit16s x_WORD_E20A4[440] =//2b30a4
{
  0x0000,0x0000,0x0000,0x0000,0x0001,0x0025,0x0002,0x0025,0x0003,0x0000,0x0000,
  0x0180,0x0000,0x021F,0x03C0,0x008C,0x0091,0x008C,0x008C,0x0091,0x0032,0x0001,
  0x0003,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
  0x0000,0x0000,0x0000,0x0000,0x0000,0x0100,0x2500,0x0200,0x2500,0x0300,0x0000,
  0x0000,0x8B00,0x0A01,0x2600,0xCA02,0x8C03,0x9100,0x8C00,0x8C00,0x9100,0x3200,
  0x0100,0x0300,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
  0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0001,0x0025,0x0002,0x0025,
  0x0003,0x0000,0x0000,0x0190,0x0006,0x022B,0x03D4,0x008C,0x0091,0x008C,0x008C,
0x0091,0x0032,0x0001,0x0003,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0100,0x2700,0x0200,
0x2700,0x0300,0x0000,0x0000,0x0100,0xBE00,0xFC00,0x3404,0xCE01,0xD300,0xCE00,
0xCE00,0xD300,0x2800,0x0100,0x0300,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0001,
0x0025,0x0002,0x0025,0x0003,0x0000,0x0000,0x01CB,0x0000,0x04FE,0x03C0,0x0092,
0x0097,0x0092,0x0092,0x0097,0x0014,0x0001,0x0003,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0100,0x0900,0x0200,0x0300,0x0300,0x0000,0x0000,0x5300,0x0002,0x3A00,0x7C02,
0x1502,0x1C01,0x1501,0x5D01,0x6700,0x0000,0x0200,0x0300,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0001,0x0009,0x0002,0x0003,0x0003,0x0000,0x0000,0x0262,0x0072,
0x0262,0x0072,0x0129,0x0130,0x0129,0x0129,0x0130,0x0000,0x0003,0x0018,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0100,0x0900,0x0200,0x0300,0x0300,0x0000,0x0000,0x6500,
0x0001,0x1F00,0x9001,0x6B02,0x7200,0x6B00,0x5D00,0x6700,0x0F00,0x0100,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0002,0x0009,0x0002,0x0003,0x0003,0x0000,
0x0000,0x03AB,0x0000,0x036F,0x0266,0x006B,0x0072,0x006B,0x005D,0x0067,0x000F,
0x0001,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0300,0x0900,0x0200,0x0300,0x0300,
0x0000,0x0000,0xAF00,0x0001,0x6900,0x0001,0x6B02,0x7200,0x6B00,0x5D00,0x6700,
0x0B00,0x0100,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0004,0x0009,0x0002,
0x0003,0x0003,0x0000,0x0000,0x01C7,0x0000,0x018B,0x0072,0x006B,0x0072,0x006B,
0x005D,0x0067,0x0012,0x0001,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0xF620,0x0025,0x0000,0x0000,
0x0000,0x0245,0x01AB,0x0028,0x0046,0x0000,0xF6F7,0x010B,0x0100,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0003,0xF640,0x0025,0x0000,0x0000

}; // idb
Bit8u off_E23E0[264] =
{
//0  1     2    3    4    5    6    7    8    9    10   11   12   13   14   15   16   17  18    19   20   21    22   23   24   25   26   27   28   29  30  31     32   33   34  35   36   37   38    39  40   41   42   43   
0x20,0xF6,0x25,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x45,0x02,0xAB,0x01,0x28,0x00,0x46,0x00,0x00,0x00,0xF7,0xF6,0x0B,0x01,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,
0x40,0xF6,0x25,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0xAB,0x01,0x28,0x00,0x46,0x00,0x00,0x00,0xF9,0xF8,0x10,0x01,0x00,0x01,0x25,0x00,0x5C,0x01,0x00,0x00,0x00,0x00,0x3C,0x00,0x00,0x00,0xD3,0x01,0x00,0x00,0x03,0x00,
0x00,0xF8,0x25,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x00,0x46,0x00,0x96,0x01,0xFB,0xFA,0x09,0x01,0x00,0x01,0x1D,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,0xC8,0x00,0x00,0x00,0xA6,0x01,0x00,0x00,0x03,0x00,
0x20,0xF8,0x25,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x45,0x02,0x00,0x00,0x28,0x00,0x46,0x00,0x95,0x01,0xFD,0xFC,0x08,0x01,0x00,0x01,0xFE,0x01,0x3C,0x00,0x00,0x00,0x00,0x00,0xC8,0x00,0x00,0x00,0xA5,0x01,0x00,0x00,0x03,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xC7,0x01,0x28,0x00,0x31,0x00,0xC4,0x00,0x26,0x00,0x00,0x00,0x1B,0x01,0x6A,0x00,0x02,0x00,0xC6,0x01,0x2A,0x01,0x2C,0x01,0x8D,0x01,0x2A,0x01,0x00,0x00,0x41,0x01,0xEC,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
}; // idb
Bit8u unk_E24BCx[0x51a] = {
0xC7,0x01,0x28,0x00,0x31,0x00,0xC4,0x00,0x26,0x00,0x00,0x00,0x1B,0x01,0x6A,0x00,
0x02,0x00,0xC6,0x01,0x2A,0x01,0x2C,0x01,0x8D,0x01,0x2A,0x01,0x00,0x00,0x41,0x01,
0xEC,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0xD1,0x01,0x03,0x01,0x20,0x03,0x5D,0x01,0x20,0x03,
0x00,0x00,0x53,0x01,0x20,0x03,0x02,0x0B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xD2,0x01,0x2F,0x01,0x69,0x01,
0xDC,0x01,0x6A,0x01,0x00,0x00,0x3C,0x02,0xB8,0x01,0x02,0x0B,0x95,0x01,0x5E,0x01,
0x41,0x00,0x11,0x02,0x52,0x00,0x00,0x00,0x54,0x02,0x1C,0x00,0x08,0x08,0x96,0x01,
0x7E,0x00,0x41,0x00,0x7B,0x00,0x52,0x00,0x00,0x00,0x37,0x00,0x1C,0x00,0x08,0x09,
0xD3,0x01,0x7F,0x00,0x68,0x01,0x7B,0x00,0x76,0x01,0x00,0x00,0x34,0x00,0xB0,0x01,
0x08,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xC9,0x01,0x04,0x00,0xB8,0x00,0x42,0x00,0xB6,0x00,0x00,0x00,
0x7E,0x00,0x82,0x00,0x00,0x00,0xCB,0x01,0x05,0x00,0x68,0x01,0x4D,0x00,0x68,0x01,
0x00,0x00,0x95,0x00,0x30,0x01,0x00,0x00,0xCA,0x01,0xBC,0x01,0x6A,0x01,0x27,0x02,
0x6A,0x01,0x00,0x00,0xC6,0x01,0x22,0x01,0x00,0x00,0xC8,0x01,0xBC,0x01,0xA8,0x00,
0x28,0x02,0xA8,0x00,0x00,0x00,0xE8,0x01,0x74,0x00,0x00,0x00,0xCC,0x01,0xA3,0x01,
0x0D,0x00,0xD7,0x01,0x19,0x00,0x00,0x00,0x48,0x01,0x18,0x00,0x08,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x9F,0x01,0x02,0x00,0x4D,0x00,0x7D,0x00,0x5A,0x00,0x3B,0x00,0xDE,0x00,0x5A,0x00,
0x02,0x06,0xA0,0x01,0x13,0x00,0x74,0x00,0xAC,0x00,0x7C,0x00,0x01,0x00,0x19,0x01,
0x7C,0x00,0x02,0x0A,0x96,0x01,0x11,0x00,0xF6,0x00,0x5F,0x00,0xF6,0x00,0x3E,0x00,
0xC0,0x00,0xAA,0x00,0x00,0x09,0x9B,0x01,0x11,0x00,0x68,0x01,0x5F,0x00,0x68,0x01,
0x3E,0x00,0xC1,0x00,0x1C,0x01,0x00,0x0D,0xA3,0x01,0xDC,0x00,0x55,0x01,0x3E,0x01,
0x55,0x01,0x41,0x00,0x3C,0x01,0xD0,0x00,0x00,0x0C,0xCF,0x01,0x9A,0x01,0x48,0x01,
0x03,0x02,0x61,0x01,0x3F,0x00,0xB5,0x01,0x22,0x01,0x08,0x0F,0xA2,0x01,0x84,0x01,
0xED,0x00,0xE5,0x01,0xEC,0x00,0x3F,0x00,0xB0,0x01,0xC4,0x00,0x08,0x08,0xA1,0x01,
0x96,0x01,0x9D,0x00,0xFC,0x01,0xA6,0x00,0x3D,0x00,0xA8,0x01,0x62,0x00,0x08,0x07,
0x97,0x01,0x9B,0x01,0x1F,0x00,0xE8,0x01,0x29,0x00,0x40,0x00,0x5A,0x01,0x28,0x00,
0x08,0x0B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xB5,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xB6,0x01,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x68,0x01,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xBF,0x01,0x74,0x02,0x73,0x00,0x8A,0x00,0x73,0x00,0x04,0x00,
0x00,0x01,0x07,0x00,0x26,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x6C,0x03,0x16,0x02,0x73,0x00,0x8A,0x00,0x75,0x00,0x08,0x00,0x00,0x01,
0x08,0x00,0x26,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x21,0x02,0x36,0x00,0x55,0x00,0x55,0x00,0x55,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x8F,0x02,
0x3A,0x00,0x55,0x00,0x55,0x00,0x57,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x34,0x02,0x58,0x00,
0x55,0x00,0x55,0x00,0x58,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x66,0x02,0x7B,0x00,0x55,0x00,
0x55,0x00,0x59,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x21,0x02,0x36,0x00,0x56,0x00,0x5C,0x00,
0x56,0x00,0x08,0x00,0x00,0x01,0x09,0x00,0x17,0x00,0x03,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x8F,0x02,0x3A,0x00,0x56,0x00,0x5C,0x00,0x58,0x00,
0x04,0x00,0x00,0x01,0xFF,0xFF,0x17,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x34,0x02,0x58,0x00,0x56,0x00,0x5C,0x00,0x59,0x00,0x16,0x00,
0x00,0x01,0xFF,0xFF,0x17,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x66,0x02,0x7B,0x00,0x56,0x00,0x5C,0x00,0x5A,0x00,0x15,0x00,0x00,0x01,
0xFF,0xFF,0x17,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x3F,0x03,0xF5,0x00,0x2E,0x00,0x3A,0x00,0x31,0x00,0x00,0x00,0x01,0x00,0x0A,0x00,
0x05,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0x03,
0xF5,0x00,0x2E,0x00,0x3A,0x00,0x31,0x00,0x00,0x00,0x01,0x01,0x0A,0x00,0x05,0x00,
0x02,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5F,0x03,0x49,0x01,
0x2E,0x00,0x3A,0x00,0x2E,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,0x05,0x00,0x02,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x76,0x02,0x5F,0x02,0x2E,0x00,
0x3A,0x00,0x34,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,0x05,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF4,0x00,0x78,0x02,0x2E,0x00,0x3A,0x00,
0x38,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,0x05,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xD4,0x00,0x32,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xBC,0x01,0x01,0x00,0x00,0x00,0xD4,0x00,
0x53,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xBD,0x01,0x00,0x00,0x00,0x00,
0xD4,0x00,0x74,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xBE,0x01,0x00,0x00,
0x00,0x00,0xD4,0x00,0x95,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xBF,0x01,
0x00,0x00,0x00,0x00,0xD4,0x00,0xB6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xC0,0x01,0x00,0x00,0x00,0x00,0xD4,0x00,0xD7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xC1,0x01,0x00,0x00,0x00,0x00,0xD4,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xC2,0x01,0x00,0x00,0x00,0x00,0xD4,0x00,0x19,0x01,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0xC3,0x01,0x00,0x00,0x00,0x00,0xD4,0x00,0x3A,0x01,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC4,0x01,0x00,0x00,0x00,0x00,0xD4,0x00,
0x5B,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC5,0x01,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x1E,0x00,0x1F,0x01,0x90,0x02,
0x03,0x00,0x0E,0x01,0x00,0x00,0x00,0x00,0x00,0x07,0x00,0x1F,0x00,0x6F,0x03,0x66,
0x02,0x03,0x00,0x0E,0x01,0x00,0x00,0x00,0x00,0x00,0x0B,0x00,0x20,0x00,0x56,0x03,
0x90,0x01,0x03,0x00,0x0E,0x01,0x00,0x00,0x00,0x00,0x00,0x11,0x00,0x21,0x00,0x8B,
0x01,0x72,0x00,0x03,0x00,0x0E,0x01,0x00,0x00,0x00,0x00,0x00,0x13,0x00,0x22,0x00,
0x6D,0x01,0xF8,0x01,0x03,0x00,0x0E,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
}; // weak
//__int16 x_WORD_E24BE[18] = { 40, 49, 196, 38, 0, 283, 106, 2, 454, 298, 300, 397, 298, 0, 321, 236, 8, 0 }; // 2b34be
Bit16u x_WORD_E24BE[27] = { // 2b34be

0x0028,0x0031,0x00C4,0x0026,0x0000,0x011B,0x006A,0x0002,0x01C6,
0x012A,0x012C,0x018D,0x012A,0x0000,0x0141,0x00EC,0x0008,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x01D1
/*0x0103,0x0320,0x015D,0x0320,0x0000,0x0153,0x0320,0x0B02,0x0000,
0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x01D2,0x012F,0x0169,0x01DC,
0x016A,0x0000,0x023C,0x01B8,0x0B02,0x0195,0x015E,0x0041,
0x0211,0x0052,0x0000,0x0254,0x001C,0x0808,0x0196,0x007E,
0x0041,0x007B,0x0052,0x0000,0x0037,0x001C,0x0908,0x01D3,
0x007F,0x0168,0x007B,0x0176,0x0000,0x0034,0x01B0,0x1008,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x01C9,0x0004,0x00B8,0x0042,0x00B6,0x0000,0x007E,*/


};
/*0x03,0x01,0x20,0x03,0x5D,0x01,0x20,0x03,0x00,0x00,//fe
0x53,0x01,0x20,0x03,0x02,0x0B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//0e
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xD2,0x01,0x2F,0x01,0x69,0x01,0xDC,0x01,//1e
0x6A,0x01,0x00,0x00,0x3C,0x02,0xB8,0x01,0x02,0x0B,0x95,0x01,0x5E,0x01,0x41,0x00,//xx */



Bit8u unk_E24F2[12] = { 0xD1,0x01,0x03,0x01,0x20,0x03,0x5D,0x01,0x20,0x03,0x00,0x00 };
Bit16s unk_E2516[] = {
	0x01D2,0x012F,0x0169,0x01DC,0x016A,0x0000,0x023C,0x01B8,0x0B02,//0
	0x0195,0x015E,0x0041,0x0211,0x0052,0x0000,0x0254,0x001C,0x0808,//18
	0x0196,0x007E,0x0041,0x007B,0x0052,0x0000,0x0037,0x001C,0x0908,//36
	0x01D3,0x007F,0x0168,0x007B,0x0176,0x0000,0x0034,0x01B0,0x1008,//36
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,//54
	0x01C9,0x0004,0x00B8,0x0042,0x00B6,0x0000,0x007E,0x0082,0x0000,//72
	0x01CB,0x0005,0x0168,0x004D,0x0168,0x0000,0x0095,0x0130,0x0000,//90
	0x01CA,0x01BC,0x016A,0x0227,0x016A,0x0000,0x01C6,0x0122,0x0000,//108
	0x01C8,0x01BC,0x00A8,0x0228,0x00A8,0x0000,0x01E8,0x0074,0x0000,//126
	0x01CC,0x01A3,0x000D,0x01D7,0x0019,0x0000,0x0148,0x0018,0x0008,//144
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000//162
	/*
	0x019F,0x0002,0x004D,0x007D,0x005A,0x003B,0x00DE,0x005A,0x0602,//here begin unk_E25DC
	0x01A0,0x0013,0x0074,0x00AC,0x007C,0x0001,0x0119,0x007C,0x0A02,
	0x0196,0x0011,0x00F6,0x005F,0x00F6,0x003E,0x00C0,0x00AA,0x0900,
	0x019B,0x0011,0x0168,0x005F,0x0168,0x003E,0x00C1,0x011C,0x0D00,
	0x01A3,0x00DC,0x0155,0x013E,0x0155,0x0041,0x013C,0x00D0,0x0C00,
0x01CF,0x019A,0x0148,0x0203,0x0161,0x003F,0x01B5,0x0122,0x0F08,
0x01A2,0x0184,0x00ED,0x01E5,0x00EC,0x003F,0x01B0,0x00C4,0x0808,
0x01A1,0x0196,0x009D,0x01FC,0x00A6,0x003D,0x01A8,0x0062,0x0708,
0x0197,0x019B,0x001F,0x01E8,0x0029,0x0040,0x015A,0x0028,0x0B08,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x01B5,0x0000,0x0001,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x01B6,0x0000,0x0002,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0168,0x0000,0x0000,0x0000,0x0000,0x01BF,0x0274,0x0073,0x008A,
0x0073,0x0004,0x0100,0x0007,0x0026,0x0002,0x0000,0x0000,0x0000
*/

}; // weak
//__int16 x_WORD_E2518[] = { 303 }; // weak
/*char x_BYTE_E2527[72] =
*/
//_UNKNOWN unk_E2570; // weak
/*Bit16s x_WORD_E2572[60] =//2B3572
{
0x0004,0x00B8,0x0042,0x00B6,0x0000,0x007E,0x0082,0x0000,0x01CB,0x0005,0x0168,0x004D,0x0168,0x0000,0x0095,
0x0130,0x0000,0x01CA,0x01BC,0x016A,0x0227,0x016A,0x0000,0x01C6,0x0122,0x0000,0x01C8,0x01BC,0x00A8,0x0228,
0x00A8,0x0000,0x01E8,0x0074,0x0000,0x01CC,0x01A3,0x000D,0x01D7,0x0019,0x0000,0x0148,0x0018,0x0008,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x019F,0x0002,0x004D,0x007D,0x005A,0x003B,0x00DE
};*/ // idb



Bit8u unk_E25DC[0x1000] = {
0x9F,0x01,0x02,0x00,0x4D,0x00,0x7D,0x00,0x5A,0x00,0x3B,0x00,0xDE,0x00,0x5A,0x00,0x02,0x06,
0xA0,0x01,0x13,0x00,0x74,0x00,0xAC,0x00,0x7C,0x00,0x01,0x00,0x19,0x01,0x7C,0x00,0x02,0x0A,
0x96,0x01,0x11,0x00,0xF6,0x00,0x5F,0x00,0xF6,0x00,0x3E,0x00,0xC0,0x00,0xAA,0x00,0x00,0x09,
0x9B,0x01,0x11,0x00,0x68,0x01,0x5F,0x00,0x68,0x01,0x3E,0x00,0xC1,0x00,0x1C,0x01,0x00,0x0D,
0xA3,0x01,0xDC,0x00,0x55,0x01,0x3E,0x01,0x55,0x01,0x41,0x00,0x3C,0x01,0xD0,0x00,0x00,0x0C,
0xCF,0x01,0x9A,0x01,0x48,0x01,0x03,0x02,0x61,0x01,0x3F,0x00,0xB5,0x01,0x22,0x01,0x08,0x0F,
0xA2,0x01,0x84,0x01,
0xED,0x00,0xE5,0x01,0xEC,0x00,0x3F,0x00,0xB0,0x01,0xC4,0x00,0x08,0x08,0xA1,0x01,
0x96,0x01,0x9D,0x00,0xFC,0x01,0xA6,0x00,0x3D,0x00,0xA8,0x01,0x62,0x00,0x08,0x07,
0x97,0x01,0x9B,0x01,0x1F,0x00,0xE8,0x01,0x29,0x00,0x40,0x00,0x5A,0x01,0x28,0x00,
0x08,0x0B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xB5,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xB6,0x01,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x68,0x01,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xBF,0x01,0x74,0x02,0x73,0x00,0x8A,0x00,0x73,0x00,0x04,0x00,
0x00,0x01,0x07,0x00,0x26,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x6C,0x03,0x16,0x02,0x73,0x00,0x8A,0x00,0x75,0x00,0x08,0x00,0x00,0x01,
0x08,0x00,0x26,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x21,0x02,0x36,0x00,0x55,0x00,0x55,0x00,0x55,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x8F,0x02,
0x3A,0x00,0x55,0x00,0x55,0x00,0x57,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x34,0x02,0x58,0x00,
0x55,0x00,0x55,0x00,0x58,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x66,0x02,0x7B,0x00,0x55,0x00,
0x55,0x00,0x59,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x21,0x02,0x36,0x00,0x56,0x00,0x5C,0x00,
0x56,0x00,0x08,0x00,0x00,0x01,0x09,0x00,0x17,0x00,0x03,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x8F,0x02,0x3A,0x00,0x56,0x00,0x5C,0x00,0x58,0x00,
0x04,0x00,0x00,0x01,0xFF,0xFF,0x17,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x34,0x02,0x58,0x00,0x56,0x00,0x5C,0x00,0x59,0x00,0x16,0x00,
0x00,0x01,0xFF,0xFF,0x17,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x66,0x02,0x7B,0x00,0x56,0x00,0x5C,0x00,0x5A,0x00,0x15,0x00,0x00,0x01,
0xFF,0xFF,0x17,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x3F,0x03,0xF5,0x00,0x2E,0x00,0x3A,0x00,0x31,0x00,0x00,0x00,0x01,0x00,0x0A,0x00,
0x05,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0x03,
0xF5,0x00,0x2E,0x00,0x3A,0x00,0x31,0x00,0x00,0x00,0x01,0x01,0x0A,0x00,0x05,0x00,
0x02,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5F,0x03,0x49,0x01,
0x2E,0x00,0x3A,0x00,0x2E,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,0x05,0x00,0x02,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x76,0x02,0x5F,0x02,0x2E,0x00,
0x3A,0x00,0x34,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,0x05,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF4,0x00,0x78,0x02,0x2E,0x00,0x3A,0x00,
0x38,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,0x05,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xD4,0x00,0x32,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xBC,0x01,0x01,0x00,0x00,0x00,0xD4,0x00,
0x53,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xBD,0x01,0x00,0x00,0x00,0x00,
0xD4,0x00,0x74,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xBE,0x01,0x00,0x00,
0x00,0x00,0xD4,0x00,0x95,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xBF,0x01,
0x00,0x00,0x00,0x00,0xD4,0x00,0xB6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xC0,0x01,0x00,0x00,0x00,0x00,0xD4,0x00,0xD7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xC1,0x01,0x00,0x00,0x00,0x00,0xD4,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xC2,0x01,0x00,0x00,0x00,0x00,0xD4,0x00,0x19,0x01,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0xC3,0x01,0x00,0x00,0x00,0x00,0xD4,0x00,0x3A,0x01,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC4,0x01,0x00,0x00,0x00,0x00,0xD4,0x00,
0x5B,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC5,0x01,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x1E,0x00,0x1F,0x01,0x90,0x02,
0x03,0x00,0x0E,0x01,0x00,0x00,0x00,0x00,0x00,0x07,0x00,0x1F,0x00,0x6F,0x03,0x66,
0x02,0x03,0x00,0x0E,0x01,0x00,0x00,0x00,0x00,0x00,0x0B,0x00,0x20,0x00,0x56,0x03,
0x90,0x01,0x03,0x00,0x0E,0x01,0x00,0x00,0x00,0x00,0x00,0x11,0x00,0x21,0x00,0x8B,
0x01,0x72,0x00,0x03,0x00,0x0E,0x01,0x00,0x00,0x00,0x00,0x00,0x13,0x00,0x22,0x00,
0x6D,0x01,0xF8,0x01,0x03,0x00,0x0E,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x01,0x00,
0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x15,0x00,0x00,0x00,
0x04,0x01,0x00,0x02,0x01,0x00,0x00,0x00,0x7F,0x03,0x02,0x04,0x00,0x00,0x47,0x65,
0x6E,0x75,0x69,0x6E,0x65,0x49,0x6E,0x74,0x65,0x6C,0x01,0x00,0x47,0x65,0x6E,0x75,
0x69,0x6E,0x65,0x49,0x6E,0x74,0x65,0x6C,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x0A,0x00,0x00,0x00,0x03,0x01,0x00,
0x64,0x2C,0x2A,0x00,0x7C,0x2C,0x2A,0x00,0x8C,0x2C,0x2A,0x00,0x9C,0x2C,0x2A,0x00,
0xAC,0x2C,0x2A,0x00,0xB8,0x2C,0x2A,0x00,0xDC,0x2C,0x2A,0x00,0xE8,0x2C,0x2A,0x00,
0xF8,0x2C,0x2A,0x00,0x0C,0x2D,0x2A,0x00,0x24,0x2D,0x2A,0x00,0x30,0x2D,0x2A,0x00,
0x3C,0x2D,0x2A,0x00,0x4C,0x2D,0x2A,0x00,0x4C,0x2D,0x2A,0x00,0x58,0x2D,0x2A,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x04,0x00,0x1E,0x01,0x32,0x00,0x40,0x01,
0x50,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,
0x00,0x00,0x02,0x02,0x01,0x00,0x00,0x02,0x1F,0x01,0x32,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,
0x02,0x02,0x01,0x00,0x04,0x00,0x20,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,
0x00,0x00,0x58,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x06,0x06,
0x01,0x00,0x24,0x00,0x21,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,
0x2C,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x2C,0x01,0x00,0x00,0x04,0x04,0x01,0x00,
0x20,0x02,0x22,0x01,0x32,0x00,0xD6,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x58,0x02,
0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x02,0x02,0x01,0x00,0x04,0x04,
0x23,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,
0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x02,0x02,0x01,0x00,0x04,0x00,0x24,0x01,
0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x00,0x00,
0x00,0x00,0x58,0x02,0x00,0x00,0x02,0x02,0x01,0x00,0x04,0x00,0x25,0x01,0x32,0x00,
0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x00,0x00,0x00,0x00,
0x58,0x02,0x00,0x00,0x02,0x02,0x01,0x00,0x04,0x00,0x26,0x01,0x32,0x00,0x40,0x01,
0x50,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,
0x00,0x00,0x02,0x02,0x01,0x00,0x24,0x06,0x27,0x01,0x32,0x00,0x40,0x01,0x50,0x00,
0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,
0x05,0x05,0x01,0x00,0x24,0x06,0x28,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,
0x00,0x00,0x58,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x05,0x05,
0x01,0x00,0x24,0x06,0x29,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,
0x58,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x05,0x05,0x01,0x00,
0x04,0x04,0x2A,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x78,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x04,0x04,0x01,0x00,0x04,0x04,
0x2B,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,
0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x05,0x05,0x01,0x00,0x04,0x00,0x2C,0x01,
0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x00,0x00,
0x00,0x00,0x58,0x02,0x00,0x00,0x04,0x04,0x01,0x00,0x04,0x00,0x2D,0x01,0x32,0x00,
0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x00,0x00,0x00,0x00,
0x58,0x02,0x00,0x00,0x04,0x04,0x01,0x00,0x24,0x06,0x2E,0x01,0x32,0x00,0xD6,0x00,
0x10,0x00,0x00,0x00,0x00,0x00,0x90,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x90,0x01,
0x00,0x00,0x05,0x05,0x02,0x00,0x00,0x04,0x32,0x01,0x32,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xA0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x00,0x00,0x00,
0x05,0x05,0x02,0x00,0x00,0x04,0x33,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xA0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x00,0x00,0x00,0x05,0x05,
0x02,0x00,0x00,0x00,0x34,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xA0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x00,0x00,0x00,0x05,0x05,0x02,0x00,
0x00,0x04,0x35,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,
0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x04,0x04,0x02,0x00,0x00,0x00,
0x36,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x01,0x00,0x00,
0x00,0x00,0x00,0x00,0x40,0x01,0x00,0x00,0x04,0x04,0x02,0x00,0x00,0x00,0x37,0x01,
0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xA0,0x00,0x00,0x00,0x05,0x05,0x02,0x00,0x00,0x00,0x38,0x01,0x32,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xA0,0x00,0x00,0x00,0x05,0x05,0x02,0x00,0x00,0x00,0x39,0x01,0x32,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x00,
0x00,0x00,0x05,0x05,0x02,0x00,0x00,0x00,0x3A,0x01,0x32,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xA0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x00,0x00,0x00,
0x05,0x05,0x02,0x00,0x00,0x00,0x3B,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x40,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x01,0x00,0x00,0x03,0x03,
0x02,0x00,0x00,0x00,0x3C,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xA0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x00,0x00,0x00,0x05,0x05,0x03,0x00,
0x20,0x02,0x3D,0x01,0x32,0x00,0xD6,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x20,0x03,
0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,0x02,0x02,0x03,0x00,0x20,0x02,
0x3E,0x01,0x32,0x00,0xD6,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,
0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,0x02,0x02,0x03,0x00,0x20,0x02,0x3F,0x01,
0x32,0x00,0x82,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,0x00,0x00,
0x00,0x00,0x20,0x03,0x00,0x00,0x02,0x02,0x03,0x00,0x20,0x02,0x40,0x01,0x32,0x00,
0x40,0x01,0x20,0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,0x00,0x00,0x00,0x00,
0x20,0x03,0x00,0x00,0x02,0x02,0x03,0x00,0x20,0x02,0x41,0x01,0x32,0x00,0x04,0x01,
0x10,0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x03,
0x00,0x00,0x02,0x02,0x03,0x00,0x20,0x02,0x42,0x01,0x32,0x00,0x40,0x01,0x10,0x00,
0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,
0x02,0x02,0x03,0x00,0x20,0x06,0x43,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x20,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,0x02,0x02,
0x04,0x00,0x20,0x02,0x44,0x01,0x32,0x00,0xD6,0x01,0x10,0x00,0x00,0x00,0x00,0x00,
0x20,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,0x02,0x03,0x04,0x00,
0x20,0x02,0x45,0x01,0x32,0x00,0xD6,0x01,0x20,0x00,0x00,0x00,0x00,0x00,0x20,0x03,
0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,0x02,0x03,0x05,0x00,0x20,0x06,
0x46,0x01,0x32,0x00,0x1C,0x02,0x20,0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,
0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,0x02,0x02,0x05,0x00,0x20,0x06,0x47,0x01,
0x32,0x00,0x58,0x02,0x20,0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,0x00,0x00,
0x00,0x00,0x20,0x03,0x00,0x00,0x02,0x02,0x05,0x00,0x20,0x06,0x48,0x01,0x32,0x00,
0x1C,0x02,0x28,0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,0x00,0x00,0x00,0x00,
0x20,0x03,0x00,0x00,0x02,0x02,0x05,0x00,0x20,0x06,0x49,0x01,0x32,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x03,
0x00,0x00,0x02,0x02,0x05,0x00,0x20,0x02,0x4A,0x01,0x32,0x00,0x30,0x02,0x10,0x00,
0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,
0x02,0x02,0x06,0x00,0x00,0x00,0xA0,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,
0x06,0x00,0x00,0x00,0xA1,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,
0x00,0x00,0xA2,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,
0xA3,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xA4,0x00,
0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xA5,0x00,0x32,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xA6,0x00,0x32,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,
0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xA7,0x00,0x32,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,
0x00,0x00,0x06,0x00,0x00,0x00,0xA8,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,
0x06,0x00,0x00,0x00,0xA9,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,
0x00,0x00,0xAA,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,
0xAB,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xAC,0x00,
0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xAD,0x00,0x32,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xAE,0x00,0x32,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,
0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xAF,0x00,0x32,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,
0x00,0x00,0x06,0x00,0x00,0x00,0xB0,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,
0x06,0x00,0x00,0x00,0xB1,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,
0x00,0x00,0xB2,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,
0xB3,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xB4,0x00,
0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xB5,0x00,0x32,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xB6,0x00,0x32,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,
0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xB7,0x00,0x32,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,
0x00,0x00,0x06,0x00,0x00,0x00,0xB8,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,
0x06,0x00,0x00,0x00,0xB9,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,
0x00,0x00,0x4B,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,
0x4C,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x4D,0x01,
0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x07,0x00,0x04,0x00,0x4E,0x01,0x32,0x00,
0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x00,0x00,0x00,0x00,
0x58,0x02,0x00,0x00,0x03,0x06,0x07,0x00,0x04,0x00,0x4F,0x01,0x32,0x00,0x40,0x01,
0x50,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,
0x00,0x00,0x03,0x06,0x07,0x00,0x04,0x00,0x50,0x01,0x32,0x00,0x40,0x01,0x50,0x00,
0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,
0x03,0x06,0x07,0x00,0x04,0x00,0x51,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,
0x00,0x00,0x58,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x03,0x06,
0x07,0x00,0x04,0x00,0x52,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,
0x58,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x03,0x06,0x07,0x00,
0x04,0x00,0x53,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x58,0x02,
0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x03,0x06,0x07,0x00,0x04,0x00,
0x54,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,
0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x03,0x06,0x07,0x00,0x04,0x00,0x55,0x01,
0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x00,0x00,
0x00,0x00,0x58,0x02,0x00,0x00,0x03,0x06,0x07,0x00,0x04,0x00,0x56,0x01,0x32,0x00,
0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x8C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x8C,0x00,0x00,0x00,0x04,0x06,0x08,0x00,0x80,0x02,0x57,0x01,0x32,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x00,
0x00,0x00,0x05,0x05,0x08,0x00,0x00,0x04,0x58,0x01,0x32,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xA0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x00,0x00,0x00,
0x05,0x05,0x08,0x00,0x80,0x02,0x59,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x64,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x05,0x05,
0x09,0x00,0x04,0x00,0x1E,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0A,0x00,
0x00,0x00,0xBA,0x00,0x46,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0B,0x00,0x00,0x00,
0xA8,0x01,0x00,0x00,0x68,0x01,0x72,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0B,0x00,0x00,0x00,0xA7,0x01,
0x00,0x00,0x68,0x01,0x92,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0B,0x00,0x00,0x00,0xAB,0x01,0x00,0x00,
0x36,0x01,0xB0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x0B,0x00,0x00,0x00,0xAA,0x01,0x00,0x00,0x68,0x01,
0xB0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x0B,0x00,0x00,0x00,0xAC,0x01,0x00,0x00,0x68,0x01,0xD2,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x01,0x00,0x04,0x00,0x7C,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,
0x00,0x00,0x64,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x04,0x04,
0x01,0x00,0x04,0x01,0x00,0x00,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,
0x90,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x90,0x01,0x00,0x00,0x03,0x03,0x01,0x00,
0x04,0x00,0x2F,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x04,0x00,
0x30,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x0C,0x00,0x00,0x00,0x60,0x01,
0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x0C,0x00,0x00,0x01,0x61,0x01,0x32,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x01,0x01,0x0D,0x00,0x00,0x00,0x5A,0x01,0x32,0x00,0x3C,0x00



}; // weak
//__int16 x_WORD_E25DE[] = { 2 }; // weak
Bit8u x_BYTE_E25ED[0x1000] = {
0x06,0xA0, 0x01,0x13, 0x00,0x74, 0x00,0xAC, 0x00,0x7C, 0x00,0x01, 0x00,0x19, 0x01,0x7C, 0x00,0x02,
0x0A,0x96, 0x01,0x11, 0x00,0xF6, 0x00,0x5F, 0x00,0xF6, 0x00,0x3E, 0x00,0xC0, 0x00,0xAA, 0x00,0x00,
0x09,0x9B, 0x01,0x11, 0x00,0x68, 0x01,0x5F, 0x00,0x68, 0x01,0x3E, 0x00,0xC1, 0x00,0x1C, 0x01,0x00,
0x0D,0xA3, 0x01,0xDC, 0x00,0x55, 0x01,0x3E, 0x01,0x55, 0x01,0x41, 0x00,0x3C, 0x01,0xD0, 0x00,0x00,
0x0C,0xCF, 0x01,0x9A, 0x01,0x48,0x01,0x03,
0x02,0x61,0x01,0x3F,0x00,0xB5,0x01,0x22,0x01,0x08,0x0F,0xA2,0x01,0x84,0x01,0xED,
0x00,0xE5,0x01,0xEC,0x00,0x3F,0x00,0xB0,0x01,0xC4,0x00,0x08,0x08,0xA1,0x01,0x96,
0x01,0x9D,0x00,0xFC,0x01,0xA6,0x00,0x3D,0x00,0xA8,0x01,0x62,0x00,0x08,0x07,0x97,
0x01,0x9B,0x01,0x1F,0x00,0xE8,0x01,0x29,0x00,0x40,0x00,0x5A,0x01,0x28,0x00,0x08,
0x0B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xB5,
0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0xB6,0x01,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x68,0x01,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xBF,0x01,0x74,0x02,0x73,0x00,0x8A,0x00,0x73,0x00,0x04,0x00,0x00,
0x01,0x07,0x00,0x26,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x6C,0x03,0x16,0x02,0x73,0x00,0x8A,0x00,0x75,0x00,0x08,0x00,0x00,0x01,0x08,
0x00,0x26,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x21,
0x02,0x36,0x00,0x55,0x00,0x55,0x00,0x55,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x8F,0x02,0x3A,
0x00,0x55,0x00,0x55,0x00,0x57,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x34,0x02,0x58,0x00,0x55,
0x00,0x55,0x00,0x58,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x66,0x02,0x7B,0x00,0x55,0x00,0x55,
0x00,0x59,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x21,0x02,0x36,0x00,0x56,0x00,0x5C,0x00,0x56,
0x00,0x08,0x00,0x00,0x01,0x09,0x00,0x17,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x8F,0x02,0x3A,0x00,0x56,0x00,0x5C,0x00,0x58,0x00,0x04,
0x00,0x00,0x01,0xFF,0xFF,0x17,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x34,0x02,0x58,0x00,0x56,0x00,0x5C,0x00,0x59,0x00,0x16,0x00,0x00,
0x01,0xFF,0xFF,0x17,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x66,0x02,0x7B,0x00,0x56,0x00,0x5C,0x00,0x5A,0x00,0x15,0x00,0x00,0x01,0xFF,
0xFF,0x17,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,
0x03,0xF5,0x00,0x2E,0x00,0x3A,0x00,0x31,0x00,0x00,0x00,0x01,0x00,0x0A,0x00,0x05,
0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0x03,0xF5,
0x00,0x2E,0x00,0x3A,0x00,0x31,0x00,0x00,0x00,0x01,0x01,0x0A,0x00,0x05,0x00,0x02,
0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5F,0x03,0x49,0x01,0x2E,
0x00,0x3A,0x00,0x2E,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,0x05,0x00,0x02,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x76,0x02,0x5F,0x02,0x2E,0x00,0x3A,
0x00,0x34,0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,0x05,0x00,0x02,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF4,0x00,0x78,0x02,0x2E,0x00,0x3A,0x00,0x38,
0x00,0x00,0x00,0x01,0x00,0xFF,0xFF,0x05,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//unk_E28A8
0xD4,0x00, 0x32,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0xBC,0x01, 0x01,0x00, 0x00,0x00,
0xD4,0x00, 0x53,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0xBD,0x01, 0x00,0x00, 0x00,0x00,
0xD4,0x00, 0x74,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0xBE,0x01, 0x00,0x00, 0x00,0x00,
0xD4,0x00, 0x95,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0xBF,0x01, 0x00,0x00, 0x00,0x00,
0xD4,0x00, 0xB6,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0xC0,0x01, 0x00,0x00, 0x00,0x00,
0xD4,0x00, 0xD7,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0xC1,0x01, 0x00,0x00, 0x00,0x00,
0xD4,0x00, 0xF8,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0xC2,0x01, 0x00,0x00, 0x00,0x00,
0xD4,0x00, 0x19,0x01, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0xC3,0x01, 0x00,0x00, 0x00,0x00,
0xD4,0x00, 0x3A,0x01, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0xC4,0x01, 0x00,0x00, 0x00,0x00,
0xD4,0x00, 0x5B,0x01, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0xC5,0x01, 0x00,0x00, 0x00,0x00,

0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x1E,0x00,0x1F,0x01,0x90,0x02,0x03,
0x00,0x0E,0x01,0x00,0x00,0x00,0x00,0x00,0x07,0x00,0x1F,0x00,0x6F,0x03,0x66,0x02,
0x03,0x00,0x0E,0x01,0x00,0x00,0x00,0x00,0x00,0x0B,0x00,0x20,0x00,0x56,0x03,0x90,
0x01,0x03,0x00,0x0E,0x01,0x00,0x00,0x00,0x00,0x00,0x11,0x00,0x21,0x00,0x8B,0x01,
0x72,0x00,0x03,0x00,0x0E,0x01,0x00,0x00,0x00,0x00,0x00,0x13,0x00,0x22,0x00,0x6D,
0x01,0xF8,0x01,0x03,0x00,0x0E,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x47,0x65,0x6E,0x75,0x69,
0x6E,0x65,0x49,0x6E,0x74,0x65,0x6C,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x01,0x00,0x64,
0x2C,0x2A,0x00,0x7C,0x2C,0x2A,0x00,0x8C,0x2C,0x2A,0x00,0x9C,0x2C,0x2A,0x00,0xAC,
0x2C,0x2A,0x00,0xB8,0x2C,0x2A,0x00,0xDC,0x2C,0x2A,0x00,0xE8,0x2C,0x2A,0x00,0xF8,
0x2C,0x2A,0x00,0x0C,0x2D,0x2A,0x00,0x24,0x2D,0x2A,0x00,0x30,0x2D,0x2A,0x00,0x3C,
0x2D,0x2A,0x00,0x4C,0x2D,0x2A,0x00,0x4C,0x2D,0x2A,0x00,0x58,0x2D,0x2A,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x04,0x00,0x1E,0x01,0x32,0x00,0x40,0x01,0x50,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,
0x00,0x02,0x00,0x01,0x00,0x00,0x02,0x1F,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x02,
0x00,0x01,0x00,0x04,0x00,0x20,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x06,0x00,0x01,
0x00,0x24,0x00,0x21,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2C,0x01,0x00,0x00,0x04,0x00,0x01,0x00,0x20,
0x02,0x22,0x01,0x32,0x00,0xD6,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x02,0x00,0x01,0x00,0x04,0x04,0x23,
0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x02,0x00,0x01,0x00,0x04,0x00,0x24,0x01,0x32,
0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x58,0x02,0x00,0x00,0x02,0x00,0x01,0x00,0x04,0x00,0x25,0x01,0x32,0x00,0x40,
0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,
0x02,0x00,0x00,0x02,0x00,0x01,0x00,0x04,0x00,0x26,0x01,0x32,0x00,0x40,0x01,0x50,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,
0x00,0x02,0x00,0x01,0x00,0x24,0x06,0x27,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x05,
0x00,0x01,0x00,0x24,0x06,0x28,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x05,0x00,0x01,
0x00,0x24,0x06,0x29,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x05,0x00,0x01,0x00,0x04,
0x04,0x2A,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x04,0x00,0x01,0x00,0x04,0x04,0x2B,
0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x05,0x00,0x01,0x00,0x04,0x00,0x2C,0x01,0x32,
0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x58,0x02,0x00,0x00,0x04,0x00,0x01,0x00,0x04,0x00,0x2D,0x01,0x32,0x00,0x40,
0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,
0x02,0x00,0x00,0x04,0x00,0x01,0x00,0x24,0x06,0x2E,0x01,0x32,0x00,0xD6,0x00,0x10,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x90,0x01,0x00,
0x00,0x05,0x00,0x02,0x00,0x00,0x04,0x32,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x00,0x00,0x00,0x05,
0x00,0x02,0x00,0x00,0x04,0x33,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x00,0x00,0x00,0x05,0x00,0x02,
0x00,0x00,0x00,0x34,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x00,0x00,0x00,0x05,0x00,0x02,0x00,0x00,
0x04,0x35,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x04,0x00,0x02,0x00,0x00,0x00,0x36,
0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x40,0x01,0x00,0x00,0x04,0x00,0x02,0x00,0x00,0x00,0x37,0x01,0x32,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0xA0,0x00,0x00,0x00,0x05,0x00,0x02,0x00,0x00,0x00,0x38,0x01,0x32,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,
0x00,0x00,0x00,0x05,0x00,0x02,0x00,0x00,0x00,0x39,0x01,0x32,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x00,0x00,
0x00,0x05,0x00,0x02,0x00,0x00,0x00,0x3A,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x00,0x00,0x00,0x05,
0x00,0x02,0x00,0x00,0x00,0x3B,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x01,0x00,0x00,0x03,0x00,0x02,
0x00,0x00,0x00,0x3C,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x00,0x00,0x00,0x05,0x00,0x03,0x00,0x20,
0x02,0x3D,0x01,0x32,0x00,0xD6,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,0x02,0x00,0x03,0x00,0x20,0x02,0x3E,
0x01,0x32,0x00,0xD6,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x20,0x03,0x00,0x00,0x02,0x00,0x03,0x00,0x20,0x02,0x3F,0x01,0x32,
0x00,0x82,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x20,0x03,0x00,0x00,0x02,0x00,0x03,0x00,0x20,0x02,0x40,0x01,0x32,0x00,0x40,
0x01,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,
0x03,0x00,0x00,0x02,0x00,0x03,0x00,0x20,0x02,0x41,0x01,0x32,0x00,0x04,0x01,0x10,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,
0x00,0x02,0x00,0x03,0x00,0x20,0x02,0x42,0x01,0x32,0x00,0x40,0x01,0x10,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,0x02,
0x00,0x03,0x00,0x20,0x06,0x43,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,0x02,0x00,0x04,
0x00,0x20,0x02,0x44,0x01,0x32,0x00,0xD6,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,0x02,0x03,0x04,0x00,0x20,
0x02,0x45,0x01,0x32,0x00,0xD6,0x01,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,0x02,0x03,0x05,0x00,0x20,0x06,0x46,
0x01,0x32,0x00,0x1C,0x02,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x20,0x03,0x00,0x00,0x02,0x00,0x05,0x00,0x20,0x06,0x47,0x01,0x32,
0x00,0x58,0x02,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x20,0x03,0x00,0x00,0x02,0x00,0x05,0x00,0x20,0x06,0x48,0x01,0x32,0x00,0x1C,
0x02,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,
0x03,0x00,0x00,0x02,0x00,0x05,0x00,0x20,0x06,0x49,0x01,0x32,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,
0x00,0x02,0x00,0x05,0x00,0x20,0x02,0x4A,0x01,0x32,0x00,0x30,0x02,0x10,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,0x02,
0x00,0x06,0x00,0x00,0x00,0xA0,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,
0x00,0x00,0x00,0xA1,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,
0x00,0xA2,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xA3,
0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xA4,0x00,0x32,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xA5,0x00,0x32,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,
0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xA6,0x00,0x32,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,
0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xA7,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,
0x00,0x06,0x00,0x00,0x00,0xA8,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,
0x00,0x00,0x00,0xA9,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,
0x00,0xAA,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xAB,
0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xAC,0x00,0x32,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xAD,0x00,0x32,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,
0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xAE,0x00,0x32,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,
0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xAF,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,
0x00,0x06,0x00,0x00,0x00,0xB0,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,
0x00,0x00,0x00,0xB1,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,
0x00,0xB2,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xB3,
0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xB4,0x00,0x32,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xB5,0x00,0x32,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,
0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xB6,0x00,0x32,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,
0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xB7,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,
0x00,0x06,0x00,0x00,0x00,0xB8,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,
0x00,0x00,0x00,0xB9,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,
0x00,0x4B,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x4C,
0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x4D,0x01,0x32,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x07,0x00,0x04,0x00,0x4E,0x01,0x32,0x00,0x40,
0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,
0x02,0x00,0x00,0x03,0x00,0x07,0x00,0x04,0x00,0x4F,0x01,0x32,0x00,0x40,0x01,0x50,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,
0x00,0x03,0x00,0x07,0x00,0x04,0x00,0x50,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x03,
0x00,0x07,0x00,0x04,0x00,0x51,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x03,0x00,0x07,
0x00,0x04,0x00,0x52,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x03,0x00,0x07,0x00,0x04,
0x00,0x53,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x03,0x00,0x07,0x00,0x04,0x00,0x54,
0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x03,0x00,0x07,0x00,0x04,0x00,0x55,0x01,0x32,
0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x58,0x02,0x00,0x00,0x03,0x00,0x07,0x00,0x04,0x00,0x56,0x01,0x32,0x00,0x40,
0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x8C,
0x00,0x00,0x00,0x04,0x00,0x08,0x00,0x80,0x02,0x57,0x01,0x32,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x00,0x00,
0x00,0x05,0x00,0x08,0x00,0x00,0x04,0x58,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x00,0x00,0x00,0x05,
0x00,0x08,0x00,0x80,0x02,0x59,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x05,0x00,0x09,
0x00,0x04,0x00,0x1E,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0A,0x00,0x00,
0x00,0xBA,0x00,0x46,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0B,0x00,0x00,0x00,0xA8,
0x01,0x00,0x00,0x68,0x01,0x72,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0B,0x00,0x00,0x00,0xA7,0x01,0x00,
0x00,0x68,0x01,0x92,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0B,0x00,0x00,0x00,0xAB,0x01,0x00,0x00,0x36,
0x01,0xB0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x0B,0x00,0x00,0x00,0xAA,0x01,0x00,0x00,0x68,0x01,0xB0,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0B,0x00,0x00,0x00,0xAC,0x01,0x00,0x00,0x68,0x01,0xD2,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x01,0x00,0x04,0x00,0x7C,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x04,0x00,0x01,
0x00,0x04,0x01,0x00,0x00,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x90,0x01,0x00,0x00,0x03,0x00,0x01,0x00,0x04,
0x00,0x2F,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x04,0x00,0x30,
0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x0C,0x00,0x00,0x00,0x60,0x01,0x32,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x0C,0x00,0x00,0x01,0x61,0x01,0x32,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x01,0x00,0x0D,0x00,0x00,0x00,0x5A,0x01,0x32,0x00,0x3C,0x00,0x68,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
//_UNKNOWN unk_E2690; // weak //x_BYTE_E25ED[0xa3]
//_UNKNOWN unk_E26C8; // weak //x_BYTE_E25ED[0xdb]
//_UNKNOWN unk_E28A8; // weak x_BYTE_E25ED[0x2BB]
//__int16 x_WORD_E28B6 = 1; // weak
x_WORD x_WORD_E2970[51] =
{
0x0000,0x0000,0x0004,0x001E,0x011F,0x0290,0x0003,0x010E,0x0000,0x0000,0x0700,0x1F00,0x6F00,0x6603,0x0302,0x0E00,0x0001,//e2970
0x0000,0x0000,0x000B,0x0020,0x0356,0x0190,0x0003,0x010E,0x0000,0x0000,0x1100,0x2100,0x8B00,0x7201,0x0300,0x0E00,0x0001,//e2992
0x0000,0x0000,0x0013,0x0022,0x016D,0x01F8,0x0003,0x010E,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000//e29b4
};
//end adress &x_WORD_E2970[52]

__int16 x_WORD_E29D6_not_movex = 0; // weak
__int16 x_WORD_E29D8 = 0; // weak
__int16 x_WORD_E29DA_type_resolution = 0; // weak
__int16 x_WORD_E29DC = 0; // weak
//char x_BYTE_E29DE = '\x01'; // weak
char x_BYTE_E29DF_skip_screen = '\0'; // weak
char x_BYTE_E29E0 = '\0'; // weak
char x_BYTE_E29E1 = '\x01'; // weak
char x_BYTE_E29E8 = '\x01'; // weak
char x_BYTE_E29EC = '\0'; // weak
char x_BYTE_E29ED = '\0'; // weak
char x_BYTE_E29EE = '\0'; // weak
char x_BYTE_E29EF = '\0'; // weak
char x_BYTE_E29F0 = '\0'; // weak
char x_BYTE_E29F1 = '\0'; // weak
__int16 x_WORD_E29F4 = 0; // weak
int x_DWORD_E29F6 = 0; // weak
int x_DWORD_E29FA = 0; // weak
int x_DWORD_E29FE = 0; // weak
int x_DWORD_E2A02 = 0; // weak
char x_BYTE_E2A06 = '\0'; // weak
_UNKNOWN unk_E2A08; // weak
Bit8s x_WORD_E2A14_sound_activel = 1; // weak
Bit8s x_WORD_E2A14_sound_activeh = 0; // weak
int x_DWORD_E2A18 = 0; // weak
int x_DWORD_E2A1C = 0; // weak
char x_BYTE_E2A20 = '\0'; // weak
Bit8u* x_WORD_E2A24 = 0; // weak
char x_BYTE_E2A28 = '\0'; // weak
int x_DWORD_E2A6C = 0; // weak
int x_DWORD_E2A70 = 0; // weak
__int16 x_WORD_E2A74[] = { 0 }; // weak
char x_BYTE_E2A76[] = { '\0' }; // weak
__int16 x_WORD_E2A78[] = { 0 }; // weak
__int16 x_WORD_E2A7A[] = { 0 }; // weak
__int16 x_WORD_E2A7C[] = { 0 }; // weak
__int16 x_WORD_E2A7E[] = { 0 }; // weak
int x_DWORD_E2A80 = 0; // weak
int x_DWORD_E2A84 = 0; // weak
int x_DWORD_E2A88 = 0; // weak
char x_BYTE_E2A90[] = { '\0' }; // weak
char x_BYTE_E2A91[] = { '\0' }; // weak
Bit8u off_E2A92[0x1000] = {//2b3a92
	0x01,0x00,0x04,0x00,0x1E,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x02,0x00,0x01,0x00,
0x00,0x02,0x1F,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x02,0x00,0x01,0x00,0x04,0x00,
0x20,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x06,0x00,0x01,0x00,0x24,0x00,0x21,0x01,
0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x2C,0x01,0x00,0x00,0x04,0x00,0x01,0x00,0x20,0x02,0x22,0x01,0x32,0x00,
0xD6,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x58,0x02,0x00,0x00,0x02,0x00,0x01,0x00,0x04,0x04,0x23,0x01,0x32,0x00,0x40,0x01,
0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,
0x00,0x00,0x02,0x00,0x01,0x00,0x04,0x00,0x24,0x01,0x32,0x00,0x40,0x01,0x50,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,
0x02,0x00,0x01,0x00,0x04,0x00,0x25,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x02,0x00,
0x01,0x00,0x04,0x00,0x26,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x02,0x00,0x01,0x00,
0x24,0x06,0x27,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x05,0x00,0x01,0x00,0x24,0x06,
0x28,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x05,0x00,0x01,0x00,0x24,0x06,0x29,0x01,
0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x58,0x02,0x00,0x00,0x05,0x00,0x01,0x00,0x04,0x04,0x2A,0x01,0x32,0x00,
0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x78,0x00,0x00,0x00,0x04,0x00,0x01,0x00,0x04,0x04,0x2B,0x01,0x32,0x00,0x40,0x01,
0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,
0x00,0x00,0x05,0x00,0x01,0x00,0x04,0x00,0x2C,0x01,0x32,0x00,0x40,0x01,0x50,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,
0x04,0x00,0x01,0x00,0x04,0x00,0x2D,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x04,0x00,
0x01,0x00,0x24,0x06,0x2E,0x01,0x32,0x00,0xD6,0x00,0x10,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x90,0x01,0x00,0x00,0x05,0x00,0x02,0x00,
0x00,0x04,0x32,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x00,0x00,0x00,0x05,0x00,0x02,0x00,0x00,0x04,
0x33,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xA0,0x00,0x00,0x00,0x05,0x00,0x02,0x00,0x00,0x00,0x34,0x01,
0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xA0,0x00,0x00,0x00,0x05,0x00,0x02,0x00,0x00,0x04,0x35,0x01,0x32,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x58,0x02,0x00,0x00,0x04,0x00,0x02,0x00,0x00,0x00,0x36,0x01,0x32,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x01,
0x00,0x00,0x04,0x00,0x02,0x00,0x00,0x00,0x37,0x01,0x32,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x00,0x00,0x00,
0x05,0x00,0x02,0x00,0x00,0x00,0x38,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x00,0x00,0x00,0x05,0x00,
0x02,0x00,0x00,0x00,0x39,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x00,0x00,0x00,0x05,0x00,0x02,0x00,
0x00,0x00,0x3A,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x00,0x00,0x00,0x05,0x00,0x02,0x00,0x00,0x00,
0x3B,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x40,0x01,0x00,0x00,0x03,0x00,0x02,0x00,0x00,0x00,0x3C,0x01,
0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xA0,0x00,0x00,0x00,0x05,0x00,0x03,0x00,0x20,0x02,0x3D,0x01,0x32,0x00,
0xD6,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x20,0x03,0x00,0x00,0x02,0x00,0x03,0x00,0x20,0x02,0x3E,0x01,0x32,0x00,0xD6,0x00,
0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x03,
0x00,0x00,0x02,0x00,0x03,0x00,0x20,0x02,0x3F,0x01,0x32,0x00,0x82,0x00,0x10,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,
0x02,0x00,0x03,0x00,0x20,0x02,0x40,0x01,0x32,0x00,0x40,0x01,0x20,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,0x02,0x00,
0x03,0x00,0x20,0x02,0x41,0x01,0x32,0x00,0x04,0x01,0x10,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,0x02,0x00,0x03,0x00,
0x20,0x02,0x42,0x01,0x32,0x00,0x40,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,0x02,0x00,0x03,0x00,0x20,0x06,
0x43,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,0x02,0x00,0x04,0x00,0x20,0x02,0x44,0x01,
0x32,0x00,0xD6,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x20,0x03,0x00,0x00,0x02,0x03,0x04,0x00,0x20,0x02,0x45,0x01,0x32,0x00,
0xD6,0x01,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x20,0x03,0x00,0x00,0x02,0x03,0x05,0x00,0x20,0x06,0x46,0x01,0x32,0x00,0x1C,0x02,
0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x03,
0x00,0x00,0x02,0x00,0x05,0x00,0x20,0x06,0x47,0x01,0x32,0x00,0x58,0x02,0x20,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,
0x02,0x00,0x05,0x00,0x20,0x06,0x48,0x01,0x32,0x00,0x1C,0x02,0x28,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,0x02,0x00,
0x05,0x00,0x20,0x06,0x49,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,0x02,0x00,0x05,0x00,
0x20,0x02,0x4A,0x01,0x32,0x00,0x30,0x02,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x00,0x00,0x02,0x00,0x06,0x00,0x00,0x00,
0xA0,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xA1,0x00,
0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xA2,0x00,0x32,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xA3,0x00,0x32,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,
0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xA4,0x00,0x32,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,
0x00,0x00,0x06,0x00,0x00,0x00,0xA5,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,
0x06,0x00,0x00,0x00,0xA6,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,
0x00,0x00,0xA7,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,
0xA8,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xA9,0x00,
0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xAA,0x00,0x32,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xAB,0x00,0x32,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,
0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xAC,0x00,0x32,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,
0x00,0x00,0x06,0x00,0x00,0x00,0xAD,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,
0x06,0x00,0x00,0x00,0xAE,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,
0x00,0x00,0xAF,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,
0xB0,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xB1,0x00,
0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xB2,0x00,0x32,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xB3,0x00,0x32,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,
0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xB4,0x00,0x32,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,
0x00,0x00,0x06,0x00,0x00,0x00,0xB5,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,
0x06,0x00,0x00,0x00,0xB6,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,
0x00,0x00,0xB7,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,
0xB8,0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0xB9,0x00,
0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x4B,0x01,0x32,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x50,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x4C,0x01,0x32,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,
0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x4D,0x01,0x32,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,
0x00,0x00,0x07,0x00,0x04,0x00,0x4E,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x03,0x00,
0x07,0x00,0x04,0x00,0x4F,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x03,0x00,0x07,0x00,
0x04,0x00,0x50,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x03,0x00,0x07,0x00,0x04,0x00,
0x51,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,0x03,0x00,0x07,0x00,0x04,0x00,0x52,0x01,
0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x58,0x02,0x00,0x00,0x03,0x00,0x07,0x00,0x04,0x00,0x53,0x01,0x32,0x00,
0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x58,0x02,0x00,0x00,0x03,0x00,0x07,0x00,0x04,0x00,0x54,0x01,0x32,0x00,0x40,0x01,
0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,
0x00,0x00,0x03,0x00,0x07,0x00,0x04,0x00,0x55,0x01,0x32,0x00,0x40,0x01,0x50,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x00,
0x03,0x00,0x07,0x00,0x04,0x00,0x56,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x8C,0x00,0x00,0x00,0x04,0x00,
0x08,0x00,0x80,0x02,0x57,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x00,0x00,0x00,0x05,0x00,0x08,0x00,
0x00,0x04,0x58,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x00,0x00,0x00,0x05,0x00,0x08,0x00,0x80,0x02,
0x59,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x05,0x00,0x09,0x00,0x04,0x00,0x1E,0x01,
0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0A,0x00,0x00,0x00,0xBA,0x00,0x46,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x0B,0x00,0x00,0x00,0xA8,0x01,0x00,0x00,0x68,0x01,
0x72,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x0B,0x00,0x00,0x00,0xA7,0x01,0x00,0x00,0x68,0x01,0x92,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x0B,0x00,0x00,0x00,0xAB,0x01,0x00,0x00,0x36,0x01,0xB0,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x0B,0x00,0x00,0x00,0xAA,0x01,0x00,0x00,0x68,0x01,0xB0,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0B,0x00,
0x00,0x00,0xAC,0x01,0x00,0x00,0x68,0x01,0xD2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x04,0x00,
0x7C,0x01,0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x04,0x00,0x01,0x00,0x04,0x01,0x00,0x00,
0x32,0x00,0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x90,0x01,0x00,0x00,0x03,0x00,0x01,0x00,0x04,0x00,0x2F,0x01,0x32,0x00,
0x40,0x01,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x04,0x00,0x30,0x01,0x32,0x00,0x40,0x01,
0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x01,0x00,0x0C,0x00,0x00,0x00,0x60,0x01,0x32,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x01,0x00,0x0C,0x00,0x00,0x01,0x61,0x01,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
0x0D,0x00,0x00,0x00,0x5A,0x01,0x32,0x00,0x3C,0x00,0x68,0x01,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x0D,0x00,
0x00,0x00,0x5B,0x01,0x32,0x00,0x8C,0x00,0x70,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x0D,0x00,0x00,0x00,
0x5C,0x01,0x32,0x00,0xD4,0x00,0x70,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x0D,0x00,0x00,0x00,0x5D,0x01,
0x32,0x00,0x16,0x01,0x70,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x0D,0x00,0x00,0x00,0x5E,0x01,0x32,0x00,
0x74,0x01,0x70,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x01,0x00,0x0D,0x00,0x00,0x00,0x5F,0x01,0x32,0x00,0x98,0x01,
0x68,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,
0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x27,0x31,0x32,0x33,0x34,
0x35,0x36,0x37,0x38,0x39,0x30,0x2D,0x3D,0x08,0x09,0x51,0x57,0x45,0x52,0x54,0x59,
0x55,0x49,0x4F,0x50,0x5B,0x5D,0x0D,0x00,0x41,0x53,0x44,0x46,0x47,0x48,0x4A,0x4B,
0x4C,0x3B,0x27,0x23,0x00,0x5C,0x5A,0x58,0x43,0x56,0x42,0x4E,0x4D,0x2C,0x2E,0x2F,
0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x2D,0x00,0x00,0x00,0x2B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2F,0x00,0x00,0x28,0x29,0x2F,
0x2A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2E,0x0D,0x00,0x40,0x01,
0xC8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x01,0xC8,0x00,0x40,0x01,
0xC8,0x00,0x19,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x84,0x2F,0x2A,0x00,0x90,0x2F,
0x2A,0x00,0x9C,0x2F,0x2A,0x00,0xA8,0x2F,0x2A,0x00,0xB8,0x2F,0x2A,0x00,0xC8,0x2F,
0x2A,0x00,0xD4,0x2F,0x2A,0x00,0xE0,0x2F,0x2A,0x00,0xEC,0x2F,0x2A,0x00,0x00,0x00,
0x00,0x00,0x0A,0x00,0x00,0x00,0x01,0x01,0x00,0x01,0x01,0x09,0x00,0xFC,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x7F,0x00,
0x00,0x00,0x36,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x30,
0x2A,0x00,0xAC,0x30,0x2A,0x00,0xB8,0x30,0x2A,0x00,0xC4,0x30,0x2A,0x00,0xD0,0x30,
0x2A,0x00,0xDC,0x30,0x2A,0x00,0xE8,0x30,0x2A,0x00,0xF8,0x30,0x2A,0x00,0x04,0x31,
0x2A,0x00,0x0C,0x31,0x2A,0x00,0x18,0x31,0x2A,0x00,0x28,0x31,0x2A,0x00,0x34,0x31,
0x2A,0x00,0x00,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xC2,0x03,0x00,0x63,0xD4,0x03,0x00,0x5F,0xD4,0x03,0x01,0x4F,0xD4,0x03,
0x02,0x50,0xD4,0x03,0x03,0x82,0xD4,0x03,0x04,0x54,0xD4,0x03,0x05,0x80,0xD4,0x03,
0x06,0xBF,0xD4,0x03,0x07,0x1F,0xD4,0x03,0x08,0x00,0xD4,0x03,0x09,0x40,0xD4,0x03,
0x10,0x9C,0xD4,0x03,0x11,0x8E,0xD4,0x03,0x12,0x8F,0xD4,0x03,0x13,0x28,0xD4,0x03,
0x14,0x00,0xD4,0x03,0x15,0x96,0xD4,0x03,0x16,0xB9,0xD4,0x03,0x17,0xE3,0xC4,0x03,
0x01,0x01,0xC4,0x03,0x04,0x06,0xCE,0x03,0x05,0x40,0xCE,0x03,0x06,0x05,0xC0,0x03,
0x10,0x41,0xC0,0x03,0x13,0x00,0x00,0x00,0x0A,0x00,0x50,0x00,0x0A,0x00,0x00,0x80,
0x0A,0x00,0x50,0x80,0x0A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x53,0x4F,
0x55,0x4E,0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
0x00,0x00,0x03,0x00,0x01,0x00,0x07,0x00,0x03,0x00,0x07,0x00,0x07,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,
0x00,0x00,0x02,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x03,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
0x00,0x00,0x07,0x00,0x01,0x00,0x07,0x00,0x05,0x00,0x0F,0x00,0x03,0x00,0x0F,0x00,
0x0B,0x00,0x0F,0x00,0x07,0x00,0x1F,0x00,0x0F,0x00,0x3F,0x00,0x1F,0x00,0x7F,0x00,
0x3F,0x00,0x7F,0x00,0x7F,0x00,0x1F,0x00,0x0F,0x00,0x3F,0x00,0x1F,0x00,0x3F,0x00,
0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x01,
0x00,0x00,0x04,0x03,0x00,0x00,0x05,0x03,0x00,0x00,0x06,0x04,0x00,0x00,0x07,0x04
}; // weak
__int16 x_WORD_E2AB8 = 0; // weak
__int16 x_WORD_E2ABA = 0; // weak
char x_BYTE_E2ACD = '\0'; // weak
char x_BYTE_E2AD0 = '\x04'; // weak
char x_BYTE_E2AEE = '$'; // weak
char x_BYTE_E2B0C = ' '; // weak
char x_BYTE_E2B2A = '\x04'; // weak
char x_BYTE_E2B48 = '\x04'; // weak
char x_BYTE_E2B66 = '\x04'; // weak
char x_BYTE_E2B84 = '\x04'; // weak
char x_BYTE_E2BA2 = '$'; // weak
__int16 x_WORD_E2BA8 = 320; // weak
__int16 x_WORD_E2BAA = 80; // weak
char x_BYTE_E2BC0 = '$'; // weak
__int16 x_WORD_E2BC6 = 320; // weak
__int16 x_WORD_E2BC8 = 80; // weak
char x_BYTE_E2BDE = '$'; // weak
__int16 x_WORD_E2BE4 = 320; // weak
__int16 x_WORD_E2BE6 = 80; // weak
char x_BYTE_E2BFC = '\x04'; // weak
char x_BYTE_E2C1A = '\x04'; // weak
char x_BYTE_E2C38 = '\x04'; // weak
char x_BYTE_E2C56 = '\x04'; // weak
char x_BYTE_E2C71 = '\0'; // weak
char x_BYTE_E2C74 = '$'; // weak
int x_DWORD_E2C86 = 0; // weak
__int16 x_WORD_E2E96 = 0; // weak
__int16 x_WORD_E2E98 = 0; // weak
char x_BYTE_E2EEA = ' '; // weak
char x_BYTE_E2F08 = ' '; // weak
char x_BYTE_E2F26 = ' '; // weak
__int16 x_WORD_E2F2C = 540; // weak
__int16 x_WORD_E2F2E = 40; // weak
char x_BYTE_E2F44 = ' '; // weak
__int16 x_WORD_E2F4A = 0; // weak
__int16 x_WORD_E2F4C = 0; // weak
char x_BYTE_E2F5F = '\0'; // weak
char x_BYTE_E2F62 = ' '; // weak
__int16 x_WORD_E2F68 = 560; // weak
__int16 x_WORD_E2F6A = 16; // weak
char x_BYTE_E32E6 = '\x04'; // weak
char x_BYTE_E3304 = '\x04'; // weak
char x_BYTE_E3322 = '\x04'; // weak
char x_BYTE_E3340 = '\x04'; // weak
char x_BYTE_E335E = '\x04'; // weak
char x_BYTE_E337C = '\x04'; // weak
char x_BYTE_E339A = '\x04'; // weak
char x_BYTE_E33B8 = '\x04'; // weak
char x_BYTE_E33D6 = '\x04'; // weak
char x_BYTE_E340F = '\0'; // weak
char x_BYTE_E3430 = '\x80'; // weak
__int16 x_WORD_E3490 = 360; // weak
__int16 x_WORD_E3492 = 114; // weak
__int16 x_WORD_E34AE = 360; // weak
__int16 x_WORD_E34B0 = 146; // weak
__int16 x_WORD_E34CC = 310; // weak
__int16 x_WORD_E34CE = 176; // weak
__int16 x_WORD_E34EA = 360; // weak
__int16 x_WORD_E34EC = 176; // weak
__int16 x_WORD_E3508 = 360; // weak
__int16 x_WORD_E350A = 210; // weak
_UNKNOWN unk_E3522; // weak
__int16 x_WORD_E359E = 0; // weak
__int16 x_WORD_E35A0 = 0; // weak
__int16 x_WORD_E35BC = 0; // weak
__int16 x_WORD_E35BE = 0; // weak
int x_DWORD_E36C4 = 0; // weak
int x_DWORD_E36C8 = 1; // weak
__int16 x_WORD_E36CC = 0; // weak
__int16 x_WORD_E36CE = 0; // weak
char x_BYTE_E36D0 = '\0'; // weak
char x_BYTE_E36D1 = '\0'; // weak
__int16 x_WORD_E36D4 = 0; // weak
char x_BYTE_E36DC[] = { '\0' }; // weak
int x_DWORD_E3758 = 0; // weak
Bit16s x_WORD_E375C_mouse_position_x = 320; // weak
Bit16s x_WORD_E375E_mouse_position_y = 200; // weak
//int x_DWORD_E3760 = 13107520; // weak
char x_BYTE_E3766 = '\0'; // weak
int x_DWORD_E3768 = 0; // weak
int x_DWORD_E3794_sound_buffer3_lenght = 10; // weak
char x_BYTE_E3798_sound_active2 = '\x01'; // weak
char x_BYTE_E3799 = '\x01'; // weak
char x_BYTE_E379A = '\0'; // weak
char x_BYTE_E379B = '\x01'; // weak
char x_BYTE_E379C = '\x01'; // weak
Bit8u* x_DWORD_E37A0_sound_buffer2 = 0; // weak
Bit8u* x_DWORD_E37A4_sound_buffer3 = 0; // weak
Bit8u* x_DWORD_E37A8_sound_buffer1 = 0; // weak
char x_BYTE_E37AC = '\0'; // weak
Bit8s x_BYTE_E37AD_actual_sound = -1; // weak
char x_BYTE_E37AE = '\0'; // weak
int x_DWORD_E37B0 = 127; // weak
__int16 x_WORD_E37B4 = 1644; // weak
__int16 x_WORD_E37B6_sound_number = 0; // weak
char x_BYTE_E37B8 = '\0'; // weak
int x_DWORD_E37BC = 0; // weak
int x_DWORD_E37F8_midi_volume = 127; // weak
char x_BYTE_E37FC = '\x01'; // weak
char x_BYTE_E37FD = '\x01'; // weak
char x_BYTE_E37FE = '\0'; // weak
__int16 x_WORD_E3800 = 0; // weak
__int16 x_WORD_E3802 = 0; // weak //2b4802
__int16 x_WORD_E3804 = 0; // weak
Bit8u* x_DWORD_E3808_music_header = 0; // weak
Bit8u* x_DWORD_E380C = 0; // weak
Bit8u* x_DWORD_E3810_music_data = 0; // weak
Bit8u x_BYTE_E3814 = '\0'; // weak
char x_BYTE_E3815 = '\0'; // weak
char x_BYTE_E3816 = '\0'; // weak
char x_BYTE_E3817 = '\x01'; // weak
char x_BYTE_E3818 = '\0'; // weak
char x_BYTE_E3819 = '\0'; // weak
char x_BYTE_E381A = '\xFF'; // weak
__int16 x_WORD_E381C = 0; // weak
__int16 x_WORD_E381E = 0; // weak
__int16 x_WORD_E3820 = 0; // weak
__int16 x_WORD_E3822 = 0; // weak
int x_DWORD_E3824 = 0; // weak
__int16 x_WORD_E3828 = 0; // weak
__int16 x_WORD_E3834 = 0; // weak
int x_DWORD_E383C = 0; // weak
int x_DWORD_E3840 = 0; // weak
int x_DWORD_E3844 = 5; // weak
//_UNKNOWN unk_E3848; // weak
__int16 x_WORD_E387A = 0; // weak
int x_DWORD_E387C = 0; // weak
int x_DWORD_E3880 = 0; // weak
int x_DWORD_E3884 = 0; // weak
int x_DWORD_E3888 = 0; // weak
char x_BYTE_E388D = '\0'; // weak
int x_DWORD_E3890 = 0; // weak
_UNKNOWN unk_E3894; // weak
__int16 x_WORD_E3908 = 0; // weak
char x_BYTE_E390C_VGA_pal_not_begin = '\0'; // weak
char aSound_2[4096] = "SOUND\0"; // weak
char x_BYTE_E39A0 = '\0'; // weak
__int16 x_WORD_E39A4 = 0; // weak
__int16 x_WORD_E39A6 = 0; // weak
__int16 x_WORD_E39A8 = 0; // weak
__int16 x_WORD_E39AA = 0; // weak
__int16 x_WORD_E39AC = 0; // weak
__int16 x_WORD_E39AE = 0; // weak
__int16 x_WORD_E39B0 = 0; // weak
__int16 x_WORD_E39B2 = 0; // weak
__int16 x_WORD_E39B4 = 0; // weak
__int16 x_WORD_E39B6 = 0; // weak
char x_BYTE_E39B8 = '\0'; // weak
int x_DWORD_E39BC = 0; // weak
_UNKNOWN unk_E39C0; // weak
_UNKNOWN unk_E3A40; // weak
_UNKNOWN unk_E3AC0; // weak
int x_DWORD_E3B40 = 0; // weak
int x_DWORD_E3B44 = 0; // weak
__int16 x_WORD_E3B4A = 0; // weak
__int16 x_WORD_E3B4C = 0; // weak
__int16 x_WORD_E3B4E = 0; // weak
char x_BYTE_E3B50 = '\0'; // weak
char x_BYTE_E3B51 = '\0'; // weak
int(*off_E3B90)() = &_null_int23_exit; // weak
int x_DWORD_E3B94 = 0; // weak
__int16 x_WORD_E3B98 = 32; // weak
__int16 x_WORD_E3B9A = 0; // weak
__int16 x_WORD_E3BA4 = 0; // weak
__int16 x_WORD_E3BA6 = 0; // weak
__int16 x_WORD_E3BA8 = 0; // weak
__int16 x_WORD_E3BAA = 0; // weak
int x_DWORD_E3BAC = 0; // weak
int x_DWORD_E3BB0 = 0; // weak
int x_DWORD_E3BB8 = 1; // weak
_UNKNOWN unk_E3BE0; // weak
int x_DWORD_E3DE8 = 0; // weak
int x_DWORD_E3DF8 = 1024; // weak
int x_DWORD_E3DFC[] = { 0 }; // weak
void(/*__noreturn*/ *off_E3E10)() = &sub_9BA00; // weak
__int16 seg_E3E14[] = { 1 }; // weak
char x_BYTE_E3E28 = '\0'; // weak
int x_DWORD_E3E2C = 0; // weak
//void* (*off_E3E30_mallocx)(size_t size) = &malloc; // weak
//int (*off_E3E34_freex)(void*) = &x_free; // weak
int x_DWORD_E3E3C = 0; // weak
int x_DWORD_E3E40 = 0; // weak
char x_BYTE_E3E44 = '\0'; // weak
char x_BYTE_E3E45 = '\x01'; // weak
//char aBullfrog[9] = "Bullfrog"; // weak
char x_BYTE_E3E54[6] = { '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
AILTIMERCB x_DWORD_E3E5C_timer[] = { 0 }; // weak
int x_DWORD_E3E9C[] = { 0 }; // weak
int x_DWORD_E3ED8 = 0; // weak
int x_DWORD_E3EDC[] = { 0 }; // weak
int x_DWORD_E3F1C[] = { 0 }; // weak
int x_DWORD_E3F5C[] = { 0 }; // weak
int x_DWORD_E3F98 = 0; // weak
int x_DWORD_E3F9C[] = { 0 }; // weak
int x_DWORD_E3FDC = 0; // weak
__int16 x_WORD_E3FE0 = 0; // weak
int x_DWORD_E3FE2 = 0; // weak
int x_DWORD_E3FE6 = 0; // weak
int x_DWORD_E3FEA = 0; // weak
int x_DWORD_E3FEE = 0; // weak
int x_DWORD_E3FF2 = 0; // weak
__int16 x_WORD_E3FF6 = 0; // weak
int x_DWORD_E3FF8 = 0; // weak
int x_DWORD_E3FFC = 0; // weak
int x_DWORD_E4000 = 0; // weak
_UNKNOWN unk_E4004; // weak
__int16 x_WORD_E4A04 = 0; // weak
int x_DWORD_E4A08 = 0; // weak
Bit8u x_BYTE_E4A0C[128] =
{
  0x00,0x02,0x04,0x06,0x08,0x0A,0x0C,0x0E,
  0x10,0x12,0x14,0x16,0x18,0x1A,0x1C,0x1E,
  0x20,0x22,0x24,0x26,0x28,0x2A,0x2C,0x2E,
  0x30,0x32,0x34,0x36,0x38,0x3A,0x3C,0x3E,
  0x40,0x42,0x44,0x46,0x48,0x4A,0x4C,0x4E,
  0x50,0x52,0x54,0x56,0x58,0x5A,0x5C,0x5E,
  0x60,0x62,0x64,0x66,0x68,0x6A,0x6C,0x6E,
  0x70,0x72,0x74,0x76,0x78,0x7A,0x7C,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80
}; // idb
int x_DWORD_E4A8C = 0; // weak
int x_DWORD_E4A90 = 0; // weak
int x_DWORD_E4A94 = 0; // weak
char aSample[7] = "SAMPLE"; // weak
int x_DWORD_E4B18 = 0; // weak
int x_DWORD_E4B1C = 0; // weak
char aTimb_0[5] = "TIMB"; // weak
char x_BYTE_E4B2A = '\xFF'; // weak
char x_BYTE_E4B2B = '\xFF'; // weak
int x_DWORD_E4B2C = 0; // weak
int x_DWORD_E4C90 = 0; // weak
int x_DWORD_E4C94 = 0; // weak
int x_DWORD_E4CA4 = 0; // weak

char x_BYTE_E4CB4 = '\0'; // weak
int(/*__fastcall*/ *off_E4CBD)(x_DWORD) = &nullsub_3; // weak
int x_DWORD_E4CCC = 0; // weak
int x_DWORD_E4CD0 = 0; // weak
int x_DWORD_E4D10 = 0; // weak
__int16 x_WORD_E4D14 = 0; // weak
__int16 x_WORD_E4D16 = 0; // weak
char x_BYTE_E4D18 = '\0'; // weak
int(*off_E4D20)(x_DWORD, x_DWORD) = &_no_support_loaded; // weak
int x_DWORD_E4E1C = 0; // weak
int x_DWORD_E4E20 = 0; // weak
int x_DWORD_E4E24 = 0; // weak
int x_DWORD_E4E28 = 0; // weak
int x_DWORD_E4E2C = 0; // weak
__int64 qx_WORD_E4E30 = 0i64; // weak
int x_DWORD_E4E38 = 0; // weak
__int16 x_WORD_E4E3C = 0; // weak
_UNKNOWN unk_E52EE; // weak
int x_DWORD_E731C = 16; // weak
int x_DWORD_E7320[] = { 0 }; // weak
int x_DWORD_E7324[255] =
{
  1647088,
  3294115,
  4941018,
  6587735,
  8234204,
  9880363,
  11526150,
  13171503,
  14816360,
  16460659,
  18104339,
  19747337,
  21389591,
  23031040,
  24671622,
  26311275,
  27949938,
  29587548,
  31224044,
  32859365,
  34493448,
  36126233,
  37757658,
  39387661,
  41016182,
  42643158,
  44268528,
  45892232,
  47514208,
  49134395,
  50752733,
  52369159,
  53983614,
  55596036,
  57206365,
  58814541,
  60420502,
  62024188,
  63625539,
  65224495,
  66820995,
  68414979,
  70006387,
  71595160,
  73181237,
  74764559,
  76345066,
  77922699,
  79497398,
  81069104,
  82637758,
  84203301,
  85765673,
  87324816,
  88880672,
  90433181,
  91982285,
  93527927,
  95070047,
  96608588,
  98143491,
  99674700,
  101202156,
  102725801,
  104245579,
  105761432,
  107273304,
  108781136,
  110284873,
  111784458,
  113279835,
  114770946,
  116257736,
  117740150,
  119218130,
  120691622,
  122160570,
  123624918,
  125084613,
  126539598,
  127989818,
  129435220,
  130875749,
  132311350,
  133741970,
  135167555,
  136588051,
  138003404,
  139413562,
  140818470,
  142218077,
  143612330,
  145001175,
  146384561,
  147762436,
  149134748,
  150501445,
  151862476,
  153217789,
  154567334,
  155911059,
  157248914,
  158580849,
  159906814,
  161226758,
  162540632,
  163848386,
  165149972,
  166445340,
  167734441,
  169017227,
  170293650,
  171563661,
  172827213,
  174084258,
  175334749,
  176578639,
  177815881,
  179046428,
  180270234,
  181487253,
  182697439,
  183900746,
  185097130,
  186286545,
  187468946,
  188644290,
  189812531,
  190973625,
  192127530,
  193274201,
  194413595,
  195545670,
  196670383,
  197787691,
  198897553,
  199999926,
  201094769,
  202182041,
  203261701,
  204333709,
  205398023,
  206454605,
  207503413,
  208544409,
  209577553,
  210602807,
  211620132,
  212629490,
  213630842,
  214624151,
  215609379,
  216586490,
  217555447,
  218516213,
  219468752,
  220413028,
  221349005,
  222276649,
  223195924,
  224106796,
  225009231,
  225903194,
  226788652,
  227665571,
  228533919,
  229393663,
  230244770,
  231087209,
  231920947,
  232745954,
  233562198,
  234369648,
  235168275,
  235958047,
  236738936,
  237510912,
  238273946,
  239028009,
  239773072,
  240509108,
  241236089,
  241953988,
  242662778,
  243362431,
  244052922,
  244734224,
  245406312,
  246069161,
  246722745,
  247367041,
  248002023,
  248627668,
  249243953,
  249850853,
  250448347,
  251036411,
  251615025,
  252184165,
  252743810,
  253293940,
  253834533,
  254365570,
  254887030,
  255398893,
  255901141,
  256393755,
  256876715,
  257350004,
  257813604,
  258267497,
  258711667,
  259146097,
  259570769,
  259985670,
  260390781,
  260786089,
  261171579,
  261547236,
  261913046,
  262268994,
  262615069,
  262951256,
  263277543,
  263593918,
  263900369,
  264196884,
  264483453,
  264760063,
  265026706,
  265283370,
  265530047,
  265766727,
  265993400,
  266210059,
  266416696,
  266613302,
  266799870,
  266976394,
  267142865,
  267299279,
  267445630,
  267581911,
  267708118,
  267824246,
  267930290,
  268026247,
  268112113,
  268187885,
  268253559,
  268309134,
  268354608,
  268389978,
  268415243,
  268430402
}; // idb
int x_DWORD_E7720 = 268435456; // weak
int x_DWORD_E7724[] = { 0 }; // weak
void *off_E7728[255] =
{
  &unk_FFFFA,
  (void *)0x1FFFD5,
  (void *)0x2FFF70,
  (void *)0x3FFEAA,
  (void *)0x4FFD65,
  (void *)0x5FFB80,
  (void *)0x6FF8DB,
  (void *)0x7FF556,
  (void *)0x8FF0D2,
  (void *)0x9FEB2F,
  (void *)0xAFE44D,
  (void *)0xBFDC0C,
  (void *)0xCFD24C,
  (void *)0xDFC6EF,
  (void *)0xEFB9D4,
  (void *)0xFFAADD,
  (void *)0x10F99EA,
  (void *)0x11F86DB,
  (void *)0x12F7193,
  (void *)0x13F59F0,
  (void *)0x14F3FD6,
  (void *)0x15F2324,
  (void *)0x16F03BD,
  (void *)0x17EE182,
  (void *)0x18EBC54,
  (void *)0x19E9415,
  (void *)0x1AE68A7,
  (void *)0x1BE39EB,
  (void *)0x1CE07C5,
  (void *)0x1DDD217,
  (void *)0x1ED98C2,
  (void *)0x1FD5BA9,
  (void *)0x20D1AB0,
  (void *)0x21CD5B9,
  (void *)0x22C8CA8,
  (void *)0x23C3F5F,
  (void *)0x24BEDC2,
  (void *)0x25B97B6,
  (void *)0x26B3D1D,
  (void *)0x27ADDDD,
  (void *)0x28A79D8,
  (void *)0x29A10F5,
  (void *)0x2A9A317,
  (void *)0x2B93023,
  (void *)0x2C8B7FF,
  (void *)0x2D83A91,
  (void *)0x2E7B7BD,
  (void *)0x2F72F69,
  (void *)0x306A17C,
  (void *)0x3160DDC,
  (void *)0x325746F,
  (void *)0x334D51D,
  (void *)0x3442FCC,
  (void *)0x3538463,
  (void *)0x362D2CA,
  (void *)0x3721AEA,
  (void *)0x3815CA9,
  (void *)0x39097F1,
  (void *)0x39FCCA9,
  (void *)0x3AEFABB,
  (void *)0x3BE2210,
  (void *)0x3CD4291,
  (void *)0x3DC5C28,
  (void *)0x3EB6EBF,
  (void *)0x3FA7A3F,
  (void *)0x4097E94,
  (void *)0x4187BA8,
  (void *)0x4277165,
  (void *)0x4365FB9,
  (void *)0x445468D,
  (void *)0x45425CE,
  (void *)0x462FD68,
  (void *)0x471CD48,
  (void *)0x4809559,
  (void *)0x48F558A,
  (void *)0x49E0DC8,
  (void *)0x4ACBDFF,
  (void *)0x4BB661E,
  (void *)0x4CA0613,
  (void *)0x4D89DCD,
  (void *)0x4E72D3A,
  (void *)0x4F5B44A,
  (void *)0x50432EB,
  (void *)0x512A90D,
  (void *)0x52116A1,
  (void *)0x52F7B96,
  (void *)0x53DD7DC,
  (void *)0x54C2B66,
  (void *)0x55A7623,
  (void *)0x568B805,
  (void *)0x576F0FE,
  (void *)0x5852100,
  (void *)0x59347FD,
  (void *)0x5A165E7,
  (void *)0x5AF7AB2,
  (void *)0x5BD8650,
  (void *)0x5CB88B5,
  (void *)0x5D981D4,
  (void *)0x5E771A2,
  (void *)0x5F55812,
  (void *)0x603351A,
  (void *)0x61108AE,
  (void *)0x61ED2C3,
  (void *)0x62C934E,
  (void *)0x63A4A45,
  (void *)0x647F79F,
  (void *)0x6559B50,
  (void *)0x6633551,
  (void *)0x670C597,
  (void *)0x67E4C19,
  (void *)0x68BC8CF,
  (void *)0x6993BB0,
  (void *)0x6A6A4B5,
  (void *)0x6B403D5,
  (void *)0x6C15908,
  (void *)0x6CEA447,
  (void *)0x6DBE58B,
  (void *)0x6E91CCD,
  (void *)0x6F64A07,
  (void *)0x7036D32,
  (void *)0x7108647,
  (void *)0x71D9542,
  (void *)0x72A9A1C,
  (void *)0x73794D0,
  (void *)0x7448559,
  (void *)0x7516BB2,
  (void *)0x75E47D6,
  (void *)0x76B19C1,
  (void *)0x777E16E,
  (void *)0x7849EDA,
  (void *)0x7915201,
  (void *)0x79DFADF,
  (void *)0x7AA9971,
  (void *)0x7B72DB5,
  (void *)0x7C3B7A6,
  (void *)0x7D03742,
  (void *)0x7DCAC88,
  (void *)0x7E91774,
  (void *)0x7F57805,
  (void *)0x801CE39,
  (void *)0x80E1A0F,
  (void *)0x81A5B84,
  (void *)0x8269298,
  (void *)0x832BF4A,
  (void *)0x83EE199,
  (void *)0x84AF984,
  (void *)0x857070B,
  (void *)0x8630A2D,
  (void *)0x86F02EB,
  (void *)0x87AF145,
  (void *)0x886D53B,
  (void *)0x892AECD,
  (void *)0x89E7DFD,
  (void *)0x8AA42CB,
  (void *)0x8B5FD37,
  (void *)0x8C1AD44,
  (void *)0x8CD52F2,
  (void *)0x8D8EE43,
  (void *)0x8E47F39,
  (void *)0x8F005D5,
  (void *)0x8FB821A,
  (void *)0x906F409,
  (void *)0x9125BA6,
  (void *)0x91DB8F1,
  (void *)0x9290BEE,
  (void *)0x93454A0,
  (void *)0x93F9309,
  (void *)0x94AC72C,
  (void *)0x955F10D,
  (void *)0x96110AF,
  (void *)0x96C2614,
  (void *)0x9773142,
  (void *)0x982323A,
  (void *)0x98D2902,
  (void *)0x998159C,
  (void *)0x9A2F80E,
  (void *)0x9ADD05B,
  (void *)0x9B89E86,
  (void *)0x9C36296,
  (void *)0x9CE1C8E,
  (void *)0x9D8CC72,
  (void *)0x9E37248,
  (void *)0x9EE0E15,
  (void *)0x9F89FDC,
  (void *)0xA0327A3,
  (void *)0xA0DA570,
  (void *)0xA181947,
  (void *)0xA22832D,
  (void *)0xA2CE329,
  (void *)0xA37393F,
  (void *)0xA418575,
  (void *)0xA4BC7D1,
  (void *)0xA560058,
  (void *)0xA602F11,
  (void *)0xA6A5401,
  (void *)0xA746F2D,
  (void *)0xA7E809D,
  (void *)0xA888856,
  (void *)0xA92865F,
  (void *)0xA9C7ABD,
  (void *)0xAA66578,
  (void *)0xAB04694,
  (void *)0xABA1E1A,
  (void *)0xAC3EC0F,
  (void *)0xACDB07A,
  (void *)0xAD76B62,
  (void *)0xAE11CCE,
  (void *)0xAEAC4C3,
  (void *)0xAF4634A,
  (void *)0xAFDF868,
  (void *)0xB078425,
  (void *)0xB110688,
  (void *)0xB1A7F98,
  (void *)0xB23EF5C,
  (void *)0xB2D55DB,
  (void *)0xB36B31C,
  (void *)0xB400727,
  (void *)0xB495202,
  (void *)0xB5293B6,
  (void *)0xB5BCC49,
  (void *)0xB64FBC2,
  (void *)0xB6E222A,
  (void *)0xB773F88,
  (void *)0xB8053E2,
  (void *)0xB895F42,
  (void *)0xB9261AD,
  (void *)0xB9B5B2D,
  (void *)0xBA44BC7,
  (void *)0xBAD3385,
  (void *)0xBB6126E,
  (void *)0xBBEE889,
  (void *)0xBC7B5DE,
  (void *)0xBD07A75,
  (void *)0xBD93656,
  (void *)0xBE1E988,
  (void *)0xBEA9414,
  (void *)0xBF33600,
  (void *)0xBFBCF56,
  (void *)0xC04601C,
  (void *)0xC0CE85B,
  (void *)0xC15681B,
  (void *)0xC1DDF62,
  (void *)0xC264E3B,
  (void *)0xC2EB4AB,
  (void *)0xC3712BC,
  (void *)0xC3F6875,
  (void *)0xC47B5DE,
  (void *)0xC4FFAFF,
  (void *)0xC5837E0,
  (void *)0xC606C8A,
  (void *)0xC689903,
  (void *)0xC70BD54,
  (void *)0xC78D986,
  (void *)0xC80ED9F,
  (void *)0xC88F9A8
}; // idb
int x_DWORD_E7B24 = 210828714; // weak
__int16 x_WORD_E7C58 = 0; // weak
_UNKNOWN unk_E7C64; // weak
double dbl_E7C6E = 1.7976931348623157e+308; // weak
float flt_E7C76 = 3.4028235e38; // weak
int x_DWORD_E7EE0[] = { 0 }; // weak
int x_DWORD_E7EE4[] = { 0 }; // weak
typedef struct {
	Bit8u* pointer;
	Bit16u size;
}myStructps;
myStructps x_DWORD_E7EE8x[100]; // weak
int x_DWORD_E7EEC[] = { 0 }; // weak
int x_DWORD_E7EF0[] = { 0 }; // weak
int x_DWORD_E7EF4[594] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,

}; // idb
int x_DWORD_E8840; // weak
char x_BYTE_E88E0[1]; // fix it - weak
char x_BYTE_E88E1[1]; // fix it -  weak
char x_BYTE_E88E2[1]; // fix it -  weak
char x_BYTE_E88E3; // weak
char x_BYTE_E88E4; // weak
char x_BYTE_E88E5; // weak
char x_BYTE_E88E6; // weak
char x_BYTE_E88E7; // weak
char x_BYTE_E88E8; // weak
char x_BYTE_E88E9; // weak
char x_BYTE_E88EA; // weak
char x_BYTE_E88EB; // weak
char x_BYTE_E88EC; // weak
char x_BYTE_E88ED; // weak
char x_BYTE_E88EE; // weak
char x_BYTE_E88EF; // weak
char x_BYTE_E88F0; // weak
char x_BYTE_E88F1; // weak
char x_BYTE_E88F2; // weak
char x_BYTE_E88F3; // weak
char x_BYTE_E88F4; // weak
char x_BYTE_E88F5; // weak
char x_BYTE_E88F6; // weak
char x_BYTE_E88F7; // weak
//Bit8u (*xadataclrd0dat.var28_begin_buffer)[4096]; // fix it -  weak
char x_BYTE_E890F; // weak
char x_BYTE_E8988; // weak
char x_BYTE_E89F0; // weak
char x_BYTE_E89FF; // weak
char x_BYTE_E9188; // weak
char x_BYTE_E9800; // weak
char x_BYTE_E980F; // weak
char x_BYTE_E98F0; // weak
char x_BYTE_E98FF; // weak
myStructps x_DWORD_E9980x[32]; // weak
//Bit16u x_WORD_E9984[0x86]; // idb
//int x_DWORD_E9B20[2] = {0,0}; // fix it -  weak
//Pathstruct x_DWORD_E9B20[2] = { pstr[3],pstr[3] };
filearray_struct x_DWORD_E9B20[2] = { filearray_2aa18c[filearrayindex_FONTS0DATTAB],filearray_2aa18c[filearrayindex_MSPRDDATTAB] };


/*
0x19f028,0x19f028,0xb803ebfc,c91fffff...
*/
int x_DWORD_E9B90; // weak
int x_DWORD_E9BA8; // weak
int x_DWORD_E9C08; // weak
int x_DWORD_E9C14; // weak
int x_DWORD_E9C18; // weak
int x_DWORD_E9C1C; // weak
int x_DWORD_E9C20; // weak
int x_DWORD_E9C24_fps; // weak
int x_DWORD_E9C28; // weak
//Bit8u* x_DWORD_E9C2C; // weak

//Bit32u x_DWORD_E9C90 = 0;
//Bit32u x_DWORD_E9A00 = 0;
//Bit32u x_DWORD_E9A20 = 0;

/*Bit32u PSTR01 = 0;
Bit32u PSTR02 = 0;
Bit32u PSTR03 = 0;
Bit32u PSTR04 = 0;
Bit32u PSTR05 = 0;
Bit32u PSTR06 = 0;
Bit32u PSTR07 = 0;
Bit32u PSTR08 = 0;
Bit32u PSTR09 = 0;
Bit32u PSTR10 = 0;
Bit32u PSTR11 = 0;
Bit32u PSTR12 = 0;
Bit32u PSTR13 = 0;
Bit32u PSTR14 = 0;

Bit32u PSTR01B = 0;
Bit32u PSTR02B = 0;
Bit32u PSTR03B = 0;
Bit32u PSTR04B = 0;
Bit32u PSTR05B = 0;
Bit32u PSTR06B = 0;
Bit32u PSTR07B = 0;
Bit32u PSTR08B = 0;
Bit32u PSTR09B = 0;
Bit32u PSTR10B = 0;
Bit32u PSTR11B = 0;
Bit32u PSTR12B = 0;
Bit32u PSTR13B = 0;
Bit32u PSTR14B = 0;*/



//Bit8u *x_DWORD_E9C38_smalltit[64000]; // weak
Bit8u* x_DWORD_E9C3C; // weak
Bit8u* x_DWORD_E9C4C_langindexbuffer[1000]; // idb
//char* E9C4C_langindexbuffer[1000];
//int x_DWORD_E9C54; // weak
//int x_DWORD_E9C84; // weak
//int x_DWORD_E9CA8[136]; // idb
//int x_DWORD_E9EC8; // weak
//int x_DWORD_E9ECC[123]; // idb
//int x_DWORD_EA0B8; // weak
//int x_DWORD_EA1D0; // weak
//int x_DWORD_EA224; // weak
//int x_DWORD_EA230; // weak
//int x_DWORD_EA234; // weak
//int x_DWORD_EA238; // weak
//int x_DWORD_EA240; // weak
//int x_DWORD_EA244; // weak
//int x_DWORD_EA248; // weak
//int x_DWORD_EA24C; // weak
//int x_DWORD_EA250; // weak
//int x_DWORD_EA254; // weak
//int x_DWORD_EA26C; // weak
//int x_DWORD_EA270; // weak
//int x_DWORD_EA274; // weak
//int x_DWORD_EA2C4; // weak
//int x_DWORD_EA2E8; // weak
//int x_DWORD_EA2EC; // weak
//int x_DWORD_EA2F0; // weak
//int x_DWORD_EA300; // weak
//int x_DWORD_EA304; // weak
//int x_DWORD_EA308; // weak
int x_DWORD_EA3B4; // weak?x_DWORD_E9C4C_langindexbuffer[474]
int x_DWORD_EA3B8; // weak?x_DWORD_E9C4C_langindexbuffer[475]
/*int x_DWORD_EA3BC; // weak*/
int x_DWORD_EA3C0; // weak?x_DWORD_E9C4C_langindexbuffer[477]
int x_DWORD_EA3C4; // weak?x_DWORD_E9C4C_langindexbuffer[478]
int x_DWORD_EA3C8; // weak?x_DWORD_E9C4C_langindexbuffer[479]
int x_DWORD_EA3CC; // weak?x_DWORD_E9C4C_langindexbuffer[480]
int x_DWORD_EA3D0; // weak?x_DWORD_E9C4C_langindexbuffer[481]
posistruct* x_DWORD_EA3D4; // weak
//Bit8u *xadatapald0dat2.var28_begin_buffer[0x300]; // weak
/*int x_DWORD_EA3DC; // weak*/
/*int x_DWORD_EA3E0_copyto_x_DWORD_EA3E0[]; // weak*/
int x_DWORD_EA3E4[1]; // fix it -  weak
int x_DWORD_EA3E8; // weak

int x_DWORD_EB384; // weak
/*int x_DWORD_EB394; // weak*/
__int16 x_WORD_EB398; // weak
__int16 x_WORD_EB39A; // weak
__int16 x_WORD_EB39C; // weak
Bit8u x_BYTE_EB39E_keys[10]; // weak 0 - setting keys
Bit8u x_BYTE_EB3A8;
/*char x_BYTE_EB39F; // weak 1
char x_BYTE_EB3A0; // weak 2
char x_BYTE_EB3A1; // weak 3
char x_BYTE_EB3A2; // weak 4
char x_BYTE_EB3A3; // weak 5
char x_BYTE_EB3A4; // weak 6
char x_BYTE_EB3A5; // weak 7
char x_BYTE_EB3A6; // weak 8
char x_BYTE_EB3A7; // weak 9
char x_BYTE_EB3A8; // weak 10*/
char x_BYTE_EB3B6; // weak 
_UNKNOWN unk_F0000; // weak
Bit8u* x_DWORD_F01E4; // weak
int(*x_DWORD_F01E8)(x_DWORD, x_DWORD, x_DWORD); // weak
int(*x_DWORD_F01EC)(x_DWORD, x_DWORD, x_DWORD); // weak
Bit16u x_WORD_F01F4; // weak
char x_BYTE_F01FE[1]; // fix it -  weak
char x_BYTE_F01FF[1]; // fix it -  weak
char x_BYTE_F0200[31]; // idb
char x_BYTE_F021F; // weak
char x_BYTE_F0220[256]; // idb
char x_BYTE_F0320[256]; // idb
char x_BYTE_F0420[256]; // idb
char x_BYTE_F0520[256]; // idb
char x_BYTE_F0620[256]; // idb
char x_BYTE_F0720[256]; // idb
char x_BYTE_F0820[256]; // idb
char x_BYTE_F0920[256]; // idb
_UNKNOWN unk_F0A20; // weak
_UNKNOWN unk_F0E20; // weak
int x_DWORD_F2C20; // weak
int x_DWORD_F2C24; // weak
int x_DWORD_F2C28; // weak
int x_DWORD_F2C2C; // weak
int x_DWORD_F2C30; // weak
int x_DWORD_F2C34; // weak
int x_DWORD_F2C38; // weak
int x_DWORD_F2C3C; // weak
int x_DWORD_F2C40; // weak
int x_DWORD_F2C44; // weak
int x_DWORD_F2C48; // weak
int x_DWORD_F2C4C; // weak
int x_DWORD_F2C50; // weak
int x_DWORD_F2C54; // weak
int x_DWORD_F2C58; // weak
int x_DWORD_F2C5C; // weak
int x_DWORD_F2C60; // weak
int x_DWORD_F2C64; // weak
int x_DWORD_F2C68; // weak
int x_DWORD_F2C6C; // weak
int x_DWORD_F2C70; // weak
int x_DWORD_F2C74; // weak
int x_DWORD_F2C78; // weak
int x_DWORD_F2C7C; // weak
int x_DWORD_F2C80; // weak
int x_DWORD_F2C84; // weak
int x_DWORD_F2C88; // weak
int x_DWORD_F2C8C; // weak
int x_DWORD_F2C90; // weak
int x_DWORD_F2C94; // weak
int x_DWORD_F2C98; // weak
int x_DWORD_F2C9C; // weak
int x_DWORD_F2CA0; // weak
int x_DWORD_F2CA4; // weak
int x_DWORD_F2CA8; // weak
int x_DWORD_F2CAC; // weak
int x_DWORD_F2CB0; // weak
int x_DWORD_F2CB4; // weak
int x_DWORD_F2CB8; // weak
int x_DWORD_F2CBC; // weak
__int16 x_WORD_F2CC0; // weak
__int16 x_WORD_F2CC2; // weak
__int16 x_WORD_F2CC4; // weak
char x_BYTE_F2CC6; // weak
char x_BYTE_F2CC7; // weak
char x_BYTE_F2CD0[1]; // fix it -  weak
char x_BYTE_F2CD1[4815]; // idb
char x_BYTE_F3FA0[1]; // fix it -  weak
char x_BYTE_F3FA1[1]; // fix it -  weak
char x_BYTE_F3FA2[670]; // idb
Bit32u unk_F4240 = 1000; // weak
int x_DWORD_F42A0; // weak
HTIMER x_DWORD_F42A4_sound_timer; // weak
__int16 x_WORD_F42A8; // weak
__int16 x_WORD_F42AE; // weak
_UNKNOWN unk_F42B0; // weak
POSITION x_DWORD_F4720; // weak
int x_DWORD_F4940; // weak
__int16 x_WORD_F4960[1]; // fix it -  weak
__int16 x_WORD_F4962[830]; // idb
__int16 x_WORD_F4FE0[1]; // fix it -  weak
__int16 x_WORD_F4FE2[1]; // fix it -  weak
__int16 x_WORD_F4FE4[1]; // fix it -  weak
__int16 x_WORD_F4FE6[1]; // fix it -  weak
__int16 x_WORD_F4FE8[1]; // fix it -  weak
__int16 x_WORD_F4FEA[418]; // idb
int x_DWORD_F5330; // weak
__int16 x_WORD_F5334; // weak
char x_BYTE_F5340[504]; // idb
char x_BYTE_F5538[504]; // idb
int x_DWORD_F5730[504]; // idb
int x_DWORD_F5F10[504]; // idb
int x_DWORD_F66F0[504]; // idb
//Bit8u TMAPS00TAB_BEGIN_BUFFER[80]; // weak
//Bit8u* TMAPS00TAB_BEGIN_BUFFER; // weak
//char x_BYTE_F6EE0_tables[16384]; // idb
Bit8u* x_BYTE_F6EE0_tablesbuff;
Bit8u* x_BYTE_F6EE0_tables = (Bit8u*)&x_BYTE_F6EE0_tablesbuff;
char x_BYTE_FAEE0[16672]; // idb
_UNKNOWN unk_FF000; // weak
_UNKNOWN unk_100000; // weak
_UNKNOWN unk_100001; // weak
char x_BYTE_10AEE0[768]; // idb
char x_BYTE_10B1E0[511]; // idb
char x_BYTE_10B3DF[1]; // fix it -  weak
char x_BYTE_10B3E0[255]; // idb
char x_BYTE_10B4DF[1]; // fix it -  weak
char x_BYTE_10B4E0[65536]; // idb
Bit8u x_BYTE_11B4E0[65536]; // idb
char x_BYTE_12B4E0[1]; // fix it -  weak
_UNKNOWN unk_12C000; // weak
//_UNKNOWN unk_13A9CA; // weak
//_UNKNOWN unk_13ACCA; // weak
//_UNKNOWN unk_13B194; // weak
//_UNKNOWN unk_13B3B8; // weak
char x_BYTE_13B4E0[65536]; // idb
//_UNKNOWN unk_13CE20; // weak
//_UNKNOWN unk_141E85; // weak
//_UNKNOWN unk_145210; // weak
/*char x_BYTE_14B4E0[65536]; // idb*/
__int16 x_WORD_15B4E0[65536]; // idb
//_UNKNOWN unk_163EFC; // weak
//_UNKNOWN unk_1641FC; // weak
//_UNKNOWN unk_1646BA; // weak
//_UNKNOWN unk_164907; // weak
//_UNKNOWN unk_164DAE; // weak
_UNKNOWN unk_164FCD; // weak
_UNKNOWN unk_165329; // weak
//_UNKNOWN unk_16554D; // weak
//_UNKNOWN unk_178B5F; // weak
_UNKNOWN unk_178E5F; // weak
__int16 x_WORD_17B4E0; // weak
_UNKNOWN unk_17C118; // weak
int x_DWORD_17D430; // weak
__int16 x_WORD_17D434; // weak
char x_BYTE_17D440[1]; // fix it -  weak
char x_BYTE_17D441[255]; // idb
_UNKNOWN unk_17D540; // weak
int x_DWORD_17D640; // weak
int x_DWORD_17D644; // weak
int x_DWORD_17D648; // weak
char x_BYTE_17D650[6]; // weak
char x_BYTE_17D674[6]; // weak
int x_DWORD_17D698; // weak
int x_DWORD_17D6A0; // weak
int x_DWORD_17D6A4; // weak
int x_DWORD_17D6A8; // weak
int x_DWORD_17D6AC; // weak
int x_DWORD_17D6B0; // weak
int x_DWORD_17D6C4; // weak
int x_DWORD_17D6C8; // weak
__int16 x_WORD_17D6CC; // weak
__int16 x_WORD_17D6CE; // weak
__int16 x_WORD_17D6D0; // weak
_UNKNOWN unk_17D6D4; // weak
int x_DWORD_17D6E4; // weak
int x_DWORD_17D6E8; // weak
int x_DWORD_17D6EC; // weak
int x_DWORD_17D6F0; // weak
__int16 x_WORD_17D6F6; // weak
__int16 x_WORD_17D706; // weak
__int16 x_WORD_17D708; // weak
__int16 x_WORD_17D70A; // weak
__int16 x_WORD_17D70C; // weak
__int16 x_WORD_17D70E; // weak
char x_BYTE_17D710; // weak
Bit32u x_DWORD_17D720[4]; // weak 0
Bit16u x_WORD_17D724; // weak 4
Bit16u x_WORD_17D726; // weak 6
int x_DWORD_17D730; // weak 
char x_BYTE_17D738[256]; // idb
Bit8u unk_17D838[0x300]; // weak
FILE* x_DWORD_17DB38_intro_file_handle; // weak
int(/*__fastcall*/ *x_DWORD_17DB3C)(); // weak
Bit8u unk_17DB40[12]; // weak
Bit16s x_WORD_17DB46; // weak
Bit16s x_WORD_17DB48; // weak
Bit16s x_WORD_17DB4A; // weak
Bit8u* x_DWORD_17DB50; // weak
int x_DWORD_17DB54_game_turn2; // weak
__int16 x_WORD_17DB58; // weak
__int16 x_WORD_17DB5A; // weak
__int16 x_WORD_17DB5C; // weak
Bit16u x_WORD_17DB60; // weak

struct
{
	Bit32u x_DWORD_17DB70; // weak
	Bit16s x_WORD_17DB74; // weak 4
	Bit16s unk_17DB76_posx; // weak 6
	Bit16s unk_17DB78_posy; // weak 8
	Bit16s fill1; // test 10
	Bit16s fill2; // test 12
	Bit16s unk_17DB7E; // weak 14
	Bit16s unk_17DB80; // weak 16
	Bit16s x_WORD_17DB82_shift_step; // weak 18
	Bit16s x_WORD_17DB84; // weak 20
	Bit16s x_WORD_17DB86; // weak 22
	Bit16s x_WORD_17DB88; // weak 24
	Bit16s x_WORD_17DB8A; // weak 26
	Bit16s x_WORD_17DB8C; // weak 28
	Bit8s x_BYTE_17DB8E; // weak 30
	Bit8s x_BYTE_17DB8F; // weak 31
	Bit16s unk_17DB90; // weak 32
	Bit8u unk_17DB92[6]; // weak 32	
	Bit8u fill3[16]; // fill
} x_DWORD_17DB70str;

struct
{
	Bit32u unk_17DBA8; // weak 40
	Bit32u unk_17DBAC; //1(+4)
	Bit32u unk_17DBB0; //2(+8)
	Bit16u unk_17DBB4; //3(+12)
	Bit8u x_BYTE_17DBB5; //(+14)
	Bit8u x_BYTE_17DBB6; //(+15)
} unk_17DBA8str;//16
Bit32s x_DWORD_17DBB8[4]; // weak//x_DWORD_17DBB8[0]
//int x_DWORD_17DBBC; // weak//x_DWORD_17DBB8[1]
__int16 x_WORD_17DBC4 = 0; // weak//x_DWORD_17DBB8[3] 34ebc4
char x_BYTE_17DBC6; // weak
//Bit8u** x_DWORD_17DBC8x[1000];//fix it
int x_DWORD_17DBC8[1]; // fix it -  weak 0
int x_DWORD_17DBCC[1]; // fix it -  weak 1
int x_DWORD_17DBD0[1]; // fix it -  weak 2
int x_DWORD_17DBD4[1]; // fix it -  weak 3
int x_DWORD_17DBD8[121]; // idb
int x_DWORD_17DDBC[1]; // fix it -  weak
int x_DWORD_17DDC0[1]; // fix it -  weak
int x_DWORD_17DDC4[1]; // fix it -  weak
int x_DWORD_17DDC8[1]; // fix it -  weak
int x_DWORD_17DDCC[21]; // idb
int x_DWORD_17DE22; // weak
__int16 x_WORD_17DE26; // weak
struct//lenght 13
{
	Bit32s x_DWORD_17DE28; // weak x_DWORD_17DE28str
	Bit32s x_DWORD_17DE2C; // weak x_DWORD_17DE28str+4
	Bit16s x_WORD_17DE30_posx; // weak x_DWORD_17DE28str+8
	Bit16s x_WORD_17DE32_posy; // weak x_DWORD_17DE28str+10
	Bit8s x_BYTE_17DE34; // weak x_DWORD_17DE28str+12
} x_DWORD_17DE28str;

Bit8u* x_DWORD_17DE38; // weak
Bit8u* x_DWORD_17DE3C; // weak//1
Bit8u* x_DWORD_17DE40; // weak//2
Bit8u* x_DWORD_17DE44; // weak//3
Bit8u* x_DWORD_17DE48c; // weak//4
Bit8u* x_DWORD_17DE4C; // weak
Bit8u* x_DWORD_17DE50; // weak
Bit8u* x_DWORD_17DE54; // weak
Bit8u* x_DWORD_17DE58; // weak
Bit8u* x_DWORD_17DE5C_border_bitmap; // weak
Bit8u* x_DWORD_17DE60; // weak
Bit8u* x_DWORD_17DE64_game_world_map; // weak
char x_BYTE_17DE68[1]; // fix it -  weak
char x_BYTE_17DE69[1]; // fix it -  weak
char x_BYTE_17DE71[1]; // fix it -  weak
char x_BYTE_17DE72[78]; // idb
Bit8u* x_DWORD_17DEC0; // weak
Bit8u* x_DWORD_17DEC4; // weak
Bit8u* x_DWORD_17DEC8; // weak
Bit8u* x_DWORD_17DECC; // weak
int x_DWORD_17DED0; // weak
Bit8u* x_DWORD_17DED4; // weak
Bit8u* x_DWORD_17DED8; // weak
int x_DWORD_17DEDC; // weak
FILE* x_DWORD_17DEE0_filedesc; // weak
Bit16s x_DWORD_17DEE4_mouse_positionx; // weak
Bit16s x_DWORD_17DEE4_mouse_positiony; // weak
__int16 x_WORD_17DEEC; // weak
__int16 x_WORD_17DEEE; // weak
__int16 x_WORD_17DEF0; // weak
__int16 x_WORD_17DEF2; // weak
__int16 x_WORD_17DEF4; // weak
__int16 x_WORD_17DEF6; // weak
__int16 x_WORD_17DEF8; // weak
__int16 x_WORD_17DEFA; // weak
__int16 x_WORD_17DEFC; // weak
__int16 x_WORD_17DEFE; // weak
__int16 x_WORD_17DF00; // weak
__int16 x_WORD_17DF02; // weak
__int16 x_WORD_17DF04; // weak
__int16 x_WORD_17DF06; // weak
__int16 x_WORD_17DF08; // weak
__int16 x_WORD_17DF0A; // weak
__int16 x_WORD_17DF0C; // weak
__int16 x_WORD_17DF0E; // weak
char x_BYTE_17DF10_get_key_scancode; // weak
char x_BYTE_17DF11_last_key_status; // weak
char x_BYTE_17DF13; // weak
Bit8u x_BYTE_17DF14[400]; // idb
char x_BYTE_17DF3C[400]; // fix it -  weak
char x_BYTE_17DF3D[400]; // fix it -  weak
char x_BYTE_17DF3E[400]; // idb
__int16 x_WORD_17E06C; // weak
__int16 x_WORD_17E06E; // weak
__int16 x_WORD_17E070; // weak
__int16 x_WORD_17E072; // weak
__int16 x_WORD_17E074; // weak
__int16 x_WORD_17E076; // weak
_UNKNOWN unk_17E078; // weak
__int16 x_WORD_17E07C; // weak
__int16 x_WORD_17E07E; // weak
__int16 x_WORD_17E080; // weak
char x_BYTE_17E082; // weak
char x_BYTE_17E083; // weak
_UNKNOWN unk_17E084; // weak
char x_BYTE_17E09C; // weak
char x_BYTE_17E09D; // weak
char* x_DWORD_17E0A0[0x300]; // fix it -  weak
int x_DWORD_17E0A4[0x300]; // fix it -  weak
int x_DWORD_17E0A8[0x300]; // idb

Bit8u x_DWORD_17ECA0[4608]; // weak
int x_DWORD_17ECA4; // weak
int x_DWORD_17ECA8; // weak
int x_DWORD_17ECAC; // weak
char x_BYTE_17ECB0[1]; // fix it -  weak
char x_BYTE_17ECB1[4590]; // idb
int x_DWORD_17FEA0; // weak
int x_DWORD_17FEA4_mem_free; // weak
int x_DWORD_17FEA8_mem_used; // weak
//int x_DWORD_17FEAC; // weak//fix 
int x_DWORD_17FEB0; // weak
int x_DWORD_17FEC0; // weak
int x_DWORD_17FEC4; // weak
int x_DWORD_17FEC8; // weak
int x_DWORD_17FECC; // weak
int x_DWORD_17FF0C; // weak
int x_DWORD_17FF10; // weak
int x_DWORD_17FF14; // weak
__int16 x_WORD_17FF18; // weak
int x_DWORD_17FF20; // weak
int x_DWORD_17FF24; // weak
_UNKNOWN unk_17FF28; // weak
int x_DWORD_17FF38; // weak
int x_DWORD_17FF40; // weak
int x_DWORD_17FF44; // weak
__int16 x_WORD_17FF4A; // weak
__int16 x_WORD_17FF56; // weak
__int16 x_WORD_17FF58; // weak
__int16 x_WORD_17FF5A; // weak
int x_DWORD_180078; // weak
int x_DWORD_180084[1]; // fix it -  weak
int x_DWORD_180088[1]; // fix it -  weak
int x_DWORD_180214[101]; // idb
_UNKNOWN unk_1803A8; // weak
__int16 x_WORD_1803AB; // weak
_UNKNOWN unk_1803C0; // weak
__int16 x_WORD_1803C3; // weak
__int16 x_WORD_1803E8; // weak
__int16 x_WORD_1803EA; // weak
__int16 x_WORD_1803EC; // weak
char x_BYTE_1803EE[100]; // idb
_UNKNOWN unk_180452; // weak
__int16 x_WORD_180455; // weak
_UNKNOWN unk_180460; // weak
__int16 x_WORD_180463; // weak
_UNKNOWN unk_180470; // weak
char x_BYTE_180471; // weak
char x_BYTE_180472; // weak
int x_DWORD_180473; // weak
_UNKNOWN unk_180484; // weak
int x_DWORD_180486; // weak
char x_BYTE_18048A; // weak
_UNKNOWN unk_18048B; // weak
_UNKNOWN unk_180498; // weak
char x_BYTE_18049E; // weak
char x_BYTE_1804A1; // weak
Bit8u unk_1804B0[171]; // weak
__int16 x_WORD_1804BE; // weak
__int16 x_WORD_1804C0; // weak
__int16 x_WORD_1804C2; // weak
__int16 x_WORD_1804C4; // weak
__int16 x_WORD_1804C6; // weak
__int16 x_WORD_1804C8; // weak
__int16 x_WORD_1804CA; // weak
signed __int16 x_WORD_1804E3[6]; // idb
__int16 x_WORD_1804EF; // weak
__int16 x_WORD_1804F7; // weak
__int16 x_WORD_1804F9; // weak
__int16 x_WORD_1804FB; // weak
__int16 x_WORD_1804FD; // weak
__int16 x_WORD_1804FF; // weak
__int16 x_WORD_180501; // weak
__int16 x_WORD_180507; // weak
__int16 x_WORD_180509; // weak
__int16 x_WORD_18050B; // weak
__int16 x_WORD_18050D; // weak
char x_BYTE_180513; // weak
char x_BYTE_180514; // weak
int x_DWORD_180516; // weak
int x_DWORD_18051A; // weak
int x_DWORD_18051E; // weak
int x_DWORD_180522; // weak
int x_DWORD_180526; // weak
int x_DWORD_18052A; // weak
int x_DWORD_180532; // weak
__int16 x_WORD_180536; // weak
__int16 x_WORD_180538; // weak
int x_DWORD_18053A; // weak
__int16 x_WORD_18053E[4]; // idb
__int16 x_WORD_180546; // weak
__int16 x_WORD_180548; // weak
__int16 x_WORD_18054A; // weak
__int16 x_WORD_18054C; // weak
__int16 x_WORD_18054E; // weak
char x_BYTE_180550; // weak
char x_BYTE_180551; // weak
char x_BYTE_180552; // weak
char x_BYTE_180553; // weak
char x_BYTE_180554; // weak
char x_BYTE_180555; // weak
char x_BYTE_180556; // weak
char x_BYTE_180557; // weak
char x_BYTE_180558; // weak
char x_BYTE_180559; // weak
char x_BYTE_18055A; // weak
_UNKNOWN unk_180560; // weak
char x_BYTE_180584; // weak
char x_BYTE_180586; // weak
char x_BYTE_180587; // weak
char x_BYTE_180588; // weak
char x_BYTE_180589; // weak
_UNKNOWN unk_18058C; // weak
int x_DWORD_180590; // weak
int x_DWORD_180594; // weak
int x_DWORD_180598; // weak
int x_DWORD_18059C; // weak
int x_DWORD_1805A0; // weak
int x_DWORD_1805A4; // weak
int x_DWORD_1805A8; // weak
int x_DWORD_1805AC; // weak
int x_DWORD_1805B0; // weak
int x_DWORD_1805B4; // weak
int x_DWORD_1805B8; // weak
int x_DWORD_1805BC; // weak
__int16 x_WORD_1805C0; // weak
__int16 x_WORD_1805C2; // weak
__int16 x_WORD_1805C4_vio1; // weak
__int16 x_WORD_1805C6_vio2; // weak
__int16 x_WORD_1805C8; // weak
_UNKNOWN unk_1805CE; // weak
Bit32u x_DWORD_180624_resolution_y; // weak
//Bit8u x_DWORD_180628b_screen_buffer; // weak
Bit32u x_DWORD_18062C_resolution_x; // weak
int x_DWORD_180630_screen_height; // weak
int x_DWORD_180634_screen_width; // weak
int x_DWORD_180638; // weak
int x_DWORD_18063C_sprite_sizex; // weak
int x_DWORD_180640_help_screen_height; // weak
int x_DWORD_180644_map_resolution2_y; // weak
int x_DWORD_180648_map_resolution2_x; // weak
int x_DWORD_18064C_help_screen_width; // weak
int x_DWORD_180650_positiony; // weak
int x_DWORD_180654; // weak
int x_DWORD_180658; // weak
int x_DWORD_18065C; // weak
__int16 x_WORD_180660_VGA_type_resolution; // weak
__int16 x_WORD_180662_graphics_handle; // weak
Bit8s x_BYTE_180664[128]; // idb
char x_BYTE_18067C; // weak
char x_BYTE_18068E; // weak
char x_BYTE_180693; // weak
char x_BYTE_180696; // weak
char x_BYTE_18069A; // weak
char x_BYTE_18069C; // weak
char x_BYTE_1806E4; // weak
char x_BYTE_1806E5; // weak
_UNKNOWN unk_1806E6; // weak
Bit8s x_DWORD_1806E8_mousex;
Bit8s x_DWORD_1806E8_mousey;
_UNKNOWN unk_1806EC; // weak
__int16 x_WORD_1806EE; // weak
Bit8u* x_DWORD_1806F0; // weak
int x_DWORD_1806F4_mouse_byte_index2; // weak
Bit16s x_DWORD_1806F8_mousex; // weak
Bit16s x_DWORD_1806F8_mousey; // weak
Bit16s x_DWORD_1806FC_mouse_invx; // weak
Bit16s x_DWORD_1806FC_mouse_invy; // weak
Bit8u* x_DWORD_180700; // weak
int x_DWORD_180704_mouse_byte_index1; // weak
Bit8u* x_DWORD_180708; // weak
Bit8u* x_DWORD_18070C; // weak
Bit8u* x_DWORD_180714; // weak
Bit8u* x_DWORD_180718; // weak
int x_DWORD_180720; // weak
Bit16u x_WORD_18072C_cursor_sizex; // weak
Bit16u x_WORD_18072E_cursor_sizey; // weak
Bit8u* x_DWORD_180730_cursor_data; // weak
int x_DWORD_180734; // weak
__int16 x_WORD_180738; // weak
int x_DWORD_18073A; // weak
__int16 x_WORD_180744; // weak
__int16 x_WORD_180746; // weak
__int16 x_WORD_18074A; // weak
__int16 x_WORD_18074C; // weak
//_UNKNOWN unk_180750; // weak
HSAMPLE unk_180750_sound_buffer3[50]; // weak -351750 23 // delka 3fc, tj 2c struktur o delce 17 end x_DWORD_180B4C_end_sound_buffer3
AIL_INI unk_180A30; // weak
//char unk_180AB0[4096]; // weak //351ab0 unk_180A30->driver_name
__int16 x_WORD_180B30; // weak
HDIGDRIVER x_DWORD_180B48; // weak
//Bit8u* x_DWORD_180B4C_end_sound_buffer3; // weak
Bit32u x_DWORD_180B4C_end_sound_buffer3_endindex;
__int16 x_WORD_180B50; // weak
AIL_INI unk_180B60; // weak
char unk_180BE0[512]; // weak
HSEQUENCE x_DWORD_180C78; // weak
HMDIDRIVER x_DWORD_180C7C; // weak
int x_DWORD_180C80; // weak
char x_BYTE_180C84_drivertype; // weak
char x_BYTE_180C90[1]; // fix it -  weak
int x_DWORD_180CA0[1]; // fix it -  weak
_UNKNOWN unk_180CA4; // weak
char x_BYTE_1810A3[1]; // fix it -  weak
__int16 x_WORD_1811E4[1]; // fix it -  weak
char x_BYTE_181504[64]; // idb
Bit8u x_BYTE_181544_oldpalbuffer[768]; // idb
//_UNKNOWN unk_181844; // weak
Bit32u unk_181B42 = 0; // weak
//__int16 x_WORD_181B44; // weak
char unk_181B50[512]; // weak
int x_DWORD_181BE0; // weak
int x_DWORD_181BE4_number_of_disc; // weak
FILE* x_DWORD_181BF0_AIL_debugfile; // weak
int x_DWORD_181BF4 = 0; // weak//352bf4
int x_DWORD_181BF8; // weak
int x_DWORD_181BFC; // weak
int x_DWORD_181C00; // weak
int x_DWORD_181C04 = 0; // weak 352c04
int x_DWORD_181C08; // weak
int x_DWORD_181C0C; // weak
int x_DWORD_181C10; // weak
char x_DWORD_181C14[256]; // weak
Bit8u x_BYTE_181C2C; // weak
Bit8u* x_DWORD_181C40_vga_init_buffer; // weak
__int16 x_WORD_181C44; // weak
AIL_DRIVER* x_DWORD_181C50[16]; // idb
char x_BYTE_181C90[513]; // weak
IO_PARMS unk_181D90; // weak

int x_DWORD_181DAC[19]; // fix it -  weak
/*int x_DWORD_181DB0; // weak //1
int x_DWORD_181DB4; // weak //2
int x_DWORD_181DB8; // weak //3
int x_DWORD_181DBC; // weak //4
int x_DWORD_181DC0; // weak //5
int x_DWORD_181DC4; // weak//6
int x_DWORD_181DC8; // weak//7
int x_DWORD_181DCC; // weak//8
int x_DWORD_181DD0; // weak//9
//10
int x_DWORD_181DD8; // weak//11
int x_DWORD_181DDC; // weak//12
int x_DWORD_181DE0; // weak//13
int x_DWORD_181DE4; // weak//14
int x_DWORD_181DE8; // weak//15
int x_DWORD_181DEC; // weak//16
int x_DWORD_181DF0; // weak//17
int x_DWORD_181DF4; // weak//18*/
IO_PARMS unk_181DF8; // weak
HSAMPLE x_DWORD_181E10; // weak
FILE* x_DWORD_181E20; // weak
int x_DWORD_181E26; // weak
__int16 x_WORD_181E2A; // weak
int x_DWORD_181E2C; // weak
__int16 x_WORD_181E30; // weak
_UNKNOWN unk_181E80; // weak
int x_DWORD_181E8C; // weak
int x_DWORD_181E90; // weak
int x_DWORD_181E94; // weak
int x_DWORD_181E98; // weak
int x_DWORD_181E9C; // weak
int x_DWORD_181EA0; // weak
int x_DWORD_181EB0; // weak
int x_DWORD_181EB4; // weak
HSEQUENCE x_DWORD_181EB8; // weak
int x_DWORD_181EBC; // weak
int x_DWORD_181EC0; // weak
int x_DWORD_181EC4; // weak
int x_DWORD_181EC8; // weak
int x_DWORD_181ECC; // weak
int x_DWORD_181ED0; // weak
int x_DWORD_181ED4; // weak
int x_DWORD_181ED8; // weak
int x_DWORD_181EDC; // weak
_UNKNOWN unk_181EE0; // weak
signed int x_DWORD_182188[6]; // idb
signed int x_DWORD_1821A0[6]; // idb
signed int x_DWORD_1821B8[6]; // idb
signed int x_DWORD_1821D0[6]; // idb
signed int x_DWORD_1821E8[6]; // idb
_UNKNOWN unk_182200; // weak
_UNKNOWN unk_182204; // weak

char sub_7C200(Bit8u a1);

void dbgfprintf(FILE* file, const char *format, ...) {
	//void dbgfprintf(FILE* file,char* str) {
	fprintf(file, format);
	fprintf(file, "\n");
}

signed int sub_916F0_sound_proc24()
{
	int i; // [esp+4h] [ebp-14h]
	int j; // [esp+4h] [ebp-14h]
	int v3; // [esp+8h] [ebp-10h]
	struct tm *timeptr; // [esp+Ch] [ebp-Ch]
	time_t timer; // [esp+10h] [ebp-8h]
	int v6; // [esp+14h] [ebp-4h]

	sub_A0EEC_s_plus2();
	v6 = x_DWORD_181BFC;
	timer = x_DWORD_181C0C;
	timeptr = (struct tm *)x_DWORD_181C08;
	v3 = x_DWORD_181C10;
	sub_A0EF9_s_minus2();
	if (x_DWORD_181C04 == 1)
	{
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "[%.02u:%.02u:%.02u.%.02u] ", v6, timer, timeptr, v3);
	}
	else
	{
		for (i = 0; i < 0xE; i++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
	}
	for (j = 1; j < x_DWORD_181C04; j++)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
	return 1;
}

char* mygetenv(const char *a1);
void sub_91660(HMDIDRIVER user);
void sub_917D0()
{
	struct tm *timeptr; // eax
	char* v2; // eax
	//int v3; // eax
	//int v4; // eax
	time_t timer; // [esp+10h] [ebp-8h]
	char* v6; // [esp+14h] [ebp-4h]

	sub_915A0_sound_proc23();
	x_DWORD_181BF4 = 0;
	x_DWORD_181BF8 = 0;
	v6 = mygetenv("AIL_DEBUG");
	if (!v6)
	{
		sub_9EC30();
		return;
	}
	if (mygetenv("AIL_SYS_DEBUG"))
		x_DWORD_181BF8 = 1;
	x_DWORD_181BF0_AIL_debugfile = myopent(v6, (char*)"w+t"/*(char*)"haw+t"*/);
	if (!x_DWORD_181BF0_AIL_debugfile)
	{
		sub_9EC30;
		return;
	}
	/*if (isatty(*(_DWORD *)(x_DWORD_181BF0_AIL_debugfile + 16)))
		setbuf(x_DWORD_181BF0_AIL_debugfile, 0);*/ // fix
	time(&timer);
	timeptr = (struct tm *)localtime(&timer);
	v2 = asctime(timeptr);
	strcpy(x_DWORD_181C14, v2);
	x_BYTE_181C2C = 0;
	dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "-----------------------------------------------------------------");
	dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Audio Interface Library application usage script generated by AIL", "3.03");
	dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Start time: %s", x_DWORD_181C14);
	/*v3 = */dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "-----------------------------------------------------------------");
	sub_9EC30(/*v3*/);
	x_DWORD_181BFC = 0;
	x_DWORD_181C0C = 0;
	x_DWORD_181C08 = 0;
	x_DWORD_181C10 = 0;
	x_DWORD_181C00 = sub_A16AE_register_timer(sub_91660);
	sub_A1840_AIL_API_set_timer_frequency(x_DWORD_181C00, 100);
	/*v4 = */sub_A1768_start_timer(x_DWORD_181C00);
	x_DWORD_181BF4 = 1;
	x_DWORD_181C04 = 1;
	sub_916F0_sound_proc24(/*v4*/);
	x_DWORD_181C04 = 0;
	dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_startup()");
}

char* mygetenv(const char *a1)//27ae33
{
	//_dupenv_s(&v7, &sz, "MDMUSIC");
	char** v1; // ebx
	unsigned int v2; // kr04_4
	int v3; // edi
	char* v5; // esi

	v1 = (char**)dword_E4CC4;//2b5cc4
	if (dword_E4CC4 && a1)
	{
		v2 = strlen(a1) + 1;
		v3 = v2 - 1;
		while (1)
		{
			v5 = v1[0];
			if (!v1[0])
				break;
			if (!strnicmp(v5, a1, v3) && v5[v3] == 61)
				return &v5[v2];
			v1++;
		}
	}
	return 0;
}


//----- (00010010) --------------------------------------------------------
signed __int16 sub_10010()
{
	__int16 v0; // bx
	__int16 v1; // cx
	__int16 v2; // [esp+0h] [ebp-Ch]
	__int16 v3; // [esp+2h] [ebp-Ah]
	int v4; // [esp+4h] [ebp-8h]
	int v5; // [esp+8h] [ebp-4h]

	// fix if begin
	v1 = 0;
	v3 = 0;
	v4 = 0;
	// end

	v0 = 0;
	if (x_BYTE_D3F48)
		return 1;
	dos_getdrive(&v5);
	if (!dos_getdiskfree(v1, 0, v5, &v2) && v2 == -1 && !v3 && v4 == 134217729)
	{
		v0 = v4;
		x_BYTE_D3F48 = 1;
	}
	return v0;
}
// 8C1B2: using guessed type x_DWORD dos_getdrive(x_DWORD);
// 8C1E8: using guessed type x_DWORD dos_getdiskfree(x_DWORD, x_DWORD);
// D3F48: using guessed type char x_BYTE_D3F48;

//----- (00010080) --------------------------------------------------------
unsigned int sub_10080(int a1, int a2)
{
	unsigned int i; // edx
	//int v3; // eax
	int v4; // ecx
	int *v5; // ebx

	for (i = 1; i < 0x64 && (int)x_DWORD_E7EE8x[i].pointer != -1; i++)
		;
	//v3 = 3 * i;
	x_DWORD_E7EE0[i] = a1;
	x_DWORD_E7EE8x[i].pointer = (Bit8u*)a1;
	x_DWORD_E7EEC[i] = 0;
	v4 = (int)x_DWORD_E7EE8x[i].pointer;
	x_DWORD_E7EE4[i] = a2;
	v5 = (int*)x_DWORD_E9980x[v4].pointer;
	x_DWORD_E7EF0[i] = (int)v5;
	x_DWORD_E7EF4[i] = *v5;
	return i;
}
// E7EE0: using guessed type int x_DWORD_E7EE0[];
// E7EE4: using guessed type int x_DWORD_E7EE4[];
// E7EE8: using guessed type int x_DWORD_E7EE8[];
// E7EEC: using guessed type int x_DWORD_E7EEC[];
// E7EF0: using guessed type int x_DWORD_E7EF0[];
// E9980: using guessed type int x_DWORD_E9980;

//----- (00010100) --------------------------------------------------------
void sub_10100(int a1)
{
	x_DWORD_E7EE8x[a1].pointer = (Bit8u*)-1;
	//return 1;
}
// E7EE8: using guessed type int x_DWORD_E7EE8[];

//----- (00010130) --------------------------------------------------------
signed int sub_10130(int a1, x_DWORD *a2, x_DWORD *a3)
{
	int *v3; // eax
	char *v4; // edx
	int v5; // ecx
	int v6; // ebx
	int v7; // esi
	int v8; // edi
	int v9; // ebx
	signed int result; // eax

	v3 = &x_DWORD_E7EE0[6 * a1];
	v4 = (char *)v3[5];
	v5 = v3[4];
	*a2 = *v4;
	*a3 = v4[1];
	v6 = v3[3] + 1;
	v3[5] += 4;
	v3[3] = v6;
	if (*(unsigned __int16 *)(v5 + 4) > v6
		|| (v7 = v3[4], v3[3] = 0, v8 = v3[2], v3[4] = v7 + 6, ++v8, v9 = v3[1], v3[2] = v8, v8 <= v9))
	{
		result = 1;
	}
	else
	{
		result = 2;
	}
	return result;
}
// E7EE0: using guessed type int x_DWORD_E7EE0[];



//----- (000101C0) --------------------------------------------------------
void sub_101C0()//1f11c0
{
	Bit8u* v0; // esi
	//unsigned int v1; // edx
	//int v2; // eax
	//Bit8u* v3; // edx
	//unsigned __int8 result; // al
	//int v5; // ebx
	//__int16 i; // cx
	char v7; // ah
	char v8; // [esp+4h] [ebp-Ch]
	char v9; // [esp+8h] [ebp-8h]
	//__int16 v10; // [esp+Ch] [ebp-4h]

	//fix
	v0 = 0;
	//fix

	//v0 = x_DWORD_180628b_screen_buffer;
	//xasearchd.var32_end_buffer = (Bit8u*)malloc(100000);//fix it
	sub_53E60_readfile_and_decompress("data/search.dat", xasearchd.var28_begin_buffer);//2A1004,351628->3AA0A4
	//v1 = 1;
	for (Bit16u k = 1;k < 100;k++)
		//while ( v1 < 0x64 )
	{
		x_DWORD_E7EE8x[k].pointer = (Bit8u*)-1;
	}
	//v3/*edx*/ = dword_E9C30[0];//002bac30 //je to v 23c8d0,23cf50,265250,27B32d, nekde u 27b453
	//result = 0;
	Bit32u l = 0;
	for (Bit16u k = 0;k < 32;k++)
	{
		//v5 = 3 * result;
		x_DWORD_E9980x[k].pointer = &dword_E9C30[0][l];
		x_DWORD_E9980x[k].size = 0;
		for (Bit16u j = 0;j < 32;j++)
		{
			for (Bit16u i = 0; i < 32; i++)//1F1212
			{
				v7 = (*xasearchd.var28_begin_buffer)[i + 32 * j];
				if (k == v7)
				{
					if (!v7 && &dword_E9C30[0][l] == dword_E9C30[0])
					{
						v8 = i;
						v9 = j;
					}
					dword_E9C30[0][l] = i - v8;
					dword_E9C30[0][l + 1] = j - v9;
					dword_E9C30[0][l + 2] = k;
					l += 4;
					x_DWORD_E9980x[k].size++;
				}
			}
		}
	}
	/*
	38001a00 0400 48001a00 0c00 78001a00 1000 b8001a00 1400 08011a00 1c00
	*/
}
// E7EE8: using guessed type int x_DWORD_E7EE8[];
// E9980: using guessed type int x_DWORD_E9980;
// E9C30: using guessed type int x_DWORD_E9C30;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;

//----- (000102D0) --------------------------------------------------------
int sub_102D0(int a1, __int16 *a2, char a3)
{
	int v3; // esi
	int result; // eax
	int v5; // esi
	__int16 v6; // ax
	int v7; // edi
	int v8; // esi
	int(*v9)(); // eax
	unsigned __int16 v10; // ax
	__int16 v11; // ax
	__int16 v12; // si
	__int16 v13; // ax
	signed int v14; // ebx
	signed int v15; // ebx
	int v16; // [esp+0h] [ebp-Ch]
	__int16 v17; // [esp+4h] [ebp-8h]
	int v18; // [esp+8h] [ebp-4h]

	if (a3 & 2)
	{
		v3 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 12);
		if (a2[2] < v3 + (signed __int16)sub_10C40(a2))
			return 1;
		v5 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 10);
		if (a2[2] > (signed __int16)sub_10C40(a2) + v5)
			return 1;
	}
	if (a3 & 1)
	{
		v16 = *(x_DWORD *)a2;
		v17 = a2[2];
		v6 = *(x_WORD *)(a1 + 84);
		if (v6 <= *(x_WORD *)(a1 + 86))
			v6 = *(x_WORD *)(a1 + 86);
		v7 = v6;
		v8 = 0;
		while (v8 <= v7)
		{
			v18 = ~*(x_DWORD *)(*(x_DWORD *)(a1 + 160) + 20);
			v9 = sub_104D0((signed __int16 *)&v16);
			result = v18 & (unsigned int)v9;
			if (result)
				return result;
			if (x_BYTE_D41B6)
			{
				LOBYTE(v10) = BYTE1(v16);
				HIBYTE(v10) = HIBYTE(v16);
				if (x_BYTE_13B4E0[v10] & 8)
					return 1;
				if (sub_11E70(a1, (__int16 *)&v16))
					return 1;
			}
			v8 += 256;
			sub_57FA0((x_WORD*)&v16, *(x_WORD *)(a1 + 28), 0, 256);
		}
	}
	if (a3 & 4)
	{
		v11 = sub_58210((x_WORD *)(a1 + 76), a2);
		v12 = v11;
		v13 = sub_582F0(0, v11);
		if (v13 < 0)
		{
			if (v13 == -1)
			{
				v15 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 16);
				if ((unsigned __int16)sub_582B0(0, v12) > v15)
					return 1;
			}
		}
		else if (v13 > 0 && v13 == 1)
		{
			v14 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 18);
			if ((unsigned __int16)sub_582B0(0, v12) > v14)
				return 1;
		}
	}
	return 0;
}
// D41B6: using guessed type char x_BYTE_D41B6;

//----- (000104A0) --------------------------------------------------------
signed int sub_104A0(int a1)
{
	unsigned __int16 v1; // ax

	LOBYTE(v1) = *(x_BYTE *)(a1 + 1);
	HIBYTE(v1) = *(x_BYTE *)(a1 + 3);
	return 1 << (x_BYTE_13B4E0[v1] & 0xF);
}

//----- (000104D0) --------------------------------------------------------
int(*sub_104D0(signed __int16 *a1))()
{
	int v1; // eax

	v1 = *a1 >> 8;
	BYTE1(v1) = (unsigned __int16)a1[1] >> 8;
	return sub_10590(x_BYTE_10B4E0[(unsigned __int16)v1]);
}

//----- (00010590) --------------------------------------------------------
int(*sub_10590(char a1))()
{
	int(*result)(); // eax

	result = 0;
	switch (a1)
	{
	case 0:
		result = (int(*)())1;
		break;
	case 1:
		result = (int(*)())2;
		break;
	case 2:
		result = (int(*)())4;
		break;
	case 3:
		result = (int(*)())8;
		break;
	case 4:
		result = (int(*)())16;
		break;
	case 5:
		result = (int(*)())32;
		break;
	case 8:
		result = (int(*)())256;
		break;
	case 9:
		result = (int(*)())512;
		break;
	case 10:
		result = (int(*)())&unk_100000;
		break;
	case 11:
		result = (int(*)())0x200000;
		break;
	case 12:
		result = (int(*)())0x400000;
		break;
	case 13:
	case 14:
		return result;
	case 15:
	case 16:
	case 17:
	case 18:
	case 19:
	case 20:
	case 28:
	case 29:
	case 30:
	case 31:
	case 32:
	case 33:
	case 34:
		result = (int(*)())1024;
		break;
	case 21:
	case 22:
	case 24:
		result = (int(*)())&loc_20000;
		break;
	case 23:
		result = (int(*)())&loc_40000;
		break;
	case 25:
	case 27:
		result = (int(*)())((char *)&loc_7FFFF + 1);
		break;
	case 26:
		result = sub_10000;
		break;
	default:
		result = (int(*)())0x800000;
		break;
	}
	return result;
}
// 10000: using guessed type int sub_10000();

//----- (00010630) --------------------------------------------------------
bool sub_10630(x_WORD *a1, signed __int16 *a2, x_WORD *a3, signed __int16 *a4)
{
	return abs((signed __int16)(*a3 - *a1)) < a2[1] + a4[1]
		&& abs((signed __int16)(a3[1] - a1[1])) < a2[2] + a4[2]
		&& abs((signed __int16)a1[2] + *a2 - ((signed __int16)a3[2] + *a4)) < a2[3] + a4[3];
}

//----- (000106C0) --------------------------------------------------------
bool sub_106C0(int a1, int a2)
{
	return sub_10630((x_WORD *)(a1 + 76), (signed __int16 *)(a1 + 82), (x_WORD *)(a2 + 76), (signed __int16 *)(a2 + 82));
}

//----- (000106F0) --------------------------------------------------------
bool sub_106F0(x_WORD *a1, int a2, x_WORD *a3, int a4)
{
	return abs((signed __int16)(*a3 - *a1)) < *(signed __int16 *)(a2 + 2) + *(signed __int16 *)(a4 + 2)
		&& abs((signed __int16)(a3[1] - a1[1])) < *(signed __int16 *)(a2 + 4) + *(signed __int16 *)(a4 + 4);
}

//----- (00010750) --------------------------------------------------------
bool sub_10750(int a1, int a2)
{
	return sub_106F0((x_WORD *)(a1 + 76), a1 + 82, (x_WORD *)(a2 + 76), a2 + 82);
}

//----- (00010780) --------------------------------------------------------
int sub_10780(int a1)
{
	int v1; // edx
	int v2; // edi
	int i; // eax
	int v5; // ebx
	int v6; // [esp+0h] [ebp-10h]
	int v7; // [esp+4h] [ebp-Ch]
	int v8; // [esp+8h] [ebp-8h]
	int v9; // [esp+Ch] [ebp-4h]

	v8 = (*(unsigned __int16 *)(a1 + 76) + 128) >> 8;
	v1 = *(signed __int16 *)(a1 + 84) + 255;
	v9 = (*(unsigned __int16 *)(a1 + 78) + 128) >> 8;
	v2 = sub_10080(0, (v1 - (__CFSHL__(v1 >> 31, 8) + (v1 >> 31 << 8))) >> 8);
	if (v2)
	{
		while (sub_10130(v2, &v7, &v6) == 1)
		{
			for (i = x_WORD_15B4E0[((unsigned __int8)(v9 + v6) << 8) + (unsigned __int8)(v7 + v8)];
				;
				i = *(unsigned __int16 *)(v5 + 22))
			{
				v5 = x_DWORD_EA3E4[i];
				if (v5 == x_DWORD_EA3E4[0])
					break;
				if (*(x_BYTE *)(v5 + 12) & 8
					&& (*(char *)(a1 + 65) == -1
						|| *(x_BYTE *)(a1 + 65) == *(x_BYTE *)(v5 + 63) && *(char *)(a1 + 66) == -1
						|| *(x_BYTE *)(a1 + 65) == *(x_BYTE *)(v5 + 63) && *(x_BYTE *)(a1 + 66) == *(x_BYTE *)(v5 + 64))
					&& *(x_WORD *)(a1 + 26) != *(x_WORD *)(v5 + 26)
					&& sub_106C0(a1, v5))
				{
					sub_10100(v2);
					return v5;
				}
			}
		}
		sub_10100(v2);
	}
	return 0;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000108B0) --------------------------------------------------------
int sub_108B0(int a1)
{
	int v1; // edx
	int v2; // edi
	int i; // eax
	unsigned __int8 v4; // al
	unsigned __int8 v5; // al
	__int16 v6; // ax
	int v8; // ebx
	int v9; // [esp+0h] [ebp-14h]
	int v10; // [esp+4h] [ebp-10h]
	int v11; // [esp+8h] [ebp-Ch]
	int v12; // [esp+Ch] [ebp-8h]
	char v13; // [esp+10h] [ebp-4h]

	v11 = (*(unsigned __int16 *)(a1 + 76) + 128) >> 8;
	v1 = *(signed __int16 *)(a1 + 84) + 255;
	v12 = (*(unsigned __int16 *)(a1 + 78) + 128) >> 8;
	v2 = sub_10080(0, (v1 - (__CFSHL__(v1 >> 31, 8) + (v1 >> 31 << 8))) >> 8);
	if (v2)
	{
	LABEL_29:
		if (sub_10130(v2, &v10, &v9) != 1)
		{
			sub_10100(v2);
			return 0;
		}
		for (i = x_WORD_15B4E0[((unsigned __int8)(v12 + v9) << 8) + (unsigned __int8)(v10 + v11)];
			;
			i = *(unsigned __int16 *)(v8 + 22))
		{
			v8 = x_DWORD_EA3E4[i];
			if (v8 == x_DWORD_EA3E4[0])
				goto LABEL_29;
			if (*(x_BYTE *)(v8 + 12) & 8)
				break;
		LABEL_27:
			;
		}
		v4 = *(x_BYTE *)(v8 + 63);
		v13 = 0;
		if (v4 >= 5u)
		{
			if (v4 <= 5u)
			{
				if (*(x_BYTE *)(v8 + 64) != 22)
					goto LABEL_22;
			}
			else
			{
				if (v4 != 10)
					goto LABEL_22;
				v5 = *(x_BYTE *)(v8 + 64);
				if (v5 < 0x2Du)
				{
					if (v5 < 0x27u || v5 > 0x28u)
						goto LABEL_22;
				}
				else
				{
					if (v5 > 0x2Du)
					{
						if (v5 == 57 && *(unsigned __int16 *)(v8 + 40) != *(signed __int16 *)(a1 + 26) && sub_106C0(a1, v8))
						{
							sub_10100(v2);
							return v8;
						}
						goto LABEL_22;
					}
					if (x_BYTE_D93C2[4 * *(char *)(v8 + 70)] & 8)
						goto LABEL_22;
				}
			}
			v13 = 1;
		}
	LABEL_22:
		if (v13)
		{
			v6 = *(x_WORD *)(a1 + 26);
			if (v6 != *(x_WORD *)(v8 + 26) && v6 != *(unsigned __int16 *)(v8 + 148) && sub_106C0(a1, v8))
			{
				sub_10100(v2);
				return v8;
			}
		}
		goto LABEL_27;
	}
	return 0;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00010A50) --------------------------------------------------------
int sub_10A50(int a1)
{
	int v1; // edx
	int v2; // edi
	int i; // eax
	int v5; // ebx
	int v6; // [esp+0h] [ebp-10h]
	int v7; // [esp+4h] [ebp-Ch]
	int v8; // [esp+8h] [ebp-8h]
	int v9; // [esp+Ch] [ebp-4h]

	v8 = (*(unsigned __int16 *)(a1 + 76) + 128) >> 8;
	v1 = *(signed __int16 *)(a1 + 84) + 255;
	v9 = (*(unsigned __int16 *)(a1 + 78) + 128) >> 8;
	v2 = sub_10080(0, (v1 - (__CFSHL__(v1 >> 31, 8) + (v1 >> 31 << 8))) >> 8);
	if (v2)
	{
		while (sub_10130(v2, &v7, &v6) == 1)
		{
			for (i = x_WORD_15B4E0[((unsigned __int8)(v9 + v6) << 8) + (unsigned __int8)(v7 + v8)];
				;
				i = *(unsigned __int16 *)(v5 + 22))
			{
				v5 = x_DWORD_EA3E4[i];
				if (v5 == x_DWORD_EA3E4[0])
					break;
				if ((*(char *)(a1 + 65) == -1
					|| *(x_BYTE *)(a1 + 65) == *(x_BYTE *)(v5 + 63) && *(char *)(a1 + 66) == -1
					|| *(x_BYTE *)(a1 + 65) == *(x_BYTE *)(v5 + 63) && *(x_BYTE *)(a1 + 66) == *(x_BYTE *)(v5 + 64))
					&& *(x_WORD *)(a1 + 26) != *(x_WORD *)(v5 + 26)
					&& sub_106C0(a1, v5))
				{
					sub_10100(v2);
					return v5;
				}
			}
		}
		sub_10100(v2);
	}
	return 0;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00010B70) --------------------------------------------------------
signed int sub_10B70(unsigned __int16 *a1, char a2, char a3)
{
	__int16 v3; // si
	__int16 i; // di
	unsigned int j; // ebx
	int v8; // [esp+0h] [ebp-8h]
	int v9; // [esp+4h] [ebp-4h]

	v9 = (*a1 - 128) >> 8;
	v3 = 0;
	v8 = (a1[1] - 128) >> 8;
	while (v3 < 2)
	{
		for (i = 0; i < 2; i++)
		{
			for (j = x_DWORD_EA3E4[x_WORD_15B4E0[((unsigned __int8)(v8 + v3) << 8) + (unsigned __int8)(v9 + i)]];
				j > x_DWORD_EA3E4[0];
				j = x_DWORD_EA3E4[*(unsigned __int16 *)(j + 22)])
			{
				if (*(x_BYTE *)(j + 63) == a2 && a3 == *(x_BYTE *)(j + 64) && sub_583F0((x_WORD*)a1, (x_WORD *)(j + 76)) <= 0x80)
					return 1;
			}
		}
		++v3;
	}
	return 0;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00010C40) --------------------------------------------------------
int sub_10C40(__int16 *a1)
{
	return sub_B5C60(*a1, a1[1]);
}

//----- (00010C60) --------------------------------------------------------
int sub_10C60(__int16 *a1)
{
	return sub_B5D68(*a1, a1[1]);
}

//----- (00010C80) --------------------------------------------------------
int sub_10C80(int a1, unsigned __int8 a2, unsigned __int16 a3)
{
	int v3; // edi
	unsigned int ii; // esi
	unsigned int jj; // esi
	int v6; // ecx
	int ll; // eax
	int v8; // esi
	int result; // eax
	int n; // esi
	int v11; // eax
	int k; // esi
	int v13; // eax
	int v14; // [esp+0h] [ebp-5Ch]
	int v15; // [esp+4h] [ebp-58h]
	int v16; // [esp+8h] [ebp-54h]
	int v17; // [esp+Ch] [ebp-50h]
	int v18; // [esp+10h] [ebp-4Ch]
	int v19; // [esp+1Ch] [ebp-40h]
	int v20; // [esp+20h] [ebp-3Ch]
	int v21; // [esp+24h] [ebp-38h]
	int v22; // [esp+28h] [ebp-34h]
	int m; // [esp+2Ch] [ebp-30h]
	int v24; // [esp+30h] [ebp-2Ch]
	int j; // [esp+34h] [ebp-28h]
	int l; // [esp+38h] [ebp-24h]
	int v27; // [esp+3Ch] [ebp-20h]
	int v28; // [esp+40h] [ebp-1Ch]
	int i; // [esp+44h] [ebp-18h]
	int kk; // [esp+48h] [ebp-14h]
	int v31; // [esp+4Ch] [ebp-10h]
	signed int v32; // [esp+54h] [ebp-8h]

	v3 = 0;
	v32 = 1 << a2;
	if (a2)
	{
		if (a2 < 3u || a2 > 4u)
		{
			v17 = (*(unsigned __int16 *)(a1 + 76) + 128) >> 8;
			v14 = (*(unsigned __int16 *)(a1 + 78) + 128) >> 8;
			v27 = (*(signed __int16 *)(a1 + 84)
				+ 255
				- (__CFSHL__((*(signed __int16 *)(a1 + 84) + 255) >> 31, 8)
					+ ((*(signed __int16 *)(a1 + 84) + 255) >> 31 << 8))) >> 8;
			for (i = -v27; i <= v27; i++)
			{
				for (j = -v27; j <= v27; j++)
				{
					for (k = x_DWORD_EA3E4[x_WORD_15B4E0[(unsigned __int8)(j + v17) + ((unsigned __int8)(i + v14) << 8)]];
						k != x_DWORD_EA3E4[0];
						k = x_DWORD_EA3E4[*(unsigned __int16 *)(k + 22)])
					{
						if (*(x_WORD *)(a1 + 26) != *(x_WORD *)(k + 26)
							&& *(x_BYTE *)(k + 63)
							&& *(x_BYTE *)(k + 12) & 8
							&& (unsigned __int8)v32 & *(x_BYTE *)(k + 56)
							&& (*(char *)(a1 + 65) == -1
								|| *(x_BYTE *)(a1 + 65) == *(x_BYTE *)(k + 63) && *(char *)(a1 + 66) == -1
								|| *(x_BYTE *)(a1 + 65) == *(x_BYTE *)(k + 63) && *(x_BYTE *)(a1 + 66) == *(x_BYTE *)(k + 64))
							&& sub_106C0(a1, k))
						{
							v13 = k + 6 * a2;
							if (*(x_WORD *)(v13 + 98))
								*(x_DWORD *)(v13 + 94) += a3;
							else
								*(x_DWORD *)(v13 + 94) = a3;
							++v3;
							*(x_WORD *)(k + 6 * a2 + 98) = *(x_WORD *)(a1 + 26);
						}
					}
				}
			}
			return v3;
		}
		v18 = (*(unsigned __int16 *)(a1 + 76) + 128) >> 8;
		v15 = (*(unsigned __int16 *)(a1 + 78) + 128) >> 8;
		v28 = (*(signed __int16 *)(a1 + 84)
			+ 255
			- (__CFSHL__((*(signed __int16 *)(a1 + 84) + 255) >> 31, 8)
				+ ((*(signed __int16 *)(a1 + 84) + 255) >> 31 << 8))) >> 8;
		for (l = -v28; l <= v28; l++)
		{
			for (m = -v28; m <= v28; ++m)
			{
				for (n = x_DWORD_EA3E4[x_WORD_15B4E0[((unsigned __int8)(l + v15) << 8) + (unsigned __int8)(m + v18)]];
					n != x_DWORD_EA3E4[0];
					n = x_DWORD_EA3E4[*(unsigned __int16 *)(n + 22)])
				{
					if (*(x_WORD *)(a1 + 26) != *(x_WORD *)(n + 26) && *(x_BYTE *)(n + 63) == 3 && sub_106C0(a1, n))
					{
						v11 = n + 6 * a2;
						if (!*(x_WORD *)(v11 + 98))
						{
							*(x_DWORD *)(v11 + 94) = a3;
							++v3;
							*(x_WORD *)(v11 + 98) = *(x_WORD *)(a1 + 26);
						}
					}
				}
			}
		}
		result = v3;
	}
	else
	{
		for (ii = x_D41A0_BYTEARRAY_4[0x9677]; ii > x_DWORD_EA3E4[0]; ii = *(x_DWORD *)ii)
		{
			if (*(x_BYTE *)(ii + 64) == 2 && *(x_WORD *)(ii + 26) != *(x_WORD *)(a1 + 26) && sub_106C0(a1, ii))
			{
				if (*(x_WORD *)(ii + 98))
					*(x_DWORD *)(ii + 94) += a3;
				else
					*(x_DWORD *)(ii + 94) = a3;
				++v3;
				*(x_WORD *)(ii + 98) = *(x_WORD *)(a1 + 26);
			}
		}
		for (jj = x_D41A0_BYTEARRAY_4[0x967F0]; jj > x_DWORD_EA3E4[0]; jj = *(x_DWORD *)jj)
		{
			if (sub_10750(a1, jj))
			{
				v6 = 0;v21 = 0; //fix it
			  //v6 = *(unsigned __int8 *)(**filearray_2aa18c[24] + 6 * *(char *)(jj + 70) + 4); //fix it
			  //v21 = *(unsigned __int8 *)(**filearray_2aa18c[24] + 6 * *(char *)(jj + 70) + 5);//fix it
				if (x_WORD_180660_VGA_type_resolution == 1)
				{
					v6 >>= 1;
					v21 >>= 1;
				}
				v22 = (*(signed __int16 *)(a1 + 76) >> 8) - (v6 >> 1);
				v20 = (*(signed __int16 *)(a1 + 78) >> 8) - (v21 >> 1);
				if ((v20 + v22) % 2)
					++v22;
				/*if ( *(x_BYTE *)(*(x_DWORD *)(**filearray_2aa18c[24] + 6 * *(char *)(jj + 70))
							  + 2
							  * ((*(signed __int16 *)(a1 + 76) >> 8) - v22 + ((*(signed __int16 *)(a1 + 78) >> 8) - v20) * v6)) != -1 )*/ //fix it
				{
					if (*(x_WORD *)(jj + 98))
						*(x_DWORD *)(jj + 94) += a3;
					else
						*(x_DWORD *)(jj + 94) = a3;
					++v3;
					*(x_WORD *)(jj + 98) = *(x_WORD *)(a1 + 26);
				}
			}
		}
		v19 = (*(unsigned __int16 *)(a1 + 76)
			+ 128
			- (__CFSHL__((*(unsigned __int16 *)(a1 + 76) + 128) >> 31, 8)
				+ ((*(unsigned __int16 *)(a1 + 76) + 128) >> 31 << 8))) >> 8;
		v16 = (*(unsigned __int16 *)(a1 + 78)
			+ 128
			- (__CFSHL__((*(unsigned __int16 *)(a1 + 78) + 128) >> 31, 8)
				+ ((*(unsigned __int16 *)(a1 + 78) + 128) >> 31 << 8))) >> 8;
		v24 = (*(signed __int16 *)(a1 + 84)
			+ 255
			- (__CFSHL__((*(signed __int16 *)(a1 + 84) + 255) >> 31, 8)
				+ ((*(signed __int16 *)(a1 + 84) + 255) >> 31 << 8))) >> 8;
		v31 = -v24;
		if (-v24 > v24)
			return v3;
		do
		{
			for (kk = -v24; kk <= v24; ++kk)
			{
				for (ll = x_WORD_15B4E0[((unsigned __int8)(v16 + v31) << 8) + (unsigned __int8)(kk + v19)];
					;
					ll = *(unsigned __int16 *)(v8 + 22))
				{
					v8 = x_DWORD_EA3E4[ll];
					if (v8 == x_DWORD_EA3E4[0])
						break;
					if (*(x_WORD *)(a1 + 26) != *(x_WORD *)(v8 + 26)
						&& (*(x_BYTE *)(v8 + 63) != 3 || *(x_BYTE *)(v8 + 64) != 2)
						&& (unsigned __int8)v32 & *(x_BYTE *)(v8 + 56)
						&& *(x_BYTE *)(v8 + 12) & 8
						&& (*(x_BYTE *)(v8 + 63) != 10 || *(x_BYTE *)(v8 + 64) != 45)
						&& sub_106C0(a1, v8)
						&& (*(char *)(a1 + 65) == -1
							|| *(x_BYTE *)(a1 + 65) == *(x_BYTE *)(v8 + 63) && *(char *)(a1 + 66) == -1
							|| *(x_BYTE *)(a1 + 65) == *(x_BYTE *)(v8 + 63) && *(x_BYTE *)(a1 + 66) == *(x_BYTE *)(v8 + 64)))
					{
						if (*(x_WORD *)(v8 + 98))
							*(x_DWORD *)(v8 + 94) += a3;
						else
							*(x_DWORD *)(v8 + 94) = a3;
						++v3;
						*(x_WORD *)(v8 + 98) = *(x_WORD *)(a1 + 26);
					}
				}
			}
			++v31;
		} while (v31 <= v24);
		result = v3;
	}
	return result;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3BC: using guessed type int x_DWORD_EA3BC;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (000112D0) --------------------------------------------------------
int sub_112D0(int a1, unsigned __int16 a2)
{
	int v2; // eax
	int v3; // edi
	int result; // eax
	int v5; // ebx
	int v6; // [esp+0h] [ebp-10h]
	int v7; // [esp+4h] [ebp-Ch]
	int i; // [esp+8h] [ebp-8h]
	int j; // [esp+Ch] [ebp-4h]

	v6 = (*(unsigned __int16 *)(a1 + 76) + 128) >> 8;
	v7 = (*(unsigned __int16 *)(a1 + 78) + 128) >> 8;
	v2 = (*(signed __int16 *)(a1 + 84)
		+ 255
		- (__CFSHL__((*(signed __int16 *)(a1 + 84) + 255) >> 31, 8)
			+ ((*(signed __int16 *)(a1 + 84) + 255) >> 31 << 8))) >> 8;
	v3 = v2;
	result = -v2;
	for (i = result; v3 >= i; i++)
	{
		result = -v3;
		for (j = -v3; v3 >= j; j++)
		{
			for (result = x_WORD_15B4E0[((unsigned __int8)(v7 + i) << 8) + (unsigned __int8)(j + v6)];
				;
				result = *(unsigned __int16 *)(v5 + 22))
			{
				v5 = x_DWORD_EA3E4[result];
				if (v5 == x_DWORD_EA3E4[0])
					break;
				if (*(x_WORD *)(a1 + 26) != *(x_WORD *)(v5 + 26)
					&& *(x_BYTE *)(v5 + 63)
					&& *(x_BYTE *)(v5 + 12) & 8
					&& *(x_BYTE *)(v5 + 56) & 2
					&& (*(char *)(a1 + 65) == -1
						|| *(x_BYTE *)(a1 + 65) == *(x_BYTE *)(v5 + 63) && *(char *)(a1 + 66) == -1
						|| *(x_BYTE *)(a1 + 65) == *(x_BYTE *)(v5 + 63) && *(x_BYTE *)(a1 + 66) == *(x_BYTE *)(v5 + 64))
					&& sub_106C0(a1, v5))
				{
					*(x_WORD *)(v5 + 104) = *(x_WORD *)(a1 + 26);
					*(x_DWORD *)(v5 + 100) = a2;
				}
			}
		}
	}
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00011400) --------------------------------------------------------
char sub_11400(int a1, char a2, unsigned __int16 a3)
{
	signed int v3; // eax
	bool v4; // zf
	unsigned int i; // ebx
	int v6; // eax
	int v7; // edi
	int l; // ebx
	int v9; // ebx
	int v11; // [esp+0h] [ebp-18h]
	int v12; // [esp+4h] [ebp-14h]
	signed int j; // [esp+8h] [ebp-10h]
	int k; // [esp+Ch] [ebp-Ch]

	v3 = 1 << a2;
	if (!a2)
	{
		v4 = (*(x_BYTE *)(a1 + 14) & 1) == 0;
		for (i = x_D41A0_BYTEARRAY_4[0x9677]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
		{
			if (*(x_BYTE *)(i + 64) == 2 && *(x_WORD *)(i + 26) != *(x_WORD *)(a1 + 26) && sub_106C0(a1, i))
			{
				if (*(x_WORD *)(i + 98))
					*(x_DWORD *)(i + 94) += a3;
				else
					*(x_DWORD *)(i + 94) = a3;
				*(x_WORD *)(i + 98) = *(x_WORD *)(a1 + 26);
			}
		}
		v11 = (*(unsigned __int16 *)(a1 + 76)
			+ 128
			- (__CFSHL__((*(unsigned __int16 *)(a1 + 76) + 128) >> 31, 8)
				+ ((*(unsigned __int16 *)(a1 + 76) + 128) >> 31 << 8))) >> 8;
		v12 = (*(unsigned __int16 *)(a1 + 78)
			+ 128
			- (__CFSHL__((*(unsigned __int16 *)(a1 + 78) + 128) >> 31, 8)
				+ ((*(unsigned __int16 *)(a1 + 78) + 128) >> 31 << 8))) >> 8;
		v6 = (*(signed __int16 *)(a1 + 84)
			+ 255
			- (__CFSHL__((*(signed __int16 *)(a1 + 84) + 255) >> 31, 8)
				+ ((*(signed __int16 *)(a1 + 84) + 255) >> 31 << 8))) >> 8;
		v7 = v6;
		v3 = -v6;
		for (j = v3; v7 >= j; j++)
		{
			v3 = -v7;
			for (k = -v7; v7 >= k; k++)
			{
				v3 = ((unsigned __int8)(v12 + j) << 8) + (unsigned __int8)(k + v11);
				for (l = x_WORD_15B4E0[v3]; ; l = *(unsigned __int16 *)(v9 + 22))
				{
					v9 = x_DWORD_EA3E4[l];
					if (v9 == x_DWORD_EA3E4[0])
						break;
					LOWORD(v3) = *(x_WORD *)(a1 + 26);
					if ((x_WORD)v3 != *(x_WORD *)(v9 + 26))
					{
						v3 = sub_106C0(a1, v9);
						if (v3)
						{
							LOBYTE(v3) = 1 << a2;
							if ((unsigned __int16)(1 << a2) & *(unsigned __int8 *)(v9 + 56))
							{
								if (*(x_BYTE *)(v9 + 12) & 8 && (*(x_BYTE *)(v9 + 63) != 3 || *(x_BYTE *)(v9 + 64) != 2))
								{
									if (*(char *)(a1 + 65) == -1
										|| *(x_BYTE *)(a1 + 65) == *(x_BYTE *)(v9 + 63) && *(char *)(a1 + 66) == -1
										|| (LOBYTE(v3) = *(x_BYTE *)(a1 + 65), (x_BYTE)v3 == *(x_BYTE *)(v9 + 63))
										&& (LOBYTE(v3) = *(x_BYTE *)(a1 + 66), (x_BYTE)v3 == *(x_BYTE *)(v9 + 64)))
									{
										if (*(x_BYTE *)(v9 + 63) != 2 || *(x_BYTE *)(v9 + 64))
										{
											if (*(x_WORD *)(v9 + 98))
												*(x_DWORD *)(v9 + 94) += a3;
											else
												*(x_DWORD *)(v9 + 94) = a3;
										}
										else if (*(x_WORD *)(v9 + 98))
										{
											*(x_DWORD *)(v9 + 94) += a3 / 10;
										}
										else
										{
											*(x_DWORD *)(v9 + 94) = a3 / 10;
										}
										LOBYTE(v3) = 0;
										*(x_WORD *)(v9 + 98) = *(x_WORD *)(a1 + 26);
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return v3;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000116A0) --------------------------------------------------------
int sub_116A0(int a1, char a2, unsigned __int16 a3)
{
	int v3; // edi
	unsigned int i; // ebx
	int l; // ebx
	int v7; // [esp+0h] [ebp-1Ch]
	int v8; // [esp+4h] [ebp-18h]
	int k; // [esp+8h] [ebp-14h]
	int v10; // [esp+Ch] [ebp-10h]
	int j; // [esp+10h] [ebp-Ch]

	v3 = 0;
	if (!a2)
	{
		for (i = x_D41A0_BYTEARRAY_4[0x9677]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
		{
			if (*(x_BYTE *)(i + 64) == 2 && sub_106C0(a1, i))
			{
				*(x_WORD *)(i + 48) = 30;
				if (*(x_WORD *)(i + 26) != *(x_WORD *)(a1 + 26))
				{
					if (*(x_WORD *)(i + 98))
						*(x_DWORD *)(i + 94) += a3;
					else
						*(x_DWORD *)(i + 94) = a3;
					++v3;
					*(x_WORD *)(i + 98) = *(x_WORD *)(a1 + 26);
				}
			}
		}
		v7 = (*(unsigned __int16 *)(a1 + 76)
			+ 128
			- (__CFSHL__((*(unsigned __int16 *)(a1 + 76) + 128) >> 31, 8)
				+ ((*(unsigned __int16 *)(a1 + 76) + 128) >> 31 << 8))) >> 8;
		v8 = (*(unsigned __int16 *)(a1 + 78)
			+ 128
			- (__CFSHL__((*(unsigned __int16 *)(a1 + 78) + 128) >> 31, 8)
				+ ((*(unsigned __int16 *)(a1 + 78) + 128) >> 31 << 8))) >> 8;
		v10 = (*(signed __int16 *)(a1 + 84)
			+ 255
			- (__CFSHL__((*(signed __int16 *)(a1 + 84) + 255) >> 31, 8)
				+ ((*(signed __int16 *)(a1 + 84) + 255) >> 31 << 8))) >> 8;
		for (j = -v10; j <= v10; j++)
		{
			for (k = -v10; k <= v10; k++)
			{
				for (l = x_DWORD_EA3E4[x_WORD_15B4E0[((unsigned __int8)(v8 + j) << 8) + (unsigned __int8)(k + v7)]];
					l != x_DWORD_EA3E4[0];
					l = x_DWORD_EA3E4[*(unsigned __int16 *)(l + 22)])
				{
					if (*(x_WORD *)(a1 + 26) != *(x_WORD *)(l + 26)
						&& sub_106C0(a1, l)
						&& (unsigned __int16)(1 << a2) & *(unsigned __int8 *)(l + 56)
						&& *(x_BYTE *)(l + 12) & 8
						&& (*(x_BYTE *)(l + 63) != 3 || *(x_BYTE *)(l + 64) != 2)
						&& (*(char *)(a1 + 65) == -1
							|| *(x_BYTE *)(a1 + 65) == *(x_BYTE *)(l + 63) && *(char *)(a1 + 66) == -1
							|| *(x_BYTE *)(a1 + 65) == *(x_BYTE *)(l + 63) && *(x_BYTE *)(a1 + 66) == *(x_BYTE *)(l + 64)))
					{
						if (*(x_WORD *)(l + 98))
							*(x_DWORD *)(l + 94) += a3;
						else
							*(x_DWORD *)(l + 94) = a3;
						++v3;
						*(x_WORD *)(l + 98) = *(x_WORD *)(a1 + 26);
					}
				}
			}
		}
	}
	return v3;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00011900) --------------------------------------------------------
int sub_11900(int a1, int a2, unsigned __int8 a3, unsigned __int16 a4)
{
	int v4; // eax
	int result; // eax

	v4 = a2 + 6 * a3;
	if (*(x_WORD *)(v4 + 98))
		*(x_DWORD *)(v4 + 94) = a4;
	else
		*(x_DWORD *)(v4 + 94) += a4;
	result = 3 * a3;
	*(x_WORD *)(a2 + 6 * a3 + 98) = *(x_WORD *)(a1 + 26);
	return result;
}

//----- (00011960) --------------------------------------------------------
unsigned int sub_11960(x_WORD *a1)
{
	__int16 v1; // di
	unsigned int v2; // ebx
	__int16 v4; // [esp+0h] [ebp-Ch]
	int v5; // [esp+4h] [ebp-8h]
	int v6; // [esp+8h] [ebp-4h]

	sub_49EC0(a1, a1[8] + 1);
	v6 = (signed __int16)a1[42];
	v1 = a1[38];
	v5 = (signed __int16)a1[43];
	v2 = x_D41A0_BYTEARRAY_4[0x967F];
	v4 = a1[39];
	while (v2 > x_DWORD_EA3E4[0])
	{
		if (abs((signed __int16)(*(x_WORD *)(v2 + 76) - v1)) <= *(signed __int16 *)(v2 + 84) + v6
			&& abs((signed __int16)(*(x_WORD *)(v2 + 78) - v4)) <= *(signed __int16 *)(v2 + 86) + v5)
		{
			*(x_DWORD *)(v2 + 8) = -1;
			*(x_BYTE *)(v2 + 61) = 0;
		}
		v2 = *(x_DWORD *)v2;
	}
	return sub_49EC0(a1, a1[8]);
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00011A10) --------------------------------------------------------
char sub_11A10(x_WORD *a1)
{
	unsigned int i; // ebx
	unsigned __int16 v3; // bx
	__int16 v4; // di
	__int16 v5; // di
	unsigned __int16 v6; // bx
	__int16 v7; // di
	unsigned __int16 v8; // bx
	int v9; // eax
	__int16 v10; // di
	unsigned __int16 v11; // bx
	__int16 v12; // [esp+0h] [ebp-24h]
	int v13; // [esp+4h] [ebp-20h]
	__int16 l; // [esp+8h] [ebp-1Ch]
	__int16 j; // [esp+Ch] [ebp-18h]
	__int16 k; // [esp+10h] [ebp-14h]
	int v17; // [esp+14h] [ebp-10h]
	__int16 v18; // [esp+14h] [ebp-10h]
	__int16 v19; // [esp+18h] [ebp-Ch]
	unsigned __int16 v20; // [esp+1Ch] [ebp-8h]
	__int16 v21; // [esp+20h] [ebp-4h]
	__int16 v22; // [esp+20h] [ebp-4h]

	v18 = a1[42] >> 8;
	v21 = a1[43] >> 8;
	sub_49EC0(a1, a1[8] + 1);
	for (i = x_D41A0_BYTEARRAY_4[0x9677]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
	{
		if (*(x_BYTE *)(i + 64) == 2 && (x_WORD *)i != a1 && sub_106C0(i, (int)a1))
		{
			sub_49EC0(a1, a1[8]);
			return 0;
		}
	}
	v19 = a1[42] >> 8;
	v12 = a1[43] >> 8;
	LOBYTE(v20) = ((unsigned __int16)(a1[38] + 128) >> 8) - v19;
	HIBYTE(v20) = ((unsigned __int16)(a1[39] + 128) >> 8) - v12;
	LOWORD(v17) = v19 - v18;
	v3 = v20;
	v22 = v12 - v21;
	v4 = v22;
	while (v4)
	{
		for (j = 2 * v19; j; j--)
		{
			if (!sub_11C80(v3))
			{
				sub_49EC0(a1, a1[8]);
				return 0;
			}
			LOBYTE(v3) = v3 + 1;
		}
		--v4;
		v3 = __PAIR__(HIBYTE(v3), (unsigned __int8)v20) + 256;
	}
	LOBYTE(v6) = v20;
	v5 = v22;
	HIBYTE(v6) = 2 * v12 + HIBYTE(v20) - v22;
	while (v5)
	{
		for (k = 2 * v19; k; k--)
		{
			if (!sub_11C80(v6))
			{
				sub_49EC0(a1, a1[8]);
				return 0;
			}
			LOBYTE(v6) = v6 + 1;
		}
		--v5;
		v6 = __PAIR__(HIBYTE(v6), (unsigned __int8)v20) + 256;
	}
	LOBYTE(v8) = v20;
	v7 = v22;
	HIBYTE(v8) = v22 + HIBYTE(v20);
	while (v7)
	{
		v9 = v17;
		while (1)
		{
			v13 = v9;
			if (!(x_WORD)v9)
				break;
			if (!sub_11C80(v8))
			{
				sub_49EC0(a1, a1[8]);
				return 0;
			}
			v9 = v13 - 1;
			LOBYTE(v8) = v8 + 1;
		}
		--v7;
		v8 = __PAIR__(HIBYTE(v8), (unsigned __int8)v20) + 256;
	}
	LOBYTE(v11) = v19 + v20 - v17;
	v10 = v22;
	HIBYTE(v11) = v22 + HIBYTE(v20);
	while (v10)
	{
		for (l = v17; l; l--)
		{
			if (!sub_11C80(v11))
			{
				sub_49EC0(a1, a1[8]);
				return 0;
			}
			LOBYTE(v11) = v11 + 1;
		}
		--v10;
		v11 = __PAIR__(HIBYTE(v11), (unsigned __int8)v20) + 256;
	}
	sub_49EC0(a1, a1[8]);
	return 1;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00011C80) --------------------------------------------------------
char sub_11C80(unsigned __int16 a1)
{
	char result; // al
	char v2; // ah

	result = 1;
	v2 = x_BYTE_13B4E0[a1];
	if (v2 < 0 || x_BYTE_D41B6 && v2 & 8)
		result = 0;
	return result;
}
// D41B6: using guessed type char x_BYTE_D41B6;

//----- (00011CB0) --------------------------------------------------------
bool sub_11CB0(__int16 *a1)
{
	__int16 v1; // cx
	unsigned int v2; // ebx
	unsigned int i; // ebx
	signed __int16 v4; // di
	unsigned __int16 v5; // bx
	signed __int16 j; // si
	__int16 v8; // [esp+8h] [ebp-10h]
	unsigned __int16 v9; // [esp+Ch] [ebp-Ch]
	char v10; // [esp+14h] [ebp-4h]

	v1 = a1[1];
	v10 = 0;
	v2 = x_D41A0_BYTEARRAY_4[0x9677];
	v8 = *a1;
	while (!v10 && v2 > x_DWORD_EA3E4[0])
	{
		if (*(x_BYTE *)(v2 + 64) == 2
			&& abs((signed __int16)(*(x_WORD *)(v2 + 76) - v8)) <= *(signed __int16 *)(v2 + 84) + 2560
			&& abs((signed __int16)(*(x_WORD *)(v2 + 78) - v1)) <= *(signed __int16 *)(v2 + 86) + 2560)
		{
			v10 = 1;
		}
		v2 = *(x_DWORD *)v2;
	}
	if (!v10)
	{
		for (i = x_D41A0_BYTEARRAY_4[0x967F]; !v10 && i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
		{
			if (abs((signed __int16)(*(x_WORD *)(i + 76) - v8)) <= *(signed __int16 *)(i + 84) + 2560
				&& abs((signed __int16)(*(x_WORD *)(i + 78) - v1)) <= *(signed __int16 *)(i + 86) + 2560)
			{
				v10 = 1;
			}
		}
	}
	if (!v10)
	{
		LOBYTE(v9) = ((unsigned __int16)*a1 >> 8) - 8;
		HIBYTE(v9) = ((unsigned __int16)a1[1] >> 8) - 8;
		v4 = 8;
		v5 = v9;
		while (v4 && !v10)
		{
			for (j = 8; j && !v10; j--)
			{
				if (!sub_11C80(v5))
					v10 = 1;
				LOBYTE(v5) = v5 + 1;
			}
			--v4;
			v5 = __PAIR__(HIBYTE(v5), (unsigned __int8)v9) + 256;
		}
	}
	return v10 == 0;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00011E20) --------------------------------------------------------
bool sub_11E20(int a1, __int16 *a2)
{
	int v2; // ebx
	int v3; // ebx

	v2 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 12);
	v3 = (signed __int16)sub_10C40(a2) + v2 + *(signed __int16 *)(a1 + 88);
	return v3 > (signed __int16)sub_10C60(a2) - 384;
}

//----- (00011E70) --------------------------------------------------------
bool sub_11E70(int a1, __int16 *a2)
{
	int v2; // ebx
	int v3; // ebx

	v2 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 12);
	v3 = *(signed __int16 *)(a1 + 88) + (signed __int16)sub_10C40(a2) + v2;
	return v3 > (signed __int16)sub_10C60(a2);
}

//----- (00011EE0) --------------------------------------------------------
signed int sub_11EE0(Bit8u* a1)
{
	char *v1; // ST00_4
	signed __int16 v2; // ax
	int v3; // esi
	signed int result; // eax
	int v5; // edx
	int v6; // edi
	char v7; // ST14_1
	int v8; // edx
	int v9; // edx
	int v10; // edx
	int v11; // edx
	int v12; // edx
	int v13; // ecx
	__int16 v14; // di
	int v15; // edx
	int v16; // edx
	int v17; // ecx

	v1 = (char*)&x_D41A0_BYTEARRAY_0[(int)&loc_365F2 + 2];
	x_D41A0_BYTEARRAY_0[(int)&loc_365F2 + 4] = 0;
	memset(v1, 0, 88);
	v2 = 10;
	v3 = (int)x_D41A0_BYTEARRAY_0;
	while (v2 > 0 && !(*(x_BYTE *)(a1 + 8 * v2 + 26028) & 0xF))
		--v2;
	x_D41A0_BYTEARRAY_0[(int)&loc_365F2 + 4] = v2;
	for (result = 1; (signed __int16)result <= *((unsigned __int8 *)&loc_36DFC + v3 + 4); ++result)
	{
		v5 = 8 * (signed __int16)result;
		v6 = (int)a1 + v5;
		v7 = *(x_BYTE *)(a1 + v5 + 26028) & 0xF;
		v8 = v3 + v5;
		*((x_BYTE *)&loc_365F2 + v8 + 2) = v7;
		if (v7)
		{
			if (*(x_BYTE *)(v6 + 26028) < 0)
				*(x_BYTE *)(v8 + 222709) |= 1u;
			v9 = 8 * (signed __int16)result;
			if (*(x_BYTE *)(v9 + a1 + 26028) & 0x40)
				*(x_BYTE *)(v3 + v9 + 222709) |= 2u;
			v10 = 8 * (signed __int16)result;
			if (*(x_BYTE *)(v10 + a1 + 26028) & 0x10)
				*(x_BYTE *)(v3 + v10 + 222709) |= 0x20u;
			v11 = 8 * (signed __int16)result;
			if (*(x_BYTE *)(v11 + a1 + 26028) & 0x20)
				*(x_BYTE *)(v3 + v11 + 222709) |= 0x40u;
			switch (*((x_BYTE *)&loc_365F2 + 8 * (signed __int16)result + v3 + 2))
			{
			case 1:
			case 2:
				v12 = 8 * (signed __int16)result;
				v13 = (int)a1 + v12;
				v14 = *(x_WORD *)(a1 + v12 + 26032);
				v15 = v3 + v12;
				*(x_WORD *)((char *)sub_365F8 + v15) = v14 << 8;
				*(x_WORD *)((char *)sub_365F8 + v15 + 2) = *(x_WORD *)(v13 + 26034) << 8;
				break;
			case 3:
			case 4:
			case 5:
			case 8:
			case 9:
				v16 = 8 * (signed __int16)result;
				v17 = v3 + v16;
				LOBYTE(v16) = *(x_BYTE *)(v3 + v16 + 222709);
				*(x_DWORD *)((char *)sub_365F8 + v17) = 0;
				if (v16 & 2)
					*(x_WORD *)((char *)sub_365F8 + v17) = *(x_WORD *)((char *)&loc_3030E
						+ 20 * *(unsigned __int16 *)((char *)&loc_36479 + v17 + 5)
						+ v3
						+ 5);
				break;
			case 6:
			case 7:
				*(x_DWORD *)((char *)sub_365F8 + 8 * (signed __int16)result + v3) = *(x_DWORD *)(a1
					+ 8 * (signed __int16)result
					+ 26032);
				break;
			default:
				break;
			}
			*(x_BYTE *)(v3 + 8 * (signed __int16)result + 222710) = *(x_BYTE *)(8 * (signed __int16)result + a1 + 26029);
		}
	}
	x_D41A0_BYTEARRAY_0 = (Bit8u*)v3;
	return result;
}
// 365F8: using guessed type int sub_365F8();
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00012100) --------------------------------------------------------
__int16 sub_12100(int a1, int a2, char a3)
{
	signed __int16 v3; // bx
	unsigned __int8 v4; // cl
	char *v5; // esi
	signed __int16 v6; // bx
	char *v7; // edx
	signed __int16 v8; // bx
	char *i; // ecx
	__int16 result; // ax

	v3 = 1;
	v4 = 0;
	v5 = (char *)sub_365F8 + x_D41A0_BYTEARRAY_0[4];
	while (v3 <= *((unsigned __int8 *)&loc_36DFC + x_D41A0_BYTEARRAY_0[4]) && !v4)
	{
		if (*v5
			&& !(v5[1] & 1)
			&& (a1 - ((signed int)&loc_3030E + x_D41A0_BYTEARRAY_0[3])) / 20 == *(unsigned __int16 *)((char *)&loc_36479
				+ 8 * v3
				+ x_D41A0_BYTEARRAY_0[3]))
		{
			v4 = v3;
		}
		++v3;
		v5 += 8;
	}
	if (!v4)
	{
		v6 = 1;
		v7 = (char *)sub_365F8 + x_D41A0_BYTEARRAY_0[4];
		while (v6 <= *((unsigned __int8 *)&loc_36DFC + x_D41A0_BYTEARRAY_0[4]) && !v4)
		{
			if (*v7
				&& v7[1] & 1
				&& *(x_WORD *)((char *)&loc_3030E
					+ 20 * *(unsigned __int16 *)((char *)&loc_36479 + 8 * v6 + x_D41A0_BYTEARRAY_0[3])
					+ x_D41A0_BYTEARRAY_0[5]) == *(x_WORD *)(a1 + 2))
			{
				v4 = v6;
			}
			++v6;
			v7 += 8;
		}
	}
	if (v4)
	{
		if (a3)
			*(x_WORD *)(a2 + 74) = v4;
		else
			sub_12330(a2, v4);
	}
	v8 = 1;
	for (i = (char *)sub_365F8 + x_D41A0_BYTEARRAY_0[4]; ; i += 8)
	{
		result = *((unsigned __int8 *)&loc_36DFC + x_D41A0_BYTEARRAY_0[4]);
		if (v8 > (unsigned __int8)result)
			break;
		if (*i)
		{
			switch (*i)
			{
			case 3:
			case 4:
			case 5:
			case 8:
			case 9:
				if (!(i[1] & 2)
					&& *(unsigned __int16 *)((char *)&loc_36479 + 8 * v8 + x_D41A0_BYTEARRAY_0[5]) == (a1
						- ((signed int)&loc_3030E
							+ x_D41A0_BYTEARRAY_0[3]))
					/ 20)
				{
					*((x_DWORD *)i + 1) = a2;
					i[1] &= 0xFBu;
				}
				break;
			default:
				break;
			}
		}
		++v8;
	}
	return result;
}
// 365F8: using guessed type int sub_365F8();
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (000122A0) --------------------------------------------------------
int sub_122A0(int a1)
{
	__int16 v1; // bx
	int result; // eax

	v1 = *(x_WORD *)(a1 + 74);
	if (v1)
		result = sub_12330(a1, v1);
	return result;
}

//----- (000122C0) --------------------------------------------------------
char *sub_122C0(__int16 a1)
{
	signed __int16 v1; // dx
	char *result; // eax

	v1 = 1;
	result = (char *)sub_365F8 + x_D41A0_BYTEARRAY_0[4];
	while (v1 <= *((unsigned __int8 *)&loc_36DFC + x_D41A0_BYTEARRAY_0[4]))
	{
		if (*result == 7 && a1 == *((x_WORD *)result + 2))
			result[1] |= 0x18u;
		++v1;
		result += 8;
	}
	return result;
}
// 365F8: using guessed type int sub_365F8();
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00012330) --------------------------------------------------------
int sub_12330(int a1, __int16 a2)
{
	int result; // eax
	char v3; // dl
	int v4; // ecx
	int v5; // ebx
	char v6; // dh
	unsigned __int8 v7; // dh
	char v8; // cl
	bool v9; // zf
	int v10; // edx
	char v11; // bl

	result = a1;
	v3 = 1;
	if (!a2)
	{
	LABEL_12:
		v3 = 0;
		goto LABEL_13;
	}
	v4 = 8 * a2;
	v5 = x_D41A0_BYTEARRAY_0[v4];
	v6 = x_D41A0_BYTEARRAY_0[v4 + 222711];
	LOBYTE(v4) = v6;
	*(x_BYTE *)(v5 + 222711) = v6 + 1;
	v7 = *(x_BYTE *)(v5 + 222709) & 0x60;
	v8 = v4 & 3;
	if (v7 < 0x40u)
	{
		if (v7 != 32 || v8 != 3)
			goto LABEL_13;
		goto LABEL_12;
	}
	if (v7 <= 0x40u)
	{
		v9 = (v8 & 1) == 0;
		goto LABEL_11;
	}
	if (v7 == 96)
	{
		v9 = (v8 & 3) == 0;
	LABEL_11:
		if (v9)
			goto LABEL_13;
		goto LABEL_12;
	}
LABEL_13:
	if (!v3)
		return sub_12470(a1, 8 * *(x_BYTE *)(a1 + 64) + 1);
	*(x_BYTE *)(a1 + 69) = 8 * *(x_BYTE *)(a1 + 64) + 7;
	*(x_BYTE *)(a1 + 72) = a2;
	v10 = x_D41A0_BYTEARRAY_0[8 * a2];
	*(x_WORD *)(a1 + 74) = 0;
	v11 = *((x_BYTE *)&loc_365F2 + v10 + 2);
	*(x_BYTE *)(a1 + 73) = v11;
	if (v11 == 6)
		*(x_WORD *)(a1 + 74) = *(x_WORD *)((char *)sub_365F8 + v10);
	return result;
}
// 365F8: using guessed type int sub_365F8();
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00012410) --------------------------------------------------------
char sub_12410(int a1, char a2)
{
	int v2; // edx
	char v3; // bh

	v2 = 8 * *(unsigned __int8 *)(a1 + 72);
	v3 = 0;
	if (x_D41A0_BYTEARRAY_0[v2 + 222710])
		sub_12330(a1, x_D41A0_BYTEARRAY_0[v2 + 222710]);
	else
		v3 = 1;
	if (v3)
		sub_12470(a1, a2);
	return 0;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00012470) --------------------------------------------------------
int sub_12470(int a1, char a2)
{
	int result; // eax

	result = a1;
	*(x_BYTE *)(a1 + 73) = 0;
	*(x_BYTE *)(a1 + 72) = 0;
	*(x_WORD *)(a1 + 74) = 0;
	*(x_BYTE *)(a1 + 69) = a2;
	return result;
}

//----- (00012500) --------------------------------------------------------
char sub_12500(int a1)
{
	int v1; // eax
	signed __int16 v2; // di
	__int16 v3; // si
	char *v4; // ecx
	__int16 v5; // si
	char v6; // dl
	__int16 v7; // dx
	int v8; // esi
	__int16 v9; // cx
	signed __int16 v11; // [esp+0h] [ebp-4h]

	LOBYTE(v1) = *(x_BYTE *)(a1 + 69) & 7;
	v2 = 0;
	v3 = (unsigned __int8)v1;
	v11 = 1;
	if ((unsigned __int8)v1 < 4u || (unsigned __int8)v1 > 5u)
	{
		LOBYTE(v1) = *(x_BYTE *)(a1 + 73) - 1;
		switch (*(x_BYTE *)(a1 + 73))
		{
		case 0xA:
			v11 = 0;
			if (v3 != 2 && v3 != 6)
				LOBYTE(v1) = sub_12330(a1, *(unsigned __int8 *)(a1 + 72));
			break;
		case 0xD:
		case 0xE:
		case 0x10:
		case 0x11:
			v11 = 0;
			if (v3 != 2 && v3 != 6)
			{
				LOBYTE(v1) = 8 * *(x_BYTE *)(a1 + 64) + 7;
				*(x_BYTE *)(a1 + 69) = v1;
			}
			break;
		case 0xF:
			LOBYTE(v1) = 0;
			v11 = 0;
			if (v3)
				LOBYTE(v1) = sub_12330(a1, *(unsigned __int8 *)(a1 + 72));
			break;
		default:
			break;
		}
		if (v11)
		{
			v4 = (char*)(0x365F2 + 8 * x_D41A0_BYTEARRAY_0[(a1 + 72) + 2]);
			LOBYTE(v1) = *v4 - 1;
			switch (*v4)
			{
			case 1:
				v1 = abs(*((signed __int16 *)v4 + 2) - *(signed __int16 *)(a1 + 76));
				if (v1 <= 2048)
				{
					v1 = abs(*((signed __int16 *)v4 + 3) - *(signed __int16 *)(a1 + 78));
					if (v1 <= 2048)
						goto LABEL_44;
				}
				goto LABEL_45;
			case 3:
				LOBYTE(v1) = v4[1];
				if (v1 & 4)
				{
					*(x_WORD *)(a1 + 74) = 0;
					if (v3 != 2 && v3 != 6)
						goto LABEL_44;
				}
				else if (v1 & 2)
				{
					v9 = *(x_WORD *)(a1 + 74);
					if (v9)
					{
						v1 = x_DWORD_EA3E4[v9];
						if (*(x_DWORD *)(v1 + 8) < 0 || *(x_BYTE *)(v1 + 13) & 4)
							*(x_WORD *)(a1 + 74) = 0;
					}
				}
				goto LABEL_45;
			case 4:
			case 5:
			case 8:
			case 9:
				v6 = v4[1];
				if (v6 & 4)
				{
					v2 = 1;
				}
				else
				{
					if (!(v6 & 2))
					{
						LOBYTE(v1) = *v4;
						if (*v4 == 9)
						{
							v8 = *((x_DWORD *)v4 + 1);
							if (v8)
							{
								v1 = abs(*(signed __int16 *)(v8 + 76) - *(signed __int16 *)(a1 + 76));
								if (v1 <= 3072)
								{
									v1 = abs(*(signed __int16 *)(*((x_DWORD *)v4 + 1) + 78) - *(signed __int16 *)(a1 + 78));
									if (v1 <= 3072)
										goto LABEL_44;
								}
							}
						}
						goto LABEL_45;
					}
					LOBYTE(v1) = *v4;
					if ((unsigned __int8)*v4 < 4u
						|| (unsigned __int8)v1 > 5u
						|| (v7 = *(x_WORD *)(a1 + 74)) == 0
						|| (v1 = x_DWORD_EA3E4[v7], *(x_DWORD *)(v1 + 8) >= 0) && !(*(x_BYTE *)(v1 + 13) & 4))
					{
					LABEL_45:
						if (v2)
							LOBYTE(v1) = sub_12410(a1, 8 * *(x_BYTE *)(a1 + 64) + 1);
						return v1;
					}
				}
				*(x_WORD *)(a1 + 74) = 0;
				goto LABEL_45;
			case 6:
				v5 = *(x_WORD *)(a1 + 74) - 1;
				*(x_WORD *)(a1 + 74) = v5;
				if (!v5)
					goto LABEL_44;
				goto LABEL_45;
			case 7:
				if (v4[1] & 0x18)
				{
					LOBYTE(v1) = (unsigned int)sub_12870();
				LABEL_44:
					v2 = 1;
				}
				goto LABEL_45;
			default:
				goto LABEL_45;
			}
		}
	}
	return v1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00012780) --------------------------------------------------------
char *sub_12780()
{
	signed __int16 v0; // bx
	char *result; // eax
	signed __int16 v2; // dx
	char v3; // cl
	int v4; // ecx
	char v5; // dh

	v0 = 1;
	result = (char *)sub_365F8 + x_D41A0_BYTEARRAY_0[4];
	while (v0 <= *((unsigned __int8 *)&loc_36DFC + x_D41A0_BYTEARRAY_0[4]))
	{
		if (!*result)
			goto LABEL_18;
		v2 = 0;
		switch (*result)
		{
		case 3:
		case 4:
		case 5:
		case 8:
		case 9:
			v3 = result[1];
			if (v3 & 4)
				goto LABEL_11;
			if (v3 & 2)
			{
				if (x_D41A0_BYTEARRAY_4[*((unsigned __int16 *)result + 2) + 38403])//fix it
					goto LABEL_12;
			LABEL_11:
				v2 = 1;
				goto LABEL_12;
			}
			v4 = *((x_DWORD *)result + 1);
			if (v4 && (*(x_DWORD *)(v4 + 8) < 0 || *(x_BYTE *)(v4 + 13) & 4))
				goto LABEL_11;
		LABEL_12:
			if (v2)
				result[1] |= 4u;
		LABEL_18:
			++v0;
			result += 8;
			break;
		case 7:
			v5 = result[1];
			if (v5 & 0x18)
			{
				if (v5 & 0x10)
					result[1] = v5 & 0xEF;
				else
					result[1] = v5 & 0xF7;
			}
			goto LABEL_18;
		default:
			goto LABEL_18;
		}
	}
	return result;
}
// 365F8: using guessed type int sub_365F8();
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (00012870) --------------------------------------------------------
char *sub_12870()
{
	signed __int16 v0; // dx
	char *result; // eax
	char v2; // bh

	v0 = 1;
	result = (char *)sub_365F8 + x_D41A0_BYTEARRAY_0[4];
	while (v0 <= *((unsigned __int8 *)&loc_36DFC + x_D41A0_BYTEARRAY_0[4]))
	{
		if (*result)
		{
			switch (*result)
			{
			case 3:
			case 4:
			case 5:
			case 8:
			case 9:
				v2 = result[1];
				if (v2 & 4)
				{
					if (v2 & 2)
						result[1] = v2 & 0xFB;
				}
				break;
			default:
				break;
			}
		}
		++v0;
		result += 8;
	}
	return result;
}
// 365F8: using guessed type int sub_365F8();
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00012910) --------------------------------------------------------
signed int sub_12910(unsigned int a1)
{
	signed int result; // eax

	sub_12A70(a1);
	switch (*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 449))
	{
	case 0:
		sub_12E70(a1);
		result = sub_12E70(a1);
		break;
	case 1:
		sub_12FF0(a1);
		result = sub_12E70(a1);
		break;
	case 2:
		_nmemneed(a1);
		result = sub_12E70(a1);
		break;
	case 3:
		sub_13100(a1);
		result = sub_12E70(a1);
		break;
	case 4:
		sub_131F0((x_WORD *)a1);
		result = sub_12E70(a1);
		break;
	case 5:
		_nmemneed_0(a1);
		result = sub_12E70(a1);
		break;
	case 6:
		sub_135C0(a1);
		result = sub_12E70(a1);
		break;
	case 7:
		sub_13710(a1);
		result = sub_12E70(a1);
		break;
	case 8:
		sub_13830(a1);
		result = sub_12E70(a1);
		break;
	case 9:
		sub_13870(a1);
		result = sub_12E70(a1);
		break;
	case 0xB:
		sub_133B0(a1);
		result = sub_12E70(a1);
		break;
	case 0xC:
		sub_13270(a1);
		result = sub_12E70(a1);
		break;
	case 0xD:
		sub_13850(a1);
		result = sub_12E70(a1);
		break;
	case 0xE:
		sub_161A0(a1);
		goto LABEL_16;
	default:
	LABEL_16:
		result = sub_12E70(a1);
		break;
	}
	return result;
}
// 130F0: using guessed type int _nmemneed(x_DWORD);
// 135B0: using guessed type int _nmemneed_0(x_DWORD);

//----- (00012A70) --------------------------------------------------------
signed int sub_12A70(unsigned int a1)
{
	int v1; // edx
	signed int v2; // edi
	__int16 v3; // cx
	__int16 v4; // dx
	int v5; // esi
	__int16 v6; // ax
	__int16 i; // dx
	int v8; // ecx
	int v9; // eax
	int v10; // esi
	unsigned __int16 v11; // cx
	int v12; // eax
	int v13; // eax
	int v14; // esi
	int v15; // eax
	unsigned __int16 v16; // dx
	int v18; // edx
	unsigned __int8 v19; // ah
	int v20; // ecx
	int v21; // edx
	int v22; // edx
	int v23; // ecx
	int v24; // ecx
	int v25; // edx
	int v26; // esi
	signed __int16 j; // si
	int v28; // edx
	int v29; // eax
	int v30; // eax
	int v32; // [esp+0h] [ebp-4h]

	sub_15EE0();
	v1 = *(x_DWORD *)(a1 + 164);
	v2 = 0;
	v3 = *(x_WORD *)(v1 + 418);
	if (v3 < 0)
		*(x_WORD *)(v1 + 418) = v3 + 1;
	v4 = 0;
	do
	{
		v5 = 2 * v4 + *(x_DWORD *)(a1 + 164);
		v6 = *(x_WORD *)(v5 + 871);
		if (v6 > 0)
			*(x_WORD *)(v5 + 871) = v6 - 1;
		++v4;
	} while (v4 < 26);
	for (i = 0; i < 8; i++)
	{
		v8 = 8 * i;
		v9 = *(x_DWORD *)(a1 + 164);
		v32 = v8;
		v10 = v8 + v9;
		v11 = *(x_WORD *)(v8 + v9 + 516);
		if (v11 < 0x601Fu)
		{
			*(x_WORD *)(v10 + 516) = *(x_WORD *)(v9 + 578) + 1 + v11;
			v12 = v32 + *(x_DWORD *)(a1 + 164);
			if (*(x_WORD *)(v12 + 516) > 0x601Fu)
				*(x_WORD *)(v12 + 516) = 24607;
		}
		v13 = *(x_DWORD *)(a1 + 164);
		v14 = v13 + 8 * i;
		if (*(x_WORD *)(v14 + 516) > 0x601Fu)
		{
			if (!*(x_WORD *)(v14 + 518))
				*(x_WORD *)(v14 + 516) -= 256 - *(x_WORD *)(v13 + 578);
			v15 = *(x_DWORD *)(a1 + 164) + 8 * i;
			if (*(x_WORD *)(v15 + 516) < 0x601Fu)
				*(x_WORD *)(v15 + 516) = 24607;
		}
	}
	_wcpp_1_unwind_leave__99(a1);
	v16 = *(x_WORD *)(*(x_DWORD *)(a1 + 164) + 58);
	if (v16 && sub_106C0(a1, x_DWORD_EA3E4[v16]))
		v2 = 1;
	if ((x_WORD)v2)
		*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 345) = 2;
	if (*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 345))
	{
		memset((void*)(a1 + 94), 0, 36);
		--*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 345);
	}
	else if (sub_5EFA0(a1) == 2)
	{
		*(x_BYTE *)(a1 + 69) = 2;
		return 0;
	}
	sub_146F0(a1);
	v18 = *(x_DWORD *)(a1 + 164);
	v19 = *(x_BYTE *)(v18 + 340);
	if (v19 < 0xC8u)
		*(x_BYTE *)(v18 + 340) = v19 + 1;
	*(x_DWORD *)(a1 + 144) += *(x_DWORD *)(a1 + 136);
	v20 = *(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 355) + *(x_DWORD *)(a1 + 8);
	*(x_DWORD *)(a1 + 8) = v20;
	if (v20 < -1)
		*(x_DWORD *)(a1 + 8) = -1;
	v21 = *(x_DWORD *)(a1 + 4);
	if (*(x_DWORD *)(a1 + 8) > v21)
		*(x_DWORD *)(a1 + 8) = v21;
	v22 = *(x_DWORD *)(a1 + 164);
	v23 = *(x_DWORD *)(v22 + 365);
	if (v23)
		*(x_DWORD *)(v22 + 365) = v23 - 1;
	if ((x_WORD)v2 || *(x_BYTE *)(a1 + 13) & 0x10)
	{
		*(x_DWORD *)(a1 + 136) = *(x_DWORD *)(a1 + 140) / 200;
		*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 355) = *(x_DWORD *)(a1 + 4) / 200;
		if (*(x_DWORD *)(a1 + 136) < 1000)
			*(x_DWORD *)(a1 + 136) = 1000;
		*(x_BYTE *)(a1 + 13) &= 0xEFu;
	}
	else
	{
		*(x_DWORD *)(a1 + 136) = *(x_DWORD *)(a1 + 140) / 2000;
		*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 355) = *(x_DWORD *)(a1 + 4) / 500;
		if (*(x_DWORD *)(a1 + 136) < 100)
			*(x_DWORD *)(a1 + 136) = 100;
	}
	if (*(x_DWORD *)(a1 + 144) < 0)
		*(x_DWORD *)(a1 + 144) = 0;
	v24 = *(x_DWORD *)(a1 + 140);
	if (*(x_DWORD *)(a1 + 144) > v24)
		*(x_DWORD *)(a1 + 144) = v24;
	v25 = *(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 582);
	if (!(*(unsigned __int8 *)(a1 + 62) % (64 - ((v25 - (__CFSHL__(v25 >> 31, 2) + 4 * (v25 >> 31))) >> 2))))
	{
		v26 = sub_15CB0(v2, a1);
		if (v26)
		{
			sub_15D20(a1);
			sub_15D40(v2, a1, v26);
		}
		if (*(x_DWORD *)(a1 + 8) < *(x_DWORD *)(a1 + 4))
		{
			for (j = *(char *)(*(x_DWORD *)(a1 + 164) + 1058); j >= 0; j--)
			{
				if ((unsigned __int16)sub_15F20(a1, j, 5) == 5)
				{
					sub_14E10(a1, 5u);
					break;
				}
			}
		}
	}
	v28 = (signed __int16)sub_10C40((__int16 *)(a1 + 76));
	v29 = *(x_DWORD *)(a1 + 160);
	if (*(signed __int16 *)(a1 + 80) > v28 + *(signed __int16 *)(v29 + 10))
		*(x_WORD *)(a1 + 80) = *(x_WORD *)(v29 + 10) + v28;
	v30 = *(x_DWORD *)(a1 + 160);
	if (*(signed __int16 *)(a1 + 80) < v28 + *(signed __int16 *)(v30 + 12))
		*(x_WORD *)(a1 + 80) = *(x_WORD *)(v30 + 12) + v28;
	return 1;
}
// 5E000: using guessed type int _wcpp_1_unwind_leave__99(x_DWORD);
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00012E70) --------------------------------------------------------
signed int sub_12E70(int a1)
{
	int v2; // edx

	if (sub_13B00(a1))
	{
		*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 449) = 3;
	}
	else
	{
		if (sub_13DC0(a1))
		{
			*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 449) = 11;
			return 1;
		}
		v2 = *(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 582);
		if (!(*(unsigned __int8 *)(a1 + 62) % (64 - ((v2 - (__CFSHL__(v2 >> 31, 2) + 4 * (v2 >> 31))) >> 2))))
		{
			if (sub_13C50(a1))
			{
				*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 449) = 1;
				return 1;
			}
			if (sub_13E40(a1))
			{
				*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 449) = 7;
				return 1;
			}
			if (sub_14030(a1))
			{
				*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 449) = 8;
				return 1;
			}
			if (sub_14250(a1))
			{
				*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 449) = 9;
				return 1;
			}
			if ((unsigned __int16)sub_15FC0((x_WORD *)a1))
			{
				*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 449) = 14;
				return 1;
			}
			if (sub_13CE0(a1))
			{
				*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 449) = 6;
				return 1;
			}
			if (sub_14530(a1))
			{
				*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 449) = 13;
				return 1;
			}
			sub_14630(a1);
		}
	}
	return 1;
}

//----- (00012FF0) --------------------------------------------------------
signed int sub_12FF0(int a1)
{
	int v1; // esi
	signed __int16 i; // di
	int v3; // eax

	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
	if (!sub_14C60(a1, x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)]))
		goto LABEL_14;
	*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u *)(a1 + 76), (Bit16u *)(v1 + 76));
	if (sub_14C90(a1, v1, 512, 2048))
	{
		for (i = *(char *)(*(x_DWORD *)(a1 + 164) + 1055); i >= 0 && (unsigned __int16)sub_15F20(a1, i, 2) != 2; i--)
			;
		if (!sub_14E10(a1, 2u))
		{
			*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 12) = 0;
			v3 = *(signed __int16 *)(a1 + 80) - (*(signed __int16 *)(v1 + 80) + 512);
			if (*(signed __int16 *)(a1 + 80) != *(signed __int16 *)(v1 + 80) + 512)
			{
				if (v3 <= 0)
					LOWORD(v3) = -1;
				else
					LOWORD(v3) = 1;
			}
			*(x_WORD *)(a1 + 80) += *(x_WORD *)(*(x_DWORD *)(a1 + 160) + 14) * v3;
			goto LABEL_13;
		}
	LABEL_14:
		sub_16580(a1);
		return 0;
	}
LABEL_13:
	sub_16580(a1);
	return 1;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00013100) --------------------------------------------------------
signed int sub_13100(int a1)
{
	signed __int16 i; // si
	int v2; // eax
	signed int v3; // ebx

	*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u *)(a1 + 76), (Bit16u *)(a1 + 154));
	if (!sub_14C90(a1, 0, 2048, 4096))
		goto LABEL_16;
	for (i = *(char *)(*(x_DWORD *)(a1 + 164) + 1055); i >= 0 && (unsigned __int16)sub_15F20(a1, i, 2) != 2; i--)
		;
	if (sub_14E10(a1, 2u))
	{
	LABEL_16:
		sub_16580(a1);
		v3 = 0;
	}
	else
	{
		*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 12) = 0;
		v2 = *(signed __int16 *)(a1 + 80) - (*(signed __int16 *)(a1 + 158) + 512);
		if (*(signed __int16 *)(a1 + 80) != *(signed __int16 *)(a1 + 158) + 512)
		{
			if (*(signed __int16 *)(a1 + 80) - (*(signed __int16 *)(a1 + 158) + 512) <= 0)
				LOWORD(v2) = -1;
			else
				LOWORD(v2) = 1;
		}
		v3 = 1;
		*(x_WORD *)(a1 + 80) += v2 * *(x_WORD *)(*(x_DWORD *)(a1 + 160) + 14);
		sub_16580(a1);
	}
	return v3;
}

//----- (000131F0) --------------------------------------------------------
signed int sub_131F0(x_WORD *a1)
{
	int v1; // esi
	signed int result; // ebx

	v1 = x_DWORD_EA3E4[(unsigned __int16)a1[75]];
	if (!sub_14C60((int)a1, x_DWORD_EA3E4[(unsigned __int16)a1[75]])
		|| (a1[16] = sub_581E0((Bit16u *)a1 + 38, (Bit16u *)(v1 + 76)), sub_14C90((int)a1, v1, 256, 2048)))
	{
		sub_16580((int)a1);
		result = 0;
	}
	else
	{
		sub_16580((int)a1);
		result = 1;
	}
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00013270) --------------------------------------------------------
signed int sub_13270(int a1)
{
	int v1; // edi
	signed __int16 v2; // si
	int v3; // edx
	unsigned __int16 v4; // cx
	signed __int16 v5; // di
	signed __int16 i; // si
	signed int v7; // ebx
	signed int result; // eax
	unsigned int v9; // eax

	v1 = *(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 580);
	v2 = 0;
	if (rand() % 255 < v1)
	{
		v3 = *(x_DWORD *)(a1 + 164);
		v4 = *(x_WORD *)(v3 + 58);
		v5 = *(char *)(v3 + 1075);
		if (v4 && sub_106C0(a1, x_DWORD_EA3E4[v4]))
			v2 = 1;
		if (!v2)
		{
			for (i = v5; i >= 0; i--)
			{
				if ((unsigned __int16)sub_15F20(a1, v5, 22) == 22)
				{
					sub_14E10(a1, 0x16u);
					sub_16580(a1);
					v7 = 1;
					goto LABEL_19;
				}
			}
		}
	}
	if (sub_15170(a1, 3u))
	{
		if (!sub_156F0(a1, 3u))
			sub_14E10(a1, 3u);
		sub_16580(a1);
		result = 1;
	}
	else
	{
		sub_16580(a1);
		v9 = sub_146C0(a1, 3u);
		if (v9 && *(x_WORD *)(v9 + 46) > 0)
		{
			result = 1;
		}
		else
		{
			*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 12) = *(x_WORD *)(a1 + 132);
			*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 14) = 1;
			v7 = 0;
		LABEL_19:
			result = v7;
		}
	}
	return result;
}
// 8C278: using guessed type int rand(void);
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000133B0) --------------------------------------------------------
signed int sub_133B0(int a1)
{
	int v1; // eax
	unsigned int v2; // esi
	signed __int16 k; // di
	signed __int16 l; // di
	signed __int16 i; // si
	signed __int16 j; // si
	unsigned int v9; // eax

	v1 = *(x_DWORD *)(a1 + 164);
	v2 = x_DWORD_EA3E4[*(unsigned __int16 *)(v1 + 58)];
	if (v2 <= x_DWORD_EA3E4[0])
	{
		for (i = *(char *)(v1 + 1064); i >= 0; i--)
		{
			if ((unsigned __int16)sub_15F20(a1, i, 11) == 11)
			{
				sub_14E10(a1, 0xBu);
				break;
			}
		}
		for (j = *(char *)(*(x_DWORD *)(a1 + 164) + 1056); j >= 0; j--)
		{
			if ((unsigned __int16)sub_15F20(a1, j, 3) == 3)
			{
				sub_14E10(a1, 3u);
				sub_16580(a1);
				return 1;
			}
		}
		v9 = sub_146C0(a1, 3u);
		if (v9 && *(x_WORD *)(v9 + 46) > 0)
		{
			sub_16580(a1);
			return 1;
		}
		*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 12) = *(x_WORD *)(a1 + 132);
		*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 14) = 1;
	}
	else
	{
		if ((unsigned int)sub_584D0((x_WORD *)(a1 + 76), (x_WORD *)(v2 + 76)) > 0x6400000)
		{
			for (k = *(char *)(*(x_DWORD *)(a1 + 164) + 1054); k >= 0; k--)
			{
				if ((unsigned __int16)sub_15F20(a1, k, 1) == 1 && sub_14E10(a1, 1u))
					goto LABEL_6;
			}
		}
		for (l = *(char *)(*(x_DWORD *)(a1 + 164) + 1064); l >= 0; l--)
		{
			if ((unsigned __int16)sub_15F20(a1, l, 11) == 11)
			{
				sub_14E10(a1, 0xBu);
				break;
			}
		}
		if (sub_14C60(a1, v2))
		{
			*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u *)(a1 + 76), (Bit16u *)(v2 + 76));
			if (sub_14C90(a1, v2, 256, 2048))
			{
				sub_16580(a1);
				return 0;
			}
		LABEL_6:
			sub_16580(a1);
			return 1;
		}
	}
	sub_16580(a1);
	return 0;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000135C0) --------------------------------------------------------
signed int sub_135C0(int a1)
{
	x_WORD *v1; // esi
	signed __int16 i; // di
	__int16 v3; // ax
	int v4; // esi
	__int16 v7; // [esp+0h] [ebp-4h]

	v1 = (x_WORD *)x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
	if (!sub_14C60(a1, x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)]))
	{
	LABEL_17:
		sub_16580(a1);
		return 0;
	}
	*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u *)(a1 + 76), (Bit16u *)v1 + 38);
	if (sub_14C90(a1, (int)v1, 1024, 3072))
	{
		for (i = *(char *)(*(x_DWORD *)(a1 + 164) + 1054); i >= 0; i--)
		{
			v7 = sub_15F20(a1, i, 1);
			if (v7 == 1)
				break;
		}
		if (v7 == 1 && sub_14E10(a1, 1u))
		{
			v3 = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)v1 + 38);
			if ((unsigned __int16)sub_582B0(*(x_WORD *)(a1 + 28), v3) < 0x1Cu)
				v1[74] = *(x_WORD *)(a1 + 26);
			goto LABEL_17;
		}
		*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 12) = 0;
		v4 = *(signed __int16 *)(a1 + 80) - ((signed __int16)v1[40] + 512);
		if (v4)
		{
			if (v4 <= 0)
				LOWORD(v4) = -1;
			else
				LOWORD(v4) = 1;
		}
		*(x_WORD *)(a1 + 80) += v4 * *(x_WORD *)(*(x_DWORD *)(a1 + 160) + 14);
	}
	sub_16580(a1);
	return 1;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00013710) --------------------------------------------------------
signed int sub_13710(int a1)
{
	int v1; // esi
	int v2; // edx
	signed __int8 v3; // al
	int v4; // edx

	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
	if (!sub_14C60(a1, v1))
		goto LABEL_12;
	*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v1 + 76));
	if (sub_14C90(a1, v1, 2048, 3584))
	{
		v2 = *(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 582);
		if (!(*(unsigned __int8 *)(a1 + 62) % (64 - ((v2 - (__CFSHL__(v2 >> 31, 2) + 4 * (v2 >> 31))) >> 2))))
		{
			v3 = sub_15910((x_DWORD *)a1);
			if (v3 == -1 || !sub_14E10(a1, v3))
			{
				*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 12) = 0;
				v4 = *(signed __int16 *)(a1 + 80) - (*(signed __int16 *)(v1 + 80) + 512);
				if (*(signed __int16 *)(a1 + 80) != *(signed __int16 *)(v1 + 80) + 512)
				{
					if (v4 <= 0)
						LOWORD(v4) = -1;
					else
						LOWORD(v4) = 1;
				}
				*(x_WORD *)(a1 + 80) += v4 * *(x_WORD *)(*(x_DWORD *)(a1 + 160) + 14);
				goto LABEL_11;
			}
		LABEL_12:
			sub_16580(a1);
			return 0;
		}
	}
LABEL_11:
	sub_16580(a1);
	return 1;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00013830) --------------------------------------------------------
signed int sub_13830(int a1)
{
	return sub_13890(a1);
}

//----- (00013850) --------------------------------------------------------
signed int sub_13850(int a1)
{
	return sub_13890(a1);
}

//----- (00013870) --------------------------------------------------------
int sub_13870(int a1)
{
	signed int v1; // eax

	v1 = sub_13890(a1);
	return nullsub_1(v1);
}
// 13880: using guessed type int /*__fastcall*/ nullsub_1(x_DWORD);

//----- (00013890) --------------------------------------------------------
signed int sub_13890(int a1)
{
	int v1; // esi
	signed __int8 v2; // al
	unsigned __int8 v3; // di
	char v4; // ah
	char v5; // dh
	int v6; // eax
	char v7; // ch
	int v8; // eax
	char v9; // cl
	int v10; // eax
	char v11; // dh
	int v12; // eax

	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
	if (sub_14C60(a1, v1))
	{
		*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u *)(a1 + 76), (Bit16u *)(v1 + 76));
		if (sub_14C90(a1, v1, 3328, 4608) && *(x_WORD *)(*(x_DWORD *)(a1 + 164) + 418) >= 0)
		{
			v2 = sub_15790(a1);
			if (v2 != -1)
			{
				v3 = v2;
				if (sub_15170(a1, v2))
				{
					if (sub_14E10(a1, v3))
					{
						v4 = *(x_BYTE *)(v1 + 64);
						if (!v4 || v4 == 1)
							*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 8 * *(signed __int16 *)(*(x_DWORD *)(v1 + 164) + 56) + 518) = 0;
						goto LABEL_36;
					}
				}
			}
			*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 12) = 0;
			v5 = *(x_BYTE *)(v1 + 64);
			if (!v5 || v5 == 1)
			{
				v6 = *(x_DWORD *)(a1 + 164);
				v7 = *(x_BYTE *)(v6 + 1117);
				if (v7 < 3 || v7 >= 5)
				{
					v8 = *(x_DWORD *)(a1 + 164);
					v9 = *(x_BYTE *)(v8 + 1117);
					if (v9 < 5 || v9 >= 20)
					{
						v10 = *(x_DWORD *)(a1 + 164);
						v11 = *(x_BYTE *)(v10 + 1117);
						if (v11 < 20)
						{
							if (v11)
							{
								if (*(x_BYTE *)(v10 + 1116) == 1)
									*(x_WORD *)(a1 + 32) -= 512;
								else
									*(x_BYTE *)(a1 + 33) += 2;
								*(x_BYTE *)(a1 + 33) &= 7u;
								*(x_WORD *)(a1 + 130) = 3
									* *(signed __int16 *)(a1 + 132)
									* *(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 582)
									/ 255;
								*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 14) = 1;
							}
							else
							{
								*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
								if ((signed int)(*(unsigned __int16 *)(a1 + 20) % 0xFFu) >= 127)
								{
									*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 1116) = 2;
									*(x_BYTE *)(a1 + 29) += 2;
								}
								else
								{
									*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 1116) = 1;
									*(x_WORD *)(a1 + 28) -= 512;
								}
								*(x_BYTE *)(a1 + 29) &= 7u;
							}
							++*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 1117);
						}
						else
						{
							*(x_BYTE *)(v10 + 1117) = 0;
						}
					}
					else
					{
						*(x_BYTE *)(v8 + 1117) = v9 + 1;
					}
				}
				else
				{
					*(x_BYTE *)(v6 + 1117) = v7 + 1;
				}
			}
			v12 = *(signed __int16 *)(a1 + 80) - (*(signed __int16 *)(v1 + 80) + 512);
			if (*(signed __int16 *)(a1 + 80) != *(signed __int16 *)(v1 + 80) + 512)
			{
				if (*(signed __int16 *)(a1 + 80) - (*(signed __int16 *)(v1 + 80) + 512) <= 0)
					LOWORD(v12) = -1;
				else
					LOWORD(v12) = 1;
			}
			*(x_WORD *)(a1 + 80) += v12 * *(x_WORD *)(*(x_DWORD *)(a1 + 160) + 14);
		}
		sub_16580(a1);
		return 1;
	}
LABEL_36:
	sub_16580(a1);
	return 0;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00013B00) --------------------------------------------------------
signed int sub_13B00(int a1)
{
	x_WORD *v1; // esi
	__int16 v2; // bx
	unsigned int v3; // eax
	int v4; // edi
	int v5; // esi
	unsigned int v7; // eax
	int v8; // edi
	int v9; // esi
	int v11; // [esp+4h] [ebp-Ch]
	__int16 i; // [esp+8h] [ebp-8h]
	int v13; // [esp+Ch] [ebp-4h]

	v1 = (x_WORD *)x_DWORD_EA3E4[0];
	if (!*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 58) && sub_146C0(a1, 2u) && sub_15730(a1, 2u))
	{
		v1[13] = *(x_WORD *)(a1 + 26);
		v13 = (*(signed __int16 *)(a1 + 76)
			- (__CFSHL__(*(signed __int16 *)(a1 + 76) >> 31, 14)
				+ (*(signed __int16 *)(a1 + 76) >> 31 << 14))) >> 14;
		v2 = 0;
		v11 = (*(signed __int16 *)(a1 + 78)
			- (__CFSHL__(*(signed __int16 *)(a1 + 78) >> 31, 14)
				+ (*(signed __int16 *)(a1 + 78) >> 31 << 14))) >> 14;
		while (v2 < 4)
		{
			for (i = 0; i < 4; i++)
			{
				v1[38] = (((x_BYTE)v13 + (x_BYTE)i) & 3) << 14;
				v1[39] = (((x_BYTE)v2 + (x_BYTE)v11) & 3) << 14;
				v3 = sub_14B10((int)v1, 2u);
				if (!v3 || (unsigned int)sub_583B0((x_WORD *)(v3 + 76), v1 + 38) > 0x3000)
				{
					v4 = a1 + 154;
					v5 = (int)(v1 + 38);
					*(x_DWORD *)v4 = *(x_DWORD *)v5;
					*(x_WORD *)(v4 + 4) = *(x_WORD *)(v5 + 4);
					return 1;
				}
				v7 = sub_14B10((int)v1, 2u);
				if (!v7 || (unsigned int)sub_583B0((x_WORD *)(v7 + 76), v1 + 38) > 0x3000)
				{
					v8 = a1 + 154;
					v9 = (int)(v1 + 38);
					*(x_DWORD *)v8 = *(x_DWORD *)v9;
					*(x_WORD *)(v8 + 4) = *(x_WORD *)(v9 + 4);
					return 1;
				}
			}
			++v2;
		}
	}
	return 0;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00013C50) --------------------------------------------------------
signed int sub_13C50(int a1)
{
	unsigned int v1; // ebx

	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(*(x_DWORD *)(a1 + 164) + 58)];
	if (v1 <= x_DWORD_EA3E4[0] || *(x_BYTE *)(v1 + 69) != 4 || *(x_WORD *)(v1 + 48) || !sub_155E0(a1))
		return 0;
	*(x_WORD *)(a1 + 150) = (signed int)(v1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
	*(x_WORD *)(a1 + 152) = sub_14C40(v1);
	return 1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00013CE0) --------------------------------------------------------
unsigned int sub_13CE0(int a1)
{
	unsigned int result; // eax
	unsigned int v2; // eax
	int v3; // eax
	int v4; // eax

	result = sub_146C0(a1, 1u);
	if (result)
	{
		v2 = sub_146C0(a1, 2u);
		if (v2)
		{
			if (*(x_DWORD *)(a1 + 140) <= *(x_DWORD *)(v2 + 140))
			{
				v3 = sub_148E0(a1);
				if (v3)
				{
					*(x_WORD *)(a1 + 150) = (v3 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
					*(x_WORD *)(a1 + 152) = sub_14C40(v3);
					return 1;
				}
			}
		}
		else
		{
			v4 = sub_148E0(a1);
			if (v4)
			{
				*(x_WORD *)(a1 + 150) = (v4 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
				*(x_WORD *)(a1 + 152) = sub_14C40(v4);
				return 1;
			}
		}
		result = 0;
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00013DC0) --------------------------------------------------------
signed int sub_13DC0(int a1)
{
	unsigned int v1; // ecx
	int v2; // ST00_4

	if (*(x_DWORD *)(a1 + 4) / 2 <= *(x_DWORD *)(a1 + 8))
		return 0;
	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(*(x_DWORD *)(a1 + 164) + 58)];
	if (v1 <= x_DWORD_EA3E4[0])
		return 0;
	v2 = x_DWORD_EA3E4[*(unsigned __int16 *)(*(x_DWORD *)(a1 + 164) + 58)];
	*(x_WORD *)(a1 + 150) = (signed int)(v1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
	*(x_WORD *)(a1 + 152) = sub_14C40(v2);
	return 1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00013E40) --------------------------------------------------------
signed int sub_13E40(int a1)
{
	int v1; // edi
	unsigned int i; // ebx
	int v3; // ecx
	unsigned int v4; // eax
	int v5; // ebx
	signed int result; // ebx
	unsigned int v8; // [esp+8h] [ebp-8h]

	v8 = -1;
	if (!sub_164B0(a1) || !*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 58) && sub_146C0(a1, 2u))
		return 0;
	v1 = 0;
	for (i = x_D41A0_BYTEARRAY_4[0x9677]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
	{
		if (*(x_WORD *)(i + 26) != *(x_WORD *)(a1 + 26) && *(x_BYTE *)(i + 64) == 2)
		{
			if ((v3 = x_DWORD_EA3E4[*(signed __int16 *)(i + 26)],
				50000 - *(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 578) * (*(x_DWORD *)(v3 + 140) / 10) / 255 < *(unsigned __int16 *)(*(x_DWORD *)(a1 + 164) + 8 * *(signed __int16 *)(*(x_DWORD *)(v3 + 164) + 56) + 516))
				&& (unsigned int)sub_584D0((x_WORD *)(v3 + 76), (x_WORD *)(i + 76)) > 0x3840000
				&& !sub_106C0(x_DWORD_EA3E4[*(signed __int16 *)(i + 26)], i)
				|| *(x_DWORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(*(x_DWORD *)(a1 + 164) + 58)] + 144) > 640
				* (255
					- *(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 578))
				+ *(x_DWORD *)(i + 144))
			{
				v4 = sub_584D0((x_WORD *)(a1 + 76), (x_WORD *)(i + 76));
				if (v4 < v8)
				{
					v1 = i;
					v8 = v4;
				}
			}
		}
	}
	if (!v1)
		return 0;
	v5 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 28);
	if (sub_584D0((x_WORD *)(v1 + 76), (x_WORD *)(a1 + 76)) >= (unsigned int)(v5 * v5))
		return 0;
	result = 1;
	*(x_WORD *)(a1 + 150) = (v1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
	*(x_WORD *)(a1 + 152) = sub_14C40(v1);
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00014030) --------------------------------------------------------
signed int sub_14030(int a1)
{
	int v1; // edi
	unsigned int i; // ebx
	char v3; // ah
	int v4; // ecx
	int v5; // eax
	unsigned int v7; // eax
	int v8; // ebx
	unsigned int v9; // [esp+0h] [ebp-14h]

	v9 = -1;
	if (!sub_15E60(a1) || !*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 58) && sub_146C0(a1, 2u))
		return 0;
	v1 = 0;
	for (i = x_D41A0_BYTEARRAY_4[0x9677]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
	{
		if (*(x_WORD *)(i + 26) != *(x_WORD *)(a1 + 26))
		{
			v3 = *(x_BYTE *)(i + 64);
			if ((!v3 || v3 == 1) && !sub_15760(i, 0xBu))
			{
				v4 = *(x_DWORD *)(i + 164);
				v5 = *(x_DWORD *)(a1 + 164) + 8 * *(signed __int16 *)(v4 + 56);
				if (*(x_WORD *)(v5 + 518) == 1)
				{
					*(x_WORD *)(a1 + 150) = (signed int)(i - (x_D41A0_BYTEARRAY_0[28302])) / 168;
					*(x_WORD *)(a1 + 152) = sub_14C40(i);
					return 1;
				}
				if (50000 - *(x_DWORD *)(i + 140) / 10 * *(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 578) / 255 <= *(unsigned __int16 *)(v5 + 516)
					|| !*(x_WORD *)(v4 + 58)
					&& sub_146C0(i, 2u)
					&& *(x_DWORD *)(i + 144) + 32 * (255 - *(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 578)) < *(x_DWORD *)(a1 + 144))
				{
					v7 = sub_584D0((x_WORD *)(a1 + 76), (x_WORD *)(i + 76));
					if (v7 < v9)
					{
						v1 = i;
						v9 = v7;
					}
				}
			}
		}
	}
	if (!v1)
		return 0;
	v8 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 28) + 10;
	if (sub_584D0((x_WORD *)(v1 + 76), (x_WORD *)(a1 + 76)) >= (unsigned int)(v8 * v8))
		return 0;
	*(x_WORD *)(a1 + 150) = (v1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
	*(x_WORD *)(a1 + 152) = sub_14C40(v1);
	return 1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00014250) --------------------------------------------------------
signed int sub_14250(int a1)
{
	int v1; // esi
	unsigned int i; // ebx
	int v3; // edx
	unsigned int v4; // eax
	int v5; // ebx
	int v7; // [esp+Ch] [ebp-Ch]
	int v8; // [esp+10h] [ebp-8h]
	unsigned int v9; // [esp+14h] [ebp-4h]

	v9 = -1;
	if (!sub_15E60(a1))
		return 0;
	v1 = 0;
	for (i = x_D41A0_BYTEARRAY_4[0x9677]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
	{
		if (*(x_WORD *)(i + 26) != *(x_WORD *)(a1 + 26) && *(x_BYTE *)(i + 64) == 3)
		{
			v3 = x_DWORD_EA3E4[*(signed __int16 *)(i + 26)];
			v8 = *(x_DWORD *)(v3 + 164);
			v7 = *(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 578);
			if (50000 - *(x_DWORD *)(v3 + 140) / 10 * v7 / 255 < *(unsigned __int16 *)(*(x_DWORD *)(a1 + 164)
				+ 8 * *(signed __int16 *)(v8 + 56)
				+ 516)
				&& 10 * (275 - v7) < *(x_DWORD *)(i + 144)
				&& !sub_106C0(i, x_DWORD_EA3E4[*(unsigned __int16 *)(v8 + 58)]))
			{
				v4 = sub_584D0((x_WORD *)(a1 + 76), (x_WORD *)(i + 76));
				if (v4 < v9)
				{
					v1 = i;
					v9 = v4;
				}
			}
		}
	}
	if (!v1)
		return 0;
	v5 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 28);
	if (sub_584D0((x_WORD *)(v1 + 76), (x_WORD *)(a1 + 76)) >= (unsigned int)(v5 * v5))
		return 0;
	*(x_WORD *)(a1 + 150) = (v1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
	*(x_WORD *)(a1 + 152) = sub_14C40(v1);
	return 1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00014530) --------------------------------------------------------
signed int sub_14530(int a1)
{
	int v1; // esi
	signed int i; // edi
	unsigned int j; // ebx
	unsigned int v4; // eax
	unsigned int v6; // [esp+0h] [ebp-8h]
	int v7; // [esp+4h] [ebp-4h]

	v1 = 0;
	v6 = -1;
	if (!sub_15E60(a1))
		return 0;
	v7 = x_DWORD_EA3E4[*(unsigned __int16 *)(*(x_DWORD *)(a1 + 164) + 58)];
	if (v7 == x_DWORD_EA3E4[0])
		v7 = a1;
	for (i = 0; i < 29; i++)
	{
		for (j = x_D41A0_BYTEARRAY_4[i + 38403]; j > x_DWORD_EA3E4[0]; j = *(x_DWORD *)j)
		{
			if (*(x_WORD *)(j + 26) != *(x_WORD *)(a1 + 26) && *(x_DWORD *)(j + 144) > 0)
			{
				v4 = sub_584D0((x_WORD *)(v7 + 76), (x_WORD *)(j + 76));
				if (v4 < v6)
				{
					v1 = j;
					v6 = v4;
				}
			}
		}
	}
	if (!v1)
		return 0;
	*(x_WORD *)(a1 + 150) = (v1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
	*(x_WORD *)(a1 + 152) = sub_14C40(v1);
	return 1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00014630) --------------------------------------------------------
signed int sub_14630(int a1)
{
	unsigned int v1; // ecx

	if (*(x_DWORD *)(a1 + 8) >= *(x_DWORD *)(a1 + 4)
		|| (v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(*(x_DWORD *)(a1 + 164) + 58)], v1 <= x_DWORD_EA3E4[0]))
	{
		*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 449) = 12;
	}
	else
	{
		*(x_WORD *)(a1 + 150) = (signed int)(v1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
		*(x_WORD *)(a1 + 152) = sub_14C40(v1);
		*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 449) = 11;
	}
	return 1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000146C0) --------------------------------------------------------
unsigned int sub_146C0(int a1, unsigned __int8 a2)
{
	unsigned int result; // eax

	result = x_DWORD_EA3E4[*(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 2 * a2 + 819)];
	if (result <= x_DWORD_EA3E4[0])
		result = 0;
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000146F0) --------------------------------------------------------
signed int sub_146F0(int a1)
{
	char v1; // ah
	signed __int16 *v2; // edx
	__int16 v3; // ST10_2
	int v4; // ST0C_4
	int v5; // ST08_4
	__int16 v6; // ax
	unsigned __int16 v7; // ax
	int v8; // edx
	__int16 v9; // cx
	x_WORD *v10; // eax
	signed __int16 v11; // dx
	signed __int16 v12; // ax
	__int16 v13; // ax
	unsigned __int16 v14; // si
	__int64 v15; // rax
	int v16; // eax
	int v17; // edx
	__int16 v18; // si
	__int16 v19; // si
	unsigned int v20; // eax
	unsigned __int16 v21; // si
	unsigned __int16 v22; // dx

	v1 = *(x_BYTE *)(a1 + 13);
	if (v1 & 8)
	{
		*(x_BYTE *)(a1 + 13) = v1 & 0xF7;
	}
	else
	{
		*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
		*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
		v2 = *(signed __int16 **)(a1 + 160);
		v3 = v2[7];
		v4 = v2[5];
		v5 = v2[6];
		v6 = sub_10C40(&x_WORD_EB398);
		sub_580E0((int)&x_WORD_EB398, v6, v5, v4, v3);
		sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), 0, *(x_WORD *)(a1 + 130));
		v7 = *(x_WORD *)(a1 + 28);
		HIBYTE(v7) += 2;
		sub_57FA0((x_WORD*)&x_WORD_EB398, v7, 0, *(x_WORD *)(*(x_DWORD *)(a1 + 164) + 16));
		v8 = *(x_DWORD *)(a1 + 164);
		v9 = *(x_WORD *)(v8 + 16);
		v10 = (x_WORD *)(v8 + 16);
		if (v9)
		{
			if (v9 <= 0)
				v11 = -1;
			else
				v11 = 1;
		}
		else
		{
			v11 = 0;
		}
		*v10 -= 4 * v11;
		sub_57CF0(a1, (int)&x_WORD_EB398);
		v12 = *(x_WORD *)(*(x_DWORD *)(a1 + 164) + 12) - *(x_WORD *)(a1 + 130);
		if (*(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 12) != *(signed __int16 *)(a1 + 130))
		{
			if (*(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 12) - *(signed __int16 *)(a1 + 130) <= 0)
				v12 = -1;
			else
				v12 = 1;
		}
		*(x_WORD *)(a1 + 130) += 16 * v12;
		v13 = *(x_WORD *)(a1 + 32);
		HIBYTE(v13) &= 7u;
		v14 = sub_582B0(*(x_WORD *)(a1 + 28), v13);
		v15 = 255 - *(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 582);
		v16 = v14
			/ (signed int)(unsigned __int16)(((signed int)(v15 - (__CFSHL__(HIDWORD(v15), 4) + 16 * HIDWORD(v15))) >> 4) + 8);
		v17 = *(x_DWORD *)(a1 + 160);
		v18 = v16;
		if ((signed __int16)v16 <= *(x_WORD *)(v17 + 2))
		{
			if ((signed __int16)v16 < *(x_WORD *)(v17 + 4))
				v18 = *(x_WORD *)(v17 + 4);
		}
		else
		{
			v18 = *(x_WORD *)(v17 + 2);
		}
		v19 = sub_582F0(*(unsigned __int16 *)(a1 + 28), *(x_WORD *)(a1 + 32)) * v18;
		v20 = *(unsigned __int16 *)(a1 + 28);
		v21 = (v20 + v19) & 0x7FF;
		v22 = *(x_WORD *)(a1 + 32);
		*(x_WORD *)(a1 + 28) = v21;
		if ((unsigned __int16)v20 < (unsigned int)v22 && v21 > v22
			|| (v22 = *(x_WORD *)(a1 + 32), v20 > v22) && v22 > *(x_WORD *)(a1 + 28))
		{
			*(x_WORD *)(a1 + 28) = v22;
		}
	}
	return 1;
}
// EB398: using guessed type __int16 x_WORD_EB398;

//----- (000148E0) --------------------------------------------------------
unsigned int sub_148E0(int a1)
{
	unsigned int v1; // edi
	unsigned int v2; // ebx
	int v3; // ST08_4
	int v4; // eax
	int v5; // edx
	char v6; // cl
	unsigned int v7; // eax
	unsigned int v8; // eax
	unsigned int i; // ebx
	unsigned int v10; // eax
	unsigned int v12; // [esp+8h] [ebp-14h]
	x_WORD *v13; // [esp+Ch] [ebp-10h]
	int v14; // [esp+10h] [ebp-Ch]
	unsigned int v15; // [esp+14h] [ebp-8h]
	unsigned int result; // [esp+18h] [ebp-4h]

	v1 = -1;
	result = 0;
	v2 = x_D41A0_BYTEARRAY_4[0x967B];
	v15 = x_DWORD_EA3E4[*(unsigned __int16 *)(*(x_DWORD *)(a1 + 164) + 58)];
	while (v2 > x_DWORD_EA3E4[0])
	{
		if (a1 == x_DWORD_EA3E4[*(unsigned __int16 *)(v2 + 148)])
			goto LABEL_22;
		if (*(x_BYTE *)(v2 + 64) == 57)
		{
			v3 = *(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 580);
			if (rand() % 255 < v3)
				break;
		}
		v4 = *(unsigned __int16 *)(v2 + 148);
		v5 = x_DWORD_EA3E4[(unsigned __int16)v4];
		v13 = (x_WORD *)(v2 + 76);
		v6 = *(x_BYTE *)(v5 + 63);
		if (v6 == 3)
		{
			if (v4 == *(signed __int16 *)(a1 + 26))
				goto LABEL_22;
			if (50000 - *(x_DWORD *)(v5 + 140) / 10 * *(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 578) / 255 >= *(unsigned __int16 *)(*(x_DWORD *)(a1 + 164) + 8 * *(signed __int16 *)(*(x_DWORD *)(v5 + 164) + 56) + 516))
			{
				v12 = sub_16FC0(v2, a1);
				if (!v12)
					goto LABEL_22;
				v8 = v15 <= x_DWORD_EA3E4[0] ? sub_14B10(v2, 2u) : sub_14BD0(v2, v15);
				v14 = v8;
				if (*(x_WORD *)(a1 + 26) != *(x_WORD *)(v12 + 26)
					&& (unsigned int)sub_584D0((x_WORD *)(v2 + 76), (x_WORD *)(v12 + 76)) <= 0x1900000)
				{
					goto LABEL_22;
				}
				if (v14 && sub_106C0(v2, v14))
					goto LABEL_22;
				v7 = sub_584D0((x_WORD *)(a1 + 76), (x_WORD *)(v2 + 76));
			}
			else
			{
				v7 = sub_584D0((x_WORD *)(v15 + 76), v13);
			}
		}
		else
		{
			if (v6 == 3)
				goto LABEL_22;
			v7 = sub_584D0((x_WORD *)(a1 + 76), v13);
		}
		if (v7 < v1)
		{
			result = v2;
			v1 = v7;
		}
	LABEL_22:
		v2 = *(x_DWORD *)v2;
	}
	if (!result)
	{
		for (i = x_D41A0_BYTEARRAY_4[0x965B]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
		{
			if (*(x_BYTE *)(i + 64) != 57 && *(unsigned __int16 *)(i + 148) != *(signed __int16 *)(a1 + 26))
			{
				v10 = sub_584D0((x_WORD *)(a1 + 76), (x_WORD *)(i + 76));
				if (v10 < v1)
				{
					result = i;
					v1 = v10;
				}
			}
		}
	}
	return result;
}
// 8C278: using guessed type int rand(void);
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00014B10) --------------------------------------------------------
unsigned int sub_14B10(int a1, unsigned __int8 a2)
{
	unsigned int v2; // edi
	unsigned int result; // esi
	unsigned int i; // ebx
	unsigned int v5; // eax
	unsigned int j; // ebx
	unsigned int v7; // eax

	v2 = -1;
	result = 0;
	if (a2 < 2u)
	{
		if (a2)
			return result;
	}
	else if (a2 > 3u)
	{
		if (a2 == -1)
		{
			for (i = x_D41A0_BYTEARRAY_4[0x9677]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
			{
				if (*(x_WORD *)(i + 26) != *(x_WORD *)(a1 + 26))
				{
					v5 = sub_584D0((x_WORD *)(a1 + 76), (x_WORD *)(i + 76));
					if (v5 < v2)
					{
						result = i;
						v2 = v5;
					}
				}
			}
		}
		return result;
	}
	for (j = x_D41A0_BYTEARRAY_4[0x9677]; j > x_DWORD_EA3E4[0]; j = *(x_DWORD *)j)
	{
		if (*(x_WORD *)(j + 26) != *(x_WORD *)(a1 + 26) && *(char *)(j + 64) == a2)
		{
			v7 = sub_584D0((x_WORD *)(a1 + 76), (x_WORD *)(j + 76));
			if (v7 < v2)
			{
				result = j;
				v2 = v7;
			}
		}
	}
	return result;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00014BD0) --------------------------------------------------------
unsigned int sub_14BD0(int a1, int a2)
{
	unsigned int v2; // edi
	unsigned int result; // esi
	unsigned int v4; // ebx
	__int16 v6; // ax
	unsigned int v7; // eax

	v2 = -1;
	result = 0;
	v4 = x_D41A0_BYTEARRAY_4[0x9677];
	if (v4 <= x_DWORD_EA3E4[0])
		return 0;
	do
	{
		v6 = *(x_WORD *)(v4 + 26);
		if (v6 != *(x_WORD *)(a1 + 26) && v6 != *(x_WORD *)(a2 + 26) && *(x_BYTE *)(v4 + 64) == 2)
		{
			v7 = sub_584D0((x_WORD *)(a1 + 76), (x_WORD *)(v4 + 76));
			if (v7 < v2)
			{
				result = v4;
				v2 = v7;
			}
		}
		v4 = *(x_DWORD *)v4;
	} while (v4 > x_DWORD_EA3E4[0]);
	return result;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00014C40) --------------------------------------------------------
__int16 sub_14C40(int a1)
{
	return *(x_WORD *)(a1 + 26) + *(char *)(a1 + 64) + (*(char *)(a1 + 63) << 7);
}

//----- (00014C60) --------------------------------------------------------
bool sub_14C60(int a1, int a2)
{
	return sub_14C40(a2) == *(x_WORD *)(a1 + 152);
}

//----- (00014C90) --------------------------------------------------------
signed int sub_14C90(int a1, int a2, signed int a3, signed int a4)
{
	signed int v4; // eax
	signed int v6; // eax

	*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 14) = 0;
	if (!a2)
	{
		v4 = sub_58490((x_WORD *)(a1 + 76), (x_WORD *)(a1 + 154));
		if (v4 > a3)
		{
			if (v4 > a4 && sub_15170(a1, 3u))
			{
				if (!sub_156F0(a1, 3u))
					sub_14E10(a1, 3u);
			}
			else
			{
				*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 12) = *(x_WORD *)(a1 + 132);
				*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 14) = 1;
			}
			return 0;
		}
	LABEL_16:
		*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 12) = 0;
		*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 14) = 1;
		return 1;
	}
	v6 = sub_58490((x_WORD *)(a1 + 76), (x_WORD *)(a2 + 76));
	if (v6 <= a3)
		goto LABEL_16;
	if (v6 > a4 && sub_15170(a1, 3u))
	{
		if (!sub_156F0(a1, 3u))
			sub_14E10(a1, 3u);
	}
	else
	{
		*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 12) = *(x_WORD *)(a1 + 132);
		*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 14) = 1;
	}
	return 0;
}

//----- (00014E10) --------------------------------------------------------
signed int sub_14E10(int a1, unsigned __int8 a2)
{
	unsigned int v2; // eax
	signed int result; // eax
	int v4; // eax
	unsigned int v5; // eax
	unsigned int v6; // edi
	int v7; // esi
	unsigned int v8; // esi
	unsigned int v9; // eax

	if (!sub_15170(a1, a2))
		return 0;
	*(x_BYTE *)(a1 + 13) &= 0xFEu;
	if (a2 > 0x16u)
		return 0;
	switch (a2)
	{
	case 0u:
	case 1u:
	case 7u:
	case 0x16u:
		v6 = sub_146C0(a1, a2);
		if (!v6
			|| *(x_WORD *)(*(x_DWORD *)(a1 + 164) + 418) < 0
			|| (unsigned __int16)sub_582B0(*(x_WORD *)(a1 + 28), *(x_WORD *)(a1 + 32)) >= 0xAAu)
		{
			return 0;
		}
		*(x_WORD *)(a1 + 30) = sub_58210((x_WORD *)(a1 + 76), (x_WORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)] + 76));
		++*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 418);
		v7 = *(x_DWORD *)(a1 + 164);
		if (*(x_WORD *)(v7 + 418) >= 8)
			*(x_WORD *)(v7 + 418) = ((*(signed __int16 *)(v7 + 582)
				- 255
				- (__CFSHL__((*(signed __int16 *)(v7 + 582) - 255) >> 31, 3)
					+ 8 * ((*(signed __int16 *)(v7 + 582) - 255) >> 31))) >> 3)
			- 1;
		if (sub_5F660(a1, v6, 0) != 1)
			return 0;
		*(x_WORD *)(2 * a2 + *(x_DWORD *)(a1 + 164) + 871) = x_WORD_D3F4C[a2];
		return 1;
	case 2u:
		v2 = sub_146C0(a1, a2);
		if (!v2)
			return 0;
		if (*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 58))
		{
			if (sub_5F660(a1, v2, 0) != 1)
				return 0;
			*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 2 * a2 + 871) = x_WORD_D3F4C[a2];
			result = 1;
		}
		else
		{
			v4 = sub_4A190(a1 + 154, 3, 2);
			if (v4)
			{
				*(x_WORD *)(v4 + 26) = *(x_WORD *)(a1 + 26);
				*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 58) = (v4 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
			}
			result = 1;
		}
		break;
	case 3u:
		v5 = sub_146C0(a1, a2);
		if (!v5 || sub_5F660(a1, v5, 0) != 1)
			return 0;
		*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 2 * a2 + 871) = x_WORD_D3F4C[a2];
		return 1;
	case 4u:
	case 9u:
	case 0xDu:
	case 0xEu:
	case 0x12u:
	case 0x13u:
	case 0x15u:
		v8 = sub_146C0(a1, a2);
		if (!v8)
			return 0;
		if ((unsigned __int16)sub_582B0(*(x_WORD *)(a1 + 28), *(x_WORD *)(a1 + 32)) >= 0xE3u)
			return 0;
		*(x_WORD *)(a1 + 30) = sub_58210((x_WORD *)(a1 + 76), (x_WORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)] + 76));
		if (sub_5F660(a1, v8, 0) != 1)
			return 0;
		*(x_WORD *)(2 * a2 + *(x_DWORD *)(a1 + 164) + 871) = x_WORD_D3F4C[a2];
		return 1;
	case 5u:
	case 6u:
	case 8u:
	case 0xAu:
	case 0xBu:
	case 0xCu:
	case 0x10u:
	case 0x11u:
	case 0x14u:
		v9 = sub_146C0(a1, a2);
		if (!v9 || sub_5F660(a1, v9, 0) != 1)
			return 0;
		*(x_WORD *)(2 * a2 + *(x_DWORD *)(a1 + 164) + 871) = x_WORD_D3F4C[a2];
		return 1;
	case 0xFu:
		return 0;
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00015170) --------------------------------------------------------
unsigned int sub_15170(int a1, unsigned __int8 a2)
{
	unsigned int v2; // eax
	unsigned int v3; // esi
	int v4; // eax
	int v5; // edx
	unsigned int v7; // eax
	unsigned int v8; // esi
	int v9; // eax
	unsigned int v10; // eax
	unsigned int v11; // esi
	int v12; // eax
	int v13; // eax
	int v14; // edi
	unsigned int v15; // eax
	unsigned int v16; // esi
	int v17; // eax
	int v18; // eax
	int v19; // edx
	__int64 v20; // rax
	unsigned int v21; // eax
	unsigned int v22; // esi
	int v23; // eax
	int v24; // eax
	int v25; // edi
	unsigned int v26; // eax
	unsigned int v27; // esi
	int v28; // eax
	int v29; // edx

	if (a2 > 0x16u)
	{
	LABEL_43:
		if (a2 < 0x1Au)
		{
			v26 = sub_146C0(a1, a2);
			v27 = v26;
			if (v26)
			{
				v28 = 80 * a2 + 26 * *(char *)(v26 + 70);
				if (*(x_DWORD *)(a1 + 140) >= *(int *)((char *)&x_DWORD_DA822 + v28))
				{
					v29 = *(x_DWORD *)(a1 + 144);
					if (v29 >= *(int *)((char *)&x_DWORD_DA81E + v28)
						&& !*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 2 * a2 + 871)
						&& v29 >= *(x_DWORD *)(v27 + 140))
					{
						return v27;
					}
				}
			}
		}
	}
	else
	{
		switch (a2)
		{
		case 0u:
		case 7u:
		case 0xDu:
		case 0xEu:
		case 0x16u:
			v21 = sub_146C0(a1, a2);
			v22 = v21;
			if (!v21)
				return 0;
			v23 = 80 * a2 + 26 * *(char *)(v21 + 70);
			if (*(x_DWORD *)(a1 + 140) < *(int *)((char *)&x_DWORD_DA822 + v23))
				return 0;
			if (*(x_DWORD *)(a1 + 144) < *(int *)((char *)&x_DWORD_DA81E + v23))
				return 0;
			v24 = *(x_DWORD *)(a1 + 164);
			if (*(x_WORD *)(v24 + 2 * a2 + 871))
				return 0;
			if (*(x_DWORD *)(a1 + 144) < *(x_DWORD *)(v22 + 140))
				return 0;
			v25 = ((((255
				- *(signed __int16 *)(v24 + 580)
				- (__CFSHL__((255 - *(signed __int16 *)(v24 + 580)) >> 31, 2)
					+ 4 * ((255 - *(signed __int16 *)(v24 + 580)) >> 31))) >> 2)
				+ 20) << 11)
				/ 360;
			if ((unsigned __int16)sub_582B0(*(x_WORD *)(a1 + 28), *(x_WORD *)(a1 + 32)) >= v25)
				return 0;
			return v22;
		case 1u:
		case 9u:
		case 0x10u:
		case 0x12u:
		case 0x13u:
		case 0x15u:
			v10 = sub_146C0(a1, a2);
			v11 = v10;
			if (!v10)
				return 0;
			v12 = 26 * *(char *)(v10 + 70) + 80 * a2;
			if (*(x_DWORD *)(a1 + 140) < *(int *)((char *)&x_DWORD_DA822 + v12))
				return 0;
			if (*(x_DWORD *)(a1 + 144) < *(int *)((char *)&x_DWORD_DA81E + v12))
				return 0;
			if (*(x_WORD *)(v11 + 46))
				return 0;
			v13 = *(x_DWORD *)(a1 + 164);
			if (*(x_WORD *)(v13 + 2 * a2 + 871))
				return 0;
			if (*(x_DWORD *)(a1 + 144) < *(x_DWORD *)(v11 + 140))
				return 0;
			v14 = ((((255
				- *(signed __int16 *)(v13 + 580)
				- (__CFSHL__((255 - *(signed __int16 *)(v13 + 580)) >> 31, 2)
					+ 4 * ((255 - *(signed __int16 *)(v13 + 580)) >> 31))) >> 2)
				+ 20) << 11)
				/ 360;
			if ((unsigned __int16)sub_582B0(*(x_WORD *)(a1 + 28), *(x_WORD *)(a1 + 32)) >= v14)
				return 0;
			return v11;
		case 2u:
			v15 = sub_146C0(a1, a2);
			v16 = v15;
			if (!v15)
				return 0;
			v17 = 80 * a2 + 26 * *(char *)(v15 + 70);
			if (*(x_DWORD *)(a1 + 140) < *(int *)((char *)&x_DWORD_DA822 + v17)
				|| *(x_DWORD *)(a1 + 144) < *(int *)((char *)&x_DWORD_DA81E + v17))
			{
				return 0;
			}
			v18 = *(x_DWORD *)(a1 + 164);
			v19 = v18 + 2 * a2;
			if (*(x_WORD *)(v18 + 58))
			{
				if (!*(x_WORD *)(v16 + 46) && !*(x_WORD *)(v19 + 871))
				{
					if (sub_11A10((x_WORD *)x_DWORD_EA3E4[*(unsigned __int16 *)(v18 + 58)]))
					{
						if (*(x_DWORD *)(a1 + 144) >= *(x_DWORD *)(v16 + 140))
						{
							v20 = 255 - *(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 580);
							if ((unsigned __int16)sub_582B0(*(x_WORD *)(a1 + 28), *(x_WORD *)(a1 + 32)) < ((((signed int)(v20 - (__CFSHL__(HIDWORD(v20), 2) + 4 * HIDWORD(v20))) >> 2)
								+ 20) << 11)
								/ 360)
								return v16;
						}
					}
				}
			}
			else if (!*(x_WORD *)(v19 + 871) && *(x_DWORD *)(a1 + 144) >= *(x_DWORD *)(v16 + 140))
			{
				return v16;
			}
			break;
		case 3u:
			v2 = sub_146C0(a1, a2);
			v3 = v2;
			if (!v2)
				return 0;
			v4 = 80 * a2 + 26 * *(char *)(v2 + 70);
			if (*(x_DWORD *)(a1 + 140) < *(int *)((char *)&x_DWORD_DA822 + v4))
				return 0;
			v5 = *(x_DWORD *)(a1 + 144);
			if (v5 < *(int *)((char *)&x_DWORD_DA81E + v4) || v5 < *(x_DWORD *)(v3 + 140))
				return 0;
			return v3;
		case 4u:
		case 6u:
		case 8u:
		case 0xBu:
			v7 = sub_146C0(a1, a2);
			v8 = v7;
			if (!v7)
				return 0;
			v9 = 26 * *(char *)(v7 + 70) + 80 * a2;
			if (*(x_DWORD *)(a1 + 140) < *(int *)((char *)&x_DWORD_DA822 + v9)
				|| *(x_DWORD *)(a1 + 144) < *(int *)((char *)&x_DWORD_DA81E + v9)
				|| *(x_WORD *)(v8 + 46)
				|| *(x_WORD *)(*(x_DWORD *)(a1 + 164) + 2 * a2 + 871)
				|| *(x_DWORD *)(a1 + 144) < *(x_DWORD *)(v8 + 140))
			{
				return 0;
			}
			return v8;
		case 5u:
		case 0xAu:
		case 0xCu:
		case 0xFu:
		case 0x11u:
		case 0x14u:
			goto LABEL_43;
		}
	}
	return 0;
}
// DA81E: using guessed type int x_DWORD_DA81E;
// DA822: using guessed type int x_DWORD_DA822;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000155E0) --------------------------------------------------------
signed int sub_155E0(int a1)
{
	unsigned int v1; // ebx
	int v2; // eax
	__int64 v4; // rax

	v1 = sub_146C0(a1, 2u);
	if (v1)
	{
		v2 = *(x_DWORD *)(a1 + 164);
		if (*(x_WORD *)(v2 + 58))
		{
			if (!*(x_WORD *)(v1 + 46) && !*(x_WORD *)(v2 + 875))
			{
				if (sub_11A10((x_WORD *)x_DWORD_EA3E4[*(unsigned __int16 *)(v2 + 58)]))
				{
					if (*(x_DWORD *)(a1 + 140) >= *(x_DWORD *)(v1 + 140))
					{
						v4 = 255 - *(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 580);
						if ((unsigned __int16)sub_582B0(*(x_WORD *)(a1 + 28), *(x_WORD *)(a1 + 32)) < ((((signed int)(v4 - (__CFSHL__(HIDWORD(v4), 2) + 4 * HIDWORD(v4))) >> 2)
							+ 20) << 11)
							/ 360)
							return 1;
					}
				}
			}
		}
		else if (!*(x_WORD *)(v2 + 875) && *(x_DWORD *)(a1 + 140) >= *(x_DWORD *)(v1 + 140))
		{
			return 1;
		}
	}
	return 0;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000156F0) --------------------------------------------------------
bool sub_156F0(int a1, unsigned __int8 a2)
{
	unsigned int v2; // eax
	bool result; // eax

	result = 0;
	if (a2 < 0x1Au)
	{
		v2 = sub_146C0(a1, a2);
		if (v2)
		{
			if (*(x_WORD *)(v2 + 46) > 0)
				result = 1;
		}
	}
	return result;
}

//----- (00015730) --------------------------------------------------------
bool sub_15730(int a1, unsigned __int8 a2)
{
	return *(x_DWORD *)(a1 + 140) >= *(x_DWORD *)(sub_146C0(a1, a2) + 140);
}

//----- (00015760) --------------------------------------------------------
unsigned int sub_15760(int a1, unsigned __int8 a2)
{
	unsigned int result; // eax

	result = sub_146C0(a1, a2);
	if (!result || *(x_WORD *)(result + 46) <= 0)
		result = 0;
	return result;
}

//----- (00015790) --------------------------------------------------------
char sub_15790(int a1)
{
	int v1; // eax
	int v2; // esi
	int v3; // eax
	int v4; // ecx
	int v5; // edi
	int i; // edi
	char *j; // esi
	int k; // edi
	char v10; // dl
	int v11; // edi
	int v12; // [esp+0h] [ebp-4h]

	v12 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
	v1 = (*(x_DWORD *)(a1 + 140) - (__CFSHL__(*(x_DWORD *)(a1 + 140) >> 31, 2) + 4 * (*(x_DWORD *)(a1 + 140) >> 31))) >> 2;
	if (v1 <= *(x_DWORD *)(a1 + 144))
	{
		v2 = *(x_DWORD *)(a1 + 164);
		if (*(x_WORD *)(v2 + 420))
		{
			v3 = v1 + 6000;
			v4 = *(x_DWORD *)(a1 + 140);
			if (v3 >= v4)
				v3 = v4 / 2;
			if (v3 <= *(x_DWORD *)(a1 + 144))
				*(x_WORD *)(v2 + 420) = 0;
		}
	}
	else
	{
		*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 420) = 1;
	}
	if (!*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 420))
	{
		if (sub_15760(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)], 8u))
		{
			v5 = *(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 580);
			if (rand() % 255 < v5)
			{
				for (i = *(char *)(*(x_DWORD *)(a1 + 164) + 1060); i >= 0; i--)
				{
					if ((signed __int16)sub_15F20(a1, i, 7) == 7)
						return 7;
				}
			}
		}
		for (j = (char *)&unk_D3F80; ; j++)
		{
			v11 = *j;
			if (v11 == -1)
				break;
			for (k = *(char *)(v11 + *(x_DWORD *)(a1 + 164) + 1053); k >= 0; k--)
			{
				if ((signed __int16)sub_15F20(a1, k, *j) == *j)
				{
					if (*j == 19)
					{
						v10 = *(x_BYTE *)(v12 + 64);
						if (!v10 || v10 == 1)
							return *j;
					}
					if (*j != 19)
						return *j;
				}
			}
		}
	}
	return -1;
}
// 8C278: using guessed type int rand(void);
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00015910) --------------------------------------------------------
char sub_15910(x_DWORD *a1)
{
	int v1; // eax
	int v2; // esi
	int v3; // eax
	int v4; // ecx
	unsigned __int8 *i; // esi
	signed __int16 j; // di
	__int16 v7; // ax
	int v8; // eax

	v1 = (a1[35] - (__CFSHL__(a1[35] >> 31, 2) + 4 * (a1[35] >> 31))) >> 2;
	if (v1 <= a1[36])
	{
		v2 = a1[41];
		if (*(x_WORD *)(v2 + 420))
		{
			v3 = v1 + 6000;
			v4 = a1[35];
			if (v3 >= v4)
				v3 = v4 / 2;
			if (v3 <= a1[36])
				*(x_WORD *)(v2 + 420) = 0;
		}
	}
	else
	{
		*(x_WORD *)(a1[41] + 420) = 1;
	}
	if (!*(x_WORD *)(a1[41] + 420))
	{
		for (i = (unsigned __int8 *)&unk_D3F89; ; i++)
		{
			v8 = *i;
			if (v8 == -1)
				break;
			for (j = *(char *)(a1[41] + v8 + 1053); j >= 0; j--)
			{
				v7 = sub_15F20((int)a1, j, *i);
				if (v7 == *i)
					return v7;
			}
		}
	}
	LOBYTE(v7) = -1;
	return v7;
}

//----- (000159E0) --------------------------------------------------------
void sub_159E0()
{
	unsigned int v0; // edi
	unsigned int v1; // esi
	unsigned int v2; // ecx
	unsigned __int8 v3; // al
	int v4; // ebx
	unsigned __int8 v5; // al
	int v6; // ebx
	unsigned __int8 v7; // al
	int v8; // edx
	int v9; // eax
	unsigned int v10; // eax
	unsigned int v11; // [esp+4h] [ebp-8h]

	v0 = x_D41A0_BYTEARRAY_4[0x9683];
	if (v0 > x_DWORD_EA3E4[0])
	{
		while (1)
		{
			if (*(x_BYTE *)(v0 + 13) & 0x20)
				goto LABEL_48;
			v1 = x_DWORD_EA3E4[*(signed __int16 *)(v0 + 26)];
			if (v1 <= x_DWORD_EA3E4[0])
				goto LABEL_48;
			if (*(x_BYTE *)(v1 + 63) != 3)
				goto LABEL_48;
			v2 = x_DWORD_EA3E4[*(unsigned __int16 *)(v0 + 150)];
			if (v2 <= x_DWORD_EA3E4[0])
				goto LABEL_48;
			*(x_BYTE *)(v0 + 13) |= 0x20u;
			v3 = *(x_BYTE *)(v2 + 63);
			if (v3 < 3u)
				goto LABEL_48;
			if (v3 <= 3u)
				break;
			if (v3 != 10)
				goto LABEL_48;
			if (*(x_BYTE *)(v0 + 64) != 1)
				goto LABEL_48;
			if (*(x_BYTE *)(v2 + 64) != 39)
				goto LABEL_48;
			v10 = x_DWORD_EA3E4[*(unsigned __int16 *)(v2 + 148)];
			v11 = v10;
			if (v10 <= x_DWORD_EA3E4[0] || *(x_BYTE *)(v10 + 63) != 3)
				goto LABEL_48;
			v6 = ((*(x_DWORD *)(v2 + 144) - (__CFSHL__(*(x_DWORD *)(v2 + 144) >> 31, 2) + 4 * (*(x_DWORD *)(v2 + 144) >> 31))) >> 2)
				+ *(unsigned __int16 *)(8 * *(signed __int16 *)(*(x_DWORD *)(v1 + 164) + 56) + *(x_DWORD *)(v10 + 164) + 516);
			if (v6 < 0)
				v6 = 0;
			if (v6 > 0xFFFF)
				LOWORD(v6) = -1;
			v9 = *(signed __int16 *)(*(x_DWORD *)(v1 + 164) + 56);
			v8 = *(x_DWORD *)(v11 + 164);
		LABEL_47:
			*(x_WORD *)(v8 + 8 * v9 + 516) = v6;
		LABEL_48:
			v0 = *(x_DWORD *)v0;
			if (v0 <= x_DWORD_EA3E4[0])
				return;
		}
		if (*(x_BYTE *)(v2 + 64) == 2)
		{
			v4 = *(unsigned __int16 *)(*(x_DWORD *)(x_DWORD_EA3E4[*(signed __int16 *)(v2 + 26)] + 164)
				+ 8 * *(signed __int16 *)(*(x_DWORD *)(v1 + 164) + 56)
				+ 516);
			v5 = *(x_BYTE *)(v0 + 64);
			if (v5 < 0xAu)
			{
				if (v5 >= 3u && v5 <= 4u)
					goto LABEL_17;
			LABEL_18:
				v4 += 1000;
			}
			else if (v5 > 0xAu)
			{
				if (v5 != 11)
					goto LABEL_18;
			LABEL_17:
				v4 += 5000;
			}
			if (v4 < 0)
				v4 = 0;
			if (v4 > 0xFFFF)
				v4 = 0xFFFF;
			*(x_WORD *)(*(x_DWORD *)(x_DWORD_EA3E4[*(signed __int16 *)(v2 + 26)] + 164)
				+ 8 * *(signed __int16 *)(*(x_DWORD *)(v1 + 164) + 56)
				+ 516) = v4;
			if (v4 > 50000 - *(x_DWORD *)(v1 + 140) / 10 * *(signed __int16 *)(*(x_DWORD *)(v2 + 164) + 578) / 255)
				*(x_WORD *)(*(x_DWORD *)(x_DWORD_EA3E4[*(signed __int16 *)(v2 + 26)] + 164)
					+ 8 * *(signed __int16 *)(*(x_DWORD *)(v1 + 164) + 56)
					+ 518) = 1;
			goto LABEL_48;
		}
		v6 = *(unsigned __int16 *)(*(x_DWORD *)(x_DWORD_EA3E4[*(signed __int16 *)(v2 + 26)] + 164)
			+ 8 * *(signed __int16 *)(*(x_DWORD *)(v1 + 164) + 56)
			+ 516);
		v7 = *(x_BYTE *)(v0 + 64);
		if (v7 < 0xAu)
		{
			if (v7 < 3u || v7 > 4u)
				goto LABEL_32;
		}
		else
		{
			if (v7 <= 0xAu)
			{
			LABEL_33:
				if (v6 < 0)
					v6 = 0;
				if (v6 > 0xFFFF)
					LOWORD(v6) = -1;
				v8 = *(x_DWORD *)(x_DWORD_EA3E4[*(signed __int16 *)(v2 + 26)] + 164);
				v9 = *(signed __int16 *)(*(x_DWORD *)(v1 + 164) + 56);
				goto LABEL_47;
			}
			if (v7 != 11)
			{
			LABEL_32:
				v6 += 500;
				goto LABEL_33;
			}
		}
		v6 += 3000;
		goto LABEL_33;
	}
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00015CB0) --------------------------------------------------------
unsigned int sub_15CB0(unsigned int a1, int a2)
{
	unsigned int v2; // esi
	unsigned int i; // ebx
	unsigned int v4; // eax
	unsigned int result; // eax

	v2 = -1;
	for (i = x_D41A0_BYTEARRAY_4[0x9683]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
	{
		if (*(unsigned __int16 *)(i + 150) == *(signed __int16 *)(a2 + 26))
		{
			v4 = sub_584D0((x_WORD *)(a2 + 76), (x_WORD *)(i + 76));
			if (v4 < v2)
			{
				v2 = v4;
				a1 = i;
			}
		}
	}
	if (v2 >= 0x1900000)
		result = 0;
	else
		result = a1;
	return result;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00015D20) --------------------------------------------------------
int sub_15D20(int a1)
{
	int result; // eax

	result = *(x_DWORD *)(a1 + 164);
	if (!*(x_BYTE *)(result + 1118))
		*(x_WORD *)(result + 16) = 80;
	return result;
}

//----- (00015D40) --------------------------------------------------------
char sub_15D40(__int16 a1, int a2, int a3)
{
	unsigned int result; // eax
	signed __int16 i; // si
	signed __int16 v5; // si
	signed __int16 v6; // si

	result = sub_584D0((x_WORD *)(a2 + 76), (x_WORD *)(a3 + 76));
	if (result >= 0x100000)
		return result;
	result = *(x_BYTE *)(a3 + 64);
	if (result < 3u)
	{
		if (result)
			return result;
	}
	else if (result > 3u)
	{
		if (result == 4)
		{
			result = *(x_DWORD *)(a2 + 164);
			v6 = *(char *)(result + 1059);
			if (v6 >= 0)
			{
				while (1)
				{
					result = sub_15F20(a2, v6, 6);
					if (result == 6)
						break;
					if (--v6 < 0)
						return result;
				}
				result = sub_14E10(a2, 6u);
			}
		}
		return result;
	}
	result = *(x_DWORD *)(a2 + 164);
	for (i = *(char *)(result + 1061); i >= 0; i--)
	{
		result = sub_15F20(a2, i, 8);
		a1 = result;
		if (result == 8)
		{
			result = sub_14E10(a2, 8u);
			break;
		}
	}
	if (a1 != 8)
	{
		result = *(x_DWORD *)(a2 + 164);
		v5 = *(char *)(result + 1059);
		if (v5 >= 0)
		{
			while (1)
			{
				result = sub_15F20(a2, v5, 6);
				if (result == 6)
					break;
				if (--v5 < 0)
					return result;
			}
			result = sub_14E10(a2, 6u);
		}
	}
	return result;
}

//----- (00015E60) --------------------------------------------------------
bool sub_15E60(int a1)
{
	return sub_146C0(a1, 0)
		|| sub_146C0(a1, 7u)
		|| sub_146C0(a1, 0x12u)
		|| sub_146C0(a1, 0x10u)
		|| sub_146C0(a1, 0x14u)
		|| sub_146C0(a1, 0x15u)
		|| sub_146C0(a1, 9u);
}

//----- (00015EE0) --------------------------------------------------------
char sub_15EE0()
{
	unsigned int v0; // eax

	v0 = x_D41A0_BYTEARRAY_4[0x9677];
	if (v0 <= x_DWORD_EA3E4[0])
		return 1;
	do
	{
		if (!*(x_BYTE *)(v0 + 64))
			x_DWORD_E8840 = v0;
		v0 = *(x_DWORD *)v0;
	} while (v0 > x_DWORD_EA3E4[0]);
	return 1;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// E8840: using guessed type int x_DWORD_E8840;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00015F20) --------------------------------------------------------
signed int sub_15F20(int a1, signed __int16 a2, signed int a3)
{
	int v3; // ebx
	int v4; // eax
	int v5; // ebx
	signed int result; // eax

	v3 = 80 * (signed __int16)a3;
	if ((unsigned __int8)(*xadataspellsdat.var28_begin_buffer)[v3] <= a2)
		return 0;
	v4 = sub_146C0(a1, a3);
	if (!v4)
		return 0;
	sub_6D5E0(v4, a2);
	if (!sub_15170(a1, a3))
		return 0;
	v5 = 26 * a2 + v3;
	if (*(x_DWORD *)(a1 + 140) < *(int *)((char *)&x_DWORD_DA822 + v5)
		|| *(x_DWORD *)(a1 + 144) < *(int *)((char *)&x_DWORD_DA81E + v5))
	{
		result = -1;
	}
	else
	{
		result = a3;
	}
	return result;
}
// DA81E: using guessed type int x_DWORD_DA81E;
// DA822: using guessed type int x_DWORD_DA822;

//----- (00015FC0) --------------------------------------------------------
signed int sub_15FC0(x_WORD *a1)
{
	unsigned __int8 v1; // bl
	int v2; // esi
	unsigned int i; // esi
	char v5; // ah
	unsigned int v6; // eax
	unsigned int k; // esi
	unsigned int v8; // eax
	int v9; // eax
	unsigned int v11; // [esp+0h] [ebp-18h]
	int v12; // [esp+4h] [ebp-14h]
	unsigned int v13; // [esp+8h] [ebp-10h]
	unsigned int v14; // [esp+Ch] [ebp-Ch]
	char *j; // [esp+10h] [ebp-8h]
	int v16; // [esp+14h] [ebp-4h]

	v11 = 0;
	v16 = 0;
	v13 = -1;
	v14 = -1;
	v1 = 0;
	v2 = x_DWORD_EA3E4[(unsigned __int16)a1[75]];
	if (!sub_156F0((int)a1, 4u) || !sub_14C60((int)a1, v2))
	{
		v12 = sub_146C0((int)a1, 4u);
		if (!v12)
			return 0;
		for (i = x_D41A0_BYTEARRAY_4[0x9677]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
		{
			if (*(x_WORD *)(i + 26) != a1[13])
			{
				v5 = *(x_BYTE *)(i + 64);
				if (!v5 || v5 == 1)
				{
					v6 = sub_583F0((x_WORD*)a1 + 38, (x_WORD *)(i + 76));
					if (v6 < v14)
					{
						v11 = i;
						v14 = v6;
					}
				}
			}
		}
		if (v14 > 0x1400)
			v11 = 0;
		if (!v11)
			return 0;
		for (j = (char *)&unk_D3F91; ; j++)
		{
			v9 = *j;
			if (v9 == -1)
				break;
			for (k = x_D41A0_BYTEARRAY_4[v9 + 38403]; k > x_DWORD_EA3E4[0]; k = *(x_DWORD *)k)
			{
				if (*(x_WORD *)(k + 26) != a1[13])
				{
					v8 = sub_583F0((x_WORD *)(v11 + 76), (x_WORD *)(k + 76));
					if (v8 < v13)
					{
						v16 = k;
						v13 = v8;
						v1 = *j;
					}
				}
			}
		}
		if (!v16 || v13 >= 0x1400 || !v1)
			return 0;
		if (v1 < 0x10u)
		{
			if (v1 == 2)
			{
			LABEL_35:
				sub_6D5E0(v12, 0);
				goto LABEL_38;
			}
		}
		else
		{
			if (v1 <= 0x10u)
			{
				sub_6D5E0(v12, 2);
				goto LABEL_38;
			}
			if (v1 >= 0x13u)
			{
				if (v1 > 0x13u)
				{
					if (v1 == 25)
						sub_6D5E0(v12, 1);
					goto LABEL_38;
				}
				goto LABEL_35;
			}
		}
	LABEL_38:
		a1[75] = (v16 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
		a1[76] = sub_14C40(v16);
		return 1;
	}
	return 1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000161A0) --------------------------------------------------------
signed int sub_161A0(int a1)
{
	int v1; // esi
	int v2; // eax
	int v3; // eax
	unsigned int v4; // eax
	int v5; // edi
	int v6; // edi
	unsigned int i; // esi
	char v8; // cl
	unsigned int v9; // eax
	signed __int8 v10; // al
	signed int result; // eax
	int v12; // eax
	__int16 v13; // ax
	unsigned int v14; // [esp+4h] [ebp-8h]
	unsigned int v15; // [esp+8h] [ebp-4h]

	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
	v15 = -1;
	if (sub_14C60(a1, x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)]))
	{
		sub_14E10(a1, 4u);
		sub_584D0((x_WORD *)(a1 + 76), (x_WORD *)(v1 + 76));
		*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u *)(a1 + 76), (Bit16u *)(v1 + 76));
		v2 = *(signed __int16 *)(a1 + 80) - (*(signed __int16 *)(v1 + 80) + 512);
		if (*(signed __int16 *)(a1 + 80) != *(signed __int16 *)(v1 + 80) + 512)
		{
			if (v2 <= 0)
				LOWORD(v2) = -1;
			else
				LOWORD(v2) = 1;
		}
		*(x_WORD *)(a1 + 80) += v2 * *(x_WORD *)(*(x_DWORD *)(a1 + 160) + 14);
		*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u *)(a1 + 76), (Bit16u *)(v1 + 76));
		v3 = *(signed __int16 *)(a1 + 80) - (*(signed __int16 *)(v1 + 80) + 512);
		if (*(signed __int16 *)(a1 + 80) != *(signed __int16 *)(v1 + 80) + 512)
		{
			if (*(signed __int16 *)(a1 + 80) - (*(signed __int16 *)(v1 + 80) + 512) <= 0)
				LOWORD(v3) = -1;
			else
				LOWORD(v3) = 1;
		}
		*(x_WORD *)(a1 + 80) += v3 * *(x_WORD *)(*(x_DWORD *)(a1 + 160) + 14);
		v4 = sub_146C0(a1, 4u);
		v14 = v4;
		if (v4 && !*(x_BYTE *)(v4 + 70))
		{
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			v5 = 2 * ((signed int)(*(unsigned __int16 *)(a1 + 20) % 0x9Du) / 79);
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			*(x_WORD *)(a1 + 32) += (v5 - 1) * (*(x_WORD *)(a1 + 20) % 0x55u);
			*(x_BYTE *)(a1 + 33) &= 7u;
		}
		v6 = 0;
		for (i = x_D41A0_BYTEARRAY_4[0x9677]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
		{
			if (*(x_WORD *)(i + 26) != *(x_WORD *)(a1 + 26))
			{
				v8 = *(x_BYTE *)(i + 64);
				if (!v8 || v8 == 1)
				{
					v9 = sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(i + 76));
					if (v9 < v15)
					{
						v6 = i;
						v15 = v9;
					}
				}
			}
		}
		if (v6 && v15 < 0x1400 && v15 > 0xA00)
		{
			*(x_WORD *)(a1 + 150) = (v6 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
			*(x_WORD *)(a1 + 152) = sub_14C40(v6);
			v10 = sub_15790(a1);
			*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 12) = 0;
			*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 14) = 1;
			if (v10 != -1 && sub_14E10(a1, v10))
			{
				sub_16580(a1);
				return 1;
			}
		}
		else
		{
			*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v6 + 76));
			v12 = *(signed __int16 *)(a1 + 80) - (*(signed __int16 *)(v6 + 80) + 512);
			if (*(signed __int16 *)(a1 + 80) != *(signed __int16 *)(v6 + 80) + 512)
			{
				if (*(signed __int16 *)(a1 + 80) - (*(signed __int16 *)(v6 + 80) + 512) <= 0)
					LOWORD(v12) = -1;
				else
					LOWORD(v12) = 1;
			}
			*(x_WORD *)(a1 + 80) += v12 * *(x_WORD *)(*(x_DWORD *)(a1 + 160) + 14);
		}
		if (v14)
		{
			if (*(x_BYTE *)(v14 + 70))
				v13 = *(x_WORD *)(a1 + 132);
			else
				v13 = 3 * *(x_WORD *)(a1 + 132);
			*(x_WORD *)(a1 + 130) = v13;
		}
		sub_16580(a1);
		result = 1;
	}
	else
	{
		sub_16580(a1);
		result = 0;
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000164B0) --------------------------------------------------------
bool sub_164B0(int a1)
{
	return sub_146C0(a1, 0x11u)
		|| sub_146C0(a1, 0x10u)
		|| sub_146C0(a1, 0x12u)
		|| sub_146C0(a1, 7u)
		|| sub_146C0(a1, 9u)
		|| sub_146C0(a1, 0x14u)
		|| sub_146C0(a1, 0x13u)
		|| sub_146C0(a1, 0x15u)
		|| sub_146C0(a1, 0);
}

//----- (00016580) --------------------------------------------------------
signed int sub_16580(int a1)
{
	__int16 v1; // di
	__int16 v2; // dx
	signed int v3; // esi
	signed __int16 v4; // ax
	signed int result; // eax
	int v6; // eax
	int v7; // eax
	unsigned __int8 v8; // [esp+0h] [ebp-4h]

	LOBYTE(v2) = 0;
	v8 = 0;
	v1 = *(x_WORD *)(a1 + 28);
	HIBYTE(v2) = *(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 1118);
	v3 = 0;
	if (SHIBYTE(v2) <= 2 || SHIBYTE(v2) >= 8)
	{
		if (*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 1118) <= 7)
			v4 = (unsigned __int8)sub_169C0(a1);
		else
			v4 = 0;
	}
	else
	{
		v4 = 3;
	}
	switch (v4)
	{
	case 0:
		*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 1118) = 0;
		return 0;
	case 1:
		v8 = sub_16730(v2, a1, 0);
		if (v8)
			*(x_WORD *)(a1 + 28) = x_WORD_D3FCE[v8];
		goto LABEL_11;
	case 2:
		v8 = sub_16730(v2, a1, 1);
		if (v8)
			*(x_WORD *)(a1 + 28) = x_WORD_D3FE8[v8];
		goto LABEL_11;
	case 3:
	case 4:
	case 5:
	case 6:
	case 7:
	case 8:
		result = 0;
		++*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 1118);
		break;
	default:
	LABEL_11:
		if (v8)
		{
			v6 = *(x_DWORD *)(a1 + 164);
			v3 = 1;
			if (*(char *)(v6 + 1119) != v8)
				*(x_BYTE *)(v6 + 1119) = v8;
			if (v1 != *(x_WORD *)(a1 + 28))
			{
				v7 = *(x_DWORD *)(a1 + 164);
				*(x_WORD *)(a1 + 130) = 0;
				*(x_WORD *)(v7 + 12) = 0;
				*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 14) = 1;
			}
			*(x_WORD *)(a1 + 32) = *(x_WORD *)(a1 + 28);
		}
		result = v3;
		break;
	}
	return result;
}

//----- (00016730) --------------------------------------------------------
int sub_16730(int a1, int a2, char a3)
{
	int v3; // eax
	int v4; // eax
	int result; // eax
	int v6; // eax
	int v7; // eax
	int v8; // eax
	int v9; // eax
	int v10; // eax
	int v11; // eax
	int v12; // eax
	int v13; // [esp+0h] [ebp-8h]
	int v14; // [esp+4h] [ebp-4h]

	v14 = *(signed __int16 *)(a2 + 78) >> 8;
	v3 = *(signed __int16 *)(a2 + 76) >> 8;
	BYTE1(v3) = v14 - 1;
	LOWORD(a1) = 0;
	if (x_BYTE_10B4E0[(unsigned __int16)v3] == 8)
	{
		LOBYTE(a1) = 1;
	}
	else
	{
		BYTE1(v3) = v14 + 1;
		if (x_BYTE_10B4E0[(unsigned __int16)v3] == 8)
			LOBYTE(a1) = 4;
	}
	BYTE1(v3) = *(x_WORD *)(a2 + 78) >> 8;
	if (a3)
		LOBYTE(v3) = v3 + 1;
	else
		LOBYTE(v3) = v3 - 1;
	if (x_BYTE_10B4E0[(unsigned __int16)v3] == 8)
	{
		if (a3)
		{
			LOBYTE(a1) = a1 | 2;
			goto LABEL_18;
		}
	LABEL_17:
		LOBYTE(a1) = a1 | 8;
		goto LABEL_18;
	}
	v13 = *(signed __int16 *)(a2 + 76) >> 8;
	if (a3)
		LOBYTE(v3) = v13 - 1;
	else
		LOBYTE(v3) = v13 + 1;
	if (x_BYTE_10B4E0[(unsigned __int16)v3] == 8)
	{
		if (!a3)
		{
			LOBYTE(a1) = a1 | 2;
			goto LABEL_18;
		}
		goto LABEL_17;
	}
LABEL_18:
	if ((x_BYTE)a1)
		return a1;
	if (a3)
	{
		switch (*(x_BYTE *)(*(x_DWORD *)(a2 + 164) + 1119))
		{
		case 1:
		case 9:
			v9 = *(signed __int16 *)(a2 + 76) >> 8;
			BYTE1(v9) = (*(x_WORD *)(a2 + 78) >> 8) - 1;
			LOBYTE(v9) = v9 - 1;
			if (x_BYTE_10B4E0[(unsigned __int16)v9] != 8)
				return a1;
			LOWORD(a1) = 1544;
			return a1;
		case 2:
		case 3:
			v10 = *(signed __int16 *)(a2 + 76) >> 8;
			BYTE1(v10) = (*(x_WORD *)(a2 + 78) >> 8) - 1;
			LOBYTE(v10) = v10 + 1;
			if (x_BYTE_10B4E0[(unsigned __int16)v10] != 8)
				return a1;
			LOWORD(a1) = 3073;
			return a1;
		case 4:
		case 6:
			v11 = *(signed __int16 *)(a2 + 76) >> 8;
			BYTE1(v11) = (*(x_WORD *)(a2 + 78) >> 8) + 1;
			LOBYTE(v11) = v11 + 1;
			if (x_BYTE_10B4E0[(unsigned __int16)v11] != 8)
				return a1;
			LOWORD(a1) = 2306;
			return a1;
		case 8:
		case 0xC:
			v12 = *(signed __int16 *)(a2 + 76) >> 8;
			BYTE1(v12) = (*(x_WORD *)(a2 + 78) >> 8) + 1;
			LOBYTE(v12) = v12 - 1;
			if (x_BYTE_10B4E0[(unsigned __int16)v12] == 8)
				LOWORD(a1) = 772;
			return a1;
		default:
			return a1;
		}
		return a1;
	}
	switch (*(x_BYTE *)(*(x_DWORD *)(a2 + 164) + 1119))
	{
	case 1:
	case 3:
		v4 = *(signed __int16 *)(a2 + 76) >> 8;
		BYTE1(v4) = (*(x_WORD *)(a2 + 78) >> 8) - 1;
		LOBYTE(v4) = v4 + 1;
		if (x_BYTE_10B4E0[(unsigned __int16)v4] != 8)
			return a1;
		LOWORD(a1) = 770;
		result = a1;
		break;
	case 2:
	case 6:
		v6 = *(signed __int16 *)(a2 + 76) >> 8;
		BYTE1(v6) = (*(x_WORD *)(a2 + 78) >> 8) + 1;
		LOBYTE(v6) = v6 + 1;
		if (x_BYTE_10B4E0[(unsigned __int16)v6] != 8)
			return a1;
		LOWORD(a1) = 1540;
		result = a1;
		break;
	case 4:
		v7 = *(signed __int16 *)(a2 + 76) >> 8;
		BYTE1(v7) = (*(x_WORD *)(a2 + 78) >> 8) + 1;
		LOBYTE(v7) = v7 - 1;
		if (x_BYTE_10B4E0[(unsigned __int16)v7] != 8)
			return a1;
		LOWORD(a1) = 3080;
		result = a1;
		break;
	case 8:
	case 9:
		v8 = *(signed __int16 *)(a2 + 76) >> 8;
		BYTE1(v8) = (*(x_WORD *)(a2 + 78) >> 8) - 1;
		LOBYTE(v8) = v8 - 1;
		if (x_BYTE_10B4E0[(unsigned __int16)v8] != 8)
			return a1;
		LOWORD(a1) = 2305;
		result = a1;
		break;
	default:
		return a1;
	}
	return result;
}

//----- (000169C0) --------------------------------------------------------
char sub_169C0(int a1)
{
	int v1; // eax
	__int16 v2; // dx
	__int16 v3; // dx
	char result; // al
	unsigned __int16 v5; // si
	unsigned __int16 v6; // si
	int v7; // eax
	char v8; // dl
	unsigned __int8 v9; // [esp+0h] [ebp-1Ch]
	unsigned __int8 v10; // [esp+1h] [ebp-1Bh]
	int v11; // [esp+4h] [ebp-18h]
	int v12; // [esp+8h] [ebp-14h]
	__int16 v13; // [esp+Ch] [ebp-10h]
	__int16 v14; // [esp+10h] [ebp-Ch]
	__int16 v15; // [esp+14h] [ebp-8h]
	__int16 v16; // [esp+18h] [ebp-4h]

	// fix if begin
	v3 = 0;
	// end

	LOBYTE(v12) = *(x_WORD *)(a1 + 76) >> 8;
	BYTE1(v12) = *(x_WORD *)(a1 + 78) >> 8;
	LOWORD(v11) = v12;
	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
	v13 = 0;
	v16 = 0;
	v9 = *(x_WORD *)(v1 + 76) >> 8;
	v10 = *(x_WORD *)(v1 + 78) >> 8;
	LOBYTE(v2) = 0;
	HIBYTE(v2) = *(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 1118);
	switch (HIBYTE(v2))
	{
	case 0:
		v15 = sub_16730(v2, a1, 0);
		v14 = sub_16730(v3, a1, 1);
		if (!(x_BYTE)v14 && !(x_BYTE)v15)
			return 0;
		if ((x_BYTE)v15)
		{
			v5 = 0;
			while (v5 < 0x28u)
			{
				LOBYTE(v12) = x_BYTE_D3F96[(unsigned __int8)v15] + v12;
				BYTE1(v12) += x_BYTE_D3FA4[(unsigned __int8)v15];
				v16 = v12;
				++v5;
				v15 = sub_16CA0((unsigned __int8)v15, &v12, (unsigned __int8)v15, 0);
			}
		}
		if ((x_BYTE)v14)
		{
			v6 = 0;
			while (v6 < 0x28u)
			{
				LOBYTE(v11) = x_BYTE_D3FB2[(unsigned __int8)v14] + v11;
				BYTE1(v11) += x_BYTE_D3FC0[(unsigned __int8)v14];
				v13 = v11;
				++v6;
				v14 = sub_16CA0((unsigned __int8)v14, &v11, (unsigned __int8)v14, 1);
			}
		}
		if ((x_BYTE)v15 && (x_BYTE)v14)
		{
			if (abs(v10 - HIBYTE(v16)) * abs(v9 - (unsigned __int8)v16) > abs(v9 - (unsigned __int8)v13)
				* abs(v10 - HIBYTE(v13)))
			{
				v7 = *(x_DWORD *)(a1 + 164);
				v8 = 2;
			}
			else
			{
				v7 = *(x_DWORD *)(a1 + 164);
				v8 = 1;
			}
			goto LABEL_21;
		}
		if (!(x_BYTE)v15)
		{
			v7 = *(x_DWORD *)(a1 + 164);
			v8 = 2;
		LABEL_21:
			*(x_BYTE *)(v7 + 1118) = v8;
			return v8;
		}
		LOBYTE(v2) = 1;
		*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 1118) = 1;
		return v2;
	case 1:
		v15 = sub_16730(v2, a1, 0);
		if (!HIBYTE(v15) || (unsigned __int16)sub_16E70((unsigned __int8 *)&v12, &v9))
		{
			result = 1;
		}
		else
		{
			*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 1118) = 3;
			result = 3;
		}
		break;
	case 2:
		v14 = sub_16730(v2, a1, 1);
		if (!HIBYTE(v14) || (unsigned __int16)sub_16E70((unsigned __int8 *)&v12, &v9))
		{
			result = 2;
		}
		else
		{
			*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 1118) = 3;
			result = 3;
		}
		break;
	default:
		return v2;
	}
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00016CA0) --------------------------------------------------------
int sub_16CA0(int a1, int *a2, __int16 a3, char a4)
{
	unsigned __int16 v4; // ax
	char v5; // al
	int v6; // eax
	char v7; // al
	int v8; // eax
	char v9; // al
	char v10; // ah
	unsigned __int16 v11; // ax
	int result; // eax
	unsigned __int16 v13; // ax
	unsigned __int16 v14; // ax
	unsigned __int16 v15; // ax
	char v16; // al
	char v17; // ah
	unsigned __int16 v18; // ax
	unsigned __int16 v19; // ax
	unsigned __int16 v20; // ax
	unsigned __int16 v21; // ax

	LOBYTE(v4) = *a2;
	HIBYTE(v4) = a2[1] - 1;
	LOWORD(a1) = 0;
	if (x_BYTE_10B4E0[v4] == 8)
	{
		LOBYTE(a1) = 1;
	}
	else
	{
		HIBYTE(v4) = a2[1] + 1;
		if (x_BYTE_10B4E0[v4] == 8)
			LOBYTE(a1) = 4;
	}
	v5 = *a2;
	if (a4)
		LOBYTE(v6) = v5 + 1;
	else
		LOBYTE(v6) = v5 - 1;
	BYTE1(v6) = a2[1];
	if (x_BYTE_10B4E0[(unsigned __int16)v6] == 8)
	{
		if (!a4)
		{
			LOBYTE(a1) = a1 | 8;
			goto LABEL_18;
		}
		goto LABEL_16;
	}
	v7 = *a2;
	if (a4)
		LOBYTE(v8) = v7 - 1;
	else
		LOBYTE(v8) = v7 + 1;
	BYTE1(v8) = a2[1];
	if (x_BYTE_10B4E0[(unsigned __int16)v8] == 8)
	{
		if (!a4)
		{
		LABEL_16:
			LOBYTE(a1) = a1 | 2;
			goto LABEL_18;
		}
		LOBYTE(a1) = a1 | 8;
	}
LABEL_18:
	if ((x_BYTE)a1)
		return a1;
	if (a4)
	{
		v16 = *a2;
		v17 = a2[1];
		switch (a3)
		{
		case 1:
		case 9:
			HIBYTE(v18) = v17 - 1;
			LOBYTE(v18) = v16 - 1;
			if (x_BYTE_10B4E0[v18] != 8)
				return a1;
			LOWORD(a1) = 1544;
			return a1;
		case 2:
		case 3:
			HIBYTE(v19) = v17 - 1;
			LOBYTE(v19) = v16 + 1;
			if (x_BYTE_10B4E0[v19] != 8)
				return a1;
			LOWORD(a1) = 3073;
			return a1;
		case 4:
		case 6:
			HIBYTE(v20) = v17 + 1;
			LOBYTE(v20) = v16 + 1;
			if (x_BYTE_10B4E0[v20] != 8)
				return a1;
			LOWORD(a1) = 2306;
			return a1;
		case 8:
		case 12:
			HIBYTE(v21) = v17 + 1;
			LOBYTE(v21) = v16 - 1;
			if (x_BYTE_10B4E0[v21] == 8)
				LOWORD(a1) = 772;
			return a1;
		default:
			return a1;
		}
		return a1;
	}
	v9 = *a2;
	v10 = a2[1];
	switch (a3)
	{
	case 1:
	case 3:
		HIBYTE(v11) = v10 - 1;
		LOBYTE(v11) = v9 + 1;
		if (x_BYTE_10B4E0[v11] != 8)
			return a1;
		LOWORD(a1) = 770;
		result = a1;
		break;
	case 2:
	case 6:
		HIBYTE(v13) = v10 + 1;
		LOBYTE(v13) = v9 + 1;
		if (x_BYTE_10B4E0[v13] != 8)
			return a1;
		LOWORD(a1) = 1540;
		result = a1;
		break;
	case 4:
		HIBYTE(v14) = v10 + 1;
		LOBYTE(v14) = v9 - 1;
		if (x_BYTE_10B4E0[v14] != 8)
			return a1;
		LOWORD(a1) = 3080;
		result = a1;
		break;
	case 8:
	case 9:
		HIBYTE(v15) = v10 - 1;
		LOBYTE(v15) = v9 - 1;
		if (x_BYTE_10B4E0[v15] != 8)
			return a1;
		LOWORD(a1) = 2305;
		result = a1;
		break;
	default:
		return a1;
	}
	return result;
}

//----- (00016E70) --------------------------------------------------------
int sub_16E70(unsigned __int8 *a1, unsigned __int8 *a2)
{
	__int16 v2; // cx
	__int16 v3; // si
	int v4; // ebx
	signed __int16 v5; // ax
	signed __int16 v6; // ax
	__int16 v7; // ax
	__int16 v8; // dx
	int j; // ecx
	unsigned __int16 v10; // ST00_2
	int i; // ecx
	unsigned __int16 v12; // ST00_2
	int result; // eax
	int v14; // ecx
	signed __int16 v15; // [esp+4h] [ebp-10h]
	int v16; // [esp+8h] [ebp-Ch]
	int v17; // [esp+Ch] [ebp-8h]
	signed __int16 v18; // [esp+10h] [ebp-4h]

	v2 = *a2 - *a1;
	v3 = a2[1] - a1[1];
	v17 = 2 * abs(v2);
	v4 = 0;
	v16 = 2 * abs(v3);
	if (v2 >= 0)
	{
		LOBYTE(v5) = *a2 != *a1;
		HIBYTE(v5) = 0;
		v15 = v5;
	}
	else
	{
		v15 = -1;
	}
	if (v3 >= 0)
	{
		LOBYTE(v6) = a2[1] != a1[1];
		HIBYTE(v6) = 0;
		v18 = v6;
	}
	else
	{
		v18 = -1;
	}
	v7 = *a1;
	v8 = a1[1];
	if ((signed __int16)v17 <= (signed __int16)v16)
	{
		for (i = (signed __int16)v17 - ((signed __int16)v16 >> 1); ; i += v17)
		{
			LOBYTE(v12) = v7;
			HIBYTE(v12) = v8;
			if (x_BYTE_10B4E0[v12] == 8)
				return v4 + 1;
			if (v8 == a2[1])
				break;
			if ((i & 0x8000u) == 0)
			{
				LOBYTE(v7) = v15 + v7;
				i -= v16;
			}
			++v4;
			v8 += v18;
		}
		result = 0;
	}
	else
	{
		for (j = (signed __int16)v16 - ((signed __int16)v17 >> 1); ; j += v16)
		{
			LOBYTE(v10) = v7;
			HIBYTE(v10) = v8;
			if (x_BYTE_10B4E0[v10] == 8)
			{
				v14 = v4 + 1;
				goto LABEL_24;
			}
			if (v7 == *a2)
				break;
			if ((j & 0x8000u) == 0)
			{
				LOBYTE(v8) = v18 + v8;
				j -= v17;
			}
			++v4;
			v7 += v15;
		}
		v14 = 0;
	LABEL_24:
		result = v14;
	}
	return result;
}

//----- (00016FC0) --------------------------------------------------------
unsigned int sub_16FC0(int a1, int a2)
{
	unsigned int v2; // edi
	unsigned int v3; // esi
	unsigned int v4; // ebx
	__int16 v6; // ax
	char v7; // ah
	unsigned int v8; // eax

	v2 = -1;
	v3 = 0;
	v4 = x_D41A0_BYTEARRAY_4[0x9677];
	if (v4 <= x_DWORD_EA3E4[0])
		return 0;
	do
	{
		v6 = *(x_WORD *)(v4 + 26);
		if (v6 != *(x_WORD *)(a1 + 26) && v6 != *(x_WORD *)(a2 + 26))
		{
			v7 = *(x_BYTE *)(v4 + 64);
			if (!v7 || v7 == 1)
			{
				v8 = sub_584D0((x_WORD *)(a1 + 76), (x_WORD *)(v4 + 76));
				if (v8 < v2)
				{
					v3 = v4;
					v2 = v8;
				}
			}
		}
		v4 = *(x_DWORD *)v4;
	} while (v4 > x_DWORD_EA3E4[0]);
	return v3;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00017060) --------------------------------------------------------
__int16 sub_17060(__int16 a1, __int16 a2)
{
	__int16 result; // ax
	int v3; // ebx
	int v4; // ecx
	int v5; // eax
	int v6; // edx

	result = x_D41A0_BYTEARRAY_4[0];
	if (!x_D41A0_BYTEARRAY_4[0xB2])
	{
		if (x_WORD_180660_VGA_type_resolution == 1)
		{
			v3 = ((a1 << 7) - 40960) / 320;
			v4 = (25600 - (a2 << 7)) / 200;
		}
		else
		{
			v3 = ((a1 << 7) - 40960) / 320;
			v4 = ((a2 << 7) - 30720) / -240;
		}
		if (v3 < -127)
			v3 = -127;
		if (v3 > 127)
			LOBYTE(v3) = 127;
		if (v4 < -127)
			v4 = -127;
		if (v4 > 127)
			LOBYTE(v4) = 127;
		v5 = (int)x_D41A0_BYTEARRAY_0;
		x_D41A0_BYTEARRAY_0[10 * x_D41A0_BYTEARRAY_0[10] + 28225] = v3;
		x_D41A0_BYTEARRAY_0[v5 + 10 * x_D41A0_BYTEARRAY_0[v5 + 12] + 28226] = v4;
		x_D41A0_BYTEARRAY_0[v5 + 10 * x_D41A0_BYTEARRAY_0[v5 + 12] + 28228] = x_DWORD_180590;
		v6 = v5 + 10 * *(signed __int16 *)(v5 + 12);
		result = x_DWORD_180594;
		*(x_WORD *)(v6 + 28230) = x_DWORD_180594;
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// 180590: using guessed type int x_DWORD_180590;
// 180594: using guessed type int x_DWORD_180594;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00017190) --------------------------------------------------------
char sub_17190()
{
	int v0; // eaxx_D41A0_BYTEARRAY_4
	int v1; // ecx
	int v2; // edx
	int v3; // edx
	char v4; // dl
	char v5; // cl
	int v6; // edx
	bool v7; // dl
	int v8; // eax

	if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 4) || (v0 = sub_473E0()) == 0)
	{
		v1 = x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
		LOBYTE(v0) = 5 * v1;
		if (!x_D41A0_BYTEARRAY_0[10 * v1 + 28222])
		{
			v2 = x_D41A0_BYTEARRAY_0[2124 * v1];
			if (!(*(x_BYTE *)(v2 + 11232) & 0x20))
			{
				v3 = x_DWORD_EA3E4[*(unsigned __int16 *)(v2 + 11240)];
				if (x_BYTE_18069C)
				{
					LOBYTE(v0) = x_BYTE_1806E4;
					if ((unsigned __int8)x_BYTE_1806E4 >= 0x3Cu)
					{
						if ((unsigned __int8)x_BYTE_1806E4 <= 0x3Cu)
						{
							LOBYTE(v0) = sub_191B0(30, 2);
							x_BYTE_1806E4 = 0;
						}
						else if ((unsigned __int8)x_BYTE_1806E4 < 0x40u)
						{
							if ((unsigned __int8)x_BYTE_1806E4 < 0x3Eu)
							{
								LOBYTE(v0) = sub_191B0(30, 3);
								x_BYTE_1806E4 = 0;
							}
							else
							{
								if ((unsigned __int8)x_BYTE_1806E4 <= 0x3Eu)
									LOBYTE(v0) = sub_191B0(30, 4);
								else
									LOBYTE(v0) = sub_191B0(30, 5);
								x_BYTE_1806E4 = 0;
							}
						}
						else if ((unsigned __int8)x_BYTE_1806E4 <= 0x40u)
						{
							LOBYTE(v0) = sub_191B0(30, 6);
							x_BYTE_1806E4 = 0;
						}
						else if ((unsigned __int8)x_BYTE_1806E4 < 0x42u)
						{
							LOBYTE(v0) = sub_191B0(30, 7);
							x_BYTE_1806E4 = 0;
						}
						else if ((unsigned __int8)x_BYTE_1806E4 <= 0x42u)
						{
							LOBYTE(v0) = sub_191B0(30, 8);
							x_BYTE_1806E4 = 0;
						}
						else if ((unsigned __int8)x_BYTE_1806E4 <= 0x43u)
						{
							LOBYTE(v0) = sub_191B0(30, 9);
							x_BYTE_1806E4 = 0;
						}
						else if (x_BYTE_1806E4 == 68)
						{
							LOBYTE(v0) = sub_191B0(30, 10);
							x_BYTE_1806E4 = 0;
						}
						goto LABEL_161;
					}
					if ((unsigned __int8)x_BYTE_1806E4 >= 0x2Cu)
					{
						if ((unsigned __int8)x_BYTE_1806E4 <= 0x2Cu)
						{
							LOBYTE(v0) = x_D41A0_BYTEARRAY_4[0];
							if (x_D41A0_BYTEARRAY_4[0x17] < 0)
							{
								v5 = x_D41A0_BYTEARRAY_4_struct.setting_byte4_25;
								if (v5 & 0x20)
									x_D41A0_BYTEARRAY_4_struct.setting_byte4_25 = v5 & 0xDF;
								else
									x_D41A0_BYTEARRAY_4_struct.setting_byte4_25 = v5 | 0x20;
							}
							x_BYTE_1806E4 = 0;
							goto LABEL_161;
						}
						if ((unsigned __int8)x_BYTE_1806E4 < 0x31u)
						{
							if (x_BYTE_1806E4 == 47)
							{
								LOBYTE(v0) = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
								if (x_D41A0_BYTEARRAY_4[0x17] < 0)
									LOBYTE(v0) = sub_191B0(4, 8);
								x_BYTE_1806E4 = 0;
							}
							goto LABEL_161;
						}
						if ((unsigned __int8)x_BYTE_1806E4 > 0x31u)
						{
							if (x_BYTE_1806E4 == 59)
							{
								LOBYTE(v0) = sub_191B0(30, 1);
								x_BYTE_1806E4 = 0;
							}
							goto LABEL_161;
						}
						goto LABEL_61;
					}
					if ((unsigned __int8)x_BYTE_1806E4 < 0x20u)
					{
						if (x_BYTE_1806E4 == 20)
						{
							LOBYTE(v0) = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
							if (x_D41A0_BYTEARRAY_4[0x17] < 0)
							{
								if (x_BYTE_18069A)
									LOBYTE(v0) = sub_70940();
								else
									LOBYTE(v0) = sub_191B0(4, 64);
							}
							x_BYTE_1806E4 = 0;
						}
						goto LABEL_161;
					}
					if ((unsigned __int8)x_BYTE_1806E4 <= 0x20u)
					{
						LOBYTE(v0) = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
						if (x_D41A0_BYTEARRAY_4[0x17] < 0)
						{
							sub_5BF10();
							LOBYTE(v0) = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
							v4 = x_D41A0_BYTEARRAY_4_struct.setting_byte3_24;
							x_BYTE_18069C = 0;
							if (v4 & 0x10)
								x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 = v4 & 0xEF;
							else
								x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 = v4 | 0x10;
						}
						x_BYTE_1806E4 = 0;
						goto LABEL_161;
					}
					if (x_BYTE_1806E4 == 35)
					{
						v0 = (int)x_D41A0_BYTEARRAY_0;
						*(x_BYTE *)(v0 + 8595) ^= 1u;
					LABEL_61:
						x_BYTE_1806E4 = 0;
					}
				LABEL_161:
					if (x_BYTE_18067C)
					{
						LOBYTE(v0) = (int)x_D41A0_BYTEARRAY_0;
						x_D41A0_BYTEARRAY_0[(int)&loc_36E03 + 1] = 2;
					}
					return v0;
				}
				if (x_BYTE_18068E || x_BYTE_18069A)
				{
					LOBYTE(v0) = x_BYTE_1806E4;
					if ((unsigned __int8)x_BYTE_1806E4 < 0x2Eu)
					{
						if ((unsigned __int8)x_BYTE_1806E4 < 0x20u)
						{
							if ((unsigned __int8)x_BYTE_1806E4 < 0x12u)
							{
								if (x_BYTE_1806E4 == 16)
								{
									LOBYTE(v0) = sub_191B0(2, 0);
									x_BYTE_1806E4 = 0;
								}
							}
							else if ((unsigned __int8)x_BYTE_1806E4 <= 0x12u)
							{
								LOBYTE(v0) = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
								if (x_D41A0_BYTEARRAY_4[0x17] < 0)
									LOBYTE(v0) = sub_191B0(26, 0);
								x_BYTE_1806E4 = 0;
							}
							else if (x_BYTE_1806E4 == 19)
							{
								LOBYTE(v0) = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
								if (x_D41A0_BYTEARRAY_4[0x17] < 0 && !(x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10))
								{
									v6 = (int)x_D41A0_BYTEARRAY_0;
									*(x_BYTE *)(v6 + 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 11232) |= 0xCu;
									LOBYTE(v0) = (int)x_D41A0_BYTEARRAY_0;
									x_D41A0_BYTEARRAY_0[2124 * (v6 + 12) + 12286] = 0;
								}
								x_BYTE_1806E4 = 0;
							}
							goto LABEL_161;
						}
						if ((unsigned __int8)x_BYTE_1806E4 <= 0x20u)
						{
							LOBYTE(v0) = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
							if (x_D41A0_BYTEARRAY_4[0x17] < 0)
							{
								v0 = 5 * (unsigned __int8)x_BYTE_3659D[11 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0[0]];
								x_D41A0_BYTEARRAY_0[(int)&loc_3654B + 2 * v0 + 2] |= 2u;
							}
						}
						else
						{
							if ((unsigned __int8)x_BYTE_1806E4 < 0x22u)
							{
								LOBYTE(v0) = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
								if (x_D41A0_BYTEARRAY_4[0x17] < 0)
								{
									v0 = 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
									x_D41A0_BYTEARRAY_0[v0 + 11232] |= 4u;
								}
								x_BYTE_1806E4 = 0;
								goto LABEL_161;
							}
							if ((unsigned __int8)x_BYTE_1806E4 > 0x22u)
							{
								if ((unsigned __int8)x_BYTE_1806E4 >= 0x25u)
								{
									if ((unsigned __int8)x_BYTE_1806E4 <= 0x25u)
									{
										if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x8010))
											*(x_DWORD *)(v3 + 8) = -1;
										LOBYTE(v0) = 0;
										x_BYTE_1806E4 = 0;
									}
									else if (x_BYTE_1806E4 == 38)
									{
										v0 = *(x_DWORD *)(v3 + 164);
										if (*(x_WORD *)(v0 + 58))
											LOBYTE(v0) = sub_191B0(42, 0);
										x_BYTE_1806E4 = 0;
									}
								}
								goto LABEL_161;
							}
						}
					}
					else
					{
						if ((unsigned __int8)x_BYTE_1806E4 <= 0x2Eu)
						{
							LOBYTE(v0) = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
							if (x_D41A0_BYTEARRAY_4[0x17] < 0)
							{
								x_BYTE_3659C[11 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0[0]] = 1;
								LOBYTE(v0) = sub_191B0(27, 0);
							}
							x_BYTE_1806E4 = 0;
							goto LABEL_161;
						}
						if ((unsigned __int8)x_BYTE_1806E4 >= 0x3Eu)
						{
							if ((unsigned __int8)x_BYTE_1806E4 <= 0x3Eu)
							{
								LOBYTE(v0) = sub_1A970(12, 0, 0);
								x_BYTE_1806E4 = 0;
							}
							else if ((unsigned __int8)x_BYTE_1806E4 < 0x40u)
							{
								LOBYTE(v0) = sub_1A970(13, 0, 0);
								x_BYTE_1806E4 = 0;
							}
							else if ((unsigned __int8)x_BYTE_1806E4 <= 0x40u)
							{
								LOBYTE(v0) = sub_1A970(14, 0, 0);
								x_BYTE_1806E4 = 0;
							}
							else if ((unsigned __int8)x_BYTE_1806E4 <= 0x41u)
							{
								LOBYTE(v0) = sub_1A970(15, 0, 0);
								x_BYTE_1806E4 = 0;
							}
							else if (x_BYTE_1806E4 == 68)
							{
								v7 = x_D41A0_BYTEARRAY_4[0xCD] == 0;
								v8 = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
								x_D41A0_BYTEARRAY_4[0xCD] = v7;
								*(x_BYTE *)(v8 + 206) = v7;
								if (v7 && *(x_BYTE *)(v8 + 24) & 1)
									sub_8CD27_set_cursor(*filearray_2aa18c[0].posistruct); //fix it sub_8CD27(dword_EB394);
								LOBYTE(v0) = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
								if (!x_D41A0_BYTEARRAY_4[0xCE] && x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 1)
									/*LOBYTE(v0) = */sub_8CD27_set_cursor(*filearray_2aa18c[x_BYTE_D419E].posistruct); //fix it LOBYTE(v0) = sub_8CD27(dword_EB394 + 6 * (unsigned __int8)byte_D419E);
								x_BYTE_1806E4 = 0;
							}
							goto LABEL_161;
						}
						if ((unsigned __int8)x_BYTE_1806E4 >= 0x3Cu)
						{
							if ((unsigned __int8)x_BYTE_1806E4 <= 0x3Cu)
							{
								LOBYTE(v0) = sub_1A970(10, 0, 0);
							}
							else
							{
								sub_1A970(11, 0, 0);
								LOBYTE(v0) = 0;
							}
							x_BYTE_1806E4 = 0;
							goto LABEL_161;
						}
						if (x_BYTE_1806E4 != 59)
							goto LABEL_161;
						LOBYTE(v0) = sub_1A970(9, 0, 0);
					}
				}
				else
				{
					if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10) && x_BYTE_1806E4 == 25)
					{
						sub_18BB0();
						x_BYTE_1806E4 = 0;
					}
					if (x_BYTE_1806E4 == 19)
					{
						sub_1A970(16, 0, 0);
						x_BYTE_1806E4 = 0;
					}
					if (x_BYTE_1806E4 == 57)
					{
						sub_191B0(15, 0);
						x_BYTE_1806E4 = 0;
					}
					LOBYTE(v0) = x_BYTE_1806E4;
					if ((unsigned __int8)x_BYTE_1806E4 >= 0x3Eu)
					{
						if ((unsigned __int8)x_BYTE_1806E4 <= 0x3Eu)
						{
							LOBYTE(v0) = sub_1A970(4, 0, 0);
							x_BYTE_1806E4 = 0;
						}
						else if ((unsigned __int8)x_BYTE_1806E4 < 0x40u)
						{
							sub_1A970(2, 0, 0);
							LOBYTE(v0) = 0;
							x_BYTE_1806E4 = 0;
						}
						else if ((unsigned __int8)x_BYTE_1806E4 <= 0x40u)
						{
							LOBYTE(v0) = sub_1A970(3, 0, 0);
							x_BYTE_1806E4 = 0;
						}
						else if ((unsigned __int8)x_BYTE_1806E4 <= 0x41u)
						{
							LOBYTE(v0) = sub_1A970(6, 0, 0);
							x_BYTE_1806E4 = 0;
						}
						else if (x_BYTE_1806E4 == 66)
						{
							LOBYTE(v0) = sub_1A970(17, 0, 0);
							x_BYTE_1806E4 = 0;
						}
						goto LABEL_161;
					}
					if ((unsigned __int8)x_BYTE_1806E4 < 0x3Bu)
					{
						if (x_BYTE_1806E4 != 31)
							goto LABEL_161;
						LOBYTE(v0) = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
						if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 1)
							&& x_WORD_180660_VGA_type_resolution & 1
							&& (x_WORD_1805C2 == 1 || x_WORD_1805C2 == 8 || x_WORD_1805C2 == 12))
						{
							LOBYTE(v0) = sub_1A970(18, 0, 0);
						}
					}
					else
					{
						if ((unsigned __int8)x_BYTE_1806E4 <= 0x3Bu)
						{
							LOBYTE(v0) = sub_1A970(1, 0, 0);
							x_BYTE_1806E4 = 0;
							goto LABEL_161;
						}
						if ((unsigned __int8)x_BYTE_1806E4 <= 0x3Cu)
						{
							LOBYTE(v0) = sub_1A970(5, 0, 0);
							x_BYTE_1806E4 = 0;
							goto LABEL_161;
						}
						LOBYTE(v0) = sub_1A970(7, 0, 0);
					}
				}
				x_BYTE_1806E4 = 0;
				goto LABEL_161;
			}
		}
	}
	return v0;
}
// D419E: using guessed type char x_BYTE_D419E;
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB394: using guessed type int x_DWORD_EB394;
// 1805C2: using guessed type __int16 x_WORD_1805C2;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;
// 18067C: using guessed type char x_BYTE_18067C;
// 18068E: using guessed type char x_BYTE_18068E;
// 18069A: using guessed type char x_BYTE_18069A;
// 18069C: using guessed type char x_BYTE_18069C;
// 1806E4: using guessed type char x_BYTE_1806E4;

//----- (00017A00) --------------------------------------------------------
char sub_17A00(x_BYTE *a1, signed int a2, __int16 a3)
{
	int result; // eax
	int v4; // ecx
	int v5; // eax
	int v6; // edx
	int v7; // ecx
	int v8; // ebx
	char v9; // ch
	char v10; // dl
	char v11; // dh
	int v12; // edi
	int v13; // eax
	int v14; // edx
	int v15; // ebx
	unsigned __int8 v16; // al
	char v17; // al
	int v18; // esi
	char v19; // al
	int v20; // eax
	char v21; // dl
	int v22; // ecx
	char v23; // al
	int v24; // ebx
	unsigned __int8 v25; // al
	char v26; // cl
	char v27; // al
	signed int v28; // eax
	int v29; // eax
	int v30; // ecx
	char v32; // [esp-4h] [ebp-Ch]
	char v33; // [esp+0h] [ebp-8h]
	char v34; // [esp+4h] [ebp-4h]

	// fix if begin
	v14 = 0;
	// end

	if ((unsigned __int8)x_BYTE_1806E4 >= 0x80u)
		x_BYTE_1806E4 = 0;
	result = 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
	v4 = x_D41A0_BYTEARRAY_0[result];
	if (!(x_D41A0_BYTEARRAY_0[result + 11232] & 0x20))
	{
		switch (*(x_BYTE *)(v4 + 12221))
		{
		case 0:
		case 4:
			if (x_D41A0_BYTEARRAY_0[10 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 28222])
				goto LABEL_292;
			if (x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 1)
				sub_197F0();
			sub_17190();
			v5 = (int)x_D41A0_BYTEARRAY_0;
			v6 = x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
			v7 = 5 * v6;
			v8 = x_DWORD_EA3E4[x_D41A0_BYTEARRAY_0[2124 * v6 + 11240]];
			LOBYTE(v6) = x_DWORD_18059C;
			x_D41A0_BYTEARRAY_0[2 * v7 + 28227] = 0;
			if (v6 & 0x10)
			{
				if (*(x_DWORD *)(v8 + 8) >= 0)
					sub_191B0(20, 5);
			}
			else if (x_BYTE_18069C || x_BYTE_180664[x_BYTE_EB39E_keys[9]])
			{
				if ((unsigned __int8)x_BYTE_1806E4 < 0x1Fu)
				{
					if ((unsigned __int8)x_BYTE_1806E4 >= 0x13u)
					{
						if ((unsigned __int8)x_BYTE_1806E4 <= 0x13u)
						{
							x_BYTE_1806E4 = 0;
						}
						else if (x_BYTE_1806E4 == 25)
						{
							x_BYTE_1806E4 = 0;
						}
					}
				}
				else if ((unsigned __int8)x_BYTE_1806E4 <= 0x1Fu)
				{
					x_BYTE_1806E4 = 0;
				}
				else if ((unsigned __int8)x_BYTE_1806E4 >= 0x21u && (unsigned __int8)x_BYTE_1806E4 <= 0x21u)
				{
					sub_191B0(4, 32);
					x_BYTE_1806E4 = 0;
				}
				if (x_DWORD_18059C & 1)
				{
					sub_18DA0(v8, 1, 1);
					LOBYTE(x_DWORD_18059C) = x_DWORD_18059C & 0xFE;
				}
				else if (x_DWORD_18059C & 2)
				{
					sub_18DA0(v8, 2, 1);
					LOBYTE(x_DWORD_18059C) = x_DWORD_18059C & 0xFD;
				}
			}
			else if (x_BYTE_18068E || x_BYTE_180664[x_BYTE_EB39E_keys[8]])
			{
				if (x_DWORD_18059C & 1)
				{
					sub_18DA0(v8, 1, 0);
					LOBYTE(x_DWORD_18059C) = x_DWORD_18059C & 0xFE;
				}
				else if (x_DWORD_18059C & 2)
				{
					sub_18DA0(v8, 2, 0);
					LOBYTE(x_DWORD_18059C) = x_DWORD_18059C & 0xFD;
				}
			}
			else
			{
				if (x_BYTE_1806E4 == 26)
				{
					if (!*(x_BYTE *)(v5 + 8592))
					{
						v9 = *(x_BYTE *)(v5 + 8589);
						if (v9 < 40)
						{
							*(x_BYTE *)(v5 + 8589) = v9 + 1;
							sub_2CA90((char)(v9 + 1));
						}
					}
					x_BYTE_1806E4 = 0;
				}
				if (x_BYTE_1806E4 == 27)
				{
					if (!x_D41A0_BYTEARRAY_0[8592])
					{
						v10 = x_D41A0_BYTEARRAY_0[8589];
						if (v10 > 17)
						{
							x_D41A0_BYTEARRAY_0[8589] = v10 - 1;
							sub_2CA90((char)(v10 - 1));
						}
					}
					x_BYTE_1806E4 = 0;
				}
				switch (x_BYTE_1806E4)
				{
				case 23:
					if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte4_25 & 2))
					{
						v11 = *(x_BYTE *)(v8 + 69);
						if (v11 != 2 && v11 != 3)
							sub_191B0(16, 0);
					}
					x_BYTE_1806E4 = 0;
					goto LABEL_296;
				case 1:
					sub_18B30();
					x_BYTE_1806E4 = 0;
					LOBYTE(result) = sub_1A7A0();
					goto LABEL_306;
				case 57:
					sub_191B0(15, 0);
					x_BYTE_1806E4 = 0;
					break;
				}
				if (x_DWORD_18059C & 1 && x_DWORD_18059C & 2)
				{
					if (*(x_DWORD *)(v8 + 8) >= 0)
						sub_191B0(20, 6);
					LOBYTE(x_DWORD_18059C) = x_DWORD_18059C & 0xFC;
				}
				if (x_BYTE_1806E4 == x_BYTE_EB39E_keys[4])
				{
					if (*(x_DWORD *)(v8 + 8) >= 0)
						sub_191B0(20, 6);
					x_BYTE_1806E4 = 0;
				}
				if ((unsigned __int8)x_BYTE_1806E4 >= 2u)
				{
					if ((unsigned __int8)x_BYTE_1806E4 <= 9u)
					{
						sub_191B0(43, x_BYTE_1806E4 - 2);
						x_BYTE_1806E4 = 0;
					}
					else if (x_BYTE_1806E4 == 32)
					{
						sub_19A70();
						x_BYTE_1806E4 = 0;
					}
				}
				if (!x_BYTE_180693 || x_D41A0_BYTEARRAY_4[0x96BF])
				{
					if (x_BYTE_180696 && !x_D41A0_BYTEARRAY_4[0x96BF])
						sub_19CA0_sound_proc5(2u);
				}
				else
				{
					sub_19CA0_sound_proc5(1u);
				}
				sub_18F80(v8);
			}
			if (x_BYTE_1806E4 && x_BYTE_E36DC[(unsigned __int8)x_BYTE_1806E4] == 8)
			{
				sub_191B0(39, 1);
				x_BYTE_1806E4 = 0;
			}
			sub_1A8A0();
			sub_17060(x_DWORD_1805B0, x_DWORD_1805B4);
			LOBYTE(result) = sub_1A7A0();
			goto LABEL_306;
		case 1:
			sub_17190();
			if ((!(x_DWORD_18059C & 1) || !(x_DWORD_18059C & 2)) && x_BYTE_1806E4 != 28)
				goto LABEL_296;
			x_BYTE_1806E4 = 0;
			LOBYTE(x_DWORD_18059C) = x_DWORD_18059C & 0xFC;
			sub_191B0(20, 0);
			LOBYTE(result) = sub_1A7A0();
			goto LABEL_306;
		case 3:
			if (!x_BYTE_1806E4 || (unsigned __int8)x_BYTE_1806E4 >= 0x80u)
				goto LABEL_216;
			if ((unsigned __int8)x_BYTE_1806E4 < 0x1Cu)
			{
				if (x_BYTE_1806E4 == 1)
				{
					sub_191B0(18, 0);
					goto LABEL_215;
				}
				goto LABEL_206;
			}
			if ((unsigned __int8)x_BYTE_1806E4 <= 0x1Cu)
			{
				sub_191B0(19, 0);
				goto LABEL_215;
			}
			if ((unsigned __int8)x_BYTE_1806E4 < 0x3Bu)
				goto LABEL_206;
			if ((unsigned __int8)x_BYTE_1806E4 <= 0x42u)
			{
				if (x_BYTE_18068E || x_BYTE_18069A)
				{
					sub_191B0(35, x_BYTE_1806E4 - 59);
				}
				else if (x_BYTE_1806E4 == 59)
				{
					sub_18AA0();
				}
				x_BYTE_1806E4 = 0;
			}
			else
			{
				if (x_BYTE_1806E4 != 67)
				{
				LABEL_206:
					v27 = x_BYTE_E36DC[(unsigned __int8)x_BYTE_1806E4];
					if ((unsigned __int8)v27 >= 0x41u && (unsigned __int8)v27 <= 0x5Au
						|| (unsigned __int8)v27 >= 0x61u && (unsigned __int8)v27 <= 0x7Au
						|| (unsigned __int8)v27 >= 0x30u && (unsigned __int8)v27 <= 0x39u
						|| v27 == 8
						|| v27 == 32)
					{
						sub_191B0(17, x_BYTE_E36DC[(unsigned __int8)x_BYTE_1806E4]);
					}
					goto LABEL_215;
				}
				v25 = *(x_BYTE *)(v4 + 12223) + 1;
				*(x_BYTE *)(v4 + 12223) = v25;
				v26 = v25;
				if ((signed int)v25 >= 4)
					v26 = 0;
				sub_191B0(36, v26);
			}
		LABEL_215:
			x_BYTE_1806E4 = 0;
		LABEL_216:
			if (x_WORD_180660_VGA_type_resolution & 1)
				v28 = 400;
			else
				v28 = 480;
			v29 = v28 - 72;
			if (x_DWORD_1805B0 < 4 || x_DWORD_1805B0 >= 66 || v29 + 28 > x_DWORD_1805B4 || v29 + 66 <= x_DWORD_1805B4)
			{
				if (x_DWORD_1805B0 < 384 || x_DWORD_1805B0 >= 654 || v29 + 26 > x_DWORD_1805B4 || v29 + 48 <= x_DWORD_1805B4)
				{
					if (x_DWORD_1805B0 < 82 || x_DWORD_1805B0 >= 378 || v29 + 32 > x_DWORD_1805B4 || v29 + 60 <= x_DWORD_1805B4)
					{
						if (x_DWORD_1805B0 < 384 || x_DWORD_1805B0 >= 440 || v29 + 4 > x_DWORD_1805B4 || v29 + 22 <= x_DWORD_1805B4)
						{
							if (x_DWORD_1805B0 < 474 || x_DWORD_1805B0 >= 530 || v29 + 4 > x_DWORD_1805B4 || v29 + 22 <= x_DWORD_1805B4)
							{
								if (x_DWORD_1805B0 >= 564
									&& x_DWORD_1805B0 < 620
									&& v29 + 4 <= x_DWORD_1805B4
									&& v29 + 22 > x_DWORD_1805B4
									&& x_DWORD_18059C & 1)
								{
									sub_191B0(18, 0);
								}
							}
							else if (x_DWORD_18059C & 1)
							{
								sub_191B0(44, 0);
							}
						}
						else if (x_DWORD_18059C & 1)
						{
							sub_191B0(19, 0);
						}
						goto LABEL_292;
					}
					if (x_DWORD_1805B0 < 82 || x_DWORD_1805B0 >= 150 || v29 + 32 > x_DWORD_1805B4 || v29 + 60 <= x_DWORD_1805B4)
					{
						if (x_DWORD_1805B0 >= 152 && x_DWORD_1805B0 < 220 && v29 + 32 <= x_DWORD_1805B4 && v29 + 60 > x_DWORD_1805B4)
						{
							if (x_D41A0_BYTEARRAY_4_struct.byteindex_A)
								x_BYTE_180559 = 99;
							if (x_DWORD_18059C & 1)
								sub_191B0(36, 1);
							goto LABEL_292;
						}
						if (x_DWORD_1805B0 >= 222 && x_DWORD_1805B0 < 290 && v29 + 32 <= x_DWORD_1805B4 && v29 + 60 > x_DWORD_1805B4)
						{
							if (x_D41A0_BYTEARRAY_4_struct.byteindex_A)
								x_BYTE_180559 = 100;
							if (x_DWORD_18059C & 1)
								sub_191B0(36, 2);
							goto LABEL_292;
						}
						if (x_DWORD_1805B0 < 310 || x_DWORD_1805B0 >= 378 || v29 + 32 > x_DWORD_1805B4 || v29 + 60 <= x_DWORD_1805B4)
							goto LABEL_292;
						if (x_D41A0_BYTEARRAY_4_struct.byteindex_A)
							x_BYTE_180559 = 101;
						if (!(x_DWORD_18059C & 1))
							goto LABEL_292;
						v32 = 3;
					}
					else
					{
						if (x_D41A0_BYTEARRAY_4_struct.byteindex_A)
							x_BYTE_180559 = 98;
						if (!(x_DWORD_18059C & 1))
							goto LABEL_292;
						v32 = 0;
					}
					sub_191B0(36, v32);
					goto LABEL_292;
				}
				if (x_D41A0_BYTEARRAY_4_struct.byteindex_A)
					x_BYTE_180559 = 102;
				if (x_DWORD_18059C & 1)
				{
					v30 = (x_DWORD_1805B0 - 384) / 34;
					if (v30 >= x_D41A0_BYTEARRAY_4_struct.dwordindex_12)
						LOBYTE(v30) = v30 + 1;
					sub_191B0(37, v30);
				}
			}
			else
			{
				if (x_D41A0_BYTEARRAY_4_struct.byteindex_A)
					x_BYTE_180559 = 97;
				if (x_DWORD_18059C & 1)
					sub_191B0(
						35,
						4 * ((x_DWORD_1805B4 - (v29 + 28)) / 20)
						+ ((x_DWORD_1805B0 - 4 - (__CFSHL__((x_DWORD_1805B0 - 4) >> 31, 4) + 16 * ((x_DWORD_1805B0 - 4) >> 31))) >> 4));
			}
		LABEL_292:
			LOBYTE(x_DWORD_18059C) = x_DWORD_18059C & 0xFC;
			LOBYTE(result) = sub_1A7A0();
			goto LABEL_306;
		case 5:
		case 8:
			v33 = 0;
			v34 = 0;
			v12 = x_DWORD_EA3E4[x_D41A0_BYTEARRAY_0[2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 11240]];
			LOBYTE(v13) = sub_17190();
			if (*(x_DWORD *)(v12 + 8) < 0)
			{
				v33 = 1;
			}
			else
			{
				v15 = *(x_DWORD *)(v12 + 164);
				_wcpp_1_unwind_leave__120(v13, v14, v15);
				v16 = *(x_BYTE *)(v15 + 1111);
				a1 = (x_BYTE *)(v15 + 611);
				if (v16)
				{
					if (v16 <= 2u)
					{
						if ((v16 != 1 || x_DWORD_18059C & 4) && (a1[500] != 2 || x_DWORD_18059C & 8))
						{
							v23 = sub_6D4F0((int)a1, x_DWORD_1805B0);
							a1[502] = v23;
							sub_191B0(41, v23);
						}
						else
						{
							if (a1[500] == 1)
								x_D41A0_BYTEARRAY_0[10 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 28222] = 31;
							else
								x_D41A0_BYTEARRAY_0[10 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 28222] = 32;
							v22 = (int)x_D41A0_BYTEARRAY_0;
							x_D41A0_BYTEARRAY_0[10 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 28223] = a1[501];
							*(x_BYTE *)(v22 + 10 * *(signed __int16 *)(v22 + 12) + 28224) = a1[502];
							a1[500] = 0;
							sub_6D200(v22 + 11230 + 2124 * *(signed __int16 *)(v22 + 12));
						}
					}
				}
				else
				{
					v34 = 1;
					v17 = sub_6D420(x_DWORD_1805B0, x_DWORD_1805B4);
					a1[501] = v17;
					v18 = (unsigned __int8)x_BYTE_D94FF[v17];
					v19 = 1;
					if (!*(x_WORD *)&a1[2 * v18 + 208] || !x_BYTE_D41B6 && v18 == 25)
						v19 = 0;
					if (!v19)
						goto LABEL_122;
					sub_6D4C0((int)a1);
					if (!(x_DWORD_18059C & 1) && !(x_DWORD_18059C & 2))
						goto LABEL_122;
					if (x_BYTE_18068E || x_BYTE_180664[x_BYTE_EB39E_keys[7]])
					{
						sub_191B0(38, v18);
						v20 = (int)x_D41A0_BYTEARRAY_0;
						x_D41A0_BYTEARRAY_0[10 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 28224] = 0;
						v21 = a1[v18 + 338];
						if (v21)
						{
							if (x_DWORD_18059C & 1)
							{
								if (v21 != 1)
									*(x_BYTE *)(v20 + 10 * *(signed __int16 *)(v20 + 12) + 28224) = 1;
								goto LABEL_122;
							}
							if (v21 == 2)
								goto LABEL_122;
						}
						else if (x_DWORD_18059C & 1)
						{
							*(x_BYTE *)(v20 + 10 * *(signed __int16 *)(v20 + 12) + 28224) = 1;
							goto LABEL_122;
						}
						*(x_BYTE *)(v20 + 10 * *(signed __int16 *)(v20 + 12) + 28224) = 2;
						goto LABEL_122;
					}
					if (x_DWORD_18059C & 1 && x_DWORD_18059C & 2)
					{
						sub_191B0(6, 64);
						x_D41A0_BYTEARRAY_0[10 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 28223] = a1[501];
					}
					else
					{
						a1[500] = ((x_DWORD_18059C & 1) == 0) + 1;
						sub_6D200(x_D41A0_BYTEARRAY_0[2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 11230]);
						sub_191B0(40, a1[501]);
						x_D41A0_BYTEARRAY_0[10 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 28224] = a1[500];
					}
				}
			}
		LABEL_122:
			if (!(x_DWORD_18059C & 0x10) && !(x_DWORD_18059C & 4) && !(x_DWORD_18059C & 8))
				v33 = 1;
			if (v33)
			{
				if (x_D41A0_BYTEARRAY_0[2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 12221] == 5)
					sub_191B0(20, 0);
				else
					sub_191B0(20, 6);
			}
			else
			{
				if (*(x_DWORD *)(v12 + 8) >= 0)
				{
					if (x_WORD_1805C0 & 1)
						sub_191B0(6, 1);
					if (x_WORD_1805C0 & 2)
						sub_191B0(6, 2);
					if (x_WORD_1805C0 & 4)
						sub_191B0(6, 4);
					if (x_WORD_1805C0 & 8)
						sub_191B0(6, 8);
				}
				if (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 2
					&& v34
					&& !x_D41A0_BYTEARRAY_0[10 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 28222])
				{
					sub_191B0(40, a1[501]);
					x_D41A0_BYTEARRAY_0[10 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 28224] = 0;
				}
			}
			sub_17060(*(x_WORD *)(*(x_DWORD *)(v12 + 164) + 20), *(x_WORD *)(*(x_DWORD *)(v12 + 164) + 22));
			x_BYTE_1806E4 = 0;
			LOBYTE(x_DWORD_18059C) = x_DWORD_18059C & 0xFC;
			LOBYTE(result) = sub_1A7A0();
			goto LABEL_306;
		case 6:
		case 7:
			v24 = x_DWORD_EA3E4[x_D41A0_BYTEARRAY_0[2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 11240]];
			if (x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 1)
				sub_197F0();
			sub_17190();
			if (x_DWORD_18059C & 1 && x_DWORD_18059C & 2 || x_BYTE_1806E4 == x_BYTE_EB39E_keys[4] || *(x_DWORD *)(v24 + 8) < 0)
			{
				sub_191B0(20, 0);
			}
			else if (x_BYTE_1806E4 == 1)
			{
				sub_18B30();
				x_BYTE_1806E4 = 0;
			}
			else
			{
				if (x_DWORD_18059C & 0x10)
				{
					sub_191B0(20, 8);
				}
				else if (x_BYTE_18069C || x_BYTE_180664[x_BYTE_EB39E_keys[9]] || x_BYTE_180664[x_BYTE_EB39E_keys[6]])
				{
					if (x_DWORD_18059C & 1)
					{
						sub_18DA0(v24, 1, 1);
						LOBYTE(x_DWORD_18059C) = x_DWORD_18059C & 0xFE;
					}
					else if (x_DWORD_18059C & 2)
					{
						sub_18DA0(v24, 2, 1);
						LOBYTE(x_DWORD_18059C) = x_DWORD_18059C & 0xFD;
					}
					else if (x_D41A0_BYTEARRAY_0[2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 12221] != 7)
					{
						sub_191B0(20, 7);
					}
				}
				else if (x_BYTE_18068E || x_BYTE_180664[x_BYTE_EB39E_keys[8]])
				{
					if (x_DWORD_18059C & 1)
					{
						sub_18DA0(v24, 1, 0);
						LOBYTE(x_DWORD_18059C) = x_DWORD_18059C & 0xFE;
					}
					else if (x_DWORD_18059C & 2)
					{
						sub_18DA0(v24, 2, 0);
						LOBYTE(x_DWORD_18059C) = x_DWORD_18059C & 0xFD;
					}
				}
				else if (x_D41A0_BYTEARRAY_0[2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 12221] != 6)
				{
					sub_191B0(20, 6);
				}
				sub_18F80(v24);
			}
			if (x_BYTE_1806E4 == 32)
			{
				sub_19A70();
				x_BYTE_1806E4 = 0;
			}
			if (!x_BYTE_180693 || x_D41A0_BYTEARRAY_4[0x96BF])
			{
				if (x_BYTE_180696 && !x_D41A0_BYTEARRAY_4[0x96BF])
					sub_19CA0_sound_proc5(2u);
			}
			else
			{
				sub_19CA0_sound_proc5(1u);
			}
			if (x_BYTE_1806E4 && x_BYTE_E36DC[(unsigned __int8)x_BYTE_1806E4] == 8)
			{
				sub_191B0(39, 1);
				x_BYTE_1806E4 = 0;
			}
			sub_1A8A0();
			sub_17060(x_DWORD_1805B0, x_DWORD_1805B4);
			x_BYTE_1806E4 = 0;
			LOBYTE(x_DWORD_18059C) = x_DWORD_18059C & 0xFC;
			LOBYTE(result) = sub_1A7A0();
			goto LABEL_306;
		case 9:
		case 0xB:
			sub_19AB0();
			LOBYTE(result) = sub_1A7A0();
			goto LABEL_306;
		case 0xA:
		case 0xC:
			sub_1A070(a2, a3);
			LOBYTE(result) = sub_1A7A0();
			goto LABEL_306;
		case 0xD:
		case 0xE:
			sub_19E00();
			goto LABEL_296;
		default:
		LABEL_296:
			LOBYTE(result) = sub_1A7A0();
			goto LABEL_306;
		}
	}
	if (x_BYTE_1806E4)
	{
		LOBYTE(result) = x_BYTE_1806E4;
		if ((unsigned __int8)x_BYTE_1806E4 >= 1u)
		{
			if ((unsigned __int8)x_BYTE_1806E4 <= 1u)
			{
				LOBYTE(result) = sub_18B30();
			}
			else if (x_BYTE_1806E4 == 25)
			{
				LOBYTE(result) = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
				if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10))
					LOBYTE(result) = sub_18BB0();
			}
		}
		x_BYTE_1806E4 = 0;
	}
LABEL_306:
	if (!(x_DWORD_18059C & 1))
		x_WORD_180746 = 0;
	if (!(x_DWORD_18059C & 2))
		x_WORD_180744 = 0;
	return result;
}
// 6D5D0: using guessed type int /*__fastcall*/ _wcpp_1_unwind_leave__120(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// D41B6: using guessed type char x_BYTE_D41B6;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB3A2: using guessed type char x_BYTE_EB3A2;
// EB3A4: using guessed type char x_BYTE_EB3A4;
// EB3A5: using guessed type char x_BYTE_EB3A5;
// EB3A6: using guessed type char x_BYTE_EB3A6;
// EB3A7: using guessed type char x_BYTE_EB3A7;
// 180559: using guessed type char x_BYTE_180559;
// 18059C: using guessed type int x_DWORD_18059C;
// 1805B0: using guessed type int x_DWORD_1805B0;
// 1805B4: using guessed type int x_DWORD_1805B4;
// 1805C0: using guessed type __int16 x_WORD_1805C0;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;
// 18068E: using guessed type char x_BYTE_18068E;
// 180693: using guessed type char x_BYTE_180693;
// 180696: using guessed type char x_BYTE_180696;
// 18069A: using guessed type char x_BYTE_18069A;
// 18069C: using guessed type char x_BYTE_18069C;
// 1806E4: using guessed type char x_BYTE_1806E4;
// 180744: using guessed type __int16 x_WORD_180744;
// 180746: using guessed type __int16 x_WORD_180746;

//----- (00018AA0) --------------------------------------------------------
int sub_18AA0()
{
	int result; // eax
	char v1; // bl
	char v2; // bh

	result = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
	v1 = 1;
	if (x_D41A0_BYTEARRAY_4_struct.byteindex_A)
	{
		x_D41A0_BYTEARRAY_4_struct.byteindex_A = 0;
	}
	else
	{
		sub_87090();
		if (x_BYTE_180552)
		{
			result = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
			x_D41A0_BYTEARRAY_4_struct.byteindex_A = 1;
		}
		else
		{
			v1 = 0;
			result = sub_19760("No Help Data", 3u, 50);
		}
	}
	if (v1)
	{
		x_BYTE_18055A = -1;
		v2 = x_D41A0_BYTEARRAY_4_struct.byteindex_A;
		x_D41A0_BYTEARRAY_4[0x9602] = 1;
		result = sub_19760((char *)x_DWORD_E9C4C_langindexbuffer[(v2 == 0) + 400], 3u, 50);
	}
	return result;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// 180552: using guessed type char x_BYTE_180552;
// 18055A: using guessed type char x_BYTE_18055A;

//----- (00018B30) --------------------------------------------------------
char sub_18B30()
{
	int v0; // eax
	unsigned __int8 v1; // dh

	v0 = x_D41A0_BYTEARRAY_0[2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12];
	if (!(*(x_BYTE *)(v0 + 11232) & 0x20))
	{
		v1 = *(x_BYTE *)(v0 + 12221);
		if (v1 != 13 && v1 != 14)
		{
			if (v1 < 6u || v1 > 8u && (v1 < 0xBu || v1 > 0xCu))
				sub_191B0(20, 13);
			else
				sub_191B0(20, 14);
			LOBYTE(v0) = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
			x_D41A0_BYTEARRAY_4[0x9692] = 1;
		}
		else
		{
			sub_191B0(29, 0);
			LOBYTE(v0) = sub_191B0(27, 0);
		}
	}
	return v0;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (00018BB0) --------------------------------------------------------
int sub_18BB0()
{
	int v0; // eax
	char v1; // dl
	char v2; // cl
	int v3; // eax
	int v4; // edx
	int result; // eax

	v0 = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
	v1 = x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 ^ 1;
	x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 = v1;
	if (v1 & 1)
	{
		if (x_D41A0_BYTEARRAY_0[0x36E09 + 2] & 2)//if ( *(0x36E09 + x_D41A0_BYTEARRAY_0 + 2) & 2 )
		{
			*(x_BYTE *)(v0 + 24) &= 0xFEu;
		}
		else
		{
			x_D41A0_BYTEARRAY_0[0x36E03 + 1] = 0;
			v2 = *(x_BYTE *)(v0 + 206);
			x_BYTE_18055A = -1;
			if (!v2 && (x_WORD_1805C2 == 7 || x_WORD_1805C2 == 1 || x_WORD_1805C2 == 2))
				sub_8CD27_set_cursor(*filearray_2aa18c[x_BYTE_D419E].posistruct);
			sub_41AF0();
			if (!x_D41A0_BYTEARRAY_4[0xCE])
				sub_8CD27_set_cursor(*filearray_2aa18c[x_BYTE_D419E].posistruct);
			sub_52E90(
				x_D41A0_BYTEARRAY_0[2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 11230],
				x_D41A0_BYTEARRAY_0[2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 12221],
				1);
			if (x_BYTE_E3799)
				sub_8D8F0_sound_proc3_endsample();
			if (x_BYTE_E37FD)
				sub_8E020_sound_proc14_stopsequence();
			if (x_D41A0_BYTEARRAY_4[0xE1])
				x_D41A0_BYTEARRAY_4[0xE1] = 2;
		}
	}
	else
	{
		sub_41B60();
		v3 = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
		v4 = 0;//fix it
		//v4 = **filearray_2aa18c[0]; //fix it
		x_D41A0_BYTEARRAY_4[0xCD] = 0;
		*(x_BYTE *)(v3 + 206) = 0;
		sub_8CD27_set_cursor(*filearray_2aa18c[0].posistruct);
		sub_52E90(
			x_D41A0_BYTEARRAY_0[2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 11230],
			x_D41A0_BYTEARRAY_0[2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 12221],
			1);
		if (x_BYTE_E37FD)
			sub_8E160_sound_proc15_startsequence(*(x_WORD *)(x_D41A0_BYTEARRAY_0 + 565), 0x7Fu);
		sub_86930(x_WORD_1803EC);
		if (x_D41A0_BYTEARRAY_4[0xE1])
			x_D41A0_BYTEARRAY_4[0xE1] = 1;
	}
	LOBYTE(result) = sub_55C00(x_D41A0_BYTEARRAY_4_struct.levelnumber_43);
	x_D41A0_BYTEARRAY_4[0xD0] = result;
	return result;
}
// D419E: using guessed type char x_BYTE_D419E;
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// E3799: using guessed type char x_BYTE_E3799;
// E37FD: using guessed type char x_BYTE_E37FD;
// EB394: using guessed type int **filearray_2aa18c[0];
// 1803EC: using guessed type __int16 x_WORD_1803EC;
// 18055A: using guessed type char x_BYTE_18055A;
// 1805C2: using guessed type __int16 x_WORD_1805C2;

//----- (00018DA0) --------------------------------------------------------
char sub_18DA0(int a1, char a2, char a3)
{
	int v3; // edx
	signed int v4; // esi
	signed int v5; // eax
	int v6; // eax
	int v7; // ebx
	int v8; // edi
	int v9; // edx
	signed int v10; // ebx
	signed int v11; // esi
	signed int v12; // eax
	int v13; // ebx
	int v14; // edi
	int v15; // edx
	signed int v16; // ebx

	v3 = *(x_DWORD *)(a1 + 164) + 611;
	if (a2 == 2)
	{
		v4 = 0;
		if (a3)
			v5 = -1;
		else
			v5 = 1;
		v6 = *(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 1107) + v5;
		while (1)
		{
			if (a3 || v6 < 26)
			{
				if (a3 == 1 && v6 < 0)
					v6 = 25;
			}
			else
			{
				v6 = 0;
			}
			v7 = (unsigned __int8)x_BYTE_D94FF[v6];
			if (*(x_WORD *)(v3 + 2 * v7 + 208))
			{
				v8 = v3 + v7;
				if (*(x_BYTE *)(v3 + v7 + 338) == 2)
					break;
			}
			if (a3)
				v10 = -1;
			else
				v10 = 1;
			++v4;
			v6 += v10;
			if (v4 >= 26)
				return v6;
		}
		*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 1115) = v6;
		v9 = (int)x_D41A0_BYTEARRAY_0;
		*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 10 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 28222) = 32;
		*(x_BYTE *)(v9 + 10 * *(signed __int16 *)(v9 + 12) + 28223) = v7;
		LOBYTE(v6) = *(x_BYTE *)(v8 + 468);
		*(x_BYTE *)(10 * *(signed __int16 *)(v9 + 12) + v9 + 28224) = v6;
	}
	else
	{
		v11 = 0;
		if (a3)
			v12 = -1;
		else
			v12 = 1;
		v6 = *(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 1105) + v12;
		while (1)
		{
			if (a3 || v6 < 26)
			{
				if (a3 == 1 && v6 < 0)
					v6 = 25;
			}
			else
			{
				v6 = 0;
			}
			v13 = (unsigned __int8)x_BYTE_D94FF[v6];
			if (*(x_WORD *)(v3 + 2 * v13 + 208))
			{
				v14 = v3 + v13;
				if (*(x_BYTE *)(v3 + v13 + 338) == 1)
					break;
			}
			if (a3)
				v16 = -1;
			else
				v16 = 1;
			++v11;
			v6 += v16;
			if (v11 >= 26)
				return v6;
		}
		*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 1114) = v6;
		v15 = (int)x_D41A0_BYTEARRAY_0;
		*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 10 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 28222) = 31;
		*(x_BYTE *)(v15 + 10 * *(signed __int16 *)(v15 + 12) + 28223) = v13;
		LOBYTE(v6) = *(x_BYTE *)(v14 + 468);
		*(x_BYTE *)(10 * *(signed __int16 *)(v15 + 12) + v15 + 28224) = v6;
	}
	return v6;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00018F80) --------------------------------------------------------
char sub_18F80(int a1)
{
	int v1; // eax
	int v2; // edx
	int v3; // eax
	int v4; // eax
	int v5; // edx

	if (x_WORD_1805C0 & 1)
		sub_191B0(6, 1);
	if (x_WORD_1805C0 & 2)
		sub_191B0(6, 2);
	if (x_WORD_1805C0 & 4)
		sub_191B0(6, 4);
	if (x_WORD_1805C0 & 8)
		sub_191B0(6, 8);
	v1 = *(x_DWORD *)(a1 + 164);
	v2 = *(signed __int16 *)(v1 + 1105);
	if (v2 == -1)
	{
		LOBYTE(x_DWORD_18059C) = x_DWORD_18059C & 0xFE;
	}
	else
	{
		v3 = x_DWORD_EA3E4[*(signed __int16 *)(v1 + 2 * v2 + 819)];
		if (*(x_BYTE *)(v3 + 59) == 1)
		{
			if (x_DWORD_18059C & 1)
			{
				sub_191B0(6, 16);
				LOBYTE(x_DWORD_18059C) = x_DWORD_18059C & 0xFE;
			}
		}
		else if (x_DWORD_18059C & 1 || x_DWORD_18059C & 4 && *(x_WORD *)(v3 + 46) > 0)
		{
			sub_191B0(6, 16);
			LOBYTE(x_DWORD_18059C) = x_DWORD_18059C & 0xFE;
		}
	}
	v4 = *(x_DWORD *)(a1 + 164);
	v5 = *(signed __int16 *)(v4 + 1107);
	if (v5 == -1)
	{
		LOBYTE(x_DWORD_18059C) = x_DWORD_18059C & 0xFD;
	}
	else
	{
		v4 = x_DWORD_EA3E4[*(signed __int16 *)(v4 + 2 * v5 + 819)];
		if (*(x_BYTE *)(v4 + 59) == 1)
		{
			if (x_DWORD_18059C & 2)
			{
				LOBYTE(v4) = sub_191B0(6, 32);
				LOBYTE(x_DWORD_18059C) = x_DWORD_18059C & 0xFD;
			}
		}
		else if (x_DWORD_18059C & 2 || x_DWORD_18059C & 8 && *(x_WORD *)(v4 + 46) > 0)
		{
			LOBYTE(v4) = sub_191B0(6, 32);
			LOBYTE(x_DWORD_18059C) = x_DWORD_18059C & 0xFD;
		}
	}
	return v4;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// 18059C: using guessed type int x_DWORD_18059C;
// 1805C0: using guessed type __int16 x_WORD_1805C0;

//----- (000191B0) --------------------------------------------------------
char sub_191B0(__int16 a1, char a2)
{
	Bit8u* v2; // edx
	char result; // al
	Bit8u* v4; // esi
	int v5; // ecx
	Bit8u* v6; // ebx
	int v7; // ecx
	Bit8u* v8; // ebx
	int v9; // esi
	int v10; // ebx
	Bit8u* v11; // ebx
	int v12; // esi
	Bit8u* v13; // ecx
	int v14; // esi
	Bit8u* v15; // esi
	x_BYTE *v16; // ebx
	Bit8u* v17; // ebx
	Bit8u* v18; // ebx

	v2 = x_D41A0_BYTEARRAY_0;
	result = a1;
	switch (a1)
	{
	case 0:
	case 1:
	case 2:
	case 26:
		goto LABEL_23;
	case 3:
	case 7:
	case 8:
	case 9:
	case 10:
	case 11:
		goto LABEL_40;
	case 4:
		v4 = &x_D41A0_BYTEARRAY_0[10 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12];
		if (*(char *)(v4 + 28222) != a1 && *(x_BYTE *)(v4 + 28222))
			goto LABEL_40;
		v5 = (int)x_D41A0_BYTEARRAY_0;
		x_D41A0_BYTEARRAY_0[10 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 28222] = a1;
		result = a2;
		x_D41A0_BYTEARRAY_0[v5 + 10 * *(signed __int16 *)(v2 + 12) + 28223] |= a2;
		x_D41A0_BYTEARRAY_0 = v2;
		return result;
	case 5:
	case 6:
		v6 = &x_D41A0_BYTEARRAY_0[10 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12];
		if (*(char *)(v6 + 28222) != a1 && *(x_BYTE *)(v6 + 28222))
			goto LABEL_40;
		v7 = (int)x_D41A0_BYTEARRAY_0;
		*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 10 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 28222) = a1;
		result = a2;
		*(x_BYTE *)(v7 + 10 * *(signed __int16 *)(v2 + 12) + 28227) |= a2;
		x_D41A0_BYTEARRAY_0 = v2;
		return result;
	case 12:
	case 13:
	case 14:
	case 16:
	case 18:
	case 19:
	case 29:
	case 42:
	case 44:
		v15 = &x_D41A0_BYTEARRAY_0[10 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12];
		if (*(char *)(v15 + 28222) != a1 && *(x_BYTE *)(v15 + 28222))
			goto LABEL_40;
	LABEL_23:
		x_D41A0_BYTEARRAY_0[10 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 28222] = a1;
		x_D41A0_BYTEARRAY_0 = v2;
		return result;
	case 15:
		v8 = &x_D41A0_BYTEARRAY_0[10 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12];
		if (*(char *)(v8 + 28222) != a1 && *(x_BYTE *)(v8 + 28222))
			goto LABEL_40;
		v9 = x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
		v10 = x_DWORD_EA3E4[*(unsigned __int16 *)(x_D41A0_BYTEARRAY_0 + 2124 * v9 + 11240)];
		if (*(x_DWORD *)(v10 + 8) >= 0 || *(x_BYTE *)(v10 + 69) != 3)
			goto LABEL_40;
		*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 10 * v9 + 28222) = a1;
		x_D41A0_BYTEARRAY_0 = v2;
		return result;
	case 27:
		v11 = &x_D41A0_BYTEARRAY_0[10 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12];
		if (*(char *)(v11 + 28222) != a1 && *(x_BYTE *)(v11 + 28222))
			goto LABEL_40;
		v12 = x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
		if (!(*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 2124 * v12 + 11232) & 2))
			goto LABEL_40;
		*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 10 * v12 + 28222) = a1;
		x_D41A0_BYTEARRAY_0 = v2;
		return result;
	case 28:
		v13 = &x_D41A0_BYTEARRAY_0[10 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12];
		if (*(char *)(v13 + 28222) != a1 && *(x_BYTE *)(v13 + 28222))
			goto LABEL_40;
		v14 = x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
		if (!(*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 2124 * v14 + 11232) & 4))
			goto LABEL_40;
		*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 10 * v14 + 28222) = a1;
		x_D41A0_BYTEARRAY_0 = v2;
		return result;
	case 30:
		if (x_D41A0_BYTEARRAY_4[0x17] < 0
			|| (v16 = (x_BYTE *)(x_D41A0_BYTEARRAY_0 + 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12), v16[12157] == 99)
			&& v16[12158] == 104
			&& v16[12159] == 114
			&& v16[12160] == 111
			&& v16[12161] == 110
			&& v16[12162] == 105
			&& v16[12163] == 99
			&& v16[12164] == 108
			&& v16[12165] == 101)
		{
			v17 = &x_D41A0_BYTEARRAY_0[10 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12];
			if (*(char *)(v17 + 28222) == a1 || !*(x_BYTE *)(v17 + 28222))
				goto LABEL_39;
		}
		goto LABEL_40;
	case 39:
		goto LABEL_39;
	default:
		v18 = &x_D41A0_BYTEARRAY_0[10 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12];
		if (*(char *)(v18 + 28222) == a1 || !*(x_BYTE *)(v18 + 28222))
		{
		LABEL_39:
			*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 10 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 28222) = a1;
			result = a2;
			*(x_BYTE *)(v2 + 10 * *(signed __int16 *)(v2 + 12) + 28223) = a2;
		}
	LABEL_40:
		x_D41A0_BYTEARRAY_0 = v2;
		return result;
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00019760) --------------------------------------------------------
int sub_19760(const char *a1, unsigned __int8 a2, __int16 a3)
{
	char *v3; // esi
	char *v4; // edi
	char v5; // al
	char v6; // al
	int result; // eax

	v3 = (char*)a1;
	v4 = (char *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11230 + 28);
	do
	{
		v5 = *v3;
		*v4 = *v3;
		if (!v5)
			break;
		v6 = v3[1];
		v3 += 2;
		v4[1] = v6;
		v4 += 2;
	} while (v6);
	result = (int)x_D41A0_BYTEARRAY_0;
	*(x_WORD *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11307) = a3;
	*(x_WORD *)(2124 * *(signed __int16 *)(result + 12) + result + 11309) = a2;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (000197F0) --------------------------------------------------------
int sub_197F0()
{
	int result; // eax
	char v1; // bl
	signed int v2; // ebx
	signed int v3; // edx
	unsigned __int8 v4; // al
	unsigned __int8 v5; // al
	int v6; // [esp+0h] [ebp-10h]
	int v7; // [esp+4h] [ebp-Ch]
	int v8; // [esp+8h] [ebp-8h]
	int v9; // [esp+Ch] [ebp-4h]

	result = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
	if (x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 1)
	{
		v1 = x_D41A0_BYTEARRAY_4[0xE1];
		x_BYTE_18055A = -1;
		if (!v1 && !x_D41A0_BYTEARRAY_4[0x96BF])
		{
			if (*(x_BYTE *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 12221) == 7)
			{
				sub_8CD27_set_cursor(*filearray_2aa18c[0].posistruct);
			}
			else if (x_WORD_1805C2 == 7 || x_WORD_1805C2 == 1 || x_WORD_1805C2 == 2)
			{
				sub_8CD27_set_cursor(*filearray_2aa18c[x_BYTE_D419E].posistruct);
			}
			if (!x_D41A0_BYTEARRAY_4[0xCE])
			{
				sub_2FFE0(&v8, &v9, &v6, &v7);
				if (x_DWORD_1805B0 >= v8 && v8 + v6 > x_DWORD_1805B0)
				{
					v2 = -1;
					v3 = 0;
					while (v3 < 4 && v2 < 0)
					{
						if (v9 <= x_DWORD_1805B4 && v9 + v7 > x_DWORD_1805B4)
							v2 = v3;
						++v3;
						v9 += v7;
					}
					if (v2 >= 0)
					{
						if (v2 != 2 || v8 + v6 / 2 > x_DWORD_1805B0)
						{
							if (v2 > 2)
								++v2;
						}
						else
						{
							v2 = 3;
						}
						x_BYTE_18055A = v2;
						if (x_DWORD_18059C & 1 || x_DWORD_18059C & 2)
						{
							switch (v2)
							{
							case 0:
								v4 = *(x_BYTE *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 12221);
								if (v4 < 6u || v4 > 8u)
									sub_191B0(20, 13);
								else
									sub_191B0(20, 14);
								x_D41A0_BYTEARRAY_4[0x9692] = 3;
								return sub_19A50();
							case 1:
								if (!x_D41A0_BYTEARRAY_4[0xD0])
									break;
								v5 = *(x_BYTE *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 12221);
								if (v5 < 6u || v5 > 8u)
									sub_191B0(20, 13);
								else
									sub_191B0(20, 14);
								x_D41A0_BYTEARRAY_4[0x9692] = 2;
								return sub_19A50();
							case 2:
								sub_19CA0_sound_proc5(1u);
								return sub_19A50();
							case 3:
								sub_19CA0_sound_proc5(2u);
								return sub_19A50();
							case 4:
								sub_19A70();
								break;
							default:
								break;
							}
						}
					}
				}
			}
			result = sub_19A50();
		}
	}
	return result;
}
// D419E: using guessed type char x_BYTE_D419E;
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EB394: using guessed type int **filearray_2aa18c[0];
// 18055A: using guessed type char x_BYTE_18055A;
// 18059C: using guessed type int x_DWORD_18059C;
// 1805B0: using guessed type int x_DWORD_1805B0;
// 1805B4: using guessed type int x_DWORD_1805B4;
// 1805C2: using guessed type __int16 x_WORD_1805C2;

//----- (00019A50) --------------------------------------------------------
__int64 sub_19A50()
{
	__int64 result; // rax

	BYTE1(result) = x_DWORD_18059C;
	if (x_DWORD_18059C & 1 || x_DWORD_18059C & 2)
		LOBYTE(x_DWORD_18059C) = x_DWORD_18059C & 0xFC;
	return result;
}
// 18059C: using guessed type int x_DWORD_18059C;

//----- (00019A70) --------------------------------------------------------
char sub_19A70()
{
	unsigned __int8 v0; // al
	char result; // al

	v0 = *(x_BYTE *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 12221);
	if (v0 < 6u || v0 > 8u)
		result = sub_191B0(20, 9);
	else
		result = sub_191B0(20, 11);
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00019AB0) --------------------------------------------------------
__int64 sub_19AB0()
{
	int v0; // eax
	signed int v1; // ebx
	int v2; // edx
	signed int v3; // eax

	if (x_WORD_1805C2 == 7 || x_WORD_1805C2 == 1 || x_WORD_1805C2 == 2)
		sub_8CD27_set_cursor(*filearray_2aa18c[x_BYTE_D419E].posistruct); //fix it
	if (x_BYTE_1806E4 == 1)
	{
		sub_18B30();
		x_BYTE_1806E4 = 0;
		return sub_19A50();
	}
	if (!(x_DWORD_18059C & 1) && !(x_DWORD_18059C & 2) && x_BYTE_1806E4 != 28 && x_BYTE_1806E4 != 32)
		return sub_19A50();
	v0 = (640 - x_D41A0_BYTEARRAY_4[0xBA]) / 2 + (x_D41A0_BYTEARRAY_4[0xBA] - 82) / 2;
	if (v0 <= x_DWORD_1805B0 && v0 + 82 > x_DWORD_1805B0 && x_DWORD_1805B4 >= 377 && x_DWORD_1805B4 < 395
		|| x_BYTE_1806E4 == 28
		|| x_BYTE_1806E4 == 32)
	{
		x_D41A0_BYTEARRAY_4[0xE1] = 0;
		if (*(x_BYTE *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 12221) == 9)
			sub_191B0(20, 0);
		else
			sub_191B0(20, 6);
		sub_8CD27_set_cursor(*filearray_2aa18c[0].posistruct);
		x_BYTE_1806E4 = 0;
		return sub_19A50();
	}
	v1 = 0;
	v2 = (640 - x_D41A0_BYTEARRAY_4[0xBA]) / 2;
	v3 = 67;
	do
	{
		if (v2 <= x_DWORD_1805B0
			&& v2 + x_D41A0_BYTEARRAY_4[0xBA] > x_DWORD_1805B0
			&& v3 <= x_DWORD_1805B4
			&& v3 + 18 > x_DWORD_1805B4)
		{
			sub_1A970(v1 + 1, (x_DWORD_18059C & 1) == 0, 1);
			sub_1A280();
			return sub_19A50();
		}
		++v1;
		v3 += 18;
	} while (v1 < 17);
	return sub_19A50();
}
// D419E: using guessed type char x_BYTE_D419E;
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EB394: using guessed type int **filearray_2aa18c[0];
// 18059C: using guessed type int x_DWORD_18059C;
// 1805B0: using guessed type int x_DWORD_1805B0;
// 1805B4: using guessed type int x_DWORD_1805B4;
// 1805C2: using guessed type __int16 x_WORD_1805C2;
// 1806E4: using guessed type char x_BYTE_1806E4;

//----- (00019CA0) --------------------------------------------------------
void sub_19CA0_sound_proc5(unsigned __int8 a1)
{
	__int16 v1; // ST00_2
	int v2; // edx
	int v3; // eax
	unsigned __int8 v4; // al

	if (a1 >= 1u)
	{
		if (a1 <= 1u)
		{
			if (x_BYTE_E3798_sound_active2)
			{
				x_D41A0_BYTEARRAY_4[0x96BF] = a1;
				x_BYTE_E3799 = 1;
			}
		}
		else if (a1 == 2 && x_BYTE_E37FC)
		{
			x_D41A0_BYTEARRAY_4[0x96BF] = 2;
			v1 = *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 565);
			x_BYTE_E37FD = 1;
			sub_8E160_sound_proc15_startsequence(v1, 0x7Fu);
		}
	}
	v2 = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
	if (x_D41A0_BYTEARRAY_4[0x96BF])
	{
		v3 = (int)x_D41A0_BYTEARRAY_0;
		x_D41A0_BYTEARRAY_0[0x36E03 + 1] = 0;
		*(x_BYTE *)(v2 + 38402) = 1;
		v4 = *(x_BYTE *)(2124 * *(signed __int16 *)(v3 + 12) + v3 + 12221);
		if (v4 < 6u || v4 > 8u)
			sub_191B0(20, 10);
		else
			sub_191B0(20, 12);
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// E3798: using guessed type char x_BYTE_E3798_sound_active2;
// E3799: using guessed type char x_BYTE_E3799;
// E37FC: using guessed type char x_BYTE_E37FC;
// E37FD: using guessed type char x_BYTE_E37FD;

//----- (00019D60) --------------------------------------------------------
int sub_19D60(signed int a1, int a2)
{
	unsigned __int8 v2; // dl
	int v4; // [esp+0h] [ebp-10h]
	int v5; // [esp+4h] [ebp-Ch]
	int v6; // [esp+8h] [ebp-8h]
	int v7; // [esp+Ch] [ebp-4h]

	v2 = x_D41A0_BYTEARRAY_4[0x96BF];
	if (v2 >= 1u)
	{
		if (v2 <= 1u)
		{
			a1 = 127;
			a2 = x_D41A0_BYTEARRAY_4_struct.dwordindex_6;
		}
		else if (v2 == 2)
		{
			a1 = 127;
			a2 = x_D41A0_BYTEARRAY_4_struct.dwordindex_8;
		}
	}
	sub_2FFE0(&v7, &v6, &v5, &v4);
	return sub_5BDC0_set_mouse_position((unsigned int)(a2 * (v5 - 12) / a1) + 5 + v7, 9 * v4 / 2 + v6);
}
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (00019E00) --------------------------------------------------------
char sub_19E00()
{
	char v0; // bl
	char v1; // bh
	int v2; // eax
	unsigned __int8 v3; // dl
	//char v5; // [esp+0h] [ebp-Ah]
	int v6; // [esp+80h] [ebp+76h]
	int v7; // [esp+84h] [ebp+7Ah]
	char v8; // [esp+88h] [ebp+7Eh]

	v0 = 0;
	v8 = 0;
	v1 = 0;
	LOBYTE(v2) = (unsigned int)sub_30BE0(&v7, &v6);
	if (x_BYTE_1806E4)
	{
		LOBYTE(v2) = x_BYTE_1806E4;
		if ((unsigned __int8)x_BYTE_1806E4 >= 1u)
		{
			if ((unsigned __int8)x_BYTE_1806E4 <= 1u)
			{
				v8 = 1;
			}
			else if (x_BYTE_1806E4 == 28)
			{
				v0 = 1;
			}
		}
		x_BYTE_1806E4 = 0;
	}
	else if (x_DWORD_18059C & 1 || x_DWORD_18059C & 2)
	{
		if (v7 > x_DWORD_1805B0 || v7 + 50 <= x_DWORD_1805B0 || v6 > x_DWORD_1805B4 || v6 + 32 <= x_DWORD_1805B4)
		{
			if (v7 + 50 <= x_DWORD_1805B0 && v7 + 100 > x_DWORD_1805B0 && v6 <= x_DWORD_1805B4 && v6 + 32 > x_DWORD_1805B4)
				v8 = 1;
		}
		else
		{
			v0 = 1;
		}
		LOBYTE(v2) = sub_19A50();
	}
	if (!v0)
		goto LABEL_37;
	LOBYTE(v2) = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
	v3 = x_D41A0_BYTEARRAY_4[0x9692];
	if (v3 >= 2u)
	{
		if (v3 > 2u)
		{
			if (v3 == 3)
			{
				if (sub_55080(0, x_D41A0_BYTEARRAY_4_struct.levelnumber_43))
					sprintf_s(printbuffer, 512, "%s:%s.", x_DWORD_E9C4C_langindexbuffer[424], "OK");
				else
					sprintf_s(printbuffer, 512, "%s:%s.", x_DWORD_E9C4C_langindexbuffer[424], x_DWORD_E9C4C_langindexbuffer[429]);
				sub_52D70(0, printbuffer);
				LOBYTE(v2) = sub_55C00(x_D41A0_BYTEARRAY_4_struct.levelnumber_43);
				v1 = 1;
				x_D41A0_BYTEARRAY_4[0xD0] = v2;
			}
			goto LABEL_38;
		}
		if (x_D41A0_BYTEARRAY_4[0xD0])
		{
			if (sub_555D0(0, x_D41A0_BYTEARRAY_4_struct.levelnumber_43))
				sprintf_s(printbuffer, 512, "%s:%s.", x_DWORD_E9C4C_langindexbuffer[423], "OK");
			else
				sprintf_s(printbuffer, 512, "%s:%s.", x_DWORD_E9C4C_langindexbuffer[423], x_DWORD_E9C4C_langindexbuffer[429]);
			LOBYTE(v2) = sub_52D70(0, printbuffer);
		}
	LABEL_37:
		v1 = 1;
		goto LABEL_38;
	}
	if (v3 == 1)
		LOBYTE(v2) = sub_18B30();
LABEL_38:
	if (v0 || v8)
	{
		v2 = x_D41A0_BYTEARRAY_4[0];
		x_D41A0_BYTEARRAY_4[0x9692] = 0;
		if (v1)
			LOBYTE(v2) = sub_191B0(20, *(x_BYTE *)(v2 + 38544));
	}
	return v2;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// D41A4: using guessed type int x_DWORD_D41A4;
// EA2E8: using guessed type int x_DWORD_EA2E8;
// EA2EC: using guessed type int x_DWORD_EA2EC;
// EA300: using guessed type int x_DWORD_EA300;
// 18059C: using guessed type int x_DWORD_18059C;
// 1805B0: using guessed type int x_DWORD_1805B0;
// 1805B4: using guessed type int x_DWORD_1805B4;
// 1806E4: using guessed type char x_BYTE_1806E4;

//----- (0001A030) --------------------------------------------------------
int sub_1A030()
{
	int v1; // [esp+0h] [ebp-8h]
	int v2; // [esp+4h] [ebp-4h]

	sub_30BE0(&v2, &v1);
	return sub_5BDC0_set_mouse_position(v2 + 87, v1 + 24);
}

//----- (0001A070) --------------------------------------------------------
void sub_1A070(signed int a1, __int16 a2)
{
	unsigned __int8 v2; // al
	int v3; // eax
	int v4; // edx
	int v5; // esi
	int v6; // ebx
	int v7; // eax
	int v8; // ett
	int v9; // ebx
	unsigned __int8 v10; // dl
	int v11; // eax
	int v12; // [esp+0h] [ebp-10h]
	int v13; // [esp+4h] [ebp-Ch]
	int v14; // [esp+8h] [ebp-8h]
	int v15; // [esp+Ch] [ebp-4h]

	if (x_WORD_1805C2 == 7 || x_WORD_1805C2 == 1 || x_WORD_1805C2 == 2)
		sub_8CD27_set_cursor(*filearray_2aa18c[x_BYTE_D419E].posistruct); //fixit
	sub_2FFE0(&v15, &v14, &v13, &v12);
	v2 = x_D41A0_BYTEARRAY_4[0x96BF];
	if (v2 >= 1u)
	{
		if (v2 <= 1u)
		{
			v3 = v13;
			v4 = v13;
		}
		else
		{
			if (v2 != 2)
				goto LABEL_12;
			v4 = 3 * v13;
			v3 = 3 * v13;
		}
		a1 = 127;
		a2 = (v3 - (__CFSHL__(v4 >> 31, 2) + 4 * (v4 >> 31))) >> 2;
	}
LABEL_12:
	if (x_DWORD_18059C & 1 || x_DWORD_18059C & 2 || x_DWORD_18059C & 4 || x_DWORD_18059C & 8 || x_BYTE_180693 || x_BYTE_180696)
	{
		v5 = v13 - 12;
		v6 = x_DWORD_1805B0 - (v15 + 4);
		if (v6 < 0)
			v6 = 0;
		if (v6 > v5)
			v6 = v13 - 12;
		v8 = a1 * v6;
		v7 = a1 * v6 / v5;
		v9 = a1 * v6 / v5;
		if (v8 / v5 < 0)
			v9 ^= v7;
		if (v9 > 127)
			v9 = 127;
		v10 = x_D41A0_BYTEARRAY_4[0x96BF];
		if (v10 >= 1u)
		{
			if (v10 <= 1u)
			{
				sub_6E450(
					*(x_WORD *)(x_D41A0_BYTEARRAY_0 + 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 11240),
					*(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12),
					8);
				sub_6E150();
				if (x_D41A0_BYTEARRAY_4_struct.dwordindex_6 != v9)
				{
					x_D41A0_BYTEARRAY_4_struct.dwordindex_6 = v9;
					sub_8E470_sound_proc17_volume((signed __int16)v9);
				}
			}
			else if (v10 == 2 && x_D41A0_BYTEARRAY_4_struct.dwordindex_8 != v9)
			{
				x_D41A0_BYTEARRAY_4_struct.dwordindex_8 = v9;
				sub_8E410_sound_proc16_xmidivolume(v9);
			}
		}
		sub_19A50();
	}
	else
	{
		v11 = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
		x_D41A0_BYTEARRAY_4[0x96BF] = x_BYTE_180693;
		sub_191B0(20, *(x_BYTE *)(v11 + 38544));
		sub_8CD27_set_cursor(*filearray_2aa18c[0].posistruct);//fix it
		sub_5BDC0_set_mouse_position(v15 + a2, v14 + 5 * v12 / 2);
		if (x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 1)
		{
			sub_8D8F0_sound_proc3_endsample();
			sub_8E020_sound_proc14_stopsequence();
		}
	}
}
// D419E: using guessed type char x_BYTE_D419E;
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EB394: using guessed type int **filearray_2aa18c[0];
// 18059C: using guessed type int x_DWORD_18059C;
// 1805B0: using guessed type int x_DWORD_1805B0;
// 1805C2: using guessed type __int16 x_WORD_1805C2;
// 180693: using guessed type char x_BYTE_180693;
// 180696: using guessed type char x_BYTE_180696;

//----- (0001A280) --------------------------------------------------------
int sub_1A280()
{
	int v0; // edx
	Bit8u* v1; // ebx
	char v2; // cl
	char v3; // ch
	char v4; // cl
	char v5; // ch
	int result; // eax

	v0 = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
	v1 = x_D41A0_BYTEARRAY_0;
	x_D41A0_BYTEARRAY_4[0xC0] = 0;
	v2 = *(x_BYTE *)(v0 + 192) | 1;
	*(x_BYTE *)(v0 + 192) = v2;
	if (x_BYTE_E3798_sound_active2)
		*(x_BYTE *)(v0 + 192) = v2 | 2;
	if (x_BYTE_E37FC)
		*(x_BYTE *)(v0 + 192) |= 4u;
	if (x_BYTE_E2A28)
		*(x_BYTE *)(v0 + 192) |= 8u;
	*(x_BYTE *)(v0 + 192) |= 0xF0u;
	if (v1[8618])
		*(x_BYTE *)(v0 + 193) |= 1u;
	if (v1[8619])
		*(x_BYTE *)(v0 + 193) |= 4u;
	if (v1[8620])
		*(x_BYTE *)(v0 + 193) |= 2u;
	if (v1[8630])
		*(x_BYTE *)(v0 + 193) |= 8u;
	v3 = *(x_BYTE *)(v0 + 193) | 0x10;
	*(x_BYTE *)(v0 + 193) = v3;
	if (v1[8632])
		*(x_BYTE *)(v0 + 193) = v3 | 0x20;
	if (v1[8633])
		*(x_BYTE *)(v0 + 193) |= 0x40u;
	if (v1[8628])
		*(x_BYTE *)(v0 + 193) |= 0x80u;
	*(x_BYTE *)(v0 + 194) |= 1u;
	v4 = *(x_BYTE *)(v0 + 10);
	*(x_DWORD *)(v0 + 188) = 0;
	if (v4)
		*(x_BYTE *)(v0 + 188) |= 1u;
	if (x_BYTE_E3799)
		*(x_BYTE *)(v0 + 188) |= 2u;
	if (x_BYTE_E37FD)
		*(x_BYTE *)(v0 + 188) |= 4u;
	if (*(x_BYTE *)(v0 + 24) & 0x40)
		*(x_BYTE *)(v0 + 188) |= 8u;
	if (v1[(x_DWORD)&loc_36DE9 + 1])
		*(x_BYTE *)(v0 + 188) |= 0x10u;
	v5 = *(x_BYTE *)(v0 + 188) | 0x20;
	*(x_BYTE *)(v0 + 188) = v5;
	if (*(x_BYTE *)(v0 + 178))
		*(x_BYTE *)(v0 + 188) = v5 | 0x40;
	*(x_BYTE *)(v0 + 188) |= 0x80u;
	if (v1[8586])
		*(x_BYTE *)(v0 + 189) |= 1u;
	if (v1[8587])
		*(x_BYTE *)(v0 + 189) |= 4u;
	if (v1[8588])
		*(x_BYTE *)(v0 + 189) |= 2u;
	if (v1[8598])
		*(x_BYTE *)(v0 + 189) |= 8u;
	if (v1[8590])
		*(x_BYTE *)(v0 + 189) |= 0x10u;
	if (v1[8600])
		*(x_BYTE *)(v0 + 189) |= 0x20u;
	if (v1[8601])
		*(x_BYTE *)(v0 + 189) |= 0x40u;
	if (v1[8596])
		*(x_BYTE *)(v0 + 189) |= 0x80u;
	result = v0;
	if (!*(x_BYTE *)(v0 + 207))
		*(x_BYTE *)(v0 + 190) |= 1u;
	x_D41A0_BYTEARRAY_0 = v1;
	x_D41A0_BYTEARRAY_4_struct.dwordindex_0 = v0;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// E2A28: using guessed type char x_BYTE_E2A28;
// E3798: using guessed type char x_BYTE_E3798_sound_active2;
// E3799: using guessed type char x_BYTE_E3799;
// E37FC: using guessed type char x_BYTE_E37FC;
// E37FD: using guessed type char x_BYTE_E37FD;

//----- (0001A4A0) --------------------------------------------------------
int sub_1A4A0()
{
	int v0; // ebx
	signed int i; // esi
	unsigned int v2; // kr04_4
	unsigned int v3; // kr08_4
	int v5; // [esp+0h] [ebp-8h]
	int v6; // [esp+4h] [ebp-4h]

	v0 = 0;
	for (i = 0; i < 17; i++)
	{
		sub_1A5B0(i + 1, &v6, &v5);
		v2 = strlen((const char *)x_DWORD_E9C4C_langindexbuffer[v6]) + 1;
		if ((signed int)(8 * (v2 - 1)) > v0)
			v0 = 8 * (v2 - 1);
		v3 = strlen((const char *)x_DWORD_E9C4C_langindexbuffer[v5]) + 1;
		if ((signed int)(8 * (v3 - 1)) > v0)
			v0 = 8 * (v3 - 1);
	}
	return 6 * ((v0 - 11) / 6 + 1) + 16;
}

//----- (0001A5B0) --------------------------------------------------------
int sub_1A5B0(int a1, int *a2, int *a3)
{
	int result; // eax

	result = (int)a2;
	switch (a1)
	{
	case 1:
		*a2 = 400;
		switch (a1)
		{
		case 6:
		case 16:
			goto LABEL_20;
		case 7:
			goto LABEL_21;
		case 14:
			goto LABEL_22;
		default:
			goto LABEL_23;
		}
		goto LABEL_23;
	case 2:
		*a2 = 390;
		switch (a1)
		{
		case 6:
		case 16:
			goto LABEL_20;
		case 7:
			goto LABEL_21;
		case 14:
			goto LABEL_22;
		default:
			goto LABEL_23;
		}
		goto LABEL_23;
	case 3:
		*a2 = 392;
		switch (a1)
		{
		case 6:
		case 16:
			goto LABEL_20;
		case 7:
			goto LABEL_21;
		case 14:
			goto LABEL_22;
		default:
			goto LABEL_23;
		}
		goto LABEL_23;
	case 4:
		*a2 = 469;
		switch (a1)
		{
		case 6:
		case 16:
			goto LABEL_20;
		case 7:
			goto LABEL_21;
		case 14:
			goto LABEL_22;
		default:
			goto LABEL_23;
		}
		goto LABEL_23;
	case 5:
		*a2 = 398;
		switch (a1)
		{
		case 6:
		case 16:
			goto LABEL_20;
		case 7:
			goto LABEL_21;
		case 14:
			goto LABEL_22;
		default:
			goto LABEL_23;
		}
		goto LABEL_23;
	case 6:
		*a2 = 7;
		switch (a1)
		{
		case 6:
		case 16:
			goto LABEL_20;
		case 7:
			goto LABEL_21;
		case 14:
			goto LABEL_22;
		default:
			goto LABEL_23;
		}
		goto LABEL_23;
	case 7:
		*a2 = 382;
		switch (a1)
		{
		case 6:
		case 16:
			goto LABEL_20;
		case 7:
			goto LABEL_21;
		case 14:
			goto LABEL_22;
		default:
			goto LABEL_23;
		}
		goto LABEL_23;
	case 8:
		*a2 = 13;
		switch (a1)
		{
		case 6:
		case 16:
			goto LABEL_20;
		case 7:
			goto LABEL_21;
		case 14:
			goto LABEL_22;
		default:
			goto LABEL_23;
		}
		goto LABEL_23;
	case 9:
		*a2 = 359;
		switch (a1)
		{
		case 6:
		case 16:
			goto LABEL_20;
		case 7:
			goto LABEL_21;
		case 14:
			goto LABEL_22;
		default:
			goto LABEL_23;
		}
		goto LABEL_23;
	case 10:
		*a2 = 363;
		switch (a1)
		{
		case 6:
		case 16:
			goto LABEL_20;
		case 7:
			goto LABEL_21;
		case 14:
			goto LABEL_22;
		default:
			goto LABEL_23;
		}
		goto LABEL_23;
	case 11:
		*a2 = 357;
		switch (a1)
		{
		case 6:
		case 16:
			goto LABEL_20;
		case 7:
			goto LABEL_21;
		case 14:
			goto LABEL_22;
		default:
			goto LABEL_23;
		}
		goto LABEL_23;
	case 12:
		*a2 = 395;
		switch (a1)
		{
		case 6:
		case 16:
			goto LABEL_20;
		case 7:
			goto LABEL_21;
		case 14:
			goto LABEL_22;
		default:
			goto LABEL_23;
		}
		goto LABEL_23;
	case 13:
		*a2 = 365;
		switch (a1)
		{
		case 6:
		case 16:
			goto LABEL_20;
		case 7:
			goto LABEL_21;
		case 14:
			goto LABEL_22;
		default:
			goto LABEL_23;
		}
		goto LABEL_23;
	case 14:
		*a2 = 441;
		switch (a1)
		{
		case 6:
		case 16:
			goto LABEL_20;
		case 7:
			goto LABEL_21;
		case 14:
			goto LABEL_22;
		default:
			goto LABEL_23;
		}
		goto LABEL_23;
	case 15:
		*a2 = 442;
		switch (a1)
		{
		case 6:
		case 16:
			goto LABEL_20;
		case 7:
			goto LABEL_21;
		case 14:
			goto LABEL_22;
		default:
			goto LABEL_23;
		}
		goto LABEL_23;
	case 16:
		*a2 = 468;
		switch (a1)
		{
		case 6:
		case 16:
			goto LABEL_20;
		case 7:
			goto LABEL_21;
		case 14:
			goto LABEL_22;
		default:
			break;
		}
	LABEL_23:
		result = *a2 + 1;
		*a3 = result;
		return result;
	case 17:
		*a2 = 402;
		break;
	default:
		break;
	}
	switch (a1)
	{
	case 6:
	case 16:
	LABEL_20:
		result = *a2;
		*a3 = *a2;
		break;
	case 7:
	LABEL_21:
		*a3 = 381;
		break;
	case 14:
	LABEL_22:
		result = *a2 - 1;
		*a3 = result;
		break;
	default:
		goto LABEL_23;
	}
	return result;
}

//----- (0001A7A0) --------------------------------------------------------
int sub_1A7A0()
{
	int result; // eax
	int v1; // ebx
	char v2; // cl
	Bit8u* v3; // edx
	__int16 v4; // dx
	int v5; // eax

	result = (int)x_D41A0_BYTEARRAY_0;
	if (x_D41A0_BYTEARRAY_0[0x36DE9 + 1])
	{
		v1 = x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
		v2 = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 2124 * v1 + 12221);
		if (v2 != 5 && v2 != 8 && v2 != 3 && !x_D41A0_BYTEARRAY_4[0xE1])
		{
			if (*(signed __int16 *)(0x36DEC + x_D41A0_BYTEARRAY_0) != x_DWORD_1805B8
				|| *(signed __int16 *)(0x36DEC + x_D41A0_BYTEARRAY_0 + 2) != x_DWORD_1805BC
				|| (v3 = &x_D41A0_BYTEARRAY_0[10 * v1], *(x_BYTE *)(v3 + 28222))
				|| *(x_BYTE *)(v3 + 28227))
			{
				v5 = (int)x_D41A0_BYTEARRAY_0;
			}
			else
			{
				v4 = *(x_WORD *)(0x36DEC + x_D41A0_BYTEARRAY_0 + 4) + 1;
				*(x_WORD *)(0x36DEC + x_D41A0_BYTEARRAY_0 + 4) = v4;
				if (v4 <= 48)
				{
				LABEL_14:
					result = (int)x_D41A0_BYTEARRAY_0;
					*(x_WORD *)(0x36DEC + x_D41A0_BYTEARRAY_0) = x_DWORD_1805B8;
					*(x_WORD *)(0x36DEC + result + 2) = x_DWORD_1805BC;
					return result;
				}
				sub_191B0(39, 0);
				v5 = (int)x_D41A0_BYTEARRAY_0;
			}
			*(x_WORD *)((char *)&loc_36DEC + v5 + 4) = 0;
			goto LABEL_14;
		}
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// 1805B8: using guessed type int x_DWORD_1805B8;
// 1805BC: using guessed type int x_DWORD_1805BC;

//----- (0001A8A0) --------------------------------------------------------
int sub_1A8A0()
{
	char v0; // dh
	int result; // eax
	char v2; // bh
	char v3; // cl

	if (x_WORD_1805C0 & 4)
	{
		if (x_WORD_1805C0 & 8)
		{
			v0 = x_D41A0_BYTEARRAY_4[0xB7];
			if (!(v0 & 1) && !(v0 & 2))
				sub_191B0(6, 128);
		}
	}
	result = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
	v2 = x_D41A0_BYTEARRAY_4[0xB7] & 0xFC;
	v3 = x_WORD_1805C0;
	x_D41A0_BYTEARRAY_4[0xB7] = v2;
	if (v3 & 4)
		*(x_BYTE *)(result + 183) = v2 | 1;
	if (x_WORD_1805C0 & 8)
	{
		result = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
		*(x_BYTE *)(result + 183) |= 2u;
	}
	return result;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// 1805C0: using guessed type __int16 x_WORD_1805C0;

//----- (0001A970) --------------------------------------------------------
char sub_1A970(char a1, int a2, int a3)
{
	int v3; // edx
	char v4; // cl
	char result; // al
	char v6; // cl
	bool v7; // zf
	int v8; // eax
	char v9; // cl
	char v10; // bl
	char v11; // ch
	bool v12; // al
	unsigned int v13; // ebx
	unsigned __int8 v14; // al
	__int16 v15; // ST04_2
	char v16; // dl
	unsigned __int8 v17; // bl
	char v18; // bl
	char v19; // cl
	char v20; // bl
	int v21; // ebx
	char v22; // cl
	int v23; // ebx
	char v24; // cl
	bool v25; // dl
	int v26; // ebx
	char v27; // ch
	char v28; // cl

	v3 = a2;
	switch (a1)
	{
	case 1:
		sub_18AA0();
		return 0;
	case 2:
		if (!x_BYTE_E3798_sound_active2)
			return 0;
		sub_19760((char *)x_DWORD_E9C4C_langindexbuffer[(x_BYTE_E3799 != 0) + 390], 3u, 50);
		sub_8D8F0_sound_proc3_endsample();
		sub_86860(x_WORD_1803EC);
		x_BYTE_E3799 ^= 1u;
		return 0;
	case 3:
		if (!x_BYTE_E37FC)
			return 0;
		if (x_BYTE_E37FD)
		{
			sub_8E020_sound_proc14_stopsequence();
			sub_19760((char *)x_DWORD_E9C4C_langindexbuffer[393], 3u, 50);
			x_BYTE_E37FD = 0;
		}
		else
		{
			v15 = *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 565);
			x_BYTE_E37FD = 1;
			sub_8E160_sound_proc15_startsequence(v15, 0x7Fu);
			sub_19760((char *)x_DWORD_E9C4C_langindexbuffer[382], 3u, 50);
		}
		return 0;
	case 4:
		if (!x_BYTE_E2A28)
			return 0;
		v16 = x_D41A0_BYTEARRAY_4_struct.setting_byte3_24;
		if (v16 & 0x40)
			x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 = v16 & 0xBF;
		else
			x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 = v16 | 0x40;
		sub_19760((char *)x_DWORD_E9C4C_langindexbuffer[((x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 0x40) == 0) + 469], 3u, 50);
		return 0;
	case 5:
		if (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10)
		{
			*(0x36DE9 + x_D41A0_BYTEARRAY_0 + 1) = 0;
		}
		else
		{
			v12 = *(0x36DE9 + x_D41A0_BYTEARRAY_0 + 1) == 0;
			*(0x36DE9 + x_D41A0_BYTEARRAY_0 + 1) = v12;
			sub_19760((char *)x_DWORD_E9C4C_langindexbuffer[(v12 == 0) + 398], 3u, 50);
		}
		return 0;
	case 6:
		if (x_D41A0_BYTEARRAY_4[0x33] < 3u || x_D41A0_BYTEARRAY_4[0xB4])
			return 0;
		x_D41A0_BYTEARRAY_4_struct.dwordindex_0 = 1;
		v17 = *(0x2FED1 + x_D41A0_BYTEARRAY_0 + 3);
		if (v17 < 1u)
		{
			if (!v17)
			{
				if (a2)
				{
					v3 = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
					v19 = x_D41A0_BYTEARRAY_4[0xB] - 1;
					x_D41A0_BYTEARRAY_4[0xB] = v19;
					if (v19 >= 0)
						goto LABEL_86;
					if (!a3)
					{
						*(x_BYTE *)(v3 + 11) = 4;
						goto LABEL_86;
					}
				}
				else
				{
					v3 = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
					v18 = x_D41A0_BYTEARRAY_4[0xB] + 1;
					x_D41A0_BYTEARRAY_4[0xB] = v18;
					if (v18 <= 4)
						goto LABEL_86;
					if (a3)
					{
						*(x_BYTE *)(v3 + 11) = 4;
						goto LABEL_86;
					}
				}
				*(x_BYTE *)(v3 + 11) = 0;
			}
		LABEL_86:
			sub_47650(a3, v3);
			return 0;
		}
		if (v17 > 1u)
		{
			if (v17 != 2)
				goto LABEL_86;
			if (a2)
			{
				v23 = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
				v24 = x_D41A0_BYTEARRAY_4[0xD] - 1;
				x_D41A0_BYTEARRAY_4[0xD] = v24;
				if (v24 < 0)
				{
					if (!a3)
					{
						*(x_BYTE *)(v23 + 13) = 4;
						sub_47650(0, a2);
						return 0;
					}
					goto LABEL_85;
				}
			}
			else
			{
				v23 = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
				v3 = (unsigned __int8)(x_D41A0_BYTEARRAY_4[0xD] + 1);
				x_D41A0_BYTEARRAY_4[0xD] = v3;
				if ((char)v3 > 4)
				{
					if (a3)
					{
						*(x_BYTE *)(v23 + 13) = 4;
						sub_47650(a3, v3);
						return 0;
					}
				LABEL_85:
					*(x_BYTE *)(v23 + 13) = 0;
					goto LABEL_86;
				}
			}
			goto LABEL_86;
		}
		if (a2)
		{
			v21 = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
			v22 = x_D41A0_BYTEARRAY_4[0xC] - 1;
			x_D41A0_BYTEARRAY_4[0xC] = v22;
			if (v22 >= 0)
				goto LABEL_86;
			if (a3)
			{
				*(x_BYTE *)(v21 + 12) = 0;
				sub_47650(a3, a2);
			}
			else
			{
				*(x_BYTE *)(v21 + 12) = 4;
				sub_47650(0, a2);
			}
			result = 0;
		}
		else
		{
			v3 = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
			v20 = x_D41A0_BYTEARRAY_4[0xC] + 1;
			x_D41A0_BYTEARRAY_4[0xC] = v20;
			if (v20 <= 4)
				goto LABEL_86;
			if (a3)
			{
				*(x_BYTE *)(v3 + 12) = 4;
				sub_47650(a3, v3);
			}
			else
			{
				*(x_BYTE *)(v3 + 12) = 0;
				sub_47650(0, v3);
			}
			result = 0;
		}
		return result;
	case 7:
		if (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10)
			return 0;
		v13 = x_DWORD_EA3E4[*(unsigned __int16 *)(x_D41A0_BYTEARRAY_0 + 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 11240)];
		if (v13 <= x_DWORD_EA3E4[0] || *(x_DWORD *)(v13 + 8) < 0)
			return 0;
		if (x_D41A0_BYTEARRAY_4[0xB2])
			x_D41A0_BYTEARRAY_4[0xB2] = 0;
		else
			x_D41A0_BYTEARRAY_4[0xB2] = (a2 != 0) + 1;
		v14 = x_D41A0_BYTEARRAY_4[0xB2];
		if (v14 < 1u)
		{
			if (v14)
				return 0;
			sub_19760((char *)x_DWORD_E9C4C_langindexbuffer[381], 3u, 50);
			result = 0;
		}
		else
		{
			if (v14 <= 1u)
			{
				sub_19760((char *)x_DWORD_E9C4C_langindexbuffer[382], 3u, 50);
			}
			else
			{
				if (v14 != 2)
					return 0;
				sub_19760((char *)x_DWORD_E9C4C_langindexbuffer[383], 3u, 50);
			}
			*(x_WORD *)(*(x_DWORD *)(v13 + 164) + 341) = 0;
			*(x_WORD *)(*(x_DWORD *)(v13 + 164) + 343) = 0;
			result = 0;
		}
		return result;
	case 8:
		v26 = (int)x_D41A0_BYTEARRAY_0;
		if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8592))
			return 0;
		if (a2)
		{
			v27 = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8589) + 1;
			*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8589) = v27;
			if (v27 <= 40)
				goto LABEL_97;
			if (!a3)
			{
				*(x_BYTE *)(v26 + 8589) = 16;
				goto LABEL_97;
			}
		}
		else
		{
			v28 = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8589) - 1;
			*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8589) = v28;
			if (v28 >= 16)
				goto LABEL_97;
			if (a3)
			{
				*(x_BYTE *)(v26 + 8589) = 16;
				goto LABEL_97;
			}
		}
		*(x_BYTE *)(v26 + 8589) = 40;
	LABEL_97:
		sub_2CA90(*(char *)(x_D41A0_BYTEARRAY_0 + 8589));
		return 0;
	case 9:
		if (!x_D41A0_BYTEARRAY_4[0x21AA])
			return 0;
		v4 = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8586) ^ 1;
		*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8586) = v4;
		sub_19760((char *)x_DWORD_E9C4C_langindexbuffer[(v4 == 0) + 359], 3u, 50);
		return 0;
	case 10:
		if (!*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8620) || !off_D41A8)
			return 0;
		*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8588) ^= 1u;
		sub_19760((char *)x_DWORD_E9C4C_langindexbuffer[(*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8588) == 0) + 363], 3u, 50);
		return 0;
	case 11:
		if (!*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8619))
			return 0;
		v6 = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8587) ^ 1;
		*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8587) = v6;
		sub_19760((char *)x_DWORD_E9C4C_langindexbuffer[(v6 == 0) + 357], 3u, 50);
		return 0;
	case 12:
		if (!*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8630))
			return 0;
		v7 = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8598) == 1;
		*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8598) ^= 1u;
		sub_19760((char *)x_DWORD_E9C4C_langindexbuffer[(unsigned __int8)v7 + 395], 3u, 50);
		return 0;
	case 13:
		v8 = (int)x_D41A0_BYTEARRAY_0;
		v9 = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8591) ^ 1;
		*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8590) ^= 1u;
		*(x_BYTE *)(v8 + 8591) = v9;
		sub_19760((char *)x_DWORD_E9C4C_langindexbuffer[(*(x_BYTE *)(v8 + 8590) == 0) + 365], 3u, 50);
		if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8590))
			return 0;
		sub_87C10();
		return 0;
	case 14:
		if (!*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8632))
			return 0;
		v10 = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8600) ^ 1;
		*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8600) = v10;
		sub_19760((char *)x_DWORD_E9C4C_langindexbuffer[(v10 != 0) + 440], 3u, 50);
		return 0;
	case 15:
		if (!*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8633))
			return 0;
		v11 = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8601) ^ 1;
		*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8601) = v11;
		sub_19760((char *)x_DWORD_E9C4C_langindexbuffer[(v11 == 0) + 442], 3u, 50);
		return 0;
	case 16:
		if (!*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8628) || *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8592))
			return 0;
		sub_41BC0();
		sub_46B40();
		return 0;
	case 17:
		v25 = x_D41A0_BYTEARRAY_4[0xCF] == 0;
		x_D41A0_BYTEARRAY_4[0xCF] = v25;
		sub_19760((char *)x_DWORD_E9C4C_langindexbuffer[(v25 != 0) + 402], 3u, 50);
		return 0;
	case 18:
		v7 = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8592) == 1;
		*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8592) ^= 1u;
		if (v7)
		{
			sub_417A0_install_pal_and_mouse_minmax();
			return 0;
		}
		sub_417D0_install_pal_and_mouse_minmax2();
		return 0;
	default:
		return 0;
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// D41A8: using guessed type char *off_D41A8;
// E2A28: using guessed type char x_BYTE_E2A28;
// E3798: using guessed type char x_BYTE_E3798_sound_active2;
// E3799: using guessed type char x_BYTE_E3799;
// E37FC: using guessed type char x_BYTE_E37FC;
// E37FD: using guessed type char x_BYTE_E37FD;
// EA240: using guessed type int x_DWORD_EA240;
// EA244: using guessed type int x_DWORD_EA244;
// EA248: using guessed type int x_DWORD_EA248;
// EA26C: using guessed type int x_DWORD_EA26C;
// EA270: using guessed type int x_DWORD_EA270;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// 1803EC: using guessed type __int16 x_WORD_1803EC;


void sub_loc_1B2E6();
void sub_loc_1B2F7(Bit8u* a2);
void sub_loc_1B316(Bit8u a1);
void sub_loc_1B334(Bit8u* a2);
void sub_loc_1B352(Bit8u* a2);
void sub_loc_1B36C();
void sub_loc_1B37D(Bit8u* a2);
void sub_loc_1B398(Bit8u* a2);
void sub_loc_1B3C9(Bit8u* a1);
void sub_loc_1B413();
void sub_loc_1B424(Bit16u a1, Bit8u* a2);
void sub_loc_1B450();
void sub_loc_1B461(Bit16u a1, Bit8u* a2);
void sub_loc_1B4A0(Bit16u a1, Bit8u* a2);
void sub_loc_1B4DF(Bit16u a1, Bit8u* a2);
void sub_loc_1B51E(Bit8u* a2);
void sub_loc_1B54A(Bit16u a1, Bit8u* a2);
void sub_loc_1B589();
void sub_loc_1B5A7();
void sub_loc_1B5BC(Bit16u a1);
void sub_loc_1B5CB();
//void sub_loc_1B5D7();

//----- (0001B280) --------------------------------------------------------
void sub_1B280_draw_intro_text(Bit8u* a1)//1fc280
{
	int v1; // eax
	Bit8u* v2; // edx
	Bit8u v3; // dl

	while (1)
	{
		v1 = 7 * x_WORD_D4004;//2a5004
		v2 = a1 + v1;
		if (x_WORD_17DB60 != *(Bit16u*)v2)
			break;
		v1 = *(Bit16u*)&v2[3];
		if (v1 == -1)
			break;
		v3 = v2[2] - 0x41;
		if (v3 <= 0x39u)
		{
			/*v3 &= 0xff; //v3
			ecx+=v1
			v3 += v1*/
			switch (v3 * 4) {
			case 0x00:
				sub_loc_1B2E6();
				break;
			case 0x04:
				sub_loc_1B2F7(a1);
				break;
			case 0x08:
				sub_loc_1B5CB();
				break;
			case 0x0c:
				sub_loc_1B51E(a1);
				break;
			case 0x10:
				sub_loc_1B316(v1);
				break;
			case 0x14:
				sub_loc_1B461(v1, a1);
				break;
			case 0x18:
				sub_loc_1B5CB();
				break;
			case 0x1c:
				sub_loc_1B5CB();
				break;
			case 0x20:
				sub_loc_1B5CB();
				break;
			case 0x24:
				sub_loc_1B5CB();
				break;
			case 0x28:
				sub_loc_1B36C();
				break;
			case 0x2c:
				sub_loc_1B334(a1);
				break;
			case 0x30:
				sub_loc_1B352(a1);
				break;
			case 0x34:
				sub_loc_1B5CB();
				break;
			case 0x38:
				sub_loc_1B4DF(v1, a1);
				break;
			case 0x3c:
				sub_loc_1B4A0(v1, a1);
				break;
			case 0x40:
				sub_loc_1B37D(a1);
				break;
			case 0x44:
				sub_loc_1B398(a1);
				break;
			case 0x48:
				sub_loc_1B3C9(a1);
				break;
			case 0x4c:
				sub_loc_1B424(v1, a1);
				break;
			case 0x50:
				sub_loc_1B5BC(v1);
				break;
			case 0x54:
				sub_loc_1B589();
				break;
			case 0x58:
				sub_loc_1B36C();
				break;
			case 0x5c:
				sub_loc_1B450();
				break;
			case 0x60:
				sub_loc_1B5A7();
				break;
			case 0x64:
				sub_loc_1B352(a1);
				break;
			case 0x68:
				sub_loc_1B5CB();
				break;
			case 0x6c:
				sub_loc_1B5CB();
				break;
			case 0x70:
				sub_loc_1B5CB();
				break;
			case 0x74:
				sub_loc_1B5CB();
				break;
			case 0x78:
				sub_loc_1B5CB();
				break;
			case 0x7c:
				sub_loc_1B5CB();
				break;
			case 0x80:
				sub_loc_1B2E6();
				break;
			case 0x84:
				sub_loc_1B2F7(a1);
				break;
			case 0x88:
				sub_loc_1B5CB();
				break;
			case 0x8c:
				sub_loc_1B51E(a1);
				break;
			case 0x90:
				sub_loc_1B316(v1);
				break;
			case 0x94:
				sub_loc_1B461(v1, a1);
				break;
			case 0x98:
				sub_loc_1B5CB();
				break;
			case 0x9c:
				sub_loc_1B54A(v1, a1);
				break;
			case 0xa0:
				sub_loc_1B5CB();
				break;
			case 0xa4:
				sub_loc_1B5CB();
				break;
			case 0xa8:
				sub_loc_1B5CB();
				break;
			case 0xac:
				sub_loc_1B334(a1);
				break;
			case 0xb0:
				sub_loc_1B352(a1);
				break;
			case 0xb4:
				sub_loc_1B5CB();
				break;
			case 0xb8:
				sub_loc_1B4DF(v1, a1);
				break;
			case 0xbc:
				sub_loc_1B4A0(v1, a1);
				break;
			case 0xc0:
				sub_loc_1B5CB();
				break;
			case 0xc4:
				sub_loc_1B398(a1);
				break;
			case 0xc8:
				sub_loc_1B3C9(a1);
				break;
			case 0xcc:
				sub_loc_1B424(v1, a1);
				break;
			case 0xd0:
				sub_loc_1B5CB();
				break;
			case 0xd4:
				sub_loc_1B5CB();
				break;
			case 0xd8:
				sub_loc_1B5CB();
				break;
			case 0xdc:
				sub_loc_1B450();
				break;
			case 0xe0:
				sub_loc_1B5CB();
				break;
			case 0xe4:
				sub_loc_1B352(a1);
				break;
			default:
				exit(0);
			}
			//JUMPOUT(__CS__, (int*) *(&off_1B190 + v3));
		}
		x_WORD_D4004++;
		//if(v3==0)break;
	}
	//return result;
}

//int tempedx, tempeax,tempebx;
//eax=d4004*7
//edx=esi+d4004*7
//dl=[edx+2] - +2
//eax=tempebx +3
//void sub_loc_1B289() {}
void sub_loc_1B2E6() {
	//x_DWORD_E3844, eax
	x_DWORD_E3844 = 0;
	//x_WORD_D4004++;
}
void sub_loc_1B2F7(Bit8u* a2) {
	sub_8E020_sound_proc14_stopsequence();
	sub_8EAD0_load_music(*(Bit32u*)(a2 + x_WORD_D4004 * 7 + 3));
	//x_WORD_D4004++;
}
void sub_loc_1B316(Bit8u a1) {
	sub_8D8F0_sound_proc3_endsample();
	sub_84300_load_sound(a1);
	//x_WORD_D4004++;
}
void sub_loc_1B334(Bit8u* a2) {
	if (x_DWORD_E387C)sub_loc_1B352(a2);
	else
	{
		sub_8F0AB((FILE*)x_DWORD_E3840, *(Bit32u*)(a2 + x_WORD_D4004 * 7 + 2), *(Bit32u*)(a2 + x_WORD_D4004 * 7 + 3));
	}
}
void sub_loc_1B352(Bit8u* a2) {
	sub_8E160_sound_proc15_startsequence(*(Bit32u*)(a2 + x_WORD_D4004 * 7 + 3), 0x7f);
	//x_WORD_D4004++;
}
void sub_loc_1B36C() {
	sub_2EC30_clear_img_mem();
	//x_WORD_D4004++;
}
void sub_loc_1B37D(Bit8u* a2) {
	sub_2EBB0_draw_text_with_border_630x340(x_DWORD_E9C4C_langindexbuffer[*(Bit32u*)(a2 + x_WORD_D4004 * 7 + 2)]);
	//x_WORD_D4004++;
}
void sub_loc_1B398(Bit8u* a2) {
	if (x_BYTE_E3798_sound_active2)sub_loc_1B5CB();
	sub_8F100_sound_proc19(0, *(Bit32u*)(a2 + x_WORD_D4004 * 7 + 3), 0x7f, 0x40, 0x64, 0xFFFFFFFF, 2);
	//x_WORD_D4004++;
}
void sub_loc_1B3C9(Bit8u* a1) {//1fc3c9
	if (x_BYTE_E3798_sound_active2)sub_loc_1B5CB();
	Bit8u* v1 = a1 + x_WORD_D4004 * 7 + 3;
	if (*(Bit32u*)v1 == 0)sub_loc_1B413();//tempesi = 2b27cc
	sub_8F100_sound_proc19(0, *(Bit32u*)v1, 0x7f, 0x40, 0x64, 0, 2);
	//x_WORD_D4004++;
}
void sub_loc_1B413() {
	sub_8D8F0_sound_proc3_endsample();
	//x_WORD_D4004++;
}
void sub_loc_1B424(Bit16u a1, Bit8u* a2) {
	if (x_BYTE_E3798_sound_active2 == 0)sub_loc_1B5BC(a1);
	if (*(Bit32u*)(a2 + x_WORD_D4004 * 7 + 3))sub_loc_1B413();
	sub_8F420_sound_proc20(0, *(Bit32u*)(a2 + x_WORD_D4004 * 7 + 3));
	//x_WORD_D4004++;
}
void sub_loc_1B450() {
	sub_8E020_sound_proc14_stopsequence();
	//x_WORD_D4004++;
}
void sub_loc_1B461(Bit16u a1, Bit8u* a2) {
	if (x_BYTE_E3798_sound_active2 == 0)sub_loc_1B5BC(a1);
	sub_8F710_sound_proc21(0, *(Bit32u*)(a2 + x_WORD_D4004 * 7 + 3), 0, 4, 0x64/*, 1, 2*/);
	/*cseg01 : 0001B46E                 movsx   edx, word_D4004
	cseg01 : 0001B475                 push    1
	cseg01 : 0001B477                 lea     eax, ds : 0[edx * 8]
	cseg01 : 0001B47E                 push    4
	cseg01 : 0001B480                 sub     eax, edx
	cseg01 : 0001B482                 push    0
	cseg01 : 0001B484                 movsx   eax, word ptr[esi + eax + 3]
	cseg01 : 0001B489                 push    eax
	cseg01 : 0001B48A                 push    0
	cseg01 : 0001B48C                 call    sub_8F710_sound_proc21*/
	//x_WORD_D4004++;
}
void sub_loc_1B4A0(Bit16u a1, Bit8u* a2) {
	if (x_BYTE_E3798_sound_active2 == 0)sub_loc_1B5BC(a1);
	sub_8F710_sound_proc21(0, *(Bit32u*)(a2 + x_WORD_D4004 * 7 + 3), 50, 2, 0);
	/*cseg01 : 0001B4AD                 movsx   edx, word_D4004
	cseg01 : 0001B4B4                 push    0
	cseg01 : 0001B4B6                 lea     eax, ds : 0[edx * 8]
	cseg01 : 0001B4BD                 push    2
	cseg01 : 0001B4BF                 sub     eax, edx
	cseg01 : 0001B4C1                 push    50h; 'P'
	cseg01:0001B4C3                 movsx   eax, word ptr[esi + eax + 3]
	cseg01 : 0001B4C8                 push    eax
	cseg01 : 0001B4C9                 push    0
	cseg01 : 0001B4CB                 call    sub_8F710_sound_proc21*/
	//x_WORD_D4004++;
}
void sub_loc_1B4DF(Bit16u a1, Bit8u* a2) {
	if (x_BYTE_E3798_sound_active2 == 0)sub_loc_1B5BC(a1);
	sub_8F710_sound_proc21(0, *(Bit32u*)(a2 + x_WORD_D4004 * 7 + 3), 0x7f, 2, 0);
	/*	cseg01 : 0001B4EC                 movsx   edx, word_D4004
		cseg01 : 0001B4F3                 push    0
		cseg01 : 0001B4F5                 lea     eax, ds : 0[edx * 8]
		cseg01 : 0001B4FC                 push    2
		cseg01 : 0001B4FE                 sub     eax, edx
		cseg01 : 0001B500                 push    7Fh
		cseg01 : 0001B502                 movsx   eax, word ptr[esi + eax + 3]
		cseg01 : 0001B507                 push    eax
		cseg01 : 0001B508                 push    0
		cseg01 : 0001B50A                 call    sub_8F710_sound_proc21*/
		//x_WORD_D4004++;
}
void sub_loc_1B51E(Bit8u* a1) {
	sub_8E160_sound_proc15_startsequence(*(Bit32u*)(a1 + x_WORD_D4004 * 7 + 3), 0x64/*, tempedx * 7*/);
	//x_WORD_D4004++;
}
void sub_loc_1B54A(Bit16u a1, Bit8u* a2) {
	if (x_BYTE_E3798_sound_active2 == 0)sub_loc_1B5BC(a1);
	sub_8F100_sound_proc19(0, *(Bit32u*)(a2 + x_WORD_D4004 * 7 + 3), 0, 0x40, 0x64, 0xFFFFFFFF, 2);
	//x_WORD_D4004++;
}
void sub_loc_1B589() {
	if (x_BYTE_D41C0 == 0)sub_loc_1B5CB();
	else
	{
		sub_2EB60();//maybe must fix
		//x_WORD_D4004++;
	}
}
void sub_loc_1B5A7() {
	sub_2EC60();
	//x_WORD_D4004++;
}
void sub_loc_1B5BC(Bit16u a1) {
	//memset(x_DWORD_180628b_screen_buffer, 200, 320*200);//debug
	//Set_basic_pallette();
	if ((a1 != 1) && (a1 != 0xe))//fixed write pause text
		sub_2EBB0_draw_text_with_border_630x340(x_DWORD_E9C4C_langindexbuffer[a1]);//fix it - edx
	//sub_90478_VGA_Blit320();//debug
}
void sub_loc_1B5CB() {
	//x_WORD_D4004++;
}
//void sub_loc_1B5D7() {}

// 1B190: using guessed type void *off_1B190;
// D4004: using guessed type __int16 x_WORD_D4004;
// D41C0: using guessed type char x_BYTE_D41C0;
// E3798: using guessed type char x_BYTE_E3798_sound_active2;
// E3844: using guessed type int x_DWORD_E3844;
// E387C: using guessed type int x_DWORD_E387C;
// 17DB60: using guessed type __int16 x_WORD_17DB60;

/*
sub_1B280_draw_intro_text       proc near               ; CODE XREF: sub_76160_play_intro+C0p
cseg01:0001B280                                         ; cseg01:0008E526p ...
cseg01:0001B280
cseg01:0001B280 arg_0           = dword ptr  14h
cseg01:0001B280
cseg01:0001B280                 push    ebx
cseg01:0001B281                 push    esi
cseg01:0001B282                 push    edi
cseg01:0001B283                 push    ebp
cseg01:0001B284                 mov     ebp, esp
cseg01:0001B286                 mov     esi, [ebp+arg_0]
cseg01:0001B289
cseg01:0001B289 loc_1B289:                              ; CODE XREF: sub_1B280_draw_intro_text+75j
cseg01:0001B289                                         ; sub_1B280_draw_intro_text+91j ...
cseg01:0001B289                 movsx   edx, word_D4004
cseg01:0001B290                 lea     eax, ds:0[edx*8]
cseg01:0001B297                 sub     eax, edx
cseg01:0001B299                 lea     edx, [esi+eax]
cseg01:0001B29C                 mov     bx, word_17DB60
cseg01:0001B2A3                 cmp     bx, [edx]
cseg01:0001B2A6                 jnz     loc_1B5D7
cseg01:0001B2AC                 mov     bx, [edx+3]
cseg01:0001B2B0                 movsx   eax, bx
cseg01:0001B2B3                 cmp     eax, 0FFFFFFFFh
cseg01:0001B2B6                 jz      loc_1B5D7
cseg01:0001B2BC                 mov     dl, [edx+2]
cseg01:0001B2BF                 sub     dl, 41h ; 'A'
cseg01:0001B2C2                 cmp     dl, 39h ; '9'
cseg01:0001B2C5                 ja      loc_1B5CB
cseg01:0001B2CB                 and     edx, 0FFh
cseg01:0001B2D1                 lea     ecx, ds:0[edx*4]
cseg01:0001B2D8                 lea     edx, ds:0[eax*4]
cseg01:0001B2DF                 jmp     cs:off_1B190[ecx]
cseg01:0001B2E6 ; ---------------------------------------------------------------------------
cseg01:0001B2E6
cseg01:0001B2E6 loc_1B2E6:                              ; CODE XREF: sub_1B280_draw_intro_text+5Fj
cseg01:0001B2E6                                         ; DATA XREF: cseg01:off_1B190o ...
cseg01:0001B2E6                 movsx   eax, bx
cseg01:0001B2E9                 mov     dword_E3844, eax
cseg01:0001B2EE                 inc     word_D4004
cseg01:0001B2F5                 jmp     short loc_1B289
cseg01:0001B2F7 ; ---------------------------------------------------------------------------
cseg01:0001B2F7
cseg01:0001B2F7 loc_1B2F7:                              ; CODE XREF: sub_1B280_draw_intro_text+5Fj
cseg01:0001B2F7                                         ; DATA XREF: cseg01:0001B194o ...
cseg01:0001B2F7                 call    sub_8E020_sound_proc14_stopsequence
cseg01:0001B2FC                 xor     eax, eax
cseg01:0001B2FE                 mov     ax, bx
cseg01:0001B301                 push    eax
cseg01:0001B302                 call    sub_8EAD0_load_music
cseg01:0001B307                 add     esp, 4
cseg01:0001B30A                 inc     word_D4004
cseg01:0001B311                 jmp     loc_1B289
cseg01:0001B316 ; ---------------------------------------------------------------------------
cseg01:0001B316
cseg01:0001B316 loc_1B316:                              ; CODE XREF: sub_1B280_draw_intro_text+5Fj
cseg01:0001B316                                         ; DATA XREF: cseg01:0001B1A0o ...
cseg01:0001B316                 call    sub_8D8F0_sound_proc3_endsample
cseg01:0001B31B                 xor     eax, eax
cseg01:0001B31D                 mov     al, bl
cseg01:0001B31F                 push    eax
cseg01:0001B320                 call    sub_84300_load_sound
cseg01:0001B325                 add     esp, 4
cseg01:0001B328                 inc     word_D4004
cseg01:0001B32F                 jmp     loc_1B289
cseg01:0001B334 ; ---------------------------------------------------------------------------
cseg01:0001B334
cseg01:0001B334 loc_1B334:                              ; CODE XREF: sub_1B280_draw_intro_text+5Fj
cseg01:0001B334                                         ; DATA XREF: cseg01:0001B1BCo ...
cseg01:0001B334                 mov     edx, dword_E387C
cseg01:0001B33A                 test    edx, edx
cseg01:0001B33C                 jz      short loc_1B352
cseg01:0001B33E                 movsx   eax, bx
cseg01:0001B341                 push    eax
cseg01:0001B342                 push    edx
cseg01:0001B343                 mov     edi, dword_E3840
cseg01:0001B349                 push    edi
cseg01:0001B34A                 call    sub_8F0AB
cseg01:0001B34F                 add     esp, 0Ch
cseg01:0001B352
cseg01:0001B352 loc_1B352:                              ; CODE XREF: sub_1B280_draw_intro_text+5Fj
cseg01:0001B352                                         ; sub_1B280_draw_intro_text+BCj
cseg01:0001B352                                         ; DATA XREF: ...
cseg01:0001B352                 push    7Fh
cseg01:0001B354                 movsx   eax, bx
cseg01:0001B357                 push    eax
cseg01:0001B358                 call    sub_8E160_sound_proc15_startsequence
cseg01:0001B35D                 add     esp, 8
cseg01:0001B360                 inc     word_D4004
cseg01:0001B367                 jmp     loc_1B289
cseg01:0001B36C ; ---------------------------------------------------------------------------
cseg01:0001B36C
cseg01:0001B36C loc_1B36C:                              ; CODE XREF: sub_1B280_draw_intro_text+5Fj
cseg01:0001B36C                                         ; DATA XREF: cseg01:0001B1B8o ...
cseg01:0001B36C                 call    sub_2EC30_clear_img_mem
cseg01:0001B371                 inc     word_D4004
cseg01:0001B378                 jmp     loc_1B289
cseg01:0001B37D ; ---------------------------------------------------------------------------
cseg01:0001B37D
cseg01:0001B37D loc_1B37D:                              ; CODE XREF: sub_1B280_draw_intro_text+5Fj
cseg01:0001B37D                                         ; DATA XREF: cseg01:0001B1D0o
cseg01:0001B37D                 mov     eax, dword_E9C4C[edx]
cseg01:0001B383                 push    eax
cseg01:0001B384                 call    sub_2EBB0_draw_text_with_border_630x340
cseg01:0001B389                 add     esp, 4
cseg01:0001B38C                 inc     word_D4004
cseg01:0001B393                 jmp     loc_1B289
cseg01:0001B398 ; ---------------------------------------------------------------------------
cseg01:0001B398
cseg01:0001B398 loc_1B398:                              ; CODE XREF: sub_1B280_draw_intro_text+5Fj
cseg01:0001B398                                         ; DATA XREF: cseg01:0001B1D4o ...
cseg01:0001B398                 cmp     byte_E3798, 0
cseg01:0001B39F                 jz      loc_1B5CB
cseg01:0001B3A5                 push    2
cseg01:0001B3A7                 push    0FFFFFFFFh
cseg01:0001B3A9                 push    64h ; 'd'
cseg01:0001B3AB                 push    40h ; '@'
cseg01:0001B3AD                 push    7Fh
cseg01:0001B3AF                 movsx   eax, bx
cseg01:0001B3B2                 push    eax
cseg01:0001B3B3                 push    0
cseg01:0001B3B5                 call    sub_8F100_sound_proc19
cseg01:0001B3BA                 add     esp, 1Ch
cseg01:0001B3BD                 inc     word_D4004
cseg01:0001B3C4                 jmp     loc_1B289
cseg01:0001B3C9 ; ---------------------------------------------------------------------------
cseg01:0001B3C9
cseg01:0001B3C9 loc_1B3C9:                              ; CODE XREF: sub_1B280_draw_intro_text+5Fj
cseg01:0001B3C9                                         ; DATA XREF: cseg01:0001B1D8o ...
cseg01:0001B3C9                 cmp     byte_E3798, 0
cseg01:0001B3D0                 jz      loc_1B5CB
cseg01:0001B3D6                 movsx   edx, word_D4004
cseg01:0001B3DD                 lea     eax, ds:0[edx*8]
cseg01:0001B3E4                 sub     eax, edx
cseg01:0001B3E6                 add     eax, esi
cseg01:0001B3E8                 cmp     dword ptr [eax+3], 0
cseg01:0001B3EC                 jz      short loc_1B413
cseg01:0001B3EE                 push    2
cseg01:0001B3F0                 push    0
cseg01:0001B3F2                 push    64h ; 'd'
cseg01:0001B3F4                 push    40h ; '@'
cseg01:0001B3F6                 push    7Fh
cseg01:0001B3F8                 movsx   eax, word ptr [eax+3]
cseg01:0001B3FC                 push    eax
cseg01:0001B3FD                 push    0
cseg01:0001B3FF                 call    sub_8F100_sound_proc19
cseg01:0001B404                 add     esp, 1Ch
cseg01:0001B407                 inc     word_D4004
cseg01:0001B40E                 jmp     loc_1B289
cseg01:0001B413 ; ---------------------------------------------------------------------------
cseg01:0001B413
cseg01:0001B413 loc_1B413:                              ; CODE XREF: sub_1B280_draw_intro_text+16Cj
cseg01:0001B413                                         ; sub_1B280_draw_intro_text+1B4j
cseg01:0001B413                 call    sub_8D8F0_sound_proc3_endsample
cseg01:0001B418                 inc     word_D4004
cseg01:0001B41F                 jmp     loc_1B289
cseg01:0001B424 ; ---------------------------------------------------------------------------
cseg01:0001B424
cseg01:0001B424 loc_1B424:                              ; CODE XREF: sub_1B280_draw_intro_text+5Fj
cseg01:0001B424                                         ; DATA XREF: cseg01:0001B1DCo ...
cseg01:0001B424                 cmp     byte_E3798, 0
cseg01:0001B42B                 jz      loc_1B5CB
cseg01:0001B431                 test    bx, bx
cseg01:0001B434                 jz      short loc_1B413
cseg01:0001B436                 movsx   eax, bx
cseg01:0001B439                 push    eax
cseg01:0001B43A                 push    0
cseg01:0001B43C                 call    sub_8F420_sound_proc20
cseg01:0001B441                 add     esp, 8
cseg01:0001B444                 inc     word_D4004
cseg01:0001B44B                 jmp     loc_1B289
cseg01:0001B450 ; ---------------------------------------------------------------------------
cseg01:0001B450
cseg01:0001B450 loc_1B450:                              ; CODE XREF: sub_1B280_draw_intro_text+5Fj
cseg01:0001B450                                         ; DATA XREF: cseg01:0001B1ECo ...
cseg01:0001B450                 call    sub_8E020_sound_proc14_stopsequence
cseg01:0001B455                 inc     word_D4004
cseg01:0001B45C                 jmp     loc_1B289
cseg01:0001B461 ; ---------------------------------------------------------------------------
cseg01:0001B461
cseg01:0001B461 loc_1B461:                              ; CODE XREF: sub_1B280_draw_intro_text+5Fj
cseg01:0001B461                                         ; DATA XREF: cseg01:0001B1A4o ...
cseg01:0001B461                 cmp     byte_E3798, 0
cseg01:0001B468                 jz      loc_1B5CB
cseg01:0001B46E                 movsx   edx, word_D4004
cseg01:0001B475                 push    1
cseg01:0001B477                 lea     eax, ds:0[edx*8]
cseg01:0001B47E                 push    4
cseg01:0001B480                 sub     eax, edx
cseg01:0001B482                 push    0
cseg01:0001B484                 movsx   eax, word ptr [esi+eax+3]
cseg01:0001B489                 push    eax
cseg01:0001B48A                 push    0
cseg01:0001B48C                 call    sub_8F710_sound_proc21
cseg01:0001B491                 add     esp, 14h
cseg01:0001B494                 inc     word_D4004
cseg01:0001B49B                 jmp     loc_1B289
cseg01:0001B4A0 ; ---------------------------------------------------------------------------
cseg01:0001B4A0
cseg01:0001B4A0 loc_1B4A0:                              ; CODE XREF: sub_1B280_draw_intro_text+5Fj
cseg01:0001B4A0                                         ; DATA XREF: cseg01:0001B1CCo ...
cseg01:0001B4A0                 cmp     byte_E3798, 0
cseg01:0001B4A7                 jz      loc_1B5CB
cseg01:0001B4AD                 movsx   edx, word_D4004
cseg01:0001B4B4                 push    0
cseg01:0001B4B6                 lea     eax, ds:0[edx*8]
cseg01:0001B4BD                 push    2
cseg01:0001B4BF                 sub     eax, edx
cseg01:0001B4C1                 push    50h ; 'P'
cseg01:0001B4C3                 movsx   eax, word ptr [esi+eax+3]
cseg01:0001B4C8                 push    eax
cseg01:0001B4C9                 push    0
cseg01:0001B4CB                 call    sub_8F710_sound_proc21
cseg01:0001B4D0                 add     esp, 14h
cseg01:0001B4D3                 inc     word_D4004
cseg01:0001B4DA                 jmp     loc_1B289
cseg01:0001B4DF ; ---------------------------------------------------------------------------
cseg01:0001B4DF
cseg01:0001B4DF loc_1B4DF:                              ; CODE XREF: sub_1B280_draw_intro_text+5Fj
cseg01:0001B4DF                                         ; DATA XREF: cseg01:0001B1C8o ...
cseg01:0001B4DF                 cmp     byte_E3798, 0
cseg01:0001B4E6                 jz      loc_1B5CB
cseg01:0001B4EC                 movsx   edx, word_D4004
cseg01:0001B4F3                 push    0
cseg01:0001B4F5                 lea     eax, ds:0[edx*8]
cseg01:0001B4FC                 push    2
cseg01:0001B4FE                 sub     eax, edx
cseg01:0001B500                 push    7Fh
cseg01:0001B502                 movsx   eax, word ptr [esi+eax+3]
cseg01:0001B507                 push    eax
cseg01:0001B508                 push    0
cseg01:0001B50A                 call    sub_8F710_sound_proc21
cseg01:0001B50F                 add     esp, 14h
cseg01:0001B512                 inc     word_D4004
cseg01:0001B519                 jmp     loc_1B289
cseg01:0001B51E ; ---------------------------------------------------------------------------
cseg01:0001B51E
cseg01:0001B51E loc_1B51E:                              ; CODE XREF: sub_1B280_draw_intro_text+5Fj
cseg01:0001B51E                                         ; DATA XREF: cseg01:0001B19Co ...
cseg01:0001B51E                 movsx   edx, word_D4004
cseg01:0001B525                 lea     eax, ds:0[edx*8]
cseg01:0001B52C                 sub     eax, edx
cseg01:0001B52E                 push    64h ; 'd'
cseg01:0001B530                 movsx   eax, word ptr [esi+eax+3]
cseg01:0001B535                 push    eax
cseg01:0001B536                 call    sub_8E160_sound_proc15_startsequence
cseg01:0001B53B                 add     esp, 8
cseg01:0001B53E                 inc     word_D4004
cseg01:0001B545                 jmp     loc_1B289
cseg01:0001B54A ; ---------------------------------------------------------------------------
cseg01:0001B54A
cseg01:0001B54A loc_1B54A:                              ; CODE XREF: sub_1B280_draw_intro_text+5Fj
cseg01:0001B54A                                         ; DATA XREF: cseg01:0001B1ACo ...
cseg01:0001B54A                 cmp     byte_E3798, 0
cseg01:0001B551                 jz      short loc_1B5CB
cseg01:0001B553                 push    2
cseg01:0001B555                 push    0FFFFFFFFh
cseg01:0001B557                 movsx   edx, word_D4004
cseg01:0001B55E                 push    64h ; 'd'
cseg01:0001B560                 lea     eax, ds:0[edx*8]
cseg01:0001B567                 push    40h ; '@'
cseg01:0001B569                 sub     eax, edx
cseg01:0001B56B                 push    0
cseg01:0001B56D                 movsx   eax, word ptr [esi+eax+3]
cseg01:0001B572                 push    eax
cseg01:0001B573                 push    0
cseg01:0001B575                 call    sub_8F100_sound_proc19
cseg01:0001B57A                 add     esp, 1Ch
cseg01:0001B57D                 inc     word_D4004
cseg01:0001B584                 jmp     loc_1B289
cseg01:0001B589 ; ---------------------------------------------------------------------------
cseg01:0001B589
cseg01:0001B589 loc_1B589:                              ; CODE XREF: sub_1B280_draw_intro_text+5Fj
cseg01:0001B589                                         ; DATA XREF: cseg01:0001B1E4o
cseg01:0001B589                 cmp     byte_D41C0, 0
cseg01:0001B590                 jz      short loc_1B5CB
cseg01:0001B592                 push    eax
cseg01:0001B593                 call    sub_2EB60
cseg01:0001B598                 add     esp, 4
cseg01:0001B59B                 inc     word_D4004
cseg01:0001B5A2                 jmp     loc_1B289
cseg01:0001B5A7 ; ---------------------------------------------------------------------------
cseg01:0001B5A7
cseg01:0001B5A7 loc_1B5A7:                              ; CODE XREF: sub_1B280_draw_intro_text+5Fj
cseg01:0001B5A7                                         ; DATA XREF: cseg01:0001B1F0o
cseg01:0001B5A7                 push    eax
cseg01:0001B5A8                 call    sub_2EC60
cseg01:0001B5AD                 add     esp, 4
cseg01:0001B5B0                 inc     word_D4004
cseg01:0001B5B7                 jmp     loc_1B289
cseg01:0001B5BC ; ---------------------------------------------------------------------------
cseg01:0001B5BC
cseg01:0001B5BC loc_1B5BC:                              ; CODE XREF: sub_1B280_draw_intro_text+5Fj
cseg01:0001B5BC                                         ; DATA XREF: cseg01:0001B1E0o
cseg01:0001B5BC                 mov     ebx, dword_E9C4C[edx]
cseg01:0001B5C2                 push    ebx
cseg01:0001B5C3                 call    sub_2EBB0_draw_text_with_border_630x340
cseg01:0001B5C8                 add     esp, 4
cseg01:0001B5CB
cseg01:0001B5CB loc_1B5CB:                              ; CODE XREF: sub_1B280_draw_intro_text+45j
cseg01:0001B5CB                                         ; sub_1B280_draw_intro_text+5Fj ...
cseg01:0001B5CB                 inc     word_D4004
cseg01:0001B5D2                 jmp     loc_1B289
cseg01:0001B5D7 ; ---------------------------------------------------------------------------
cseg01:0001B5D7
cseg01:0001B5D7 loc_1B5D7:                              ; CODE XREF: sub_1B280_draw_intro_text+26j
cseg01:0001B5D7                                         ; sub_1B280_draw_intro_text+36j
cseg01:0001B5D7                 pop     ebp
cseg01:0001B5D8                 pop     edi
cseg01:0001B5D9                 pop     esi
cseg01:0001B5DA                 pop     ebx
cseg01:0001B5DB                 retn
*/

/*
cseg01:0001B18F                 align 10h
cseg01:0001B190 off_1B190       dd offset loc_1B2E6//00     ; DATA XREF: sub_1B280_draw_intro_text+5Fr
cseg01:0001B194                 dd offset loc_1B2F7//04
cseg01:0001B198                 dd offset loc_1B5CB//08
cseg01:0001B19C                 dd offset loc_1B51E//0c
cseg01:0001B1A0                 dd offset loc_1B316//10
cseg01:0001B1A4                 dd offset loc_1B461//14
cseg01:0001B1A8                 dd offset loc_1B5CB//18
cseg01:0001B1AC                 dd offset loc_1B54A//1c
cseg01:0001B1B0                 dd offset loc_1B5CB//20
cseg01:0001B1B4                 dd offset loc_1B5CB//24
cseg01:0001B1B8                 dd offset loc_1B36C//28
cseg01:0001B1BC                 dd offset loc_1B334//2c
cseg01:0001B1C0                 dd offset loc_1B352//30
cseg01:0001B1C4                 dd offset loc_1B5CB//34
cseg01:0001B1C8                 dd offset loc_1B4DF//38
cseg01:0001B1CC                 dd offset loc_1B4A0//3c
cseg01:0001B1D0                 dd offset loc_1B37D//40
cseg01:0001B1D4                 dd offset loc_1B398//44
cseg01:0001B1D8                 dd offset loc_1B3C9//48
cseg01:0001B1DC                 dd offset loc_1B424//4c
cseg01:0001B1E0                 dd offset loc_1B5BC//50
cseg01:0001B1E4                 dd offset loc_1B589//54
cseg01:0001B1E8                 dd offset loc_1B36C//58
cseg01:0001B1EC                 dd offset loc_1B450//5c
cseg01:0001B1F0                 dd offset loc_1B5A7//60
cseg01:0001B1F4                 dd offset loc_1B352//64
cseg01:0001B1F8                 dd offset loc_1B5CB//68
cseg01:0001B1FC                 dd offset loc_1B5CB//6c
cseg01:0001B200                 dd offset loc_1B5CB//70
cseg01:0001B204                 dd offset loc_1B5CB//74
cseg01:0001B208                 dd offset loc_1B5CB//78
cseg01:0001B20C                 dd offset loc_1B5CB//7c
cseg01:0001B210                 dd offset loc_1B2E6//80
cseg01:0001B214                 dd offset loc_1B2F7//84
cseg01:0001B218                 dd offset loc_1B5CB//88
cseg01:0001B21C                 dd offset loc_1B51E//8c
cseg01:0001B220                 dd offset loc_1B316//90
cseg01:0001B224                 dd offset loc_1B461//94
cseg01:0001B228                 dd offset loc_1B5CB//98
cseg01:0001B22C                 dd offset loc_1B54A//9c
cseg01:0001B230                 dd offset loc_1B5CB//a0
cseg01:0001B234                 dd offset loc_1B5CB//a4
cseg01:0001B238                 dd offset loc_1B5CB//a8
cseg01:0001B23C                 dd offset loc_1B334//ac
cseg01:0001B240                 dd offset loc_1B352//b0
cseg01:0001B244                 dd offset loc_1B5CB//b4
cseg01:0001B248                 dd offset loc_1B4DF//b8
cseg01:0001B24C                 dd offset loc_1B4A0//bc
cseg01:0001B250                 dd offset loc_1B5CB//c0
cseg01:0001B254                 dd offset loc_1B398//c4
cseg01:0001B258                 dd offset loc_1B3C9//c8
cseg01:0001B25C                 dd offset loc_1B424//cc
cseg01:0001B260                 dd offset loc_1B5CB//d0
cseg01:0001B264                 dd offset loc_1B5CB//d4
cseg01:0001B268                 dd offset loc_1B5CB//d8
cseg01:0001B26C                 dd offset loc_1B450//dc
cseg01:0001B270                 dd offset loc_1B5CB//e0
cseg01:0001B274                 dd offset loc_1B352//e4
cseg01:0001B278                 align 10h
*/

//----- (0001B5F0) --------------------------------------------------------
int sub_1B5F0()
{
	unsigned __int16 v0; // ax
	unsigned int j; // edx
	__int16 v2; // bx
	unsigned int i; // edx
	__int16 v4; // bx

	v0 = 0;
	do
	{
		if (v0 < 0xAu)
			goto LABEL_16;
		if (v0 <= 0xAu)
			goto LABEL_12;
		if (v0 != 27)
		{
		LABEL_16:
			for (i = x_D41A0_BYTEARRAY_4[(signed __int16)v0 + 38403]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
			{
				v4 = *(x_WORD *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240);
				*(x_DWORD *)(i + 8) = -1;
				*(x_WORD *)(i + 36) = v4;
			}
		}
		else
		{
			for (j = x_D41A0_BYTEARRAY_4[0x966F]; j > x_DWORD_EA3E4[0]; j = *(x_DWORD *)j)
			{
				v2 = *(x_WORD *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240);
				*(x_BYTE *)(j + 69) = -35;
				*(x_WORD *)(j + 36) = v2;
			}
		}
	LABEL_12:
		++v0;
	} while ((signed __int16)v0 < 29);
	return 0;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0001B6B0) --------------------------------------------------------
void sub_1B6B0(int a1)
{
	int v1; // esi
	int v2; // esi
	int v3; // esi
	int v4; // edi
	__int16 v5; // ax

	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 50)];
	if (*(x_BYTE *)(v1 + 63) != 5)
		sub_57F10(a1);
	if (*(x_BYTE *)(a1 + 57))
	{
		*(x_WORD *)(a1 + 28) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v1 + 76));
		*(x_WORD *)(a1 + 30) = sub_58210((x_WORD *)(a1 + 76), (x_WORD *)(v1 + 76));
		v2 = v1 + 76;
		*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)v2;
		*(&x_WORD_EB398 + 2) = *(x_WORD *)(v2 + 4);
		sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), *(x_WORD *)(a1 + 30), -*(x_WORD *)(a1 + 54));
		sub_57CF0(a1, (int)&x_WORD_EB398);
		if (*(x_WORD *)(a1 + 98))
		{
			v3 = *(x_DWORD *)(a1 + 94);
			v4 = *(x_DWORD *)(a1 + 8);
			v5 = *(x_WORD *)(a1 + 98);
			*(x_WORD *)(a1 + 98) = 0;
			*(x_WORD *)(a1 + 38) = v5;
			*(x_DWORD *)(a1 + 8) = v4 - v3;
		}
		else
		{
			*(x_WORD *)(a1 + 38) = 0;
		}
	}
	else if (!(*(x_BYTE *)(a1 + 62) & 3))
	{
		sub_57CF0(a1, v1 + 76);
		*(x_WORD *)(a1 + 28) = *(x_WORD *)(v1 + 28);
	}
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;

//----- (0001B7A0) --------------------------------------------------------
int sub_1B7A0(signed __int16 *a1)
{
	int v1; // eax
	unsigned __int16 v2; // dx
	unsigned __int16 v3; // bx
	unsigned __int8 v4; // cl
	unsigned __int16 v5; // bx
	int v6; // esi
	int v7; // ebx
	int v8; // ecx
	int v9; // ebx

	v1 = *a1 >> 8;
	BYTE1(v1) = (unsigned __int16)a1[1] >> 8;
	v2 = v1;
	LOBYTE(v1) = v1 + 1;
	v3 = v1;
	++BYTE1(v1);
	v4 = x_BYTE_11B4E0[v3];
	v5 = v1;
	LOBYTE(v2) = x_BYTE_11B4E0[v2];
	LOBYTE(v1) = v1 - 1;
	HIBYTE(v2) = x_BYTE_11B4E0[v5];
	v6 = x_BYTE_11B4E0[(unsigned __int16)v1];
	v7 = (unsigned __int8)v2 + v4 - v6;
	v8 = abs((unsigned __int8)v2 + v6 - v4 - HIBYTE(v2));
	v9 = abs(v7 - HIBYTE(v2));
	if (v8 > v9)
		v9 = v8;
	return v9;
}

//----- (0001B830) --------------------------------------------------------
int sub_1B830(x_WORD *a1)
{
	unsigned __int16 v1; // ax
	unsigned __int16 v2; // dx
	unsigned __int16 v3; // bx
	unsigned __int8 v4; // cl
	unsigned __int16 v5; // bx
	int v6; // esi
	int v7; // ebx
	int v8; // ecx
	int v9; // ebx

	LOBYTE(v1) = (*a1 >> 8) - 1;
	HIBYTE(v1) = (a1[1] >> 8) - 1;
	v2 = v1;
	LOBYTE(v1) = v1 + 2;
	v3 = v1;
	HIBYTE(v1) += 2;
	v4 = x_BYTE_11B4E0[v3];
	v5 = v1;
	LOBYTE(v2) = x_BYTE_11B4E0[v2];
	LOBYTE(v1) = v1 - 2;
	HIBYTE(v2) = x_BYTE_11B4E0[v5];
	v6 = x_BYTE_11B4E0[v1];
	v7 = (unsigned __int8)v2 + v4 - v6;
	v8 = abs((unsigned __int8)v2 + v6 - v4 - HIBYTE(v2));
	v9 = abs(v7 - HIBYTE(v2));
	if (v8 > v9)
		v9 = v8;
	return v9;
}

//----- (0001B8C0) --------------------------------------------------------
signed int sub_1B8C0(int a1)
{
	char v1; // ah
	char v2; // dl
	signed int result; // eax
	signed __int16 *v4; // eax
	__int16 v5; // ST10_2
	int v6; // ST0C_4
	int v7; // ST08_4
	__int16 v8; // ax
	__int16 v9; // ax
	int v10; // esi
	__int16 v11; // ax
	char v12; // ch
	__int16 v13; // ax
	signed __int16 *v14; // eax
	__int16 v15; // ST10_2
	int v16; // ST0C_4
	int v17; // ST08_4
	__int16 v18; // ax
	int v19; // esi
	__int16 v20; // ax
	__int16 v21; // ax
	signed __int16 *v22; // eax
	__int16 v23; // ST10_2
	int v24; // ST0C_4
	int v25; // ST08_4
	__int16 v26; // ax
	int v27; // esi
	__int16 v28; // ax
	signed __int16 *v29; // eax
	__int16 v30; // ST10_2
	int v31; // ST0C_4
	int v32; // ST08_4
	__int16 v33; // ax
	int v34; // esi
	__int16 v35; // ax
	int v36; // ebx
	__int16 v37; // [esp+0h] [ebp-4h]

	v1 = *(x_BYTE *)(a1 + 13);
	if (v1 & 8)
	{
		v2 = v1 & 0xF7;
		result = 4;
		*(x_BYTE *)(a1 + 13) = v2;
	}
	else if (*(x_BYTE *)(a1 + 64) == 27)
	{
		result = (unsigned __int8)sub_2AF10(a1, 1);
	}
	else
	{
		*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
		*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
		v4 = *(signed __int16 **)(a1 + 160);
		v5 = v4[7];
		v6 = v4[5];
		v7 = v4[6];
		v8 = sub_10C40(&x_WORD_EB398);
		sub_580E0((int)&x_WORD_EB398, v8, v7, v6, v5);
		sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), 0, *(x_WORD *)(a1 + 130));
		if (*(signed __int16 *)(a1 + 76) >> 8 != x_WORD_EB398 >> 8 || *(signed __int16 *)(a1 + 78) >> 8 != x_WORD_EB39A >> 8)
		{
			if (sub_102D0(a1, &x_WORD_EB398, 1)
				|| (v10 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 16), sub_1B7A0(&x_WORD_EB398) >= v10))
			{
				*(x_BYTE *)(a1 + 14) |= 4u;
				v13 = *(x_WORD *)(a1 + 28);
				v37 = v13;
				v13 += 341;
				HIBYTE(v13) &= 7u;
				*(x_WORD *)(a1 + 28) = v13;
				*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
				*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
				v14 = *(signed __int16 **)(a1 + 160);
				v15 = v14[7];
				v16 = v14[5];
				v17 = v14[6];
				v18 = sub_10C40(&x_WORD_EB398);
				sub_580E0((int)&x_WORD_EB398, v18, v17, v16, v15);
				sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), 0, *(x_WORD *)(a1 + 130));
				if (sub_102D0(a1, &x_WORD_EB398, 1)
					|| (v19 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 16), sub_1B7A0(&x_WORD_EB398) >= v19))
				{
					LOBYTE(v21) = v37 - 85;
					HIBYTE(v21) = ((unsigned __int16)(v37 - 341) >> 8) & 7;
					*(x_WORD *)(a1 + 28) = v21;
					*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
					*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
					v22 = *(signed __int16 **)(a1 + 160);
					v23 = v22[7];
					v24 = v22[5];
					v25 = v22[6];
					v26 = sub_10C40(&x_WORD_EB398);
					sub_580E0((int)&x_WORD_EB398, v26, v25, v24, v23);
					sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), 0, *(x_WORD *)(a1 + 130));
					if (sub_102D0(a1, &x_WORD_EB398, 1)
						|| (v27 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 16), sub_1B7A0(&x_WORD_EB398) >= v27))
					{
						*(x_WORD *)(a1 + 28) = __PAIR__(HIBYTE(v37) + 4, (unsigned __int8)v37) & 0x7FF;
						*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
						*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
						v29 = *(signed __int16 **)(a1 + 160);
						v30 = v29[7];
						v31 = v29[5];
						v32 = v29[6];
						v33 = sub_10C40(&x_WORD_EB398);
						sub_580E0((int)&x_WORD_EB398, v33, v32, v31, v30);
						sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), 0, *(x_WORD *)(a1 + 130));
						if (sub_102D0(a1, &x_WORD_EB398, 1)
							|| (v34 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 16), sub_1B7A0(&x_WORD_EB398) >= v34))
						{
							if (*(x_BYTE *)(*(x_DWORD *)(a1 + 160) + 32) & 1 || sub_104D0((signed __int16 *)(a1 + 76)) == (int(*)())1)
								*(x_DWORD *)(a1 + 8) = -1;
							if (*(x_DWORD *)(a1 + 8) == -1)
							{
								v36 = *(x_DWORD *)(0x364D1 + x_D41A0_BYTEARRAY_0 + 1);
								if (v36)
									*(x_DWORD *)(0x364D1 + x_D41A0_BYTEARRAY_0 + 1) = v36 - 1;
							}
							result = 4;
						}
						else
						{
							sub_57CF0(a1, (int)&x_WORD_EB398);
							v35 = *(x_WORD *)(a1 + 28)
								+ sub_58350(
									*(x_WORD *)(a1 + 28),
									*(x_WORD *)(a1 + 32),
									*(unsigned __int16 *)(*(x_DWORD *)(a1 + 160) + 4),
									*(x_WORD *)(*(x_DWORD *)(a1 + 160) + 2));
							HIBYTE(v35) &= 7u;
							*(x_WORD *)(a1 + 28) = v35;
							result = 3;
						}
					}
					else
					{
						sub_57CF0(a1, (int)&x_WORD_EB398);
						v28 = *(x_WORD *)(a1 + 28)
							+ sub_58350(
								*(x_WORD *)(a1 + 28),
								*(x_WORD *)(a1 + 32),
								*(unsigned __int16 *)(*(x_DWORD *)(a1 + 160) + 4),
								*(x_WORD *)(*(x_DWORD *)(a1 + 160) + 2));
						HIBYTE(v28) &= 7u;
						*(x_WORD *)(a1 + 28) = v28;
						result = 3;
					}
				}
				else
				{
					sub_57CF0(a1, (int)&x_WORD_EB398);
					v20 = *(x_WORD *)(a1 + 28)
						+ sub_58350(
							*(x_WORD *)(a1 + 28),
							*(x_WORD *)(a1 + 32),
							*(unsigned __int16 *)(*(x_DWORD *)(a1 + 160) + 4),
							*(x_WORD *)(*(x_DWORD *)(a1 + 160) + 2));
					HIBYTE(v20) &= 7u;
					*(x_WORD *)(a1 + 28) = v20;
					result = 3;
				}
			}
			else
			{
				sub_57CF0(a1, (int)&x_WORD_EB398);
				v11 = *(x_WORD *)(a1 + 28)
					+ sub_58350(
						*(x_WORD *)(a1 + 28),
						*(x_WORD *)(a1 + 32),
						*(unsigned __int16 *)(*(x_DWORD *)(a1 + 160) + 4),
						*(x_WORD *)(*(x_DWORD *)(a1 + 160) + 2));
				HIBYTE(v11) &= 7u;
				v12 = *(x_BYTE *)(a1 + 14) & 0xFB;
				*(x_WORD *)(a1 + 28) = v11;
				result = 2;
				*(x_BYTE *)(a1 + 14) = v12;
			}
		}
		else
		{
			sub_57CF0(a1, (int)&x_WORD_EB398);
			v9 = *(x_WORD *)(a1 + 28)
				+ sub_58350(
					*(x_WORD *)(a1 + 28),
					*(x_WORD *)(a1 + 32),
					*(unsigned __int16 *)(*(x_DWORD *)(a1 + 160) + 4),
					*(x_WORD *)(*(x_DWORD *)(a1 + 160) + 2));
			HIBYTE(v9) &= 7u;
			*(x_BYTE *)(a1 + 14) &= 0xFBu;
			*(x_WORD *)(a1 + 28) = v9;
			result = 1;
		}
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39A: using guessed type __int16 x_WORD_EB39A;

//----- (0001BD90) --------------------------------------------------------
signed int sub_1BD90(int a1, char a2)
{
	unsigned int v2; // esi
	__int16 v3; // ax
	int i; // eax
	int v5; // edx
	int v6; // eax
	char v7; // al
	int v8; // esi
	unsigned int j; // esi
	int v10; // eax
	unsigned int v11; // edi
	signed int v12; // ST08_4
	__int16 v13; // ax
	unsigned int v15; // [esp+4h] [ebp-Ch]
	unsigned int v16; // [esp+8h] [ebp-8h]
	unsigned int v17; // [esp+Ch] [ebp-4h]

	v2 = 0;
	if (*(x_WORD *)(a1 + 98))
	{
		*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
		v3 = *(x_WORD *)(a1 + 98);
		*(x_WORD *)(a1 + 98) = 0;
		v2 = 1;
		*(x_WORD *)(a1 + 38) = v3;
	}
	else
	{
		*(x_WORD *)(a1 + 38) = 0;
	}
	if (*(x_WORD *)(a1 + 52))
	{
		for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52))
		{
			v6 = x_DWORD_EA3E4[i];
			if (v6 == x_DWORD_EA3E4[0])
				break;
			v5 = *(x_DWORD *)(v6 + 8);
			if (v5 < *(x_DWORD *)(a1 + 8))
			{
				*(x_DWORD *)(a1 + 8) = v5;
				v2 = 1;
				*(x_WORD *)(a1 + 38) = *(x_WORD *)(v6 + 38);
				break;
			}
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 0)
	{
		v2 = 2;
		*(x_WORD *)(a1 + 36) = *(x_WORD *)(a1 + 38);
	}
	if (v2 >= 1)
	{
		if (v2 <= 1)
		{
			*(x_WORD *)(a1 + 150) = *(x_WORD *)(a1 + 38);
			if (*(x_BYTE *)(*(x_DWORD *)(a1 + 160) + 32) & 8)
				v7 = a2 + 6;
			else
				v7 = a2 + 2;
		}
		else
		{
			if (v2 != 2)
				return sub_1EEE0(a1);
			v7 = a2 + 4;
		}
		goto LABEL_35;
	}
	if (!v2)
	{
		v8 = *(x_DWORD *)(a1 + 160);
		if (!(*(x_BYTE *)(v8 + 32) & 4) && !(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(v8 + 26)))
		{
			v16 = -1;
			v15 = *(signed __int16 *)(v8 + 28) * *(signed __int16 *)(v8 + 28);
			v17 = 0;
			for (j = x_D41A0_BYTEARRAY_4[*(char *)(a1 + 64) + 38403]; j > x_DWORD_EA3E4[0]; j = *(x_DWORD *)j)
			{
				if (!*(x_WORD *)(j + 50) && j != a1)
				{
					v10 = (signed __int16)(*(x_WORD *)(j + 76) - *(x_WORD *)(a1 + 76));
					v11 = (signed __int16)(*(x_WORD *)(j + 78) - *(x_WORD *)(a1 + 78))
						* (signed __int16)(*(x_WORD *)(j + 78) - *(x_WORD *)(a1 + 78))
						+ v10 * v10;
					if (v11 <= v15)
					{
						v12 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 30);
						v13 = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(j + 76));
						if ((unsigned __int16)sub_582B0(*(x_WORD *)(a1 + 28), v13) < v12 && v11 < v16)
						{
							v17 = j;
							v16 = v11;
						}
					}
				}
			}
			if (v17)
			{
				*(x_WORD *)(a1 + 50) = (signed int)(v17 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
				v7 = a2 + 3;
			LABEL_35:
				*(x_BYTE *)(a1 + 69) = v7;
				return sub_1EEE0(a1);
			}
		}
	}
	return sub_1EEE0(a1);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0001BF90) --------------------------------------------------------
void sub_1BF90(int a1, char a2)
{
	unsigned int v2; // esi
	__int16 v3; // ax
	int i; // eax
	int v5; // edx
	int v6; // eax
	char v7; // al
	char v8; // al
	unsigned __int16 v9; // ax
	char v10; // cl
	int v11; // eax
	unsigned int v12; // esi
	int v13; // eax
	unsigned int v14; // edi
	signed int v15; // ST0C_4
	__int16 v16; // ax
	int v17; // eax
	unsigned int j; // esi
	int v19; // eax
	unsigned int v20; // edi
	signed int v21; // ST0C_4
	__int16 v22; // ax
	unsigned int v23; // [esp+0h] [ebp-1Ch]
	unsigned int v24; // [esp+8h] [ebp-14h]
	unsigned int v25; // [esp+Ch] [ebp-10h]
	unsigned int v26; // [esp+10h] [ebp-Ch]
	unsigned int v27; // [esp+14h] [ebp-8h]
	unsigned int v28; // [esp+18h] [ebp-4h]

	v2 = 0;
	if (*(x_WORD *)(a1 + 98))
	{
		*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
		v3 = *(x_WORD *)(a1 + 98);
		*(x_WORD *)(a1 + 98) = 0;
		v2 = 1;
		*(x_WORD *)(a1 + 38) = v3;
	}
	else
	{
		*(x_WORD *)(a1 + 38) = 0;
	}
	if (*(x_WORD *)(a1 + 52))
	{
		for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52))
		{
			v6 = x_DWORD_EA3E4[i];
			if (v6 == x_DWORD_EA3E4[0])
				break;
			v5 = *(x_DWORD *)(v6 + 8);
			if (v5 < *(x_DWORD *)(a1 + 8))
			{
				*(x_DWORD *)(a1 + 8) = v5;
				v2 = 1;
				*(x_WORD *)(a1 + 38) = *(x_WORD *)(v6 + 38);
				break;
			}
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 0)
	{
		v2 = 2;
		*(x_WORD *)(a1 + 36) = *(x_WORD *)(a1 + 38);
	}
	if (v2 < 1)
	{
		if (!v2)
		{
			sub_1B8C0(a1);
			if (!(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 26)))
			{
				*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
				v9 = *(x_WORD *)(a1 + 20);
				*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
				*(x_WORD *)(a1 + 32) += ((*(x_WORD *)(a1 + 20) & 0xFF) + 85) * (2 * ((signed int)(v9 % 0x9Du) / 79) - 1);
				v10 = *(x_BYTE *)(a1 + 57);
				*(x_BYTE *)(a1 + 33) &= 7u;
				if (v10)
				{
					v11 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 28);
					v23 = -1;
					v24 = 0;
					v12 = x_D41A0_BYTEARRAY_4[0x9677];
					v27 = v11 * v11;
					while (v12 > x_DWORD_EA3E4[0])
					{
						v13 = (signed __int16)(*(x_WORD *)(v12 + 76) - *(x_WORD *)(a1 + 76));
						v14 = (signed __int16)(*(x_WORD *)(v12 + 78) - *(x_WORD *)(a1 + 78))
							* (signed __int16)(*(x_WORD *)(v12 + 78) - *(x_WORD *)(a1 + 78))
							+ v13 * v13;
						if (v14 <= v27 && !(*(x_BYTE *)(v12 + 12) & 0x20))
						{
							v15 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 30);
							v16 = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v12 + 76));
							if ((unsigned __int16)sub_582B0(*(x_WORD *)(a1 + 28), v16) < v15 && v14 < v23)
							{
								v24 = v12;
								v23 = v14;
							}
						}
						v12 = *(x_DWORD *)v12;
					}
					if (v24)
					{
						*(x_WORD *)(a1 + 150) = (signed int)(v24 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
						if (*(x_BYTE *)(*(x_DWORD *)(a1 + 160) + 32) & 8)
							*(x_BYTE *)(a1 + 69) = a2 + 6;
						else
							*(x_BYTE *)(a1 + 69) = a2 + 2;
					}
					else
					{
						v17 = *(x_DWORD *)(a1 + 160);
						if (!(*(x_BYTE *)(v17 + 32) & 4))
						{
							v28 = -1;
							v26 = *(signed __int16 *)(v17 + 28) * *(signed __int16 *)(v17 + 28);
							v25 = 0;
							for (j = x_D41A0_BYTEARRAY_4[*(char *)(a1 + 64) + 38403]; j > x_DWORD_EA3E4[0]; j = *(x_DWORD *)j)
							{
								if (!*(x_WORD *)(j + 50) && j != a1)
								{
									v19 = (signed __int16)(*(x_WORD *)(j + 76) - *(x_WORD *)(a1 + 76));
									v20 = (signed __int16)(*(x_WORD *)(j + 78) - *(x_WORD *)(a1 + 78))
										* (signed __int16)(*(x_WORD *)(j + 78) - *(x_WORD *)(a1 + 78))
										+ v19 * v19;
									if (v20 <= v26)
									{
										v21 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 30);
										v22 = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(j + 76));
										if ((unsigned __int16)sub_582B0(*(x_WORD *)(a1 + 28), v22) < v21 && v20 < v28)
										{
											v25 = j;
											v28 = v20;
										}
									}
								}
							}
							if (v25)
							{
								*(x_WORD *)(a1 + 50) = (signed int)(v25 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
								v7 = a2 + 3;
								goto LABEL_49;
							}
						}
					}
				}
			}
		}
	}
	else
	{
		if (v2 > 1)
		{
			if (v2 != 2)
				return;
			v7 = a2 + 4;
		LABEL_49:
			*(x_BYTE *)(a1 + 69) = v7;
			return;
		}
		*(x_WORD *)(a1 + 150) = *(x_WORD *)(a1 + 38);
		if (*(x_BYTE *)(*(x_DWORD *)(a1 + 160) + 32) & 8)
			v8 = a2 + 6;
		else
			v8 = a2 + 2;
		*(x_BYTE *)(a1 + 69) = v8;
		sub_1EEE0(a1);
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0001C310) --------------------------------------------------------
signed int sub_1C310(int a1, char a2, unsigned __int16(*a3)(int, int))
{
	signed int v3; // edi
	unsigned int v4; // eax
	__int16 v5; // ax
	int i; // edx
	int v7; // edx
	int v8; // ecx
	int v10; // eax
	int v11; // esi
	__int16 v12; // ax
	int v13; // edx
	unsigned int j; // ecx
	int v15; // ecx
	unsigned int v16; // ST0C_4

	v3 = 0;
	v4 = 0;
	if (*(x_WORD *)(a1 + 98))
	{
		v5 = *(x_WORD *)(a1 + 98);
		*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
		*(x_WORD *)(a1 + 38) = v5;
		*(x_WORD *)(a1 + 98) = 0;
		v4 = 1;
	}
	else
	{
		*(x_WORD *)(a1 + 38) = 0;
	}
	if (*(x_WORD *)(a1 + 52))
	{
		for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v8 + 52))
		{
			v8 = x_DWORD_EA3E4[i];
			if (v8 == x_DWORD_EA3E4[0])
				break;
			v7 = *(x_DWORD *)(v8 + 8);
			if (v7 < *(x_DWORD *)(a1 + 8))
			{
				*(x_DWORD *)(a1 + 8) = v7;
				*(x_WORD *)(a1 + 38) = *(x_WORD *)(v8 + 38);
				v4 = 1;
				break;
			}
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 0)
	{
		*(x_WORD *)(a1 + 36) = *(x_WORD *)(a1 + 38);
		v4 = 2;
	}
	if (v4 < 1)
	{
		if (!v4)
		{
			sub_1B8C0(a1);
			v10 = sub_1ED30(a1, x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)]);
			v11 = v10;
			if (v10 == x_DWORD_EA3E4[0] || *(x_DWORD *)(v10 + 8) < 0 || *(x_BYTE *)(v10 + 13) & 4)
			{
				*(x_BYTE *)(a1 + 69) = a2 + 1;
				return 0;
			}
			if (!(*(x_BYTE *)(a1 + 62) & 3))
			{
				v12 = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v10 + 76));
				v13 = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
				*(x_WORD *)(a1 + 32) = v12;
				for (j = *(x_DWORD *)(v13 + 4 * *(char *)(a1 + 64) + 38403); j > x_DWORD_EA3E4[0]; j = *(x_DWORD *)j)
				{
					if (*(x_WORD *)(j + 26) != *(x_WORD *)(a1 + 26)
						&& abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(j + 76)) < (signed int)*(signed __int16 *)(a1 + 84)
						&& abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(j + 78)) < (signed int)*(signed __int16 *)(a1 + 84))
					{
						*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(j + 76), (Bit16u*)(a1 + 76));
						break;
					}
				}
			}
			v15 = *(x_DWORD *)(a1 + 160);
			if (!(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(v15 + 26)))
			{
				v16 = *(signed __int16 *)(v15 + 28);
				if (sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(v11 + 76)) >= v16)
				{
					*(x_BYTE *)(a1 + 69) = a2 + 1;
					return 0;
				}
				if (a3(a1, v11))
					v3 = 1;
			}
		}
	}
	else
	{
		if (v4 <= 1)
		{
			*(x_WORD *)(a1 + 150) = *(x_WORD *)(a1 + 38);
			sub_1EEE0(a1);
			return 0;
		}
		if (v4 == 2)
			*(x_BYTE *)(a1 + 69) = a2 + 4;
	}
	return v3;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0001C560) --------------------------------------------------------
char sub_1C560(int a1, unsigned __int16 a2)
{
	char v2; // al
	int v3; // eax
	int v4; // esi
	signed __int16 v5; // cx
	int i; // eax
	int v7; // edx
	int v8; // eax
	char v9; // al
	int v10; // eax
	char v11; // al
	int v12; // eax
	char v13; // al
	unsigned int v14; // ecx
	bool v16; // [esp+4h] [ebp-4h]

	if (!*(x_WORD *)(a1 + 50))
	{
		v2 = a2;
	LABEL_57:
		LOBYTE(v3) = v2 + 1;
	LABEL_58:
		*(x_BYTE *)(a1 + 69) = v3;
		return v3;
	}
	LOWORD(v3) = *(x_WORD *)(a1 + 50);
	v4 = x_DWORD_EA3E4[(unsigned __int16)v3];
	v16 = *(x_DWORD *)(v4 + 8) >= 0
		&& !(*(x_BYTE *)(v4 + 13) & 4)
		&& (LOBYTE(v3) = *(x_BYTE *)(v4 + 63), (x_BYTE)v3 == *(x_BYTE *)(a1 + 63))
		&& (LOBYTE(v3) = *(x_BYTE *)(v4 + 64), (x_BYTE)v3 == *(x_BYTE *)(a1 + 64));
	v5 = 0;
	if (*(x_WORD *)(a1 + 98))
	{
		*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
		LOWORD(v3) = *(x_WORD *)(a1 + 98);
		*(x_WORD *)(a1 + 98) = 0;
		v5 = 1;
		*(x_WORD *)(a1 + 38) = v3;
	}
	else
	{
		*(x_WORD *)(a1 + 38) = 0;
	}
	if (*(x_WORD *)(a1 + 52))
	{
		for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v3 + 52))
		{
			v3 = x_DWORD_EA3E4[i];
			if (v3 == x_DWORD_EA3E4[0])
				break;
			v7 = *(x_DWORD *)(v3 + 8);
			if (v7 < *(x_DWORD *)(a1 + 8))
			{
				*(x_DWORD *)(a1 + 8) = v7;
				LOWORD(v3) = *(x_WORD *)(v3 + 38);
				v5 = 1;
				*(x_WORD *)(a1 + 38) = v3;
				break;
			}
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 0)
	{
		LOWORD(v3) = *(x_WORD *)(a1 + 38);
		v5 = 2;
		*(x_WORD *)(a1 + 36) = v3;
	}
	if ((unsigned __int16)v5 < 1u)
	{
		if (v5)
			return v3;
		sub_1B8C0(a1);
		if (!v16)
		{
			v2 = a2;
			*(x_WORD *)(a1 + 50) = 0;
			goto LABEL_57;
		}
		LOWORD(v3) = (signed __int16)*(unsigned __int8 *)(a1 + 62) / *(x_WORD *)(*(x_DWORD *)(a1 + 160) + 26);
		if (!(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 26)))
		{
			switch (*(unsigned __int8 *)(v4 + 69) - a2)
			{
			case 0:
			case 1:
				goto LABEL_45;
			case 2:
				*(x_WORD *)(a1 + 150) = *(x_WORD *)(v4 + 150);
				*(x_WORD *)(a1 + 50) = 0;
				LOBYTE(v3) = a2 + 2;
				*(x_BYTE *)(a1 + 69) = a2 + 2;
				return v3;
			case 3:
				*(x_WORD *)(a1 + 50) = *(x_WORD *)(v4 + 50);
			LABEL_45:
				*(x_WORD *)(a1 + 32) = sub_581E0(
					(Bit16u*)(a1 + 76),
					(Bit16u*)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 50)] + 76));
				v14 = x_D41A0_BYTEARRAY_4[*(char *)(a1 + 64) + 38403];
				break;
			case 6:
				*(x_WORD *)(a1 + 150) = *(x_WORD *)(v4 + 150);
				*(x_WORD *)(a1 + 50) = 0;
				LOBYTE(v3) = a2 + 6;
				*(x_BYTE *)(a1 + 69) = a2 + 6;
				return v3;
			default:
				*(x_WORD *)(a1 + 50) = 0;
				LOBYTE(v3) = a2 + 1;
				*(x_BYTE *)(a1 + 69) = a2 + 1;
				return v3;
			}
			while (v14 > x_DWORD_EA3E4[0])
			{
				if (*(x_WORD *)(v14 + 26) != *(x_WORD *)(a1 + 26)
					&& abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(v14 + 76)) < 256
					&& abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(v14 + 78)) < 256)
				{
					*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(v14 + 76), (Bit16u*)(a1 + 76));
					break;
				}
				v14 = *(x_DWORD *)v14;
			}
			LOWORD(v3) = *(x_WORD *)(v4 + 134) + *(x_WORD *)(v4 + 130);
			*(x_WORD *)(a1 + 130) = v3;
		}
	}
	else
	{
		if ((unsigned __int16)v5 > 1u)
		{
			if (v5 != 2)
				return v3;
			if (v16)
			{
				*(x_WORD *)(v4 + 150) = *(x_WORD *)(a1 + 38);
				v8 = *(x_DWORD *)(v4 + 160);
				*(x_WORD *)(v4 + 50) = 0;
				if (*(x_BYTE *)(v8 + 32) & 8)
					v9 = a2 + 6;
				else
					v9 = a2 + 2;
				*(x_BYTE *)(v4 + 69) = v9;
			}
			*(x_WORD *)(a1 + 50) = 0;
			LOBYTE(v3) = a2 + 4;
			goto LABEL_58;
		}
		if (v16)
		{
			*(x_WORD *)(v4 + 150) = *(x_WORD *)(a1 + 38);
			v10 = *(x_DWORD *)(v4 + 160);
			*(x_WORD *)(v4 + 50) = 0;
			if (*(x_BYTE *)(v10 + 32) & 8)
				v11 = a2 + 6;
			else
				v11 = a2 + 2;
			*(x_BYTE *)(v4 + 69) = v11;
		}
		*(x_WORD *)(a1 + 150) = *(x_WORD *)(a1 + 38);
		v12 = *(x_DWORD *)(a1 + 160);
		*(x_WORD *)(a1 + 50) = 0;
		if (*(x_BYTE *)(v12 + 32) & 8)
			v13 = a2 + 6;
		else
			v13 = a2 + 2;
		*(x_BYTE *)(a1 + 69) = v13;
		LOBYTE(v3) = sub_1EEE0(a1);
	}
	return v3;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0001C890) --------------------------------------------------------
int sub_1C890(int a1, char a2)
{
	int result; // eax
	int i; // edx
	__int16 v4; // bx
	int v5; // edx
	int v6; // edx
	unsigned int v7; // edx
	char v8; // bl

	result = a1;
	for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52))
	{
		v5 = x_DWORD_EA3E4[i];
		if (v5 == x_DWORD_EA3E4[0])
			break;
		*(x_BYTE *)(v5 + 69) = a2 + 5;
		v4 = *(x_WORD *)(v5 + 36);
		if (v4)
			*(x_WORD *)(a1 + 36) = v4;
	}
	HIWORD(v6) = HIWORD(x_DWORD_EA3E4[0]) ^ HIWORD(v5);
	LOWORD(v6) = *(x_WORD *)(a1 + 36);
	v7 = x_DWORD_EA3E4[v6];
	if (v7 > x_DWORD_EA3E4[0]
		&& *(x_BYTE *)(v7 + 63) == 3
		&& !*(x_BYTE *)(v7 + 64)
		&& *(x_WORD *)(a1 + 26) != *(x_WORD *)(v7 + 26))
	{
		v8 = *(x_BYTE *)(a1 + 64);
		if (v8 != 12 && v8 != 13 && v8 != 14 && v8 != 15 && v8 != 9)
			++*(x_DWORD *)(*(x_DWORD *)(v7 + 164) + 373);
	}
	*(x_BYTE *)(a1 + 69) = a2 + 5;
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0001C930) --------------------------------------------------------
void sub_1C930(int a1)
{
	int v1; // eax

	if (!(*(x_BYTE *)(a1 + 62) & 7))
	{
		sub_36BA0(a1, 0);
		if (!(*(x_BYTE *)(a1 + 14) & 0x10))
		{
			v1 = sub_4A190(a1 + 76, 10, 1);
			if (v1)
				*(x_WORD *)(v1 + 26) = *(x_WORD *)(a1 + 26);
		}
		sub_57F10(a1);
	}
}

//----- (0001C980) --------------------------------------------------------
int sub_1C980(int a1, char a2)
{
	unsigned int v2; // ecx
	__int16 v3; // ax
	int i; // eax
	int v5; // edx
	int v6; // eax
	char v7; // al
	unsigned int v9; // eax
	unsigned int v10; // esi
	__int16 v11; // ax
	int v12; // edx
	int v13; // eax
	unsigned int j; // ecx
	int v15; // ecx
	unsigned int v16; // ST08_4

	v2 = 0;
	if (*(x_WORD *)(a1 + 98))
	{
		v3 = *(x_WORD *)(a1 + 98);
		*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
		*(x_WORD *)(a1 + 38) = v3;
		v2 = 1;
		*(x_WORD *)(a1 + 98) = 0;
	}
	else
	{
		*(x_WORD *)(a1 + 38) = 0;
	}
	if (*(x_WORD *)(a1 + 52))
	{
		for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52))
		{
			v6 = x_DWORD_EA3E4[i];
			if (v6 == x_DWORD_EA3E4[0])
				break;
			v5 = *(x_DWORD *)(v6 + 8);
			if (v5 < *(x_DWORD *)(a1 + 8))
			{
				*(x_DWORD *)(a1 + 8) = v5;
				v2 = 1;
				*(x_WORD *)(a1 + 38) = *(x_WORD *)(v6 + 38);
				break;
			}
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 0)
	{
		v2 = 2;
		*(x_WORD *)(a1 + 36) = *(x_WORD *)(a1 + 38);
	}
	if (v2 < 1)
	{
		if (v2)
			return 0;
		sub_1B8C0(a1);
		v9 = sub_1ED30(a1, x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)]);
		v10 = v9;
		if (v9 > x_DWORD_EA3E4[0] && *(x_DWORD *)(v9 + 8) >= 0 && !(*(x_BYTE *)(v9 + 13) & 4))
		{
			if (!(*(x_BYTE *)(a1 + 62) & 3))
			{
				v11 = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v9 + 76));
				HIBYTE(v11) += 4;
				*(x_WORD *)(a1 + 32) = v11;
				v12 = 4 * *(char *)(a1 + 64);
				v13 = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;
				*(x_BYTE *)(a1 + 33) &= 7u;
				for (j = *(x_DWORD *)(v12 + v13 + 38403); j > x_DWORD_EA3E4[0]; j = *(x_DWORD *)j)
				{
					if (*(x_WORD *)(j + 26) != *(x_WORD *)(a1 + 26)
						&& abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(j + 76)) < (signed int)*(signed __int16 *)(a1 + 84)
						&& abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(j + 78)) < (signed int)*(signed __int16 *)(a1 + 84))
					{
						*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(j + 76), (Bit16u*)(a1 + 76));
						break;
					}
				}
			}
			v15 = *(x_DWORD *)(a1 + 160);
			if (*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(v15 + 26))
				return 0;
			v16 = *(signed __int16 *)(v15 + 28);
			if (sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(v10 + 76)) < v16)
				return 0;
		}
		v7 = a2 + 1;
		goto LABEL_34;
	}
	if (v2 <= 1)
	{
		*(x_WORD *)(a1 + 150) = *(x_WORD *)(a1 + 38);
		sub_1EEE0(a1);
		return 0;
	}
	if (v2 == 2)
	{
		v7 = a2 + 4;
	LABEL_34:
		*(x_BYTE *)(a1 + 69) = v7;
	}
	return 0;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0001CC20) --------------------------------------------------------
signed int sub_1CC20(x_WORD *a1, unsigned int a2)
{
	x_WORD *v2; // esi
	signed int v3; // edi
	int v4; // eax
	int v5; // ebx
	char v6; // al

	v2 = a1 + 38;
	v3 = 0;
	v4 = sub_4A190((int)(a1 + 38), 9, 0);
	v5 = v4;
	if (v4)
	{
		*(x_BYTE *)(v4 + 67) = 10;
		*(x_BYTE *)(v4 + 68) = 0;
		*(x_WORD *)(v4 + 26) = a1[13];
		*(x_WORD *)(v4 + 28) = sub_581E0((Bit16u*)v2, (Bit16u*)(a2 + 76));
		*(x_WORD *)(v5 + 30) = sub_58210(v2, (x_WORD *)(a2 + 76));
		*(x_WORD *)(v5 + 80) += a1[44];
		*(x_WORD *)(v5 + 150) = a1[75];
		*(x_DWORD *)(v5 + 160) = (x_DWORD)&unk_D8478;
		*(x_BYTE *)(v5 + 66) = *(x_BYTE *)(a2 + 64);
		v6 = *(x_BYTE *)(a2 + 63);
		*(x_WORD *)(v5 + 42) = 500;
		v3 = 1;
		*(x_BYTE *)(v5 + 65) = v6;
		sub_5EF70(a2);
	}
	return v3;
}

//----- (0001CCE0) --------------------------------------------------------
signed int sub_1CCE0(x_WORD *a1, unsigned int a2)
{
	x_WORD *v2; // edi
	signed int v3; // esi
	int v4; // ebx
	char v5; // al

	v2 = a1 + 38;
	v3 = 0;
	v4 = sub_4A190((int)(a1 + 38), 9, 13);
	if (v4)
	{
		*(x_WORD *)(v4 + 26) = a1[13];
		*(x_WORD *)(v4 + 28) = sub_581E0((Bit16u*)v2, (Bit16u*)(a2 + 76));
		*(x_WORD *)(v4 + 30) = sub_58210(v2, (x_WORD *)(a2 + 76));
		*(x_WORD *)(v4 + 80) += a1[44] / 2;
		*(x_WORD *)(v4 + 150) = a1[75];
		*(x_BYTE *)(v4 + 66) = *(x_BYTE *)(a2 + 64);
		v5 = *(x_BYTE *)(a2 + 63);
		*(x_WORD *)(v4 + 42) = 250;
		*(x_BYTE *)(v4 + 65) = v5;
		sub_49E10((x_WORD *)v4, 195);
		v3 = 1;
		sub_5EF70(a2);
	}
	return v3;
}

//----- (0001CDA0) --------------------------------------------------------
signed int sub_1CDA0(x_WORD *a1, unsigned int a2)
{
	signed int v2; // edi
	int v3; // ebx
	x_WORD *v5; // [esp+4h] [ebp-4h]

	v2 = 0;
	v5 = a1 + 38;
	v3 = sub_4A190((int)(a1 + 38), 9, 13);
	if (v3)
	{
		*(x_WORD *)(v3 + 26) = a1[13];
		*(x_WORD *)(v3 + 28) = sub_581E0((Bit16u*)v5, (Bit16u*)(a2 + 76));
		*(x_WORD *)(v3 + 30) = sub_58210(v5, (x_WORD *)(a2 + 76));
		*(x_WORD *)(v3 + 80) += a1[44];
		*(x_WORD *)(v3 + 150) = a1[75];
		*(x_BYTE *)(v3 + 66) = *(x_BYTE *)(a2 + 64);
		*(x_BYTE *)(v3 + 65) = *(x_BYTE *)(a2 + 63);
		if (a1[74])
			*(x_WORD *)(v3 + 42) = 600;
		else
			*(x_WORD *)(v3 + 42) = 400;
		sub_49E10((x_WORD *)v3, 203);
		v2 = 1;
		sub_5EF70(a2);
	}
	return v2;
}

//----- (0001CE80) --------------------------------------------------------
signed int sub_1CE80(int a1, int a2)
{
	signed int v2; // ebx

	v2 = 0;
	if ((signed int)sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(a2 + 76)) < 1024)
	{
		v2 = 1;
		sub_11900(a1, a2, 0, *(x_WORD *)(a1 + 42));
	}
	return v2;
}

//----- (0001CED0) --------------------------------------------------------
signed int sub_1CED0(int a1, int a2)
{
	signed int v2; // ebx

	v2 = 0;
	if ((signed int)sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(a2 + 76)) < 768)
	{
		v2 = 1;
		sub_11900(a1, a2, 0, *(x_WORD *)(a1 + 42));
	}
	return v2;
}

//----- (0001CF20) --------------------------------------------------------
signed int sub_1CF20(int a1, int a2)
{
	signed int v2; // ebx

	v2 = 0;
	if ((signed int)sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(a2 + 76)) < 1536)
	{
		v2 = 1;
		sub_11900(a1, a2, 0, *(x_WORD *)(a1 + 42));
	}
	return v2;
}

//----- (0001D0E0) --------------------------------------------------------
signed int sub_1D0E0(x_WORD *a1, unsigned int a2)
{
	x_WORD *v2; // esi
	signed int v3; // edi
	int v4; // eax
	int v5; // ebx
	char v6; // al

	v2 = a1 + 38;
	v3 = 0;
	v4 = sub_4A190((int)(a1 + 38), 9, 20);
	v5 = v4;
	if (v4)
	{
		*(x_BYTE *)(v4 + 67) = 10;
		*(x_BYTE *)(v4 + 68) = 65;
		*(x_WORD *)(v4 + 26) = a1[13];
		*(x_WORD *)(v4 + 28) = sub_581E0((Bit16u*)v2, (Bit16u*)(a2 + 76));
		*(x_WORD *)(v5 + 30) = sub_58210(v2, (x_WORD *)(a2 + 76));
		*(x_WORD *)(v5 + 80) += a1[44];
		*(x_WORD *)(v5 + 150) = a1[75];
		*(x_DWORD *)(v5 + 160) = (x_DWORD)&unk_D8478;
		*(x_BYTE *)(v5 + 66) = *(x_BYTE *)(a2 + 64);
		v6 = *(x_BYTE *)(a2 + 63);
		*(x_WORD *)(v5 + 42) = 780;
		v3 = 1;
		*(x_BYTE *)(v5 + 65) = v6;
		sub_5EF70(a2);
	}
	return v3;
}

//----- (0001D1A0) --------------------------------------------------------
signed int sub_1D1A0(x_WORD *a1, unsigned int a2)
{
	x_WORD *v2; // esi
	signed int v3; // edi
	int v4; // eax
	int v5; // ebx
	__int16 v6; // ax
	__int16 v7; // dx

	v2 = a1 + 38;
	v3 = 0;
	v4 = sub_4A190((int)(a1 + 38), 9, 21);
	v5 = v4;
	if (v4)
	{
		*(x_BYTE *)(v4 + 67) = 10;
		*(x_BYTE *)(v4 + 68) = 66;
		*(x_WORD *)(v4 + 26) = a1[13];
		*(x_WORD *)(v4 + 28) = sub_581E0((Bit16u*)v2, (Bit16u*)(a2 + 76));
		v6 = sub_58210(v2, (x_WORD *)(a2 + 76));
		v7 = *(x_WORD *)(v5 + 80);
		*(x_WORD *)(v5 + 30) = v6;
		*(x_WORD *)(v5 + 80) = v7 + 128;
		*(x_WORD *)(v5 + 150) = a1[75];
		*(x_DWORD *)(v5 + 160) = (x_DWORD)&unk_D8478;
		*(x_BYTE *)(v5 + 66) = *(x_BYTE *)(a2 + 64);
		LOBYTE(v6) = *(x_BYTE *)(a2 + 63);
		*(x_WORD *)(v5 + 42) = 780;
		v3 = 1;
		*(x_BYTE *)(v5 + 65) = v6;
		sub_5EF70(a2);
	}
	return v3;
}

//----- (0001D260) --------------------------------------------------------
signed int sub_1D260(int a1, unsigned int a2)
{
	int v2; // eax
	int v3; // ebx
	char v4; // al
	signed int v6; // [esp+0h] [ebp-4h]

	*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
	*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
	v6 = 0;
	x_WORD_EB39C += *(x_WORD *)(a1 + 88);
	v2 = sub_4A190((int)&x_WORD_EB398, 9, 9);
	v3 = v2;
	if (v2)
	{
		*(x_BYTE *)(v2 + 67) = 10;
		*(x_BYTE *)(v2 + 68) = 23;
		*(x_WORD *)(v2 + 26) = *(x_WORD *)(a1 + 26);
		*(x_WORD *)(v2 + 28) = sub_581E0((Bit16u *)&x_WORD_EB398, (Bit16u *)(a2 + 76));
		*(x_WORD *)(v3 + 30) = sub_58210(&x_WORD_EB398, (x_WORD *)(a2 + 76));
		*(x_WORD *)(v3 + 150) = *(x_WORD *)(a1 + 150);
		*(x_DWORD *)(v3 + 160) = (x_DWORD)&off_D8456;
		*(x_BYTE *)(v3 + 66) = *(x_BYTE *)(a2 + 64);
		v4 = *(x_BYTE *)(a2 + 63);
		*(x_WORD *)(v3 + 42) = 4000;
		*(x_BYTE *)(v3 + 65) = v4;
		sub_5EF70(a2);
		v6 = 1;
	}
	return v6;
}
// D8456: using guessed type void *off_D8456;
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (0001D460) --------------------------------------------------------
signed int sub_1D460(x_WORD *a1, int a2)
{
	unsigned __int16 v2; // si
	signed __int16 v3; // di
	int v4; // eax
	x_WORD *v5; // ebx
	__int16 v6; // ax
	__int16 v7; // cx
	x_WORD *v9; // [esp+4h] [ebp-8h]
	signed int v10; // [esp+8h] [ebp-4h]

	v2 = 0;
	v10 = 0;
	do
	{
		switch (v2)
		{
		case 0u:
			v3 = -226;
			break;
		case 1u:
			v3 = -113;
			break;
		case 2u:
			v3 = 0;
			break;
		case 3u:
			v3 = 113;
			break;
		default:
			v3 = 226;
			break;
		}
		v9 = a1 + 38;
		v4 = sub_4A190((int)(a1 + 38), 9, 0);
		v5 = (x_WORD *)v4;
		if (v4)
		{
			*(x_BYTE *)(v4 + 67) = 10;
			*(x_BYTE *)(v4 + 68) = 0;
			*(x_DWORD *)(v4 + 160) = (x_DWORD)&unk_D83F0;
			*(x_BYTE *)(v4 + 66) = *(x_BYTE *)(a2 + 64);
			*(x_BYTE *)(v4 + 65) = *(x_BYTE *)(a2 + 63);
			*(x_WORD *)(v4 + 42) = 800;
			*(x_WORD *)(v4 + 26) = a1[13];
			*(x_WORD *)(v4 + 28) = v3 + sub_581E0((Bit16u*)v9, (Bit16u*)(a2 + 76));
			v6 = sub_58210(v9, (x_WORD *)(a2 + 76));
			v7 = v5[40];
			v5[15] = v6;
			v5[40] = v7 + 200;
			v10 = 1;
			v5[75] = a1[75];
		}
		++v2;
	} while (v2 < 5u);
	return v10;
}

//----- (0001D5D0) --------------------------------------------------------
void sub_1D5D0(int a1, __int16 a2)
{
	switch (*(x_BYTE *)(a1 + 73))
	{
	case 1:
		sub_1DDA0(a1, a2);
		break;
	case 2:
		sub_1DBF0(a1, a2);
		break;
	case 3:
		sub_1D7C0(a1, a2);
		break;
	case 4:
		sub_1D700(a1, a2);
		break;
	case 5:
		sub_1D8C0(a1, a2);
		break;
	case 6:
		sub_1E000(a1, a2);
		break;
	case 7:
		sub_1E020(a1, a2);
		break;
	case 8:
		sub_1D880(a1, a2);
		break;
	case 9:
		sub_1D8A0(a1, a2);
		break;
	case 0xA:
		sub_1E040(a1, a2);
		break;
	case 0xC:
		sub_1E4D0(a1);
		break;
	case 0xD:
	case 0x10:
		sub_1E580(a1, a2);
		break;
	case 0xE:
		sub_1E9C0(a1, a2);
		break;
	case 0x11:
		sub_1E320(a1);
		break;
	default:
		return;
	}
}

//----- (0001D700) --------------------------------------------------------
void sub_1D700(int a1, __int16 a2)
{
	char *v2; // esi
	unsigned int v3; // esi
	unsigned __int16 v4; // dx
	unsigned int v5; // edi

	sub_1D8C0(a1, a2);
	if (!(*(x_BYTE *)(a1 + 62) & 7))
	{
		v2 = (char*)(0x365F2 + 8 * *(unsigned __int8 *)(a1 + 72) + x_D41A0_BYTEARRAY_0 + 2);
		if (v2[1] & 2)
			v3 = x_DWORD_EA3E4[*(signed __int16 *)(a1 + 74)];
		else
			v3 = *((x_DWORD *)v2 + 1);
		if (v3)
		{
			if (v3 > x_DWORD_EA3E4[0])
			{
				v4 = *(x_WORD *)(v3 + 150);
				if (v4)
				{
					v5 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 28);
					if (sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(x_DWORD_EA3E4[v4] + 76)) <= v5)
					{
						*(x_WORD *)(a1 + 150) = *(x_WORD *)(v3 + 150);
						*(x_BYTE *)(a1 + 73) = 10;
						sub_1E040(a1, a2);
					}
				}
			}
		}
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0001D7C0) --------------------------------------------------------
void sub_1D7C0(int a1, __int16 a2)
{
	Bit8u* v2; // esi
	unsigned int v3; // esi
	unsigned int v4; // edi

	sub_1D8C0(a1, a2);
	if (!(*(x_BYTE *)(a1 + 62) & 7))
	{
		v2 = 0x365F2 + 8 * *(unsigned __int8 *)(a1 + 72) + x_D41A0_BYTEARRAY_0 + 2;
		if (v2[1] & 2)
			v3 = x_DWORD_EA3E4[*(signed __int16 *)(a1 + 74)];
		else
			v3 = *((x_DWORD *)v2 + 1);
		if (v3 && v3 > x_DWORD_EA3E4[0])
		{
			v4 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 28);
			if (sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(v3 + 76)) <= v4)
			{
				*(x_WORD *)(a1 + 150) = (signed int)(v3 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
				*(x_BYTE *)(a1 + 73) = 10;
				sub_1E040(a1, a2);
			}
		}
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0001D880) --------------------------------------------------------
char sub_1D880(int a1, __int16 a2)
{
	return sub_1E1C0(a1, a2);
}

//----- (0001D8A0) --------------------------------------------------------
char sub_1D8A0(int a1, __int16 a2)
{
	return sub_1E1C0(a1, a2);
}

//----- (0001D8C0) --------------------------------------------------------
void sub_1D8C0(int a1, __int16 a2)
{
	unsigned int v2; // ecx
	__int16 v3; // ax
	int i; // eax
	int v5; // eax
	int v6; // esi
	int v7; // eax
	char v8; // al
	char v9; // cl
	char v10; // al
	Bit8u* v11; // esi
	x_WORD *v12; // esi
	__int16 v13; // ax
	char v14; // dl
	unsigned __int16 v15; // ax
	unsigned int j; // ecx

	// fix it
	v12 = 0;
	// fix it

	v2 = 0;
	if (*(x_WORD *)(a1 + 98))
	{
		*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
		v3 = *(x_WORD *)(a1 + 98);
		*(x_WORD *)(a1 + 98) = 0;
		v2 = 1;
		*(x_WORD *)(a1 + 38) = v3;
	}
	else
	{
		*(x_WORD *)(a1 + 38) = 0;
	}
	if (*(x_WORD *)(a1 + 52) && *(x_BYTE *)(a1 + 64) != 27)
	{
		for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52))
		{
			v6 = x_DWORD_EA3E4[i];
			if (v6 == x_DWORD_EA3E4[0])
				break;
			v5 = *(x_DWORD *)(v6 + 8);
			if (v5 < *(x_DWORD *)(a1 + 8))
			{
				*(x_DWORD *)(a1 + 8) = v5;
				v2 = 1;
				*(x_WORD *)(a1 + 38) = *(x_WORD *)(v6 + 38);
				break;
			}
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 0)
	{
		v2 = 2;
		*(x_WORD *)(a1 + 36) = *(x_WORD *)(a1 + 38);
	}
	if (v2 < 1)
	{
		if (!v2)
		{
			sub_1B8C0(a1);
			if (!(*(x_BYTE *)(a1 + 62) & 7))
			{
				v11 = x_D41A0_BYTEARRAY_0 + 8 * *(unsigned __int8 *)(a1 + 72);
				if (*(x_BYTE *)(v11 + 222709) & 2)
				{
					if (!*(x_WORD *)(a1 + 74))
						*(x_WORD *)(a1 + 74) = sub_1E3E0(a1);
					v12 = (x_WORD *)x_DWORD_EA3E4[*(signed __int16 *)(a1 + 74)];
				}
				else
				{
					//v12 = *(x_WORD **)((char *)sub_365F8 + v11);//fix it
				}
				if (v12 && (unsigned int)v12 > x_DWORD_EA3E4[0])
				{
					if (!(*(x_BYTE *)(a1 + 14) & 4))
					{
						v13 = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)v12 + 38);
						v14 = *(x_BYTE *)(a1 + 62);
						*(x_WORD *)(a1 + 32) = v13;
						if (!(v14 & 0x3F))
						{
							*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
							v15 = *(x_WORD *)(a1 + 20);
							*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
							*(x_WORD *)(a1 + 32) += (2 * ((signed int)(v15 % 0x9Du) / 79) - 1) * ((*(x_WORD *)(a1 + 20) & 0xFF) + 85);
							*(x_BYTE *)(a1 + 33) &= 7u;
						}
					}
					for (j = x_D41A0_BYTEARRAY_4[*(char *)(a1 + 64) + 38403]; j > x_DWORD_EA3E4[0]; j = *(x_DWORD *)j)
					{
						if (*(x_WORD *)(j + 26) != *(x_WORD *)(a1 + 26)
							&& abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(j + 76)) < (signed int)*(signed __int16 *)(a1 + 84)
							&& abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(j + 78)) < (signed int)*(signed __int16 *)(a1 + 84))
						{
							*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(j + 76), (Bit16u*)(a1 + 76));
							break;
						}
					}
					if (abs(*(signed __int16 *)(a1 + 76) - (signed __int16)v12[38]) < *(signed __int16 *)(a1 + 84)
						+ (signed __int16)v12[42]
						&& abs(*(signed __int16 *)(a1 + 78) - (signed __int16)v12[39]) < *(signed __int16 *)(a1 + 84)
						+ (signed __int16)v12[42])
					{
						*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)v12 + 38, (Bit16u*)(a1 + 76));
					}
				}
				else if (!(*(x_BYTE *)(a1 + 62) & 0xF) && !(*(x_BYTE *)(a1 + 14) & 4))
				{
					*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
					*(x_WORD *)(a1 + 32) += *(x_WORD *)(a1 + 20) % 0x71u + 142;
					*(x_BYTE *)(a1 + 33) &= 7u;
				}
			}
		}
	}
	else if (v2 <= 1)
	{
		v7 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 38)];
		if (*(x_BYTE *)(v7 + 63) != *(x_BYTE *)(a1 + 63) || (v8 = *(x_BYTE *)(v7 + 64), v9 = *(x_BYTE *)(a1 + 64), v8 != v9))
			v10 = 1;
		else
			v10 = v9 ^ v8;
		if (v10)
		{
			*(x_WORD *)(a1 + 150) = *(x_WORD *)(a1 + 38);
			*(x_BYTE *)(a1 + 73) = 10;
			sub_1E040(a1, a2);
		}
		sub_1EEE0(a1);
	}
	else if (v2 == 2)
	{
		*(x_BYTE *)(a1 + 69) = a2 + 4;
	}
}
// 365F8: using guessed type int sub_365F8();
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0001DBF0) --------------------------------------------------------
int sub_1DBF0(int a1, unsigned __int16 a2)
{
	Bit8u* v2; // esi
	int result; // eax
	int v4; // esi
	unsigned int v5; // edi
	unsigned int v6; // esi
	int v7; // ecx
	__int16 v8; // dx
	int v9; // ST08_4
	__int16 v10; // ax
	unsigned int v11; // [esp+4h] [ebp-Ch]
	unsigned int v12; // [esp+8h] [ebp-8h]
	unsigned int v13; // [esp+Ch] [ebp-4h]

	v2 = 0x365F2 + 8 * *(unsigned __int8 *)(a1 + 72) + x_D41A0_BYTEARRAY_0 + 2;
	if (abs(*((signed __int16 *)v2 + 2) - *(signed __int16 *)(a1 + 76)) > 3072
		|| abs(*((signed __int16 *)v2 + 3) - *(signed __int16 *)(a1 + 78)) > 3072)
	{
		sub_1DDA0(a1, a2);
	}
	else
	{
		sub_1E1C0(a1, a2);
	}
	result = a2 + 7;
	if (*(unsigned __int8 *)(a1 + 69) == result && *(x_BYTE *)(a1 + 73) == 2)
	{
		if (*(x_BYTE *)(a1 + 57))
		{
			v4 = *(x_DWORD *)(a1 + 160);
			result = *(unsigned __int8 *)(a1 + 62) / *(signed __int16 *)(v4 + 26);
			if (!(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(v4 + 26)))
			{
				result = *(signed __int16 *)(v4 + 28) * *(signed __int16 *)(v4 + 28);
				v5 = 0;
				v12 = -1;
				v6 = x_D41A0_BYTEARRAY_4[0x9677];
				v11 = result;
				while (v6 > x_DWORD_EA3E4[0])
				{
					v7 = (signed __int16)(*(x_WORD *)(v6 + 76) - *(x_WORD *)(a1 + 76));
					v8 = *(x_WORD *)(v6 + 78) - *(x_WORD *)(a1 + 78);
					v13 = v8 * v8 + v7 * v7;
					result = v13;
					if (v13 <= v11 && !(*(x_BYTE *)(v6 + 12) & 0x20))
					{
						v9 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 30);
						v10 = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v6 + 76));
						result = (unsigned __int16)sub_582B0(*(x_WORD *)(a1 + 28), v10);
						if (result < v9)
						{
							result = v13;
							if (v13 < v12)
							{
								v5 = v6;
								v12 = v13;
							}
						}
					}
					v6 = *(x_DWORD *)v6;
				}
				if (v5)
				{
					*(x_WORD *)(a1 + 150) = (signed int)(v5 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
					*(x_BYTE *)(a1 + 73) = 10;
					result = sub_1E040(a1, a2);
				}
			}
		}
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0001DDA0) --------------------------------------------------------
char sub_1DDA0(int a1, __int16 a2)
{
	signed int v2; // eax
	__int16 v3; // ax
	int i; // edx
	int v5; // edx
	int v6; // ecx
	int v7; // eax
	char v8; // al
	char v9; // cl
	char v10; // al
	unsigned __int16 v11; // ax
	unsigned int j; // ecx
	__int16 v14; // [esp+0h] [ebp-Ch]
	__int16 v15; // [esp+2h] [ebp-Ah]
	char v16; // [esp+8h] [ebp-4h]

	v2 = 0;
	if (*(x_WORD *)(a1 + 98))
	{
		*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
		v3 = *(x_WORD *)(a1 + 98);
		*(x_WORD *)(a1 + 98) = 0;
		*(x_WORD *)(a1 + 38) = v3;
		v2 = 1;
	}
	else
	{
		*(x_WORD *)(a1 + 38) = 0;
	}
	if (*(x_WORD *)(a1 + 52) && *(x_BYTE *)(a1 + 64) != 27)
	{
		for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52))
		{
			v6 = x_DWORD_EA3E4[i];
			if (v6 == x_DWORD_EA3E4[0])
				break;
			v5 = *(x_DWORD *)(v6 + 8);
			if (v5 < *(x_DWORD *)(a1 + 8))
			{
				*(x_DWORD *)(a1 + 8) = v5;
				*(x_WORD *)(a1 + 38) = *(x_WORD *)(v6 + 38);
				v2 = 1;
				break;
			}
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 0)
	{
		*(x_WORD *)(a1 + 36) = *(x_WORD *)(a1 + 38);
		v2 = 2;
	}
	if ((unsigned int)v2 < 1)
	{
		if (!v2)
		{
			LOBYTE(v2) = sub_1B8C0(a1);
			if (!(*(x_BYTE *)(a1 + 62) & 7))
			{
				//v14 = *(x_WORD *)((char *)sub_365F8 + 8 * *(unsigned __int8 *)(a1 + 72) + x_D41A0_BYTEARRAY_0); //fix it
				v15 = *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 8 * *(unsigned __int8 *)(a1 + 72) + 222714);
				if (!(*(x_BYTE *)(a1 + 14) & 4))
				{
					*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)&v14);
					if (!(*(x_BYTE *)(a1 + 62) & 0x3F))
					{
						*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
						v11 = *(x_WORD *)(a1 + 20);
						*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
						*(x_WORD *)(a1 + 32) += ((*(x_WORD *)(a1 + 20) & 0xFF) + 85) * (2 * ((signed int)(v11 % 0x9Du) / 79) - 1);
						*(x_BYTE *)(a1 + 33) &= 7u;
					}
				}
				v2 = *(char *)(a1 + 64);
				v16 = 0;
				for (j = x_D41A0_BYTEARRAY_4[v2 + 38403]; j > x_DWORD_EA3E4[0]; j = *(x_DWORD *)j)
				{
					LOWORD(v2) = *(x_WORD *)(j + 26);
					if ((x_WORD)v2 != *(x_WORD *)(a1 + 26))
					{
						v2 = abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(j + 76));
						if (v2 < *(signed __int16 *)(a1 + 84))
						{
							v2 = abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(j + 78));
							if (v2 < *(signed __int16 *)(a1 + 84))
							{
								LOWORD(v2) = sub_581E0((Bit16u*)(j + 76), (Bit16u*)(a1 + 76));
								*(x_WORD *)(a1 + 32) = v2;
								v16 = 1;
								return v2;
							}
						}
					}
				}
			}
		}
	}
	else if ((unsigned int)v2 <= 1)
	{
		v7 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 38)];
		if (*(x_BYTE *)(v7 + 63) != *(x_BYTE *)(a1 + 63) || (v8 = *(x_BYTE *)(v7 + 64), v9 = *(x_BYTE *)(a1 + 64), v8 != v9))
			v10 = 1;
		else
			v10 = v9 ^ v8;
		if (v10)
		{
			*(x_WORD *)(a1 + 150) = *(x_WORD *)(a1 + 38);
			*(x_BYTE *)(a1 + 73) = 10;
			sub_1E040(a1, a2);
		}
		LOBYTE(v2) = sub_1EEE0(a1);
	}
	else if (v2 == 2)
	{
		LOBYTE(v2) = a2 + 4;
		*(x_BYTE *)(a1 + 69) = a2 + 4;
	}
	return v2;
}
// 365F8: using guessed type int sub_365F8();
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0001E000) --------------------------------------------------------
char sub_1E000(int a1, __int16 a2)
{
	return sub_1E1C0(a1, a2);
}

//----- (0001E020) --------------------------------------------------------
char sub_1E020(int a1, __int16 a2)
{
	return sub_1E1C0(a1, a2);
}

//----- (0001E040) --------------------------------------------------------
int sub_1E040(int a1, char a2)
{
	int result; // eax
	char v3; // bl

	result = *(x_DWORD *)(a1 + 160);
	if (*(x_BYTE *)(result + 32) & 8)
		v3 = a2 + 6;
	else
		v3 = a2 + 2;
	*(x_BYTE *)(a1 + 69) = v3;
	return result;
}

//----- (0001E1C0) --------------------------------------------------------
char sub_1E1C0(int a1, __int16 a2)
{
	unsigned int v2; // eax
	__int16 v3; // ax
	int i; // edx
	int v5; // ecx
	int v6; // edx
	int v7; // eax
	char v8; // al
	char v9; // cl
	char v10; // al

	v2 = 0;
	if (*(x_WORD *)(a1 + 98))
	{
		*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
		v3 = *(x_WORD *)(a1 + 98);
		*(x_WORD *)(a1 + 98) = 0;
		*(x_WORD *)(a1 + 38) = v3;
		v2 = 1;
	}
	else
	{
		*(x_WORD *)(a1 + 38) = 0;
	}
	if (*(x_WORD *)(a1 + 52) && *(x_BYTE *)(a1 + 64) != 27)
	{
		for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52))
		{
			v6 = x_DWORD_EA3E4[i];
			if (v6 == x_DWORD_EA3E4[0])
				break;
			v5 = *(x_DWORD *)(v6 + 8);
			if (v5 < *(x_DWORD *)(a1 + 8))
			{
				*(x_DWORD *)(a1 + 8) = v5;
				*(x_WORD *)(a1 + 38) = *(x_WORD *)(v6 + 38);
				v2 = 1;
				break;
			}
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 0)
	{
		*(x_WORD *)(a1 + 36) = *(x_WORD *)(a1 + 38);
		v2 = 2;
	}
	if (v2 < 1)
	{
		if (!v2)
		{
			v2 = *(x_DWORD *)(a1 + 160);
			if (!(*(x_BYTE *)(v2 + 32) & 2))
			{
				sub_1B8C0(a1);
				LOBYTE(v2) = *(x_BYTE *)(a1 + 62);
				if (!(v2 & 0xF) && !(*(x_BYTE *)(a1 + 14) & 4))
				{
					*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
					v2 = *(unsigned __int16 *)(a1 + 20) % 0x71u + 142 + *(unsigned __int16 *)(a1 + 32);
					*(x_WORD *)(a1 + 32) = v2;
					*(x_BYTE *)(a1 + 33) &= 7u;
				}
			}
		}
	}
	else if (v2 <= 1)
	{
		v7 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 38)];
		if (*(x_BYTE *)(v7 + 63) != *(x_BYTE *)(a1 + 63) || (v8 = *(x_BYTE *)(v7 + 64), v9 = *(x_BYTE *)(a1 + 64), v8 != v9))
			v10 = 1;
		else
			v10 = v9 ^ v8;
		if (v10)
		{
			*(x_WORD *)(a1 + 150) = *(x_WORD *)(a1 + 38);
			*(x_BYTE *)(a1 + 73) = 10;
			sub_1E040(a1, a2);
		}
		LOBYTE(v2) = sub_1EEE0(a1);
	}
	else if (v2 == 2)
	{
		LOBYTE(v2) = a2 + 4;
		*(x_BYTE *)(a1 + 69) = a2 + 4;
	}
	return v2;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0001E320) --------------------------------------------------------
void sub_1E320(int a1)
{
	unsigned int v1; // eax
	__int16 v2; // dx

	sub_1B8C0(a1);
	if (*(x_DWORD *)(a1 + 8) < 0)
	{
		sub_57F10(a1);
		return;
	}
	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
	if (v1 <= x_DWORD_EA3E4[0] || *(x_DWORD *)(v1 + 8) < 0 || *(x_BYTE *)(v1 + 13) & 4)
		goto LABEL_14;
	LOWORD(v1) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v1 + 76));
	v2 = *(x_WORD *)(a1 + 130);
	*(x_WORD *)(a1 + 32) = v1;
	v2 -= 8;
	*(x_WORD *)(a1 + 130) = v2;
	if (v2 <= 16)
	{
		LOBYTE(v1) = *(x_BYTE *)(a1 + 64);
		if ((unsigned __int8)v1 < 0x13u)
		{
			if (!(x_BYTE)v1)
				*(x_WORD *)(a1 + 130) = 30;
		}
		else if ((unsigned __int8)v1 <= 0x13u)
		{
			*(x_WORD *)(a1 + 130) = 76;
		}
		else if ((x_BYTE)v1 == 21)
		{
			*(x_WORD *)(a1 + 130) = 96;
		}
	LABEL_14:
		*(x_BYTE *)(a1 + 73) = 16;
	}
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0001E3E0) --------------------------------------------------------
int sub_1E3E0(int a1)
{
	unsigned int v1; // edi
	int v2; // ebx
	int v3; // edx
	unsigned int i; // eax
	unsigned int j; // esi
	//unsigned int v6; // eax
	unsigned int v8; // [esp+0h] [ebp-4h]

	v8 = -1;
	v1 = 0;
	v2 = 0;
	if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8 * *(unsigned __int8 *)(a1 + 72) + 222709) & 1)
	{
		HIWORD(v3) = HIWORD(x_D41A0_BYTEARRAY_4_struct.dwordindex_0);
		for (i = x_D41A0_BYTEARRAY_4[*(char *)(a1 + 64) + 38403]; i > x_DWORD_EA3E4[0] && !(x_WORD)v2; i = *(x_DWORD *)i)
		{
			if (*(x_BYTE *)(i + 72) == *(x_BYTE *)(a1 + 72))
			{
				LOWORD(v3) = *(x_WORD *)(i + 74);
				if ((x_WORD)v3)
					v2 = v3;
			}
		}
	}
	if (!(x_WORD)v2)
	{
		/*for ( j = *(x_DWORD *)(x_D41A0_BYTEARRAY_4_struct.dwordindex_0
							+ 4 * *(unsigned __int16 *)((char *)sub_365F8 + 8 * *(unsigned __int8 *)(a1 + 72) + x_D41A0_BYTEARRAY_0)
							+ 38403); j > x_DWORD_EA3E4[0]; j = *(x_DWORD *)j )
		{
		  v6 = sub_584D0((x_WORD *)(a1 + 76), (x_WORD *)(j + 76));
		  if ( v6 < v8 )
		  {
			v8 = v6;
			v1 = j;
		  }
		}*/ // fix it
		if (v1)
			v2 = (signed int)(v1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
	}
	return v2;
}
// 365F8: using guessed type int sub_365F8();
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0001E4D0) --------------------------------------------------------
int sub_1E4D0(int a1)
{
	unsigned int v1; // ebx
	unsigned __int8 v2; // al
	int v3; // edx
	int result; // eax

	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
	if (v1 <= x_DWORD_EA3E4[0] || *(x_DWORD *)(v1 + 8) < 0)
		sub_57F10(a1);
	x_WORD_EB398 = *(x_WORD *)(v1 + 76);
	v2 = *(x_BYTE *)(a1 + 64);
	x_WORD_EB39A = *(x_WORD *)(v1 + 78);
	v3 = *(signed __int16 *)(v1 + 80);
	if (v2 >= 0x10u)
	{
		if (v2 <= 0x10u)
		{
			v3 -= 896;
		}
		else if (v2 > 0x13u && v2 == 25)
		{
			v3 -= 512;
		}
	}
	if (v3 <= 0)
		LOWORD(v3) = 0;
	x_WORD_EB39C = v3;
	result = sub_57CF0(a1, (int)&x_WORD_EB398);
	*(x_WORD *)(a1 + 32) = *(x_WORD *)(v1 + 32);
	*(x_WORD *)(a1 + 28) = *(x_WORD *)(v1 + 28);
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39A: using guessed type __int16 x_WORD_EB39A;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (0001E580) --------------------------------------------------------
void sub_1E580(int a1, __int16 a2)
{
	unsigned int v2; // eax
	unsigned int v3; // esi
	unsigned int v4; // edi
	__int16 v5; // si
	char v6; // [esp+0h] [ebp-4h]

	v6 = 0;
	v2 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
	if (v2 <= x_DWORD_EA3E4[0] || *(x_DWORD *)(v2 + 8) < 0 || *(x_BYTE *)(v2 + 13) & 4)
	{
		*(x_WORD *)(a1 + 46) = 0;
	}
	else if (*(x_BYTE *)(a1 + 73) == 13)
	{
		--*(x_WORD *)(a1 + 46);
	}
	if (*(x_WORD *)(a1 + 46) <= 0)
	{
		v6 = 1;
	}
	else
	{
		v3 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
		if (v3 > x_DWORD_EA3E4[0] && (*(x_DWORD *)(v3 + 8) <= 0 || *(x_BYTE *)(v3 + 13) & 4))
		{
			*(x_WORD *)(a1 + 150) = 0;
			v3 = x_DWORD_EA3E4[0];
		}
		if (v3 <= x_DWORD_EA3E4[0] && !(*(x_BYTE *)(a1 + 62) & 7))
		{
			v3 = sub_16FC0(v2, v2);
			*(x_WORD *)(a1 + 150) = (signed int)(v3 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
		}
		if (v3 <= x_DWORD_EA3E4[0])
		{
			*(x_WORD *)(a1 + 150) = *(x_WORD *)(a1 + 40);
			sub_1E700(a1, a2);
			v5 = *(x_WORD *)(a1 + 46);
			*(x_WORD *)(a1 + 150) = 0;
			*(x_WORD *)(a1 + 46) = v5 - 4;
		}
		else
		{
			sub_1E700(a1, a2);
			if (!(*(x_BYTE *)(a1 + 62) & 7))
			{
				v4 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 28);
				if (sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(v3 + 76)) < v4)
					*(x_BYTE *)(a1 + 69) = a2 + 2;
			}
		}
	}
	if (v6)
	{
		if (*(x_BYTE *)(a1 + 73) == 13)
			sub_4A190(a1 + 76, 10, 73);
		sub_4A190(a1 + 76, 10, 0);
		sub_57F10(a1);
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0001E700) --------------------------------------------------------
void sub_1E700(int a1, char a2)
{
	unsigned int v2; // eax
	__int16 v3; // ax
	int i; // edx
	int v5; // edx
	int v6; // ecx
	int v7; // edx
	char v8; // al
	char v9; // al
	unsigned int v10; // eax
	__int16 v11; // ax
	char v12; // ch
	unsigned __int16 v13; // ax
	unsigned int j; // ecx

	v2 = 0;
	if (*(x_WORD *)(a1 + 98))
	{
		*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
		v3 = *(x_WORD *)(a1 + 98);
		*(x_WORD *)(a1 + 98) = 0;
		*(x_WORD *)(a1 + 38) = v3;
		v2 = 1;
	}
	else
	{
		*(x_WORD *)(a1 + 38) = 0;
	}
	if (*(x_WORD *)(a1 + 52) && *(x_BYTE *)(a1 + 64) != 27)
	{
		for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52))
		{
			v6 = x_DWORD_EA3E4[i];
			if (v6 == x_DWORD_EA3E4[0])
				break;
			v5 = *(x_DWORD *)(v6 + 8);
			if (v5 < *(x_DWORD *)(a1 + 8))
			{
				*(x_DWORD *)(a1 + 8) = v5;
				*(x_WORD *)(a1 + 38) = *(x_WORD *)(v6 + 38);
				v2 = 1;
				break;
			}
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 0)
	{
		*(x_WORD *)(a1 + 36) = *(x_WORD *)(a1 + 38);
		v2 = 2;
	}
	if (v2 < 1)
	{
		if (!v2)
		{
			sub_1B8C0(a1);
			if (!(*(x_BYTE *)(a1 + 62) & 7))
			{
				v10 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
				if (v10 > x_DWORD_EA3E4[0])
				{
					if (!(*(x_BYTE *)(a1 + 14) & 4))
					{
						v11 = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v10 + 76));
						v12 = *(x_BYTE *)(a1 + 62);
						*(x_WORD *)(a1 + 32) = v11;
						if (!(v12 & 0x3F))
						{
							*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
							v13 = *(x_WORD *)(a1 + 20);
							*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
							*(x_WORD *)(a1 + 32) += ((*(x_WORD *)(a1 + 20) & 0xFF) + 85) * (2 * ((signed int)(v13 % 0x9Du) / 79) - 1);
							*(x_BYTE *)(a1 + 33) &= 7u;
						}
					}
					for (j = x_D41A0_BYTEARRAY_4[0x9603 + 4 * *(char *)(a1 + 64)]; j > x_DWORD_EA3E4[0]; j = *(x_DWORD *)j)
					{
						if (*(x_WORD *)(j + 26) != *(x_WORD *)(a1 + 26)
							&& abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(j + 76)) < (signed int)*(signed __int16 *)(a1 + 84)
							&& abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(j + 78)) < (signed int)*(signed __int16 *)(a1 + 84))
						{
							*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(j + 76), (Bit16u*)(a1 + 76));
							return;
						}
					}
				}
			}
		}
	}
	else if (v2 <= 1)
	{
		sub_1B8C0(a1);
		v7 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 38)];
		v8 = 1;
		if (*(x_BYTE *)(v7 + 63) == *(x_BYTE *)(a1 + 63) && *(x_BYTE *)(v7 + 64) == *(x_BYTE *)(a1 + 64))
			v8 = 0;
		if (*(x_WORD *)(a1 + 40) == *(x_WORD *)(a1 + 38))
			v8 = 0;
		if (v8)
		{
			*(x_WORD *)(a1 + 150) = *(x_WORD *)(a1 + 38);
			if (*(x_BYTE *)(*(x_DWORD *)(a1 + 160) + 32) & 8)
				v9 = a2 + 6;
			else
				v9 = a2 + 2;
			*(x_BYTE *)(a1 + 69) = v9;
			sub_6D8B0(*(x_WORD *)(a1 + 40), 0x13u, 1);
		}
	}
	else if (v2 == 2)
	{
		*(x_WORD *)(a1 + 46) = 1;
	}
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0001E9C0) --------------------------------------------------------
void sub_1E9C0(int a1, __int16 a2)
{
	__int16 v2; // cx
	unsigned int v3; // esi
	char v4; // al
	int i; // eax
	char v6; // dl
	int v7; // eax
	unsigned __int16 v8; // di
	unsigned __int16 v9; // ax
	unsigned int v10; // esi
	unsigned int v11; // edi
	int v12; // esi
	int v13; // edx
	int j; // eax
	int v15; // eax
	signed __int16 v16; // [esp+0h] [ebp-4h]

	v2 = *(x_WORD *)(a1 + 46) - 1;
	v16 = 0;
	*(x_WORD *)(a1 + 46) = v2;
	if (v2 <= 0)
		goto LABEL_66;
	v3 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
	v4 = 0;
	if (v2 <= *(signed __int16 *)(a1 + 48) - 16 && *(x_WORD *)(a1 + 46) >= 16)
	{
		if ((*(x_BYTE *)(a1 + 62) & 0x1C) == 16)
			v4 = *(x_BYTE *)(a1 + 62) & 3;
	}
	else
	{
		v4 = *(x_BYTE *)(a1 + 62) & 1 ? 0 : 2;
	}
	switch (v4)
	{
	case 0:
		*(x_BYTE *)(a1 + 15) &= 0xF9u;
		break;
	case 1:
	case 3:
		*(x_BYTE *)(a1 + 15) = (*(x_BYTE *)(a1 + 15) | 2) & 0xFB;
		break;
	case 2:
		*(x_BYTE *)(a1 + 15) = *(x_BYTE *)(a1 + 15) & 0xF9 | 4;
		break;
	default:
		break;
	}
	if (*(x_WORD *)(a1 + 52))
	{
		for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v7 + 52))
		{
			v7 = x_DWORD_EA3E4[i];
			if (v7 == x_DWORD_EA3E4[0])
				break;
			v6 = 0;
			if (*(signed __int16 *)(a1 + 46) <= *(signed __int16 *)(a1 + 48) - 16 && *(x_WORD *)(a1 + 46) >= 16)
			{
				if ((*(x_BYTE *)(a1 + 62) & 0x1C) == 16)
					v6 = *(x_BYTE *)(a1 + 62) & 3;
			}
			else if (*(x_BYTE *)(a1 + 62) & 1)
			{
				v6 = 0;
			}
			else
			{
				v6 = 2;
			}
			switch (v6)
			{
			case 0:
				*(x_BYTE *)(v7 + 15) &= 0xF9u;
				break;
			case 1:
			case 3:
				*(x_BYTE *)(v7 + 15) = (*(x_BYTE *)(v7 + 15) | 2) & 0xFB;
				break;
			case 2:
				*(x_BYTE *)(v7 + 15) = *(x_BYTE *)(v7 + 15) & 0xF9 | 4;
				break;
			default:
				continue;
			}
		}
	}
	if (v3 <= x_DWORD_EA3E4[0] || *(x_DWORD *)(v3 + 8) <= 0)
	{
	LABEL_66:
		v16 = 1;
	}
	else
	{
		v8 = *(x_WORD *)(a1 + 150);
		*(x_WORD *)(a1 + 150) = *(x_WORD *)(a1 + 40);
		sub_1E700(a1, a2);
		v9 = *(x_WORD *)(v3 + 150);
		if (!v9 && *(x_WORD *)(v3 + 38))
			v9 = *(x_WORD *)(v3 + 38);
		if (v9 && v8 != v9)
			v8 = v9;
		*(x_WORD *)(a1 + 150) = v8;
		if (v8)
		{
			v10 = x_DWORD_EA3E4[v8];
			if (v10 > x_DWORD_EA3E4[0]
				&& (*(x_WORD *)(v10 + 40) == *(x_WORD *)(a1 + 40) && *(x_BYTE *)(v10 + 73) == 14
					|| *(x_DWORD *)(v10 + 8) <= 0
					|| *(x_BYTE *)(v10 + 13) & 4))
			{
				*(x_WORD *)(a1 + 150) = 0;
				v10 = x_DWORD_EA3E4[0];
			}
			if (v10 > x_DWORD_EA3E4[0])
			{
				v11 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 28);
				if (sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(v10 + 76)) < v11)
				{
					*(x_WORD *)(a1 + 150) = (signed int)(v10 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
					*(x_BYTE *)(a1 + 69) = a2 + 2;
					sub_6D8B0(*(x_WORD *)(a1 + 40), 0x18u, 1);
				}
			}
		}
	}
	if (v16)
	{
		*(x_BYTE *)(a1 + 73) = 10;
		*(x_WORD *)(a1 + 150) = 0;
		*(x_WORD *)(a1 + 40) = 0;
		v12 = *(signed __int16 *)(a1 + 46);
		v13 = *(signed __int16 *)(a1 + 48) - 16;
		*(x_BYTE *)(a1 + 72) = *(x_BYTE *)(a1 + 74);
		if (v12 <= v13)
			*(x_WORD *)(a1 + 46);
		switch (0)
		{
		case 0:
			*(x_BYTE *)(a1 + 15) &= 0xF9u;
			break;
		case 1:
		case 3:
			*(x_BYTE *)(a1 + 15) = (*(x_BYTE *)(a1 + 15) | 2) & 0xFB;
			break;
		case 2:
			*(x_BYTE *)(a1 + 15) = *(x_BYTE *)(a1 + 15) & 0xF9 | 4;
			break;
		default:
			break;
		}
		if (*(x_WORD *)(a1 + 52))
		{
			for (j = *(unsigned __int16 *)(a1 + 52); ; j = *(unsigned __int16 *)(v15 + 52))
			{
				v15 = x_DWORD_EA3E4[j];
				if (v15 == x_DWORD_EA3E4[0])
					break;
				if (*(signed __int16 *)(a1 + 46) <= *(signed __int16 *)(a1 + 48) - 16)
					*(x_WORD *)(a1 + 46);
				switch (0)
				{
				case 0:
					*(x_BYTE *)(v15 + 15) &= 0xF9u;
					break;
				case 1:
				case 3:
					*(x_BYTE *)(v15 + 15) = (*(x_BYTE *)(v15 + 15) | 2) & 0xFB;
					break;
				case 2:
					*(x_BYTE *)(v15 + 15) = *(x_BYTE *)(v15 + 15) & 0xF9 | 4;
					break;
				default:
					continue;
				}
			}
		}
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0001ED30) --------------------------------------------------------
int sub_1ED30(int a1, int a2)
{
	int v2; // ebx
	char v3; // dl
	int i; // edx
	char v5; // cl
	char v6; // cl
	int v7; // edx
	__int16 v8; // dx
	unsigned int v9; // eax
	unsigned __int16 v10; // ax

	v2 = a2;
	if (*(x_BYTE *)(a1 + 73) == 14)
	{
		v3 = 0;
		if (*(signed __int16 *)(a1 + 48) - 16 >= *(signed __int16 *)(a1 + 46) && *(x_WORD *)(a1 + 46) >= 16)
		{
			if ((*(x_BYTE *)(a1 + 62) & 0x1C) == 16)
				v3 = *(x_BYTE *)(a1 + 62) & 3;
		}
		else if (*(x_BYTE *)(a1 + 62) & 1)
		{
			v3 = 0;
		}
		else
		{
			v3 = 2;
		}
		switch (v3)
		{
		case 0:
			*(x_BYTE *)(a1 + 15) &= 0xF9u;
			break;
		case 1:
		case 3:
			*(x_BYTE *)(a1 + 15) = (*(x_BYTE *)(a1 + 15) | 2) & 0xFB;
			break;
		case 2:
			*(x_BYTE *)(a1 + 15) = *(x_BYTE *)(a1 + 15) & 0xF9 | 4;
			break;
		default:
			break;
		}
		if (*(x_WORD *)(a1 + 52))
		{
			for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v7 + 52))
			{
				v7 = x_DWORD_EA3E4[i];
				if (v7 == x_DWORD_EA3E4[0])
					break;
				v5 = 0;
				if (*(signed __int16 *)(a1 + 46) <= *(signed __int16 *)(a1 + 48) - 16 && *(x_WORD *)(a1 + 46) >= 16)
				{
					if ((*(x_BYTE *)(a1 + 62) & 0x1C) == 16)
						v5 = *(x_BYTE *)(a1 + 62) & 3;
				}
				else if (*(x_BYTE *)(a1 + 62) & 1)
				{
					v5 = 0;
				}
				else
				{
					v5 = 2;
				}
				switch (v5)
				{
				case 0:
					*(x_BYTE *)(v7 + 15) &= 0xF9u;
					break;
				case 1:
				case 3:
					v6 = (*(x_BYTE *)(v7 + 15) | 2) & 0xFB;
					goto LABEL_26;
				case 2:
					v6 = *(x_BYTE *)(v7 + 15) & 0xF9 | 4;
				LABEL_26:
					*(x_BYTE *)(v7 + 15) = v6;
					break;
				default:
					continue;
				}
			}
		}
		v8 = *(x_WORD *)(a1 + 46) - 1;
		*(x_WORD *)(a1 + 46) = v8;
		if (v8 <= 0)
			return x_DWORD_EA3E4[0];
		v9 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
		if (v9 > x_DWORD_EA3E4[0])
		{
			if (a2 == v9)
				return x_DWORD_EA3E4[0];
			if (*(x_WORD *)(v9 + 150))
			{
				v10 = *(x_WORD *)(v9 + 150);
			}
			else
			{
				if (!*(x_WORD *)(v9 + 38))
					return v2;
				v10 = *(x_WORD *)(v9 + 38);
			}
			if (x_DWORD_EA3E4[v10] != a2)
				return x_DWORD_EA3E4[0];
		}
	}
	return v2;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0001EEE0) --------------------------------------------------------
signed int sub_1EEE0(int a1)
{
	signed __int16 *v1; // eax
	__int16 v2; // ST10_2
	int v3; // ST0C_4
	int v4; // ST08_4
	__int16 v5; // ax

	v1 = *(signed __int16 **)(a1 + 160);
	v2 = v1[7];
	v3 = v1[5];
	v4 = v1[6];
	v5 = sub_10C40((__int16 *)(a1 + 76));
	return sub_580E0(a1 + 76, v5, v4, v3, v2);
}

//----- (0001EF20) --------------------------------------------------------
signed int sub_1EF20(int a1)
{
	return sub_1BD90(a1, 0);
}

//----- (0001EF40) --------------------------------------------------------
int sub_1EF40(int a1, x_WORD *a2)
{
	sub_1BF90((int)a2, 0);
	sub_1F0C0(a1, (int)a2);
	return sub_1F040(a2);
}

//----- (0001EF70) --------------------------------------------------------
int sub_1EF70(int a1, x_WORD *a2)
{
	if ((unsigned __int16)sub_1C310((int)a2, 0, (unsigned __int16(*)(int, int))sub_1CC20))
		sub_6E450((signed int)((char *)a2 - (char*)x_D41A0_BYTEARRAY_0 - 28302) / 168, -1, 8);
	sub_1F0C0(a1, (int)a2);
	return sub_1F040(a2);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0001EFD0) --------------------------------------------------------
int sub_1EFD0(int a1, x_WORD *a2)
{
	sub_1C560((int)a2, 0);
	sub_1F0C0(a1, (int)a2);
	return sub_1F040(a2);
}

//----- (0001F000) --------------------------------------------------------
int sub_1F000(int a1)
{
	return sub_1C890(a1, 0);
}

//----- (0001F020) --------------------------------------------------------
void sub_1F020(int a1)
{
	sub_1C930(a1);
}

//----- (0001F040) --------------------------------------------------------
int sub_1F040(x_WORD *a1)
{
	__int16 v1; // ax
	int result; // eax

	a1[40] += a1[8];
	v1 = sub_10C40(a1 + 38);
	*((x_DWORD *)a1 + 4) -= 5;
	result = v1 + 256;
	if ((signed __int16)a1[40] >= result)
	{
		if (x_BYTE_D41B6)
		{
			result = sub_10C60(a1 + 38);
			if ((signed __int16)a1[40] > (signed __int16)result - 256)
				*((x_DWORD *)a1 + 4) = -150;
		}
	}
	else
	{
		*((x_DWORD *)a1 + 4) = 150;
	}
	return result;
}
// D41B6: using guessed type char x_BYTE_D41B6;

//----- (0001F0C0) --------------------------------------------------------
void sub_1F0C0(int a1, int a2)
{
	char v2; // ah
	int v3; // edi
	int i; // eax
	int v5; // eax
	char v6; // cl
	unsigned int v7; // esi
	__int16 v8; // ax
	int v9; // [esp+0h] [ebp-14h]
	int v10; // [esp+4h] [ebp-10h]
	int v11; // [esp+8h] [ebp-Ch]
	int v12; // [esp+Ch] [ebp-8h]
	char v13; // [esp+10h] [ebp-4h]

	v2 = *(x_BYTE *)(a2 + 61);
	if (v2)
	{
		*(x_BYTE *)(a2 + 61) = v2 - 1;
		if (*(x_BYTE *)(a2 + 70))
		{
			if (*(x_WORD *)(a2 + 44))
			{
				v7 = x_DWORD_EA3E4[*(unsigned __int16 *)(a2 + 36)];
				if (v7 <= x_DWORD_EA3E4[0] || *(x_DWORD *)(v7 + 8) < 0 || *(x_BYTE *)(v7 + 13) & 4)
				{
					*(x_BYTE *)(a2 + 70) = 0;
					*(x_WORD *)(a2 + 36) = 0;
				}
				else
				{
					if (*(x_BYTE *)(a2 + 36) & 1)
						v8 = *(x_WORD *)(v7 + 28) + 512;
					else
						v8 = *(x_WORD *)(v7 + 28) - 512;
					*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a2 + 76);
					*(&x_WORD_EB398 + 2) = *(x_WORD *)(a2 + 80);
					sub_57FA0((x_WORD*)&x_WORD_EB398, v8 & 0x7FF, 0, 48 * *(x_WORD *)(a2 + 44));
					sub_57CF0(a2, (int)&x_WORD_EB398);
					--*(x_WORD *)(a2 + 44);
				}
			}
			else
			{
				*(x_BYTE *)(a2 + 70) = 0;
				*(x_WORD *)(a2 + 36) = 0;
			}
		}
		else
		{
			v11 = (*(unsigned __int16 *)(a2 + 76) + 128) >> 8;
			v12 = (*(unsigned __int16 *)(a2 + 78) + 128) >> 8;
			v3 = sub_10080(0, 4);
			if (v3)
			{
				v13 = 0;
			LABEL_11:
				while (!v13 && sub_10130(v3, &v10, &v9) == 1)
				{
					for (i = x_WORD_15B4E0[((unsigned __int8)(v9 + v12) << 8) + (unsigned __int8)(v10 + v11)];
						;
						i = *(unsigned __int16 *)(a1 + 22))
					{
						a1 = x_DWORD_EA3E4[i];
						if (a1 == x_DWORD_EA3E4[0])
							break;
						if (*(x_BYTE *)(a1 + 63) == 9 && *(unsigned __int16 *)(a1 + 150) == *(signed __int16 *)(a2 + 26))
						{
							v13 = 1;
							goto LABEL_11;
						}
					}
				}
				sub_10100(v3);
				if (v13)
				{
					v5 = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
					v6 = *(x_BYTE *)(a2 + 70);
					*(x_WORD *)(a2 + 44) = 5;
					*(x_BYTE *)(a2 + 70) = v6 + 1;
					*(x_WORD *)(a2 + 36) = v5;
				}
			}
		}
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;

//----- (0001F300) --------------------------------------------------------
int sub_1F300(int a1, int a2)
{
	int result; // eax

	sub_1D5D0(a2, 0);
	result = (unsigned __int8)(*(x_BYTE *)(a2 + 73) - 1);
	switch (*(x_BYTE *)(a2 + 73))
	{
	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
	case 6:
	case 7:
	case 8:
	case 9:
	case 0xA:
	case 0xD:
	case 0xE:
	case 0x10:
		sub_1F0C0(a1, a2);
		goto LABEL_3;
	case 0x11:
	LABEL_3:
		result = sub_1F040((x_WORD *)a2);
		break;
	default:
		return result;
	}
	return result;
}

//----- (0001F340) --------------------------------------------------------
void sub_1F340(int a1)
{
	sub_1BD90(a1, 8);
	*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
	if (!(*(unsigned __int16 *)(a1 + 20) % 0x4Du))
		sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 46);
	if (*(x_BYTE *)(a1 + 69) == 14)
		*(x_WORD *)(a1 + 130) = *(x_WORD *)(a1 + 132);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0001F3C0) --------------------------------------------------------
void sub_1F3C0(int a1)
{
	sub_1BF90(a1, 8);
	*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
	if (!(*(unsigned __int16 *)(a1 + 20) % 0x4Du))
		sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 46);
	if (*(x_BYTE *)(a1 + 69) == 14)
		*(x_WORD *)(a1 + 130) = *(x_WORD *)(a1 + 132);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0001F440) --------------------------------------------------------
void sub_1F440(int a1)
{
	*(x_BYTE *)(a1 + 69) = 14;
	*(x_WORD *)(a1 + 130) = *(x_WORD *)(a1 + 132);
	sub_1F530(a1);
}

//----- (0001F470) --------------------------------------------------------
void sub_1F470(int a1)
{
	sub_1C560(a1, 8u);
	*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
	if (!(*(unsigned __int16 *)(a1 + 20) % 0x4Du))
		sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 46);
	if (*(x_BYTE *)(a1 + 69) == 14)
		*(x_WORD *)(a1 + 130) = *(x_WORD *)(a1 + 132);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0001F4F0) --------------------------------------------------------
int sub_1F4F0(int a1)
{
	return sub_1C890(a1, 8);
}

//----- (0001F510) --------------------------------------------------------
void sub_1F510(int a1)
{
	sub_1C930(a1);
}

//----- (0001F530) --------------------------------------------------------
void sub_1F530(int a1)
{
	sub_1C980(a1, 8);
	if (*(x_BYTE *)(a1 + 69) != 14)
		*(x_WORD *)(a1 + 130) = *(x_WORD *)(a1 + 134);
	*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
	if (!(*(unsigned __int16 *)(a1 + 20) % 0x2Bu))
		sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 46);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0001F5B0) --------------------------------------------------------
__int16 sub_1F5B0(int a1)
{
	__int16 result; // ax

	sub_1D5D0(a1, 8);
	*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
	if (!(*(unsigned __int16 *)(a1 + 20) % 0x4Du))
		sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 46);
	if (*(x_BYTE *)(a1 + 69) == 14)
		result = *(x_WORD *)(a1 + 132);
	else
		result = *(x_WORD *)(a1 + 134);
	*(x_WORD *)(a1 + 130) = result;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0001F630) --------------------------------------------------------
signed int sub_1F630(int a1)
{
	signed int result; // eax

	result = sub_1BD90(a1, 16);
	BYTE1(result) = *(x_BYTE *)(a1 + 69);
	if (BYTE1(result) == 18)
		*(x_DWORD *)(a1 + 16) = 1;
	return result;
}

//----- (0001F660) --------------------------------------------------------
void sub_1F660(int a1)
{
	sub_1BF90(a1, 16);
	if (*(x_BYTE *)(a1 + 69) == 18)
	{
		*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
		sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, (*(x_WORD *)(a1 + 20) & 1) + 12);
		*(x_DWORD *)(a1 + 16) = 1;
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0001F6D0) --------------------------------------------------------
void sub_1F6D0(int a1)
{
	int v1; // edx
	int v2; // eax
	unsigned __int16 v3; // dx
	int v4; // eax

	v1 = *(x_DWORD *)(a1 + 16);
	if (v1)
	{
		v2 = *(x_DWORD *)(a1 + 16);
		*(x_DWORD *)(a1 + 16) = v1 - 1;
		if (v2 == 1)
			*(x_WORD *)(a1 + 130) = 5 * *(signed __int16 *)(a1 + 132) >> 1;
	}
	v3 = *(x_WORD *)(a1 + 150);
	if (v3)
	{
		v4 = *(signed __int16 *)(a1 + 80)
			- (*(signed __int16 *)(x_DWORD_EA3E4[v3] + 82)
				+ *(signed __int16 *)(x_DWORD_EA3E4[v3] + 80));
		if (*(signed __int16 *)(a1 + 80) != *(signed __int16 *)(x_DWORD_EA3E4[v3] + 82)
			+ *(signed __int16 *)(x_DWORD_EA3E4[v3] + 80))
		{
			if (v4 <= 0)
				LOWORD(v4) = -1;
			else
				LOWORD(v4) = 1;
		}
		*(x_WORD *)(a1 + 80) += v4 * *(x_WORD *)(*(x_DWORD *)(a1 + 160) + 14);
		if ((unsigned __int16)sub_1C310(a1, 16, (unsigned __int16(*)(int, int))sub_1CE80))
		{
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, (*(x_WORD *)(a1 + 20) & 1) + 12);
			*(x_WORD *)(a1 + 130) = -*(x_WORD *)(a1 + 134);
			*(x_DWORD *)(a1 + 16) = 3 * *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 26);
		}
	}
	else
	{
		*(x_BYTE *)(a1 + 69) = 17;
	}
	if (*(x_BYTE *)(a1 + 69) != 18)
		*(x_WORD *)(a1 + 130) = *(x_WORD *)(a1 + 132);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0001F800) --------------------------------------------------------
char sub_1F800(int a1)
{
	char result; // al

	result = sub_1C560(a1, 0x10u);
	if (*(x_BYTE *)(a1 + 69) == 18)
		*(x_DWORD *)(a1 + 16) = 1;
	return result;
}

//----- (0001F830) --------------------------------------------------------
int sub_1F830(int a1)
{
	return sub_1C890(a1, 16);
}

//----- (0001F850) --------------------------------------------------------
void sub_1F850(int a1)
{
	sub_1C930(a1);
}

//----- (0001F8A0) --------------------------------------------------------
void sub_1F8A0(int a1)
{
	int v1; // esi

	sub_1D5D0(a1, 16);
	if (!(*(x_BYTE *)(a1 + 62) & 7) && (unsigned __int8)(*(x_BYTE *)(a1 + 73) - 1) <= 8u)
	{
		*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
		v1 = 2 * ((signed int)(*(unsigned __int16 *)(a1 + 20) % 0x9Du) / 79);
		*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
		*(x_WORD *)(a1 + 32) += *(x_WORD *)(a1 + 20) % 0x55u * (v1 - 1);
		*(x_BYTE *)(a1 + 33) &= 7u;
	}
	if (*(x_BYTE *)(a1 + 69) == 18)
		*(x_DWORD *)(a1 + 16) = 1;
}

//----- (0001F950) --------------------------------------------------------
signed int sub_1F950(int a1)
{
	return sub_1BD90(a1, 24);
}

//----- (0001F970) --------------------------------------------------------
void sub_1F970(int a1)
{
	sub_1BF90(a1, 24);
}

//----- (0001F990) --------------------------------------------------------
void sub_1F990(int a1)
{
	if ((unsigned __int16)sub_1C310(a1, 24, (unsigned __int16(*)(int, int))sub_1CC20))
		sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 8);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0001F9E0) --------------------------------------------------------
char sub_1F9E0(int a1)
{
	return sub_1C560(a1, 0x18u);
}

//----- (0001FA00) --------------------------------------------------------
int sub_1FA00(int a1)
{
	return sub_1C890(a1, 24);
}

//----- (0001FA20) --------------------------------------------------------
void sub_1FA20(int a1)
{
	sub_1C930(a1);
}

//----- (0001FA50) --------------------------------------------------------
void sub_1FA50(int a1)
{
	sub_1D5D0(a1, 24);
}

//----- (0001FA70) --------------------------------------------------------
char sub_1FA70(int a1)
{
	char result; // al

	result = sub_1BD90(a1, 32);
	if (*(x_BYTE *)(a1 + 69) == 34)
		result = sub_20060(a1);
	return result;
}

//----- (0001FAA0) --------------------------------------------------------
char sub_1FAA0(int a1)
{
	__int16 v1; // cx
	unsigned int j; // eax
	__int16 v3; // ax
	int i; // edx
	int v5; // edi
	int v6; // edx
	unsigned __int16 v7; // ax
	int v8; // edi
	int v9; // ecx
	unsigned int v10; // esi
	unsigned int v11; // edi
	int v12; // eax
	signed int v13; // ST14_4
	__int16 v14; // ax
	unsigned int v15; // esi
	char v16; // dh
	int v17; // eax
	unsigned int v18; // esi
	unsigned int v19; // edi
	int v20; // edx
	unsigned int v21; // edx
	int v22; // eax
	unsigned int v23; // edi
	unsigned int k; // esi
	int v25; // eax
	signed int v26; // ST14_4
	__int16 v27; // ax
	int v28; // esi
	unsigned int v30; // [esp+0h] [ebp-28h]
	unsigned int v31; // [esp+4h] [ebp-24h]
	unsigned int v32; // [esp+8h] [ebp-20h]
	unsigned int v33; // [esp+14h] [ebp-14h]
	unsigned int v34; // [esp+18h] [ebp-10h]
	unsigned int v35; // [esp+1Ch] [ebp-Ch]
	unsigned int v36; // [esp+20h] [ebp-8h]

	v1 = *(x_WORD *)(a1 + 98);
	j = 0;
	*(x_DWORD *)(a1 + 16) = 0;
	if (v1)
	{
		*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
		v3 = *(x_WORD *)(a1 + 98);
		*(x_WORD *)(a1 + 98) = 0;
		*(x_WORD *)(a1 + 38) = v3;
		j = 1;
	}
	else
	{
		*(x_WORD *)(a1 + 38) = 0;
	}
	if (*(x_WORD *)(a1 + 52))
	{
		for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52))
		{
			v6 = x_DWORD_EA3E4[i];
			if (v6 == x_DWORD_EA3E4[0])
				break;
			v5 = *(x_DWORD *)(v6 + 8);
			if (v5 < *(x_DWORD *)(a1 + 8))
			{
				*(x_DWORD *)(a1 + 8) = v5;
				*(x_WORD *)(a1 + 38) = *(x_WORD *)(v6 + 38);
				j = 1;
				break;
			}
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 0)
	{
		*(x_WORD *)(a1 + 36) = *(x_WORD *)(a1 + 38);
		j = 2;
	}
	if (j >= 1)
	{
		if (j <= 1)
		{
			*(x_WORD *)(a1 + 150) = *(x_WORD *)(a1 + 38);
			*(x_BYTE *)(a1 + 69) = 34;
			LOBYTE(j) = sub_1EEE0(a1);
		}
		else if (j == 2)
		{
			LOBYTE(j) = 36;
			*(x_BYTE *)(a1 + 69) = 36;
		}
		goto LABEL_68;
	}
	if (!j)
	{
		sub_1B8C0(a1);
		LOWORD(j) = (signed __int16)*(unsigned __int8 *)(a1 + 62) / *(x_WORD *)(*(x_DWORD *)(a1 + 160) + 26);
		if (!(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 26)))
		{
			if (*(x_WORD *)(a1 + 150))
			{
				LOWORD(j) = *(x_WORD *)(a1 + 150);
				v28 = x_DWORD_EA3E4[(unsigned __int16)j];
				if (*(x_BYTE *)(v28 + 63) != 10 || *(x_BYTE *)(v28 + 64) != 45)
				{
					*(x_WORD *)(a1 + 150) = 0;
				}
				else if (sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(v28 + 76)) > 0x1000)
				{
					LOWORD(j) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v28 + 76));
					*(x_WORD *)(a1 + 32) = j;
				}
				else
				{
					*(x_DWORD *)(a1 + 16) = 1;
					LOBYTE(j) = 36;
					*(x_BYTE *)(a1 + 69) = 36;
					++*(x_DWORD *)(v28 + 16);
				}
				goto LABEL_68;
			}
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			v7 = *(x_WORD *)(a1 + 20);
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			*(x_WORD *)(a1 + 32) += ((*(x_WORD *)(a1 + 20) & 0xFF) + 85) * (2 * ((signed int)(v7 % 0x9Du) / 79) - 1);
			v8 = *(x_DWORD *)(a1 + 160);
			*(x_BYTE *)(a1 + 33) &= 7u;
			v9 = 4 * *(signed __int16 *)(v8 + 26);
			j = *(unsigned __int8 *)(a1 + 62) / v9;
			if (!(*(unsigned __int8 *)(a1 + 62) % v9))
			{
				j = *(signed __int16 *)(v8 + 28) * *(signed __int16 *)(v8 + 28);
				v32 = -1;
				v10 = x_D41A0_BYTEARRAY_4[0x9677];
				v11 = 0;
				v31 = j;
				while (v10 > x_DWORD_EA3E4[0])
				{
					v12 = (signed __int16)(*(x_WORD *)(v10 + 76) - *(x_WORD *)(a1 + 76));
					j = (signed __int16)(*(x_WORD *)(v10 + 78) - *(x_WORD *)(a1 + 78))
						* (signed __int16)(*(x_WORD *)(v10 + 78) - *(x_WORD *)(a1 + 78))
						+ v12 * v12;
					v35 = j;
					if (j <= v31 && !(*(x_BYTE *)(v10 + 12) & 0x20))
					{
						v13 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 30);
						v14 = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v10 + 76));
						j = (unsigned __int16)sub_582B0(*(x_WORD *)(a1 + 28), v14);
						if ((signed int)j < v13)
						{
							LOBYTE(j) = v35;
							if (v35 < v32)
							{
								v11 = v10;
								v32 = v35;
							}
						}
					}
					v10 = *(x_DWORD *)v10;
				}
				v15 = v11;
				if (v11)
				{
					if (v11 <= x_DWORD_EA3E4[0]
						|| (v16 = *(x_BYTE *)(v11 + 64)) != 0 && v16 != 1
						|| (j = *(x_DWORD *)(v11 + 164), !*(x_WORD *)(j + 584)))
					{
						v15 = 0;
					}
				}
				if (!v15)
				{
					v17 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 28);
					v33 = v17 * v17;
					v18 = -1;
					v19 = 0;
					for (j = x_D41A0_BYTEARRAY_4[38439]; j > x_DWORD_EA3E4[0]; j = *(x_DWORD *)j)
					{
						v20 = (signed __int16)(*(x_WORD *)(j + 76) - *(x_WORD *)(a1 + 76));
						v21 = v20 * v20
							+ (signed __int16)(*(x_WORD *)(j + 78) - *(x_WORD *)(a1 + 78))
							* (signed __int16)(*(x_WORD *)(j + 78) - *(x_WORD *)(a1 + 78));
						if (v21 <= v33 && v21 < v18)
						{
							v19 = j;
							v18 = v21;
						}
					}
					v15 = v19;
				}
				if (v15)
				{
					if (*(x_BYTE *)(v15 + 63) == 10 && *(x_BYTE *)(v15 + 64) == 45)
						goto LABEL_68;
					*(x_WORD *)(a1 + 150) = (signed int)(v15 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
					LOBYTE(j) = 34;
				LABEL_60:
					*(x_BYTE *)(a1 + 69) = j;
					goto LABEL_68;
				}
				v22 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 28);
				v23 = 0;
				v30 = v22 * v22;
				j = *(char *)(a1 + 64);
				v34 = -1;
				for (k = x_D41A0_BYTEARRAY_4[j + 38403]; k > x_DWORD_EA3E4[0]; k = *(x_DWORD *)k)
				{
					if (!*(x_WORD *)(k + 50) && k != a1)
					{
						v25 = (signed __int16)(*(x_WORD *)(k + 76) - *(x_WORD *)(a1 + 76));
						j = (signed __int16)(*(x_WORD *)(k + 78) - *(x_WORD *)(a1 + 78))
							* (signed __int16)(*(x_WORD *)(k + 78) - *(x_WORD *)(a1 + 78))
							+ v25 * v25;
						v36 = j;
						if (j <= v30)
						{
							v26 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 30);
							v27 = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(k + 76));
							j = (unsigned __int16)sub_582B0(*(x_WORD *)(a1 + 28), v27);
							if ((signed int)j < v26)
							{
								LOBYTE(j) = v36;
								if (v36 < v34)
								{
									v23 = k;
									v34 = v36;
								}
							}
						}
					}
				}
				if (v23)
				{
					*(x_WORD *)(a1 + 50) = (signed int)(v23 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
					LOBYTE(j) = 35;
					goto LABEL_60;
				}
			}
		}
	}
LABEL_68:
	if (*(x_BYTE *)(a1 + 69) == 34)
		LOBYTE(j) = sub_20060(a1);
	return j;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0001FF40) --------------------------------------------------------
unsigned int sub_1FF40(int a1)
{
	unsigned int result; // eax
	char v2; // cl

	sub_1C310(a1, 32, (unsigned __int16(*)(int, int))sub_1CCE0);
	if (*(x_BYTE *)(a1 + 69) != 34)
		return (unsigned int)sub_200F0(a1);
	result = *(unsigned __int8 *)(a1 + 62) / *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 26);
	if (!(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 26)))
	{
		result = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
		if (result > x_DWORD_EA3E4[0])
		{
			v2 = *(x_BYTE *)(result + 64);
			if (!v2 || v2 == 1)
			{
				result = *(x_DWORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)] + 164);
				*(x_WORD *)(result + 584) = 200;
			}
		}
	}
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0001FFE0) --------------------------------------------------------
void sub_1FFE0(int a1)
{
	//char result; // al

	sub_1C560(a1, 0x20u);
	if (*(x_BYTE *)(a1 + 69) == 34)
		sub_20060(a1);
	//return result;
}

//----- (00020010) --------------------------------------------------------
void sub_20010(int a1)
{
	//int result; // eax

	if (*(x_DWORD *)(a1 + 16))
		sub_57F10(a1);
	else
		sub_1C890(a1, 32);
	//return result;
}

//----- (00020040) --------------------------------------------------------
void sub_20040(int a1)
{
	sub_1C930(a1);
}

//----- (00020060) --------------------------------------------------------
char sub_20060(int a1)
{
	signed int v1; // edx
	char result; // al

	*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
	v1 = *(unsigned __int16 *)(a1 + 20) % 0x14u;
	*(x_WORD *)(a1 + 130) = 0;
	if (v1 <= 10)
		sub_49CD0((x_WORD *)a1, 206);
	else
		sub_49CD0((x_WORD *)a1, 1);
	sub_49EA0((x_WORD *)a1, 128, 256);
	*(x_BYTE *)(a1 + 65) = *(x_BYTE *)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)] + 63);
	result = *(x_BYTE *)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)] + 64);
	*(x_BYTE *)(a1 + 66) = result;
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000200F0) --------------------------------------------------------
x_WORD *sub_200F0(int a1)
{
	x_WORD *result; // eax

	*(x_WORD *)(a1 + 130) = *(x_WORD *)(a1 + 132);
	sub_49CD0((x_WORD *)a1, 0);
	result = sub_49EA0((x_WORD *)a1, 128, 256);
	*(x_BYTE *)(a1 + 65) = 3;
	*(x_BYTE *)(a1 + 66) = -1;
	return result;
}

//----- (00020140) --------------------------------------------------------
void sub_20140(int a1)
{
	*(x_DWORD *)(a1 + 16) = 0;
	sub_1D5D0(a1, 32);
	if (*(x_BYTE *)(a1 + 69) == 34)
		sub_20060(a1);
}

//----- (00020370) --------------------------------------------------------
int sub_20370(int a1)
{
	int result; // eax
	int v2; // edx

	result = *(x_DWORD *)(a1 + 16);
	v2 = result - 1;
	*(x_DWORD *)(a1 + 16) = result - 1;
	if (result)
	{
		if (v2 < 16)
		{
			result = v2 / 2;
			if (!(v2 % 2))
				result = sub_585A0(a1);
		}
	}
	else
	{
		sub_20F20(a1);
		*(x_BYTE *)(a1 + 69) = 73;
		*(x_DWORD *)(a1 + 16) = 400;
		*(x_BYTE *)(a1 + 70) = 0;
		result = sub_122A0(a1);
	}
	return result;
}

//----- (000203D0) --------------------------------------------------------
void sub_203D0(int a1)
{
	int v1; // edx
	char v2; // al
	unsigned int v3; // esi
	__int16 v4; // ax
	int i; // eax
	int v6; // edx
	int v7; // eax
	unsigned int v8; // edx
	int v9; // edi
	unsigned int j; // esi
	int v11; // eax
	unsigned int v12; // eax
	unsigned int v13; // ST18_4
	unsigned __int16 v14; // ax
	int v15; // eax
	int v16; // edi
	unsigned int v17; // esi
	int v18; // eax
	int v19; // edx
	int v20; // eax
	signed int v21; // ST18_4
	__int16 v22; // ax
	int v23; // edx
	int v24; // esi
	unsigned int v25; // edx
	unsigned int v26; // edi
	int v27; // esi
	unsigned int k; // eax
	int v29; // edx
	unsigned int v30; // edx
	unsigned int v31; // edi
	unsigned int l; // eax
	int v33; // edx
	unsigned int v34; // edx
	unsigned int v35; // edi
	unsigned int m; // eax
	int v37; // edx
	unsigned int v38; // edx
	int v39; // eax
	unsigned int v40; // [esp+0h] [ebp-24h]
	int v41; // [esp+4h] [ebp-20h]
	unsigned int v42; // [esp+8h] [ebp-1Ch]
	unsigned int v43; // [esp+10h] [ebp-14h]
	unsigned int v44; // [esp+14h] [ebp-10h]
	unsigned int v45; // [esp+18h] [ebp-Ch]
	unsigned int v46; // [esp+1Ch] [ebp-8h]

	v1 = *(x_DWORD *)(a1 + 16);
	if (v1 > 0)
	{
		*(x_DWORD *)(a1 + 16) = v1 - 1;
		if (v1 == 1)
			sub_20F60(a1);
	}
	v2 = *(x_BYTE *)(a1 + 70);
	if (v2)
	{
		if (v2 == 1)
			sub_20940(a1);
		goto LABEL_85;
	}
	if (*(x_BYTE *)(a1 + 57))
		*(x_DWORD *)(a1 + 16) = 400;
	v3 = 0;
	if (*(x_WORD *)(a1 + 98))
	{
		*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
		v4 = *(x_WORD *)(a1 + 98);
		*(x_WORD *)(a1 + 98) = 0;
		v3 = 1;
		*(x_WORD *)(a1 + 38) = v4;
	}
	else
	{
		*(x_WORD *)(a1 + 38) = 0;
	}
	if (*(x_WORD *)(a1 + 52))
	{
		for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v7 + 52))
		{
			v7 = x_DWORD_EA3E4[i];
			if (v7 == x_DWORD_EA3E4[0])
				break;
			v6 = *(x_DWORD *)(v7 + 8);
			if (v6 < *(x_DWORD *)(a1 + 8))
			{
				*(x_DWORD *)(a1 + 8) = v6;
				v3 = 1;
				*(x_WORD *)(a1 + 38) = *(x_WORD *)(v7 + 38);
				break;
			}
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 0)
	{
		v3 = 2;
		*(x_WORD *)(a1 + 36) = *(x_WORD *)(a1 + 38);
	}
	if (v3 >= 1)
	{
		if (v3 <= 1)
		{
			*(x_WORD *)(a1 + 150) = *(x_WORD *)(a1 + 38);
			*(x_BYTE *)(a1 + 69) = 74;
		}
		else if (v3 == 2)
		{
			*(x_BYTE *)(a1 + 69) = 76;
		}
		goto LABEL_85;
	}
	if (!v3)
	{
		sub_1B8C0(a1);
		if (!(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 26)))
		{
			v8 = -1;
			v9 = 0;
			for (j = x_D41A0_BYTEARRAY_4[0x9677]; j > x_DWORD_EA3E4[0]; j = *(x_DWORD *)j)
			{
				if (*(x_BYTE *)(j + 64) == 2 && *(x_WORD *)(j + 26) != *(x_WORD *)(a1 + 26))
				{
					v11 = (signed __int16)(*(x_WORD *)(j + 76) - *(x_WORD *)(a1 + 76));
					v12 = v11 * v11
						+ (signed __int16)(*(x_WORD *)(j + 78) - *(x_WORD *)(a1 + 78))
						* (signed __int16)(*(x_WORD *)(j + 78) - *(x_WORD *)(a1 + 78));
					if (v12 < v8)
					{
						v9 = j;
						v8 = v12;
					}
				}
			}
			v41 = v9;
			if (v9)
			{
				*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v9 + 76));
				v13 = *(signed __int16 *)(v9 + 84) + *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 28);
				if (sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(v9 + 76)) > v13)
				{
					v41 = 0;
				}
				else
				{
					*(x_WORD *)(a1 + 150) = (v9 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
					*(x_BYTE *)(a1 + 69) = 74;
				}
			}
			else
			{
				*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
				v14 = *(x_WORD *)(a1 + 20);
				*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
				*(x_WORD *)(a1 + 32) += ((*(x_WORD *)(a1 + 20) & 0xFF) + 85) * (2 * ((signed int)(v14 % 0x9Du) / 79) - 1);
				*(x_BYTE *)(a1 + 33) &= 7u;
			}
			if (!v41)
			{
				if (*(x_BYTE *)(a1 + 57))
				{
					v15 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 28);
					v16 = 0;
					v44 = -1;
					v17 = x_D41A0_BYTEARRAY_4[0x9677];
					v42 = v15 * v15;
					while (v17 > x_DWORD_EA3E4[0])
					{
						if (*(x_WORD *)(v17 + 26) != *(x_WORD *)(a1 + 26))
						{
							v18 = (signed __int16)(*(x_WORD *)(v17 + 76) - *(x_WORD *)(a1 + 76));
							v19 = v18 * v18;
							v20 = (signed __int16)(*(x_WORD *)(v17 + 78) - *(x_WORD *)(a1 + 78));
							v43 = v20 * v20 + v19;
							if (v43 <= v42 && !(*(x_BYTE *)(v17 + 12) & 0x20))
							{
								v21 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 30);
								v22 = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v17 + 76));
								if ((unsigned __int16)sub_582B0(*(x_WORD *)(a1 + 28), v22) < v21 && v43 < v44)
								{
									v16 = v17;
									v44 = v43;
								}
							}
						}
						v17 = *(x_DWORD *)v17;
					}
					v41 = v16;
					if (v16)
					{
						*(x_WORD *)(a1 + 150) = (v16 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
						*(x_BYTE *)(a1 + 69) = 74;
					}
				}
				v23 = v41;
				if (!v41)
				{
					LOBYTE(v23) = *(x_BYTE *)(a1 + 62);
					v24 = *(x_DWORD *)(a1 + 160);
					v25 = v23 / *(signed __int16 *)(v24 + 26) % 3;
					if (v25 < 1)
					{
						if (v25)
						{
						LABEL_79:
							if (v41)
							{
								if (sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(v41 + 76)) <= 0x600)
								{
									*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(v41 + 76);
									*(&x_WORD_EB398 + 2) = *(x_WORD *)(v41 + 80);
									sub_57F10(v41);
									v39 = sub_4A190((int)&x_WORD_EB398, 5, 9);
									if (v39)
									{
										if (*(x_BYTE *)(x_DWORD_EA3E4[*(signed __int16 *)(a1 + 26)] + 63) == 3)
											*(x_WORD *)(v39 + 26) = *(x_WORD *)(a1 + 26);
									}
								}
							}
							goto LABEL_85;
						}
						v45 = *(signed __int16 *)(v24 + 28) * *(signed __int16 *)(v24 + 28);
						v26 = -1;
						v27 = 0;
						for (k = x_D41A0_BYTEARRAY_4[38419]; k > x_DWORD_EA3E4[0]; k = *(x_DWORD *)k)
						{
							v29 = (signed __int16)(*(x_WORD *)(k + 76) - *(x_WORD *)(a1 + 76));
							v30 = v29 * v29
								+ (signed __int16)(*(x_WORD *)(k + 78) - *(x_WORD *)(a1 + 78))
								* (signed __int16)(*(x_WORD *)(k + 78) - *(x_WORD *)(a1 + 78));
							if (v30 <= v45 && v30 < v26)
							{
								v27 = k;
								v26 = v30;
							}
						}
					}
					else if (v25 <= 1)
					{
						v46 = *(signed __int16 *)(v24 + 28) * *(signed __int16 *)(v24 + 28);
						v31 = -1;
						v27 = 0;
						for (l = x_D41A0_BYTEARRAY_4[38451]; l > x_DWORD_EA3E4[0]; l = *(x_DWORD *)l)
						{
							v33 = (signed __int16)(*(x_WORD *)(l + 76) - *(x_WORD *)(a1 + 76));
							v34 = v33 * v33
								+ (signed __int16)(*(x_WORD *)(l + 78) - *(x_WORD *)(a1 + 78))
								* (signed __int16)(*(x_WORD *)(l + 78) - *(x_WORD *)(a1 + 78));
							if (v34 <= v46 && v34 < v31)
							{
								v27 = l;
								v31 = v34;
							}
						}
					}
					else
					{
						if (v25 != 2)
							goto LABEL_79;
						v40 = *(signed __int16 *)(v24 + 28) * *(signed __int16 *)(v24 + 28);
						v35 = -1;
						v27 = 0;
						for (m = x_D41A0_BYTEARRAY_4[38455]; m > x_DWORD_EA3E4[0]; m = *(x_DWORD *)m)
						{
							v37 = (signed __int16)(*(x_WORD *)(m + 76) - *(x_WORD *)(a1 + 76));
							v38 = v37 * v37
								+ (signed __int16)(*(x_WORD *)(m + 78) - *(x_WORD *)(a1 + 78))
								* (signed __int16)(*(x_WORD *)(m + 78) - *(x_WORD *)(a1 + 78));
							if (v38 <= v40 && v38 < v35)
							{
								v27 = m;
								v35 = v38;
							}
						}
					}
					v41 = v27;
					goto LABEL_79;
				}
			}
		}
	}
LABEL_85:
	if (*(x_BYTE *)(a1 + 69) == 74)
		sub_20EC0(a1);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;

//----- (00020940) --------------------------------------------------------
void sub_20940(int a1)
{
	signed int v1; // ecx
	__int16 v2; // ax
	int i; // eax
	int v4; // edx
	int v5; // eax
	__int16 v6; // ax
	int v7; // edx
	int v8; // esi
	unsigned int v9; // edx
	unsigned int v10; // edi
	unsigned int j; // ecx
	int v12; // eax
	unsigned int v13; // eax
	unsigned int v14; // edi
	unsigned int k; // ecx
	int v16; // eax
	unsigned int v17; // eax
	unsigned int v18; // edi
	unsigned int l; // ecx
	int v20; // eax
	unsigned int v21; // eax
	int v22; // eax
	int v23; // eax
	x_WORD *v24; // [esp+10h] [ebp-4h]

	v1 = 0;
	v24 = 0;
	if (*(x_WORD *)(a1 + 98))
	{
		*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
		v2 = *(x_WORD *)(a1 + 98);
		*(x_WORD *)(a1 + 98) = 0;
		v1 = 1;
		*(x_WORD *)(a1 + 38) = v2;
	}
	else
	{
		*(x_WORD *)(a1 + 38) = 0;
	}
	if (*(x_WORD *)(a1 + 52))
	{
		for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52))
		{
			v5 = x_DWORD_EA3E4[i];
			if (v5 == x_DWORD_EA3E4[0])
				break;
			v4 = *(x_DWORD *)(v5 + 8);
			if (v4 < *(x_DWORD *)(a1 + 8))
			{
				*(x_DWORD *)(a1 + 8) = v4;
				v1 = 1;
				*(x_WORD *)(a1 + 38) = *(x_WORD *)(v5 + 38);
				break;
			}
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 0)
	{
		v1 = 2;
		*(x_WORD *)(a1 + 36) = *(x_WORD *)(a1 + 38);
	}
	if ((unsigned int)v1 >= 1)
	{
		if ((unsigned int)v1 <= 1)
		{
			v6 = *(x_WORD *)(a1 + 38);
			*(x_BYTE *)(a1 + 69) = 74;
			*(x_WORD *)(a1 + 150) = v6;
		}
		else if (v1 == 2)
		{
			*(x_BYTE *)(a1 + 69) = 76;
		}
		return;
	}
	if (v1)
		return;
	v7 = *(x_DWORD *)(a1 + 16);
	if (v7 < 0)
	{
		*(x_DWORD *)(a1 + 16) = v7 + 1;
		if (v7 == -1)
			sub_20F80(a1);
		return;
	}
	if (*(x_BYTE *)(a1 + 57))
	{
		*(x_DWORD *)(a1 + 16) = -50;
		return;
	}
	LOBYTE(v1) = *(x_BYTE *)(a1 + 62);
	v8 = *(x_DWORD *)(a1 + 160);
	if (!(v1 % *(signed __int16 *)(v8 + 26)))
	{
		v9 = v1 / *(signed __int16 *)(v8 + 26) % 3;
		if (v9 < 1)
		{
			if (v9)
			{
			LABEL_50:
				if (v24)
				{
					v22 = (signed __int16)(v24[38] - *(x_WORD *)(a1 + 76));
					if (sub_7277A(
						(signed __int16)(v24[39] - *(x_WORD *)(a1 + 78)) * (signed __int16)(v24[39] - *(x_WORD *)(a1 + 78))
						+ v22 * v22
						+ (signed __int16)(v24[40] - *(x_WORD *)(a1 + 80)) * (signed __int16)(v24[40] - *(x_WORD *)(a1 + 80))) <= 0x600)
					{
						*(x_DWORD *)&x_WORD_EB398 = *((x_DWORD *)v24 + 19);
						*(&x_WORD_EB398 + 2) = v24[40];
						sub_57F10((int)v24);
						v23 = sub_4A190((int)&x_WORD_EB398, 5, 9);
						if (v23)
							*(x_WORD *)(v23 + 26) = *(x_WORD *)(a1 + 26);
					}
				}
				return;
			}
			v10 = -1;
			for (j = x_D41A0_BYTEARRAY_4[38419]; j > x_DWORD_EA3E4[0]; j = *(x_DWORD *)j)
			{
				v12 = (signed __int16)(*(x_WORD *)(j + 76) - *(x_WORD *)(a1 + 76));
				v13 = v12 * v12
					+ (signed __int16)(*(x_WORD *)(j + 78) - *(x_WORD *)(a1 + 78))
					* (signed __int16)(*(x_WORD *)(j + 78) - *(x_WORD *)(a1 + 78));
				if (v13 <= *(signed __int16 *)(v8 + 28) * *(signed __int16 *)(v8 + 28) && v13 < v10)
				{
					v9 = j;
					v10 = v13;
				}
			}
		}
		else if (v9 <= 1)
		{
			v14 = -1;
			v9 = 0;
			for (k = x_D41A0_BYTEARRAY_4[38451]; k > x_DWORD_EA3E4[0]; k = *(x_DWORD *)k)
			{
				v16 = (signed __int16)(*(x_WORD *)(k + 76) - *(x_WORD *)(a1 + 76));
				v17 = v16 * v16
					+ (signed __int16)(*(x_WORD *)(k + 78) - *(x_WORD *)(a1 + 78))
					* (signed __int16)(*(x_WORD *)(k + 78) - *(x_WORD *)(a1 + 78));
				if (v17 <= *(signed __int16 *)(v8 + 28) * *(signed __int16 *)(v8 + 28) && v17 < v14)
				{
					v9 = k;
					v14 = v17;
				}
			}
		}
		else
		{
			if (v9 != 2)
				goto LABEL_50;
			v18 = -1;
			v9 = 0;
			for (l = x_D41A0_BYTEARRAY_4[38455]; l > x_DWORD_EA3E4[0]; l = *(x_DWORD *)l)
			{
				v20 = (signed __int16)(*(x_WORD *)(l + 76) - *(x_WORD *)(a1 + 76));
				v21 = v20 * v20
					+ (signed __int16)(*(x_WORD *)(l + 78) - *(x_WORD *)(a1 + 78))
					* (signed __int16)(*(x_WORD *)(l + 78) - *(x_WORD *)(a1 + 78));
				if (v21 <= *(signed __int16 *)(v8 + 28) * *(signed __int16 *)(v8 + 28) && v21 < v18)
				{
					v9 = l;
					v18 = v21;
				}
			}
		}
		v24 = (x_WORD *)v9;
		goto LABEL_50;
	}
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;

//----- (00020C50) --------------------------------------------------------
void sub_20C50(int a1)
{
	unsigned int v1; // esi
	__int16 v2; // ax
	int i; // eax
	int v4; // eax
	int v5; // ecx
	unsigned int v6; // eax
	unsigned int v7; // esi
	int v8; // edi
	unsigned int v9; // edi

	v1 = 0;
	if (*(x_WORD *)(a1 + 98))
	{
		*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
		v2 = *(x_WORD *)(a1 + 98);
		*(x_WORD *)(a1 + 98) = 0;
		v1 = 1;
		*(x_WORD *)(a1 + 38) = v2;
	}
	else
	{
		*(x_WORD *)(a1 + 38) = 0;
	}
	if (*(x_WORD *)(a1 + 52))
	{
		for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52))
		{
			v5 = x_DWORD_EA3E4[i];
			if (v5 == x_DWORD_EA3E4[0])
				break;
			v4 = *(x_DWORD *)(v5 + 8);
			if (v4 < *(x_DWORD *)(a1 + 8))
			{
				*(x_DWORD *)(a1 + 8) = v4;
				v1 = 1;
				*(x_WORD *)(a1 + 38) = *(x_WORD *)(v5 + 38);
				break;
			}
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 0)
	{
		v1 = 2;
		*(x_WORD *)(a1 + 36) = *(x_WORD *)(a1 + 38);
	}
	if (v1 >= 1)
	{
		if (v1 <= 1)
		{
			*(x_WORD *)(a1 + 150) = *(x_WORD *)(a1 + 38);
		}
		else if (v1 == 2)
		{
			*(x_BYTE *)(a1 + 69) = 76;
		}
		goto LABEL_32;
	}
	if (v1)
		goto LABEL_32;
	sub_1B8C0(a1);
	v6 = sub_1ED30(a1, x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)]);
	v7 = v6;
	if (v6 <= x_DWORD_EA3E4[0] || *(x_DWORD *)(v6 + 8) < 0 || *(x_BYTE *)(v6 + 13) & 4)
	{
	LABEL_31:
		*(x_BYTE *)(a1 + 69) = 73;
		goto LABEL_32;
	}
	if (!(*(unsigned __int8 *)(a1 + 62) % 10))
		*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v6 + 76));
	v8 = *(x_DWORD *)(a1 + 160);
	if (!(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(v8 + 26)))
	{
		v9 = *(signed __int16 *)(v8 + 28);
		if (*(x_BYTE *)(v7 + 63) == 3 && *(x_BYTE *)(v7 + 64) == 2)
			v9 += *(signed __int16 *)(v7 + 84);
		if (sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(v7 + 76)) < v9)
		{
			sub_1CDA0((x_WORD *)a1, v7);
			goto LABEL_32;
		}
		goto LABEL_31;
	}
LABEL_32:
	if (*(x_BYTE *)(a1 + 69) != 74)
		sub_20F20(a1);
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00020E50) --------------------------------------------------------
char sub_20E50(int a1)
{
	char result; // al

	result = sub_1C560(a1, 0x48u);
	if (*(x_BYTE *)(a1 + 69) == 74)
		result = sub_20EC0(a1);
	return result;
}

//----- (00020E80) --------------------------------------------------------
int sub_20E80(int a1)
{
	return sub_1C890(a1, 72);
}

//----- (00020EA0) --------------------------------------------------------
void sub_20EA0(int a1)
{
	sub_1C930(a1);
}

//----- (00020EC0) --------------------------------------------------------
char sub_20EC0(int a1)
{
	int v1; // esi
	char result; // al

	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
	if (*(x_WORD *)(a1 + 26) == *(x_WORD *)(v1 + 26))
	{
		*(x_BYTE *)(a1 + 69) = 73;
	}
	else
	{
		*(x_WORD *)(a1 + 130) = 0;
		sub_49CD0((x_WORD *)a1, 202);
		*(x_BYTE *)(a1 + 65) = *(x_BYTE *)(v1 + 63);
		result = *(x_BYTE *)(v1 + 64);
		*(x_BYTE *)(a1 + 66) = result;
	}
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00020F20) --------------------------------------------------------
int sub_20F20(int a1)
{
	int result; // eax

	*(x_WORD *)(a1 + 130) = *(x_WORD *)(a1 + 132);
	result = sub_49CD0((x_WORD *)a1, 201);
	*(x_BYTE *)(a1 + 65) = 3;
	*(x_BYTE *)(a1 + 66) = -1;
	*(x_DWORD *)(a1 + 16) = 50;
	*(x_BYTE *)(a1 + 70) = 0;
	return result;
}

//----- (00020F60) --------------------------------------------------------
int sub_20F60(int a1)
{
	int result; // eax

	result = sub_49CD0((x_WORD *)a1, 201);
	*(x_BYTE *)(a1 + 70) = 1;
	return result;
}

//----- (00020F80) --------------------------------------------------------
int sub_20F80(int a1)
{
	*(x_BYTE *)(a1 + 70) = 0;
	*(x_DWORD *)(a1 + 16) = 400;
	return sub_49CD0((x_WORD *)a1, 201);
}

//----- (00020FC0) --------------------------------------------------------
void sub_20FC0(int a1)
{
	sub_1D5D0(a1, 72);
	if (*(x_BYTE *)(a1 + 69) == 74)
		sub_20EC0(a1);
}

//----- (00021030) --------------------------------------------------------
__int16 sub_21030(int a1)
{
	int v1; // esi
	unsigned __int8 v2; // al
	int v3; // eax
	char v4; // dh
	int v5; // edx
	int v6; // ecx
	int v7; // edi
	int v8; // eax
	int v9; // edi
	int v10; // edx
	int v11; // esi
	int v12; // eax
	int v13; // eax
	__int16 v14; // dx
	int v15; // ecx
	int v16; // edi
	char v17; // ah
	unsigned int i; // eax
	char v19; // dl
	int v20; // ecx
	int v21; // eax
	__int16 v22; // dx
	char v24; // [esp+0h] [ebp-4h]

	v24 = 0;
	sub_223E0();
	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240)];
	if (sub_21F60(a1))
		*(x_BYTE *)(a1 + 42) |= 1u;
	v2 = *(x_BYTE *)(a1 + 70);
	if (v2 > 1u && (v2 < 0xCu || v2 > 0xFu) && *(x_DWORD *)(a1 + 8) >= 10)
		sub_22190(a1);
	switch (*(x_BYTE *)(a1 + 70))
	{
	case 0:
		v3 = (int)x_D41A0_BYTEARRAY_0;
		*(x_WORD *)(0x36546 + x_D41A0_BYTEARRAY_0 + 2) = 1;
		*(x_BYTE *)(a1 + 70) = 1;
		*(x_WORD *)(a1 + 42) = 8;
		*(x_DWORD *)(a1 + 16) = 15;
		LOWORD(v3) = *(x_WORD *)(2124 * *(signed __int16 *)(v3 + 12) + v3 + 11240);
		*(x_WORD *)(a1 + 44) = 22;
		*(x_WORD *)(a1 + 150) = v3;
		x_WORD_DA7CA = 60;
		sub_22490((unsigned __int16 *)a1);
		goto LABEL_10;
	case 1:
	LABEL_10:
		if (sub_21490(a1))
		{
			v4 = *(x_BYTE *)(a1 + 42);
			*(x_BYTE *)(a1 + 70) = 4;
			*(x_BYTE *)(a1 + 42) = v4 | 0x80;
		}
		goto LABEL_48;
	case 2:
		v5 = 26 * *(x_DWORD *)(a1 + 8);
		*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
		v6 = *(x_DWORD *)(a1 + 4);
		v7 = *(x_WORD *)(a1 + 20) & 7;
		*(x_BYTE *)(a1 + 70) = 3;
		v8 = v5 / v6 - v7;
		*(x_DWORD *)(a1 + 16) = v8;
		if (v8 < 3)
			*(x_DWORD *)(a1 + 16) = 3;
		if (*(x_DWORD *)(a1 + 16) > 26)
			*(x_DWORD *)(a1 + 16) = 26;
		*(x_BYTE *)(a1 + 68) = 0;
		*(x_WORD *)(a1 + 44) = 22;
		sub_221F0(a1, 341);
		goto LABEL_17;
	case 3:
	LABEL_17:
		if (*(x_DWORD *)(a1 + 8) < 10)
		{
			*(x_BYTE *)(a1 + 70) = 12;
			goto LABEL_48;
		}
		if (*(x_BYTE *)(a1 + 42) & 1)
			goto LABEL_26;
		--*(x_DWORD *)(a1 + 16);
		if ((signed int)sub_58490((x_WORD *)(v1 + 76), (x_WORD *)(a1 + 76)) < 0x2000 && *(x_DWORD *)(a1 + 16) <= 0)
		{
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			if ((signed int)(*(unsigned __int16 *)(a1 + 20) % 0xCu) < 9)
			{
				*(x_BYTE *)(a1 + 70) = 4;
				goto LABEL_48;
			}
		LABEL_26:
			*(x_BYTE *)(a1 + 70) = 6;
		}
	LABEL_48:
		if (v24 && !(*(x_BYTE *)(a1 + 62) & 3))
			sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 63);
		return sub_22270(a1);
	case 4:
		*(x_BYTE *)(a1 + 70) = 5;
		*(x_DWORD *)(a1 + 16) = 6;
		*(x_BYTE *)(a1 + 68) = 2;
		*(x_WORD *)(a1 + 44) = 113;
		goto LABEL_25;
	case 5:
	LABEL_25:
		v9 = *(x_DWORD *)(a1 + 16) - 1;
		*(x_DWORD *)(a1 + 16) = v9;
		if (v9 <= 0)
			goto LABEL_26;
		goto LABEL_48;
	case 6:
		*(x_BYTE *)(a1 + 70) = 7;
		*(x_DWORD *)(a1 + 16) = 16;
		*(x_BYTE *)(a1 + 68) = 0;
		*(x_WORD *)(a1 + 44) = 113;
		sub_221F0(a1, 343);
		goto LABEL_28;
	case 7:
	LABEL_28:
		v10 = *(x_DWORD *)(a1 + 16) - 1;
		*(x_DWORD *)(a1 + 16) = v10;
		if (v10 <= 0)
			*(x_BYTE *)(a1 + 70) = 8;
		goto LABEL_48;
	case 8:
		*(x_BYTE *)(a1 + 70) = 9;
		*(x_DWORD *)(a1 + 16) = 0;
		*(x_BYTE *)(a1 + 68) = 3;
		*(x_WORD *)(a1 + 44) = 22;
		sub_221F0(a1, 342);
		sub_21850(a1);
		goto LABEL_31;
	case 9:
	LABEL_31:
		sub_21AB0(a1);
		v11 = *(x_DWORD *)(a1 + 16) - 1;
		*(x_DWORD *)(a1 + 16) = v11;
		if (v11 <= 0)
			*(x_BYTE *)(a1 + 70) = 10;
		goto LABEL_48;
	case 0xA:
		*(x_BYTE *)(a1 + 70) = 11;
		*(x_DWORD *)(a1 + 16) = 16;
		*(x_WORD *)(a1 + 44) = 22;
		sub_221F0(a1, 344);
		goto LABEL_34;
	case 0xB:
	LABEL_34:
		v12 = *(x_DWORD *)(a1 + 16) - 1;
		*(x_DWORD *)(a1 + 16) = v12;
		if (v12 <= 0)
			*(x_BYTE *)(a1 + 70) = 2;
		goto LABEL_48;
	case 0xC:
		*(x_BYTE *)(a1 + 70) = 13;
		*(x_DWORD *)(a1 + 16) = 32;
		v13 = sub_4A190(a1 + 76, 10, 17);
		if (v13)
		{
			v14 = *(x_WORD *)(v1 + 26);
			*(x_WORD *)(v13 + 80) = 0;
			*(x_DWORD *)(v13 + 4) = 70;
			*(x_WORD *)(v13 + 26) = v14;
			*(x_DWORD *)(v13 + 8) = *(x_DWORD *)(v13 + 4);
		}
		goto LABEL_38;
	case 0xD:
	LABEL_38:
		v24 = 1;
		v15 = *(x_DWORD *)(a1 + 16) - 1;
		*(x_DWORD *)(a1 + 16) = v15;
		if (v15 <= 0)
		{
			*(x_BYTE *)(a1 + 70) = 14;
			*(x_DWORD *)(a1 + 16) = 32;
			sub_221F0(a1, 345);
		}
		goto LABEL_48;
	case 0xE:
		v24 = 1;
		sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 10);
		v16 = *(x_DWORD *)(a1 + 16) - 1;
		*(x_DWORD *)(a1 + 16) = v16;
		if (v16 <= 0)
		{
			*(x_BYTE *)(a1 + 70) = 15;
			*(x_DWORD *)(a1 + 16) = 60;
			v17 = *(x_BYTE *)(a1 + 12);
			*(x_DWORD *)(a1 + 8) = -1;
			*(x_BYTE *)(a1 + 12) = v17 | 1;
			sub_1B5F0();
			for (i = x_D41A0_BYTEARRAY_4[0x967B]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
			{
				v19 = *(x_BYTE *)(i + 13);
				*(x_DWORD *)(i + 4) = 140;
				*(x_BYTE *)(i + 13) = v19 | 0x20;
				*(x_DWORD *)(i + 8) = *(x_DWORD *)(i + 4);
			}
		}
		goto LABEL_48;
	case 0xF:
		sub_1B5F0();
		v20 = *(x_DWORD *)(a1 + 16) - 1;
		v24 = 1;
		*(x_DWORD *)(a1 + 16) = v20;
		if (v20 <= 0)
		{
			v21 = sub_4A190(a1 + 76, 10, 9);
			if (v21)
			{
				v22 = *(x_WORD *)(v1 + 26);
				*(x_DWORD *)(v21 + 8) = 32;
				*(x_DWORD *)(v21 + 4) = 11;
				*(x_WORD *)(v21 + 26) = v22;
				*(0x36E03 + x_D41A0_BYTEARRAY_0) = 1;
			}
			*(x_WORD *)(0x36546 + x_D41A0_BYTEARRAY_0 + 2) = 0;
			sub_57F10(a1);
		}
		goto LABEL_48;
	default:
		goto LABEL_48;
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// DA7CA: using guessed type __int16 x_WORD_DA7CA;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00021490) --------------------------------------------------------
char sub_21490(int a1)
{
	char v1; // cl
	int v2; // edx
	int v3; // esi
	int v4; // esi
	unsigned __int16 v5; // ax
	char v6; // ah
	unsigned int v7; // esi
	char v8; // dh
	char v9; // al
	char v10; // dl
	char v11; // cl
	int v12; // edx
	char v13; // ah
	unsigned int i; // esi
	int v15; // eax
	int v16; // eax
	int v18; // [esp+0h] [ebp-30h]
	__int16 v19; // [esp+4h] [ebp-2Ch]
	int v20; // [esp+8h] [ebp-28h]
	int v21; // [esp+Ch] [ebp-24h]
	int v22; // [esp+10h] [ebp-20h]
	int v23; // [esp+14h] [ebp-1Ch]
	int v24; // [esp+18h] [ebp-18h]
	int v25; // [esp+1Ch] [ebp-14h]
	char v26; // [esp+20h] [ebp-10h]
	char v27; // [esp+24h] [ebp-Ch]
	char v28; // [esp+28h] [ebp-8h]
	unsigned __int8 v29; // [esp+2Ch] [ebp-4h]

	v1 = *(x_BYTE *)(a1 + 42);
	v27 = 1;
	v29 = 0;
	v26 = 0;
	if (v1 & 8)
	{
		v25 = (*(signed __int16 *)(a1 + 76) + 128) >> 8;
		v2 = *(x_DWORD *)(a1 + 16);
		v22 = (*(signed __int16 *)(a1 + 78) + 128) >> 8;
		if (v2 < 0)
		{
			v28 = 1;
			v4 = sub_10080(0, 7);
			if (v4)
			{
				while (sub_10130(v4, &v21, &v20) == 1 && v28)
				{
					LOBYTE(v5) = v21 + v25;
					HIBYTE(v5) = v20 + v22;
					if (x_BYTE_10B4E0[v5])
						v28 = 0;
				}
				sub_10100(v4);
			}
			if (v28)
			{
				v6 = *(x_BYTE *)(a1 + 42) | 4;
				*(x_DWORD *)(a1 + 16) = 70;
				*(x_BYTE *)(a1 + 42) = v6 & 0xF7;
			}
			else
			{
				*(x_DWORD *)(a1 + 16) = 15;
			}
		}
		else
		{
			sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 10);
			v3 = sub_10080(0, 15 - *(x_DWORD *)(a1 + 16));
			if (v3)
			{
				while (sub_10130(v3, &v21, &v20) == 1)
					sub_56F10(v21 + v25, v20 + v22, -1, 0);
				sub_10100(v3);
			}
			--*(x_DWORD *)(a1 + 16);
		}
	}
	else if (v1 & 4)
	{
		sub_1B5F0();
		v7 = *(x_DWORD *)(a1 + 16);
		*(x_DWORD *)(a1 + 16) = v7 - 1;
		if (v7 < 0x11)
		{
			if (v7)
			{
				if (v7 == 1)
					v29 = 3;
			}
			else
			{
				*(x_BYTE *)(a1 + 42) = (*(x_BYTE *)(a1 + 42) | 0x10) & 0xFB;
				v8 = *(x_BYTE *)(a1 + 12);
				*(x_DWORD *)(a1 + 16) = 1;
				*(x_BYTE *)(a1 + 12) = v8 & 0xFE;
			}
		}
		else if (v7 <= 0x11)
		{
			v29 = 2;
		}
		else if (v7 >= 0x23)
		{
			if (v7 <= 0x23)
			{
				v29 = 1;
			}
			else if (v7 == 70)
			{
				*(0x36DFC + x_D41A0_BYTEARRAY_0 + 4) = 0;
			}
		}
	}
	else if (v1 & 0x10)
	{
		if (*(x_DWORD *)(a1 + 16) == 1)
		{
			v11 = *(x_BYTE *)(a1 + 42);
			*(x_DWORD *)(a1 + 16) = 0;
			*(x_BYTE *)(a1 + 42) = v11 & 0xBF;
		}
		else if (v1 & 0x40)
		{
			if (sub_58490(
				(x_WORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12
					+ x_D41A0_BYTEARRAY_0
					+ 11240)]
					+ 76),
					(x_WORD *)(a1 + 76)) >= 0xA00)
			{
				*(x_BYTE *)(a1 + 42) &= 0xBFu;
			}
			else
			{
				v9 = *(x_BYTE *)(a1 + 42);
				v10 = *(x_BYTE *)(a1 + 14);
				*(x_DWORD *)(a1 + 16) = 30;
				v9 |= 0x20u;
				*(x_BYTE *)(a1 + 42) = v9;
				*(x_BYTE *)(a1 + 14) = v10 & 0x7F;
				*(x_BYTE *)(a1 + 42) = v9 & 0xEF;
			}
		}
	}
	else if (v1 & 0x20)
	{
		if (*(x_DWORD *)(a1 + 16) >= 600)
			v27 = 0;
		v12 = *(x_DWORD *)(a1 + 16) + 30;
		*(x_DWORD *)(a1 + 16) = v12;
		if (v12 >= 1200)
		{
			v13 = *(x_BYTE *)(a1 + 42);
			*(x_DWORD *)(a1 + 16) = 1200;
			*(x_BYTE *)(a1 + 42) = v13 & 0xDF;
		}
		x_WORD_DA7CA = *(x_WORD *)(a1 + 16);
	}
	else
	{
		v26 = 1;
	}
	if (v29)
	{
		for (i = x_D41A0_BYTEARRAY_4[0x967B]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
		{
			if (v29 < 2u)
			{
				if (v29 == 1)
				{
					*(x_BYTE *)(i + 15) |= 1u;
					*(x_BYTE *)(i + 14) &= 0x7Fu;
				}
			}
			else if (v29 <= 2u)
			{
				*(x_BYTE *)(i + 14) |= 0x80u;
				*(x_BYTE *)(i + 15) &= 0xFEu;
			}
			else if (v29 == 3)
			{
				sub_57F10(i);
			}
		}
	}
	if (v27)
	{
		*(x_WORD *)(a1 + 40) += 96;
		*(x_BYTE *)(a1 + 41) &= 7u;
		v24 = 0;
		v15 = *(unsigned __int16 *)(a1 + 40);
		while (1)
		{
			v23 = v15;
			if (v24 >= 4)
				break;
			v18 = *(x_DWORD *)(a1 + 76);
			v19 = *(x_WORD *)(a1 + 80);
			sub_57FA0((x_WORD*)&v18, v23, 0, 192);
			v16 = sub_4A190((int)&v18, 10, 14);
			if (v16)
			{
				*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
				*(x_DWORD *)(v16 + 8) = (*(x_WORD *)(a1 + 20) & 7) + 8;
			}
			v15 = ((x_WORD)v23 + 512) & 0x7FF;
			++v24;
		}
	}
	return v26;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// DA7CA: using guessed type __int16 x_WORD_DA7CA;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00021850) --------------------------------------------------------
void sub_21850(int a1)
{
	signed int v1; // ecx
	char v2; // ah
	signed int v3; // esi
	signed int v4; // edx
	char v5; // al
	int v6; // eax
	int v7; // eax
	int v8; // eax
	int v9; // eax
	signed int v10; // edx

	v1 = 0;
	v2 = *(x_BYTE *)(a1 + 42) & 0xFD;
	v3 = 0;
	*(x_BYTE *)(a1 + 42) = v2;
	if (v2 & 1)
	{
		*(x_BYTE *)(a1 + 42) = v2 & 0xFE;
		if (*(x_BYTE *)(a1 + 57))
		{
			v3 = 1;
			*(x_BYTE *)(a1 + 42) = v2 & 0xFE | 2;
		}
	}
	else
	{
		*(x_BYTE *)(a1 + 42) = v2 | 2;
		*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
		v4 = *(unsigned __int16 *)(a1 + 20) % 0x46u;
		v5 = *(x_BYTE *)(a1 + 42);
		*(x_WORD *)(a1 + 20) += x_D41A0_BYTEARRAY_4_struct.setting_30;
		if (v5 < 0)
		{
			v4 = 0;
			*(x_BYTE *)(a1 + 42) = v5 & 0x7F;
		}
		if (v4 < 40)
		{
			if (v4 >= 3 && v4 <= 6)
			{
				v3 = 1;
				goto LABEL_22;
			}
		}
		else if (v4 > 48)
		{
			if (v4 > 58)
			{
				if (v4 > 68)
				{
					*(x_DWORD *)(a1 + 16) = 8;
					*(x_WORD *)(a1 + 36) = 3;
					v9 = (int)x_D41A0_BYTEARRAY_0;
					*(x_WORD *)(a1 + 74) = 682;
					if (*(x_WORD *)(0x3653D + v9 + 3) < 12)
					{
						*(x_BYTE *)(a1 + 67) = 4;
						goto LABEL_22;
					}
				}
				else
				{
					*(x_DWORD *)(a1 + 16) = 8;
					*(x_WORD *)(a1 + 36) = 3;
					v8 = (int)x_D41A0_BYTEARRAY_0;
					*(x_WORD *)(a1 + 74) = 682;
					if (*(x_WORD *)(0x36541 + v8 + 1) < 6)
					{
						*(x_BYTE *)(a1 + 67) = 5;
						goto LABEL_22;
					}
				}
			}
			else
			{
				*(x_DWORD *)(a1 + 16) = 8;
				*(x_WORD *)(a1 + 36) = 3;
				v7 = (int)x_D41A0_BYTEARRAY_0;
				*(x_WORD *)(a1 + 74) = 682;
				if (*(x_WORD *)(0x3653D + v7 + 1) < 4)
				{
					*(x_BYTE *)(a1 + 67) = 3;
					goto LABEL_22;
				}
			}
		}
		else
		{
			*(x_DWORD *)(a1 + 16) = 8;
			*(x_WORD *)(a1 + 36) = 8;
			v6 = (int)x_D41A0_BYTEARRAY_0;
			*(x_WORD *)(a1 + 74) = 256;
			if (*(x_WORD *)(0x36543 + v6 + 1) < 28)
			{
				*(x_BYTE *)(a1 + 67) = 6;
				goto LABEL_22;
			}
		}
		v1 = 1;
	}
LABEL_22:
	if (v1)
	{
		*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
		v10 = *(unsigned __int16 *)(a1 + 20) % 0x1Du;
		*(x_WORD *)(a1 + 20) += x_D41A0_BYTEARRAY_4_struct.setting_30;
		if (v10 > 7)
		{
			if (v10 > 17)
			{
				if (v10 > 25)
				{
					if (v10 > 27)
					{
						v3 = 1;
					}
					else
					{
						*(x_BYTE *)(a1 + 67) = 8;
						*(x_WORD *)(a1 + 36) = 1;
						*(x_DWORD *)(a1 + 16) = 5;
					}
				}
				else
				{
					*(x_BYTE *)(a1 + 67) = 9;
					*(x_WORD *)(a1 + 36) = 1;
					*(x_DWORD *)(a1 + 16) = 5;
				}
			}
			else
			{
				*(x_BYTE *)(a1 + 67) = 2;
				*(x_WORD *)(a1 + 36) = 8;
				*(x_DWORD *)(a1 + 16) = 8;
			}
		}
		else
		{
			*(x_BYTE *)(a1 + 67) = 1;
			*(x_WORD *)(a1 + 36) = 10;
			*(x_DWORD *)(a1 + 16) = 10;
		}
	}
	if (v3)
	{
		*(x_BYTE *)(a1 + 67) = 7;
		*(x_WORD *)(a1 + 36) = 24;
		*(x_DWORD *)(a1 + 16) = 32;
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (00021AB0) --------------------------------------------------------
void sub_21AB0(int a1)
{
	int v1; // edx
	unsigned int v2; // eax
	__int16 v3; // dx
	__int16 v4; // ax
	x_WORD *v5; // eax
	x_WORD *v6; // eax
	x_WORD *v7; // eax
	x_WORD *v8; // eax
	__int16 v9; // ax
	x_DWORD *v10; // eax
	int v11; // eax
	int v12; // esi
	int v13; // edx
	char v14; // cl
	int v15; // eax
	__int16 v16; // si
	x_WORD *v17; // ST0C_4
	unsigned __int16 v18; // ax
	int v19; // edi
	int v20; // esi
	__int16 v21; // ax
	x_WORD *v22; // esi
	x_WORD *v23; // ST0C_4
	__int16 v24; // ax
	__int16 v25; // ax
	x_WORD *v26; // edx
	unsigned int v27; // ST0C_4
	int v28; // [esp+0h] [ebp-20h]
	__int16 v29; // [esp+4h] [ebp-1Ch]
	int v30; // [esp+8h] [ebp-18h]
	unsigned int v31; // [esp+Ch] [ebp-14h]
	int v32; // [esp+10h] [ebp-10h]
	x_WORD *v33; // [esp+14h] [ebp-Ch]
	int v34; // [esp+18h] [ebp-8h]
	x_DWORD *v35; // [esp+1Ch] [ebp-4h]

	v33 = 0;
	v35 = 0;
	v1 = 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
	v34 = -1;
	v2 = x_DWORD_EA3E4[*(unsigned __int16 *)(v1 + x_D41A0_BYTEARRAY_0 + 11240)];
	v31 = v2;
	if (v2 > x_DWORD_EA3E4[0] && *(x_DWORD *)(v2 + 8) >= 0 && !(*(x_BYTE *)(v2 + 13) & 4))
	{
		v3 = *(x_WORD *)(a1 + 36);
		if (v3)
		{
			*(x_WORD *)(a1 + 36) = v3 - 1;
			v28 = *(x_DWORD *)(a1 + 76);
			v29 = *(x_WORD *)(a1 + 80);
			sub_57FA0((x_WORD*)&v28, *(x_WORD *)(a1 + 28), 0, 640);
			v4 = *(x_WORD *)(a1 + 80);
			HIBYTE(v4) += 3;
			v29 = v4;
			switch (*(x_BYTE *)(a1 + 67))
			{
			case 1:
				v5 = (x_WORD *)sub_4A190((int)&v28, 9, 0);
				v33 = v5;
				if (v5)
				{
					*((x_BYTE *)v5 + 67) = 10;
					*((x_BYTE *)v5 + 68) = 0;
					*((x_DWORD *)v5 + 40) = (x_DWORD)&off_D8412;
					v5[21] = 800;
					v34 = 15;
				}
				break;
			case 2:
				v6 = (x_WORD *)sub_4A190((int)&v28, 9, 9);
				v33 = v6;
				if (v6)
				{
					*((x_BYTE *)v6 + 67) = 10;
					*((x_BYTE *)v6 + 68) = 23;
					*((x_DWORD *)v6 + 40) = (x_DWORD)&off_D8412;
					v6[21] = 800;
					v34 = 23;
				}
				break;
			case 3:
			case 4:
			case 5:
			case 6:
				v32 = (*(x_WORD *)(a1 + 74) * *(x_WORD *)(a1 + 36) + *(x_WORD *)(a1 + 28)) & 0x7FF;
				sub_57FA0((x_WORD*)&v28, v32, 0, 1792);
				v9 = *(x_WORD *)(a1 + 80);
				HIBYTE(v9) += 3;
				v29 = v9;
				switch (*(x_BYTE *)(a1 + 67))
				{
				case 3:
					v10 = sub_4B240((int)&v28);
					goto LABEL_19;
				case 4:
					v10 = (x_DWORD *)sub_4C8F0((int)&v28);
					goto LABEL_19;
				case 5:
					v10 = (x_DWORD *)sub_4CE00((int)&v28);
					goto LABEL_19;
				case 6:
					v10 = (x_DWORD *)sub_4C6B0((int)&v28);
				LABEL_19:
					v35 = v10;
					break;
				default:
					break;
				}
				if (v35)
				{
					++*(x_DWORD *)(0x364D1 + x_D41A0_BYTEARRAY_0 + 1);
					switch (*(x_BYTE *)(a1 + 67))
					{
					case 3:
						v30 = 7;
						v34 = 8;
						break;
					case 4:
						v30 = 175;
						v34 = 42;
						break;
					case 5:
						v30 = 207;
						v34 = 37;
						break;
					case 6:
						v30 = 159;
						v34 = 44;
						break;
					default:
						break;
					}
					v11 = (int)x_D41A0_BYTEARRAY_0;
					v12 = (int)v35;
					*((x_WORD *)v35 + 75) = *(x_WORD *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240);
					*(x_WORD *)(v12 + 26) = *(x_WORD *)(a1 + 26);
					v13 = (int)v35;
					*((x_BYTE *)v35 + 73) = 17;
					*(x_WORD *)(v13 + 46) = 250;
					*(x_WORD *)(v13 + 130) = 320;
					*(x_WORD *)(v13 + 40) = (a1 - (v11 + 28302)) / 168;
					LOWORD(v11) = v32;
					*(x_WORD *)(v13 + 28) = v32;
					*(x_WORD *)(v13 + 32) = v11;
					*(x_BYTE *)(v13 + 69) = v30;
				}
				break;
			case 7:
				if (*(x_BYTE *)(a1 + 42) & 2)
				{
					sub_5C800(v31, 6);
					*(x_WORD *)(0x36546 + x_D41A0_BYTEARRAY_0) = 1024;
					v14 = *(x_BYTE *)(a1 + 42);
					v34 = 19;
					*(x_BYTE *)(a1 + 42) = v14 & 0xFD;
				}
				v15 = (int)x_D41A0_BYTEARRAY_0;
				v16 = *(x_WORD *)(0x36546 + x_D41A0_BYTEARRAY_0) - 80;
				*(x_WORD *)(0x36546 + x_D41A0_BYTEARRAY_0) = v16;
				if (v16 < 10)
					*(x_WORD *)(0x36546 + v15) = 10;
				if (*(x_WORD *)(0x36546 + x_D41A0_BYTEARRAY_0) > 1024)
					*(x_WORD *)(0x36546 + x_D41A0_BYTEARRAY_0) = 1024;
				v17 = (x_WORD *)(v31 + 76);
				*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(v31 + 76);
				*(&x_WORD_EB398 + 2) = *(x_WORD *)(v31 + 80);
				v18 = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)v17);
				v32 = v18;
				sub_57FA0((x_WORD*)&x_WORD_EB398, v18, 0, *(x_WORD *)(0x36546 + x_D41A0_BYTEARRAY_0));
				v19 = v31;
				if ((unsigned __int16)sub_5D0A0(v31))
				{
					v20 = *(signed __int16 *)(*(x_DWORD *)(v19 + 160) + 12);
					v21 = sub_10C40(&x_WORD_EB398);
					if (x_WORD_EB39C < v21 + v20)
						x_WORD_EB39C = *(x_WORD *)(*(x_DWORD *)(v19 + 160) + 12) + v21;
					sub_57CF0(v31, (int)&x_WORD_EB398);
				}
				break;
			case 8:
				v8 = (x_WORD *)sub_4A190((int)&v28, 9, 26);
				v33 = v8;
				if (v8)
				{
					*((x_BYTE *)v8 + 67) = 10;
					*((x_BYTE *)v8 + 68) = 22;
					v8[21] = 20;
					*((x_BYTE *)v8 + 70) = 3;
					v34 = 15;
				}
				break;
			case 9:
				v7 = (x_WORD *)sub_4A190((int)&v28, 9, 3);
				v33 = v7;
				if (v7)
				{
					*((x_BYTE *)v7 + 67) = 10;
					*((x_BYTE *)v7 + 68) = 17;
					v7[21] = 6000;
					*((x_BYTE *)v7 + 70) = 10;
					v34 = 15;
				}
				break;
			default:
				break;
			}
			if (v33)
			{
				v22 = (x_WORD *)(v31 + 76);
				v23 = (x_WORD *)(v31 + 76);
				v33[13] = *(x_WORD *)(a1 + 26);
				v24 = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)v23);
				v33[14] = v24;
				v25 = sub_58210((x_WORD *)(a1 + 76), v22);
				v26 = v33;
				v33[15] = v25;
				*((x_BYTE *)v26 + 66) = *(x_BYTE *)(v31 + 64);
				v27 = v31;
				*((x_BYTE *)v26 + 65) = *(x_BYTE *)(v31 + 63);
				sub_5EF70(v27);
			}
		}
		if (v34 >= 0)
			sub_6E450(*(x_WORD *)(a1 + 26), -1, v34);
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D8412: using guessed type void *off_D8412;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (00021F60) --------------------------------------------------------
char sub_21F60(int a1)
{
	unsigned int i; // ebx
	unsigned __int8 v2; // al
	bool v3; // eax
	unsigned __int16 v4; // si
	int v5; // eax
	int v6; // eax
	__int16 v7; // di
	int v9; // [esp+0h] [ebp-28h]
	__int16 v10; // [esp+4h] [ebp-24h]
	char v11; // [esp+8h] [ebp-20h]
	__int16 v12; // [esp+Ah] [ebp-1Eh]
	__int16 v13; // [esp+Ch] [ebp-1Ch]
	int v14; // [esp+10h] [ebp-18h]
	__int16 v15; // [esp+14h] [ebp-14h]
	int v16; // [esp+18h] [ebp-10h]
	bool v17; // [esp+1Ch] [ebp-Ch]
	char v18; // [esp+20h] [ebp-8h]
	char v19; // [esp+24h] [ebp-4h]

	v19 = 0;
	v16 = x_DWORD_EA3E4[*(unsigned __int16 *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240)];
	v17 = *(x_BYTE *)(a1 + 63) != 5 || *(x_BYTE *)(a1 + 64) != 10;
	for (i = x_D41A0_BYTEARRAY_4[0x9683]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
	{
		v2 = *(x_BYTE *)(i + 64);
		v18 = 0;
		if (v2 < 0xAu)
		{
			if (v2 < 2u || v2 > 2u && (v2 < 4u || v2 > 5u))
				goto LABEL_31;
			goto LABEL_19;
		}
		if (v2 > 0xAu)
		{
			if (v2 < 0x19u)
			{
				if (v2 < 0x16u || v2 > 0x17u)
					goto LABEL_31;
			}
			else if (v2 > 0x19u && v2 != 30)
			{
				goto LABEL_31;
			}
		LABEL_19:
			if (!v17)
			{
				if (sub_58490((x_WORD *)(a1 + 76), (x_WORD *)(i + 76)) <= 0xC00)
				{
					v19 = 1;
					v18 = 1;
				}
				goto LABEL_31;
			}
			v12 = 5120;
			v13 = 5120;
			v3 = sub_106F0((x_WORD *)(a1 + 76), a1 + 82, (x_WORD *)(i + 76), (int)&v11);
			goto LABEL_29;
		}
		v12 = 5120;
		v13 = 5120;
		HIWORD(v9) = 5120;
		v10 = 5120;
		v14 = *(x_DWORD *)(i + 76);
		v15 = *(x_WORD *)(i + 80);
		v4 = *(x_WORD *)(*(x_DWORD *)(v16 + 164) + 58);
		if (v4)
		{
			v5 = x_DWORD_EA3E4[v4];
			v14 = *(x_DWORD *)(v5 + 76);
			v15 = *(x_WORD *)(v5 + 80);
			v9 = *(x_DWORD *)(v5 + 82);
			*(x_DWORD *)&v10 = *(x_DWORD *)(v5 + 86);
		}
		if (v17)
		{
			v3 = sub_106F0((x_WORD *)(a1 + 76), a1 + 82, (x_WORD*)&v14, (int)&v9);
		LABEL_29:
			if (v3)
				v18 = 1;
			goto LABEL_31;
		}
		if (sub_106F0((x_WORD *)(a1 + 76), (int)&v11, (x_WORD*)&v14, (int)&v9))
		{
			v19 = 1;
			v18 = 1;
		}
	LABEL_31:
		if (v18)
		{
			if (*(x_BYTE *)(i + 64) == 10)
				*(x_WORD *)(x_DWORD_EA3E4[*(signed __int16 *)(*(x_DWORD *)(v16 + 164) + 823)] + 46) = 0;
			v6 = sub_4A190(i + 76, 10, 0);
			if (v6)
				*(x_WORD *)(v6 + 26) = *(x_WORD *)(a1 + 26);
			sub_57F10(i);
		}
	}
	v7 = *(x_WORD *)(*(x_DWORD *)(v16 + 164) + 835);
	if (v7 && *(x_WORD *)(x_DWORD_EA3E4[v7] + 46) > 0)
		v19 = 1;
	return v19;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00022190) --------------------------------------------------------
char sub_22190(int a1)
{
	char v1; // dl
	signed int v2; // edx
	__int16 v3; // dx

	v1 = 0;
	if (*(x_BYTE *)(a1 + 57))
	{
		if (*(x_WORD *)(a1 + 98))
		{
			v2 = *(x_DWORD *)(a1 + 94);
			if (v2 < 1)
				v2 = 1;
			if (v2 > 300)
				v2 = 300;
			*(x_DWORD *)(a1 + 8) -= v2;
			v3 = *(x_WORD *)(a1 + 98);
			*(x_WORD *)(a1 + 98) = 0;
			*(x_WORD *)(a1 + 38) = v3;
			v1 = 1;
		}
		else
		{
			*(x_WORD *)(a1 + 38) = 0;
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 10)
	{
		v1 = 2;
		*(x_DWORD *)(a1 + 8) = 8;
	}
	return v1;
}

//----- (000221F0) --------------------------------------------------------
char sub_221F0(int a1, __int16 a2)
{
	int v2; // eax
	unsigned __int16 v3; // bx

	LOBYTE(v2) = sub_49C90(a1, a2);
	if ((unsigned __int16)a2 >= 0x157u && (unsigned __int16)a2 <= 0x159u)
	{
		v3 = x_WORD_D951C[7 * a2];
		LOBYTE(v2) = sub_71AB0(v3, 1);
		if (x_DWORD_F66F0[v3])
		{
			v2 = *(unsigned __int16 *)(sub_724F0(x_DWORD_E9C08, v3) + 16);
			*(x_DWORD *)(a1 + 16) = v2;
		}
	}
	return v2;
}
// D951C: using guessed type __int16 x_WORD_D951C[];
// E9C08: using guessed type int x_DWORD_E9C08;

//----- (00022270) --------------------------------------------------------
__int16 sub_22270(int a1)
{
	__int16 result; // ax
	signed int v2; // edx

	result = sub_10C40((__int16 *)(a1 + 76));
	v2 = *(x_DWORD *)(a1 + 8);
	*(x_WORD *)(a1 + 80) = result;
	if (v2 >= 10)
		result = sub_222B0(a1);
	return result;
}

//----- (000222B0) --------------------------------------------------------
__int16 sub_222B0(int a1)
{
	int v1; // eax
	unsigned int v2; // edx
	signed int v3; // esi
	signed __int16 v4; // dx
	__int16 v5; // ax
	char v6; // ch

	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240)];
	v2 = (((*(unsigned __int16 *)(a1 + 28) - *(unsigned __int16 *)(v1 + 28)) >> 3) & 0xF0) >> 4;
	v3 = 0;
	if (v2 <= 2)
	{
		LOWORD(v1) = *(x_WORD *)(v1 + 28) + 384;
		*(x_WORD *)(a1 + 28) = v1;
	}
	else if (v2 >= 0xD && v2 <= 0xF)
	{
		LOWORD(v1) = *(x_WORD *)(v1 + 28);
		BYTE1(v1) += 6;
		*(x_WORD *)(a1 + 28) = v1;
	}
	else
	{
		switch (*(x_BYTE *)(a1 + 68))
		{
		case 0:
			v3 = 1;
			LOWORD(v1) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v1 + 76));
			goto LABEL_15;
		case 1:
			goto LABEL_13;
		case 2:
			if (x_D41A0_BYTEARRAY_4[26] & 1)
				v4 = 512;
			else
				v4 = -512;
			v5 = *(x_WORD *)(v1 + 28);
			HIBYTE(v5) += 4;
			LOWORD(v1) = v4 + v5;
			*(x_WORD *)(a1 + 32) = v1;
			v6 = *(x_BYTE *)(a1 + 33);
			*(x_BYTE *)(a1 + 68) = 1;
			*(x_BYTE *)(a1 + 33) = v6 & 7;
		LABEL_13:
			v3 = 1;
			break;
		case 3:
			LOWORD(v1) = *(x_WORD *)(a1 + 28);
		LABEL_15:
			*(x_WORD *)(a1 + 32) = v1;
			break;
		default:
			break;
		}
		if (v3)
		{
			LOWORD(v1) = sub_58350(
				*(x_WORD *)(a1 + 28),
				*(x_WORD *)(a1 + 32),
				*(unsigned __int16 *)(*(x_DWORD *)(a1 + 160) + 4),
				*(x_WORD *)(a1 + 44));
			*(x_WORD *)(a1 + 28) += v1;
		}
	}
	*(x_BYTE *)(a1 + 29) &= 7u;
	return v1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000223E0) --------------------------------------------------------
unsigned int sub_223E0()
{
	Bit8u* v0; // edx
	Bit8u* v1; // ecx
	x_DWORD *i; // eax
	x_DWORD *j; // eax
	x_DWORD *k; // eax
	unsigned int result; // eax

	v0 = x_D41A0_BYTEARRAY_0;
	v1 = x_D41A0_BYTEARRAY_4;
	*(x_WORD *)(0x3653D + x_D41A0_BYTEARRAY_0 + 1) = 0;
	for (i = *(x_DWORD **)(v1 + 38403); (unsigned int)i > x_DWORD_EA3E4[0]; i = (x_DWORD *)*i)
		++*(x_WORD *)(0x3653D + v0 + 1);
	*(x_WORD *)(0x3653D + v0 + 3) = 0;
	for (j = *(x_DWORD **)(v1 + 38403); (unsigned int)j > x_DWORD_EA3E4[0]; j = (x_DWORD *)*j)
		++*(x_WORD *)(0x3653D + v0 + 3);
	*(x_WORD *)(0x36543 + v0 + 1) = 0;
	for (k = *(x_DWORD **)(v1 + 38403); (unsigned int)k > x_DWORD_EA3E4[0]; k = (x_DWORD *)*k)
		++*(x_WORD *)(0x36543 + v0 + 1);
	*(x_WORD *)(0x36541 + v0 + 1) = 0;
	for (result = *(x_DWORD *)(v1 + 38503); result > x_DWORD_EA3E4[0]; result = *(x_DWORD *)result)
	{
		if (*(x_BYTE *)(result + 69) != -56)
			++*(x_WORD *)(0x36541 + v0 + 1);
	}
	x_D41A0_BYTEARRAY_4 = (Bit8u*)v1;
	x_D41A0_BYTEARRAY_0 = v0;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00022490) --------------------------------------------------------
char sub_22490(unsigned __int16 *a1)
{
	unsigned __int16 v1; // ax
	signed int v2; // esi
	unsigned __int16 v3; // bx
	signed int v4; // edi
	unsigned __int16 v6; // [esp+8h] [ebp-4h]

	LOBYTE(v1) = ((unsigned __int16)(a1[38] + 128) >> 8) - 19;
	HIBYTE(v1) = ((unsigned __int16)(a1[39] + 128) >> 8) - 19;
	v2 = 0;
	v6 = v1;
	do
	{
		v3 = v6;
		v4 = 0;
		while (v4 < 38)
		{
			++v4;
			LOBYTE(v1) = sub_57390(v3, a1[13]);
			LOBYTE(v3) = v3 + 1;
		}
		++v2;
		++HIBYTE(v6);
	} while (v2 < 38);
	return v1;
}

//----- (00022530) --------------------------------------------------------
int sub_22530(int a1)
{
	int result; // eax

	result = a1;
	*(x_BYTE *)(a1 + 69) = 80;
	return result;
}

//----- (00022540) --------------------------------------------------------
int sub_22540(int a1)
{
	int result; // eax

	result = a1;
	*(x_BYTE *)(a1 + 69) = 80;
	return result;
}

//----- (00022550) --------------------------------------------------------
int sub_22550(int a1)
{
	int result; // eax

	result = a1;
	*(x_BYTE *)(a1 + 69) = 80;
	return result;
}

//----- (00022560) --------------------------------------------------------
int sub_22560(int a1)
{
	return sub_1C890(a1, 80);
}

//----- (00022580) --------------------------------------------------------
void sub_22580(int a1)
{
	sub_1C930(a1);
}

//----- (000225A0) --------------------------------------------------------
int sub_225A0(int a1)
{
	int result; // eax

	result = a1;
	*(x_BYTE *)(a1 + 69) = 80;
	return result;
}

//----- (000225B0) --------------------------------------------------------
int sub_225B0(int a1)
{
	int result; // eax

	result = a1;
	*(x_BYTE *)(a1 + 69) = 80;
	return result;
}

//----- (00022640) --------------------------------------------------------
bool sub_22640(x_WORD *a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4)
{
	unsigned __int8 v4; // bl
	unsigned __int8 v5; // bh

	v4 = (*a1 >> 8) - ((signed int)a2 >> 1);
	v5 = (a1[1] >> 8) - ((signed int)a3 >> 1);
	if ((v4 + v5) % 2)
		++v4;
	return (signed __int16)sub_48990(v4, v5, a3, a2) < (signed int)a4;
}

//----- (000226D0) --------------------------------------------------------
x_WORD *sub_226D0(unsigned __int16 a1, x_WORD *a2, x_WORD *a3)
{
	unsigned __int16 v3; // cx
	unsigned __int16 v4; // bx
	x_WORD *result; // eax
	v3 = 0;v4 = 0;//fix it
	/*v3 = *(unsigned __int8 *)(**filearray_2aa18c[24] + 6 * a1 + 5);
	v4 = *(unsigned __int8 *)(**filearray_2aa18c[24] + 6 * a1 + 4);*/ //fix it
	if (x_WORD_180660_VGA_type_resolution == 1)
	{
		v3 >>= 1;
		v4 >>= 1;
	}
	*a3 = (v3 << 8) / 2 + 768;
	result = a2;
	*a2 = (v4 << 8) / 2 + 768;
	return result;
}
// EA3BC: using guessed type int **filearray_2aa18c[24];
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00022760) --------------------------------------------------------
char sub_22760(int a1)
{
	int v1; // eax
	signed int v2; // eax
	int v3; // eax
	__int16 v4; // ax
	__int16 v5; // dx
	__int16 v6; // ax
	__int16 v7; // di
	int v8; // eax
	char v9; // cl
	unsigned int i; // esi
	unsigned int j; // esi
	unsigned int k; // esi
	unsigned int l; // esi
	int v14; // esi
	char v15; // al
	int v17; // [esp+0h] [ebp-1Ch]
	unsigned __int16 v18; // [esp+8h] [ebp-14h]
	unsigned __int16 v19; // [esp+Ch] [ebp-10h]
	__int16 v20; // [esp+10h] [ebp-Ch]
	int v21; // [esp+14h] [ebp-8h]
	unsigned __int8 v22; // [esp+18h] [ebp-4h]

	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
	v20 = 96;
	v17 = v1;
	if (!*(x_BYTE *)(v1 + 63) || *(x_BYTE *)(v1 + 64) != 45)
	{
		*(x_DWORD *)(a1 + 16) = 5;
	LABEL_51:
		v15 = v20;
		*(x_WORD *)(a1 + 150) = 0;
		LOBYTE(v8) = v15 + 1;
		*(x_BYTE *)(a1 + 69) = v8;
		return v8;
	}
	*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(v1 + 76);
	*(&x_WORD_EB398 + 2) = *(x_WORD *)(v1 + 80);
	v2 = *(x_DWORD *)(a1 + 16);
	*(x_DWORD *)(a1 + 16) = v2 + 1;
	if (v2 >= 4)
	{
		*(x_DWORD *)(a1 + 16) = 1;
		goto LABEL_51;
	}
	v22 = sub_232C0();
	sub_226D0(v22, (x_WORD*)&v19, (x_WORD*)&v18);
	v3 = *(x_DWORD *)(a1 + 16) - 1;
	switch (*(x_DWORD *)(a1 + 16))
	{
	case 1:
		*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
		v4 = 9377 * *(x_WORD *)(a1 + 20);
		x_WORD_EB398 += (*(x_WORD *)(a1 + 20) % 3u << 8) + *(x_WORD *)(v17 + 84) + v19 + 256;
		*(x_WORD *)(a1 + 20) = v4 + 9439;
		v3 = (*(unsigned __int16 *)(a1 + 20) % 3u << 8) - 1280;
		v5 = v3 + x_WORD_EB39A;
		goto LABEL_10;
	case 2:
		*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
		x_WORD_EB398 -= (*(x_WORD *)(a1 + 20) % 3u << 8) + *(x_WORD *)(v17 + 84) + v19 + 256;
		*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
		v3 = (*(unsigned __int16 *)(a1 + 20) % 3u << 8) - 1280;
		v5 = v3 + x_WORD_EB39A;
		goto LABEL_10;
	case 3:
		*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
		v6 = 9377 * *(x_WORD *)(a1 + 20);
		x_WORD_EB398 += (*(x_WORD *)(a1 + 20) % 3u << 8) - 1280;
		*(x_WORD *)(a1 + 20) = v6 + 9439;
		v3 = (*(unsigned __int16 *)(a1 + 20) % 3u << 8) + *(signed __int16 *)(v17 + 86) + v18 + 256;
		v5 = v3 + x_WORD_EB39A;
		goto LABEL_10;
	case 4:
		*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
		x_WORD_EB398 += (*(x_WORD *)(a1 + 20) % 3u << 8) - 1280;
		*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
		v3 = *(signed __int16 *)(v17 + 86) + v18;
		v5 = x_WORD_EB39A - (v3 + (*(x_WORD *)(a1 + 20) % 3u << 8) + 256);
	LABEL_10:
		x_WORD_EB39A = v5;
		break;
	default:
		break;
	}
	LOWORD(v3) = x_WORD_EB398;
	v7 = x_WORD_EB39A;
	v21 = v3;
	if (sub_104D0(&x_WORD_EB398) == (int(*)())1)
	{
		*(x_DWORD *)(a1 + 16) = 2;
		goto LABEL_51;
	}
	LOBYTE(v8) = sub_22640(
		&x_WORD_EB398,
		(signed int)v19 >> 8,
		(signed int)v18 >> 8,
		(((signed int)v19 >> 7) + ((signed int)v18 >> 7) > 4) + 15);
	if ((x_BYTE)v8)
	{
		v9 = 0;
		for (i = x_D41A0_BYTEARRAY_4[0x967F]; !v9 && i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
		{
			v8 = abs((signed __int16)(*(x_WORD *)(i + 76) - v21));
			if (v8 <= *(signed __int16 *)(i + 84) + v19)
			{
				v8 = abs((signed __int16)(*(x_WORD *)(i + 78) - v7));
				if (v8 <= v18 + (signed int)*(signed __int16 *)(i + 86))
					v9 = 1;
			}
		}
		if (!v9)
		{
			for (j = x_D41A0_BYTEARRAY_4[0x9677]; !v9 && j > x_DWORD_EA3E4[0]; j = *(x_DWORD *)j)
			{
				if (*(x_BYTE *)(j + 64) == 2)
				{
					v8 = abs((signed __int16)(*(x_WORD *)(j + 76) - v21));
					if (v8 <= *(signed __int16 *)(j + 84) + v19)
					{
						v8 = abs((signed __int16)(*(x_WORD *)(j + 78) - v7));
						if (v8 <= v18 + (signed int)*(signed __int16 *)(j + 86))
							v9 = 1;
					}
				}
			}
		}
		if (!v9)
		{
			for (k = x_D41A0_BYTEARRAY_4[38535]; !v9 && k > x_DWORD_EA3E4[0]; k = *(x_DWORD *)k)
			{
				if (*(x_BYTE *)(k + 64) == 67)
				{
					v8 = abs((signed __int16)(*(x_WORD *)(k + 76) - v21));
					if (v8 <= *(signed __int16 *)(k + 84) + v19)
					{
						v8 = abs((signed __int16)(*(x_WORD *)(k + 78) - v7));
						if (v8 <= v18 + (signed int)*(signed __int16 *)(k + 86))
							v9 = 1;
					}
				}
			}
		}
		if (!v9)
		{
			for (l = x_D41A0_BYTEARRAY_4[38451]; !v9 && l > x_DWORD_EA3E4[0]; l = *(x_DWORD *)l)
			{
				if (*(x_BYTE *)(l + 61))
					v9 = 1;
			}
		}
		if (!v9)
		{
			v8 = sub_4A190((int)&x_WORD_EB398, 10, 45);
			v14 = v8;
			if (v8)
			{
				sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 10);
				LOBYTE(v8) = sub_49A30(v14, v22);
				*(x_BYTE *)(v14 + 69) = 51;
			}
			*(x_WORD *)(a1 + 150) = 0;
			*(x_BYTE *)(a1 + 61) = 1;
			*(x_BYTE *)(a1 + 69) = 105;
		}
	}
	return v8;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39A: using guessed type __int16 x_WORD_EB39A;

//----- (00022C80) --------------------------------------------------------
char sub_22C80(int a1)
{
	unsigned int v1; // eax
	__int16 v2; // ax
	int i; // edx
	int v4; // ecx
	int v5; // edx
	unsigned int v6; // edx
	unsigned __int16 v7; // ax

	*(x_BYTE *)(a1 + 61) = 0;
	v1 = 0;
	if (*(x_WORD *)(a1 + 98))
	{
		*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
		v2 = *(x_WORD *)(a1 + 98);
		*(x_WORD *)(a1 + 98) = 0;
		*(x_WORD *)(a1 + 38) = v2;
		v1 = 1;
	}
	else
	{
		*(x_WORD *)(a1 + 38) = 0;
	}
	if (*(x_WORD *)(a1 + 52))
	{
		for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52))
		{
			v5 = x_DWORD_EA3E4[i];
			if (v5 == x_DWORD_EA3E4[0])
				break;
			v4 = *(x_DWORD *)(v5 + 8);
			if (v4 < *(x_DWORD *)(a1 + 8))
			{
				*(x_DWORD *)(a1 + 8) = v4;
				*(x_WORD *)(a1 + 38) = *(x_WORD *)(v5 + 38);
				v1 = 1;
				break;
			}
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 0)
	{
		*(x_WORD *)(a1 + 36) = *(x_WORD *)(a1 + 38);
		v1 = 2;
	}
	if (v1 >= 1)
	{
		if (v1 <= 1)
		{
			v6 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 38)];
			if (v6 > x_DWORD_EA3E4[0] && (!*(x_BYTE *)(v6 + 64) || *(x_BYTE *)(v6 + 64) == 1))
				*(x_WORD *)(*(x_DWORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 38)] + 164) + 584) = 200;
			*(x_WORD *)(a1 + 150) = *(x_WORD *)(a1 + 38);
			LOBYTE(v1) = 102;
		}
		else
		{
			if (v1 != 2)
				goto LABEL_28;
			LOBYTE(v1) = 100;
		}
	LABEL_27:
		*(x_BYTE *)(a1 + 69) = v1;
		goto LABEL_28;
	}
	if (!v1)
	{
		sub_1B8C0(a1);
		LOWORD(v1) = (signed __int16)*(unsigned __int8 *)(a1 + 62) / *(x_WORD *)(*(x_DWORD *)(a1 + 160) + 26);
		if (!(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 26)))
		{
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			v7 = *(x_WORD *)(a1 + 20);
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			*(x_WORD *)(a1 + 32) += ((*(x_WORD *)(a1 + 20) & 0xFF) + 85) * (2 * ((signed int)(v7 % 0x9Du) / 79) - 1);
			v1 = *(x_DWORD *)(a1 + 16);
			*(x_BYTE *)(a1 + 33) &= 7u;
			*(x_DWORD *)(a1 + 16) = v1 - 1;
			if (!v1)
			{
				LOBYTE(v1) = 99;
				*(x_DWORD *)(a1 + 16) = 1;
				goto LABEL_27;
			}
		}
	}
LABEL_28:
	if (*(x_BYTE *)(a1 + 69) == 102)
	{
		LOWORD(v1) = *(x_WORD *)(a1 + 132);
		*(x_WORD *)(a1 + 130) = v1;
	}
	return v1;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00022E60) --------------------------------------------------------
char sub_22E60(int a1)
{
	unsigned int v1; // eax
	__int16 v2; // ax
	int i; // edx
	int v4; // esi
	int v5; // edx
	unsigned int v6; // edx
	int v7; // edx
	int v8; // eax
	x_WORD *v9; // esi

	v1 = 0;
	if (*(x_WORD *)(a1 + 98))
	{
		*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
		v2 = *(x_WORD *)(a1 + 98);
		*(x_WORD *)(a1 + 98) = 0;
		*(x_WORD *)(a1 + 38) = v2;
		v1 = 1;
	}
	else
	{
		*(x_WORD *)(a1 + 38) = 0;
	}
	if (*(x_WORD *)(a1 + 52))
	{
		for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52))
		{
			v5 = x_DWORD_EA3E4[i];
			if (v5 == x_DWORD_EA3E4[0])
				break;
			v4 = *(x_DWORD *)(v5 + 8);
			if (v4 < *(x_DWORD *)(a1 + 8))
			{
				*(x_DWORD *)(a1 + 8) = v4;
				*(x_WORD *)(a1 + 38) = *(x_WORD *)(v5 + 38);
				v1 = 1;
				break;
			}
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 0)
	{
		*(x_WORD *)(a1 + 36) = *(x_WORD *)(a1 + 38);
		v1 = 2;
	}
	if (v1 >= 1)
	{
		if (v1 <= 1)
		{
			v6 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 38)];
			if (v6 > x_DWORD_EA3E4[0] && (!*(x_BYTE *)(v6 + 64) || *(x_BYTE *)(v6 + 64) == 1))
				*(x_WORD *)(*(x_DWORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 38)] + 164) + 584) = 200;
			*(x_WORD *)(a1 + 150) = *(x_WORD *)(a1 + 38);
			LOBYTE(v1) = 102;
		}
		else
		{
			if (v1 != 2)
				goto LABEL_31;
			LOBYTE(v1) = 100;
		}
	LABEL_30:
		*(x_BYTE *)(a1 + 69) = v1;
		goto LABEL_31;
	}
	if (!v1)
	{
		sub_1B8C0(a1);
		v1 = *(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 26) / 2;
		if (!v1)
		{
			v7 = *(x_DWORD *)(a1 + 16);
			v8 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
			*(x_DWORD *)(a1 + 16) = v7 - 1;
			if (!v7 || !*(x_BYTE *)(v8 + 63))
			{
				*(x_DWORD *)(a1 + 16) = 5;
				*(x_BYTE *)(a1 + 69) = 97;
			}
			v9 = (x_WORD *)(v8 + 76);
			*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v8 + 76));
			v1 = sub_583F0((x_WORD *)(a1 + 76), v9);
			if (v1 < 0xA00)
			{
				LOBYTE(v1) = 96;
				*(x_DWORD *)(a1 + 16) = 0;
				goto LABEL_30;
			}
		}
	}
LABEL_31:
	if (*(x_BYTE *)(a1 + 69) == 102)
	{
		LOWORD(v1) = *(x_WORD *)(a1 + 132);
		*(x_WORD *)(a1 + 130) = v1;
	}
	return v1;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00023020) --------------------------------------------------------
char sub_23020(int a1)
{
	unsigned int v1; // eax
	__int16 v2; // ax
	int i; // edx
	int v4; // esi
	int v5; // edx
	unsigned int v6; // edx
	unsigned int v7; // edi
	unsigned int j; // esi
	unsigned int v9; // eax
	unsigned int v11; // [esp+0h] [ebp-8h]

	v1 = 0;
	v11 = -1;
	if (*(x_WORD *)(a1 + 98))
	{
		*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
		v2 = *(x_WORD *)(a1 + 98);
		*(x_WORD *)(a1 + 98) = 0;
		*(x_WORD *)(a1 + 38) = v2;
		v1 = 1;
	}
	else
	{
		*(x_WORD *)(a1 + 38) = 0;
	}
	if (*(x_WORD *)(a1 + 52))
	{
		for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52))
		{
			v5 = x_DWORD_EA3E4[i];
			if (v5 == x_DWORD_EA3E4[0])
				break;
			v4 = *(x_DWORD *)(v5 + 8);
			if (v4 < *(x_DWORD *)(a1 + 8))
			{
				*(x_DWORD *)(a1 + 8) = v4;
				*(x_WORD *)(a1 + 38) = *(x_WORD *)(v5 + 38);
				v1 = 1;
				break;
			}
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 0)
	{
		*(x_WORD *)(a1 + 36) = *(x_WORD *)(a1 + 38);
		v1 = 2;
	}
	if (v1 >= 1)
	{
		if (v1 <= 1)
		{
			v6 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 38)];
			if (v6 > x_DWORD_EA3E4[0] && (!*(x_BYTE *)(v6 + 64) || *(x_BYTE *)(v6 + 64) == 1))
				*(x_WORD *)(*(x_DWORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 38)] + 164) + 584) = 200;
			*(x_WORD *)(a1 + 150) = *(x_WORD *)(a1 + 38);
			LOBYTE(v1) = 102;
		}
		else
		{
			if (v1 != 2)
				goto LABEL_34;
			LOBYTE(v1) = 100;
		}
	LABEL_33:
		*(x_BYTE *)(a1 + 69) = v1;
		goto LABEL_34;
	}
	if (!v1)
	{
		v7 = 0;
		for (j = x_D41A0_BYTEARRAY_4[0x967F]; j > x_DWORD_EA3E4[0]; j = *(x_DWORD *)j)
		{
			v9 = sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(j + 76));
			if (v9 && v9 < v11)
			{
				v7 = j;
				v11 = v9;
			}
		}
		if (v7)
		{
			*(x_WORD *)(a1 + 150) = (signed int)(v7 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
			*(x_DWORD *)(a1 + 16) = 10;
			LOBYTE(v1) = 98;
		}
		else
		{
			*(x_DWORD *)(a1 + 16) = 5;
			LOBYTE(v1) = 97;
		}
		goto LABEL_33;
	}
LABEL_34:
	if (*(x_BYTE *)(a1 + 69) == 102)
	{
		LOWORD(v1) = *(x_WORD *)(a1 + 132);
		*(x_WORD *)(a1 + 130) = v1;
	}
	return v1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000231E0) --------------------------------------------------------
int sub_231E0(int a1)
{
	return sub_1C890(a1, 96);
}

//----- (00023200) --------------------------------------------------------
void sub_23200(int a1)
{
	unsigned int v1; // edx

	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 36)];
	if (v1 > x_DWORD_EA3E4[0] && (!*(x_BYTE *)(v1 + 64) || *(x_BYTE *)(v1 + 64) == 1))
		*(x_WORD *)(*(x_DWORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 36)] + 164) + 584) = 200;
	sub_1C930(a1);
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00023260) --------------------------------------------------------
__int16 sub_23260(int a1)
{
	__int16 result; // ax

	LOBYTE(result) = sub_1C980(a1, 96);
	HIBYTE(result) = *(x_BYTE *)(a1 + 69);
	if (HIBYTE(result) != 102)
	{
		*(x_DWORD *)(a1 + 16) = 5;
		*(x_WORD *)(a1 + 150) = 0;
		result = *(x_WORD *)(a1 + 134);
		*(x_BYTE *)(a1 + 69) = 97;
		*(x_WORD *)(a1 + 130) = result;
	}
	return result;
}

//----- (000232A0) --------------------------------------------------------
char sub_232A0(int a1)
{
	*(x_DWORD *)(a1 + 16) = 5;
	*(x_BYTE *)(a1 + 69) = 97;
	return sub_22C80(a1);
}

//----- (000232C0) --------------------------------------------------------
char sub_232C0()
{
	int v0; // eax
	unsigned __int8 v1; // bl
	unsigned int v2; // eax

	v0 = (int)x_D41A0_BYTEARRAY_0;
	*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8) = 9377 * *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8) + 9439;
	v1 = 0;
	v2 = *(x_DWORD *)(v0 + 8) % 0x3Cu + 17;
	while (!(x_BYTE_D93C2[4 * (unsigned __int8)v2] & 2) && v1 < 0x4Du)
	{
		LOBYTE(v2) = v2 + 1;
		++v1;
		if ((unsigned __int8)v2 >= 0x4Cu)
			LOBYTE(v2) = 17;
	}
	if (v1 >= 0x4Du)
		LOBYTE(v2) = 17;
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00023320) --------------------------------------------------------
char sub_23320(int a1)
{
	*(x_BYTE *)(a1 + 69) = 105;
	return sub_23340(a1);
}

//----- (00023340) --------------------------------------------------------
char sub_23340(int a1)
{
	unsigned int j; // eax
	__int16 v2; // ax
	int i; // edx
	int v4; // edx
	int v5; // esi
	unsigned int v6; // edx
	unsigned __int16 v7; // ax
	unsigned int v8; // edi
	unsigned int v9; // esi
	int v10; // edx
	unsigned int v11; // edx
	int v12; // esi

	j = 0;
	if (*(x_WORD *)(a1 + 98))
	{
		*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
		v2 = *(x_WORD *)(a1 + 98);
		*(x_WORD *)(a1 + 98) = 0;
		*(x_WORD *)(a1 + 38) = v2;
		j = 1;
	}
	else
	{
		*(x_WORD *)(a1 + 38) = 0;
	}
	if (*(x_WORD *)(a1 + 52))
	{
		for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52))
		{
			v5 = x_DWORD_EA3E4[i];
			if (v5 == x_DWORD_EA3E4[0])
				break;
			v4 = *(x_DWORD *)(v5 + 8);
			if (v4 < *(x_DWORD *)(a1 + 8))
			{
				*(x_DWORD *)(a1 + 8) = v4;
				*(x_WORD *)(a1 + 38) = *(x_WORD *)(v5 + 38);
				j = 1;
				break;
			}
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 0)
	{
		*(x_WORD *)(a1 + 36) = *(x_WORD *)(a1 + 38);
		j = 2;
	}
	if (j >= 1)
	{
		if (j <= 1)
		{
			v6 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 38)];
			if (v6 > x_DWORD_EA3E4[0] && (!*(x_BYTE *)(v6 + 64) || *(x_BYTE *)(v6 + 64) == 1))
				*(x_WORD *)(*(x_DWORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 38)] + 164) + 584) = 200;
			*(x_WORD *)(a1 + 150) = *(x_WORD *)(a1 + 38);
			LOBYTE(j) = 110;
			*(x_BYTE *)(a1 + 69) = 110;
		}
		else if (j == 2)
		{
			LOBYTE(j) = 108;
			*(x_BYTE *)(a1 + 69) = 108;
		}
		goto LABEL_43;
	}
	if (j)
		goto LABEL_43;
	sub_1B8C0(a1);
	LOWORD(j) = (signed __int16)*(unsigned __int8 *)(a1 + 62) / *(x_WORD *)(*(x_DWORD *)(a1 + 160) + 26);
	if (*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 26))
		goto LABEL_43;
	if (*(x_WORD *)(a1 + 150))
	{
		v12 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
		if (*(x_BYTE *)(v12 + 63) == 10 && *(x_BYTE *)(v12 + 64) == 45)
		{
			if (sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(v12 + 76)) > 0x800)
			{
				LOWORD(j) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v12 + 76));
				*(x_WORD *)(a1 + 32) = j;
				goto LABEL_43;
			}
			if ((signed int)*(signed __int16 *)(v12 + 132) > *(x_DWORD *)(v12 + 16))
			{
				*(x_DWORD *)(a1 + 16) = 1;
				LOBYTE(j) = 108;
				*(x_BYTE *)(a1 + 69) = 108;
				++*(x_DWORD *)(v12 + 16);
				goto LABEL_43;
			}
		}
		*(x_WORD *)(a1 + 150) = 0;
		LOWORD(j) = *(x_WORD *)(a1 + 134);
		goto LABEL_42;
	}
	*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
	v7 = *(x_WORD *)(a1 + 20);
	*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
	*(x_WORD *)(a1 + 32) += (2 * ((signed int)(v7 % 0x9Du) / 79) - 1) * ((*(x_WORD *)(a1 + 20) & 0xFF) + 85);
	*(x_BYTE *)(a1 + 33) &= 7u;
	LOWORD(j) = (signed __int16)*(unsigned __int8 *)(a1 + 62) / *(x_WORD *)(*(x_DWORD *)(a1 + 160) + 26);
	if (!(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 26)))
	{
		v8 = -1;
		v9 = 0;
		for (j = x_D41A0_BYTEARRAY_4[0x967F]; j > x_DWORD_EA3E4[0]; j = *(x_DWORD *)j)
		{
			if (x_BYTE_D93C2[4 * *(char *)(j + 70)] & 1)
			{
				v10 = (signed __int16)(*(x_WORD *)(j + 76) - *(x_WORD *)(a1 + 76));
				v11 = v10 * v10
					+ (signed __int16)(*(x_WORD *)(j + 78) - *(x_WORD *)(a1 + 78))
					* (signed __int16)(*(x_WORD *)(j + 78) - *(x_WORD *)(a1 + 78));
				if (v11 < v8)
				{
					v9 = j;
					v8 = v11;
				}
			}
		}
		if (v9)
		{
			*(x_WORD *)(a1 + 150) = (signed int)(v9 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
			LOWORD(j) = *(x_WORD *)(a1 + 134) + 12;
		LABEL_42:
			*(x_WORD *)(a1 + 130) = j;
			goto LABEL_43;
		}
	}
LABEL_43:
	if (*(x_BYTE *)(a1 + 69) == 110)
	{
		LOWORD(j) = *(x_WORD *)(a1 + 132);
		*(x_WORD *)(a1 + 130) = j;
	}
	return j;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00023640) --------------------------------------------------------
char sub_23640(int a1)
{
	*(x_BYTE *)(a1 + 69) = 105;
	return sub_23340(a1);
}

//----- (00023660) --------------------------------------------------------
char sub_23660(int a1)
{
	*(x_BYTE *)(a1 + 69) = 105;
	return sub_23340(a1);
}

//----- (00023680) --------------------------------------------------------
int sub_23680(int a1)
{
	unsigned int v2; // ebx

	if (*(x_DWORD *)(a1 + 16))
		sub_57F10(a1);
	v2 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 36)];
	if (v2 > x_DWORD_EA3E4[0] && (!*(x_BYTE *)(v2 + 64) || *(x_BYTE *)(v2 + 64) == 1))
		*(x_WORD *)(*(x_DWORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 36)] + 164) + 584) = 200;
	return sub_1C890(a1, 104);
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000236F0) --------------------------------------------------------
void sub_236F0(int a1)
{
	sub_1C930(a1);
}

//----- (00023710) --------------------------------------------------------
__int16 sub_23710(int a1)
{
	__int16 result; // ax

	LOBYTE(result) = sub_1C980(a1, 104);
	HIBYTE(result) = *(x_BYTE *)(a1 + 69);
	if (HIBYTE(result) != 110)
	{
		result = *(x_WORD *)(a1 + 134);
		*(x_WORD *)(a1 + 150) = 0;
		*(x_WORD *)(a1 + 130) = result;
	}
	return result;
}

//----- (00023750) --------------------------------------------------------
__int16 sub_23750(int a1)
{
	__int16 result; // ax

	sub_1D5D0(a1, 104);
	if (*(x_BYTE *)(a1 + 69) == 110)
		result = *(x_WORD *)(a1 + 132);
	else
		result = *(x_WORD *)(a1 + 134);
	*(x_WORD *)(a1 + 130) = result;
	return result;
}

//----- (00023790) --------------------------------------------------------
char sub_23790(int a1)
{
	*(x_BYTE *)(a1 + 69) = 113;
	return sub_237B0(a1);
}

//----- (000237B0) --------------------------------------------------------
char sub_237B0(int a1)
{
	unsigned int v1; // eax
	__int16 v2; // ax
	int i; // edx
	int v4; // edx
	int v5; // esi
	unsigned int v6; // edx
	unsigned __int16 v7; // di
	unsigned __int16 v8; // ax
	unsigned int v9; // edi
	unsigned int v10; // esi
	int v11; // edx
	unsigned int v12; // edx
	int v13; // esi

	v1 = 0;
	if (*(x_WORD *)(a1 + 98))
	{
		*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
		v2 = *(x_WORD *)(a1 + 98);
		*(x_WORD *)(a1 + 98) = 0;
		*(x_WORD *)(a1 + 38) = v2;
		v1 = 1;
	}
	else
	{
		*(x_WORD *)(a1 + 38) = 0;
	}
	if (*(x_WORD *)(a1 + 52))
	{
		for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52))
		{
			v5 = x_DWORD_EA3E4[i];
			if (v5 == x_DWORD_EA3E4[0])
				break;
			v4 = *(x_DWORD *)(v5 + 8);
			if (v4 < *(x_DWORD *)(a1 + 8))
			{
				*(x_DWORD *)(a1 + 8) = v4;
				*(x_WORD *)(a1 + 38) = *(x_WORD *)(v5 + 38);
				v1 = 1;
				break;
			}
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 0)
	{
		*(x_WORD *)(a1 + 36) = *(x_WORD *)(a1 + 38);
		v1 = 2;
	}
	if (v1 >= 1)
	{
		if (v1 <= 1)
		{
			v6 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 38)];
			if (v6 > x_DWORD_EA3E4[0] && (!*(x_BYTE *)(v6 + 64) || *(x_BYTE *)(v6 + 64) == 1))
				*(x_WORD *)(*(x_DWORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 38)] + 164) + 584) = 200;
			*(x_WORD *)(a1 + 150) = *(x_WORD *)(a1 + 38);
			LOBYTE(v1) = 118;
			*(x_BYTE *)(a1 + 69) = 118;
		}
		else if (v1 == 2)
		{
			LOBYTE(v1) = 116;
			*(x_BYTE *)(a1 + 69) = 116;
		}
		goto LABEL_44;
	}
	if (v1)
		goto LABEL_44;
	sub_1B8C0(a1);
	LOWORD(v1) = (signed __int16)*(unsigned __int8 *)(a1 + 62) / *(x_WORD *)(*(x_DWORD *)(a1 + 160) + 26);
	if (*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 26))
		goto LABEL_44;
	v7 = *(x_WORD *)(a1 + 150);
	if (v7)
	{
		v13 = x_DWORD_EA3E4[v7];
		if (*(x_BYTE *)(v13 + 63) == 10 && *(x_BYTE *)(v13 + 64) == 45)
		{
			if (sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(v13 + 76)) > 0x800)
			{
				LOWORD(v1) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v13 + 76));
				*(x_WORD *)(a1 + 32) = v1;
				goto LABEL_44;
			}
			if ((signed int)*(signed __int16 *)(v13 + 132) > *(x_DWORD *)(v13 + 16))
			{
				*(x_DWORD *)(a1 + 16) = 1;
				LOBYTE(v1) = 116;
				*(x_BYTE *)(a1 + 69) = 116;
				++*(x_DWORD *)(v13 + 16);
				goto LABEL_44;
			}
		}
		*(x_WORD *)(a1 + 150) = 0;
		LOWORD(v1) = *(x_WORD *)(a1 + 134);
		goto LABEL_43;
	}
	*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
	v8 = *(x_WORD *)(a1 + 20);
	*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
	*(x_WORD *)(a1 + 32) += ((*(x_WORD *)(a1 + 20) & 0xFF) + 85) * (2 * ((signed int)(v8 % 0x9Du) / 79) - 1);
	*(x_BYTE *)(a1 + 33) &= 7u;
	LOWORD(v1) = (signed __int16)*(unsigned __int8 *)(a1 + 62) / *(x_WORD *)(*(x_DWORD *)(a1 + 160) + 26);
	if (!(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 26)))
	{
		v9 = -1;
		v1 = x_D41A0_BYTEARRAY_4[0x967F];
		v10 = 0;
		while (v1 > x_DWORD_EA3E4[0])
		{
			if (x_BYTE_D93C2[4 * *(char *)(v1 + 70)] & 1)
			{
				v11 = (signed __int16)(*(x_WORD *)(v1 + 76) - *(x_WORD *)(a1 + 76));
				v12 = v11 * v11
					+ (signed __int16)(*(x_WORD *)(v1 + 78) - *(x_WORD *)(a1 + 78))
					* (signed __int16)(*(x_WORD *)(v1 + 78) - *(x_WORD *)(a1 + 78));
				if (v12 < v9 && v12 > 0xE100000)
				{
					v10 = v1;
					v9 = v12;
				}
			}
			v1 = *(x_DWORD *)v1;
		}
		if (v10)
		{
			*(x_WORD *)(a1 + 150) = (signed int)(v10 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
			LOWORD(v1) = *(x_WORD *)(a1 + 134) + 12;
		LABEL_43:
			*(x_WORD *)(a1 + 130) = v1;
			goto LABEL_44;
		}
	}
LABEL_44:
	if (*(x_BYTE *)(a1 + 69) == 118)
	{
		LOWORD(v1) = *(x_WORD *)(a1 + 132);
		*(x_WORD *)(a1 + 130) = v1;
	}
	return v1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00023AC0) --------------------------------------------------------
char sub_23AC0(int a1)
{
	*(x_BYTE *)(a1 + 69) = 113;
	return sub_237B0(a1);
}

//----- (00023AE0) --------------------------------------------------------
char sub_23AE0(int a1)
{
	*(x_BYTE *)(a1 + 69) = 113;
	return sub_237B0(a1);
}

//----- (00023B00) --------------------------------------------------------
void sub_23B00(int a1)
{
	//int result; // eax

	if (*(x_DWORD *)(a1 + 16))
		sub_57F10(a1);
	else
		sub_1C890(a1, 112);
	//return result;
}

//----- (00023B30) --------------------------------------------------------
void sub_23B30(int a1)
{
	unsigned int v1; // edx

	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 36)];
	if (v1 > x_DWORD_EA3E4[0] && (!*(x_BYTE *)(v1 + 64) || *(x_BYTE *)(v1 + 64) == 1))
		*(x_WORD *)(*(x_DWORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 36)] + 164) + 584) = 200;
	sub_1C930(a1);
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00023B90) --------------------------------------------------------
__int16 sub_23B90(int a1)
{
	__int16 result; // ax

	LOBYTE(result) = sub_1C980(a1, 112);
	HIBYTE(result) = *(x_BYTE *)(a1 + 69);
	if (HIBYTE(result) != 118)
	{
		result = *(x_WORD *)(a1 + 134);
		*(x_WORD *)(a1 + 150) = 0;
		*(x_WORD *)(a1 + 130) = result;
	}
	return result;
}

//----- (00023BD0) --------------------------------------------------------
__int16 sub_23BD0(int a1)
{
	__int16 result; // ax

	sub_1D5D0(a1, 112);
	if (*(x_BYTE *)(a1 + 69) == 118)
		result = *(x_WORD *)(a1 + 132);
	else
		result = *(x_WORD *)(a1 + 134);
	*(x_WORD *)(a1 + 130) = result;
	return result;
}

//----- (00023C20) --------------------------------------------------------
signed int sub_23C20(int a1)
{
	return sub_1BD90(a1, 120);
}

//----- (00023C40) --------------------------------------------------------
void sub_23C40(int a1)
{
	unsigned int v1; // esi
	__int16 v2; // ax
	int i; // eax
	int v4; // edx
	int v5; // eax
	int v6; // eax
	__int16 v7; // ax
	int v8; // esi
	int v9; // eax
	unsigned int v10; // esi
	int v11; // eax
	unsigned int v12; // edi
	signed int v13; // ST0C_4
	__int16 v14; // ax
	int v15; // eax
	unsigned int v16; // [esp+0h] [ebp-10h]
	unsigned int v17; // [esp+8h] [ebp-8h]
	unsigned int v18; // [esp+Ch] [ebp-4h]

	v1 = 0;
	if (*(x_WORD *)(a1 + 98))
	{
		*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
		v2 = *(x_WORD *)(a1 + 98);
		*(x_WORD *)(a1 + 98) = 0;
		v1 = 1;
		*(x_WORD *)(a1 + 38) = v2;
	}
	else
	{
		*(x_WORD *)(a1 + 38) = 0;
	}
	if (*(x_WORD *)(a1 + 52))
	{
		for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52))
		{
			v5 = x_DWORD_EA3E4[i];
			if (v5 == x_DWORD_EA3E4[0])
				break;
			v4 = *(x_DWORD *)(v5 + 8);
			if (v4 < *(x_DWORD *)(a1 + 8))
			{
				*(x_DWORD *)(a1 + 8) = v4;
				v1 = 1;
				*(x_WORD *)(a1 + 38) = *(x_WORD *)(v5 + 38);
				break;
			}
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 0)
	{
		v1 = 2;
		*(x_WORD *)(a1 + 36) = *(x_WORD *)(a1 + 38);
	}
	if (v1 < 1)
	{
		if (!v1)
		{
			sub_24190(a1);
			v8 = *(x_DWORD *)(a1 + 160);
			if (!(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(v8 + 26)))
			{
				if (*(x_BYTE *)(a1 + 57))
				{
					v9 = *(signed __int16 *)(v8 + 28) * *(signed __int16 *)(v8 + 28);
					v16 = -1;
					v18 = 0;
					v10 = x_D41A0_BYTEARRAY_4[0x9677];
					v17 = v9;
					while (v10 > x_DWORD_EA3E4[0])
					{
						if (*(x_WORD *)(v10 + 26) != *(x_WORD *)(a1 + 26))
						{
							v11 = (signed __int16)(*(x_WORD *)(v10 + 76) - *(x_WORD *)(a1 + 76));
							v12 = (signed __int16)(*(x_WORD *)(v10 + 78) - *(x_WORD *)(a1 + 78))
								* (signed __int16)(*(x_WORD *)(v10 + 78) - *(x_WORD *)(a1 + 78))
								+ v11 * v11;
							if (v12 <= v17 && !(*(x_BYTE *)(v10 + 12) & 0x20))
							{
								v13 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 30);
								v14 = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v10 + 76));
								if ((unsigned __int16)sub_582B0(*(x_WORD *)(a1 + 28), v14) < v13 && v12 < v16)
								{
									v18 = v10;
									v16 = v12;
								}
							}
						}
						v10 = *(x_DWORD *)v10;
					}
					if (v18)
					{
						v15 = v18 - (x_D41A0_BYTEARRAY_0[28302]);
						*(x_BYTE *)(a1 + 69) = 122;
						*(x_WORD *)(a1 + 150) = v15 / 168;
					}
				}
			}
		}
	}
	else if (v1 <= 1)
	{
		v6 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 38)];
		if (*(x_BYTE *)(v6 + 63) == 3 && *(x_WORD *)(v6 + 26) != *(x_WORD *)(a1 + 26))
		{
			v7 = *(x_WORD *)(a1 + 38);
			*(x_BYTE *)(a1 + 69) = 122;
			*(x_WORD *)(a1 + 150) = v7;
		}
		sub_1EEE0(a1);
	}
	else if (v1 == 2)
	{
		*(x_BYTE *)(a1 + 69) = 124;
	}
	if (*(x_BYTE *)(a1 + 69) == 122)
		sub_24100((x_WORD *)a1);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00023E60) --------------------------------------------------------
void sub_23E60(int a1)
{
	unsigned int v1; // esi
	__int16 v2; // ax
	int i; // eax
	int v4; // edx
	int v5; // eax
	unsigned int v6; // edi
	int v7; // esi
	unsigned int v8; // esi
	int v9; // eax
	int v10; // esi
	x_WORD *v11; // [esp+4h] [ebp-8h]
	x_WORD *v12; // [esp+8h] [ebp-4h]

	v1 = 0;
	if (*(x_WORD *)(a1 + 98))
	{
		*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
		v2 = *(x_WORD *)(a1 + 98);
		*(x_WORD *)(a1 + 98) = 0;
		v1 = 1;
		*(x_WORD *)(a1 + 38) = v2;
	}
	else
	{
		*(x_WORD *)(a1 + 38) = 0;
	}
	if (*(x_WORD *)(a1 + 52))
	{
		for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52))
		{
			v5 = x_DWORD_EA3E4[i];
			if (v5 == x_DWORD_EA3E4[0])
				break;
			v4 = *(x_DWORD *)(v5 + 8);
			if (v4 < *(x_DWORD *)(a1 + 8))
			{
				*(x_DWORD *)(a1 + 8) = v4;
				v1 = 1;
				*(x_WORD *)(a1 + 38) = *(x_WORD *)(v5 + 38);
				break;
			}
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 0)
	{
		v1 = 2;
		*(x_WORD *)(a1 + 36) = *(x_WORD *)(a1 + 38);
	}
	if (v1 <= 1)
	{
		v6 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
		if (!(*(x_BYTE *)(a1 + 62) & 3))
			*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v6 + 76));
		if (*(x_DWORD *)(v6 + 8) < 0 || *(x_BYTE *)(v6 + 13) & 4)
		{
			*(x_BYTE *)(a1 + 69) = 121;
			goto LABEL_26;
		}
		v7 = *(x_DWORD *)(a1 + 160);
		if (!(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(v7 + 26)))
		{
			v11 = (x_WORD *)(v6 + 76);
			v8 = *(signed __int16 *)(v7 + 28);
			v12 = (x_WORD *)(a1 + 76);
			if (sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(v6 + 76)) >= v8)
			{
				*(x_BYTE *)(a1 + 69) = 121;
				goto LABEL_26;
			}
			v9 = sub_4A190((int)v12, 9, 13);
			v10 = v9;
			if (v9)
			{
				*(x_WORD *)(v9 + 26) = *(x_WORD *)(a1 + 26);
				*(x_WORD *)(v9 + 28) = sub_581E0((Bit16u*)v12, (Bit16u*)v11);
				*(x_WORD *)(v10 + 30) = sub_58210(v12, v11);
				*(x_WORD *)(v10 + 80) += *(x_WORD *)(a1 + 88) / 2;
				*(x_WORD *)(v10 + 150) = *(x_WORD *)(a1 + 150);
				*(x_BYTE *)(v10 + 66) = *(x_BYTE *)(a1 + 66);
				*(x_BYTE *)(v10 + 65) = *(x_BYTE *)(a1 + 65);
				sub_5EF70(v6);
			}
		}
		sub_1EEE0(a1);
	}
	else if (v1 == 2)
	{
		*(x_BYTE *)(a1 + 69) = 124;
	}
LABEL_26:
	if (*(x_BYTE *)(a1 + 69) != 122)
		sub_24150((x_WORD *)a1);
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000240A0) --------------------------------------------------------
char sub_240A0(int a1)
{
	return sub_1C560(a1, 0x78u);
}

//----- (000240C0) --------------------------------------------------------
int sub_240C0(int a1)
{
	return sub_1C890(a1, 120);
}

//----- (000240E0) --------------------------------------------------------
void sub_240E0(int a1)
{
	sub_1C930(a1);
}

//----- (00024100) --------------------------------------------------------
int sub_24100(x_WORD *a1)
{
	signed int v1; // edx
	int result; // eax

	a1[10] = 9377 * a1[10] + 9439;
	v1 = (unsigned __int16)a1[10] % 0x14u;
	a1[65] = 0;
	if (v1 <= 10)
		result = sub_49CD0(a1, 206);
	else
		result = sub_49CD0(a1, 1);
	return result;
}

//----- (00024150) --------------------------------------------------------
int sub_24150(x_WORD *a1)
{
	a1[65] = a1[66];
	return sub_49CD0(a1, 0);
}

//----- (00024190) --------------------------------------------------------
signed int sub_24190(int a1)
{
	int v1; // esi
	signed int result; // eax
	unsigned __int16 v3; // ST04_2
	unsigned __int16 v4; // dx
	unsigned int v5; // esi
	int v6; // eax
	unsigned int i; // ecx
	int v8; // [esp+0h] [ebp-18h]
	int v9; // [esp+4h] [ebp-14h]
	int v10; // [esp+8h] [ebp-10h]
	int v11; // [esp+Ch] [ebp-Ch]
	int v12; // [esp+10h] [ebp-8h]
	char v13; // [esp+14h] [ebp-4h]

	v10 = 0;
	v8 = *(x_DWORD *)"X\x1BX\x1B\n";
	v9 = *(x_DWORD *)"\n";
	v12 = 1;
	if (!(*(unsigned __int8 *)(a1 + 62) % 8))
	{
		v1 = ~*(x_DWORD *)(*(x_DWORD *)(a1 + 160) + 20);
		result = (signed int)sub_104D0((signed __int16 *)(a1 + 76));
		if (result & v1)
		{
			*(x_BYTE *)(a1 + 69) = 124;
			return result;
		}
		LOWORD(result) = *(x_WORD *)(a1 + 28);
		while (1)
		{
			v11 = result;
			if ((unsigned __int16)v10 >= 4u)
				break;
			v3 = v11;
			*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
			*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
			sub_57FA0((x_WORD*)&x_WORD_EB398, v3, 0, 256);
			v4 = v10;
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			v5 = *(unsigned __int16 *)(a1 + 20) % (unsigned int)*((unsigned __int16 *)&v8 + v4);
			v6 = (v5 + 2) * (sub_102D0(a1, &x_WORD_EB398, 1) == 0);
			if ((unsigned __int16)v6 > (unsigned __int16)v12)
			{
				v12 = v6;
				*(x_WORD *)(a1 + 28) = v11;
			}
			result = v11;
			BYTE1(result) = (BYTE1(result) + 2) & 7;
			++v10;
		}
	}
	*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
	*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
	if (!(*(unsigned __int8 *)(a1 + 62) % 16))
	{
		switch (((*(unsigned __int16 *)(a1 + 28) - 256) >> 9) & 3)
		{
		case 0:
		case 2:
			x_WORD_EB39A = (x_WORD_EB39A >> 8 << 8) + 128;
			break;
		case 1:
		case 3:
			x_WORD_EB398 = (x_WORD_EB398 >> 8 << 8) + 128;
			break;
		default:
			break;
		}
	}
	v13 = 0;
	for (i = x_D41A0_BYTEARRAY_4[0x9603 + 4 * *(char *)(a1 + 64)]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
	{
		if (*(x_WORD *)(i + 26) != *(x_WORD *)(a1 + 26)
			&& abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(i + 76)) < 256
			&& abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(i + 78)) < 256)
		{
			*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(i + 76), (Bit16u*)(a1 + 76));
			v13 = 1;
			break;
		}
	}
	if (*(x_WORD *)(a1 + 32) == *(x_WORD *)(a1 + 28)
		|| (*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439,
		(signed int)(*(unsigned __int16 *)(a1 + 20) % 0x14u) <= 10))
	{
		sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), 0, *(x_WORD *)(a1 + 130));
		sub_57CF0(a1, (int)&x_WORD_EB398);
	}
	return sub_1EEE0(a1);
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39A: using guessed type __int16 x_WORD_EB39A;

//----- (00024400) --------------------------------------------------------
void sub_24400(int a1)
{
	sub_1D5D0(a1, 120);
}

//----- (00024420) --------------------------------------------------------
signed int sub_24420(int a1)
{
	return sub_1BD90(a1, 128);
}

//----- (00024440) --------------------------------------------------------
void sub_24440(int a1)
{
	int v1; // ecx
	int v2; // edx
	unsigned int v3; // esi
	unsigned int i; // eax
	int v5; // ecx
	unsigned int v6; // ecx
	int v7; // eax
	unsigned int v8; // [esp+4h] [ebp-4h]

	sub_1BF90(a1, 128);
	if (*(x_BYTE *)(a1 + 69) == -127)
	{
		v1 = *(x_DWORD *)(a1 + 160);
		v2 = *(unsigned __int8 *)(a1 + 62) % (*(signed __int16 *)(v1 + 26) + 1);
		if (!v2)
		{
			v8 = *(signed __int16 *)(v1 + 28) * *(signed __int16 *)(v1 + 28);
			v3 = -1;
			for (i = x_D41A0_BYTEARRAY_4[0x967F]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
			{
				v5 = (signed __int16)(*(x_WORD *)(i + 76) - *(x_WORD *)(a1 + 76));
				v6 = v5 * v5
					+ (signed __int16)(*(x_WORD *)(i + 78) - *(x_WORD *)(a1 + 78))
					* (signed __int16)(*(x_WORD *)(i + 78) - *(x_WORD *)(a1 + 78));
				if (v6 <= v8 && v6 < v3)
				{
					v2 = i;
					v3 = v6;
				}
			}
			if (v2)
			{
				v7 = (v2 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
				*(x_BYTE *)(a1 + 69) = -126;
				*(x_WORD *)(a1 + 150) = v7;
			}
		}
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00024510) --------------------------------------------------------
__int16 sub_24510(int a1)
{
	int v1; // eax
	unsigned int i; // eax
	unsigned int v3; // esi
	int v4; // edi
	unsigned int v5; // edi
	int v6; // eax
	int v7; // eax
	int v8; // esi
	__int16 v9; // ax
	int v10; // eax
	__int16 v11; // ax
	unsigned int v13; // [esp+4h] [ebp-8h]
	x_WORD *v14; // [esp+8h] [ebp-4h]

	v1 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 28);
	i = v1 * v1;
	v3 = 0;
	v13 = i;
	if (*(x_WORD *)(a1 + 98))
	{
		*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
		LOWORD(i) = *(x_WORD *)(a1 + 98);
		*(x_WORD *)(a1 + 98) = 0;
		v3 = 1;
		*(x_WORD *)(a1 + 38) = i;
	}
	else
	{
		*(x_WORD *)(a1 + 38) = 0;
	}
	if (*(x_WORD *)(a1 + 52))
	{
		for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v4 + 52))
		{
			v4 = x_DWORD_EA3E4[i];
			if (v4 == x_DWORD_EA3E4[0])
				break;
			i = *(x_DWORD *)(v4 + 8);
			if ((signed int)i < *(x_DWORD *)(a1 + 8))
			{
				*(x_DWORD *)(a1 + 8) = (x_DWORD)i;
				LOWORD(i) = *(x_WORD *)(v4 + 38);
				v3 = 1;
				*(x_WORD *)(a1 + 38) = i;
				break;
			}
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 0)
	{
		LOWORD(i) = *(x_WORD *)(a1 + 38);
		v3 = 2;
		*(x_WORD *)(a1 + 36) = i;
	}
	if (v3 < 1)
	{
		if (!v3)
		{
			sub_1B8C0(a1);
			i = sub_1ED30(a1, x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)]);
			v5 = i;
			if (i > x_DWORD_EA3E4[0])
			{
				if (!(*(x_BYTE *)(a1 + 62) & 7))
				{
					if (*(x_BYTE *)(i + 63) == 3 || (i = sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(i + 76)), i >= 0x200))
					{
						LOWORD(i) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v5 + 76));
						*(x_WORD *)(a1 + 32) = i;
					}
				}
				if (*(x_DWORD *)(v5 + 8) < 0 || *(x_BYTE *)(v5 + 13) & 4)
				{
					*(x_BYTE *)(a1 + 69) = -127;
				}
				else
				{
					v6 = *(x_DWORD *)(a1 + 16);
					if (v6)
					{
						*(x_DWORD *)(a1 + 16) = v6 - 1;
						v14 = (x_WORD *)(a1 + 76);
						v7 = sub_4A190(a1 + 76, 9, 0);
						v8 = v7;
						if (v7)
						{
							*(x_BYTE *)(v7 + 67) = 10;
							*(x_BYTE *)(v7 + 68) = 0;
							*(x_DWORD *)(v7 + 160) = (x_DWORD)&unk_D83F0;
							*(x_BYTE *)(v7 + 66) = *(x_BYTE *)(v5 + 64);
							*(x_BYTE *)(v7 + 65) = *(x_BYTE *)(v5 + 63);
							*(x_WORD *)(v7 + 26) = *(x_WORD *)(a1 + 26);
							*(x_WORD *)(v7 + 28) = sub_581E0((Bit16u*)v14, (Bit16u*)(v5 + 76));
							*(x_WORD *)(v8 + 30) = sub_58210(v14, (x_WORD *)(v5 + 76));
							*(x_WORD *)(v8 + 80) += 6 * *(x_WORD *)(a1 + 88);
							v9 = *(x_WORD *)(a1 + 150);
							*(x_WORD *)(v8 + 42) = 1600;
							*(x_DWORD *)(v8 + 144) = 50000;
							*(x_WORD *)(v8 + 150) = v9;
						}
					}
					LOWORD(i) = (signed __int16)*(unsigned __int8 *)(a1 + 62) / *(x_WORD *)(*(x_DWORD *)(a1 + 160) + 26);
					if (!(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 26)))
					{
						v10 = (signed __int16)(*(x_WORD *)(v5 + 76) - *(x_WORD *)(a1 + 76));
						i = v10 * v10
							+ (signed __int16)(*(x_WORD *)(v5 + 78) - *(x_WORD *)(a1 + 78))
							* (signed __int16)(*(x_WORD *)(v5 + 78) - *(x_WORD *)(a1 + 78));
						if (i < v13)
						{
							if (!(*(unsigned __int8 *)(a1 + 62) % (2 * *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 26))))
								sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 39);
							v11 = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v5 + 76));
							LOWORD(i) = sub_582B0(*(x_WORD *)(a1 + 28), v11);
							if ((unsigned __int16)i < 0xE3u)
							{
								*(x_DWORD *)(a1 + 16) = 15;
								LOWORD(i) = sub_5EF70(v5);
							}
						}
						else
						{
							*(x_BYTE *)(a1 + 69) = -127;
						}
					}
				}
			}
		}
	}
	else if (v3 <= 1)
	{
		LOWORD(i) = *(x_WORD *)(a1 + 38);
		*(x_WORD *)(a1 + 150) = i;
	}
	else if (v3 == 2)
	{
		*(x_BYTE *)(a1 + 69) = -124;
	}
	return i;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000247D0) --------------------------------------------------------
char sub_247D0(int a1)
{
	return sub_1C560(a1, 0x80u);
}

//----- (000247F0) --------------------------------------------------------
int sub_247F0(int a1)
{
	return sub_1C890(a1, 128);
}

//----- (00024810) --------------------------------------------------------
void sub_24810(int a1)
{
	sub_1C930(a1);
}

//----- (00024840) --------------------------------------------------------
void sub_24840(int a1)
{
	sub_1D5D0(a1, 128);
}

//----- (00024860) --------------------------------------------------------
unsigned int sub_24860(int a1)
{
	unsigned int result; // eax
	char v2; // dh

	result = sub_1BD90(a1, 136);
	BYTE1(result) = *(x_BYTE *)(a1 + 69);
	if (BYTE1(result) == -118)
	{
		result = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
		if (result <= x_DWORD_EA3E4[0] || *(x_BYTE *)(result + 63) != 3 || (v2 = *(x_BYTE *)(result + 64)) != 0 && v2 != 1)
			*(x_WORD *)(a1 + 150) = 0;
		*(x_BYTE *)(a1 + 70) = 0;
	}
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000248C0) --------------------------------------------------------
void sub_248C0(int a1)
{
	unsigned int v1; // eax
	char v2; // dh

	sub_1BF90(a1, 136);
	if (*(x_BYTE *)(a1 + 69) == -118)
	{
		v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
		if (v1 <= x_DWORD_EA3E4[0] || *(x_BYTE *)(v1 + 63) != 3 || (v2 = *(x_BYTE *)(v1 + 64)) != 0 && v2 != 1)
			*(x_WORD *)(a1 + 150) = 0;
		*(x_BYTE *)(a1 + 70) = 0;
	}
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00024930) --------------------------------------------------------
__int16 sub_24930(int a1)
{
	unsigned int v1; // eax
	__int16 v2; // ax
	int i; // ecx
	int v4; // edx
	unsigned int v5; // eax
	char v6; // al
	unsigned int j; // ecx
	signed int v8; // esi
	signed int v9; // eax
	__int16 v10; // ax
	int v11; // esi
	signed int v13; // [esp+0h] [ebp-10h]
	signed int v14; // [esp+4h] [ebp-Ch]
	unsigned int v15; // [esp+8h] [ebp-8h]

	sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 58);
	v1 = 0;
	if (*(x_WORD *)(a1 + 98))
	{
		*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
		v2 = *(x_WORD *)(a1 + 98);
		*(x_WORD *)(a1 + 98) = 0;
		*(x_WORD *)(a1 + 38) = v2;
		v1 = 1;
	}
	else
	{
		*(x_WORD *)(a1 + 38) = 0;
	}
	if (*(x_WORD *)(a1 + 52))
	{
		for (i = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 52)];
			i != x_DWORD_EA3E4[0];
			i = x_DWORD_EA3E4[*(unsigned __int16 *)(i + 52)])
		{
			v4 = *(x_DWORD *)(i + 8);
			if (v4 < *(x_DWORD *)(a1 + 8))
			{
				*(x_DWORD *)(a1 + 8) = v4;
				*(x_WORD *)(a1 + 38) = *(x_WORD *)(i + 38);
				v1 = 1;
				break;
			}
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 0)
	{
		*(x_WORD *)(a1 + 36) = *(x_WORD *)(a1 + 38);
		v1 = 2;
	}
	if (v1 < 1)
	{
		if (v1)
			return v1;
	}
	else
	{
		if (v1 > 1)
		{
			if (v1 == 2)
				*(x_BYTE *)(a1 + 69) = -116;
			return v1;
		}
		*(x_WORD *)(a1 + 150) = *(x_WORD *)(a1 + 38);
	}
	v13 = sub_1B8C0(a1);
	v5 = sub_1ED30(a1, x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)]);
	v15 = v5;
	if (v5 <= x_DWORD_EA3E4[0] || *(x_DWORD *)(v5 + 8) < 0 || *(x_BYTE *)(v5 + 13) & 4)
	{
		*(x_DWORD *)(a1 + 160) = (x_DWORD)&unk_D8720;
		*(x_WORD *)(a1 + 150) = 0;
		LOWORD(v1) = *(x_WORD *)(a1 + 132);
		*(x_BYTE *)(a1 + 69) = -119;
		*(x_WORD *)(a1 + 130) = v1;
	}
	else
	{
		if (!(*(x_BYTE *)(a1 + 62) & 3))
		{
			v6 = *(x_BYTE *)(a1 + 70);
			if (!v6 || v6 == 4)
			{
				*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v15 + 76));
				for (j = x_D41A0_BYTEARRAY_4[4 * *(char *)(a1 + 64)]; j > x_DWORD_EA3E4[0]; j = *(x_DWORD *)j)
				{
					if (*(x_WORD *)(j + 26) != *(x_WORD *)(a1 + 26)
						&& abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(j + 76)) < (signed int)*(signed __int16 *)(a1 + 84)
						&& abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(j + 78)) < (signed int)*(signed __int16 *)(a1 + 84))
					{
						*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(j + 76), (Bit16u*)(a1 + 76));
						break;
					}
				}
			}
		}
		LOWORD(v1) = *(unsigned __int8 *)(a1 + 70);
		switch ((x_BYTE)v1)
		{
		case 0:
			LOWORD(v1) = (signed __int16)*(unsigned __int8 *)(a1 + 62) / *(x_WORD *)(*(x_DWORD *)(a1 + 160) + 26);
			if (!(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 26)))
			{
				v1 = sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(v15 + 76));
				if (v1 >= *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 28))
				{
					*(x_BYTE *)(a1 + 69) = -119;
				}
				else if (v1 >= 0x700)
				{
					LOWORD(v1) = sub_1D0E0((x_WORD *)a1, v15);
				}
				else
				{
					*(x_BYTE *)(a1 + 70) = 1;
				}
			}
			return v1;
		case 1:
			LOWORD(v1) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v15 + 76));
			*(x_WORD *)(a1 + 32) = v1;
			*(x_WORD *)(a1 + 28) = v1;
			LOWORD(v1) = 3 * *(x_WORD *)(a1 + 132);
			*(x_DWORD *)(a1 + 160) = (x_DWORD)&unk_D8764;
			*(x_DWORD *)(a1 + 16) = 0;
			*(x_BYTE *)(a1 + 70) = 2;
			*(x_WORD *)(a1 + 130) = v1;
			return v1;
		case 2:
		case 3:
			if (v13 != 3)
				*(x_WORD *)(a1 + 28) = *(x_WORD *)(a1 + 32);
			v8 = *(x_DWORD *)(a1 + 16);
			if (v8 <= 4)
			{
				v9 = 192 >> *(x_BYTE *)(a1 + 16);
			}
			else
			{
				if (4 - (v8 - 4) <= 0)
				{
					v14 = -192;
					goto LABEL_49;
				}
				v9 = -(192 >> (4 - (v8 - 4)));
			}
			v14 = v9;
		LABEL_49:
			++*(x_DWORD *)(a1 + 16);
			v10 = *(x_WORD *)(a1 + 130);
			if (v10 > *(x_WORD *)(a1 + 134))
				*(x_WORD *)(a1 + 130) = v10 - 8;
			*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
			*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
			v11 = v14 + x_WORD_EB39C;
			LOWORD(v1) = sub_10C40(&x_WORD_EB398);
			if (v11 <= (signed __int16)v1)
			{
				*(x_BYTE *)(a1 + 70) = 4;
				*(x_DWORD *)(a1 + 16) = 18;
			}
			else
			{
				LOBYTE(v1) = v14;
				BYTE1(v1) = *(x_BYTE *)(a1 + 70);
				*(x_WORD *)(a1 + 80) += v14;
				if (BYTE1(v1) != 3)
				{
					LOWORD(v1) = sub_1CED0(a1, v15);
					if ((x_WORD)v1)
						*(x_BYTE *)(a1 + 70) = 3;
				}
			}
			break;
		case 4:
			v1 = *(x_DWORD *)(a1 + 16);
			*(x_DWORD *)(a1 + 16) = v1 - 1;
			if (v1)
			{
				if (v1 == 18)
				{
					LOWORD(v1) = *(x_WORD *)(a1 + 134);
					*(x_DWORD *)(a1 + 160) = (x_DWORD)&unk_D8720;
					*(x_WORD *)(a1 + 130) = v1;
				}
			}
			else
			{
				*(x_BYTE *)(a1 + 70) = 0;
				LOWORD(v1) = *(x_WORD *)(a1 + 132);
				*(x_WORD *)(a1 + 130) = v1;
			}
			return v1;
		default:
			return v1;
		}
	}
	return v1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (00024D40) --------------------------------------------------------
char sub_24D40(int a1)
{
	unsigned int v1; // eax
	char v2; // dh

	LOBYTE(v1) = sub_1C560(a1, 0x88u);
	if (*(x_BYTE *)(a1 + 69) == -118)
	{
		v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
		if (v1 <= x_DWORD_EA3E4[0] || *(x_BYTE *)(v1 + 63) != 3 || (v2 = *(x_BYTE *)(v1 + 64)) != 0 && v2 != 1)
			*(x_WORD *)(a1 + 150) = 0;
		*(x_BYTE *)(a1 + 70) = 0;
	}
	return v1;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00024DA0) --------------------------------------------------------
int sub_24DA0(int a1)
{
	return sub_1C890(a1, 136);
}

//----- (00024DC0) --------------------------------------------------------
void sub_24DC0(int a1)
{
	sub_1C930(a1);
}

//----- (00024DF0) --------------------------------------------------------
void sub_24DF0(int a1)
{
	sub_1D5D0(a1, 136);
	if (*(x_BYTE *)(a1 + 69) == -118)
		*(x_BYTE *)(a1 + 70) = 0;
}

//----- (00024E20) --------------------------------------------------------
int sub_24E20(int a1)
{
	int result; // eax
	int v2; // edx
	int v3; // eax
	unsigned int v4; // edi
	unsigned int v5; // esi
	int v6; // eax
	int v7; // ST10_4
	__int16 v8; // ax
	int v9; // eax
	int v10; // esi
	int v11; // eax
	unsigned int v12; // [esp+0h] [ebp-10h]
	unsigned int v13; // [esp+8h] [ebp-8h]
	unsigned int v14; // [esp+Ch] [ebp-4h]

	result = sub_252E0(a1);
	if (result)
	{
		if (result == 1)
			result = sub_253B0(1, a1, 2u, 0);
	}
	else
	{
		result = *(unsigned __int8 *)(a1 + 70);
		if ((x_BYTE)result)
		{
			if ((x_BYTE)result == 1 && *(x_WORD *)(a1 + 150))
			{
				v10 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
				v11 = sub_58490((x_WORD *)(a1 + 76), (x_WORD *)(v10 + 76));
				if (v11 < *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 28))
				{
					sub_254E0(a1, v10, 4u);
					*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
					result = *(unsigned __int16 *)(a1 + 20) / 0x31u;
					if (!(*(unsigned __int16 *)(a1 + 20) % 0x31u))
						result = sub_253B0(result, a1, 2u, 0);
				}
				else
				{
					*(x_WORD *)(a1 + 150) = 0;
					result = sub_253B0(v11, a1, 0, 0);
				}
			}
		}
		else
		{
			v2 = *(x_DWORD *)(a1 + 16) - 1;
			*(x_DWORD *)(a1 + 16) = v2;
			if (v2)
			{
				if (*(x_BYTE *)(a1 + 57))
				{
					*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
					result = *(x_WORD *)(a1 + 20) & 1;
					if (!result)
					{
						v3 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 28);
						result = v3 * v3;
						v13 = -1;
						v4 = 0;
						v5 = x_D41A0_BYTEARRAY_4[0x9677];
						v12 = result;
						while (v5 > x_DWORD_EA3E4[0])
						{
							v6 = (signed __int16)(*(x_WORD *)(v5 + 76) - *(x_WORD *)(a1 + 76));
							result = (signed __int16)(*(x_WORD *)(v5 + 78) - *(x_WORD *)(a1 + 78))
								* (signed __int16)(*(x_WORD *)(v5 + 78) - *(x_WORD *)(a1 + 78))
								+ v6 * v6;
							v14 = result;
							if (result <= v12 && !(*(x_BYTE *)(v5 + 12) & 0x20))
							{
								v7 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 30);
								v8 = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v5 + 76));
								result = (unsigned __int16)sub_582B0(*(x_WORD *)(a1 + 28), v8);
								if (result < v7)
								{
									result = v14;
									if (v14 < v13)
									{
										v4 = v5;
										v13 = v14;
									}
								}
							}
							v5 = *(x_DWORD *)v5;
						}
						if (v4 && *(x_BYTE *)(v4 + 63) == 3)
						{
							v9 = (signed int)(v4 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
							*(x_WORD *)(a1 + 150) = v9;
							result = sub_253B0(v9, a1, 0, 1u);
						}
					}
				}
			}
			else
			{
				result = sub_253B0(result, a1, 1u, 0);
			}
		}
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00025050) --------------------------------------------------------
int sub_25050(int a1)
{
	int result; // eax
	int v2; // edx

	result = sub_252E0(a1);
	if (result)
	{
		if (result == 1)
			result = sub_253B0(1, a1, 0, 1u);
	}
	else
	{
		*(x_WORD *)(a1 + 150) = 0;
		result = sub_1B8C0(a1);
		v2 = *(x_DWORD *)(a1 + 16) - 1;
		*(x_DWORD *)(a1 + 16) = v2;
		if (v2 <= 0)
			result = sub_253B0(result, a1, 0, 0);
	}
	return result;
}

//----- (000250B0) --------------------------------------------------------
__int16 sub_250B0(int a1)
{
	int v1; // eax
	int v2; // esi
	int v3; // edx
	int v4; // esi
	int v5; // eax
	int v6; // esi
	int v7; // ecx

	v1 = sub_252E0(a1);
	v2 = v1;
	if ((unsigned int)v1 <= 1)
	{
		v1 = *(unsigned __int8 *)(a1 + 70);
		switch ((x_BYTE)v1)
		{
		case 0:
			v1 = sub_254E0(a1, x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)], 4u);
			if (v2 == 1)
			{
				v3 = *(x_DWORD *)(a1 + 16) - 47;
				*(x_DWORD *)(a1 + 16) = v3;
				if (v3 < 0)
					LOWORD(v1) = sub_253B0(v1, a1, 2u, 1u);
			}
			else
			{
				*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
				v1 = *(unsigned __int16 *)(a1 + 20) / 0x29u;
				if (*(unsigned __int16 *)(a1 + 20) % 0x29u)
				{
					v4 = *(x_DWORD *)(a1 + 16) - 1;
					*(x_DWORD *)(a1 + 16) = v4;
					if (v4 < 0)
						LOWORD(v1) = sub_253B0(v1, a1, 2u, 2u);
				}
				else
				{
					LOWORD(v1) = sub_253B0(v1, a1, 2u, 1u);
				}
			}
			return v1;
		case 1:
			v5 = *(x_DWORD *)(a1 + 16) - 1;
			*(x_DWORD *)(a1 + 16) = v5;
			if (v5 <= 0)
				goto LABEL_17;
			LOWORD(v1) = (signed __int16)*(unsigned __int8 *)(a1 + 62) / *(x_WORD *)(*(x_DWORD *)(a1 + 160) + 26);
			if (!(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 26)))
			{
				v5 = sub_1ED30(a1, x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)]);
				v6 = v5;
				if ((unsigned int)v5 <= x_DWORD_EA3E4[0] || *(x_DWORD *)(v5 + 8) < 0 || *(x_BYTE *)(v5 + 13) & 4)
				{
				LABEL_17:
					LOWORD(v1) = sub_253B0(v5, a1, 2u, 2u);
				}
				else
				{
					*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v5 + 76));
					*(x_WORD *)(a1 + 28) += sub_58350(*(x_WORD *)(a1 + 28), *(x_WORD *)(a1 + 32), 5, 0x400u);
					*(x_BYTE *)(a1 + 29) &= 7u;
					LOWORD(v1) = sub_1D460((x_WORD *)a1, v6);
				}
			}
			break;
		case 2:
			v1 = *(x_DWORD *)(a1 + 16) - 1;
			*(x_DWORD *)(a1 + 16) = v1;
			if (v1 <= 0)
				LOWORD(v1) = sub_253B0(v1, a1, 2u, 3u);
			break;
		case 3:
			v7 = *(x_DWORD *)(a1 + 16) - 1;
			*(x_DWORD *)(a1 + 16) = v7;
			if (v7 < 0)
			{
				LOWORD(v1) = sub_253B0(v1, a1, 1u, 0);
			}
			else if (v7 >= 8)
			{
				*(x_WORD *)(a1 + 28) += 170;
				*(x_BYTE *)(a1 + 29) &= 7u;
				LOWORD(v1) = *(x_WORD *)(a1 + 28);
				*(x_WORD *)(a1 + 32) = v1;
			}
			break;
		default:
			return v1;
		}
	}
	return v1;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00025280) --------------------------------------------------------
int sub_25280(int a1, int a2)
{
	return sub_253B0(a1, a2, 0, 0);
}

//----- (000252A0) --------------------------------------------------------
int sub_252A0(int a1)
{
	return sub_1C890(a1, 144);
}

//----- (000252C0) --------------------------------------------------------
void sub_252C0(int a1)
{
	sub_1C930(a1);
}

//----- (000252E0) --------------------------------------------------------
unsigned int sub_252E0(int a1)
{
	__int16 v1; // ax
	__int16 v2; // dx
	unsigned int result; // eax
	__int16 v4; // ax
	int i; // edx
	int v6; // ecx
	int v7; // edx

	v1 = sub_10C40((__int16 *)(a1 + 76));
	v2 = *(x_WORD *)(a1 + 98);
	*(x_WORD *)(a1 + 80) = v1;
	result = 0;
	if (v2)
	{
		*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
		v4 = *(x_WORD *)(a1 + 98);
		*(x_WORD *)(a1 + 98) = 0;
		*(x_WORD *)(a1 + 38) = v4;
		result = 1;
	}
	else
	{
		*(x_WORD *)(a1 + 38) = 0;
	}
	if (*(x_WORD *)(a1 + 52))
	{
		for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v7 + 52))
		{
			v7 = x_DWORD_EA3E4[i];
			if (v7 == x_DWORD_EA3E4[0])
				break;
			v6 = *(x_DWORD *)(v7 + 8);
			if (v6 < *(x_DWORD *)(a1 + 8))
			{
				*(x_DWORD *)(a1 + 8) = v6;
				*(x_WORD *)(a1 + 38) = *(x_WORD *)(v7 + 38);
				result = 1;
				break;
			}
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 0)
	{
		*(x_WORD *)(a1 + 36) = *(x_WORD *)(a1 + 38);
		result = 2;
	}
	if (result >= 1)
	{
		if (result <= 1)
		{
			*(x_WORD *)(a1 + 150) = *(x_WORD *)(a1 + 38);
		}
		else if (result == 2)
		{
			*(x_BYTE *)(a1 + 69) = -108;
		}
	}
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000253B0) --------------------------------------------------------
int sub_253B0(int result, int a2, unsigned __int8 a3, unsigned __int8 a4)
{
	signed int v4; // esi
	unsigned __int64 v5; // rax
	unsigned __int64 v6; // rt2

	if (a3 < 1u)
	{
		if (!a3)
		{
			if (a4)
			{
				if (a4 != 1)
					goto LABEL_19;
				HIDWORD(v5) = 0;
				*(x_WORD *)(a2 + 20) = 9377 * *(x_WORD *)(a2 + 20) + 9439;
				WORD1(v5) = 0;
				v4 = 60;
			}
			else
			{
				v4 = 400;
				*(x_WORD *)(a2 + 20) = 9377 * *(x_WORD *)(a2 + 20) + 9439;
				v5 = 0i64;
			}
			LOWORD(v5) = *(x_WORD *)(a2 + 20);
			v6 = v5 % (unsigned int)v4;
			result = v5 / (unsigned int)v4;
			*(x_DWORD *)(a2 + 16) = v4 + v6;
		}
	LABEL_19:
		*(x_BYTE *)(a2 + 70) = a4;
		*(x_BYTE *)(a2 + 69) = a3 - 112;
		return result;
	}
	if (a3 <= 1u)
	{
		*(x_WORD *)(a2 + 20) = 9377 * *(x_WORD *)(a2 + 20) + 9439;
		result = *(unsigned __int16 *)(a2 + 20) / 0x190u;
		*(x_DWORD *)(a2 + 16) = *(unsigned __int16 *)(a2 + 20) % 0x190u + 400;
		*(x_BYTE *)(a2 + 70) = a4;
		*(x_BYTE *)(a2 + 69) = a3 - 112;
		return result;
	}
	if (a3 != 2 || a4 > 3u)
		goto LABEL_19;
	result = a4;
	switch (a4)
	{
	case 0u:
		*(x_WORD *)(a2 + 20) = 9377 * *(x_WORD *)(a2 + 20) + 9439;
		result = *(unsigned __int16 *)(a2 + 20) / 0xC8u;
		*(x_DWORD *)(a2 + 16) = *(unsigned __int16 *)(a2 + 20) % 0xC8u + 200;
		*(x_BYTE *)(a2 + 70) = a4;
		*(x_BYTE *)(a2 + 69) = -110;
		break;
	case 1u:
		*(x_DWORD *)(a2 + 16) = 10;
		*(x_BYTE *)(a2 + 70) = a4;
		*(x_BYTE *)(a2 + 69) = -110;
		break;
	case 2u:
		*(x_DWORD *)(a2 + 16) = 12;
		*(x_BYTE *)(a2 + 70) = a4;
		*(x_BYTE *)(a2 + 69) = -110;
		break;
	case 3u:
		*(x_DWORD *)(a2 + 16) = 14;
		goto LABEL_19;
	}
	return result;
}

//----- (000254E0) --------------------------------------------------------
int sub_254E0(int a1, int a2, unsigned __int8 a3)
{
	int v3; // ebx
	int result; // eax

	v3 = a1;
	*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(a2 + 76));
	result = sub_58350(*(x_WORD *)(v3 + 28), *(x_WORD *)(v3 + 32), 5, (a3 << 11) / 360);
	*(x_WORD *)(v3 + 28) += result;
	BYTE1(result) = *(x_BYTE *)(a1 + 29) & 7;
	*(x_BYTE *)(a1 + 29) = BYTE1(result);
	return result;
}

//----- (00025550) --------------------------------------------------------
int sub_25550(int a1)
{
	int result; // eax

	sub_1D5D0(a1, 144);
	result = sub_10C40((__int16 *)(a1 + 76));
	*(x_WORD *)(a1 + 80) = result;
	BYTE1(result) = *(x_BYTE *)(a1 + 69);
	if (BYTE1(result) == -110)
		result = sub_253B0(result, a1, 2u, 0);
	return result;
}

//----- (00025590) --------------------------------------------------------
signed int sub_25590(int a1)
{
	signed int result; // eax

	result = sub_1BD90(a1, 152);
	BYTE1(result) = *(x_BYTE *)(a1 + 69);
	if (BYTE1(result) == -102)
		*(x_BYTE *)(a1 + 70) = 0;
	return result;
}

//----- (000255C0) --------------------------------------------------------
void sub_255C0(int a1)
{
	sub_1BF90(a1, 152);
	if (*(x_BYTE *)(a1 + 69) == -102)
		*(x_BYTE *)(a1 + 70) = 0;
}

//----- (00025610) --------------------------------------------------------
void sub_25610(int a1)
{
	unsigned int v1; // eax
	__int16 v2; // ax
	int i; // edx
	int v4; // edx
	int v5; // ecx
	__int16 v6; // ax
	unsigned int v7; // eax
	__int16 v8; // ax
	__int16 v9; // ax
	char v10; // dh
	unsigned int j; // ecx
	__int16 v12; // cx
	int v13; // eax
	int v14; // edx
	unsigned int v15; // ecx
	unsigned int v16; // edx
	signed __int16 v17; // dx
	__int16 v18; // dx
	__int16 v19; // ST0C_2
	__int16 v20; // ax
	int v21; // edi
	unsigned int v22; // ecx
	int v23; // ecx
	char v24; // dh
	int v25; // ecx
	unsigned int v26; // esi
	__int16 v27; // ax
	__int16 v28; // ax
	int v29; // edx
	unsigned int v30; // ecx
	int v31; // ecx
	unsigned int v32; // esi
	__int16 v33; // ax
	unsigned __int16 *v34; // [esp+0h] [ebp-14h]

	v1 = 0;
	if (*(x_WORD *)(a1 + 98))
	{
		*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
		v2 = *(x_WORD *)(a1 + 98);
		*(x_WORD *)(a1 + 98) = 0;
		*(x_WORD *)(a1 + 38) = v2;
		v1 = 1;
	}
	else
	{
		*(x_WORD *)(a1 + 38) = 0;
	}
	if (*(x_WORD *)(a1 + 52))
	{
		for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52))
		{
			v5 = x_DWORD_EA3E4[i];
			if (v5 == x_DWORD_EA3E4[0])
				break;
			v4 = *(x_DWORD *)(v5 + 8);
			if (v4 < *(x_DWORD *)(a1 + 8))
			{
				*(x_DWORD *)(a1 + 8) = v4;
				*(x_WORD *)(a1 + 38) = *(x_WORD *)(v5 + 38);
				v1 = 1;
				break;
			}
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 0)
	{
		*(x_WORD *)(a1 + 36) = *(x_WORD *)(a1 + 38);
		v1 = 2;
	}
	if (v1 < 1)
	{
		if (!v1)
		{
			sub_1B8C0(a1);
			v7 = sub_1ED30(a1, x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)]);
			v34 = (unsigned __int16 *)v7;
			if (v7 <= x_DWORD_EA3E4[0] || *(x_DWORD *)(v7 + 8) < 0 || *(x_BYTE *)(v7 + 13) & 4)
			{
			LABEL_92:
				v33 = *(x_WORD *)(a1 + 132);
				*(x_BYTE *)(a1 + 69) = -103;
				*(x_WORD *)(a1 + 130) = v33;
			}
			else
			{
				switch (*(x_BYTE *)(a1 + 70))
				{
				case 0:
					v8 = *(x_WORD *)(a1 + 132);
					*(x_BYTE *)(a1 + 70) = 1;
					*(x_WORD *)(a1 + 130) = v8;
					goto LABEL_25;
				case 1:
				LABEL_25:
					*(x_DWORD *)&x_WORD_EB398 = *((x_DWORD *)v34 + 19);
					*(&x_WORD_EB398 + 2) = v34[40];
					*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
					sub_57FA0(
						&x_WORD_EB398,
						(v34[14] - 256 + (signed int)(*(unsigned __int16 *)(a1 + 20) % 0x5Au << 11) / 360) & 0x7FF,
						0,
						2048);
					if (sub_583F0((x_WORD *)(a1 + 76), &x_WORD_EB398) <= 0x500)
					{
						*(x_BYTE *)(a1 + 70) = 2;
					}
					else
					{
						v9 = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)&x_WORD_EB398);
						v10 = *(x_BYTE *)(a1 + 62);
						*(x_WORD *)(a1 + 32) = v9;
						if (v10 & 3)
							return;
						for (j = x_D41A0_BYTEARRAY_4[*(char *)(a1 + 64) + 38403]; j > x_DWORD_EA3E4[0]; j = *(x_DWORD *)j)
						{
							if (*(x_WORD *)(j + 26) != *(x_WORD *)(a1 + 26)
								&& abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(j + 76)) < (signed int)*(signed __int16 *)(a1 + 84)
								&& abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(j + 78)) < (signed int)*(signed __int16 *)(a1 + 84))
							{
								*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(j + 76), (Bit16u*)(a1 + 76));
								return;
							}
						}
					}
					return;
				case 2:
					v12 = *(x_WORD *)(a1 + 20);
					*(x_WORD *)(a1 + 130) = *(x_WORD *)(a1 + 134);
					*(x_WORD *)(a1 + 20) = 9377 * v12 + 9439;
					v13 = *(signed __int16 *)(v7 + 80);
					v14 = *(x_WORD *)(a1 + 20) & 0x3FF;
					*(x_BYTE *)(a1 + 70) = 3;
					*(x_DWORD *)(a1 + 16) = v14 + v13;
					goto LABEL_37;
				case 3:
				LABEL_37:
					*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v34 + 38));
					if (*(x_BYTE *)(a1 + 62) & 3)
						return;
					v15 = x_D41A0_BYTEARRAY_4[*(char *)(a1 + 64) + 38403];
					while (2)
					{
						if (v15 > x_DWORD_EA3E4[0])
						{
							if (*(x_WORD *)(v15 + 26) == *(x_WORD *)(a1 + 26)
								|| abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(v15 + 76)) >= (signed int)*(signed __int16 *)(a1 + 84)
								|| abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(v15 + 78)) >= (signed int)*(signed __int16 *)(a1 + 84))
							{
								v15 = *(x_DWORD *)v15;
								continue;
							}
							*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(v15 + 76), (Bit16u*)(a1 + 76));
						}
						break;
					}
					*(x_DWORD *)&x_WORD_EB398 = *((x_DWORD *)v34 + 19);
					*(&x_WORD_EB398 + 2) = v34[40];
					sub_57FA0((x_WORD*)&x_WORD_EB398, v34[14], 0, 2048);
					if (sub_583F0((x_WORD *)(a1 + 76), &x_WORD_EB398) > 0x500)
					{
					LABEL_57:
						*(x_BYTE *)(a1 + 70) = 0;
					}
					else
					{
						*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
						v16 = *(unsigned __int16 *)(a1 + 20) % 0x11Fu;
						if (!(v16 & 0x3F))
							*(x_BYTE *)(a1 + 70) = 6;
						if (!(v16 & 0x1F))
							*(x_BYTE *)(a1 + 70) = 7;
						if (!v16)
							*(x_BYTE *)(a1 + 70) = 4;
						if (!(v16 & 3))
						{
							if ((signed int)*(signed __int16 *)(a1 + 80) <= *(x_DWORD *)(a1 + 16))
								v17 = 64;
							else
								v17 = -64;
							*(x_WORD *)(a1 + 80) += v17;
						}
					}
					return;
				case 4:
					v27 = *(x_WORD *)(a1 + 132);
					*(x_BYTE *)(a1 + 70) = 5;
					*(x_WORD *)(a1 + 130) = v27;
					goto LABEL_81;
				case 5:
				LABEL_81:
					if (*(x_BYTE *)(a1 + 62) & 3)
						goto LABEL_89;
					v28 = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v34 + 38));
					v29 = (int)x_D41A0_BYTEARRAY_4;
					*(x_WORD *)(a1 + 32) = v28;
					v30 = *(x_DWORD *)(v29 + 4 * *(char *)(a1 + 64) + 38403);
					while (2)
					{
						if (v30 > x_DWORD_EA3E4[0])
						{
							if (*(x_WORD *)(v30 + 26) == *(x_WORD *)(a1 + 26)
								|| abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(v30 + 76)) >= (signed int)*(signed __int16 *)(a1 + 84)
								|| abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(v30 + 78)) >= (signed int)*(signed __int16 *)(a1 + 84))
							{
								v30 = *(x_DWORD *)v30;
								continue;
							}
							*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(v30 + 76), (Bit16u*)(a1 + 76));
						}
						break;
					}
				LABEL_89:
					v31 = *(x_DWORD *)(a1 + 160);
					if (*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(v31 + 26))
						return;
					v32 = *(signed __int16 *)(v31 + 28);
					if (sub_583F0((x_WORD *)(a1 + 76), (x_WORD*)(v34 + 38)) >= v32)
						goto LABEL_79;
					sub_1CC20((x_WORD *)a1, (unsigned int)v34);
					return;
				case 6:
					goto LABEL_92;
				case 7:
					v18 = *(x_WORD *)(a1 + 20);
					*(x_WORD *)(a1 + 130) = 3 * *(x_WORD *)(a1 + 132);
					*(x_WORD *)(a1 + 20) = 9377 * v18 + 9439;
					v19 = (*(x_WORD *)(a1 + 20) & 1) + 43;
					v20 = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
					*(x_DWORD *)(a1 + 16) = 24;
					*(x_BYTE *)(a1 + 70) = 8;
					sub_6E450(v20, -1, v19);
					goto LABEL_59;
				case 8:
				case 9:
				LABEL_59:
					v21 = *(x_DWORD *)(a1 + 16) - 1;
					*(x_DWORD *)(a1 + 16) = v21;
					if (!v21)
						goto LABEL_57;
					if (*(x_BYTE *)(a1 + 62) & 3)
						goto LABEL_70;
					if (v21 > 16)
						*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v34 + 38));
					v22 = x_D41A0_BYTEARRAY_4[*(char *)(a1 + 64) + 38403];
					break;
				default:
					return;
				}
				while (v22 > x_DWORD_EA3E4[0])
				{
					if (*(x_WORD *)(v22 + 26) != *(x_WORD *)(a1 + 26)
						&& abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(v22 + 76)) < (signed int)*(signed __int16 *)(a1 + 84)
						&& abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(v22 + 78)) < (signed int)*(signed __int16 *)(a1 + 84))
					{
						*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(v22 + 76), (Bit16u*)(a1 + 76));
						break;
					}
					v22 = *(x_DWORD *)v22;
				}
			LABEL_70:
				v23 = (signed __int16)v34[40] - *(signed __int16 *)(a1 + 80);
				if (abs(v23) > 64)
				{
					if (v23 <= 0)
						LOWORD(v23) = -64;
					else
						LOWORD(v23) = 64;
				}
				v24 = *(x_BYTE *)(a1 + 70);
				*(x_WORD *)(a1 + 80) += v23;
				if (v24 == 8 && (unsigned __int16)sub_1CED0(a1, (int)v34))
					*(x_BYTE *)(a1 + 70) = 9;
				v25 = *(x_DWORD *)(a1 + 160);
				if (!(*(unsigned __int8 *)(a1 + 62) % *(signed __int16 *)(v25 + 26)))
				{
					v26 = *(signed __int16 *)(v25 + 28);
					if (sub_583F0((x_WORD *)(a1 + 76), (x_WORD*)(v34 + 38)) >= v26)
						LABEL_79:
					*(x_BYTE *)(a1 + 70) = 6;
				}
			}
		}
	}
	else if (v1 <= 1)
	{
		v6 = *(x_WORD *)(a1 + 38);
		*(x_BYTE *)(a1 + 70) = 7;
		*(x_WORD *)(a1 + 150) = v6;
	}
	else if (v1 == 2)
	{
		*(x_BYTE *)(a1 + 69) = -100;
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;

//----- (00025CD0) --------------------------------------------------------
char sub_25CD0(int a1)
{
	char result; // al

	result = sub_1C560(a1, 0x98u);
	if (*(x_BYTE *)(a1 + 69) == -102)
		*(x_BYTE *)(a1 + 70) = 0;
	return result;
}

//----- (00025D00) --------------------------------------------------------
int sub_25D00(int a1)
{
	return sub_1C890(a1, 152);
}

//----- (00025D20) --------------------------------------------------------
void sub_25D20(int a1)
{
	sub_1C930(a1);
}

//----- (00025D50) --------------------------------------------------------
void sub_25D50(int a1)
{
	sub_1D5D0(a1, 152);
	if (*(x_BYTE *)(a1 + 69) == -102)
		*(x_BYTE *)(a1 + 70) = 0;
}

//----- (00025D80) --------------------------------------------------------
unsigned int sub_25D80(int a1)
{
	unsigned int result; // eax
	char v2; // dh

	result = sub_1BD90(a1, 160);
	BYTE1(result) = *(x_BYTE *)(a1 + 69);
	if (BYTE1(result) == -94)
	{
		result = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
		if (result <= x_DWORD_EA3E4[0] || *(x_BYTE *)(result + 63) != 3 || (v2 = *(x_BYTE *)(result + 64)) != 0 && v2 != 1)
			*(x_WORD *)(a1 + 150) = 0;
		*(x_BYTE *)(a1 + 70) = 0;
	}
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00025DE0) --------------------------------------------------------
void sub_25DE0(int a1)
{
	unsigned int v1; // eax
	char v2; // dh

	sub_1BF90(a1, 160);
	if (*(x_BYTE *)(a1 + 69) == -94)
	{
		v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
		if (v1 <= x_DWORD_EA3E4[0] || *(x_BYTE *)(v1 + 63) != 3 || (v2 = *(x_BYTE *)(v1 + 64)) != 0 && v2 != 1)
			*(x_WORD *)(a1 + 150) = 0;
		*(x_BYTE *)(a1 + 70) = 0;
	}
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00025E40) --------------------------------------------------------
void sub_25E40(int a1)
{
	unsigned int v1; // esi
	unsigned __int8 v2; // al
	char v3; // al
	bool v4; // zf
	__int16 v5; // dx
	int v6; // ecx
	__int16 v7; // ax
	char v8; // [esp+0h] [ebp-4h]

	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
	v8 = 0;
	if (v1 <= x_DWORD_EA3E4[0])
	{
		*(x_BYTE *)(a1 + 69) = -95;
		goto LABEL_21;
	}
	sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 32);
	v2 = *(x_BYTE *)(a1 + 70);
	if (v2 < 1u)
	{
		if (!v2)
		{
			v3 = sub_1C310(a1, 160, (unsigned __int16(*)(int, int))sub_1D1A0);
			if (*(x_BYTE *)(v1 + 63) != 3 || *(x_BYTE *)(v1 + 64))
				v4 = v3 == 0;
			else
				v4 = *(x_BYTE *)(*(x_DWORD *)(v1 + 164) + 334) == 0;
			if (!v4)
				*(x_BYTE *)(a1 + 70) = 1;
		}
	}
	else
	{
		if (v2 <= 1u)
		{
			*(x_BYTE *)(a1 + 70) = 2;
			v5 = *(x_WORD *)(a1 + 132);
			*(x_DWORD *)(a1 + 16) = 32;
			*(x_WORD *)(a1 + 130) = 2 * v5;
		}
		else if (v2 != 2)
		{
			goto LABEL_21;
		}
		if ((unsigned __int16)sub_1C310(a1, 160, (unsigned __int16(*)(int, int))sub_1CE80))
			v8 = 1;
		v6 = *(x_DWORD *)(a1 + 16) - 1;
		*(x_DWORD *)(a1 + 16) = v6;
		if (!v6)
			v8 = 1;
		if (v8)
		{
			v7 = *(x_WORD *)(a1 + 132);
			*(x_BYTE *)(a1 + 70) = 0;
			*(x_WORD *)(a1 + 130) = v7;
		}
	}
LABEL_21:
	if (*(x_BYTE *)(a1 + 69) != -94)
		*(x_WORD *)(a1 + 130) = *(x_WORD *)(a1 + 132);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00025F70) --------------------------------------------------------
char sub_25F70(int a1)
{
	unsigned int v1; // eax
	char v2; // dh

	LOBYTE(v1) = sub_1C560(a1, 0xA0u);
	if (*(x_BYTE *)(a1 + 69) == -94)
	{
		v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
		if (v1 <= x_DWORD_EA3E4[0] || *(x_BYTE *)(v1 + 63) != 3 || (v2 = *(x_BYTE *)(v1 + 64)) != 0 && v2 != 1)
			*(x_WORD *)(a1 + 150) = 0;
		*(x_BYTE *)(a1 + 70) = 0;
	}
	return v1;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00025FD0) --------------------------------------------------------
int sub_25FD0(int a1)
{
	return sub_1C890(a1, 160);
}

//----- (00025FF0) --------------------------------------------------------
void sub_25FF0(int a1)
{
	sub_1C930(a1);
}

//----- (00026020) --------------------------------------------------------
void sub_26020(int a1)
{
	sub_1D5D0(a1, 160);
	if (*(x_BYTE *)(a1 + 69) == -94)
		*(x_BYTE *)(a1 + 70) = 0;
}

//----- (00026050) --------------------------------------------------------
int sub_26050(int a1)
{
	return sub_268F0(a1, 1u);
}

//----- (00026070) --------------------------------------------------------
char sub_26070(int a1)
{
	signed int v1; // eax
	unsigned __int16 v2; // ax
	int v3; // eax
	unsigned int v4; // edi
	unsigned int v5; // esi
	int v6; // eax
	int v7; // edx
	int v8; // eax
	signed int v9; // ST08_4
	__int16 v10; // ax
	unsigned int v12; // [esp+4h] [ebp-Ch]
	unsigned int v13; // [esp+8h] [ebp-8h]
	unsigned int v14; // [esp+Ch] [ebp-4h]

	v1 = sub_26830(a1);
	if ((unsigned int)v1 <= 1)
	{
		sub_1B8C0(a1);
		sub_265A0(a1);
		LOBYTE(v1) = sub_26930(a1);
		if ((x_BYTE)v1)
		{
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			v2 = *(x_WORD *)(a1 + 20);
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			*(x_WORD *)(a1 + 28) += ((*(x_WORD *)(a1 + 20) & 0xFF) + 85) * (2 * ((signed int)(v2 % 0x9Du) / 79) - 1);
			*(x_BYTE *)(a1 + 29) &= 7u;
			LOWORD(v1) = *(x_WORD *)(a1 + 28);
			*(x_WORD *)(a1 + 32) = v1;
		}
		if (!(*(x_BYTE *)(a1 + 62) & 0x3F) && *(x_BYTE *)(a1 + 57))
		{
			v3 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 28);
			v1 = v3 * v3;
			v4 = 0;
			v13 = -1;
			v5 = x_D41A0_BYTEARRAY_4[0x9677];
			v12 = v1;
			while (v5 > x_DWORD_EA3E4[0])
			{
				v6 = (signed __int16)(*(x_WORD *)(v5 + 76) - *(x_WORD *)(a1 + 76));
				v7 = v6 * v6;
				v8 = (signed __int16)(*(x_WORD *)(v5 + 78) - *(x_WORD *)(a1 + 78));
				v1 = v8 * v8;
				v14 = v1 + v7;
				if (v1 + v7 <= v12 && !(*(x_BYTE *)(v5 + 12) & 0x20))
				{
					v9 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 30);
					v10 = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v5 + 76));
					v1 = (unsigned __int16)sub_582B0(*(x_WORD *)(a1 + 28), v10);
					if (v1 < v9)
					{
						LOBYTE(v1) = v14;
						if (v14 < v13)
						{
							v4 = v5;
							v13 = v14;
						}
					}
				}
				v5 = *(x_DWORD *)v5;
			}
			if (v4)
			{
				*(x_WORD *)(a1 + 150) = (signed int)(v4 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
				LOBYTE(v1) = sub_268F0(a1, 2u);
			}
		}
	}
	return v1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00026220) --------------------------------------------------------
unsigned int sub_26220(unsigned int a1, int a2)
{
	unsigned int result; // eax
	unsigned __int16 v3; // dx
	unsigned int v4; // eax
	unsigned int i; // ecx
	unsigned int v6; // edi
	char v7; // [esp+8h] [ebp-8h]
	char v8; // [esp+Ch] [ebp-4h]

	v7 = 1;
	v8 = 0;
	result = sub_26830(a2);
	if (result <= 1)
	{
		v3 = *(x_WORD *)(a2 + 150);
		if (v3)
		{
			v4 = sub_1ED30(a2, x_DWORD_EA3E4[v3]);
			a1 = v4;
			if (v4 <= x_DWORD_EA3E4[0] || *(x_DWORD *)(v4 + 8) < 0 || *(x_BYTE *)(v4 + 13) & 4)
				v7 = 0;
		}
		else
		{
			v7 = 0;
		}
		if (!v7)
			goto LABEL_26;
		if (sub_26930(a2))
		{
			*(x_WORD *)(a2 + 32) = sub_581E0((Bit16u*)(a2 + 76), (Bit16u*)(a1 + 76));
			if (!(*(x_BYTE *)(a2 + 62) & 3))
			{
				for (i = x_D41A0_BYTEARRAY_4[0x9603 + 4 * *(char *)(a2 + 64)]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
				{
					if (*(x_WORD *)(i + 26) != *(x_WORD *)(a2 + 26)
						&& abs(*(signed __int16 *)(a2 + 76) - *(signed __int16 *)(i + 76)) < (signed int)*(signed __int16 *)(a2 + 84)
						&& abs(*(signed __int16 *)(a2 + 78) - *(signed __int16 *)(i + 78)) < (signed int)*(signed __int16 *)(a2 + 84))
					{
						*(x_WORD *)(a2 + 32) = sub_581E0((Bit16u*)(i + 76), (Bit16u*)(a2 + 76));
						break;
					}
				}
			}
		}
		if (*(x_BYTE *)(a2 + 62) & 0x1F)
			goto LABEL_22;
		v6 = *(signed __int16 *)(*(x_DWORD *)(a2 + 160) + 28);
		if (sub_583F0((x_WORD *)(a2 + 76), (x_WORD *)(a1 + 76)) < v6)
			sub_1CC20((x_WORD *)a2, a1);
		else
			LABEL_26:
		v8 = 1;
	LABEL_22:
		sub_1B8C0(a2);
		result = sub_265A0(a2);
		if (v8)
			result = sub_268F0(a2, 1u);
	}
	return result;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000263C0) --------------------------------------------------------
int sub_263C0(int a1)
{
	return sub_268F0(a1, 1u);
}

//----- (000263E0) --------------------------------------------------------
int sub_263E0(int a1)
{
	return sub_1C890(a1, 168);
}

//----- (00026400) --------------------------------------------------------
void sub_26400(int a1)
{
	sub_1C930(a1);
}

//----- (00026470) --------------------------------------------------------
int sub_26470(x_BYTE *a1)
{
	int result; // eax

	sub_1D5D0((int)a1, 168);
	result = (unsigned __int8)(a1[73] - 1);
	switch (a1[73])
	{
	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
	case 6:
	case 7:
	case 8:
	case 9:
	case 0xA:
		result = sub_265A0((int)a1);
		break;
	case 0xD:
	case 0xE:
	case 0x10:
		a1[67] = 0;
		result = sub_265A0((int)a1);
		break;
	default:
		break;
	}
	BYTE1(result) = a1[69];
	if (BYTE1(result) != -81)
		result = sub_268F0((int)a1, BYTE1(result) + 88);
	return result;
}

//----- (00026500) --------------------------------------------------------
int sub_26500(int result, int a2)
{
	switch (*(x_BYTE *)(a2 + 70))
	{
	case 0:
		result = 311;
		break;
	case 1:
	case 2:
	case 3:
	case 9:
		result = 308;
		break;
	case 4:
		result = 309;
		break;
	case 5:
		result = 310;
		break;
	case 6:
		result = 305;
		break;
	case 7:
		result = 306;
		break;
	case 8:
		result = 307;
		break;
	case 0xA:
		result = 312;
		break;
	default:
		break;
	}
	if (*(signed __int16 *)(a2 + 90) != result)
		result = sub_49CD0((x_WORD *)a2, result);
	return result;
}

//----- (000265A0) --------------------------------------------------------
int sub_265A0(int a1)
{
	char v1; // dh
	__int16 v2; // dx
	int v3; // esi
	unsigned int v4; // esi
	unsigned int v5; // edx
	signed int v6; // esi
	__int16 v7; // cx
	int v8; // edi
	int v9; // eax
	int v10; // eax
	int result; // eax
	char v12; // [esp+0h] [ebp-8h]
	char v13; // [esp+4h] [ebp-4h]

	v12 = 0;
	v13 = 1;
	switch (*(x_BYTE *)(a1 + 70))
	{
	case 0:
	case 1:
		v1 = *(x_BYTE *)(a1 + 68);
		if (v1)
			*(x_BYTE *)(a1 + 68) = v1 - 1;
		else
			*(x_BYTE *)(a1 + 70) = 2;
		v12 = 1;
		v13 = 0;
		break;
	case 2:
		v12 = 1;
		*(x_BYTE *)(a1 + 70) = 3;
		v13 = 0;
		break;
	case 3:
		*(x_BYTE *)(a1 + 70) = 4;
		break;
	case 4:
		*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
		v2 = *(x_WORD *)(a1 + 20) % 0x64u;
		*(x_BYTE *)(a1 + 70) = 5;
		*(x_WORD *)(a1 + 44) = v2 + 140;
		break;
	case 5:
		if (*(x_WORD *)(a1 + 44) < 0)
			*(x_BYTE *)(a1 + 70) = 6;
		break;
	case 6:
		v3 = *(signed __int16 *)(a1 + 80);
		if (v3 - (signed __int16)sub_10C40((__int16 *)(a1 + 76)) < 230)
			*(x_BYTE *)(a1 + 70) = 7;
		break;
	case 7:
		*(x_BYTE *)(a1 + 70) = 8;
		v13 = 0;
		break;
	case 8:
		v12 = 1;
		*(x_BYTE *)(a1 + 70) = 9;
		v13 = 0;
		break;
	case 9:
		*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
		if (!(*(unsigned __int16 *)(a1 + 20) % 0xBu))
			sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 42);
		if (*(x_BYTE *)(a1 + 67))
		{
			v4 = *(char *)(a1 + 67);
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			v5 = *(unsigned __int16 *)(a1 + 20) % v4;
			*(x_BYTE *)(a1 + 68) = v5;
			*(x_BYTE *)(a1 + 70) = (v5 & 1) == 0;
		}
		else
		{
			*(x_BYTE *)(a1 + 68) = 1;
			*(x_BYTE *)(a1 + 70) = 0;
		}
		v12 = 1;
		v13 = 0;
		break;
	case 0xA:
		v12 = 1;
		break;
	default:
		break;
	}
	v6 = (signed __int16)sub_10C40((__int16 *)(a1 + 76));
	if (v12)
	{
		*(x_WORD *)(a1 + 80) -= 42;
	}
	else
	{
		v7 = *(x_WORD *)(a1 + 44) - 42;
		*(x_WORD *)(a1 + 80) += *(x_WORD *)(a1 + 44);
		*(x_WORD *)(a1 + 44) = v7;
	}
	if (*(signed __int16 *)(a1 + 80) < v6)
		*(x_WORD *)(a1 + 80) = v6;
	if (x_BYTE_D41B6)
	{
		v8 = *(signed __int16 *)(a1 + 88);
		v9 = (signed __int16)sub_10C60((__int16 *)(a1 + 76)) - v8;
		if (*(signed __int16 *)(a1 + 80) > v9)
		{
			*(x_WORD *)(a1 + 44) = 0;
			*(x_WORD *)(a1 + 80) = v9;
		}
	}
	if (sub_104D0((signed __int16 *)(a1 + 76)) == (int(*)())1)
	{
		if (*(x_BYTE *)(a1 + 70) == 10)
		{
			if (*(signed __int16 *)(a1 + 80) > v6)
				*(x_BYTE *)(a1 + 70) = 0;
		}
		else if (*(signed __int16 *)(a1 + 80) == v6)
		{
			*(x_BYTE *)(a1 + 70) = 10;
			sub_4A190((int)&x_WORD_EB398, 10, 5);
		}
		if (*(x_BYTE *)(a1 + 69) == -86)
			v10 = 66;
		else
			v10 = 40;
	}
	else
	{
		if (*(x_BYTE *)(a1 + 70) == 10)
			*(x_BYTE *)(a1 + 70) = 0;
		if (*(x_BYTE *)(a1 + 69) == -86)
			v10 = 96;
		else
			v10 = 60;
	}
	*(x_WORD *)(a1 + 130) = v10;
	result = sub_26500(v10, a1);
	if (!v13)
		*(x_BYTE *)(a1 + 13) |= 8u;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41B6: using guessed type char x_BYTE_D41B6;
// EB398: using guessed type __int16 x_WORD_EB398;

//----- (00026830) --------------------------------------------------------
signed int sub_26830(int a1)
{
	__int16 v1; // dx
	unsigned int v2; // ebx
	int i; // edx
	int v4; // ecx
	int v5; // edx

	v1 = *(x_WORD *)(a1 + 98);
	v2 = 0;
	if (v1)
	{
		*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
		v1 = *(x_WORD *)(a1 + 98);
		*(x_WORD *)(a1 + 98) = 0;
		v2 = 1;
	}
	*(x_WORD *)(a1 + 38) = v1;
	if (*(x_WORD *)(a1 + 52))
	{
		for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52))
		{
			v5 = x_DWORD_EA3E4[i];
			if (v5 == x_DWORD_EA3E4[0])
				break;
			v4 = *(x_DWORD *)(v5 + 8);
			if (v4 < *(x_DWORD *)(a1 + 8))
			{
				*(x_DWORD *)(a1 + 8) = v4;
				v2 = 1;
				*(x_WORD *)(a1 + 38) = *(x_WORD *)(v5 + 38);
				break;
			}
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 0)
	{
		v2 = 2;
		*(x_WORD *)(a1 + 36) = *(x_WORD *)(a1 + 38);
	}
	if (v2 >= 1)
	{
		if (v2 <= 1)
		{
			*(x_WORD *)(a1 + 150) = *(x_WORD *)(a1 + 38);
			sub_268F0(a1, 2u);
		}
		else if (v2 == 2)
		{
			*(x_BYTE *)(a1 + 69) = -84;
			return 2;
		}
	}
	return v2;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000268F0) --------------------------------------------------------
int sub_268F0(int a1, unsigned __int8 a2)
{
	int result; // eax

	result = a1;
	if (a2 >= 1u)
	{
		if (a2 <= 1u)
		{
			*(x_BYTE *)(a1 + 67) = 64;
			*(x_WORD *)(a1 + 150) = 0;
		}
		else if (a2 == 2)
		{
			*(x_BYTE *)(a1 + 67) = 0;
		}
	}
	*(x_BYTE *)(a1 + 69) = a2 - 88;
	return result;
}

//----- (00026930) --------------------------------------------------------
char sub_26930(int a1)
{
	char result; // al
	unsigned __int8 v2; // ah

	result = 0;
	v2 = *(x_BYTE *)(a1 + 70);
	if (v2 >= 9u && (v2 <= 9u || v2 == 10 && !(*(x_BYTE *)(a1 + 62) & 7)))
		result = 1;
	return result;
}

//----- (00026960) --------------------------------------------------------
void sub_26960(int a1)
{
	sub_26FF0(a1);
	sub_272C0(a1);
	sub_26F10(a1);
	sub_27880(a1);
}

//----- (00026990) --------------------------------------------------------
int sub_26990(int a1)
{
	__int16 v1; // si
	signed __int16 v2; // di
	int result; // eax
	int v4; // edx
	__int16 v5; // ax
	int v6; // [esp+0h] [ebp-1Ch]
	__int16 v7; // [esp+4h] [ebp-18h]
	int v8; // [esp+8h] [ebp-14h]
	__int16 v9; // [esp+10h] [ebp-Ch]
	char v10; // [esp+18h] [ebp-4h]

	v10 = 1;
	sub_26FF0(a1);
	sub_272C0(a1);
	v8 = *(x_DWORD *)(a1 + 16) >> 8;
	v1 = *(x_WORD *)(a1 + 16) & 0xFF;
	v2 = 0;
	result = sub_369F0(a1, *(x_WORD *)(a1 + 148));
	v9 = result;
	while (v2 < (signed __int16)((v1 != 0) + 1))
	{
		if (v2)
			v4 = -v1;
		else
			LOWORD(v4) = v1;
		v7 = v4 + v8;
		result = abs((signed __int16)(v4 + v8));
		if (result <= *(char *)(a1 + 70) / 2)
		{
			result = sub_27470(a1, v7);
			v6 = result;
			if (result)
			{
				v5 = sub_278F0(v9, *(char *)(a1 + 70), v7);
				result = sub_49D50(v6, v5);
				v10 = 0;
			}
		}
		++v2;
	}
	if (v10)
	{
		if (*(x_WORD *)(a1 + 148))
			*(x_BYTE *)(a1 + 69) = -78;
		else
			*(x_BYTE *)(a1 + 69) = -80;
	}
	else
	{
		result = (signed __int16)(v1 + 1);
		*(x_DWORD *)(a1 + 16) = result | ((signed __int16)v8 << 8);
	}
	return result;
}

//----- (00026AA0) --------------------------------------------------------
void sub_26AA0(int a1)
{
	unsigned __int16 v1; // dx
	int v2; // eax
	unsigned __int16 v3; // si
	int v4; // esi
	__int16 v5; // ax
	char v6; // ch
	char v7; // [esp+4h] [ebp-4h]

	v7 = 0;
	sub_26FF0(a1);
	sub_272C0(a1);
	sub_26F10(a1);
	sub_27880(a1);
	if (!(*(x_BYTE *)(a1 + 62) & 0x1F))
	{
		v1 = *(x_WORD *)(a1 + 148);
		if (!v1)
			goto LABEL_17;
		if (*(x_WORD *)(a1 + 130) > *(x_WORD *)(a1 + 134))
			goto LABEL_13;
		v2 = x_DWORD_EA3E4[v1];
		if (*(x_BYTE *)(v2 + 63) != 3)
			goto LABEL_17;
		if (*(x_DWORD *)(v2 + 8) < 0)
			goto LABEL_17;
		if (*(x_BYTE *)(v2 + 13) & 4)
			goto LABEL_17;
		v3 = *(x_WORD *)(*(x_DWORD *)(v2 + 164) + 58);
		if (!v3)
			goto LABEL_17;
		v4 = x_DWORD_EA3E4[v3];
		v5 = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v4 + 76));
		v6 = *(x_BYTE *)(a1 + 62);
		*(x_WORD *)(a1 + 32) = v5;
		if (v6 & 3 || sub_58490((x_WORD *)(a1 + 76), (x_WORD *)(v4 + 76)) > 0x100)
			goto LABEL_13;
		if (*(x_DWORD *)(a1 + 144) + *(x_DWORD *)(v4 + 144) < *(x_DWORD *)(v4 + 140))
		{
			*(x_DWORD *)(a1 + 16) = 128;
			*(x_BYTE *)(a1 + 69) = -77;
		}
		else
		{
		LABEL_17:
			v7 = 1;
		}
	LABEL_13:
		if (v7)
		{
			*(x_DWORD *)(a1 + 16) = 0;
			*(x_WORD *)(a1 + 148) = 0;
			*(x_BYTE *)(a1 + 69) = -79;
		}
	}
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00026BD0) --------------------------------------------------------
void sub_26BD0(int a1)
{
	int v1; // edx
	char v2; // dl
	int v3; // eax
	unsigned __int16 v4; // dx
	int v5; // eax
	int v6; // edi
	int v7; // edx

	sub_272C0(a1);
	v1 = *(x_DWORD *)(a1 + 16);
	if (v1)
	{
		*(x_DWORD *)(a1 + 16) = v1 - 1;
	}
	else if (!(*(x_BYTE *)(a1 + 62) & 1))
	{
		v2 = *(x_BYTE *)(a1 + 70);
		if (v2 > 1)
		{
			sub_27720(a1, v2 - 2);
		}
		else
		{
			v3 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 148)];
			if (*(x_BYTE *)(v3 + 63) == 3 && *(x_DWORD *)(v3 + 8) >= 0 && !(*(x_BYTE *)(v3 + 13) & 4))
			{
				v4 = *(x_WORD *)(*(x_DWORD *)(v3 + 164) + 58);
				if (v4)
				{
					v5 = x_DWORD_EA3E4[v4];
					v6 = *(x_DWORD *)(v5 + 140);
					v7 = *(x_DWORD *)(a1 + 144) + *(x_DWORD *)(v5 + 144);
					if (v7 >= v6)
						*(x_DWORD *)(v5 + 144) = v6;
					else
						*(x_DWORD *)(v5 + 144) = v7;
				}
			}
			sub_57F10(a1);
		}
	}
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00026CA0) --------------------------------------------------------
int sub_26CA0(int a1)
{
	sub_271D0(a1);
	return sub_26D20(a1);
}

//----- (00026CC0) --------------------------------------------------------
int sub_26CC0(int a1)
{
	int i; // ebx
	int v2; // ebx

	for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v2 + 52))
	{
		v2 = x_DWORD_EA3E4[i];
		if (v2 == x_DWORD_EA3E4[0])
			break;
		sub_36BA0(v2, 0);
		sub_57F10(v2);
	}
	sub_36BA0(a1, 0);
	sub_57F10(a1);
	return 1;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00026D20) --------------------------------------------------------
int sub_26D20(int a1)
{
	int v1; // ebx
	unsigned __int8 v2; // al
	__int16 v3; // ax
	int v4; // eax
	int v5; // ecx
	int v6; // eax
	int v7; // eax
	__int16 v8; // cx
	__int16 v9; // ax
	__int16 v10; // ax
	int i; // eax
	int v12; // eax

	if (*(x_BYTE *)(a1 + 57))
	{
		v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
		v2 = *(x_BYTE *)(v1 + 69);
		if (v2 >= 0xB0u && (v2 <= 0xB0u || v2 == -78))
		{
			if (*(x_WORD *)(a1 + 98))
			{
				*(x_WORD *)(v1 + 130) = ((*(signed __int16 *)(v1 + 132) - *(signed __int16 *)(v1 + 134)) >> 2)
					+ *(x_WORD *)(v1 + 134);
				v3 = sub_581E0((Bit16u*)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 98)] + 76), (Bit16u*)(a1 + 76));
				*(x_WORD *)(v1 + 28) = v3;
				*(x_WORD *)(v1 + 32) = v3;
				v4 = 56 * abs(*(char *)(a1 + 70)) / (*(char *)(v1 + 70) >> 1);
				if (((*(x_WORD *)(v1 + 28) - *(x_WORD *)(a1 + 44)) & 0x7FF) >= 1024)
					v4 = -v4;
				v5 = v4 + *(signed __int16 *)(v1 + 44);
				if (abs(v5) < 11)
				{
					if (v5 <= 0)
						v5 = -11;
					else
						v5 = 11;
				}
				if (abs(v5) > 227)
				{
					if (v5 <= 0)
						LOWORD(v5) = -227;
					else
						LOWORD(v5) = 227;
				}
				v6 = *(unsigned __int16 *)(v1 + 52);
				*(x_WORD *)(v1 + 44) = v5;
				while (1)
				{
					v7 = x_DWORD_EA3E4[v6];
					if (v7 == x_DWORD_EA3E4[0])
						break;
					*(x_WORD *)(v7 + 98) = 0;
					v6 = *(unsigned __int16 *)(v7 + 52);
				}
			}
			v8 = *(x_WORD *)(a1 + 104);
			if (v8)
			{
				if (v8 != *(x_WORD *)(v1 + 148))
				{
					if (*(x_DWORD *)(a1 + 100))
					{
						*(x_BYTE *)(v1 + 69) = -79;
						*(x_DWORD *)(v1 + 16) = *(char *)(a1 + 70) << 8;
						v10 = *(x_WORD *)(a1 + 104);
						*(x_WORD *)(v1 + 148) = v10;
						sub_6E450(v10, -1, 4);
						*(x_BYTE *)(a1 + 14) |= 0x20u;
					}
					else if (!(*(x_BYTE *)(a1 + 14) & 0x20))
					{
						*(x_BYTE *)(v1 + 69) = -79;
						*(x_DWORD *)(v1 + 16) = *(char *)(a1 + 70) << 8;
						v9 = *(x_WORD *)(a1 + 104);
						*(x_WORD *)(v1 + 148) = v9;
						sub_6E450(v9, -1, 4);
					}
				}
				for (i = *(unsigned __int16 *)(v1 + 52); ; i = *(unsigned __int16 *)(v12 + 52))
				{
					v12 = x_DWORD_EA3E4[i];
					if (v12 == x_DWORD_EA3E4[0])
						break;
					*(x_WORD *)(v12 + 104) = 0;
				}
			}
		}
	}
	return 0;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00026F10) --------------------------------------------------------
int sub_26F10(int a1)
{
	int v1; // eax
	signed __int16 v2; // cx
	__int16 v3; // si
	__int16 v4; // ax
	__int16 v5; // di
	__int16 v6; // ax

	if (*(x_BYTE *)(a1 + 57))
	{
		if (*(x_WORD *)(a1 + 98))
		{
			v1 = (*(x_DWORD *)(a1 + 94) >> 2) + *(signed __int16 *)(a1 + 130);
			v2 = *(x_WORD *)(a1 + 134);
			*(x_WORD *)(a1 + 130) = v1;
			if ((signed __int16)v1 < v2)
				*(x_WORD *)(a1 + 130) = v2;
			v3 = *(x_WORD *)(a1 + 132);
			if (*(x_WORD *)(a1 + 130) > v3)
				*(x_WORD *)(a1 + 130) = v3;
			v4 = sub_581E0((Bit16u*)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 98)] + 76), (Bit16u*)(a1 + 76));
			*(x_WORD *)(a1 + 98) = 0;
			*(x_WORD *)(a1 + 28) = v4;
			*(x_WORD *)(a1 + 32) = v4;
		}
		v5 = *(x_WORD *)(a1 + 104);
		if (v5)
		{
			if (v5 != *(x_WORD *)(a1 + 148))
			{
				v6 = *(x_WORD *)(a1 + 104);
				*(x_WORD *)(a1 + 148) = v6;
				*(x_BYTE *)(a1 + 69) = -79;
				*(x_DWORD *)(a1 + 16) = 0;
				sub_6E450(v6, -1, 4);
			}
			*(x_WORD *)(a1 + 104) = 0;
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 0)
		*(x_BYTE *)(a1 + 69) = -75;
	return 0;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00026FF0) --------------------------------------------------------
__int16 sub_26FF0(int a1)
{
	__int16 v1; // ax
	__int16 v2; // si
	__int16 v3; // di
	int v4; // eax
	int v5; // eax
	int v6; // esi
	__int16 v7; // si
	int v9; // [esp+0h] [ebp-10h]
	__int16 v10; // [esp+4h] [ebp-Ch]
	x_WORD *v11; // [esp+8h] [ebp-8h]
	int v12; // [esp+Ch] [ebp-4h]

	v1 = *(x_WORD *)(a1 + 130);
	if (v1 > *(x_WORD *)(a1 + 134))
		*(x_WORD *)(a1 + 130) = v1 - 2;
	v2 = *(x_WORD *)(a1 + 88);
	v3 = *(x_WORD *)(a1 + 84);
	sub_49EA0((x_WORD *)a1, *(char *)(a1 + 70) << 8, *(x_WORD *)(a1 + 88));
	sub_1B8C0(a1);
	if (!(*(x_BYTE *)(a1 + 62) & 0xF))
		sub_27120(a1);
	v11 = (x_WORD *)a1;
	v12 = 0;
	sub_49EA0((x_WORD *)a1, v3, v2);
	while (v11 != (x_WORD *)x_DWORD_EA3E4[0])
	{
		v4 = sub_10C40(v11 + 38);
		if ((signed __int16)v4 > (signed __int16)v12)
		{
			v12 = v4;
			v9 = *((x_DWORD *)v11 + 19);
			v10 = v11[40];
		}
		v11 = (x_WORD *)x_DWORD_EA3E4[(unsigned __int16)v11[26]];
	}
	v12 += 384;
	LOWORD(v5) = *(x_WORD *)(a1 + 80);
	if ((signed __int16)v5 >= (signed __int16)v12)
	{
		v7 = *(x_WORD *)(a1 + 36);
		if (v7)
		{
			LOWORD(v5) = v7 - 1;
			*(x_WORD *)(a1 + 36) = v7 - 1;
		}
		else
		{
			*(x_WORD *)(a1 + 80) = v5 - 2;
		}
	}
	else
	{
		v6 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 16);
		v5 = sub_1B7A0((signed __int16 *)&v9);
		if (v5 > v6)
			++*(x_BYTE *)(a1 + 81);
		else
			*(x_WORD *)(a1 + 80) += 64;
		*(x_WORD *)(a1 + 36) = 64;
	}
	return v5;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00027120) --------------------------------------------------------
int sub_27120(int a1)
{
	int v1; // edi
	int v2; // esi
	unsigned int v3; // ecx
	__int16 v5; // ax

	v1 = 2 * *(signed __int16 *)(a1 + 88) + 32;
	v2 = 2 * *(signed __int16 *)(a1 + 84);
	v3 = x_D41A0_BYTEARRAY_4[0x9603 + 4 * *(char *)(a1 + 64)];
	if (v3 <= x_DWORD_EA3E4[0])
		return 0;
	do
	{
		if (*(x_WORD *)(v3 + 26) != *(x_WORD *)(a1 + 26)
			&& abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(v3 + 76)) < v2
			&& abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(v3 + 78)) < v2
			&& abs(*(signed __int16 *)(a1 + 80) - *(signed __int16 *)(v3 + 80)) < v1)
		{
			v5 = *(x_WORD *)(a1 + 80);
			if (v5 >= *(x_WORD *)(v3 + 80))
				*(x_WORD *)(a1 + 80) = v5 + 64;
		}
		v3 = *(x_DWORD *)v3;
	} while (v3 > x_DWORD_EA3E4[0]);
	return 0;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000271D0) --------------------------------------------------------
signed int sub_271D0(int a1)
{
	signed int result; // eax
	int v2; // eax
	__int16 v3; // si
	unsigned __int16 v4; // ax
	int v5; // ebx
	unsigned __int16 v6; // cx

	result = a1;
	if (*(x_WORD *)(a1 + 150))
	{
		v2 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
		v3 = *(x_WORD *)(v2 + 42);
		v4 = (v3 + sub_273C0(*(unsigned __int8 *)(v2 + 92), *(x_WORD *)(v2 + 54), *(char *)(a1 + 70), *(char *)(v2 + 70))) & 0x7FF;
		*(x_WORD *)(a1 + 44) = v4;
		v5 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 50)];
		if (v5)
		{
			v6 = *(x_WORD *)(v5 + 50);
			if (v6)
				v5 = x_DWORD_EA3E4[v6];
		}
		*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(v5 + 76);
		*(&x_WORD_EB398 + 2) = *(x_WORD *)(v5 + 80);
		sub_57FA0((x_WORD*)&x_WORD_EB398, v4, 0, *(x_WORD *)(a1 + 84) + *(x_WORD *)(v5 + 84));
		x_WORD_EB39C = *(x_WORD *)(v5 + 84) - *(x_WORD *)(a1 + 84) + *(x_WORD *)(v5 + 80);
		result = sub_57CF0(a1, (int)&x_WORD_EB398);
	}
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (000272C0) --------------------------------------------------------
char sub_272C0(int a1)
{
	signed __int16 v1; // ax
	unsigned __int8 v2; // dl
	unsigned __int8 v3; // ch
	char v4; // ah
	char v5; // dl
	int v6; // eax
	int v7; // edx
	signed __int16 v9; // [esp+0h] [ebp-4h]

	if (*(x_BYTE *)(a1 + 70) >= 11)
	{
		v1 = sub_27430(*(unsigned __int8 *)(a1 + 92));
		v2 = *(x_BYTE *)(a1 + 92);
		v9 = v1;
		if (v2 && v2 < 0x10u)
			sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 48);
		if (*(x_BYTE *)(a1 + 54) & 1)
		{
			v3 = v9 + *(x_BYTE *)(a1 + 92);
			*(x_BYTE *)(a1 + 92) = v3;
			if (v3 > 0x64u)
			{
				v4 = *(x_BYTE *)(a1 + 54);
				*(x_BYTE *)(a1 + 92) = 100;
				*(x_BYTE *)(a1 + 54) = v4 & 0xFE;
			}
		}
		else if (*(unsigned __int8 *)(a1 + 92) > v9)
		{
			*(x_BYTE *)(a1 + 92) -= v9;
		}
		else
		{
			v5 = *(x_BYTE *)(a1 + 54) | 1;
			*(x_BYTE *)(a1 + 54) = v5;
			*(x_BYTE *)(a1 + 92) = 0;
			*(x_BYTE *)(a1 + 54) = v5 ^ 2;
		}
	}
	*(x_WORD *)(a1 + 42) += *(x_WORD *)(a1 + 44);
	LOBYTE(v6) = *(x_BYTE *)(a1 + 62);
	*(x_BYTE *)(a1 + 43) &= 7u;
	if (!(v6 & 3))
	{
		v6 = abs(*(signed __int16 *)(a1 + 44)) - 5;
		if ((signed __int16)v6 < 11)
			LOWORD(v6) = 11;
		if (*(x_WORD *)(a1 + 44) <= 0)
			v7 = -(signed __int16)v6;
		else
			LOWORD(v7) = v6;
		*(x_WORD *)(a1 + 44) = v7;
	}
	return v6;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (000273C0) --------------------------------------------------------
int sub_273C0(__int16 a1, char a2, __int16 a3, __int16 a4)
{
	__int16 v4; // ax
	int result; // eax
	__int16 v6; // ax

	v4 = abs(a3);
	result = ((15 - a4) * v4 + v4 * a1) & 0x7FF;
	if (a3 >= 0)
	{
		if (a2 & 2)
			return result;
		v6 = 2048 - result;
	}
	else if (a2 & 2)
	{
		v6 = 1024 - result;
	}
	else
	{
		v6 = result + 1024;
	}
	return v6 & 0x7FF;
}

//----- (00027430) --------------------------------------------------------
int sub_27430(int a1)
{
	int v1; // eax

	HIWORD(v1) = HIWORD(a1);
	if ((signed __int16)a1 >= 96)
		return 2;
	if ((signed __int16)a1 >= 87)
		return 3;
	if ((signed __int16)a1 >= 60)
		return 4;
	LOBYTE(v1) = (signed __int16)a1 < 30;
	BYTE1(v1) = 0;
	return v1 + 5;
}

//----- (00027470) --------------------------------------------------------
int sub_27470(int a1, __int16 a2)
{
	int result; // eax

	result = a1;
	if (a2)
	{
		while (1)
		{
			result = x_DWORD_EA3E4[*(unsigned __int16 *)(result + 52)];
			if (result == x_DWORD_EA3E4[0])
				break;
			if (*(char *)(result + 70) == a2)
				return result;
		}
		result = 0;
	}
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000274C0) --------------------------------------------------------
int sub_274C0(int a1, int a2, x_WORD *a3, __int16 a4)
{
	int v4; // edx
	int v5; // eax

	qmemcpy((void *)a2, a3, 0xA8u);
	v4 = a2 - (x_D41A0_BYTEARRAY_0[28302]);
	*(x_WORD *)(a2 + 50) = (signed int)((char *)a3 - (char *)x_D41A0_BYTEARRAY_0 - 28302) / 168;
	a3[26] = v4 / 168;
	*(x_WORD *)(a2 + 52) = 0;
	*(x_BYTE *)(a2 + 62) = abs((x_BYTE)a4) & 1;
	*(x_BYTE *)(a2 + 12) &= 0xFBu;
	*(x_BYTE *)(a2 + 70) = a4;
	v5 = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
	*(x_BYTE *)(a2 + 69) = -76;
	*(x_WORD *)(a2 + 44) = 0;
	*(x_WORD *)(a2 + 148) = 0;
	*(x_DWORD *)(a2 + 144) = 0;
	*(x_WORD *)(a2 + 150) = v5;
	*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
	*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
	sub_57D70(a2, (int)&x_WORD_EB398);
	return sub_49A20(a2);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EB398: using guessed type __int16 x_WORD_EB398;

//----- (00027590) --------------------------------------------------------
int sub_27590(signed int a1, int a2)
{
	__int16 v2; // ax
	__int16 v3; // di
	__int16 v4; // ax
	int result; // eax
	__int16 v6; // ax
	int v7; // ebx

	v2 = sub_369F0(a1, *(x_WORD *)(a2 + 148));
	v3 = v2;
	v4 = sub_278F0(v2, *(char *)(a2 + 70), 0);
	sub_49D50(a2, v4);
	for (result = *(unsigned __int16 *)(a2 + 52); ; result = *(unsigned __int16 *)(v7 + 52))
	{
		v7 = x_DWORD_EA3E4[result];
		if (v7 == x_DWORD_EA3E4[0])
			break;
		v6 = sub_278F0(v3, *(char *)(a2 + 70), *(char *)(v7 + 70));
		sub_49D50(v7, v6);
	}
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00027610) --------------------------------------------------------
int sub_27610(signed int a1, int a2)
{
	__int16 v2; // di
	__int64 v3; // rtt
	int result; // eax
	__int64 v5; // rtt
	int v6; // ebx

	v2 = sub_369F0(a1, *(x_WORD *)(a2 + 148));
	v3 = 550 * (unsigned __int16)x_WORD_D9524[7 * (signed __int16)sub_278F0(v2, *(char *)(a2 + 70), 0)];
	sub_49EA0((x_WORD *)a2, v3 / 1000, v3 / 1000);
	for (result = *(unsigned __int16 *)(a2 + 52); ; result = *(unsigned __int16 *)(v6 + 52))
	{
		v6 = x_DWORD_EA3E4[result];
		if (v6 == x_DWORD_EA3E4[0])
			break;
		v5 = 550 * (unsigned __int16)x_WORD_D9524[7 * (signed __int16)sub_278F0(v2, *(char *)(a2 + 70), *(char *)(v6 + 70))];
		sub_49EA0((x_WORD *)v6, v5 / 1000, v5 / 1000);
	}
	return result;
}
// D9524: using guessed type __int16 x_WORD_D9524[];
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000276E0) --------------------------------------------------------
signed int sub_276E0(signed int a1)
{
	signed int result; // eax
	int i; // ebx
	int v3; // ebx

	result = a1;
	for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v3 + 52))
	{
		v3 = x_DWORD_EA3E4[i];
		if (v3 == x_DWORD_EA3E4[0])
			break;
		result = sub_271D0(v3);
	}
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00027720) --------------------------------------------------------
void sub_27720(int a1, signed __int16 a2)
{
	signed int i; // ebx
	signed __int16 v3; // di
	x_WORD *v4; // edi
	__int16 v5; // ST0C_2
	int v6; // ebx
	int v7; // eax
	int v8; // ST10_4
	int v9; // [esp+4h] [ebp-Ch]
	int v10; // [esp+8h] [ebp-8h]
	char v11; // [esp+Ch] [ebp-4h]

	LOBYTE(a2) = a2 | 1;
	v11 = 0;
	if (a2 >= 1 && a2 <= 15 && *(char *)(a1 + 70) != a2)
	{
		for (i = a1; ; i = x_DWORD_EA3E4[*(unsigned __int16 *)(i + 52)])
		{
			v3 = *(x_WORD *)(i + 52);
			if (!v3)
				break;
		}
		if (*(char *)(a1 + 70) >= a2)
		{
			v10 = (*(char *)(a1 + 70) - a2) / 2;
			while (v3 < (signed __int16)v10)
			{
				v6 = x_DWORD_EA3E4[*(unsigned __int16 *)(i + 50)];
				v7 = v6;
				i = x_DWORD_EA3E4[*(unsigned __int16 *)(v6 + 50)];
				*(x_WORD *)(i + 52) = 0;
				v8 = x_DWORD_EA3E4[*(unsigned __int16 *)(v7 + 52)];
				sub_57F10(v7);
				++v3;
				sub_57F10(v8);
			}
		}
		else
		{
			v4 = (x_WORD *)sub_4A050();
			if (v4)
			{
				v9 = sub_4A050();
				if (v9)
				{
					sub_274C0(a1, (int)v4, (x_WORD *)i, abs(*(char *)(i + 70)) + 1);
					v5 = -(abs(*(char *)(i + 70)) + 1);
					i = v9;
					sub_274C0(a1, v9, v4, v5);
				}
				else
				{
					sub_57F10((int)v4);
					v11 = 1;
				}
			}
			else
			{
				v11 = 1;
			}
		}
		if (!v11)
		{
			*(x_BYTE *)(a1 + 70) = a2;
			sub_27590(i, a1);
			sub_27610(i, a1);
		}
	}
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00027880) --------------------------------------------------------
void sub_27880(int a1)
{
	__int16 v1; // dx
	char v2; // ah
	signed int v3; // edx

	v1 = *(x_WORD *)(a1 + 150);
	if (v1)
	{
		*(x_WORD *)(a1 + 150) = v1 - 1;
	}
	else
	{
		v2 = *(x_BYTE *)(a1 + 70);
		*(x_WORD *)(a1 + 150) = 1024;
		if (v2 <= 13)
			sub_27720(a1, v2 + 2);
		v3 = *(x_DWORD *)(a1 + 144);
		if (v3 < 50000)
			*(x_DWORD *)(a1 + 144) = v3 + 1000;
	}
}

//----- (000278F0) --------------------------------------------------------
int sub_278F0(int a1, __int16 a2, __int16 a3)
{
	int v3; // eax

	v3 = (signed __int16)abs(a3);
	LOWORD(v3) = (unsigned __int8)x_BYTE_D400C[8 * (signed __int16)(a2 >> 1) + (signed __int16)v3];
	return a1 + v3;
}

//----- (00027930) --------------------------------------------------------
void sub_27930(int a1)
{
	sub_1D5D0(a1, 176);
}

//----- (00027950) --------------------------------------------------------
char sub_27950(int a1)
{
	unsigned int i; // ecx
	int v2; // ecx
	signed __int16 v3; // cx
	unsigned __int8 v4; // cl
	int v5; // eax
	unsigned int v6; // eax
	int v7; // eax
	__int16 v8; // ax
	x_WORD *v9; // edi
	char v11; // [esp-Ch] [ebp-10h]
	char v12; // [esp-8h] [ebp-Ch]
	int v13; // [esp-4h] [ebp-8h]

	sub_1B8C0(a1);
	for (i = x_D41A0_BYTEARRAY_4[*(char *)(a1 + 64) + 38403]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
	{
		if (*(x_WORD *)(i + 26) != *(x_WORD *)(a1 + 26)
			&& abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(i + 76)) < (signed int)*(signed __int16 *)(a1 + 84)
			&& abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(i + 78)) < (signed int)*(signed __int16 *)(a1 + 84))
		{
			*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(i + 76), (Bit16u*)(a1 + 76));
			break;
		}
	}
	v2 = *(signed __int16 *)(a1 + 80) - *(signed __int16 *)(a1 + 44);
	if (abs(v2) >= 256)
	{
		if (v2 <= 0)
			v3 = 32;
		else
			v3 = -32;
		*(x_WORD *)(a1 + 80) += v3;
	}
	v4 = *(x_BYTE *)(a1 + 70);
	if (v4 < 1u)
	{
		if (v4)
			return sub_28110(a1);
		*(x_WORD *)(a1 + 130) = *(x_WORD *)(a1 + 134);
		v5 = *(x_DWORD *)(a1 + 16);
		*(x_DWORD *)(a1 + 16) = v5 - 1;
		if (v5)
			return sub_28110(a1);
	LABEL_27:
		v13 = v5;
		v12 = 1;
		v11 = -72;
		goto LABEL_28;
	}
	if (v4 <= 1u)
	{
		v6 = sub_28000(a1);
		if (v6)
		{
			v7 = v6 - (x_D41A0_BYTEARRAY_0[28302]);
			*(x_WORD *)(a1 + 44) = 0x2000;
			*(x_WORD *)(a1 + 150) = v7 / 168;
			sub_27FE0(a1, 184, 2, 0);
		}
		else
		{
			v8 = sub_10C40((__int16 *)(a1 + 76));
			HIBYTE(v8) += 7;
			*(x_WORD *)(a1 + 44) = v8;
			sub_27FE0(a1, 184, 0, 80);
		}
		return sub_28110(a1);
	}
	if (v4 != 2)
		return sub_28110(a1);
	v5 = sub_28420(a1);
	if (!v5)
		goto LABEL_27;
	if (!(*(x_BYTE *)(a1 + 62) & 3))
	{
		v9 = (x_WORD *)(v5 + 76);
		*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v5 + 76));
		if ((signed int)sub_58490((x_WORD *)(a1 + 76), v9) < 768)
		{
			v13 = 500;
			v12 = 0;
			v11 = -71;
		LABEL_28:
			sub_27FE0(a1, v11, v12, v13);
			return sub_28110(a1);
		}
	}
	return sub_28110(a1);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00027B20) --------------------------------------------------------
char sub_27B20(int a1)
{
	char v1; // al
	int v2; // edx
	int v3; // esi
	__int16 v5; // dx
	char v6; // [esp+0h] [ebp-4h]

	v6 = 0;
	v1 = *(x_BYTE *)(a1 + 70);
	if (v1)
	{
		if (v1 == 1)
		{
			v5 = *(x_WORD *)(a1 + 80);
			if (v5 >= 0x2000)
			{
				sub_27FE0(a1, 184, 0, 80);
				return sub_28110(a1);
			}
			*(x_WORD *)(a1 + 80) = v5 + 32;
		}
	}
	else
	{
		v2 = *(x_DWORD *)(a1 + 16);
		*(x_WORD *)(a1 + 130) = *(x_WORD *)(a1 + 132);
		*(x_DWORD *)(a1 + 16) = --v2;
		if (v2 && (v3 = sub_28420(a1)) != 0 && !sub_28060(a1))
		{
			if (sub_28390((x_WORD *)a1, v3))
				sub_27FE0(a1, 187, 0, 0);
		}
		else
		{
			v6 = 1;
		}
		if (v6)
		{
			sub_27FE0(a1, 185, 1, 0);
			return sub_28110(a1);
		}
	}
	return sub_28110(a1);
}

//----- (00027C10) --------------------------------------------------------
char sub_27C10(int a1)
{
	unsigned __int8 v1; // al
	int v2; // eax
	int v3; // eax
	int v4; // esi
	int v5; // edi
	int v6; // edx
	unsigned int v7; // eax
	char v9; // [esp+0h] [ebp-8h]
	char v10; // [esp+4h] [ebp-4h]

	v10 = 0;
	v9 = 0;
	sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 59);
	v1 = *(x_BYTE *)(a1 + 70);
	if (v1 < 1u)
	{
		if (v1)
			goto LABEL_24;
		v2 = sub_28420(a1);
		if (!v2 || *(x_BYTE *)(v2 + 12) & 0x40)
		{
			v9 = 1;
		}
		else
		{
			*(x_WORD *)(a1 + 44) = 18;
			sub_27FE0(a1, 187, 1, 64);
		}
	}
	else if (v1 > 1u)
	{
		if (v1 == 3)
		{
			*(x_WORD *)(a1 + 150) = 0;
			v7 = sub_28000(a1);
			if (v7
				&& (*(x_WORD *)(a1 + 150) = (signed int)(v7 - (x_D41A0_BYTEARRAY_0[28302])) / 168,
				(signed int)sub_58490((x_WORD *)(a1 + 76), (x_WORD *)(v7 + 76)) <= 3584))
			{
				sub_27FE0(a1, 185, 0, 500);
			}
			else
			{
				v10 = 1;
			}
		}
		goto LABEL_24;
	}
	if (*(x_WORD *)(a1 + 150))
	{
		v3 = sub_28420(a1);
		v4 = v3;
		v5 = v3;
		if (v3 && (v6 = *(x_DWORD *)(a1 + 16) - 1, (*(x_DWORD *)(a1 + 16) = v6) != 0))
		{
			*(x_BYTE *)(v3 + 12) |= 0x40u;
			*(x_WORD *)(v3 + 150) = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
			*(x_WORD *)(a1 + 44) += 10;
			if (sub_106C0(a1, v3) || *(x_WORD *)(v4 + 80) > *(x_WORD *)(a1 + 80))
			{
				*(x_DWORD *)(a1 + 144) += *(x_DWORD *)(v5 + 144);
				sub_57F10(v5);
				v9 = 1;
			}
		}
		else
		{
			v9 = 1;
		}
	}
	else
	{
		v10 = 1;
	}
	if (v9)
		sub_27FE0(a1, 187, 3, 0);
LABEL_24:
	if (v10)
		sub_27FE0(a1, 185, 1, 0);
	return sub_28110(a1);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00027E00) --------------------------------------------------------
char sub_27E00(int a1)
{
	x_WORD *v1; // ebx
	unsigned int v2; // eax
	unsigned int v3; // esi
	unsigned int i; // ecx
	int v5; // eax
	unsigned int v6; // edi
	char result; // al
	char v8; // [esp+4h] [ebp-8h]

	v1 = (x_WORD *)a1;
	v8 = 0;
	sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 59);
	v1[65] = v1[66];
	sub_1B8C0(a1);
	v2 = sub_1ED30((int)v1, x_DWORD_EA3E4[(unsigned __int16)v1[75]]);
	v3 = v2;
	if (v2 <= x_DWORD_EA3E4[0] || *(x_DWORD *)(v2 + 8) < 0 || *(x_BYTE *)(v2 + 13) & 4)
	{
	LABEL_15:
		v8 = 1;
		goto LABEL_16;
	}
	if (!(*(x_BYTE *)(a1 + 62) & 3))
	{
		*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v2 + 76));
		for (i = x_D41A0_BYTEARRAY_4[*(char *)(a1 + 64) + 38403]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
		{
			if (*(x_WORD *)(i + 26) != *(x_WORD *)(a1 + 26)
				&& abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(i + 76)) < (signed int)*(signed __int16 *)(a1 + 84)
				&& abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(i + 78)) < (signed int)*(signed __int16 *)(a1 + 84))
			{
				*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(i + 76), (Bit16u*)(a1 + 76));
				break;
			}
		}
	}
	v5 = *(x_DWORD *)(a1 + 160);
	if (!(*(signed __int16 *)(v5 + 26) & *(unsigned __int8 *)(a1 + 62)))
	{
		v6 = *(signed __int16 *)(v5 + 28);
		if (sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(v3 + 76)) < v6)
		{
			sub_1D260(a1, v3);
			goto LABEL_16;
		}
		goto LABEL_15;
	}
LABEL_16:
	result = sub_28110(a1);
	if (v8)
	{
		*(x_WORD *)(a1 + 150) = 0;
		result = sub_27FE0(a1, 187, 3, 0);
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00027FA0) --------------------------------------------------------
int sub_27FA0(int a1)
{
	return sub_1C890(a1, 184);
}

//----- (00027FC0) --------------------------------------------------------
void sub_27FC0(int a1)
{
	sub_1C930(a1);
}

//----- (00027FE0) --------------------------------------------------------
int sub_27FE0(int a1, char a2, char a3, int a4)
{
	int result; // eax

	result = a1;
	*(x_BYTE *)(a1 + 69) = a2;
	*(x_BYTE *)(a1 + 70) = a3;
	*(x_DWORD *)(a1 + 16) = a4;
	return result;
}

//----- (00028000) --------------------------------------------------------
unsigned int sub_28000(int a1)
{
	unsigned int v1; // edi
	unsigned int v2; // esi
	unsigned int v3; // ebx
	unsigned int v5; // eax

	v1 = -1;
	v2 = 0;
	v3 = x_D41A0_BYTEARRAY_4[0x967B];
	if (v3 <= x_DWORD_EA3E4[0])
		return 0;
	do
	{
		if (*(x_BYTE *)(v3 + 64) == 39)
		{
			v5 = sub_584D0((x_WORD *)(a1 + 76), (x_WORD *)(v3 + 76));
			if (v5 < v1)
			{
				v2 = v3;
				v1 = v5;
			}
		}
		v3 = *(x_DWORD *)v3;
	} while (v3 > x_DWORD_EA3E4[0]);
	return v2;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00028060) --------------------------------------------------------
char sub_28060(int a1)
{
	int v1; // esi
	unsigned int i; // ecx
	__int16 v3; // ax
	char v5; // [esp+4h] [ebp-4h]

	v5 = 0;
	v1 = 2 * *(signed __int16 *)(a1 + 84);
	for (i = x_D41A0_BYTEARRAY_4[*(char *)(a1 + 64) + 38403]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
	{
		if (*(x_WORD *)(i + 26) != *(x_WORD *)(a1 + 26)
			&& abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(i + 76)) < v1
			&& abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(i + 78)) < v1
			&& abs(*(signed __int16 *)(a1 + 80) - *(signed __int16 *)(i + 80)) < 2 * *(signed __int16 *)(a1 + 88))
		{
			v3 = *(x_WORD *)(a1 + 80);
			if (v3 >= *(x_WORD *)(i + 80))
			{
				v5 = 1;
				*(x_WORD *)(a1 + 80) = v3 + 16;
				return v5;
			}
		}
	}
	return v5;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00028110) --------------------------------------------------------
char sub_28110(int a1)
{
	signed int v1; // esi
	__int16 v2; // ax
	unsigned __int16 v3; // ax
	int v4; // eax
	int v5; // ecx
	char v6; // al
	unsigned int v7; // eax
	unsigned int v8; // edi
	unsigned int v9; // esi
	int v10; // eax
	char v11; // dh

	v1 = 0;
	if (*(x_BYTE *)(a1 + 57))
	{
		if (*(x_WORD *)(a1 + 98))
		{
			v2 = *(x_WORD *)(a1 + 98);
			*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
			*(x_WORD *)(a1 + 38) = v2;
			v3 = *(x_WORD *)(a1 + 38);
			*(x_WORD *)(a1 + 98) = 0;
			if (*(x_BYTE *)(x_DWORD_EA3E4[v3] + 63) == 3)
			{
				v1 = 1;
				v4 = sub_28420(a1);
				v5 = v4;
				if (v4 && *(x_BYTE *)(v4 + 12) & 0x40 && *(unsigned __int16 *)(v4 + 150) == (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168)
				{
					v6 = *(x_BYTE *)(v4 + 12);
					*(x_WORD *)(v5 + 150) = 0;
					*(x_BYTE *)(v5 + 12) = v6 & 0xBF;
				}
				*(x_WORD *)(a1 + 150) = *(x_WORD *)(a1 + 38);
				sub_27FE0(a1, 186, 0, 0);
			}
		}
		else
		{
			*(x_WORD *)(a1 + 38) = 0;
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 0)
	{
		v1 = 2;
		*(x_WORD *)(a1 + 36) = *(x_WORD *)(a1 + 38);
		sub_27FE0(a1, 188, 0, 0);
	}
	if (!v1 && !(*(x_BYTE *)(a1 + 62) & 0x1F))
	{
		v7 = sub_282D0(a1);
		v8 = v7;
		if (v7)
		{
			v9 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 28);
			if (sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(v7 + 76)) < v9)
			{
				v10 = sub_28420(a1);
				if (v10
					&& *(x_BYTE *)(v10 + 12) & 0x40
					&& *(unsigned __int16 *)(v10 + 150) == (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168)
				{
					v11 = *(x_BYTE *)(v10 + 12);
					*(x_WORD *)(v10 + 150) = 0;
					*(x_BYTE *)(v10 + 12) = v11 & 0xBF;
				}
				*(x_WORD *)(a1 + 150) = (signed int)(v8 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
				sub_27FE0(a1, 186, 0, 0);
			}
		}
	}
	return 0;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000282D0) --------------------------------------------------------
unsigned int sub_282D0(int a1)
{
	unsigned int v1; // esi
	unsigned int v2; // edi
	unsigned int i; // ebx
	unsigned __int8 v4; // al
	int v5; // eax
	int v6; // eax
	int v7; // eax
	unsigned int v8; // eax

	v1 = -1;
	v2 = 0;
	for (i = x_D41A0_BYTEARRAY_4[0x9677]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
	{
		v4 = *(x_BYTE *)(i + 64);
		if (v4 <= 1u)
		{
			v5 = *(x_DWORD *)(i + 164);
		}
		else
		{
			if (v4 != 3)
				continue;
			if (*(x_DWORD *)(i + 144) <= 0)
				continue;
			v6 = x_DWORD_EA3E4[*(signed __int16 *)(i + 26)];
			if (!v6)
				continue;
			v5 = *(x_DWORD *)(v6 + 164);
		}
		v7 = x_DWORD_EA3E4[*(unsigned __int16 *)(v5 + 58)];
		if (v7)
		{
			if (!sub_10750(i, v7))
			{
				v8 = sub_584D0((x_WORD *)(a1 + 76), (x_WORD *)(i + 76));
				if (v8 < v1)
				{
					v1 = v8;
					v2 = i;
				}
			}
		}
	}
	return v2;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00028390) --------------------------------------------------------
char sub_28390(x_WORD *a1, int a2)
{
	char v3; // [esp+0h] [ebp-4h]

	v3 = 1;
	if ((signed int)sub_58490(a1 + 38, (x_WORD *)(a2 + 76)) > 128)
	{
		v3 = 0;
		a1[16] = sub_581E0((Bit16u*)a1 + 38, (Bit16u*)(a2 + 76));
		sub_1B8C0((int)a1);
	}
	if (abs((signed __int16)a1[40] - (*(signed __int16 *)(a2 + 80) + 640)) > 64)
	{
		v3 = 0;
		if ((signed __int16)a1[40] - (*(signed __int16 *)(a2 + 80) + 640) <= 0)
			a1[40] += 32;
		else
			a1[40] -= 32;
	}
	return v3;
}

//----- (00028420) --------------------------------------------------------
int sub_28420(int a1)
{
	int result; // eax

	result = 0;
	if (*(x_WORD *)(a1 + 150))
	{
		LOWORD(result) = *(x_WORD *)(a1 + 150);
		result = x_DWORD_EA3E4[result];
		if (result)
		{
			if (*(x_DWORD *)(result + 8) < 0
				|| *(x_BYTE *)(result + 13) & 4
				|| *(x_BYTE *)(result + 63) != 10
				|| *(x_BYTE *)(result + 64) != 39)
			{
				result = 0;
			}
		}
	}
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00028470) --------------------------------------------------------
void sub_28470(int a1)
{
	sub_1D5D0(a1, 184);
}

//----- (00028490) --------------------------------------------------------
int sub_28490(int a1)
{
	sub_1BD90(a1, 192);
	if (*(x_BYTE *)(a1 + 69) == -64)
	{
		if (!(*(x_BYTE *)(a1 + 62) & 7))
		{
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			if (!(*(unsigned __int16 *)(a1 + 20) % 3u))
				*(x_BYTE *)(a1 + 69) = -63;
		}
		if (*(x_BYTE *)(a1 + 69) == -64)
			sub_28690(a1);
	}
	else
	{
		*(x_BYTE *)(a1 + 69) = -58;
	}
	return sub_287B0(a1);
}

//----- (00028500) --------------------------------------------------------
int sub_28500(int a1)
{
	sub_1BF90(a1, 192);
	if (*(x_BYTE *)(a1 + 69) == -63)
	{
		if (!(*(x_BYTE *)(a1 + 62) & 7))
		{
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			if (!(*(unsigned __int16 *)(a1 + 20) % 3u))
				*(x_BYTE *)(a1 + 69) = -64;
		}
		if (*(x_BYTE *)(a1 + 69) == -63)
			sub_28690(a1);
	}
	else
	{
		*(x_BYTE *)(a1 + 69) = -58;
	}
	return sub_287B0(a1);
}

//----- (00028570) --------------------------------------------------------
int sub_28570(int a1)
{
	sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 7);
	if ((unsigned __int16)sub_1C310(a1, 192, (unsigned __int16(*)(int, int))sub_1CF20))
		*(x_BYTE *)(a1 + 69) = -58;
	return sub_287B0(a1);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (000285D0) --------------------------------------------------------
signed int sub_285D0(int a1)
{
	*(x_BYTE *)(a1 + 69) = -63;
	return sub_1BD90(a1, 192);
}

//----- (000285F0) --------------------------------------------------------
int sub_285F0(int a1)
{
	return sub_1C890(a1, 192);
}

//----- (00028610) --------------------------------------------------------
void sub_28610(int a1)
{
	sub_1C930(a1);
}

//----- (00028630) --------------------------------------------------------
int sub_28630(int a1)
{
	sub_1C980(a1, 192);
	sub_28690(a1);
	return sub_287B0(a1);
}

//----- (00028660) --------------------------------------------------------
int sub_28660(int a1)
{
	sub_1D5D0(a1, 192);
	return sub_287B0(a1);
}

//----- (00028690) --------------------------------------------------------
void sub_28690(int a1)
{
	int v1; // eax
	unsigned int v2; // esi
	int v3; // eax
	unsigned int v4; // edi
	signed int v5; // ST0C_4
	__int16 v6; // ax
	unsigned int v7; // eax
	int v8; // eax
	unsigned int v9; // [esp+0h] [ebp-10h]
	int v10; // [esp+8h] [ebp-8h]
	unsigned int v11; // [esp+Ch] [ebp-4h]

	if (*(x_BYTE *)(a1 + 57) && !(*(x_BYTE *)(a1 + 62) & 0xF))
	{
		v1 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 28);
		v11 = -1;
		v10 = 0;
		v2 = x_D41A0_BYTEARRAY_4[0x9677];
		v9 = v1 * v1;
		while (v2 > x_DWORD_EA3E4[0])
		{
			v3 = (signed __int16)(*(x_WORD *)(v2 + 76) - *(x_WORD *)(a1 + 76));
			v4 = (signed __int16)(*(x_WORD *)(v2 + 78) - *(x_WORD *)(a1 + 78))
				* (signed __int16)(*(x_WORD *)(v2 + 78) - *(x_WORD *)(a1 + 78))
				+ v3 * v3;
			if (v4 <= v9 && !(*(x_BYTE *)(v2 + 12) & 0x20))
			{
				v5 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 30);
				v6 = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v2 + 76));
				if ((unsigned __int16)sub_582B0(*(x_WORD *)(a1 + 28), v6) < v5 && v4 < v11)
				{
					v10 = v2;
					v11 = v4;
				}
			}
			v2 = *(x_DWORD *)v2;
		}
		if (v10)
		{
			v7 = sub_1ED30(a1, v10);
			if (v7 > x_DWORD_EA3E4[0] && *(x_DWORD *)(v7 + 8) >= 0 && !(*(x_BYTE *)(v7 + 13) & 4))
			{
				v8 = v7 - (x_D41A0_BYTEARRAY_0[28302]);
				*(x_BYTE *)(a1 + 69) = -62;
				*(x_WORD *)(a1 + 150) = v8 / 168;
			}
		}
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000287B0) --------------------------------------------------------
int sub_287B0(int a1)
{
	int result; // eax
	unsigned __int8 v2; // dl
	signed int v3; // edx
	__int16 v4; // dx

	result = a1;
	v2 = *(x_BYTE *)(a1 + 69);
	if (v2 < 0xC2u)
	{
		if (v2 == -64)
		{
			v3 = 336;
			*(x_WORD *)(a1 + 130) = 0;
			goto LABEL_11;
		}
		goto LABEL_9;
	}
	if (v2 <= 0xC2u)
	{
		v4 = *(x_WORD *)(a1 + 132);
	}
	else
	{
		if (v2 != -58)
		{
		LABEL_9:
			v4 = *(x_WORD *)(a1 + 134);
			goto LABEL_10;
		}
		v4 = 2 * *(x_WORD *)(a1 + 134);
	}
LABEL_10:
	*(x_WORD *)(a1 + 130) = v4;
	v3 = 335;
LABEL_11:
	if (v3 != *(signed __int16 *)(a1 + 90))
	{
		*(x_WORD *)(a1 + 90) = v3;
		*(x_BYTE *)(a1 + 92) = 0;
		*(x_BYTE *)(a1 + 93) = x_BYTE_D8A2E[(unsigned __int8)x_BYTE_D9528[14 * v3]];
	}
	return result;
}

//----- (00028860) --------------------------------------------------------
__int16 sub_28860(int a1)
{
	char v1; // dh
	int(*v2)(); // eax
	__int16 v3; // ax
	int i; // edx
	int v5; // ecx
	int v6; // edx
	__int16 v7; // si
	int v8; // eax
	int v9; // ecx
	int v10; // ecx
	__int16 v11; // ax
	char v12; // cl
	int v13; // eax
	char v14; // dh
	__int16 v15; // ax
	unsigned int v16; // edx
	int v17; // eax
	unsigned __int16 v18; // di
	int v19; // esi
	unsigned __int16 v20; // dx
	int v21; // esi
	int v22; // ecx
	__int64 v23; // rtt
	char v24; // ch
	char v26; // [esp+0h] [ebp-4h]

	v26 = 0;
	v1 = *(x_BYTE *)(a1 + 70);
	v2 = 0;
	if (v1 != 1 && v1 != 2)
	{
		if (*(x_WORD *)(a1 + 98))
		{
			*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
			v3 = *(x_WORD *)(a1 + 98);
			*(x_WORD *)(a1 + 98) = 0;
			*(x_WORD *)(a1 + 38) = v3;
			v2 = (int(*)())1;
		}
		else
		{
			*(x_WORD *)(a1 + 38) = 0;
		}
		if (*(x_WORD *)(a1 + 52))
		{
			for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52))
			{
				v6 = x_DWORD_EA3E4[i];
				if (v6 == x_DWORD_EA3E4[0])
					break;
				v5 = *(x_DWORD *)(v6 + 8);
				if (v5 < *(x_DWORD *)(a1 + 8))
				{
					*(x_DWORD *)(a1 + 8) = v5;
					*(x_WORD *)(a1 + 38) = *(x_WORD *)(v6 + 38);
					v2 = (int(*)())1;
					break;
				}
			}
		}
		if (*(x_DWORD *)(a1 + 8) < 0)
		{
			*(x_WORD *)(a1 + 36) = *(x_WORD *)(a1 + 38);
			v2 = (int(*)())2;
		}
	}
	v7 = *(x_WORD *)(a1 + 42) - 1;
	*(x_WORD *)(a1 + 42) = v7;
	if (!v7)
		v2 = (int(*)())2;
	if (v2 == (int(*)())2)
	{
		*(x_BYTE *)(a1 + 69) = -52;
	}
	else
	{
		switch (*(x_BYTE *)(a1 + 70))
		{
		case 1:
			*(x_DWORD *)(a1 + 16) = 52;
			*(x_BYTE *)(a1 + 70) = 2;
			goto LABEL_20;
		case 2:
		LABEL_20:
			v8 = *(x_DWORD *)(a1 + 4);
			v9 = *(x_DWORD *)(a1 + 16);
			*(x_WORD *)(a1 + 98) = 0;
			v10 = v9 - 1;
			*(x_DWORD *)(a1 + 8) = v8;
			*(x_DWORD *)(a1 + 16) = v10;
			if (v10 < 0)
				goto LABEL_21;
			if (v10 > 13)
			{
				v11 = *(x_WORD *)(a1 + 32);
				HIBYTE(v11) = (HIBYTE(v11) + 1) & 7;
				*(x_WORD *)(a1 + 32) = v11;
			}
			break;
		case 3:
			v12 = 0;
			if (!*(x_WORD *)(a1 + 36)
				|| (v13 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 36)], *(x_BYTE *)(v13 + 63) != 3)
				|| (v14 = *(x_BYTE *)(v13 + 64)) != 0 && v14 != 1)
			{
				v12 = 1;
			}
			else if (*(x_WORD *)(*(x_DWORD *)(v13 + 164) + 58))
			{
				v15 = *(x_WORD *)(a1 + 36);
				*(x_BYTE *)(a1 + 70) = 5;
				*(x_WORD *)(a1 + 150) = v15;
			}
			else
			{
				*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
				v16 = *(unsigned __int16 *)(a1 + 20) % 0x64u;
				*(x_BYTE *)(a1 + 70) = 4;
				*(x_DWORD *)(a1 + 16) = v16 + 100;
			}
			if (v12)
			{
				*(x_BYTE *)(a1 + 70) = 8;
				*(x_DWORD *)(a1 + 16) = 100;
			}
			break;
		case 4:
			v17 = *(x_DWORD *)(a1 + 16) - 1;
			*(x_DWORD *)(a1 + 16) = v17;
			if (v17 < 0)
				goto LABEL_35;
			break;
		case 5:
			v18 = *(x_WORD *)(*(x_DWORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)] + 164) + 58);
			if (v18)
			{
				if (!(*(x_BYTE *)(a1 + 62) & 7))
				{
					v19 = x_DWORD_EA3E4[v18];
					*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v19 + 76));
					if (sub_10750(a1, v19))
						*(x_BYTE *)(a1 + 70) = 6;
				}
			}
			else
			{
			LABEL_35:
				*(x_BYTE *)(a1 + 70) = 3;
			}
			break;
		case 6:
			*(x_BYTE *)(a1 + 70) = 7;
			v26 = 1;
			goto LABEL_41;
		case 7:
		LABEL_41:
			v20 = *(x_WORD *)(*(x_DWORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)] + 164) + 58);
			if (v20)
			{
				v21 = x_DWORD_EA3E4[v20];
				if (sub_10750(a1, x_DWORD_EA3E4[v20]))
				{
					sub_11900(a1, v21, 0, 0x3Cu);
				}
				else
				{
					*(x_BYTE *)(a1 + 70) = 5;
					v26 = 1;
				}
			}
			else
			{
			LABEL_21:
				*(x_BYTE *)(a1 + 70) = 3;
				v26 = 1;
			}
			break;
		case 8:
			v22 = *(x_DWORD *)(a1 + 16) - 1;
			*(x_DWORD *)(a1 + 16) = v22;
			if (v22 < 0)
				*(x_BYTE *)(a1 + 69) = -52;
			break;
		default:
			break;
		}
		if (!(*(x_BYTE *)(a1 + 62) & 7))
		{
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			v23 = *(unsigned __int16 *)(a1 + 20) % 0x9Du;
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			*(x_WORD *)(a1 + 32) += (2 * (unsigned __int64)(v23 / 79) - 1) * (*(x_WORD *)(a1 + 20) % 0x17Du);
			*(x_BYTE *)(a1 + 33) &= 7u;
		}
		sub_1B8C0(a1);
		v2 = sub_104D0((signed __int16 *)(a1 + 76));
		if (v2 == (int(*)())1)
		{
			if (*(x_WORD *)(a1 + 90) == 314)
			{
				LOWORD(v2) = sub_10C40((__int16 *)(a1 + 76));
				if ((signed __int16)v2 < *(x_WORD *)(a1 + 80))
					LOWORD(v2) = sub_49CD0((x_WORD *)a1, 313);
			}
			else
			{
				LOWORD(v2) = sub_49CD0((x_WORD *)a1, 314);
				*(x_WORD *)(a1 + 132) = 35;
				v26 = 1;
			}
		}
		else if (*(x_WORD *)(a1 + 90) != 313)
		{
			LOWORD(v2) = sub_49CD0((x_WORD *)a1, 313);
			*(x_WORD *)(a1 + 132) = 60;
			v26 = 1;
		}
		if (v26)
		{
			LOWORD(v2) = *(x_WORD *)(a1 + 132);
			v24 = *(x_BYTE *)(a1 + 70);
			*(x_WORD *)(a1 + 130) = (x_WORD)v2;
			if (v24 == 2)
				*(x_WORD *)(a1 + 130) = (x_WORD)v2 + 50;
		}
	}
	return (signed __int16)v2;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00028C30) --------------------------------------------------------
int sub_28C30(int a1)
{
	int result; // eax
	// fix if begin
	result = 0;
	// end

	sub_1BF90(a1, 200);
	if (*(x_DWORD *)(a1 + 8) < 0)
		*(x_DWORD *)(a1 + 8) = 0;
	return result;
}

//----- (00028C60) --------------------------------------------------------
signed int sub_28C60(int a1)
{
	signed int result; // eax

	sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 37);
	result = sub_1C310(a1, 200, (unsigned __int16(*)(int, int))sub_1CC20);
	if (*(x_DWORD *)(a1 + 8) < 0)
		*(x_DWORD *)(a1 + 8) = 0;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00028CC0) --------------------------------------------------------
int sub_28CC0(int a1)
{
	int result; // eax
	int v2; // edx

	result = a1;
	v2 = *(x_DWORD *)(a1 + 8);
	*(x_BYTE *)(a1 + 69) = -55;
	if (v2 < 0)
		*(x_DWORD *)(a1 + 8) = 0;
	return result;
}

//----- (00028CE0) --------------------------------------------------------
int sub_28CE0(int a1)
{
	int v1; // eax
	int v2; // ebx
	__int16 v3; // dx
	__int16 v4; // ax
	__int16 v5; // ax
	Bit8u* v6; // edx
	int v7; // eax
	int result; // eax
	int v9; // [esp+0h] [ebp-10h]
	signed int i; // [esp+4h] [ebp-Ch]
	int v11; // [esp+8h] [ebp-8h]
	int v12; // [esp+Ch] [ebp-4h]

	if (*(x_BYTE *)(a1 + 70))
		return sub_1C890(a1, 200);
	if (sub_4A810() <= 1)
	{
		sub_36BA0(a1, 0);
	}
	else
	{
		v12 = *(x_DWORD *)(a1 + 144);
		v9 = v12 / 3;
		for (i = 0; i < 3; i++)
		{
			v1 = sub_4A050();
			v2 = v1;
			v11 = v1;
			if (v1)
			{
				*(x_BYTE *)(v1 + 69) = -56;
				*(x_BYTE *)(v1 + 63) = 5;
				*(x_BYTE *)(v1 + 64) = 25;
				*(x_DWORD *)(v1 + 76) = *(x_DWORD *)(a1 + 76);
				*(x_WORD *)(v1 + 80) = *(x_WORD *)(a1 + 80);
				*(x_BYTE *)(v1 + 70) = 3;
				*(x_WORD *)(v1 + 132) = 35;
				*(x_WORD *)(v1 + 134) = 60;
				*(x_WORD *)(v1 + 130) = *(x_WORD *)(v1 + 132) + 50;
				v3 = *(x_WORD *)(v1 + 20);
				*(x_DWORD *)(v1 + 144) = v9;
				*(x_WORD *)(v1 + 20) = 9377 * v3 + 9439;
				v4 = *(x_WORD *)(v1 + 20);
				*(x_DWORD *)(v2 + 4) = 80;
				*(x_WORD *)(v2 + 42) = 15000;
				v5 = (v4 & 0x7FF) - 1;
				*(x_WORD *)(v2 + 32) = v5;
				*(x_WORD *)(v2 + 28) = v5;
				*(x_BYTE *)(v2 + 56) = 1;
				v6 = *(char *)(a1 + 64) + x_D41A0_BYTEARRAY_0;
				LOBYTE(v5) = (*(x_BYTE *)(v6 + 16))++;
				*(x_BYTE *)(v2 + 62) = v5;
				*(x_DWORD *)(v2 + 160) = (x_DWORD)&unk_D8874;
				*(x_BYTE *)(v2 + 57) = 64;
				v12 -= v9;
				*(x_BYTE *)(v2 + 65) = 3;
				sub_57D70(v2, a1 + 76);
				sub_49A20(v2);
				sub_49CD0((x_WORD *)v2, 314);
				sub_49EA0((x_WORD *)v2, 32, 32);
				*(x_BYTE *)(v2 + 70) = 1;
				*(x_WORD *)(v2 + 36) = *(x_WORD *)(a1 + 38);
			}
		}
		if (v11)
			*(x_DWORD *)(v11 + 144) += v12;
	}
	v7 = sub_4A190(a1 + 76, 10, 1);
	if (v7)
		*(x_WORD *)(v7 + 26) = *(x_WORD *)(a1 + 26);
	*(x_BYTE *)(a1 + 69) = -51;
	result = (int)x_D41A0_BYTEARRAY_0;
	*(x_DWORD *)(0x364D1 + result + 1) += 3;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00028EC0) --------------------------------------------------------
void sub_28EC0(int a1)
{
	Bit8u* v1; // edx
	Bit8u* v2; // edx

	if (*(x_BYTE *)(a1 + 70))
	{
		v2 = 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0;
		if (*(x_WORD *)(a1 + 36) == *(x_WORD *)(v2 + 11240))
			++*(x_DWORD *)(v2 + 12601);
		sub_1C930(a1);
	}
	else
	{
		v1 = 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0;
		if (*(x_WORD *)(a1 + 36) == *(x_WORD *)(v1 + 11240))
			++*(x_DWORD *)(v1 + 12601);
		*(x_DWORD *)(a1 + 8) = -1;
		sub_57F10(a1);
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00028F50) --------------------------------------------------------
void sub_28F50(int a1)
{
	if (*(x_BYTE *)(a1 + 70))
	{
		sub_12470(a1, 200);
		*(x_BYTE *)(a1 + 70) = 3;
	}
	else
	{
		sub_1D5D0(a1, 200);
	}
}

//----- (00028F90) --------------------------------------------------------
int sub_28F90(int a1)
{
	sub_1BD90(a1, 208);
	return sub_293B0(a1);
}

//----- (00028FC0) --------------------------------------------------------
int sub_28FC0(int a1)
{
	sub_1BF90(a1, 208);
	return sub_293B0(a1);
}

//----- (00028FF0) --------------------------------------------------------
int sub_28FF0(int a1)
{
	unsigned int v1; // esi
	__int16 v2; // ax
	int i; // ecx
	int v4; // eax
	int v5; // ecx
	unsigned int v6; // esi
	char v7; // dh
	unsigned int j; // ecx
	int v9; // edx
	signed int v10; // eax
	int v11; // eax
	unsigned int v12; // edx
	int v14; // edx
	int v15; // eax
	__int16 v16; // dx
	int v17; // edx
	int v18; // eax
	__int16 v19; // cx

	if (!(*(x_BYTE *)(a1 + 62) & 0x1F))
		sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 62);
	v1 = 0;
	if (*(x_WORD *)(a1 + 98))
	{
		*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
		v2 = *(x_WORD *)(a1 + 98);
		*(x_WORD *)(a1 + 98) = 0;
		v1 = 1;
		*(x_WORD *)(a1 + 38) = v2;
	}
	else
	{
		*(x_WORD *)(a1 + 38) = 0;
	}
	if (*(x_WORD *)(a1 + 52))
	{
		for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52))
		{
			v5 = x_DWORD_EA3E4[i];
			if (v5 == x_DWORD_EA3E4[0])
				break;
			v4 = *(x_DWORD *)(v5 + 8);
			if (v4 < *(x_DWORD *)(a1 + 8))
			{
				*(x_DWORD *)(a1 + 8) = v4;
				v1 = 1;
				*(x_WORD *)(a1 + 38) = *(x_WORD *)(v5 + 38);
				break;
			}
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 0)
	{
		v1 = 2;
		*(x_WORD *)(a1 + 36) = *(x_WORD *)(a1 + 38);
	}
	if (v1 < 1)
	{
		if (v1)
			return sub_293D0(a1);
	}
	else
	{
		if (v1 > 1)
		{
			if (v1 == 2)
				*(x_BYTE *)(a1 + 69) = -44;
			return sub_293D0(a1);
		}
		*(x_WORD *)(a1 + 150) = *(x_WORD *)(a1 + 38);
	}
	sub_1B8C0(a1);
	v6 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
	if (v6 > x_DWORD_EA3E4[0] && *(x_BYTE *)(v6 + 63) == 3)
	{
		v7 = *(x_BYTE *)(v6 + 64);
		if ((!v7 || v7 == 1) && *(x_DWORD *)(v6 + 8) >= 0 && !(*(x_BYTE *)(v6 + 13) & 4))
		{
			if (!(*(x_BYTE *)(a1 + 62) & 3))
			{
				*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v6 + 76));
				for (j = x_D41A0_BYTEARRAY_4[*(char *)(a1 + 64) + 38403]; j > x_DWORD_EA3E4[0]; j = *(x_DWORD *)j)
				{
					if (*(x_WORD *)(j + 26) != *(x_WORD *)(a1 + 26)
						&& abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(j + 76)) < (signed int)*(signed __int16 *)(a1 + 84)
						&& abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(j + 78)) < (signed int)*(signed __int16 *)(a1 + 84))
					{
						*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(j + 76), (Bit16u*)(a1 + 76));
						break;
					}
				}
			}
			v9 = *(x_DWORD *)(v6 + 144) - (*(x_DWORD *)(v6 + 136) + 14);
			*(x_DWORD *)(v6 + 144) = v9;
			if (v9 < 0)
				*(x_DWORD *)(v6 + 144) = 0;
			if (*(x_BYTE *)(a1 + 62) & 3)
				return sub_293D0(a1);
			v10 = sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(v6 + 76));
			if (v10 <= *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 28))
			{
				if (v10 >= 2048)
					return sub_293D0(a1);
				if (*(x_BYTE *)(v6 + 64))
					return sub_293D0(a1);
				v11 = (int)x_D41A0_BYTEARRAY_0;
				*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8) = 9377 * *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8) + 9439;
				v12 = *(x_DWORD *)(v11 + 8) % 0x3Fu;
				if (v12 < 4)
					return sub_293D0(a1);
				if (v12 <= 4)
				{
					v17 = *(x_DWORD *)(v6 + 164);
					v18 = *(signed __int16 *)(v17 + 1107);
					if (v18 == -1)
						return sub_293D0(a1);
					v19 = *(x_WORD *)(v17 + 2 * v18 + 819);
					if (!v19)
						return sub_293D0(a1);
					sub_69300(x_DWORD_EA3E4[v19], a1);
				}
				else
				{
					if (v12 != 5)
						return sub_293D0(a1);
					v14 = *(x_DWORD *)(v6 + 164);
					v15 = *(signed __int16 *)(v14 + 1105);
					if (v15 == -1)
						return sub_293D0(a1);
					v16 = *(x_WORD *)(v14 + 2 * v15 + 819);
					if (!v16)
						return sub_293D0(a1);
					sub_69300(x_DWORD_EA3E4[v16], a1);
				}
				return sub_293D0(a1);
			}
		}
	}
	*(x_BYTE *)(a1 + 69) = -47;
	return sub_293D0(a1);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00029300) --------------------------------------------------------
int sub_29300(int a1)
{
	sub_1C560(a1, 0xD0u);
	return sub_293B0(a1);
}

//----- (00029330) --------------------------------------------------------
int sub_29330(int a1)
{
	return sub_1C890(a1, 208);
}

//----- (00029350) --------------------------------------------------------
void sub_29350(int a1)
{
	sub_1C930(a1);
}

//----- (00029380) --------------------------------------------------------
int sub_29380(int a1)
{
	sub_1D5D0(a1, 208);
	return sub_293B0(a1);
}

//----- (000293B0) --------------------------------------------------------
int sub_293B0(int a1)
{
	int result; // eax

	result = a1;
	if (*(x_BYTE *)(a1 + 69) == -46)
	{
		*(x_BYTE *)(a1 + 14) &= 0x7Fu;
		*(x_WORD *)(a1 + 130) = *(x_WORD *)(a1 + 132);
	}
	return result;
}

//----- (000293D0) --------------------------------------------------------
int sub_293D0(int a1)
{
	int result; // eax
	char v2; // dh

	result = a1;
	if (*(x_BYTE *)(a1 + 69) != -46)
	{
		v2 = *(x_BYTE *)(a1 + 14);
		*(x_WORD *)(a1 + 150) = 0;
		*(x_BYTE *)(a1 + 14) = v2 | 0x80;
		*(x_WORD *)(a1 + 130) = *(x_WORD *)(a1 + 134);
	}
	return result;
}

//----- (00029400) --------------------------------------------------------
__int16 sub_29400(int a1)
{
	unsigned int v1; // eax
	unsigned int i; // eax
	int v3; // ecx
	__int16 v4; // ax
	signed int v5; // esi
	unsigned int v7; // [esp+0h] [ebp-4h]

	v1 = *(x_DWORD *)(a1 + 16);
	v7 = 0;
	*(x_DWORD *)(a1 + 16) = v1 + 1;
	if (v1 < 9)
	{
		if (v1 < 3)
		{
			if (!v1)
			{
				sub_2AED0(a1, 337);
				*(x_DWORD *)(a1 + 8) = (x_DWORD)&unk_F4240;
				*(x_WORD *)(a1 + 150) = 0;
			}
			goto LABEL_26;
		}
		if (v1 <= 3)
		{
		LABEL_15:
			v7 = 1;
			i = a1;
			goto LABEL_35;
		}
		if (v1 != 6)
		{
		LABEL_26:
			if (!v7)
				goto LABEL_36;
			i = a1;
			goto LABEL_35;
		}
	}
	else
	{
		if (v1 <= 9)
		{
			*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
			*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			v3 = (*(x_WORD *)(a1 + 20) & 7) + 8;
			v4 = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			*(x_WORD *)(a1 + 20) = v4;
			v5 = 0;
			x_WORD_EB398 += (x_WORD)v3 << 8;
			x_WORD_EB39A += ((v4 & 7) + 8) << 8;
			while (v5 < 128)
			{
				x_WORD_EB39C = sub_10C40(&x_WORD_EB398);
				if (!sub_102D0(a1, &x_WORD_EB398, 1) && !sub_102D0(a1, &x_WORD_EB398, 4) && sub_1B830(&x_WORD_EB398) < 32)
					break;
				++v5;
				sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), 0, 768);
			}
			sub_57CF0(a1, (int)&x_WORD_EB398);
			sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 22);
			goto LABEL_36;
		}
		if (v1 >= 0xF)
		{
			if (v1 > 0xF)
			{
				if (v1 == 18)
				{
					*(x_BYTE *)(a1 + 69) = -38;
					v7 = 3;
					sub_2AED0(a1, 337);
					*(x_WORD *)(a1 + 150) = 0;
					*(x_BYTE *)(a1 + 70) = 1;
				}
				goto LABEL_26;
			}
			goto LABEL_15;
		}
		if (v1 != 12)
			goto LABEL_26;
	}
	v7 = 2;
LABEL_35:
	for (i = a1; i > x_DWORD_EA3E4[0]; i = x_DWORD_EA3E4[*(unsigned __int16 *)(i + 52)])
	{
		*(x_WORD *)(i + 14) &= 0xFE7Fu;
		if (v7 >= 1)
		{
			if (v7 <= 1)
			{
				*(x_BYTE *)(i + 15) |= 1u;
			}
			else if (v7 == 2)
			{
				*(x_BYTE *)(i + 14) |= 0x80u;
			}
		}
	}
LABEL_36:
	*(x_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
	return sub_29A90(a1);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39A: using guessed type __int16 x_WORD_EB39A;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (00029670) --------------------------------------------------------
__int16 sub_29670(int a1)
{
	signed int v1; // eax
	__int16 v2; // ax
	char v3; // al

	v1 = sub_2A6B0(a1);
	if (v1)
	{
		if (v1 != 1)
			return sub_29A90(a1);
		*(x_BYTE *)(a1 + 69) = -38;
		v2 = *(x_WORD *)(a1 + 38);
		*(x_DWORD *)(a1 + 8) = (x_DWORD)&unk_F4240;
		*(x_WORD *)(a1 + 150) = v2;
	}
	v3 = sub_2AF10(a1, 1);
	if ((unsigned __int8)v3 >= 3u)
	{
		if ((unsigned __int8)v3 <= 3u)
			return sub_29A90(a1);
		if (v3 == 4)
		{
			*(x_BYTE *)(a1 + 69) = -40;
			*(x_DWORD *)(a1 + 16) = 0;
			return sub_29A90(a1);
		}
	}
	if (!(*(x_BYTE *)(a1 + 62) & 0x3F))
	{
		*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
		*(x_WORD *)(a1 + 32) = (*(x_WORD *)(a1 + 20) % 0x1C7u + *(x_WORD *)(a1 + 32) - 227) & 0x7FF;
	}
	return sub_29A90(a1);
}

//----- (00029710) --------------------------------------------------------
__int16 sub_29710(int a1)
{
	signed int v1; // eax
	char v2; // al
	unsigned int v3; // esi
	signed int v4; // edi
	__int16 v5; // ax
	unsigned int v6; // edi
	char v8; // [esp+0h] [ebp-4h]

	v8 = 0;
	v1 = sub_2A6B0(a1);
	if (v1)
	{
		if (v1 != 1)
			goto LABEL_19;
		*(x_DWORD *)(a1 + 8) = (x_DWORD)&unk_F4240;
		*(x_WORD *)(a1 + 150) = *(x_WORD *)(a1 + 38);
	}
	v2 = sub_2AF10(a1, *(x_BYTE *)(a1 + 70) == 0);
	if (v2 == 4)
	{
		*(x_BYTE *)(a1 + 69) = -40;
		*(x_DWORD *)(a1 + 16) = 0;
	}
	else
	{
		v3 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
		if (v3 <= x_DWORD_EA3E4[0] || *(x_DWORD *)(v3 + 8) < 0 || *(x_BYTE *)(v3 + 13) & 4)
			goto LABEL_24;
		if (!(*(x_BYTE *)(a1 + 62) & 3) && v2 != 3 && !*(x_BYTE *)(a1 + 70))
			*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v3 + 76));
		if (!(*(x_BYTE *)(a1 + 62) & 0x1F))
		{
			v4 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 30);
			v5 = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v3 + 76));
			if ((unsigned __int16)sub_582B0(*(x_WORD *)(a1 + 28), v5) <= v4)
			{
				*(x_BYTE *)(a1 + 70) = 1;
				sub_2AED0(a1, 337);
			}
			else
			{
				*(x_BYTE *)(a1 + 70) = 0;
				sub_2AED0(a1, 315);
			}
			v6 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 28);
			if (sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(v3 + 76)) >= v6)
				LABEL_24:
			v8 = 1;
		}
	}
LABEL_19:
	if (v8)
	{
		*(x_BYTE *)(a1 + 69) = -39;
		sub_2AED0(a1, 315);
		*(x_WORD *)(a1 + 150) = 0;
		*(x_BYTE *)(a1 + 70) = 0;
	}
	return sub_29A90(a1);
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00029890) --------------------------------------------------------
__int16 sub_29890(int a1)
{
	*(x_BYTE *)(a1 + 69) = -39;
	return sub_29670(a1);
}

//----- (000298B0) --------------------------------------------------------
int sub_298B0(int a1)
{
	*(x_DWORD *)(a1 + 8) = -1;
	return sub_1C890(a1, 216);
}

//----- (000298D0) --------------------------------------------------------
int sub_298D0(unsigned int a1)
{
	int v1; // eax

	*(x_DWORD *)(a1 + 8) = -1;
	sub_36BA0(a1, 1);
	if (!(*(x_BYTE *)(a1 + 14) & 0x10))
	{
		v1 = sub_4A190(a1 + 76, 10, 1);
		if (v1)
			*(x_WORD *)(v1 + 26) = *(x_WORD *)(a1 + 26);
	}
	sub_2AE80(a1);
	return 1;
}

//----- (00029930) --------------------------------------------------------
__int16 sub_29930(int a1)
{
	unsigned __int8 v1; // al
	char v2; // ah
	int v3; // eax
	unsigned int v4; // eax

	sub_1D5D0(a1, 216);
	v1 = *(x_BYTE *)(a1 + 73);
	if (v1 < 2u || v1 > 2u && (v1 < 6u || v1 > 9u))
		sub_2AED0(a1, 315);
	else
		sub_2AED0(a1, 337);
	v2 = *(x_BYTE *)(a1 + 69);
	*(x_DWORD *)(a1 + 8) = (x_DWORD)&unk_F4240;
	if (v2 == -38)
	{
		v3 = *(unsigned __int16 *)(a1 + 52);
		*(x_BYTE *)(a1 + 73) = 10;
		while (1)
		{
			v4 = x_DWORD_EA3E4[v3];
			if (v4 <= x_DWORD_EA3E4[0])
				break;
			if (*(x_BYTE *)(v4 + 69) == -23 && *(x_BYTE *)(v4 + 70) == 1)
			{
				*(x_BYTE *)(v4 + 70) = 2;
				*(x_WORD *)(v4 + 150) = *(x_WORD *)(a1 + 150);
			}
			v3 = *(unsigned __int16 *)(v4 + 52);
		}
	}
	else if (v2 == -40)
	{
		*(x_BYTE *)(a1 + 73) = 15;
	}
	return sub_29A90(a1);
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00029A90) --------------------------------------------------------
__int16 sub_29A90(int a1)
{
	int v1; // edx
	int v2; // eax
	unsigned int i; // ebx
	x_WORD *v4; // esi
	unsigned __int8 v5; // al
	int v6; // eax
	__int16 v7; // di
	unsigned __int16 v8; // ax
	__int16 v9; // ax
	unsigned int v10; // eax
	int v11; // eax
	int v12; // ecx
	int v13; // eax
	int v14; // eax
	int v15; // ecx
	int v16; // edi
	int v17; // eax
	signed int v18; // ecx
	int v19; // edx
	int j; // eax
	int v21; // eax
	char v22; // dh
	signed int v23; // eax
	signed int v24; // eax
	int v25; // eax
	char v26; // cl
	__int16 v27; // ax
	__int16 v28; // ax
	int v29; // ecx
	int k; // eax
	int v31; // ecx
	unsigned int v32; // edx
	int v34; // [esp+0h] [ebp-10h]
	unsigned int v35; // [esp+4h] [ebp-Ch]
	char v36; // [esp+8h] [ebp-8h]
	char v37; // [esp+Ch] [ebp-4h]

	HIWORD(v1) = HIWORD(a1);
	LOWORD(v2) = *(x_WORD *)(a1 + 52);
	for (i = x_DWORD_EA3E4[(unsigned __int16)v2]; i > x_DWORD_EA3E4[0]; i = x_DWORD_EA3E4[*(unsigned __int16 *)(i + 52)])
	{
		if (*(x_BYTE *)(i + 69) == -23)
		{
			LOBYTE(v1) = 0;
			v37 = 0;
			BYTE1(v1) = *(x_BYTE *)(i + 62) + 1;
			v4 = (x_WORD *)((char *)&off_D404C + 22 * *(unsigned __int8 *)(i + 59));
			v5 = *(x_BYTE *)(i + 70);
			*(x_BYTE *)(i + 62) = BYTE1(v1);
			if (v5 <= 5u)
			{
				*(x_WORD *)(i + 20) = 9377 * *(x_WORD *)(i + 20) + 9439;
				*(x_BYTE *)(i + 67) = *(x_WORD *)(i + 20) % 0x14u;
				sub_2A5B0(a1, i, 672);
				sub_2A660(a1, i);
				if (*(x_BYTE *)(i + 70) == 1)
				{
					*(x_WORD *)(i + 20) = 9377 * *(x_WORD *)(i + 20) + 9439;
					v6 = *(x_WORD *)(i + 20) & 7;
					v7 = *(x_WORD *)(i + 38);
					v34 = *(x_WORD *)(i + 20) & 7;
					if (v7)
					{
						if (v6 < 4)
						{
							*(x_WORD *)(i + 38) = 0;
							*(x_BYTE *)(i + 70) = 2;
							v8 = *(x_WORD *)(i + 54);
							*(x_WORD *)(i + 150) = v7;
							v8 += 22;
							*(x_WORD *)(i + 54) = v8;
							if (v8 > 0x44u)
								*(x_WORD *)(i + 54) = 68;
						}
					}
					else if (v6 < 4 && *(x_WORD *)(a1 + 150) && !(*(x_BYTE *)(i + 62) & 7))
					{
						v9 = *(x_WORD *)(a1 + 150);
						*(x_BYTE *)(i + 70) = 2;
						*(x_WORD *)(i + 150) = v9;
					}
				}
			}
			switch (*(x_BYTE *)(i + 70))
			{
			case 0:
				*(x_WORD *)(i + 150) = 0;
				*(x_BYTE *)(i + 70) = 1;
				*(x_WORD *)(i + 44) = 0;
				*(x_WORD *)(i + 54) = 0;
				*(x_WORD *)(i + 132) = 16;
				goto LABEL_15;
			case 1:
			LABEL_15:
				if (*(x_BYTE *)(a1 + 57))
				{
					if (!(*(x_BYTE *)(i + 62) & 7))
					{
						v1 = v34;
						if (v34)
						{
							if (v34 > 4)
								*(x_BYTE *)(i + 70) = 4;
						}
						else
						{
							v10 = sub_2A6F0(i);
							v35 = v10;
							if (v10)
							{
								v11 = v10 - (x_D41A0_BYTEARRAY_0[28302]);
								v1 = v11 % 168;
								*(x_BYTE *)(i + 70) = 2;
								*(x_WORD *)(i + 150) = v11 / 168;
							}
						}
					}
					if (!(*(x_BYTE *)(i + 62) & 7) && !(v34 & 1))
					{
						v12 = *(x_DWORD *)(i + 160);
						*(x_WORD *)(i + 20) = 9377 * *(x_WORD *)(i + 20) + 9439;
						v4 = (x_WORD *)(*(unsigned __int16 *)(a1 + 28) + (signed __int16)v4[6] - *(signed __int16 *)(v12 + 30));
						v1 = (int)v4 + *(unsigned __int16 *)(i + 20) % (unsigned int)*(signed __int16 *)(v12 + 30);
						*(x_WORD *)(i + 28) = v1;
					}
				}
				break;
			case 2:
				*(x_BYTE *)(i + 70) = 3;
				*(x_BYTE *)(i + 68) = 0;
				*(x_WORD *)(i + 44) = 2;
				*(x_WORD *)(i + 132) = 16;
				goto LABEL_26;
			case 3:
			LABEL_26:
				v13 = sub_2A7B0(i);
				v35 = v13;
				if (v13)
				{
					LOBYTE(v1) = *(x_BYTE *)(i + 68);
					if ((unsigned __int8)v1 < 1u)
					{
						if (!(x_BYTE)v1 && !*(x_WORD *)(i + 130))
						{
							v4 = (x_WORD *)(v13 + 76);
							*(x_BYTE *)(i + 68) = 1;
							*(x_WORD *)(i + 44) = 1;
							*(x_WORD *)(i + 132) = 16;
							*(x_WORD *)(i + 28) = sub_581E0((Bit16u*)(i + 76), (Bit16u*)(v13 + 76));
							*(x_WORD *)(i + 30) = sub_58210((x_WORD *)(i + 76), v4);
							v1 = a1;
							*(x_WORD *)(i + 32) = *(x_WORD *)(i + 28) - *(x_WORD *)(a1 + 28);
							*(x_WORD *)(i + 34) = *(x_WORD *)(i + 30) - *(x_WORD *)(a1 + 30);
						}
					}
					else if ((unsigned __int8)v1 <= 1u)
					{
						if (*(x_WORD *)(i + 130) == 192)
						{
							*(x_WORD *)(i + 44) = 3;
							*(x_BYTE *)(i + 68) = 3;
							*(x_DWORD *)(i + 16) = 4;
							v37 = 1;
						}
					}
					else if ((x_BYTE)v1 == 3)
					{
						v37 = 2;
						v14 = *(x_DWORD *)(i + 16) - 1;
						*(x_DWORD *)(i + 16) = v14;
						if (!v14)
						{
							*(x_BYTE *)(i + 70) = 0;
							*(x_DWORD *)(i + 16) = 1;
						}
					}
				}
				else
				{
					*(x_BYTE *)(i + 70) = 0;
				}
				break;
			case 4:
				*(x_BYTE *)(i + 70) = 5;
				*(x_BYTE *)(i + 68) = 0;
				*(x_WORD *)(i + 44) = 2;
				*(x_WORD *)(i + 132) = 16;
				goto LABEL_40;
			case 5:
			LABEL_40:
				switch (*(x_BYTE *)(i + 68))
				{
				case 0:
					if (!*(x_WORD *)(i + 130))
					{
						*(x_BYTE *)(i + 68) = 1;
						*(x_WORD *)(i + 44) = 1;
						*(x_WORD *)(i + 132) = -16;
						*(x_WORD *)(i + 32) = v4[6];
						*(x_WORD *)(i + 34) = v4[7];
						LOWORD(v1) = *(x_WORD *)(i + 32);
						*(x_WORD *)(i + 28) = v1 + *(x_WORD *)(a1 + 28);
						*(x_WORD *)(i + 30) = *(x_WORD *)(i + 34) + *(x_WORD *)(a1 + 30);
					}
					break;
				case 1:
					if (*(signed __int16 *)(i + 130) == -192)
					{
						*(x_BYTE *)(i + 68) = 2;
						*(x_DWORD *)(i + 16) = 2;
					}
					break;
				case 2:
					v15 = *(x_DWORD *)(i + 16) - 1;
					*(x_DWORD *)(i + 16) = v15;
					if (!v15)
					{
						*(x_WORD *)(i + 44) = 4;
						*(x_BYTE *)(i + 68) = 6;
						*(x_DWORD *)(i + 16) = 1;
					}
					break;
				case 5:
					v1 = *(x_DWORD *)(i + 16) - 1;
					*(x_DWORD *)(i + 16) = v1;
					if (v1 <= 4)
					{
						*(x_BYTE *)(i + 70) = 0;
						*(x_DWORD *)(i + 16) = 4;
					}
					break;
				case 6:
					sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 17);
					v16 = *(x_DWORD *)(i + 16) + 1;
					*(x_DWORD *)(i + 16) = v16;
					if (v16 >= 4)
						*(x_BYTE *)(i + 68) = 5;
					break;
				default:
					goto LABEL_94;
				}
				break;
			case 6:
				*(x_DWORD *)(i + 16) = 0;
				*(x_WORD *)(i + 44) = 2;
				*(x_BYTE *)(i + 70) = 7;
				*(x_BYTE *)(i + 68) = 0;
				*(x_WORD *)(i + 132) = 80;
				goto LABEL_52;
			case 7:
			LABEL_52:
				v36 = 0;
				sub_2A5B0(a1, i, 672);
				v17 = *(unsigned __int8 *)(i + 68);
				switch ((x_BYTE)v17)
				{
				case 0:
					if (!*(x_WORD *)(i + 130))
					{
						*(x_BYTE *)(i + 68) = 1;
						*(x_WORD *)(i + 44) = 1;
						*(x_WORD *)(i + 32) = v4[6];
						LOWORD(v17) = v4[7];
						*(x_WORD *)(i + 34) = v17;
					}
					break;
				case 1:
					LOWORD(v17) = *(x_WORD *)(i + 130);
					v36 = 1;
					if ((x_WORD)v17 == 192)
					{
						*(x_BYTE *)(i + 68) = 7;
						*(x_WORD *)(i + 44) = 5;
						*(x_DWORD *)(i + 16) = 8;
					}
					break;
				case 7:
					v36 = 1;
					v17 = *(x_DWORD *)(i + 16) - 1;
					*(x_DWORD *)(i + 16) = v17;
					if (!v17)
					{
						*(x_BYTE *)(i + 68) = 8;
						*(x_WORD *)(i + 44) = 6;
						*(x_WORD *)(i + 34) = 0;
						*(x_BYTE *)(i + 67) = 0;
						*(x_WORD *)(i + 54) = 0;
						*(x_WORD *)(i + 132) = 12;
						*(x_DWORD *)(i + 16) = 0;
					}
					break;
				case 8:
					v18 = *(x_DWORD *)(i + 16);
					if (v18 > 10)
					{
						*(x_BYTE *)(i + 70) = 8;
					}
					else
					{
						if (v18)
						{
							v19 = x_DWORD_EA3E4[*(unsigned __int16 *)(i + 52)];
							for (j = 0; ; j++)
							{
								v35 = v19;
								if (j >= 9 - *(x_DWORD *)(i + 16))
									break;
								v19 = x_DWORD_EA3E4[*(unsigned __int16 *)(v19 + 52)];
							}
						}
						else
						{
							v35 = i;
						}
						if (v35 > x_DWORD_EA3E4[0])
							*(x_BYTE *)(v35 + 12) = (*(x_BYTE *)(v35 + 12) | 1) & 0xF7;
						v21 = *(x_DWORD *)(i + 16) + 1;
						v22 = *(x_BYTE *)(i + 67) + 1;
						*(x_DWORD *)(i + 16) = v21;
						LOWORD(v21) = v22;
						v17 = 28 * v21;
						*(x_BYTE *)(i + 67) = v22;
						*(x_WORD *)(i + 54) += v17;
					}
					break;
				default:
					break;
				}
				if (v36)
				{
					if (*(x_BYTE *)(i + 62) & 1)
						v23 = -204;
					else
						v23 = 204;
					v17 = *(unsigned __int16 *)(a1 + 28) + (signed __int16)v4[6] + v23;
					*(x_WORD *)(i + 28) = v17;
				}
				sub_2A340(v17, a1, a1, (int)v4, a1, i);
				sub_2A940(a1, i);
				break;
			case 8:
				*(x_BYTE *)(i + 70) = 9;
				*(x_DWORD *)(i + 16) = 100;
				--*(x_BYTE *)(a1 + 59);
				goto LABEL_83;
			case 9:
			LABEL_83:
				v25 = *(x_DWORD *)(i + 16) - 1;
				*(x_DWORD *)(i + 16) = v25;
				if (!v25)
					*(x_BYTE *)(i + 70) = 10;
				break;
			case 0xA:
				++*(x_BYTE *)(a1 + 59);
				*(x_BYTE *)(i + 70) = 11;
				*(x_WORD *)(i + 44) = 5;
				v26 = *(x_BYTE *)(i + 12);
				*(x_DWORD *)(i + 16) = 7;
				v26 &= 0xF6u;
				v27 = *(x_WORD *)(i + 52);
				*(x_BYTE *)(i + 12) = v26;
				*(x_WORD *)(i + 150) = v27;
				*(x_BYTE *)(i + 12) = v26 | 8;
				*(x_WORD *)(i + 32) = v4[6];
				v28 = v4[7];
				*(x_WORD *)(i + 130) = 156;
				*(x_WORD *)(i + 34) = v28;
				goto LABEL_86;
			case 0xB:
			LABEL_86:
				v29 = *(x_DWORD *)(i + 16) - 1;
				*(x_DWORD *)(i + 16) = v29;
				if (v29 <= 0)
				{
					*(x_BYTE *)(i + 70) = 12;
					*(x_DWORD *)(i + 16) = 0;
				}
				break;
			case 0xC:
				if (*(x_DWORD *)(i + 16) < 9)
				{
					v1 = *(unsigned __int16 *)(i + 52);
					for (k = 0; ; k++)
					{
						v4 = (x_WORD *)x_DWORD_EA3E4[v1];
						if (k >= *(x_DWORD *)(i + 16))
							break;
						v1 = (unsigned __int16)v4[26];
					}
					*((x_BYTE *)v4 + 12) &= 0xFEu;
					v31 = *(x_DWORD *)(i + 16) + 1;
					*(x_WORD *)(i + 150) = v4[26];
					*(x_DWORD *)(i + 16) = v31;
					if (v31 >= 9)
					{
						*(x_WORD *)(i + 20) = 9377 * *(x_WORD *)(i + 20) + 9439;
						v32 = *(unsigned __int16 *)(i + 20) % 0x398u;
						*(x_WORD *)(i + 98) = 0;
						*(x_BYTE *)(i + 70) = 0;
						v1 = v32 + 920;
						*(x_DWORD *)(i + 8) = v1;
					}
				}
				break;
			case 0xD:
				*(x_BYTE *)(i + 70) = 14;
				*(x_BYTE *)(i + 67) = 10;
				*(x_DWORD *)(i + 16) = 10;
				goto LABEL_77;
			case 0xE:
			LABEL_77:
				v4 = (x_WORD *)(*(x_DWORD *)(i + 16) - 1);
				*(x_DWORD *)(i + 16) = (x_DWORD)v4;
				if (!v4)
					*(x_BYTE *)(i + 70) = 15;
				break;
			case 0xF:
				v35 = i;
				*(x_BYTE *)(i + 70) = 8;
				v24 = 0;
				do
				{
					*(x_BYTE *)(v35 + 12) = (*(x_BYTE *)(v35 + 12) | 1) & 0xF7;
					v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(v35 + 52)];
					++v24;
					v35 = x_DWORD_EA3E4[*(unsigned __int16 *)(v35 + 52)];
				} while (v24 < 10);
				break;
			default:
				break;
			}
		LABEL_94:
			v2 = *(unsigned __int8 *)(i + 70);
			switch ((x_BYTE)v2)
			{
			case 0:
			case 1:
			case 2:
			case 3:
			case 4:
			case 5:
				sub_2A340(v2, v1, a1, (int)v4, a1, i);
				sub_2A940(a1, i);
				sub_2AA90(i, a1, i);
				if (v37)
				{
					sub_2A7F0(i, v35, v37 == 1);
					sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 17);
				}
				goto LABEL_99;
			case 6:
			case 7:
				LOWORD(v2) = sub_2AA90(i, a1, i);
				break;
			case 0xB:
			case 0xC:
				sub_2A5B0(a1, i, 672);
				sub_2A940(a1, i);
				sub_2AA90(i, a1, i);
				v35 = x_DWORD_EA3E4[*(unsigned __int16 *)(i + 150)];
				*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(v35 + 76);
				*(&x_WORD_EB398 + 2) = *(x_WORD *)(v35 + 80);
				sub_57CF0(i, (int)&x_WORD_EB398);
			LABEL_99:
				LOWORD(v2) = sub_2A9F0(a1, i);
				break;
			default:
				continue;
			}
		}
	}
	return v2;
}
// D404C: using guessed type void *off_D404C;
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;

//----- (0002A340) --------------------------------------------------------
char sub_2A340(int a1, int a2, int a3, int a4, int a5, int a6)
{
	int v6; // eax
	int v7; // eax
	__int16 v8; // cx
	int v9; // edi
	__int16 v10; // dx
	__int16 v11; // di
	__int16 v12; // cx
	__int16 v13; // cx

	LOWORD(v6) = *(x_WORD *)(a6 + 44);
	switch ((x_WORD)v6)
	{
	case 0:
		LOWORD(a1) = *(x_WORD *)(a6 + 134);
		LOWORD(a2) = *(x_WORD *)(a6 + 54);
		v7 = a2 + a1 + 73;
		v8 = v7 + *(x_WORD *)(a6 + 32);
		LOWORD(v7) = *(x_WORD *)(a6 + 134);
		LOWORD(a4) = *(x_WORD *)(a6 + 54);
		LOWORD(a3) = *(x_WORD *)(a6 + 34);
		*(x_WORD *)(a6 + 32) = v8;
		v9 = a4 + v7 + 62 + a3;
		LOWORD(v7) = *(x_WORD *)(a6 + 130);
		*(x_WORD *)(a6 + 34) = v9;
		if ((x_WORD)v7 != 192)
		{
			v10 = *(x_WORD *)(a6 + 132) + *(x_WORD *)(a6 + 130);
			*(x_WORD *)(a6 + 130) = v10;
			if (abs(v10) > 192)
			{
				if (*(x_WORD *)(a6 + 132) <= 0)
					*(x_WORD *)(a6 + 130) = -192;
				else
					*(x_WORD *)(a6 + 130) = 192;
				*(x_WORD *)(a6 + 132) = -*(x_WORD *)(a6 + 132);
			}
		}
		if (!(*(x_BYTE *)(a6 + 62) & 1))
		{
			v11 = *(x_WORD *)(a6 + 54);
			if (v11)
				*(x_WORD *)(a6 + 54) = v11 - 1;
		}
		LOBYTE(v6) = *(x_BYTE *)(a6 + 67);
		if ((x_BYTE)v6)
		{
			if ((x_BYTE)v6 == 3 && *(x_WORD *)(a6 + 130) == 192)
			{
				*(x_WORD *)(a6 + 132) = -16;
				LOWORD(v6) = *(x_WORD *)(a6 + 132);
				*(x_WORD *)(a6 + 130) += v6;
			}
		}
		else
		{
			*(x_WORD *)(a6 + 20) = 9377 * *(x_WORD *)(a6 + 20) + 9439;
			LOWORD(v6) = *(x_WORD *)(a6 + 20) / 0x1Cu;
			*(x_WORD *)(a6 + 134) = *(x_WORD *)(a6 + 20) % 0x1Cu;
		}
		break;
	case 1:
		v6 = abs(*(signed __int16 *)(a6 + 130));
		if (v6 < 192)
		{
			LOWORD(v6) = *(x_WORD *)(a6 + 132);
			*(x_WORD *)(a6 + 130) += v6;
		}
		if (*(x_WORD *)(a6 + 132) <= 0)
		{
			v6 = *(signed __int16 *)(a6 + 130);
			if (v6 < -192)
				LABEL_23:
			*(x_WORD *)(a6 + 130) = -192;
		}
		else if (*(x_WORD *)(a6 + 130) > 192)
		{
		LABEL_21:
			*(x_WORD *)(a6 + 130) = 192;
		}
		break;
	case 2:
		v6 = abs(*(signed __int16 *)(a6 + 130));
		if (v6 < *(signed __int16 *)(a6 + 132))
		{
			*(x_WORD *)(a6 + 130) = 0;
		}
		else
		{
			v12 = *(x_WORD *)(a6 + 130);
			if (v12 <= 0)
			{
				LOWORD(v6) = *(x_WORD *)(a6 + 132);
				*(x_WORD *)(a6 + 130) = v6 + v12;
			}
			else
			{
				LOWORD(v6) = *(x_WORD *)(a6 + 132);
				*(x_WORD *)(a6 + 130) = v12 - v6;
			}
		}
		break;
	case 3:
	case 4:
		v6 = *(x_DWORD *)(a6 + 16) - 1;
		switch (*(x_DWORD *)(a6 + 16))
		{
		case 1:
			goto LABEL_23;
		case 2:
			*(x_WORD *)(a6 + 130) = -130;
			return v6;
		case 3:
			*(x_WORD *)(a6 + 130) = -23;
			return v6;
		case 4:
			goto LABEL_21;
		default:
			return v6;
		}
	case 6:
		v13 = *(x_WORD *)(a6 + 80) - *(x_WORD *)(a6 + 54);
		*(x_WORD *)(a6 + 130) -= *(x_WORD *)(a6 + 132);
		*(x_WORD *)(a6 + 80) = v13;
		LOWORD(v6) = sub_10C40((__int16 *)(a6 + 76));
		if (*(signed __int16 *)(a6 + 80) < (signed __int16)v6)
			*(x_WORD *)(a6 + 80) = v6;
		break;
	default:
		return v6;
	}
	return v6;
}

//----- (0002A5B0) --------------------------------------------------------
signed int sub_2A5B0(int a1, int a2, __int16 a3)
{
	__int16 *v3; // ebx
	__int16 v4; // si
	__int16 v5; // ax

	v3 = (__int16 *)((char *)&off_D404C + 22 * *(unsigned __int8 *)(a2 + 59));
	*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
	*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
	sub_57FA0((x_WORD*)&x_WORD_EB398, v3[1] + *(x_WORD *)(a1 + 28), 0, *v3);
	v4 = v3[7];
	v5 = *(x_WORD *)(a1 + 30);
	x_WORD_EB39C += v3[2];
	sub_57FA0((x_WORD*)&x_WORD_EB398, v3[6] + *(x_WORD *)(a1 + 28), v4 + v5, a3);
	return sub_57CF0(a2, (int)&x_WORD_EB398);
}
// D404C: using guessed type void *off_D404C;
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (0002A660) --------------------------------------------------------
int sub_2A660(int a1, int a2)
{
	int result; // eax
	__int16 v3; // dx
	signed int v4; // edx
	__int16 v5; // dx
	int v6; // ecx

	result = a2;
	v3 = *(x_WORD *)(a2 + 98);
	if (v3)
	{
		*(x_WORD *)(a1 + 98) = v3;
		v4 = *(x_DWORD *)(a2 + 94);
		*(x_DWORD *)(a1 + 94) = v4;
		if (v4 > 76)
			v4 = 76;
		*(x_DWORD *)(a2 + 8) -= v4;
		v5 = *(x_WORD *)(a2 + 98);
		*(x_WORD *)(a2 + 98) = 0;
		v6 = *(x_DWORD *)(a2 + 8);
		*(x_WORD *)(a2 + 38) = v5;
		if (v6 < 0)
			*(x_BYTE *)(a2 + 70) = 6;
	}
	return result;
}

//----- (0002A6B0) --------------------------------------------------------
signed int sub_2A6B0(int a1)
{
	__int16 v1; // bx
	signed int v2; // edx
	char v3; // dl

	v1 = *(x_WORD *)(a1 + 98);
	v2 = 0;
	if (v1)
	{
		v3 = *(x_BYTE *)(a1 + 59);
		*(x_WORD *)(a1 + 38) = v1;
		if (v3)
		{
			v2 = 1;
		}
		else
		{
			*(x_BYTE *)(a1 + 69) = -36;
			v2 = 2;
			*(x_WORD *)(a1 + 36) = v1;
		}
		*(x_WORD *)(a1 + 98) = 0;
	}
	return v2;
}

//----- (0002A6F0) --------------------------------------------------------
unsigned int sub_2A6F0(int a1)
{
	int v1; // esi
	unsigned int v2; // edi
	unsigned int v3; // ebx
	int v4; // esi
	signed int v5; // ST08_4
	__int16 v6; // ax
	int v8; // [esp+4h] [ebp-10h]
	signed int v9; // [esp+10h] [ebp-4h]

	v1 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 28);
	v2 = 0;
	v9 = 0x10000000;
	v3 = x_D41A0_BYTEARRAY_4[0x9677];
	v8 = v1 * v1;
	while (v3 > x_DWORD_EA3E4[0])
	{
		v4 = sub_584D0((x_WORD *)(a1 + 76), (x_WORD *)(v3 + 76));
		if (v4 < v8)
		{
			v5 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 30);
			v6 = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v3 + 76));
			if ((unsigned __int16)sub_582B0(*(x_WORD *)(a1 + 28), v6) < v5 && v4 < v9)
			{
				v2 = v3;
				v9 = v4;
			}
		}
		v3 = *(x_DWORD *)v3;
	}
	return v2;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0002A7B0) --------------------------------------------------------
int sub_2A7B0(int a1)
{
	unsigned __int16 v1; // bx
	int result; // eax
	int v3; // edx

	v1 = *(x_WORD *)(a1 + 150);
	result = 0;
	if (v1)
	{
		v3 = x_DWORD_EA3E4[v1];
		if (*(x_DWORD *)(v3 + 8) >= 0 && !(*(x_BYTE *)(v3 + 13) & 4))
			result = x_DWORD_EA3E4[v1];
	}
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0002A7F0) --------------------------------------------------------
void sub_2A7F0(int a1, int a2, char a3)
{
	int v3; // esi
	signed int v4; // edx
	unsigned int v5; // eax
	int v6; // eax
	__int16 v7; // [esp-4h] [ebp-8h]

	v3 = 0;
	if (a3)
	{
		*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
		v4 = *(unsigned __int16 *)(a1 + 20) % 0xCu;
		*(x_WORD *)(a1 + 20) += x_D41A0_BYTEARRAY_4_struct.setting_30;
		*(x_DWORD *)(a1 + 136) = (v4 > 7) + 1;
	}
	v5 = *(x_DWORD *)(a1 + 136);
	if (v5 >= 1)
	{
		if (v5 <= 1)
		{
			if (!a3)
				goto LABEL_13;
			v6 = sub_4A190(a1 + 76, 9, 0);
			v3 = v6;
			if (!v6)
				goto LABEL_13;
			*(x_BYTE *)(v6 + 67) = 10;
			*(x_BYTE *)(v6 + 68) = 0;
			v7 = 15;
		}
		else
		{
			if (v5 != 2)
				goto LABEL_13;
			v6 = sub_4A190(a1 + 76, 9, 9);
			v3 = v6;
			if (!v6)
				goto LABEL_13;
			*(x_BYTE *)(v6 + 67) = 10;
			*(x_BYTE *)(v6 + 68) = 23;
			v7 = 23;
		}
		*(x_WORD *)(v6 + 42) = 850;
		sub_6E450(*(x_WORD *)(a1 + 26), -1, v7);
	}
LABEL_13:
	if (v3)
	{
		*(x_WORD *)(v3 + 26) = *(x_WORD *)(a1 + 26);
		*(x_WORD *)(v3 + 28) = sub_581E0((Bit16u *)(a1 + 76), (Bit16u *)(a2 + 76));
		*(x_WORD *)(v3 + 30) = sub_58210((int16 *)(a1 + 76), (int16 *)(a2 + 76));
		*(x_WORD *)(v3 + 80) += *(x_WORD *)(a1 + 88) / 2;
		*(x_WORD *)(v3 + 150) = *(x_WORD *)(a1 + 150);
		*(x_DWORD *)(v3 + 160) = (x_DWORD)&off_D89EA;
		*(x_BYTE *)(v3 + 66) = *(x_BYTE *)(a2 + 64);
		*(x_BYTE *)(v3 + 65) = *(x_BYTE *)(a2 + 63);
	}
}
// D41A4: using guessed type int x_DWORD_D41A4;
// D89EA: using guessed type void *off_D89EA;

//----- (0002A940) --------------------------------------------------------
signed int sub_2A940(signed int a1, int a2)
{
	signed int result; // eax
	char *v3; // edx

	result = a1;
	if (x_DWORD_E9BA8)
	{
		v3 = (char *)&off_D404C + 22 * *(unsigned __int8 *)(a2 + 59);
		*(x_WORD *)(a2 + 32) = *((x_WORD *)v3 + 6);
		LOWORD(v3) = *((x_WORD *)v3 + 7);
		*(x_WORD *)(a2 + 130) = 192;
		*(x_BYTE *)(a2 + 70) = 0;
		*(x_WORD *)(a2 + 34) = (x_WORD)v3;
		*(x_BYTE *)(a1 + 13) |= 8u;
	}
	else
	{
		*(x_BYTE *)(a1 + 13) &= 0xF7u;
	}
	if (*(x_WORD *)(a2 + 130))
	{
		*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a2 + 76);
		*(&x_WORD_EB398 + 2) = *(x_WORD *)(a2 + 80);
		sub_57FA0(
			&x_WORD_EB398,
			*(x_WORD *)(a2 + 32) + *(x_WORD *)(a1 + 28),
			*(x_WORD *)(a2 + 34) + *(x_WORD *)(a1 + 30),
			*(x_WORD *)(a2 + 130));
		result = sub_57CF0(a2, (int)&x_WORD_EB398);
	}
	return result;
}
// D404C: using guessed type void *off_D404C;
// E9BA8: using guessed type int x_DWORD_E9BA8;
// EB398: using guessed type __int16 x_WORD_EB398;

//----- (0002A9F0) --------------------------------------------------------
signed int sub_2A9F0(int a1, int a2)
{
	int v2; // eax
	x_WORD *v3; // eax
	__int16 v4; // di
	__int16 v5; // ST0C_2
	__int16 v6; // dx

	v2 = 22 * *(unsigned __int8 *)(a2 + 59);
	*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a2 + 76);
	*(&x_WORD_EB398 + 2) = *(x_WORD *)(a2 + 80);
	v3 = (x_WORD *)((char *)&off_D404C + v2);
	v4 = v3[7];
	v5 = v3[3];
	v6 = *(x_WORD *)(a1 + 30);
	x_WORD_EB39C += v3[5];
	sub_57FA0((x_WORD*)&x_WORD_EB398, v3[6] + *(x_WORD *)(a1 + 28), v4 + v6, v5);
	return sub_57CF0(a2, (int)&x_WORD_EB398);
}
// D404C: using guessed type void *off_D404C;
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (0002AA90) --------------------------------------------------------
unsigned __int16 sub_2AA90(int a1, int a2, int a3)
{
	__int16 *v3; // ecx
	__int16 v4; // ax
	int v5; // eax
	signed int v6; // esi
	x_WORD *v7; // edi
	int v8; // eax
	int v9; // ebx
	__int16 v10; // ax
	unsigned __int16 result; // ax
	int v12; // [esp+0h] [ebp-20h]
	int v13; // [esp+4h] [ebp-1Ch]
	int v14; // [esp+8h] [ebp-18h]
	__int16 v15; // [esp+Ch] [ebp-14h]
	__int16 *v16; // [esp+10h] [ebp-10h]
	int v17; // [esp+14h] [ebp-Ch]
	int v18; // [esp+18h] [ebp-8h]
	int v19; // [esp+1Ch] [ebp-4h]

	v3 = (__int16 *)((char *)&off_D404C + 22 * *(unsigned __int8 *)(a3 + 59));
	v12 = *(x_DWORD *)(a2 + 76);
	LOWORD(v13) = *(x_WORD *)(a2 + 80);
	v4 = *v3;
	v16 = v3;
	sub_57FA0((x_WORD*)&v12, v3[1] + *(x_WORD *)(a2 + 28), 0, v4);
	LOWORD(v13) = v16[2] + v13;
	v14 = *(x_DWORD *)(a3 + 76);
	v15 = *(x_WORD *)(a3 + 80);
	v5 = (signed int)(sub_583F0((x_WORD*)&v12, (x_WORD*)&v14) - 468) / 24;
	v18 = 16 - v5;
	if (16 - v5 <= 15)
	{
		if (16 - v5 < 0)
			v18 = 0;
	}
	else
	{
		v18 = 15;
	}
	LOWORD(v19) = sub_581E0((Bit16u *)&v12, (Bit16u *)&v14);
	v19 = (unsigned __int16)v19;
	LOWORD(v17) = sub_58210((int16 *)&v12, (int16 *)&v14);
	v17 = (unsigned __int16)v17;
	v6 = 0;
	v7 = (x_WORD *)x_DWORD_EA3E4[*(unsigned __int16 *)(a3 + 52)];
	do
	{
		v8 = 3 * v18;
		switch (v6)
		{
		case 0:
			LOWORD(a1) = 0;
			break;
		case 1:
		case 8:
			v9 = x_DWORD_D40BC[v8];
			goto LABEL_12;
		case 2:
		case 7:
			v9 = x_DWORD_D40C0[v8];
		LABEL_12:
			a1 = -v9;
			break;
		case 3:
		case 6:
			a1 = x_DWORD_D40C0[v8];
			break;
		case 4:
		case 5:
			a1 = x_DWORD_D40BC[v8];
			break;
		default:
			break;
		}
		if (v6)
			sub_57FA0((x_WORD*)&v12, v19, a1 + v17, 96);
		sub_57CF0((int)v7, (int)&v12);
		if (*(x_BYTE *)(a3 + 70) == 7 && *(x_BYTE *)(a3 + 68) == 8)
		{
			v10 = sub_10C40(v7 + 38);
			if ((signed __int16)v7[40] <= v10)
				v7[40] = v10;
		}
		result = v7[26];
		++v6;
		v7 = (x_WORD *)x_DWORD_EA3E4[result];
	} while (v6 < 9);
	return result;
}
// D404C: using guessed type void *off_D404C;
// D40BC: using guessed type int x_DWORD_D40BC[];
// D40C0: using guessed type int x_DWORD_D40C0[];
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0002AC50) --------------------------------------------------------
x_WORD *sub_2AC50(int a1)
{
	int v1; // ebx
	int v2; // ecx
	int v3; // edx
	int v4; // ecx
	char v5; // ah

	v1 = a1;
	*(x_WORD *)(a1 + 32) = 0;
	*(x_WORD *)(v1 + 28) = *(x_WORD *)(v1 + 32);
	v2 = (int)x_D41A0_BYTEARRAY_0;
	*(x_WORD *)(v1 + 30) = *(x_WORD *)(v1 + 32);
	*(x_WORD *)(a1 + 132) = 64;
	*(x_WORD *)(a1 + 134) = 0;
	*(x_WORD *)(a1 + 130) = 30;
	*(x_BYTE *)(a1 + 59) = 5;
	*(x_DWORD *)(a1 + 8) = (x_DWORD)&unk_F4240;
	*(x_DWORD *)(a1 + 4) = 36000;
	*(x_DWORD *)(a1 + 144) = 20000;
	*(x_DWORD *)(v1 + 16) = (v1 - (v2 + 28302)) / 168 % 100;
	v3 = *(char *)(a1 + 64);
	*(x_WORD *)(a1 + 34) = 0;
	v4 = v3 + v2;
	*(x_BYTE *)(a1 + 56) = 1;
	LOBYTE(v3) = (*(x_BYTE *)(v4 + 16))++;
	*(x_DWORD *)(a1 + 160) = (x_DWORD)&off_D88B8;
	*(x_BYTE *)(a1 + 62) = v3;
	v5 = *(x_BYTE *)(a1 + 15) | 0x80;
	LOBYTE(v3) = *(x_BYTE *)(*(x_DWORD *)(a1 + 160) + 26);
	*(x_BYTE *)(a1 + 65) = 3;
	*(x_BYTE *)(a1 + 15) = v5;
	*(x_BYTE *)(a1 + 57) = v3 + 1;
	sub_49CD0((x_WORD *)a1, 315);
	return sub_49EA0((x_WORD *)a1, 1024, 1536);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D88B8: using guessed type void *off_D88B8;

//----- (0002AD40) --------------------------------------------------------
unsigned __int16 sub_2AD40(signed int a1)
{
	unsigned __int16 result; // ax
	signed int v2; // esi
	unsigned int i; // ebx
	__int16 v4; // cx
	int v5; // eax

	result = *(x_WORD *)(a1 + 52);
	v2 = 1;
	for (i = x_DWORD_EA3E4[result]; i > x_DWORD_EA3E4[0]; i = x_DWORD_EA3E4[*(unsigned __int16 *)(i + 52)])
	{
		if (*(x_BYTE *)(i + 69) == -23)
		{
			sub_49CD0((x_WORD *)i, 316);
			*(x_BYTE *)(i + 15) |= 0xA0u;
			*(x_WORD *)(i + 20) = 9377 * *(x_WORD *)(i + 20) + 9439;
			v4 = *(x_WORD *)(i + 20);
			*(x_WORD *)(i + 32) = *(x_WORD *)(i + 20) & 0x7FF;
			*(x_WORD *)(i + 20) = 9377 * v4 + 9439;
			*(x_WORD *)(i + 34) = *(x_WORD *)(i + 20) & 0x7FF;
			*(x_WORD *)(i + 132) = 16;
			*(x_WORD *)(i + 130) = 16;
			*(x_DWORD *)(i + 160) = (x_DWORD)&off_D8984;
			*(x_BYTE *)(i + 56) = 1;
			v5 = 460 * v2 + 920;
			*(x_DWORD *)(i + 8) = v5;
			*(x_DWORD *)(i + 4) = v5;
			result = sub_2A940(a1, i);
		}
		++v2;
	}
	return result;
}
// D8984: using guessed type void *off_D8984;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0002AE30) --------------------------------------------------------
int sub_2AE30(int a1)
{
	int result; // eax
	int i; // ebx
	unsigned int v3; // ebx

	result = a1;
	for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v3 + 52))
	{
		v3 = x_DWORD_EA3E4[i];
		if (v3 <= x_DWORD_EA3E4[0])
			break;
		if (*(x_BYTE *)(v3 + 69) == -22)
		{
			result = sub_49CD0((x_WORD *)v3, 317);
			*(x_BYTE *)(v3 + 15) |= 0xA0u;
		}
	}
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0002AE80) --------------------------------------------------------
void sub_2AE80(unsigned int a1)
{
	int i; // ebx
	unsigned int v2; // ebx
	//int result; // eax

	if (a1 && a1 > x_DWORD_EA3E4[0])
	{
		for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v2 + 52))
		{
			v2 = x_DWORD_EA3E4[i];
			if (v2 <= x_DWORD_EA3E4[0])
				break;
			sub_57F10(v2);
		}
		sub_57F10(a1);
	}
	//return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0002AED0) --------------------------------------------------------
char sub_2AED0(int a1, int a2)
{
	int v2; // eax

	v2 = *(signed __int16 *)(a1 + 90);
	if (a2 != v2)
	{
		*(x_WORD *)(a1 + 90) = a2;
		*(x_BYTE *)(a1 + 92) = 0;
		LOBYTE(v2) = x_BYTE_D8A2E[(unsigned __int8)x_BYTE_D9528[14 * a2]];
		*(x_BYTE *)(a1 + 93) = v2;
	}
	return v2;
}

//----- (0002AF10) --------------------------------------------------------
char sub_2AF10(int a1, char a2)
{
	char v2; // dh
	char v3; // al
	signed int v4; // eax
	__int16 v5; // ax
	signed int v7; // [esp+0h] [ebp-1Ch]
	unsigned __int16 v8; // [esp+4h] [ebp-18h]
	int v9; // [esp+8h] [ebp-14h]
	char v10; // [esp+Ch] [ebp-10h]
	char v11; // [esp+10h] [ebp-Ch]
	char v12; // [esp+14h] [ebp-8h]
	char v13; // [esp+18h] [ebp-4h]

	v2 = *(x_BYTE *)(a1 + 14);
	v10 = 0;
	v12 = 0;
	if (v2 & 0x10)
		*(x_BYTE *)(a1 + 14) = v2 & 0xEF;
	else
		*(x_BYTE *)(a1 + 12) &= 0xFEu;
	v3 = *(x_BYTE *)(a1 + 13);
	if (v3 & 8)
	{
		*(x_BYTE *)(a1 + 13) = v3 & 0xF7;
		v13 = 4;
	}
	else
	{
		*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
		*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
		if (a2)
			sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), 0, *(x_WORD *)(a1 + 130));
		x_WORD_EB39C = sub_10C40(&x_WORD_EB398);
		if (a2
			&& *(signed __int16 *)(a1 + 76) >> 8 == x_WORD_EB398 >> 8
			&& *(signed __int16 *)(a1 + 78) >> 8 == x_WORD_EB39A >> 8)
		{
			v10 = 1;
			v12 = 1;
			v13 = 1;
			*(x_BYTE *)(a1 + 14) &= 0xFBu;
		}
		else if (sub_102D0(a1, &x_WORD_EB398, 1) || sub_102D0(a1, &x_WORD_EB398, 4) || sub_1B830(&x_WORD_EB398) >= 32)
		{
			if (*(x_WORD *)(a1 + 28) == *(x_WORD *)(a1 + 32))
			{
				*(x_BYTE *)(a1 + 14) |= 4u;
				v7 = 91;
				v9 = 1;
				v11 = BYTE1(v7);
				while (v7 <= 1024)
				{
					*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
					*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
					v8 = (*(x_WORD *)(a1 + 28) + v9 * v7) & 0x7FF;
					sub_57FA0((x_WORD*)&x_WORD_EB398, v8, 0, *(x_WORD *)(a1 + 130));
					x_WORD_EB39C = sub_10C40(&x_WORD_EB398);
					if (!sub_102D0(a1, &x_WORD_EB398, 1) && !sub_102D0(a1, &x_WORD_EB398, 4) && sub_1B830(&x_WORD_EB398) < 32)
					{
						v11 = 1;
						break;
					}
					v9 = 0 - v9;
					if (v9 == 1)
						v4 = 91;
					else
						v4 = 0;
					v7 += v4;
				}
				if (v11)
				{
					*(x_WORD *)(a1 + 32) = v8;
					v12 = 1;
					v13 = 3;
				}
				else
				{
					v13 = 4;
				}
			}
			else
			{
				*(x_BYTE *)(a1 + 14) |= 4u;
				v12 = 1;
				v13 = 3;
			}
		}
		else
		{
			v10 = 1;
			v12 = 1;
			v13 = 2;
			*(x_BYTE *)(a1 + 14) &= 0xFBu;
		}
		if (a2 && v10)
			sub_57CF0(a1, (int)&x_WORD_EB398);
		if (v12)
		{
			v5 = *(x_WORD *)(a1 + 28)
				+ sub_58350(
					*(x_WORD *)(a1 + 28),
					*(x_WORD *)(a1 + 32),
					*(unsigned __int16 *)(*(x_DWORD *)(a1 + 160) + 4),
					*(x_WORD *)(*(x_DWORD *)(a1 + 160) + 2));
			HIBYTE(v5) &= 7u;
			*(x_WORD *)(a1 + 28) = v5;
		}
		*(x_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
	}
	if (v13 == 4)
	{
		*(x_BYTE *)(a1 + 69) = -40;
		*(x_DWORD *)(a1 + 16) = 0;
	}
	return v13;
}
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39A: using guessed type __int16 x_WORD_EB39A;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (0002B1D0) --------------------------------------------------------
signed int sub_2B1D0(int a1)
{
	signed int result; // eax

	result = sub_1BD90(a1, 224);
	BYTE1(result) = *(x_BYTE *)(a1 + 69);
	if (BYTE1(result) == -30)
		result = sub_2B840(a1);
	return result;
}

//----- (0002B200) --------------------------------------------------------
void sub_2B200(int a1)
{
	sub_1BF90(a1, 224);
	if (*(x_BYTE *)(a1 + 69) == -30)
		sub_2B840(a1);
}

//----- (0002B260) --------------------------------------------------------
char sub_2B260(int a1)
{
	signed int v1; // eax
	__int16 v2; // dx
	unsigned __int16 *v3; // edx
	int v4; // edi
	unsigned int v5; // ecx
	Bit8u* v6; // edx
	__int16 v7; // ax
	char v8; // dl
	unsigned __int16 v9; // di
	char v10; // al
	unsigned __int16 *v11; // edx
	int v12; // esi
	char v13; // al
	unsigned int v14; // ecx
	char v15; // cl
	signed __int16 v16; // ax
	char v17; // al
	unsigned __int16 v18; // cx
	unsigned __int16 *v19; // edx
	unsigned int v20; // esi
	int v21; // esi
	int v23; // [esp+0h] [ebp-1Ch]
	unsigned __int16 v24; // [esp+4h] [ebp-18h]
	unsigned __int16 *v25; // [esp+8h] [ebp-14h]
	char v26; // [esp+Ch] [ebp-10h]
	char v27; // [esp+10h] [ebp-Ch]
	char v28; // [esp+14h] [ebp-8h]
	char v29; // [esp+18h] [ebp-4h]

	// fix if begin
	v25 = 0;
	// end

	v1 = sub_2B9A0(a1);
	if ((unsigned int)v1 <= 1)
	{
		LOBYTE(v1) = *(x_BYTE *)(a1 + 70);
		switch ((x_BYTE)v1)
		{
		case 0:
			sub_2B860(a1, 3u);
			LOBYTE(v1) = sub_2BA50(a1, 1u);
			return v1;
		case 1:
			sub_4A190(a1 + 76, 10, 5);
			LOBYTE(v1) = sub_2BA50(a1, 2u);
			return v1;
		case 2:
			LOBYTE(v1) = 0;
			v2 = *(x_WORD *)(a1 + 150);
			v29 = 0;
			if (v2)
			{
				v3 = (unsigned __int16 *)x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
				v25 = v3;
				if ((unsigned int)v3 > x_DWORD_EA3E4[0] && *((x_DWORD *)v3 + 2) >= 0 && !(*((x_BYTE *)v3 + 13) & 4))
					LOBYTE(v1) = 1;
			}
			if (!(x_BYTE)v1 || (v4 = *(x_DWORD *)(a1 + 16) - 1, *(x_DWORD *)(a1 + 16) = v4, v4 <= 0))
			{
				v29 = 1;
				goto LABEL_31;
			}
			v23 = *((x_DWORD *)v25 + 19);
			v24 = v25[40];
			sub_57FA0((x_WORD*)&v23, v25[14], 0, 768);
			if (!(*(x_BYTE *)(a1 + 62) & 3))
				*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u *)(a1 + 76), (Bit16u *)&v23);
			if (*(x_BYTE *)(a1 + 62) & 3)
				goto LABEL_22;
			v28 = 0;
			v5 = x_D41A0_BYTEARRAY_4[*(char *)(a1 + 64) + 38403];
			while (2)
			{
				if (v5 > x_DWORD_EA3E4[0])
				{
					if (*(x_WORD *)(v5 + 26) == *(x_WORD *)(a1 + 26)
						|| abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(v5 + 76)) >= (signed int)*(signed __int16 *)(a1 + 84)
						|| abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(v5 + 78)) >= (signed int)*(signed __int16 *)(a1 + 84))
					{
						v5 = *(x_DWORD *)v5;
						continue;
					}
					*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u *)(v5 + 76), (Bit16u *)(a1 + 76));
					v28 = 1;
				}
				break;
			}
		LABEL_22:
			v1 = sub_1B8C0(a1);
			if (v1 == 3)
			{
				LOBYTE(v1) = sub_2BA50(a1, 7u);
			}
			else if (!(*(x_BYTE *)(a1 + 62) & 3) && *(x_DWORD *)(a1 + 16) < 14)
			{
				v1 = sub_584D0((x_WORD *)(a1 + 76), (x_WORD*)&v23);
				if (v1 < 2768896)
				{
					LOBYTE(v1) = sub_2B7E0(a1);
					if (!(x_BYTE)v1)
						LOBYTE(v1) = sub_2BA50(a1, 3u);
				}
			}
		LABEL_31:
			if (v29)
			{
				LOBYTE(v1) = sub_2B7E0(a1);
				if (!(x_BYTE)v1)
					LOBYTE(v1) = sub_2BA50(a1, 3u);
			}
			return v1;
		case 3:
			sub_2BA50(a1, 4u);
			sub_2B860(a1, 2u);
			v6 = x_D41A0_BYTEARRAY_0 + 28302;
			*(x_WORD *)(a1 + 48) = *(x_WORD *)(a1 + 28);
			sub_6E450((a1 - (int)v6) / 168, -1, 38);
			goto LABEL_35;
		case 4:
		case 5:
		LABEL_35:
			if (*(x_DWORD *)(a1 + 16) <= 0)
			{
				LOBYTE(v1) = sub_2BA50(a1, 6u);
				return v1;
			}
			v7 = *(x_WORD *)(a1 + 48);
			*(x_WORD *)(a1 + 28) = v7;
			v8 = *(x_BYTE *)(a1 + 70);
			*(x_WORD *)(a1 + 32) = v7;
			if (v8 == 4)
			{
				v9 = *(x_WORD *)(a1 + 150);
				v10 = 0;
				if (v9)
				{
					v11 = (unsigned __int16 *)x_DWORD_EA3E4[v9];
					v25 = v11;
					if ((unsigned int)v11 > x_DWORD_EA3E4[0] && *((x_DWORD *)v11 + 2) >= 0 && !(*((x_BYTE *)v11 + 13) & 4))
						v10 = 1;
				}
				if (v10)
				{
					if (!(*(x_BYTE *)(a1 + 62) & 7) && sub_584D0((x_WORD *)(a1 + 76), (x_WORD*)(v25 + 38)) > 802816)
						*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u *)(a1 + 76), (Bit16u *)(v25 + 38));
					v12 = *(x_DWORD *)(a1 + 16);
					if (*(signed __int16 *)(a1 + 44) - 3 > v12 && v12 > 3 && (unsigned __int16)sub_1CED0(a1, (int)v25))
						*(x_BYTE *)(a1 + 70) = 5;
				}
			}
			v13 = *(x_BYTE *)(a1 + 62);
			--*(x_DWORD *)(a1 + 16);
			if (v13 & 3)
				goto LABEL_58;
			v27 = 0;
			v14 = x_D41A0_BYTEARRAY_4[*(char *)(a1 + 64) + 38403];
			break;
		case 6:
			sub_2B860(a1, 3u);
			sub_4A190(a1 + 76, 10, 5);
			v17 = 0;
			v18 = *(x_WORD *)(a1 + 150);
			v26 = 0;
			if (v18)
			{
				v19 = (unsigned __int16 *)x_DWORD_EA3E4[v18];
				v25 = v19;
				if ((unsigned int)v19 > x_DWORD_EA3E4[0] && *((x_DWORD *)v19 + 2) >= 0 && !(*((x_BYTE *)v19 + 13) & 4))
					v17 = 1;
			}
			if (v17)
			{
				v20 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 28);
				if (sub_583F0((x_WORD *)(a1 + 76), (x_WORD*)(v25 + 38)) < v20)
					v26 = 1;
			}
			if (v26)
				LOBYTE(v1) = sub_2BA50(a1, 2u);
			else
				LOBYTE(v1) = sub_2BA50(a1, 7u);
			return v1;
		case 7:
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			*(x_WORD *)(a1 + 32) = *(x_WORD *)(a1 + 20) & 0x7FF;
			sub_2BA50(a1, 8u);
			goto LABEL_76;
		case 8:
		LABEL_76:
			LOBYTE(v1) = sub_1B8C0(a1);
			v21 = *(x_DWORD *)(a1 + 16) - 1;
			*(x_DWORD *)(a1 + 16) = v21;
			if (v21 <= 0)
				LOBYTE(v1) = sub_2BA50(a1, 9u);
			return v1;
		case 9:
			LOBYTE(v1) = sub_2B860(a1, 1u);
			*(x_BYTE *)(a1 + 69) = -31;
			*(x_WORD *)(a1 + 150) = 0;
			return v1;
		default:
			return v1;
		}
		while (v14 > x_DWORD_EA3E4[0])
		{
			if (*(x_WORD *)(v14 + 26) != *(x_WORD *)(a1 + 26)
				&& abs(*(signed __int16 *)(a1 + 76) - *(signed __int16 *)(v14 + 76)) < (signed int)*(signed __int16 *)(a1 + 84)
				&& abs(*(signed __int16 *)(a1 + 78) - *(signed __int16 *)(v14 + 78)) < (signed int)*(signed __int16 *)(a1 + 84))
			{
				*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u *)(v14 + 76), (Bit16u *)(a1 + 76));
				v27 = 1;
				break;
			}
			v14 = *(x_DWORD *)v14;
		}
	LABEL_58:
		sub_1B8C0(a1);
		v15 = *(x_BYTE *)(a1 + 16);
		*(x_WORD *)(a1 + 48) = *(x_WORD *)(a1 + 28);
		if (v15 & 4)
			v16 = 56;
		else
			v16 = -56;
		LOWORD(v1) = *(x_WORD *)(a1 + 28) + v16;
		*(x_WORD *)(a1 + 28) = v1;
		*(x_BYTE *)(a1 + 29) &= 7u;
	}
	return v1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0002B750) --------------------------------------------------------
int sub_2B750(int a1)
{
	int result; // eax

	result = a1;
	*(x_BYTE *)(a1 + 69) = -31;
	return result;
}

//----- (0002B760) --------------------------------------------------------
int sub_2B760(int a1)
{
	return sub_1C890(a1, 224);
}

//----- (0002B780) --------------------------------------------------------
void sub_2B780(int a1)
{
	sub_1C930(a1);
}

//----- (0002B7B0) --------------------------------------------------------
void sub_2B7B0(int a1)
{
	sub_1D5D0(a1, 224);
	if (*(x_BYTE *)(a1 + 69) == -30)
		sub_2B840(a1);
}

//----- (0002B7E0) --------------------------------------------------------
char sub_2B7E0(int a1)
{
	unsigned int v1; // eax
	char v3; // bl

	v1 = x_D41A0_BYTEARRAY_4[38515];
	if (v1 <= x_DWORD_EA3E4[0])
		return 0;
	do
	{
		if (v1 != a1 && *(x_BYTE *)(v1 + 69) == -30)
		{
			v3 = *(x_BYTE *)(v1 + 70);
			if (v3 == 3 || v3 == 4 || v3 == 5)
				return 1;
		}
		v1 = *(x_DWORD *)v1;
	} while (v1 > x_DWORD_EA3E4[0]);
	return 0;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0002B840) --------------------------------------------------------
int sub_2B840(int a1)
{
	int result; // eax

	result = a1;
	*(x_BYTE *)(a1 + 69) = -30;
	*(x_BYTE *)(a1 + 70) = 0;
	return result;
}

//----- (0002B860) --------------------------------------------------------
char sub_2B860(int a1, unsigned __int8 a2)
{
	__int16 v2; // ax
	char v3; // ah
	char v4; // dh
	unsigned __int16 v5; // si
	char v6; // ch

	LOBYTE(v2) = a2;
	if (a2 < 2u)
	{
		if (a2 == 1)
		{
			v3 = *(x_BYTE *)(a1 + 12) & 0xF6;
			*(x_DWORD *)(a1 + 160) = (x_DWORD)&unk_D8830;
			*(x_BYTE *)(a1 + 12) = v3 | 8;
			sub_49CD0((x_WORD *)a1, 292);
			sub_49EA0((x_WORD *)a1, 85, 42);
			v2 = *(x_WORD *)(a1 + 134);
			*(x_WORD *)(a1 + 130) = v2;
		}
	}
	else if (a2 <= 2u)
	{
		*(x_DWORD *)(a1 + 160) = (x_DWORD)&unk_D8830;
		*(x_WORD *)(a1 + 44) = 0;
		v4 = *(x_BYTE *)(a1 + 12) & 0xF6;
		*(x_WORD *)(a1 + 130) = *(x_WORD *)(a1 + 132);
		*(x_BYTE *)(a1 + 12) = v4;
		v5 = x_WORD_DA506;
		*(x_BYTE *)(a1 + 12) = v4 | 8;
		sub_49CD0((x_WORD *)a1, 291);
		sub_49EA0((x_WORD *)a1, 384, 768);
		LOBYTE(v2) = sub_71AB0(v5, 0);
		if (x_DWORD_F66F0[v5])
		{
			*(x_DWORD *)(a1 + 16) = *(unsigned __int16 *)(sub_724F0(x_DWORD_E9C08, v5) + 16);
			v2 = *(x_WORD *)(a1 + 16);
			*(x_WORD *)(a1 + 44) = v2;
		}
	}
	else if (a2 == 3)
	{
		*(x_BYTE *)(a1 + 57) = 0;
		*(x_DWORD *)(a1 + 160) = (x_DWORD)&unk_D8852;
		v6 = *(x_BYTE *)(a1 + 12) | 1;
		*(x_WORD *)(a1 + 130) = *(x_WORD *)(a1 + 132) - 28;
		LOBYTE(v2) = v6 & 0xF7;
		*(x_BYTE *)(a1 + 12) = v6 & 0xF7;
	}
	return v2;
}
// DA506: using guessed type __int16 x_WORD_DA506;
// E9C08: using guessed type int x_DWORD_E9C08;

//----- (0002B9A0) --------------------------------------------------------
signed int sub_2B9A0(int a1)
{
	unsigned int v1; // edx
	__int16 v2; // dx
	int i; // ebx
	int v4; // ecx
	int v5; // ebx

	v1 = 0;
	if (*(x_WORD *)(a1 + 98))
	{
		*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
		v2 = *(x_WORD *)(a1 + 98);
		*(x_WORD *)(a1 + 98) = 0;
		*(x_WORD *)(a1 + 38) = v2;
		v1 = 1;
	}
	else
	{
		*(x_WORD *)(a1 + 38) = 0;
	}
	if (*(x_WORD *)(a1 + 52))
	{
		for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v5 + 52))
		{
			v5 = x_DWORD_EA3E4[i];
			if (v5 == x_DWORD_EA3E4[0])
				break;
			v4 = *(x_DWORD *)(v5 + 8);
			if (v4 < *(x_DWORD *)(a1 + 8))
			{
				*(x_DWORD *)(a1 + 8) = v4;
				*(x_WORD *)(a1 + 38) = *(x_WORD *)(v5 + 38);
				v1 = 1;
				break;
			}
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 0)
	{
		*(x_WORD *)(a1 + 36) = *(x_WORD *)(a1 + 38);
		v1 = 2;
	}
	if (v1 >= 1)
	{
		if (v1 <= 1)
		{
			*(x_WORD *)(a1 + 150) = *(x_WORD *)(a1 + 38);
		}
		else if (v1 == 2)
		{
			*(x_BYTE *)(a1 + 69) = -28;
			return 2;
		}
	}
	return v1;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0002BA50) --------------------------------------------------------
unsigned __int8 sub_2BA50(int a1, unsigned __int8 a2)
{
	unsigned __int8 result; // al

	result = a2;
	*(x_BYTE *)(a1 + 70) = a2;
	if (a2 < 2u)
		goto LABEL_10;
	if (a2 <= 2u)
	{
		*(x_DWORD *)(a1 + 16) = 32;
		return result;
	}
	if (a2 == 8)
		*(x_DWORD *)(a1 + 16) = 16;
	else
		LABEL_10:
	*(x_DWORD *)(a1 + 16) = 0;
	return result;
}

//----- (0002BB40) --------------------------------------------------------
void sub_2BB40_draw_bitmap(Bit16s posx, Bit16s posy, posistruct tempposstr)//20cb40
{
	//a3=48c80f-> 48ae47002633

  //void (*v3)(__int16, __int16, Pathstruct); // eax
  //int result; // eax
  //int v5; // edi
  //int (*v6)(__int16, __int16, Pathstruct); // [esp+0h] [ebp-4h]
//123 cd 48c80f 


  /*Pathstruct tempstruct;
  Bit8u* tempcharstar;
  tempstruct.var28_begin_buffer = &tempcharstar;//this fix
  *tempstruct.var28_begin_buffer = bitmap;//this fix */ //fix this


  //push [ebp+18] -cd- pote ecx
  //push [ebp+14] -123- pote ebx

	if (x_WORD_180660_VGA_type_resolution & 1)
		sub_8F8B0_draw_bitmap320(posx, posy, tempposstr);
	else
		sub_8F8E8_draw_bitmap640(posx, posy, tempposstr);
	//v6 = v3;
	//v3(a1, a2, a3);
	//result = (int)x_D41A0_BYTEARRAY_0;
	if (x_D41A0_BYTEARRAY_0[8592] == 1)
	{
		//v5 = (int)x_DWORD_180628b_screen_buffer;
		x_DWORD_180628b_screen_buffer = x_DWORD_E9C3C;
		if (x_WORD_180660_VGA_type_resolution & 1)
			sub_8F8B0_draw_bitmap320(posx, posy, tempposstr);
		else
			sub_8F8E8_draw_bitmap640(posx, posy, tempposstr);
		//x_DWORD_180628b_screen_buffer = v5;
	}
	//return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// E9C3C: using guessed type int x_DWORD_E9C3C;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0002BBB0) --------------------------------------------------------
int sub_2BBB0(__int16 a1, __int16 a2, int a3)
{
	int result; // eax
	int v4; // edi

	x_DWORD_F01EC(a1, a2, a3);
	result = (int)x_D41A0_BYTEARRAY_0;
	if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8592) == 1)
	{
		v4 = (int)x_DWORD_180628b_screen_buffer;
		x_DWORD_180628b_screen_buffer = (Bit8u*)x_DWORD_E9C3C;
		result = x_DWORD_F01EC(a1, a2, a3);
		x_DWORD_180628b_screen_buffer = (Bit8u*)v4;
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// E9C3C: using guessed type int x_DWORD_E9C3C;
// F01EC: using guessed type int (*x_DWORD_F01EC)(x_DWORD, x_DWORD, x_DWORD);
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;

//----- (0002BC10) --------------------------------------------------------
void sub_2BC10_draw_text(Bit8u* textbuffer, Bit16s posx, Bit16s posy, Bit8u color)//20cc10
{
	//int result; // eax
	Bit8u* v5; // ST10_4

	sub_6F940_sub_draw_text(textbuffer, posx, posy, color);
	//result = (int)x_D41A0_BYTEARRAY_0;
	if (x_D41A0_BYTEARRAY_0[8592] == 1)//shifted graphics
	{
		v5 = x_DWORD_180628b_screen_buffer;
		x_DWORD_180628b_screen_buffer = (Bit8u*)x_DWORD_E9C3C;
		sub_6F940_sub_draw_text(textbuffer, posx, posy, color);
		//result = v5;
		x_DWORD_180628b_screen_buffer = (Bit8u*)v5;
	}
	//return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// E9C3C: using guessed type int x_DWORD_E9C3C;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;

//----- (0002BC80) --------------------------------------------------------
void sub_2BC80(Bit16u x1, Bit16u y1, Bit16u x2, Bit16u y2, Bit8u a5)
{
	//void *v5; // ebx
	Bit8u* result; // eax
	//int v7; // ST14_4

	//debug
	  //loadfromsnapshot((char*)"0160-00253633", (Bit8u*)&a1, 0x354ef8, 2);//4c

	//debug

	if (x_WORD_180660_VGA_type_resolution & 1)
		sub_90164(x1, y1, x2, y2, a5);
	else
		sub_901E4(x1, y1, x2, y2, a5);
	result = x_D41A0_BYTEARRAY_0;
	if (x_D41A0_BYTEARRAY_0[8592] == 1)
	{
		//v7 = (int)x_DWORD_180628b_screen_buffer;
		x_DWORD_180628b_screen_buffer = x_DWORD_E9C3C;
		if (x_WORD_180660_VGA_type_resolution & 1)
			sub_90164(x1, y1, x2, y2, a5);
		else
			sub_901E4(x1, y1, x2, y2, a5);
		//result = (Bit8u)x_DWORD_180628b_screen_buffer;
		//x_DWORD_180628b_screen_buffer = (Bit8u*)v7;
	}
	//return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// E9C3C: using guessed type int x_DWORD_E9C3C;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0002BD10) --------------------------------------------------------
void sub_2BD10(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int8 a5)
{
	void *v5; // ebx
	int result; // eax
	int v7; // ST14_4

	if (x_WORD_180660_VGA_type_resolution & 1)
		v5 = sub_BD524;
	else
		v5 = sub_BD542;
	((void(*)(x_DWORD, x_DWORD, x_DWORD, x_DWORD, x_DWORD))v5)(a1, a2, a3, a4, a5);
	//result = (int)x_D41A0_BYTEARRAY_0;
	if (x_D41A0_BYTEARRAY_0[8592] == 1)
	{
		v7 = (int)x_DWORD_180628b_screen_buffer;
		x_DWORD_180628b_screen_buffer = (Bit8u*)x_DWORD_E9C3C;
		((void(*)(x_DWORD, x_DWORD, x_DWORD, x_DWORD, x_DWORD))v5)(a1, a2, a3, a4, a5);
		result = v7;
		x_DWORD_180628b_screen_buffer = (Bit8u*)v7;
	}
	//return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// E9C3C: using guessed type int x_DWORD_E9C3C;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0002BE30) --------------------------------------------------------
int sub_2BE30()
{
	char v0; // dl
	//void (*v1)(__int16, __int16, Bit8u*); // eax
	char v2; // bh
	int v3; // esi
	char v4; // dl
	Bit8u* v5; // ebx
	signed int v6; // edi
	__int16 v7; // bx
	int v8; // ebx
	Bit8u* v9; // edx
	Bit8u* v10; // eax
	Bit8u* v11; // edi
	Bit8u* v12; // ebx
	unsigned __int8 v13; // al
	signed int v14; // edi
	Bit8u* v15; // edx
	Bit8u* v16; // eax
	Bit8u* v17; // esi
	Bit8u* v18; // esi
	Bit8u* v19; // edx
	Bit8u* v20; // eax
	Bit8u* v21; // esi
	unsigned __int16 v22; // dx
	int v23; // eax
	int v24; // esi
	int v25; // esi
	int v26; // ecx
	int v27; // eax
	signed int v28; // esi
	int v29; // ebx
	__int16 v30; // di
	signed int v31; // esi
	int v33; // eax
	unsigned __int16 v34; // cx
	int v35; // [esp+8h] [ebp-18h]
	signed __int16 v36; // [esp+Ch] [ebp-14h]
	signed __int16 v37; // [esp+10h] [ebp-10h]
	signed __int16 v38; // [esp+14h] [ebp-Ch]
	signed __int16 v39; // [esp+18h] [ebp-8h]
	__int16 v40; // [esp+1Ch] [ebp-4h]

	v0 = x_D41A0_BYTEARRAY_4_struct.setting_byte1_22;
	x_DWORD_D41C8 = 0;
	posistruct tempstruct;//this must fix
	tempstruct.pointer = new Bit8u;//this must fix
	if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8600))
	{
		if (x_WORD_180660_VGA_type_resolution & 1)
			//v1 = sub_8F8B0_draw_bitmap320;
			/*x_DWORD_F01E8 = */sub_8F8B0_draw_bitmap320(0, 0, tempstruct);//this must fix
		else
			//v1 = sub_8F8E8_draw_bitmap640;
			/*x_DWORD_F01E8 = */sub_8F8E8_draw_bitmap640(0, 0, tempstruct);//this must fix
			//x_DWORD_F01E8 = (int (*)(x_DWORD, x_DWORD, x_DWORD))v1;
	}
	else
	{
		/*x_DWORD_F01E8 = */sub_2DE80(0, 0, 0);
	}
	x_DWORD_F01EC = x_DWORD_F01E8;
	v2 = x_D41A0_BYTEARRAY_4_struct.byteindex_A;
	/*x_DWORD_F01E8 = */sub_2BBB0(0, 0, 0);
	if (v2)
		sub_88580();
	switch (*(x_BYTE *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 12221))
	{
	case 0:
	case 3:
	case 5:
	case 9:
	case 0xA:
	case 0xD:
		v3 = x_DWORD_EA3E4[*(unsigned __int16 *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240)];
		if (x_BYTE_D41C4 || *(char *)(x_D41A0_BYTEARRAY_0 + 8589) != (unsigned __int8)x_BYTE_D41C6)
		{
			v4 = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8589);
			x_BYTE_D41C4 = 0;
			x_BYTE_D41C6 = v4;
			if (v4 < 40)
			{
				if (x_WORD_180660_VGA_type_resolution & 1)
					sub_72883_clear_text_mode(/*(unsigned __int8)x_BYTE_EB3A8, */(void *)x_DWORD_180628b_screen_buffer, 0xC8u, x_BYTE_EB3A8);
				else
					sub_728A9_clear_graphics_mode((void *)x_DWORD_180628b_screen_buffer, 0x1E0u, x_BYTE_EB3A8);
			}
		}
		if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8589) < 40)
		{
			if (x_WORD_180660_VGA_type_resolution & 1)
				sub_72883_clear_text_mode(/*(unsigned __int8)x_BYTE_EB3A8, */(void *)x_DWORD_180628b_screen_buffer, 0xC8u, x_BYTE_EB3A8);
			else
				sub_728A9_clear_graphics_mode((void *)x_DWORD_180628b_screen_buffer, 0x1E0u, x_BYTE_EB3A8);
		}
		sub_40C50(*(char *)(x_D41A0_BYTEARRAY_0 + 8589));
		v5 = x_D41A0_BYTEARRAY_0 + 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
		v6 = *(unsigned __int16 *)(v5 + 11244);
		sub_411A0(
			(int)x_DWORD_180628b_screen_buffer,
			*(signed __int16 *)(v5 + 14 * (unsigned __int16)v6 + 11709),
			*(signed __int16 *)(v5 + 14 * (unsigned __int16)v6 + 11711),
			*(x_WORD *)(v5 + 14 * (unsigned __int16)v6 + 11715),
			*(signed __int16 *)(v5 + 14 * (unsigned __int16)v6 + 11713) + 128,
			*(signed __int16 *)(v5 + 14 * (unsigned __int16)v6 + 11717),
			*(x_WORD *)(v5 + 14 * (unsigned __int16)v6 + 11719),
			*(signed __int16 *)(v5 + 14 * (unsigned __int16)v6 + 11721));
		if (*(x_DWORD *)(v3 + 8) < 0)
		{
			v13 = *(x_BYTE *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 12221);
			if (v13 < 0xAu)
			{
				if (v13 == 9)
				{
					sub_30050();
					break;
				}
			}
			else if (v13 <= 0xAu)
			{
				sub_303D0(v6);
			}
			else if (v13 == 13)
			{
				sub_30A60(6, 6);
				break;
			}
			sub_2FD90();
		}
		else
		{
			if (x_DWORD_D4188 && *(x_BYTE *)(*(x_DWORD *)(v3 + 164) + 334))
			{
				if (x_WORD_180660_VGA_type_resolution & 1)
				{
					v39 = 2;
					v37 = 4;
				}
				else
				{
					v39 = 4;
					v37 = 6;
				}
				v6 = 1;
				v38 = 0;
				v40 = 0;
				v7 = *(unsigned __int8 *)(x_DWORD_D418C + 11);
				while (v38 < v39)
				{
					v36 = 0;
					v35 = 0;
					while (v36 < v37)
					{
						v8 = 6 * v6;
						//fix it! sub_2BB40_draw_bitmap(v35, v40, (Bit8u**)(6 * v6 + x_DWORD_D418C));
						++v36;
						++v6;
						v35 += *(unsigned __int8 *)(v8 + x_DWORD_D418C + 4);
						v7 = *(unsigned __int8 *)(x_DWORD_D418C + 11);
					}
					++v38;
					v40 += v7;
				}
			}
			if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8590))
			{
				v9 = x_D41A0_BYTEARRAY_0 + 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
				v10 = v9 + 14 * *(unsigned __int16 *)(v9 + 11244);
				sub_63600(
					0,
					0,
					*(signed __int16 *)(v10 + 11709),
					*(signed __int16 *)(v10 + 11711),
					128,
					128,
					*(x_WORD *)(v10 + 11715),
					256,
					x_DWORD_180648_map_resolution2_x - 2 * (x_DWORD_180648_map_resolution2_x / 5u),
					0);
				v11 = 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0;
				sub_61880(
					0,
					0,
					*(x_WORD *)(v11 + 14 * *(unsigned __int16 *)(v11 + 11244) + 11709),
					*(x_WORD *)(v11 + 14 * *(unsigned __int16 *)(v11 + 11244) + 11711),
					128,
					128,
					*(x_WORD *)(v11 + 14 * *(unsigned __int16 *)(v11 + 11244) + 11715),
					256);
				v12 = x_D41A0_BYTEARRAY_0 + 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
				v6 = 256;
				sub_644F0(
					0,
					0,
					*(x_WORD *)(v12 + 14 * *(unsigned __int16 *)(v12 + 11244) + 11709),
					*(x_WORD *)(v12 + 14 * *(unsigned __int16 *)(v12 + 11244) + 11711),
					128,
					128,
					*(x_WORD *)(v12 + 14 * *(unsigned __int16 *)(v12 + 11244) + 11715),
					256);
			}
			sub_6FC50(x_BYTE_D419D);
			if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8591))
			{
				sub_2E260(
					510,
					2,
					x_DWORD_EA3E4[*(signed __int16 *)(*(x_DWORD *)(v3 + 164)
						+ 2 * *(signed __int16 *)(*(x_DWORD *)(v3 + 164) + 1105)
						+ 819)],
					0);
				sub_2E260(
					574,
					2,
					x_DWORD_EA3E4[*(signed __int16 *)(*(x_DWORD *)(v3 + 164)
						+ 2 * *(signed __int16 *)(*(x_DWORD *)(v3 + 164) + 1107)
						+ 819)],
					0);
				sub_2D710(v3);
			}
			switch (*(x_BYTE *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 12221))
			{
			case 3:
				sub_2F6B0();
				goto LABEL_41;
			case 9:
				sub_30050();
				break;
			case 0xA:
				sub_303D0(v6);
				goto LABEL_41;
			case 0xD:
				sub_30A60(132, 50);
				break;
			default:
			LABEL_41:
				sub_2FD90();
				break;
			}
			sub_2CE30(132, 50);
			if (*(x_BYTE *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 12221) == 5)
				sub_2ECC0();
		}
		break;
	case 6:
	case 7:
	case 8:
	case 0xB:
	case 0xC:
	case 0xE:
		v14 = x_DWORD_EA3E4[*(unsigned __int16 *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240)];
		if (x_WORD_180660_VGA_type_resolution & 1)
			sub_72883_clear_text_mode(/*(unsigned __int8)x_BYTE_EB3A8, */(void *)x_DWORD_180628b_screen_buffer, 0xC8u, x_BYTE_EB3A8);
		else
			sub_728A9_clear_graphics_mode((void *)x_DWORD_180628b_screen_buffer, 0x1E0u, x_BYTE_EB3A8);
		if (x_WORD_180660_VGA_type_resolution == 1)
		{
			v15 = x_D41A0_BYTEARRAY_0 + 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
			v16 = v15 + 14 * *(unsigned __int16 *)(v15 + 11244);
			sub_63600(
				0,
				0,
				*(signed __int16 *)(v16 + 11709),
				*(signed __int16 *)(v16 + 11711),
				382,
				400,
				*(x_WORD *)(v16 + 11715),
				204,
				x_DWORD_180648_map_resolution2_x - 192,
				1);
			v17 = x_D41A0_BYTEARRAY_0 + 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
			sub_61880(
				0,
				0,
				*(x_WORD *)(v17 + 14 * *(unsigned __int16 *)(v17 + 11244) + 11709),
				*(x_WORD *)(v17 + 14 * *(unsigned __int16 *)(v17 + 11244) + 11711),
				382,
				400,
				*(x_WORD *)(v17 + 14 * *(unsigned __int16 *)(v17 + 11244) + 11715),
				204);
		}
		else
		{
			v18 = x_D41A0_BYTEARRAY_0 + 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
			sub_63600(
				0,
				0,
				*(signed __int16 *)(v18 + 14 * *(unsigned __int16 *)(v18 + 11244) + 11709),
				*(signed __int16 *)(v18 + 14 * *(unsigned __int16 *)(v18 + 11244) + 11711),
				382,
				400,
				*(x_WORD *)(v18 + 14 * *(unsigned __int16 *)(v18 + 11244) + 11715),
				204,
				x_DWORD_180648_map_resolution2_x - 192,
				1);
			v19 = x_D41A0_BYTEARRAY_0 + 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
			v20 = v19 + 14 * *(unsigned __int16 *)(v19 + 11244);
			sub_61880(0, 0, *(x_WORD *)(v20 + 11709), *(x_WORD *)(v20 + 11711), 382, 400, *(x_WORD *)(v20 + 11715), 204);
		}
		sub_40BF0(384, 0, 256, 400);
		v21 = x_D41A0_BYTEARRAY_0 + 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
		v22 = *(x_WORD *)(v21 + 11244);
		sub_411A0(
			(int)x_DWORD_180628b_screen_buffer,
			*(signed __int16 *)(v21 + 14 * v22 + 11709),
			*(signed __int16 *)(v21 + 14 * v22 + 11711),
			*(x_WORD *)(v21 + 14 * v22 + 11715),
			*(signed __int16 *)(v21 + 14 * v22 + 11713) + 128,
			*(signed __int16 *)(v21 + 14 * v22 + 11717),
			*(x_WORD *)(v21 + 14 * v22 + 11719),
			*(signed __int16 *)(v21 + 14 * v22 + 11721));
		if (x_WORD_180660_VGA_type_resolution & 1)
			sub_9025C(384, 0, 384, 400, (unsigned __int8)*xadataclrd0dat.var28_begin_buffer, 0);
		else
			sub_90374(384, 0, 384, 400, (unsigned __int8)*xadataclrd0dat.var28_begin_buffer, 0);
		if (x_WORD_180660_VGA_type_resolution & 1)
			sub_9025C(382, 0, 382, 400, (unsigned __int8)*xadataclrd0dat.var28_begin_buffer, 0);
		else
			sub_90374(382, 0, 382, 400, (unsigned __int8)*xadataclrd0dat.var28_begin_buffer, 0);
		sub_40C50(*(char *)(x_D41A0_BYTEARRAY_0 + 8589));
		if (x_WORD_180660_VGA_type_resolution == 1)
		{
			v23 = (int)x_D41A0_BYTEARRAY_0;
			v24 = 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
		}
		else
		{
			v24 = (int)x_D41A0_BYTEARRAY_0;
			v23 = 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
		}
		v25 = v23 + v24;
		sub_644F0(
			0,
			0,
			*(x_WORD *)(v25 + 14 * *(unsigned __int16 *)(v25 + 11244) + 11709),
			*(x_WORD *)(v25 + 14 * *(unsigned __int16 *)(v25 + 11244) + 11711),
			382,
			400,
			*(x_WORD *)(v25 + 14 * *(unsigned __int16 *)(v25 + 11244) + 11715),
			204);
		switch (*(x_BYTE *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 12221))
		{
		case 7:
			sub_2D1D0();
			break;
		case 8:
			sub_2FD90();
			sub_2ECC0();
			break;
		case 0xB:
			sub_30050();
			break;
		case 0xC:
			sub_303D0(v14);
			goto LABEL_73;
		case 0xE:
			sub_30A60(6, 6);
			break;
		default:
		LABEL_73:
			sub_2FD90();
			break;
		}
		sub_2CE30(6, 6);
		if (x_D41A0_BYTEARRAY_4[38400])
			sub_2E260(
				510,
				2,
				x_DWORD_EA3E4[*(signed __int16 *)(*(x_DWORD *)(v14 + 164)
					+ 2 * *(signed __int16 *)(*(x_DWORD *)(v14 + 164) + 1105)
					+ 819)],
				0);
		if (x_D41A0_BYTEARRAY_4[38401])
			sub_2E260(
				574,
				2,
				x_DWORD_EA3E4[*(signed __int16 *)(*(x_DWORD *)(v14 + 164)
					+ 2 * *(signed __int16 *)(*(x_DWORD *)(v14 + 164) + 1107)
					+ 819)],
				0);
		break;
	default:
		break;
	}
	if (*(0x36E03 + x_D41A0_BYTEARRAY_0 + 1))
		sub_30630();
	sub_6FC50(x_BYTE_D419D);
	if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 4))
		return _wcpp_1_unwind_leave__62();
	if (x_D41A0_BYTEARRAY_4[204] == 3)
	{
		v26 = x_D41A0_BYTEARRAY_4[210];
		if (v26 <= 0)
			x_D41A0_BYTEARRAY_4[204] = 2;
		else
			x_D41A0_BYTEARRAY_4[210] = v26 - 1;
	}
	v27 = (int)x_D41A0_BYTEARRAY_4;
	if (x_D41A0_BYTEARRAY_4[204] == 2)
	{
		x_D41A0_BYTEARRAY_4[204] = 1;
		*(x_WORD *)(v27 + 214) = 0;
		*(x_DWORD *)(v27 + 210) = 50;
	}
	if (x_D41A0_BYTEARRAY_4[204] != 1)
		return _wcpp_1_unwind_leave__62();
	if (x_D41A0_BYTEARRAY_4[210] <= 0)
	{
		while (1)
		{
			v33 = (int)x_D41A0_BYTEARRAY_4;
			if (*off_DB558[x_D41A0_BYTEARRAY_4[214]] == 33)
				break;
			++x_D41A0_BYTEARRAY_4[214];
		}
		v34 = x_D41A0_BYTEARRAY_4[214] + 1;
		x_D41A0_BYTEARRAY_4[214] = v34;
		if (*off_DB558[v34] == 35)
		{
			*(x_BYTE *)(v33 + 204) = 3;
			*(x_DWORD *)(v33 + 210) = 200;
			return _wcpp_1_unwind_leave__62();
		}
		*(x_DWORD *)(v33 + 210) = 50;
		return _wcpp_1_unwind_leave__62();
	}
	v28 = 380;
	v29 = 0;
	while (*off_DB558[v29 + x_D41A0_BYTEARRAY_4[214]] != 33)
	{
		++v29;
		v28 -= sub_6FC30_get34_sizey();
	}
	v30 = 0;
	v31 = 8;
	while (v29 > 0)
	{
		if (v30)
			sub_2BC10_draw_text((Bit8u*)off_DB558[v30 + x_D41A0_BYTEARRAY_4[214]], 8, v31, (unsigned __int8)*xadataclrd0dat.var28_begin_buffer);
		else
			sub_2BC10_draw_text((Bit8u*)off_DB558[x_D41A0_BYTEARRAY_4[214]], 8, v31, x_BYTE_E98FF);
		--v29;
		++v30;
		v31 += sub_6FC30_get34_sizey();
	}
	--x_D41A0_BYTEARRAY_4[210];
	return _wcpp_1_unwind_leave__62();
}
// 2BB30: using guessed type int _wcpp_1_unwind_leave__62(void);
// D4188: using guessed type int x_DWORD_D4188;
// D418C: using guessed type int x_DWORD_D418C;
// D419D: using guessed type char x_BYTE_D419D;
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// D41C4: using guessed type char x_BYTE_D41C4;
// D41C6: using guessed type char x_BYTE_D41C6;
// D41C8: using guessed type int x_DWORD_D41C8;
// DB558: using guessed type const char *off_DB558[3];
// E98FF: using guessed type char x_BYTE_E98FF;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB3A8: using guessed type char x_BYTE_EB3A8;
// F01E8: using guessed type int (*x_DWORD_F01E8)(x_DWORD, x_DWORD, x_DWORD);
// F01EC: using guessed type int (*x_DWORD_F01EC)(x_DWORD, x_DWORD, x_DWORD);
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 180648: using guessed type int x_DWORD_180648_map_resolution2_x;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0002CA60) --------------------------------------------------------
int sub_2CA60(__int16 a1, __int16 a2, __int16 a3, __int16 a4)
{
	int result; // eax

	x_DWORD_EA3D0 = a1;
	x_DWORD_EA3CC = a2;
	x_DWORD_EA3C4 = a3;
	result = a4;
	x_DWORD_EA3C0 = a4;
	return result;
}
// EA3C0: using guessed type int x_DWORD_EA3C0;
// EA3C4: using guessed type int x_DWORD_EA3C4;
// EA3CC: using guessed type int x_DWORD_EA3CC;
// EA3D0: using guessed type int x_DWORD_EA3D0;

//----- (0002CA90) --------------------------------------------------------
int sub_2CA90(__int16 a1)
{
	int v1; // eax
	int result; // eax
	int v3; // esi
	int v4; // ecx

	v1 = 40 - a1;
	x_DWORD_EA3D0 = 8 * v1;
	x_DWORD_EA3C4 = 16 * a1;
	if (x_WORD_180660_VGA_type_resolution & 1)
	{
		result = 5 * v1 / 2;
		v3 = 10 * a1;
		v4 = 2 * result;
	}
	else
	{
		result = 12 * v1 / 2;
		v3 = 12 * a1;
		v4 = result;
	}
	x_DWORD_EA3C0 = v3;
	x_DWORD_EA3CC = v4;
	return result;
}
// EA3C0: using guessed type int x_DWORD_EA3C0;
// EA3C4: using guessed type int x_DWORD_EA3C4;
// EA3CC: using guessed type int x_DWORD_EA3CC;
// EA3D0: using guessed type int x_DWORD_EA3D0;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0002CB30) --------------------------------------------------------
__int16 sub_2CB30(x_DWORD *a1, __int16 a2, int a3, __int16 a4)
{
	char *v4; // edi
	char *v5; // esi
	char v6; // al
	char v7; // al
	int v8; // esi
	int v9; // eax
	__int16 v10; // bx
	__int16 v11; // bx
	int v12; // edi
	int v13; // esi
	unsigned __int8 v14; // ST10_1
	unsigned __int8 v15; // ST10_1
	unsigned __int8 v16; // ST10_1
	unsigned __int8 v17; // ST10_1
	unsigned __int8 v18; // ST10_1
	unsigned __int8 v19; // ST10_1
	char *v21; // [esp-4h] [ebp-5Ch]
	unsigned __int8 v22; // [esp-4h] [ebp-5Ch]
	unsigned __int8 v23; // [esp-4h] [ebp-5Ch]
	char v24[32]; // [esp+0h] [ebp-58h]
	int v25; // [esp+20h] [ebp-38h]
	int v26; // [esp+24h] [ebp-34h]
	int v27; // [esp+28h] [ebp-30h]
	int v28; // [esp+2Ch] [ebp-2Ch]
	int v29; // [esp+30h] [ebp-28h]
	int v30; // [esp+34h] [ebp-24h]
	int v31; // [esp+38h] [ebp-20h]
	int v32; // [esp+3Ch] [ebp-1Ch]
	unsigned __int8 v33; // [esp+40h] [ebp-18h]
	char v34; // [esp+44h] [ebp-14h]
	char v35; // [esp+48h] [ebp-10h]
	char v36; // [esp+4Ch] [ebp-Ch]
	char v37; // [esp+50h] [ebp-8h]
	unsigned __int8 v38; // [esp+54h] [ebp-4h]
	int v39; // [esp+74h] [ebp+1Ch]

	// fix if begin
	v14 = 0;
	v15 = 0;
	v16 = 0;
	v17 = 0;
	v18 = 0;
	v19 = 0;
	v22 = 0;
	v23 = 0;
	// end

	v31 = x_DWORD_EA3C4 + x_DWORD_EA3D0 - 4;
	v29 = x_DWORD_EA3C0 + x_DWORD_EA3CC - 22;
	v25 = *(signed __int16 *)(a1[41] + 56);
	v4 = v24;
	v5 = (char *)(2124 * v25 + x_D41A0_BYTEARRAY_0 + 11230 + 927);
	v21 = v24;
	do
	{
		v6 = *v5;
		*v4 = *v5;
		if (!v6)
			break;
		v7 = v5[1];
		v5 += 2;
		v4[1] = v7;
		v4 += 2;
	} while (v7);
	v36 = x_BYTE_E88E0[3 * sub_61790(v25)];
	v35 = (unsigned __int8)*xadataclrd0dat.var28_begin_buffer;
	v34 = x_BYTE_E88E0[3 * sub_61790(v25)];
	v8 = 5 * *(0x2FED1 + x_D41A0_BYTEARRAY_0 + 3);
	v33 = x_BYTE_D94F2[v8];
	v38 = x_BYTE_D94F3[v8];
	v37 = x_BYTE_D94F0[v8];
	v9 = a4 >> 1;
	v10 = v9 + a2;
	if (x_WORD_180660_VGA_type_resolution & 1)
	{
		v10 *= 2;
		a3 *= 2;
	}
	LOWORD(v9) = x_DWORD_EA3CC;
	v11 = x_DWORD_EA3D0 + v10;
	v12 = v9 + a3 - 20;
	v39 = v9 + a3 - 20;
	if (v11 >= x_DWORD_EA3D0)
	{
		LOWORD(v9) = v12;
		if ((signed __int16)v12 >= x_DWORD_EA3CC && v11 < v31 && (signed __int16)v12 < v29)
		{
			v9 = strlen(v24);
			v13 = 8 * v9 + 4;
			if (v11 + v13 > v31)
			{
				v13 = v31 - v11;
				v9 = (v31 - v11 - 4 - (__CFSHL__((v31 - v11 - 4) >> 31, 3) + 8 * ((v31 - v11 - 4) >> 31))) >> 3;
			}
			if (v9 > 0)
			{
				v24[v9] = 0;
				v32 = v13 + 2;
				v26 = (signed __int16)(v13 + 2);
				v30 = v11;
				sub_2BC80(v11, v39, v13 + 2, 18, v22);
				v27 = v33;
				sub_2BC80(v30, v39, v26, 2, v14);
				v28 = v38;
				sub_2BC80(v30, v39 + 16, v26, 2, v15);
				sub_2BC80(v30, v39, 2, 16, v16);
				sub_2BC80(v11 + v32 - 2, v39, 2, 18, v17);
				sub_2BC10_draw_text((Bit8u*)v24, v11 + 4, v39, v18);
				sub_2BC80(v11 + 2, v39 + 14, v13 - 2, 2, v19);
				LOWORD(v9) = (x_WORD)a1;
				if (a1[1])
				{
					v9 = a1[2] * (v13 - 2) / a1[1];
					if (v30 + 2 + v9 > v31 - 2)
						v9 = v31 - 2 - (v30 + 2);
					if (v9 > 0)
						sub_2BC80(v11 + 2, v39 + 14, v9, 2, v23);
				}
			}
		}
	}
	return v9;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3C0: using guessed type int x_DWORD_EA3C0;
// EA3C4: using guessed type int x_DWORD_EA3C4;
// EA3CC: using guessed type int x_DWORD_EA3CC;
// EA3D0: using guessed type int x_DWORD_EA3D0;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;
// 2CB30: using guessed type char var_58[32];

//----- (0002CE30) --------------------------------------------------------
int sub_2CE30(int a1, int a2)
{
	int v2; // esi
	int result; // eax
	unsigned int v4; // edi
	unsigned __int8 v5; // bl
	int v6; // eax
	Bit8u* v7; // ebx
	unsigned __int16 v8; // ax
	__int16 v9; // ax
	int v10; // eax
	__int16 v11; // ax
	int v12; // eax
	__int16 v13; // ax
	__int64 v14; // rax
	unsigned __int8 v15; // al
	int v16; // eax
	__int16 v17; // ax
	__int64 v18; // rax
	int v19; // eax
	//char v20; // [esp+0h] [ebp-Eh]
	Bit8u* v21; // [esp+80h] [ebp+72h]
	int v22; // [esp+84h] [ebp+76h]

	v2 = a2;
	sub_6FC50(x_BYTE_D419D);
	result = (int)x_D41A0_BYTEARRAY_4;
	LOWORD(v4) = a1;
	v5 = x_BYTE_E9800;
	if (!x_D41A0_BYTEARRAY_4[0xCD] && !x_D41A0_BYTEARRAY_4[0x9692])
	{
		if (x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 1)
		{
			sub_2BC10_draw_text(x_DWORD_E9C4C_langindexbuffer[425], a1, a2, x_BYTE_E89F0);
			v4 = 8 * (strlen((const char *)x_DWORD_E9C4C_langindexbuffer[425]) + 2) + a1;
		}
		if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x20) && x_D41A0_BYTEARRAY_0[0x3659C + 11 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12])
		{
			sprintf_s(printbuffer, 512, "%s. %s.", x_DWORD_E9C4C_langindexbuffer[378], x_DWORD_E9C4C_langindexbuffer[379]);
			sub_2BC10_draw_text((Bit8u*)printbuffer, v4, a2, v5);
			LOWORD(v4) = a1;
			LOWORD(v6) = sub_6FC30_get34_sizey();
			v2 = v6 + a2;
		}
		v22 = 0;
		v7 = x_D41A0_BYTEARRAY_0 + 11230;
		while (1)
		{
			result = (int)x_D41A0_BYTEARRAY_0;
			if ((unsigned __int16)v22 >= *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 14))
				break;
			v8 = *(x_WORD *)(v7 + 79) - 1;
			if (v8 <= 4u)
			{
				v21 = v7 + 28;
				switch (v8)
				{
				case 0u:
					v9 = *(x_WORD *)(v7 + 77);
					*(x_WORD *)(v7 + 77) = v9 - 1;
					if (v9 <= 0)
						goto LABEL_24;
					sprintf_s(printbuffer, 512, "%s %s", v7 + 927, v7 + 28);
					sub_2BC10_draw_text((Bit8u*)printbuffer, v4, v2, x_BYTE_E9800);
					LOWORD(v4) = a1;
					LOWORD(v10) = sub_6FC30_get34_sizey();
					v2 += v10;
					break;
				case 1u:
					v13 = *(x_WORD *)(v7 + 77);
					*(x_WORD *)(v7 + 77) = v13 - 1;
					if (v13 <= 0)
						goto LABEL_24;
					sprintf_s(printbuffer, 512, "[%s] %s", v7 + 927, v21);
					if (*(x_WORD *)(v7 + 77) <= 100)
					{
						v15 = x_BYTE_E9800;
					}
					else
					{
						v14 = 4080 * x_D41A0_BYTEARRAY_4[0x7B];
						v15 = (*xadataclrd0dat.var28_begin_buffer)[256 * ((signed int)(v14 - (__CFSHL__(HIDWORD(v14), 8) + (HIDWORD(v14) << 8))) >> 8)];
					}
					sub_2BC10_draw_text((Bit8u*)printbuffer, v4, v2, v15);
					LOWORD(v16) = sub_6FC30_get34_sizey();
					LOWORD(v4) = a1;
					v2 += v16;
					break;
				case 2u:
				case 4u:
					v11 = *(x_WORD *)(v7 + 77);
					*(x_WORD *)(v7 + 77) = v11 - 1;
					if (v11 <= 0)
						goto LABEL_24;
					if (*(x_WORD *)(v7 + 79) == 3 || (unsigned __int16)v22 == x_D41A0_BYTEARRAY_4_struct.dwordindex_12)
					{
						sprintf_s(printbuffer, 512, "%s", v7 + 28);
						sub_2BC10_draw_text((Bit8u*)printbuffer, v4, v2, x_BYTE_E9800);
						LOWORD(v4) = a1;
						LOWORD(v12) = sub_6FC30_get34_sizey();
						v2 += v12;
					}
					break;
				case 3u:
					v17 = *(x_WORD *)(v7 + 77);
					*(x_WORD *)(v7 + 77) = v17 - 1;
					if (v17 <= 0)
					{
					LABEL_24:
						*(x_WORD *)(v7 + 79) = 0;
					}
					else
					{
						sprintf_s(printbuffer, 512, "[%s] %s", v7 + 927, v21);
						v18 = 4080 * x_D41A0_BYTEARRAY_4[0x7B];
						sub_2BC10_draw_text((Bit8u*)printbuffer, v4, v2,
							(*xadataclrd0dat.var28_begin_buffer)[16 * ((signed int)(v18 - (__CFSHL__(HIDWORD(v18), 8) + (HIDWORD(v18) << 8))) >> 8)]);
						LOWORD(v4) = a1;
						LOWORD(v19) = sub_6FC30_get34_sizey();
						v2 += v19;
					}
					break;
				}
			}
			v7 += 2124;
			++v22;
		}
	}
	return result;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// D419D: using guessed type char x_BYTE_D419D;
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// E89F0: using guessed type char x_BYTE_E89F0;
// E9800: using guessed type char x_BYTE_E9800;
// EA234: using guessed type int x_DWORD_EA234;
// EA238: using guessed type int x_DWORD_EA238;
// EA2F0: using guessed type int x_DWORD_EA2F0;

//----- (0002D190) --------------------------------------------------------
void sub_2D190(__int16 a1, __int16 a2, int a3, __int16 a4, int a5, unsigned __int8 a6)
{
	int result; // eax

	result = a5;
	if (a5 >= a3)
		result = a3;
	if (result >= 2)
		sub_2BC80(a1, a2, result, a4, a6);
	//return result;
}

//----- (0002D1D0) --------------------------------------------------------
int sub_2D1D0()
{
	signed int v0; // esi
	int v1; // eax
	Bit8u* v2; // edx
	int v3; // ebx
	signed int v4; // edx
	int v5; // ebx
	char v6; // cl
	int v7; // edi
	unsigned __int8 v8; // si
	unsigned __int8 v9; // ST10_1
	int v10; // esi
	int v11; // eax
	int v12; // edi
	int v13; // eax
	int v14; // esi
	signed int v15; // eax
	unsigned __int16 v16; // cx
	signed int j; // esi
	//int v18; // eax
	//int v19; // eax
	int result; // eax
	//char v21; // [esp+0h] [ebp-124h]
	int v22; // [esp+100h] [ebp-24h]
	int v23; // [esp+104h] [ebp-20h]
	Bit8u* i; // [esp+108h] [ebp-1Ch]
	int v25; // [esp+10Ch] [ebp-18h]
	int v26; // [esp+110h] [ebp-14h]
	int v27; // [esp+114h] [ebp-10h]
	int v28; // [esp+118h] [ebp-Ch]
	unsigned __int8 v29; // [esp+11Ch] [ebp-8h]
	unsigned __int8 v30; // [esp+120h] [ebp-4h]

	v0 = 0;
	sub_6FC50(x_BYTE_D419D);
	v1 = 0;
	v2 = x_D41A0_BYTEARRAY_0 + 11230;
	while (v0 < *(unsigned __int16 *)(x_D41A0_BYTEARRAY_0 + 14))
	{
		if (*(x_BYTE *)(v2 + 6))
			++v1;
		++v0;
		v2 += 2124;
	}
	v3 = 0;v28 = 0;//fix it
  /*  v3 = v1 * *(unsigned __int8 *)(**filearray_2aa18c[6] + 515);
	v28 = (640 - (v1 * *(unsigned __int8 *)(**filearray_2aa18c[6] + 520) + *(unsigned __int8 *)(**filearray_2aa18c[6] + 514))) / 2;*/ //fix it
	if (x_WORD_180660_VGA_type_resolution == 1)
		v4 = 400;
	else
		v4 = 480;
	v5 = (v4 - v3) / 2;
	v25 = 0;
	for (i = x_D41A0_BYTEARRAY_0 + 11230; ; i += 2124)
	{
		result = *(unsigned __int16 *)(x_D41A0_BYTEARRAY_0 + 14);
		if (result <= v25)
			break;
		v6 = *(x_BYTE *)(i + 6);
		v23 = x_DWORD_EA3E4[*(unsigned __int16 *)(i + 10)];
		if (v6 == 1)
		{
			v29 = x_BYTE_E88E1[3 * sub_61790(v25)];
			v30 = x_BYTE_E88E0[3 * sub_61790(v25)];
			v7 = v28;
			/*sub_2BB40_draw_bitmap(v28, v5, (Bit8u**)(**filearray_2aa18c[6] + 510));
			sub_2BC80(
			  v7 + 4,
			  v5 + 4,
			  *(unsigned __int8 *)(**filearray_2aa18c[6] + 514) - 8,
			  *(unsigned __int8 *)(**filearray_2aa18c[6] + 515) - 8,
			  v30);*/ //fix it
			v8 = v29;
			v22 = (signed __int16)(v7 + 8);
			sub_2BC10_draw_text((Bit8u*)(i + 927), v7 + 8, v5 + 6, v29);
			sprintf_s(printbuffer, 512, "%d", *(x_DWORD *)(v23 + 140));
			v9 = v8;
			v10 = v25;
			sub_2BC10_draw_text((Bit8u*)printbuffer, v22, v5 + 20, v9);
			if (!v10 && x_D41A0_BYTEARRAY_4_struct.byteindex_A)
			{
				x_WORD_180546 = v7 + 20;
				x_WORD_180548 = v5 + 30;
			}
			v11 = 0;//fix it
			/*HIWORD(v11) = HIWORD(**filearray_2aa18c[6]);
			LOWORD(v11) = *(unsigned __int8 *)(**filearray_2aa18c[6] + 514);*/ //fix it
			v12 = v11 + v7;
			if (x_D41A0_BYTEARRAY_4_struct.byteindex_A && *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 14) > 1u && !x_BYTE_180558)
			{
				x_DWORD_180532 = 9377 * x_DWORD_180532 + 9439;
				v13 = x_D41A0_BYTEARRAY_4[26] & 0xFF;
				x_BYTE_180558 = x_DWORD_180532 % (unsigned int)*(unsigned __int16 *)(x_D41A0_BYTEARRAY_0 + 14) + 1;
				v14 = v13 + x_DWORD_180532;
				v15 = 1;
				x_DWORD_180532 = v14;
				while (v15 < 8 && !*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 2124 * v15 + 11236))
				{
					v16 = *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 14);
					if ((unsigned __int8)++x_BYTE_180558 >= (signed int)v16)
						x_BYTE_180558 = 1;
					++v15;
				}
				if (!*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 2124 * (unsigned __int8)x_BYTE_180558 + 11236))
					x_BYTE_180558 = 0;
			}
			for (j = 0; j < 8; j++)
			{
				if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 2124 * j + 11236) == 1)
				{
					v27 = v12 + 4;
					v26 = v5 + 4;
					if (j == v25)
					{
						/*sub_2BB40_draw_bitmap(v12, v5, (Bit8u**)(**filearray_2aa18c[6] + 516));
						sub_2BC80(
						  v27,
						  v26,
						  *(unsigned __int8 *)(**filearray_2aa18c[6] + 520) - 8,
						  *(unsigned __int8 *)(**filearray_2aa18c[6] + 521) - 8,
						  (unsigned __int8)*xadataclrd0dat.var28_begin_buffer);*/ // fix it
					}
					else
					{
						v29 = x_BYTE_E88E1[3 * sub_61790(j)];
						v30 = x_BYTE_E88E0[3 * sub_61790(j)];
						/*sub_2BB40_draw_bitmap(v12, v5, (Bit8u**)(**filearray_2aa18c[6] + 516));
						sub_2BC80(
						  v27,
						  v26,
						  *(unsigned __int8 *)(**filearray_2aa18c[6] + 520) - 8,
						  *(unsigned __int8 *)(**filearray_2aa18c[6] + 521) - 8,
						  v30);*/ //fix it
						sprintf_s(printbuffer, 512, "%03d", *(signed __int16 *)(*(x_DWORD *)(v23 + 164) + 2 * j + 38));
						sub_2BC10_draw_text((Bit8u*)printbuffer, v12 + 8, v5 + 10, v29);
						if (x_D41A0_BYTEARRAY_4_struct.byteindex_A && x_BYTE_180558 && !v25 && j == (unsigned __int8)x_BYTE_180558)
						{
							x_WORD_18054A = v12 + 20;
							x_WORD_18054C = v5 + 20;
						}
					}
					/*HIWORD(v18) = HIWORD(**filearray_2aa18c[6]);
					LOWORD(v18) = *(unsigned __int8 *)(**filearray_2aa18c[6] + 520);
					v12 += v18;*/ //fix it
				}
			}
			/*HIWORD(v19) = HIWORD(**filearray_2aa18c[6]);
			LOWORD(v19) = *(unsigned __int8 *)(**filearray_2aa18c[6] + 515);
			v5 += v19;*/ // fix it
		}
		++v25;
	}
	return result;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// D419D: using guessed type char x_BYTE_D419D;
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3DC: using guessed type int **filearray_2aa18c[6];
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// 180532: using guessed type int x_DWORD_180532;
// 180546: using guessed type __int16 x_WORD_180546;
// 180548: using guessed type __int16 x_WORD_180548;
// 18054A: using guessed type __int16 x_WORD_18054A;
// 18054C: using guessed type __int16 x_WORD_18054C;
// 180558: using guessed type char x_BYTE_180558;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0002D710) --------------------------------------------------------
void sub_2D710(int a1)
{
	__int16 v1; // bx
	unsigned int v2; // ecx
	int v3; // ecx
	int v4; // edx
	int v5; // eax
	__int64 v6; // rtt
	__int16 v8; // bx
	unsigned int v9; // eax
	__int16 v12; // bx
	__int16 v14; // bx
	unsigned __int8 v16; // [esp-4h] [ebp-4Ch]
	int v17; // [esp+0h] [ebp-48h]
	int v18; // [esp+8h] [ebp-40h]
	unsigned int v19; // [esp+Ch] [ebp-3Ch]
	int v20; // [esp+10h] [ebp-38h]
	__int16 v21; // [esp+1Ch] [ebp-2Ch]
	__int16 v22; // [esp+24h] [ebp-24h]
	x_DWORD *v23; // [esp+28h] [ebp-20h]
	signed __int16 v24; // [esp+2Ch] [ebp-1Ch]
	signed __int16 v25; // [esp+30h] [ebp-18h]
	unsigned __int8 v26; // [esp+34h] [ebp-14h]
	unsigned __int8 v27; // [esp+3Ch] [ebp-Ch]
	unsigned __int8 v28; // [esp+40h] [ebp-8h]

	v28 = x_BYTE_E88E0[3 * sub_61790(*(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 56))];
	v27 = x_BYTE_E88E1[3 * sub_61790(*(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 56))];
	v26 = x_BYTE_E88E0[3 * sub_61790(*(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 56))
		+ x_D41A0_BYTEARRAY_4[0x7B]];
	/*x_DWORD_F01E8(2, 2, **filearray_2aa18c[6] + 240);
	v1 = *(unsigned __int8 *)(*filearray_2aa18c[6] + 244) + 2;*/ //fix it
	v18 = x_D41A0_BYTEARRAY_4[0xF6];
	v20 = *(x_DWORD *)(a1 + 164);
	v2 = x_DWORD_EA3E4[*(unsigned __int16 *)(v20 + 58)];
	v23 = (x_DWORD *)v2;
	if (v2 > x_DWORD_EA3E4[0] && *(x_DWORD *)(v2 + 16))
	{
		if (*(x_BYTE *)(v20 + 405) > 0 && x_D41A0_BYTEARRAY_4[0x7A])
		{
			//x_DWORD_F01E8(v1, 2, **filearray_2aa18c[6] + 330); //fix it
			--*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 405);
		}
		v1 = 0;//fix it 
		/*else
		{
		  x_DWORD_F01E8(v1, 2, **filearray_2aa18c[6] + 246);
		}*/ //fix it
		/*sub_2BB40_draw_bitmap(v1 + 2, 2, (Bit8u**)(6 * (v23[4] + 43) + **filearray_2aa18c[6]));
		sub_2BB40_draw_bitmap(v1 + 38, 2, (Bit8u**)((Bit8u**)(**filearray_2aa18c[6] + 252)));*/ //fix it
		v22 = v1 + 58;
		sub_2D190(v1 + 58, 10, 64, 10, (v23[2] << 6) / v23[1], 0x7Bu);
		v17 = (v23[36] + *(x_DWORD *)(*(x_DWORD *)(a1 + 164) + 316)) << 6;
		if (v23[36] + *(x_DWORD *)(*(x_DWORD *)(a1 + 164) + 316) == v23[35])
		{
			if (x_D41A0_BYTEARRAY_4[0x7B] == 1)
			{
				v3 = v18;
				v4 = v23[35] << 6;
				v16 = v27;
				v5 = v23[35] << 6;
			}
			else
			{
				v16 = v28;
				v5 = (v23[36] + *(x_DWORD *)(*(x_DWORD *)(a1 + 164) + 316)) << 6;
				v4 = (v23[36] + *(x_DWORD *)(*(x_DWORD *)(a1 + 164) + 316)) << 6;
				v3 = v18;
			}
		}
		else
		{
			sub_2D190(v22, 28, 64, 10, (v23[35] << 6) / v18, v27);
			v16 = v28;
			v5 = v17;
			v4 = v17;
			v3 = v18;
		}
		LODWORD(v6) = v5;
		HIDWORD(v6) = v4 >> 31;
		sub_2D190(v22, 28, 64, 10, v6 / v3, v16);
		if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10) && *(x_WORD *)(0x2FED5 + x_D41A0_BYTEARRAY_0))
		{
			sub_2BC80(v22 + (*(unsigned __int16 *)(0x2FED5 + x_D41A0_BYTEARRAY_0) << 6) / 100, 26, 2, 2, v26);
			sub_2BC80(v22 + (*(unsigned __int16 *)(0x2FED5 + x_D41A0_BYTEARRAY_0) << 6) / 100, 38, 2, 2, v26);
		}
	}
	/*else
	{
	  x_DWORD_F01E8(v1, 2, **filearray_2aa18c[6] + 324);
	}
	v8 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 250) + v1;
	if ( x_DWORD_EA3E4[0] >= (unsigned int)v23 )
	{
	  x_DWORD_F01E8(v8, 2, **filearray_2aa18c[6] + 324);
	}
	else*/// fix it
	{
		if (*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 407) > 0 && x_D41A0_BYTEARRAY_4[0x7A])
		{
			//x_DWORD_F01E8(v8, 2, **filearray_2aa18c[6] + 330);//fix it
			--*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 407);
		}
		/*else
		{
		  x_DWORD_F01E8(v8, 2, **filearray_2aa18c[6] + 246);
		}*/ // fix it
		switch (v23[4])
		{
		case 1:
		case 2:
		case 3:
			v25 = 1;
			break;
		case 4:
		case 5:
			v25 = 2;
			break;
		case 6:
		case 7:
			v25 = 3;
			break;
		default:
			v25 = 0;
			break;
		}
		v8 = 0;v24 = 0;//fix it
		/*sub_2BB40_draw_bitmap(v8 + 2, 2, (Bit8u**)(6 * (v25 + 50) + **filearray_2aa18c[6]));
		v24 = 0;
		sub_2BB40_draw_bitmap(v8 + 38, 2, (Bit8u**)((Bit8u**)(**filearray_2aa18c[6] + 252)));*/ // fix it
		if (v25 > 0)
		{
			do
			{
				v21 = v8 + 58;
				v9 = x_DWORD_EA3E4[*(unsigned __int16 *)(*(x_DWORD *)(a1 + 164) + 2 * v24 + 60)];
				v19 = v9;
				if (v9 > x_DWORD_EA3E4[0])
				{
					if (*(x_DWORD *)(v9 + 8) >= 0)
						sub_2D190(v21, 2 * v24 + 12, 64, 2, (*(x_DWORD *)(v9 + 8) << 6) / *(x_DWORD *)(v9 + 4), 0x7Bu);
					sub_2D190(v21, 2 * v24 + 30, 64, 2, (*(x_DWORD *)(v19 + 144) << 6) / *(x_DWORD *)(v19 + 140), v28);
				}
				++v24;
			} while (v24 < v25);
		}
	}
	v12 = 0;//fix it
	/*v12 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 250) + v8;
	if ( *(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 406) > 0 && x_D41A0_BYTEARRAY_4[0x7A] )
	{
	  x_DWORD_F01E8(v12, 2, **filearray_2aa18c[6] + 330);
	  --*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 406);
	}
	else
	{
	  x_DWORD_F01E8(v12, 2, **filearray_2aa18c[6] + 246);
	}*/ // fix it
	/*if ( (*(x_BYTE *)(a1 + 12) & 0x20 || *(x_WORD *)(*(x_DWORD *)(a1 + 164) + 345)) && x_D41A0_BYTEARRAY_4[0x7B] )
	{
	  sub_2DE80(v12 + 2, 2, (Bit8u**)(**filearray_2aa18c[6] + 258));
	  sub_2DE80(v12 + 38, 2, (Bit8u**)((Bit8u**)(**filearray_2aa18c[6] + 252)));
	}
	else
	{
	  sub_2BB40_draw_bitmap(v12 + 2, 2, (Bit8u**)(**filearray_2aa18c[6] + 258));
	  sub_2BB40_draw_bitmap(v12 + 38, 2, (Bit8u**)((Bit8u**)(**filearray_2aa18c[6] + 252)));
	}*/ // fix it
	v14 = v12 + 58;
	sub_2D190(v14, 10, 64, 10, (*(x_DWORD *)(a1 + 8) << 6) / *(x_DWORD *)(a1 + 4), 0x7Bu);
	sub_2D190(v14, 28, 64, 10, (*(x_DWORD *)(a1 + 140) << 6) / v18, v27);
	return sub_2D190(v14, 28, 64, 10, (*(x_DWORD *)(a1 + 144) << 6) / v18, v28);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3DC: using guessed type int **filearray_2aa18c[6];
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// F01E8: using guessed type int (*x_DWORD_F01E8)(x_DWORD, x_DWORD, x_DWORD);

//----- (0002DE80) --------------------------------------------------------
char sub_2DE80(__int16 a1, __int16 a2, Bit8u** a3)
{
	__int16 v3; // bx
	int v4; // eax
	x_BYTE *v5; // edi
	x_BYTE *v6; // edx
	x_BYTE *v7; // esi
	int v8; // ecx
	__int16 v9; // bx
	x_BYTE *v10; // edi
	x_BYTE *v11; // edx
	x_BYTE *v12; // esi
	int v13; // ecx
	int v15; // [esp+0h] [ebp-Ch]
	int v16; // [esp+0h] [ebp-Ch]
	int v17; // [esp+4h] [ebp-8h]
	int i; // [esp+8h] [ebp-4h]

	if (x_WORD_180660_VGA_type_resolution == 1)
	{
		v3 = *(unsigned __int8 *)(a3 + 5) / 2;
		v4 = a2 / 2 * x_DWORD_18062C_resolution_x + a1 / 2;
		v5 = (x_BYTE *)(v4 + x_DWORD_180628b_screen_buffer);
		v6 = *(x_BYTE **)a3;
		for (i = v4 + (int)x_DWORD_180628b_screen_buffer; v3; v6 += v15)
		{
			while (1)
			{
				while (1)
				{
					LOBYTE(v4) = *v6++;
					if ((x_BYTE)v4)
						break;
					--v3;
					i += x_DWORD_18062C_resolution_x;
					v5 = (x_BYTE *)i;
					if (!v3)
						return v4;
				}
				if ((v4 & 0x80u) == 0)
					break;
				v5 -= (char)v4;
				if (!v3)
					return v4;
			}
			v4 = (char)v4;
			v7 = v6;
			v8 = v4;
			v15 = (char)v4;
			HIWORD(v4) = 0;
			do
			{
				LOBYTE(v4) = *v7++;
				BYTE1(v4) = *v5;
				LOBYTE(v4) = x_BYTE_FAEE0[v4];
				*v5++ = v4;
				--v8;
			} while (v8);
		}
	}
	else
	{
		v4 = a1 + x_DWORD_18062C_resolution_x * a2;
		v9 = *(unsigned __int8 *)(a3 + 5);
		v10 = (x_BYTE *)(v4 + (int)x_DWORD_180628b_screen_buffer);
		v11 = *(x_BYTE **)a3;
		v17 = v4 + (int)x_DWORD_180628b_screen_buffer;
		if (*(x_BYTE *)(a3 + 5))
		{
			do
			{
				while (1)
				{
					while (1)
					{
						LOBYTE(v4) = *v11++;
						if ((x_BYTE)v4)
							break;
						--v9;
						v17 += x_DWORD_18062C_resolution_x;
						v10 = (x_BYTE *)v17;
						if (!v9)
							return v4;
					}
					if ((v4 & 0x80u) == 0)
						break;
					v10 -= (char)v4;
					if (!v9)
						return v4;
				}
				v4 = (char)v4;
				v12 = v11;
				v13 = v4;
				v16 = (char)v4;
				HIWORD(v4) = 0;
				do
				{
					LOBYTE(v4) = *v12++;
					BYTE1(v4) = *v10;
					LOBYTE(v4) = x_BYTE_FAEE0[v4];
					*v10++ = v4;
					--v13;
				} while (v13);
				v11 += v16;
			} while (v9);
		}
	}
	return v4;
}
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 18062C: using guessed type int x_DWORD_18062C_resolution_x;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0002DFD0) --------------------------------------------------------
char sub_2DFD0(__int16 a1, __int16 a2, int a3, unsigned __int8 a4)
{
	int v4; // eax
	x_BYTE *v5; // edi
	x_BYTE *v6; // edx
	int v7; // ebx
	int v8; // ecx
	x_BYTE *v9; // edi
	x_BYTE *v10; // edx
	int v11; // ebx
	int v12; // ecx
	int v14; // [esp+0h] [ebp-14h]
	int v15; // [esp+0h] [ebp-14h]
	int i; // [esp+4h] [ebp-10h]
	int v17; // [esp+8h] [ebp-Ch]
	__int16 v18; // [esp+Ch] [ebp-8h]
	__int16 v19; // [esp+10h] [ebp-4h]

	if (x_WORD_180660_VGA_type_resolution == 1)
	{
		v19 = *(unsigned __int8 *)(a3 + 5) / 2;
		v4 = a2 / 2 * x_DWORD_18062C_resolution_x + a1 / 2;
		v5 = (x_BYTE *)(v4 + (int)x_DWORD_180628b_screen_buffer);
		v6 = *(x_BYTE **)a3;
		for (i = v4 + (int)x_DWORD_180628b_screen_buffer; v19; v6 += v14)
		{
			while (1)
			{
				while (1)
				{
					LOBYTE(v4) = *v6++;
					if ((x_BYTE)v4)
						break;
					LOBYTE(v4) = x_DWORD_18062C_resolution_x;
					i += x_DWORD_18062C_resolution_x;
					v5 = (x_BYTE *)i;
					if (!--v19)
						return v4;
				}
				if ((v4 & 0x80u) == 0)
					break;
				v5 -= (char)v4;
				if (!v19)
					return v4;
			}
			v7 = a4;
			v8 = (char)v4;
			v14 = (char)v4;
			do
			{
				BYTE1(v7) = *v5;
				LOBYTE(v4) = x_BYTE_FAEE0[v7];
				*v5++ = v4;
				--v8;
			} while (v8);
		}
	}
	else
	{
		v18 = *(unsigned __int8 *)(a3 + 5);
		LOBYTE(v4) = (int)x_DWORD_180628b_screen_buffer;
		v9 = (x_BYTE *)((int)x_DWORD_180628b_screen_buffer + a1 + x_DWORD_18062C_resolution_x * a2);
		v10 = *(x_BYTE **)a3;
		v17 = (int)x_DWORD_180628b_screen_buffer + a1 + x_DWORD_18062C_resolution_x * a2;
		if (*(x_BYTE *)(a3 + 5))
		{
			do
			{
				while (1)
				{
					while (1)
					{
						LOBYTE(v4) = *v10++;
						if ((x_BYTE)v4)
							break;
						LOBYTE(v4) = x_DWORD_18062C_resolution_x;
						v9 = (x_BYTE *)(x_DWORD_18062C_resolution_x + v17);
						v17 += x_DWORD_18062C_resolution_x;
						if (!--v18)
							return v4;
					}
					if ((v4 & 0x80u) == 0)
						break;
					v9 -= (char)v4;
					if (!v18)
						return v4;
				}
				v11 = a4;
				v12 = (char)v4;
				v15 = (char)v4;
				do
				{
					BYTE1(v11) = *v9;
					LOBYTE(v4) = x_BYTE_FAEE0[v11];
					*v9++ = v4;
					--v12;
				} while (v12);
				v10 += v15;
			} while (v18);
		}
	}
	return v4;
}
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 18062C: using guessed type int x_DWORD_18062C_resolution_x;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0002E260) --------------------------------------------------------
void sub_2E260(__int16 a1, __int16 a2, unsigned int a3, char a4)
{
	unsigned int v4; // eax
	signed int v5; // eax
	__int16 v6; // t1
	__int16 v7; // cx
	//Bit8u** v8; // eax
	int v9; // eax
	int v10; // edi
	unsigned __int16 v11; // di
	unsigned __int8 v12; // al
	signed int i; // [esp+0h] [ebp-14h]
	signed int j; // [esp+4h] [ebp-10h]
	unsigned int v15; // [esp+8h] [ebp-Ch]
	unsigned __int8 v16; // [esp+Ch] [ebp-8h]
	unsigned __int8 v17; // [esp+10h] [ebp-4h]

	if (a3 > x_DWORD_EA3E4[0])
	{
		sub_6FC50(x_BYTE_D419D);
		v4 = x_DWORD_EA3E4[*(unsigned __int16 *)(a3 + 40)];
		v15 = v4;
		if (v4 > x_DWORD_EA3E4[0])
		{
			v17 = x_BYTE_E88E0[3 * sub_61790(*(signed __int16 *)(*(x_DWORD *)(v4 + 164) + 56))];
			v5 = sub_61790(*(signed __int16 *)(*(x_DWORD *)(v15 + 164) + 56));
			v6 = *(x_WORD *)(a3 + 46);
			v16 = x_BYTE_E88E1[3 * v5];
			if (!(x_BYTE_DA819[80 * *(char *)(a3 + 64)] & 4)
				|| (v7 = *(x_WORD *)(a3 + 46), v7 <= 0)
				|| v7 >= 32
				|| !x_D41A0_BYTEARRAY_4[0x7A])
			{
				if (a4)
				{
					/*if ( *(x_WORD *)(a3 + 46) )
					  v8 = (Bit8u**)(**filearray_2aa18c[6] + 12);
					else
					  v8 = (Bit8u**)(**filearray_2aa18c[6] + 6);
					sub_2BB40_draw_bitmap(a1, a2, v8);*/ // fix it
				}
				else
				{
					/*if ( *(x_WORD *)(a3 + 46) )
					  v9 = **filearray_2aa18c[6] + 12;
					else
					  v9 = **filearray_2aa18c[6] + 6;*/ // fix it
					v9 = 0;//fix it
					x_DWORD_F01E8(a1, a2, v9);
				}
				/*sub_2BB40_draw_bitmap(a1, a2, (Bit8u**)(6 * (*(char *)(a3 + 64) + 123) + **filearray_2aa18c[6]));
				sub_2BC10_draw_text(
				  (x_BYTE*)*(&off_DB06C + *(char *)(a3 + 70)),
				  *(unsigned __int8 *)(**filearray_2aa18c[6] + 10) + a1 - 8 * strlen((const char *)*(&off_DB06C + *(char *)(a3 + 70))) - 2,
				  a2,
				  (unsigned __int8)*xadataclrd0dat.var28_begin_buffer);*/ // fix it
				if (*(x_DWORD *)(a3 + 140))
				{
					sub_2BC80(
						a1 + 4,
						a2 + 36,
						56 * (*(x_DWORD *)(v15 + 144) % *(x_DWORD *)(a3 + 140)) / *(x_DWORD *)(a3 + 140),
						4,
						v16);
					v10 = *(x_DWORD *)(v15 + 144) / *(x_DWORD *)(a3 + 140);
					for (i = 0; i < 27 && v10; i++)
					{
						for (j = 0; j < 2 && v10; j++)
						{
							sub_2BC80(a1 + 2 * (i + 2), a2 + 2 * (j + 18), 2, 2, v17);
							--v10;
						}
					}
				}
				if (*(x_DWORD *)(a3 + 136))
				{
					v11 = *(x_WORD *)(*(x_DWORD *)(v15 + 164) + 58);
					if (!v11 || *(x_DWORD *)(a3 + 136) > *(x_DWORD *)(x_DWORD_EA3E4[v11] + 144))
					{
						if (*(0x2FED1 + x_D41A0_BYTEARRAY_0 + 3))
							v12 = 16;
						else
							v12 = 48;
						//sub_2E850(a1, a2, *(unsigned __int8 *)(**filearray_2aa18c[6] + 10), *(unsigned __int8 *)(**filearray_2aa18c[6] + 11), v12); // fix it
					}
				}
			}
		}
	}
}
// D419D: using guessed type char x_BYTE_D419D;
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// DB06C: using guessed type void *off_DB06C;
// EA3DC: using guessed type int **filearray_2aa18c[6];
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// F01E8: using guessed type int (*x_DWORD_F01E8)(x_DWORD, x_DWORD, x_DWORD);

//----- (0002E790) --------------------------------------------------------
int sub_2E790(__int16 a1, int a2, int a3, int a4, unsigned __int8 a5)
{
	__int16 v5; // bx
	int v6; // ecx
	int v7; // eax
	int result; // eax
	__int16 v9; // si
	int v10; // [esp+Ch] [ebp-4h]

	v5 = a1;
	v6 = a2;
	if (x_WORD_180660_VGA_type_resolution == 1)
	{
		v5 = a1 / 2;
		HIWORD(v7) = HIWORD(a2);
		LOWORD(v7) = (signed __int16)a2 / 2;
		v6 = v7;
		HIWORD(v7) = HIWORD(a3);
		LOWORD(v7) = (signed __int16)a3 / 2;
		a3 = v7;
		HIWORD(v7) = HIWORD(a4);
		LOWORD(v7) = (signed __int16)a4 / 2;
		a4 = v7;
	}
	for (result = v6; (signed __int16)result < (signed __int16)v6 + (signed __int16)a4; ++result)
	{
		v9 = v5;
		while (1)
		{
			v10 = v9;
			if ((signed __int16)a3 + v5 <= v9)
				break;
			++v9;
			*(x_BYTE *)((int)x_DWORD_180628b_screen_buffer + x_DWORD_18062C_resolution_x * (signed __int16)result + v10) = x_BYTE_FAEE0[256 * a5
				+ *(unsigned __int8 *)((int)x_DWORD_180628b_screen_buffer + x_DWORD_18062C_resolution_x * (signed __int16)result + v10)];
		}
	}
	return result;
}
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 18062C: using guessed type int x_DWORD_18062C_resolution_x;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0002E850) --------------------------------------------------------
int sub_2E850(__int16 a1, int a2, int a3, int a4, unsigned __int8 a5)
{
	__int16 v5; // bx
	int v6; // ecx
	int v7; // eax
	int result; // eax
	__int16 v9; // si
	int v10; // [esp+Ch] [ebp-4h]

	v5 = a1;
	v6 = a2;
	if (x_WORD_180660_VGA_type_resolution == 1)
	{
		v5 = a1 / 2;
		HIWORD(v7) = HIWORD(a2);
		LOWORD(v7) = (signed __int16)a2 / 2;
		v6 = v7;
		HIWORD(v7) = HIWORD(a3);
		LOWORD(v7) = (signed __int16)a3 / 2;
		a3 = v7;
		HIWORD(v7) = HIWORD(a4);
		LOWORD(v7) = (signed __int16)a4 / 2;
		a4 = v7;
	}
	for (result = v6; (signed __int16)result < (signed __int16)v6 + (signed __int16)a4; ++result)
	{
		v9 = v5;
		while (1)
		{
			v10 = v9;
			if ((signed __int16)a3 + v5 <= v9)
				break;
			++v9;
			*(x_BYTE *)((int)x_DWORD_180628b_screen_buffer + x_DWORD_18062C_resolution_x * (signed __int16)result + v10) = x_BYTE_F6EE0_tables[256 * a5
				+ *(unsigned __int8 *)((int)x_DWORD_180628b_screen_buffer + x_DWORD_18062C_resolution_x * (signed __int16)result + v10)];
		}
	}
	return result;
}
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 18062C: using guessed type int x_DWORD_18062C_resolution_x;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0002EB40) --------------------------------------------------------
void sub_2EB40()
{
	//int result; // eax

	//BYTE1(result) = 0;
	x_BYTE_D41CE = 0;
	x_BYTE_D41C1 = 0;
	x_DWORD_D41D0 = 0;
	//return result;
}
// D41C1: using guessed type char x_BYTE_D41C1;
// D41CE: using guessed type char x_BYTE_D41CE;
// D41D0: using guessed type int x_DWORD_D41D0;

//----- (0002EB60) --------------------------------------------------------
void sub_2EB60()
{
	//int result; // eax

	if (!x_BYTE_D41CE)
	{
		x_BYTE_D41CE = 1;
		x_BYTE_D41C1 = 1;
		x_DWORD_F01E4 = &x_DWORD_180628b_screen_buffer[0xfb40];//line 320x201 - after normal image
		x_WORD_F01F4 = 0x3200;
		sub_2EC30_clear_img_mem();
		x_DWORD_D41D0 = 0;
	}
	//return result;
}
// D41C1: using guessed type char x_BYTE_D41C1;
// D41CE: using guessed type char x_BYTE_D41CE;
// D41D0: using guessed type int x_DWORD_D41D0;
// F01E4: using guessed type int x_DWORD_F01E4;
// F01F4: using guessed type __int16 x_WORD_F01F4;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;

//----- (0002EBB0) --------------------------------------------------------
void sub_2EBB0_draw_text_with_border_630x340(Bit8u* a1)//20fbb0
{
	//int result; // eax

	if (x_BYTE_D41CE)
	{
		x_DWORD_D41D0 = a1;
		x_WORD_E36D4 = 64;
		x_DWORD_180628b_screen_buffer += 0x26C0;
		/*result = */sub_7FCB0_draw_text_with_border(64, a1, 0, 630, 340, 5, x_BYTE_EB3B6, 0);
		x_WORD_E36D4 = 0;
		x_DWORD_180628b_screen_buffer -= 0x26C0;
	}
	//return result;
}
// D41CE: using guessed type char x_BYTE_D41CE;
// D41D0: using guessed type int x_DWORD_D41D0;
// E36D4: using guessed type __int16 x_WORD_E36D4;
// EB3B6: using guessed type char x_BYTE_EB3B6;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;

//----- (0002EC30) --------------------------------------------------------
void sub_2EC30_clear_img_mem()
{
	//int result; // eax

	if (x_BYTE_D41CE)
		memset((void*)x_DWORD_F01E4, 0, x_WORD_F01F4);
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D41CE: using guessed type char x_BYTE_D41CE;
// F01E4: using guessed type int x_DWORD_F01E4;
// F01F4: using guessed type __int16 x_WORD_F01F4;

//----- (0002EC60) --------------------------------------------------------
void sub_2EC60()
{
	//int result; // eax

	if (x_BYTE_D41CE)
	{
		sub_2EC30_clear_img_mem();
		x_BYTE_D41C1 = 0;
		x_BYTE_D41CE = 0;
		x_DWORD_D41D0 = 0;
	}
	//return result;
}
// D41C1: using guessed type char x_BYTE_D41C1;
// D41CE: using guessed type char x_BYTE_D41CE;
// D41D0: using guessed type int x_DWORD_D41D0;

//----- (0002EC90) --------------------------------------------------------
void sub_2EC90(char a1)
{
	//char result; // al

	if (x_BYTE_D41CE)
	{
		//result = a1;
		x_BYTE_EB3B6 = a1;
		if (x_DWORD_D41D0)
			/*result = */sub_2EBB0_draw_text_with_border_630x340((Bit8u*)x_DWORD_D41D0);
	}
	//return result;
}
// D41CE: using guessed type char x_BYTE_D41CE;
// D41D0: using guessed type int x_DWORD_D41D0;
// EB3B6: using guessed type char x_BYTE_EB3B6;

//----- (0002ECC0) --------------------------------------------------------
__int16 sub_2ECC0()
{
	char v0; // t0
	int v1; // eax
	int v2; // eax
	char v3; // dh
	signed int v4; // eax
	__int16 v5; // si
	__int16 v6; // di
	__int16 v7; // bx
	char v8; // dl
	unsigned int v9; // edx
	__int16 v10; // ax
	__int16 v11; // ax
	unsigned __int16 v12; // dx
	int v13; // eax
	unsigned __int8 v14; // al
	int v15; // eax
	int v16; // eax
	unsigned __int8 v17; // dl
	__int16 v18; // cx
	int v19; // esi
	int v20; // ebx
	char *v21; // edi
	int v22; // eax
	unsigned __int16 v23; // cx
	signed __int16 v24; // ax
	__int16 v25; // cx
	int v26; // eax
	int v27; // eax
	int v28; // ecx
	int v29; // edx
	int v30; // ecx
	int v31; // eax
	int v32; // edi
	__int16 result; // ax
	int v34; // [esp+4h] [ebp-6Ch]
	int v35; // [esp+Ch] [ebp-64h]
	int v36; // [esp+10h] [ebp-60h]
	unsigned int v37; // [esp+14h] [ebp-5Ch]
	signed int i; // [esp+18h] [ebp-58h]
	char *v39; // [esp+24h] [ebp-4Ch]
	signed int v40; // [esp+28h] [ebp-48h]
	__int16 v41; // [esp+2Ch] [ebp-44h]
	__int16 v42; // [esp+34h] [ebp-3Ch]
	int v43; // [esp+38h] [ebp-38h]
	__int16 v44; // [esp+38h] [ebp-38h]
	//__int16 v45; // [esp+3Ch] [ebp-34h]
	unsigned __int8 v46; // [esp+40h] [ebp-30h]
	signed __int16 v47; // [esp+40h] [ebp-30h]
	int v48; // [esp+44h] [ebp-2Ch]
	__int16 v49; // [esp+48h] [ebp-28h]
	__int16 v50; // [esp+4Ch] [ebp-24h]
	//int v51; // [esp+50h] [ebp-20h]
	__int16 v52; // [esp+54h] [ebp-1Ch]
	__int16 v53; // [esp+58h] [ebp-18h]
	__int16 v54; // [esp+5Ch] [ebp-14h]
	char v55; // [esp+60h] [ebp-10h]
	unsigned __int8 v56; // [esp+64h] [ebp-Ch]
	unsigned __int8 v57; // [esp+68h] [ebp-8h]
	char v58; // [esp+6Ch] [ebp-4h]

	v0 = *(0x2FED1 + x_D41A0_BYTEARRAY_0 + 3);
	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240)];
	v37 = v1;
	v2 = *(x_DWORD *)(v1 + 164);
	v36 = v2 + 611;
	v57 = x_BYTE_E88E0[3 * sub_61790(*(signed __int16 *)(v2 + 56))];
	v56 = x_BYTE_E88E1[3 * sub_61790(*(signed __int16 *)(*(x_DWORD *)(v37 + 164) + 56))];
	v3 = x_WORD_180660_VGA_type_resolution;
	x_D41A0_BYTEARRAY_4[50] = -1;
	if (v3 & 1)
		v4 = 400;
	else
		v4 = 480;
	/*  v41 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 532);
	  v48 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 539);
	  v51 = v4 - 2 * v48;
	  v42 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 538);
	  v49 = 0;
	  v54 = 0;
	  v45 = v42 - *(unsigned __int8 *)(**filearray_2aa18c[6] + 898);*/ // fix it
	v48 = 0;v49 = 0;//fix it
	v5 = v4 - 2 * v48;
	while (v49 < 2)
	{
		/*if ( !v49 )
		  x_DWORD_F01E8(0, v5, **filearray_2aa18c[6] + 528);*/ //fix it
		v41 = 0;v44 = 0;v54 = 0;//fix it
		v6 = v41;
		v7 = 0;
		while (v7 < 13)
		{
			v44 = (unsigned __int8)x_BYTE_D94FF[v54];
			v8 = 1;
			if (!*xadataspellsdat.var28_begin_buffer[80 * (unsigned __int8)x_BYTE_D94FF[v54]] || !x_BYTE_D41B6 && v44 == 25)
				v8 = 0;
			if (!v8)
			{
				//x_DWORD_F01E8(v6, v5, **filearray_2aa18c[6] + 534);//fix it
				goto LABEL_54;
			}
			v9 = x_DWORD_EA3E4[*(signed __int16 *)(*(x_DWORD *)(v37 + 164) + 2 * (unsigned __int8)x_BYTE_D94FF[v54] + 819)];
			if (v9 > x_DWORD_EA3E4[0])
			{
				if (v54 == *(char *)(v36 + 501))
				{
					x_D41A0_BYTEARRAY_4[50] = v54;
					v10 = *(char *)(v36 + 502);
				}
				else
				{
					v10 = *(char *)((unsigned __int8)x_BYTE_D94FF[v54] + v36 + 468);
				}
				v46 = v10;
				v39 = (char*)(*xadataspellsdat.var28_begin_buffer[80 * v44 + 2 + 26 * v10]);
				if (x_BYTE_DA819[80 * *(char *)(v9 + 64)] & 4)
				{
					v11 = *(x_WORD *)(v9 + 46);
					if (v11 > 0 && v11 < 32 && x_D41A0_BYTEARRAY_4[0x7A])
						goto LABEL_43;
				}
				v55 = 0;
				if (!*((x_DWORD *)v39 + 2)
					|| (v12 = *(x_WORD *)(*(x_DWORD *)(v37 + 164) + 58)) != 0
					&& *((x_DWORD *)v39 + 2) <= *(x_DWORD *)(x_DWORD_EA3E4[v12] + 144))
				{
					v55 = 1;
				}
				if (v55)
				{
					if (x_D41A0_BYTEARRAY_4[50] == v54)
					{
						v35 = sub_6D710(v37, v44, v46);
						if (v35 > 0)
						{
							//sub_2BB40_draw_bitmap(v6, v5, (Bit8u**)(**filearray_2aa18c[6] + 522)); // fix it
							sub_2BC80(v6 + 6, v5 + 28, 36 * (*(x_DWORD *)(v37 + 144) % v35) / v35, 4, v56);
							v34 = *(x_DWORD *)(v37 + 144) / v35;
							for (i = 0; i < 36 && v34 > 0; i += 2)
							{
								v40 = 0;
								while (v40 < 4 && v34 > 0)
								{
									sub_2BC80(i + v6 + 6, v40 + v5 + 28, 2, 2, v57);
									v40 += 2;
									--v34;
								}
							}
						}
					LABEL_40:
						/*if ( v55 )
						  sub_2BB40_draw_bitmap(v6, v5, (Bit8u**)(**filearray_2aa18c[6] + 6 * (v44 + 97)));
						else
						  sub_2DE80(v6, v5, (Bit8u**)(6 * (v44 + 97) + **filearray_2aa18c[6]));*///fix it
					LABEL_43:
						v14 = *(x_BYTE *)(v36 + v44 + 338);
						if (v14 >= 1u)
						{
							/*if ( v14 <= 1u )
							{
							  sub_2DE80(v6, v5, (Bit8u**)(**filearray_2aa18c[6] + 894));
							}
							else if ( v14 == 2 )
							{
							  sub_2DE80(v6 + v45, v5, (Bit8u**)(**filearray_2aa18c[6] + 900));
							}*/ //fix it
						}
						goto LABEL_54;
					}
					//v13 = **filearray_2aa18c[6] + 534;// fix it
				}
				else
				{
					//v13 = **filearray_2aa18c[6] + 546;//fix it
					v13 = 0;//fix it
				}
				x_DWORD_F01E8(v6, v5, v13);
				goto LABEL_40;
			}
			//x_DWORD_F01E8(v6, v5, **filearray_2aa18c[6] + 534);//fix it
			v15 = v44 + *(x_DWORD *)(v37 + 164);
			/*if ( *(x_BYTE *)(v15 + 1001) || *(x_BYTE *)(v15 + 1027) )
			  sub_2DFD0(v6, v5, **filearray_2aa18c[6] + 6 * (v44 + 97), 0xA6u);*/ //fix it
			v42 = 0;//fix it
		LABEL_54:
			++v7;
			v6 += v42;
			++v54;
		}
		/*if ( !v49 )
		  x_DWORD_F01E8(v6, v5, **filearray_2aa18c[6] + 528);
		v5 += *(unsigned __int8 *)(**filearray_2aa18c[6] + 539);*/ //fix it
		++v49;
	}
	//sub_2BB40_draw_bitmap(v41 + v42 * (*(char *)(v36 + 501) % 13), *(char *)(v36 + 501) / 13 * v48 + v51, (Bit8u**)(**filearray_2aa18c[6] + 540));//fix it
	v16 = x_D41A0_BYTEARRAY_4[50];
	if (v16 != -1)
	{
		v17 = x_BYTE_D94FF[v16];
		LOWORD(v43) = v17;
		v47 = *(char *)(v36 + v17 + 442);
		/*v18 = 3 * *(unsigned __int8 *)(**filearray_2aa18c[6] + 982);
		v50 = v51 - *(unsigned __int8 *)(**filearray_2aa18c[6] + 983);*/ // fix it
		v18 = 0;v50 = 0;//fix it
		v19 = v42 / 2 + v42 * (*(char *)(v36 + 501) % 13) + v41 - v18 / 2;
		if ((signed __int16)v19 <= 640 - v18)
		{
			if ((v19 & 0x8000u) != 0)
				LOWORD(v19) = 0;
		}
		else
		{
			LOWORD(v19) = 640 - v18;
		}
		v20 = 0;
		//v52 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 982);//fix it
		while (2)
		{
			if ((signed __int16)v20 >= 3)
				break;
			v21 = (char*)*xadataspellsdat.var28_begin_buffer[80 * (signed __int16)v43 + 2 + 26 * (signed __int16)v20];
			LOBYTE(v22) = 0;
			v58 = 0;
			if (!*((x_DWORD *)v21 + 2)
				|| (v23 = *(x_WORD *)(*(x_DWORD *)(v37 + 164) + 58)) != 0
				&& *((x_DWORD *)v21 + 2) <= *(x_DWORD *)(x_DWORD_EA3E4[v23] + 144))
			{
				v58 = 1;
				v22 = *(x_DWORD *)(v37 + 144) / sub_6D710(v37, v43, v20);
			}
			if ((signed __int16)v20 > v47)
			{
				//fix it  sub_2BB40_draw_bitmap(v19, v50, (Bit8u**)(**filearray_2aa18c[6] + 978));
			}
			else
			{
				if (v58 && (x_BYTE)v22)
					v24 = 161;
				else
					v24 = 162;
				//fix it  sub_2BB40_draw_bitmap(v19, v50, (Bit8u**)(**filearray_2aa18c[6] + 6 * v24));
				//fix it  sub_2BB40_draw_bitmap(v19 + 6, v50 + 10, (Bit8u**)(**filearray_2aa18c[6] + 6 * (signed __int16)(v20 + 165)));
				v53 = v19 + 18;
				v25 = v50 + 6;
				v26 = v20 + 3 * v43 + 179;
				//fix it  if ( v58 )
					//fix it  sub_2BB40_draw_bitmap(v53, v25, (Bit8u**)(**filearray_2aa18c[6] + 6 * (signed __int16)v26));
					//fix it  else
					//fix it  sub_2DE80(v53, v25, (Bit8u**)(6 * (signed __int16)v26 + **filearray_2aa18c[6]));
			}
			//fix it  if ( (x_WORD)v20 == *(char *)(v36 + 502) )
			//fix it  sub_2BB40_draw_bitmap(v19, v50, (Bit8u**)(**filearray_2aa18c[6] + 984));
			v52 = 0;//fix it
			if ((signed __int16)v20 <= v47 && (signed __int16)v20 < 2)
			{
				if ((x_WORD)v20 == v47)
				{
					if (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10)
					{
						v27 = (signed __int16)v43;
						v28 = *(x_DWORD *)(v21 + 42);
						v29 = *((x_DWORD *)v21 + 4);
					}
					else
					{
						v27 = (signed __int16)v43;
						v28 = *(x_DWORD *)(v21 + 38);
						v29 = *((x_DWORD *)v21 + 3);
					}
					v30 = v28 - v29;
					v31 = *(x_DWORD *)(4 * v27 + v36) + *(x_DWORD *)(4 * v27 + v36 + 104) - v29;
					if (v30 > 0)
					{
						v32 = 54 * v31 / v30;
						goto LABEL_92;
					}
				LABEL_91:
					LOWORD(v32) = 0;
				}
				else
				{
					if ((signed __int16)v20 >= v47)
						goto LABEL_91;
					LOWORD(v32) = 54;
				}
			LABEL_92:
				if ((v32 & 0x8000u) != 0)
					LOWORD(v32) = 0;
				if ((signed __int16)v32 > 54)
					LOWORD(v32) = 54;
				sub_2BC80(v19 + 6, v50 + 28, 54, 2, (unsigned __int8)*xadataclrd0dat.var28_begin_buffer);
				if ((x_WORD)v32)
					sub_2BC80(v19 + 6, v50 + 28, v32, 2, x_BYTE_E9800);
			}
			++v20;
			LOWORD(v19) = v52 + v19;
			continue;
		}
	}
	result = x_WORD_1805C2;
	if (x_WORD_1805C2 == 8
		|| x_WORD_1805C2 == 12
		|| x_WORD_1805C2 == 13
		|| x_WORD_1805C2 == 4
		|| x_WORD_1805C2 == 6
		|| x_WORD_1805C2 == 11
		|| x_WORD_1805C2 == 5)
	{
		//fix it  result = sub_2BB40_draw_bitmap(x_DWORD_1805B0, x_DWORD_1805B4, (Bit8u**)(**filearray_2aa18c[0] + 6 * (unsigned __int8)x_BYTE_D419E));
	}
	return result;
}
// D419E: using guessed type char x_BYTE_D419E;
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// D41B6: using guessed type char x_BYTE_D41B6;
// E9800: using guessed type char x_BYTE_E9800;
// EA3DC: using guessed type int **filearray_2aa18c[6];
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB394: using guessed type int **filearray_2aa18c[0];
// F01E8: using guessed type int (*x_DWORD_F01E8)(x_DWORD, x_DWORD, x_DWORD);
// 1805B0: using guessed type int x_DWORD_1805B0;
// 1805B4: using guessed type int x_DWORD_1805B4;
// 1805C2: using guessed type __int16 x_WORD_1805C2;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0002F6B0) --------------------------------------------------------
int sub_2F6B0()
{
	signed int v0; // eax
	int v1; // eax
	unsigned __int8 v2; // dl
	char v3; // dh
	__int16 v4; // bx
	unsigned __int8 v5; // di
	unsigned __int8 v6; // al
	__int16 v7; // si
	int v8; // ebx
	__int16 v9; // di
	unsigned int v10; // ebx
	__int16 v11; // si
	unsigned __int8 v12; // al
	__int16 v13; // ST04_2
	__int16 v14; // ST00_2
	__int16 v15; // si
	__int16 v16; // bx
	__int16 v17; // si
	__int16 v18; // bx
	int v19; // eax
	int v20; // ebx
	__int16 v21; // si
	int v22; // eax
	signed int v23; // eax
	int v24; // ebx
	int v25; // esi
	char v26; // al
	//int v27; // eax
	__int16 v28; // si
	__int16 v29; // bx
	__int16 v30; // si
	unsigned __int8 v31; // di
	int result; // eax
	//char v33; // [esp+0h] [ebp-Eh]
	int v34; // [esp+48h] [ebp+3Ah]
	int v35; // [esp+4Ch] [ebp+3Eh]
	int v36; // [esp+50h] [ebp+42h]
	int v37; // [esp+54h] [ebp+46h]
	int v38; // [esp+58h] [ebp+4Ah]
	int v39; // [esp+5Ch] [ebp+4Eh]
	int v40; // [esp+60h] [ebp+52h]
	x_BYTE *v41; // [esp+64h] [ebp+56h]
	unsigned __int8 v42; // [esp+68h] [ebp+5Ah]
	unsigned __int8 v43; // [esp+6Ch] [ebp+5Eh]
	unsigned __int8 v44; // [esp+70h] [ebp+62h]
	unsigned __int8 v45; // [esp+74h] [ebp+66h]
	unsigned __int8 v46; // [esp+78h] [ebp+6Ah]
	unsigned __int8 v47; // [esp+7Ch] [ebp+6Eh]
	unsigned __int8 v48; // [esp+80h] [ebp+72h]
	unsigned __int8 v49; // [esp+84h] [ebp+76h]
	bool v50; // [esp+88h] [ebp+7Ah]
	char v51; // [esp+8Ch] [ebp+7Eh]

	v41 = (x_BYTE *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11230);
	if (x_WORD_180660_VGA_type_resolution & 1)
		v0 = 400;
	else
		v0 = 480;
	v40 = v0 - 72;
	v36 = 0;
	v1 = 5 * *(0x2FED1 + x_D41A0_BYTEARRAY_0 + 3);
	v2 = x_BYTE_D94F0[v1];
	v47 = x_BYTE_D94F1[v1];
	v3 = x_BYTE_D94F2[v1];
	v48 = x_BYTE_D94F3[v1];
	v42 = x_BYTE_E98FF;
	v44 = (unsigned __int8)*xadataclrd0dat.var28_begin_buffer;
	v49 = v3;
	v45 = x_BYTE_E89F0;
	v43 = x_BYTE_E9800;
	v4 = v40;
	v51 = -1;
	sub_2BC80(0, v40, 640, 72, v2);
	v34 = v49;
	sub_2BC80(0, v4, 640, 2, v49);
	v5 = v48;
	sub_2BC80(0, v40 + 70, 640, 2, v48);
	sub_2BC80(0, v4, 2, 70, v34);
	sub_2BC80(v36 + 638, v4, 2, 72, v5);
	if (x_WORD_E3760_mousex < 4
		|| x_WORD_E3760_mousex >= 66
		|| x_WORD_E3762_mousey < v40 + 28
		|| x_WORD_E3762_mousey >= v40 + 66)
	{
		v6 = v41[992];
	}
	else
	{
		v6 = 4 * ((x_WORD_E3762_mousey - (v40 + 28)) / 20)
			+ ((x_WORD_E3760_mousex
				- 4
				- (__CFSHL__((x_WORD_E3760_mousex - 4) >> 31, 4)
					+ 16 * ((x_WORD_E3760_mousex - 4) >> 31))) >> 4);
	}
	v46 = v6;
	v7 = v40 + 4;
	v8 = v36 + 4;
	v9 = v36 + 4;
	v34 = (signed __int16)(v40 + 4);
	sub_2BC80(v36 + 4, v40 + 4, 372, 20, v47);
	v35 = v48;
	sub_2BC80(v9, v34, 372, 2, v48);
	v38 = v49;
	sub_2BC80(v9, v7 + 18, 372, 2, v49);
	sub_2BC80(v9, v34, 2, 18, v35);
	sub_2BC80(v8 + 370, v34, 2, 20, v38);
	sprintf_s(printbuffer, 512, "%s", &v41[48 * v46 + 81]);
	v7 += 2;
	v8 += 6;
	sub_2BC10_draw_text((Bit8u*)printbuffer, v8, v7, v42);
	v10 = 8 * strlen(printbuffer) + v8;
	v11 = v7 + 2;
	if (x_D41A0_BYTEARRAY_4[26] & 8)
		v12 = v43;
	else
		v12 = v47;
	v13 = v11;
	v39 = 0;
	v14 = v10;
	v15 = v40;
	v16 = v36;
	sub_2BC80(v14, v13, 6, 12, v12);
	v17 = v15 + 28;
	v18 = v16 + 4;
	while (v39 < 8)
	{
		//fix it
		/*if ( (unsigned __int8)v41[992] == v39 )
		v19 = **filearray_2aa18c[6] + 930;
	  else
		v19 = **filearray_2aa18c[6] + 948;*/
		v19 = 0;  //fix it
	  //fix it! sub_2BB40_draw_bitmap(v18, v17, v19);
		sprintf_s(printbuffer, 512, "%d", v39 + 1);
		sub_2BC10_draw_text((Bit8u*)printbuffer, v18 + 4, v17 + 2, v44);
		if (++v39 == 4)
		{
			v18 = 4;
			v17 += 20;
		}
		else
		{
			v18 += 16;
		}
	}
	v39 = 0;
	v20 = v36 + 82;
	v21 = v40 + 32;
	while (v39 < 4)
	{
		/*if ( (unsigned __int8)v41[993] == v39 )
		  v22 = **filearray_2aa18c[6] + 936;
		else
		  v22 = **filearray_2aa18c[6] + 954;*/ //fix it
		v22 = 0;  //fix it
	  //fix it! sub_2BB40_draw_bitmap(v20, v21, v22);
		switch (v39)
		{
		case 0:
			v37 = 154;
			break;
		case 1:
			v37 = 153;
			break;
		case 2:
			v37 = 152;
			break;
		case 3:
			v37 = 151;
			break;
		default:
			break;
		}
		//fix it //sub_2BB40_draw_bitmap(v20 + 2, v21 + 2, (Bit8u**)(6 * v37 + **filearray_2aa18c[6]));
		if (++v39 == 3)
			v23 = 20;
		else
			v23 = 2;
		v20 += v23 + 68;
	}
	v50 = v41[993] != 3;
	v39 = 0;
	v24 = v36 + 384;
	v25 = v40 + 26;
	while (v39 < 8)
	{
		if (x_D41A0_BYTEARRAY_4_struct.dwordindex_12 == v39)
			++v39;
		v26 = 1;
		if (!v50 && (1 << v39) & (unsigned __int8)v41[995])
			v26 = 0;
		/*if ( v26 )
		  v27 = **filearray_2aa18c[6] + 960;
		else
		  v27 = **filearray_2aa18c[6] + 942;
		sub_2BB40_draw_bitmap(v24, v25, (Bit8u**)v27);
		sub_2BB40_draw_bitmap(v24 + 2, v25 + 2, (Bit8u**)(6 * (v39 + 74) + **filearray_2aa18c[6]));*/ //fix it
		if (x_WORD_E3760_mousex >= v24
			&& x_WORD_E3760_mousex < v24 + 32
			&& x_WORD_E3762_mousey >= v25
			&& x_WORD_E3762_mousey < v25 + 22)
		{
			v51 = v39;
		}
		v24 += 34;
		++v39;
	}
	v28 = v40 + 4;
	v29 = v36 + 384;
	/*sub_2BB40_draw_bitmap(v36 + 384, v40 + 4, (Bit8u**)(**filearray_2aa18c[6] + 1554));
	sub_2BB40_draw_bitmap(v36 + 474, v28, (Bit8u**)(**filearray_2aa18c[6] + 1566));
	sub_2BB40_draw_bitmap(v36 + 564, v28, (Bit8u**)(**filearray_2aa18c[6] + 1560));*///fix it
	v30 = v40 + 50;
	sub_2BC80(v29, v40 + 50, 236, 18, v47);
	v31 = v48;
	sub_2BC80(v29, v30, 236, 2, v48);
	v38 = v49;
	sub_2BC80(v29, v40 + 66, 236, 2, v49);
	sub_2BC80(v29, v30, 2, 16, v31);
	sub_2BC80(v36 + 618, v30, 2, 18, v38);
	result = v51;
	if (v51 != -1)
		/*result = */sub_2BC10_draw_text((Bit8u*)(2124 * v51 + x_D41A0_BYTEARRAY_0 + 11230 + 927), v36 + 390, v40 + 52, v45);
	if (x_WORD_1805C2 == 8
		|| x_WORD_1805C2 == 12
		|| x_WORD_1805C2 == 13
		|| x_WORD_1805C2 == 4
		|| x_WORD_1805C2 == 6
		|| x_WORD_1805C2 == 11
		|| x_WORD_1805C2 == 5)
	{
		//fix it result = sub_2BB40_draw_bitmap(x_DWORD_1805B0, x_DWORD_1805B4, (Bit8u**)(**filearray_2aa18c[0] + 6 * (unsigned __int8)x_BYTE_D419E));
	}
	return result;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// D419E: using guessed type char x_BYTE_D419E;
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// E3760: using guessed type int x_DWORD_E3760;
// E89F0: using guessed type char x_BYTE_E89F0;
// E9800: using guessed type char x_BYTE_E9800;
// E98FF: using guessed type char x_BYTE_E98FF;
// EA3DC: using guessed type int **filearray_2aa18c[6];
// EB394: using guessed type int **filearray_2aa18c[0];
// 1805B0: using guessed type int x_DWORD_1805B0;
// 1805B4: using guessed type int x_DWORD_1805B4;
// 1805C2: using guessed type __int16 x_WORD_1805C2;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0002FD90) --------------------------------------------------------
char sub_2FD90()
{
	char result; // al
	signed int v1; // ebx
	signed int v2; // ebx
	signed int v3; // ebx
	int v4; // [esp+0h] [ebp-14h]
	int v5; // [esp+4h] [ebp-10h]
	int v6; // [esp+8h] [ebp-Ch]
	int v7; // [esp+Ch] [ebp-8h]
	unsigned __int8 v8; // [esp+10h] [ebp-4h]

	v8 = (unsigned __int8)*xadataclrd0dat.var28_begin_buffer;
	result = (char)x_D41A0_BYTEARRAY_4;
	if (x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 1)
	{
		if (!x_D41A0_BYTEARRAY_4[0xCE])
		{
			sub_2FFE0(&v6, &v7, &v5, &v4);
			/*sub_2BB40_draw_bitmap(v6, v7, (Bit8u**)(**filearray_2aa18c[6] + 1044));
			v7 += v4;
			sub_2BB40_draw_bitmap(v6, v7, (Bit8u**)(**filearray_2aa18c[6] + 1050));*/ //fix it
			if (!x_D41A0_BYTEARRAY_4[0xD0])
			{
				v1 = 0;
				while (v1 < 2)
				{
					++v1;
					sub_2E790(v6, (signed __int16)v7, (signed __int16)(v5 - 2), (signed __int16)v4, v8);
				}
			}
			v7 += v4;
			//fix it sub_2BB40_draw_bitmap(v6, v7, (Bit8u**)(**filearray_2aa18c[6] + 1056));
			if (!x_BYTE_E3798_sound_active2)
			{
				v2 = 0;
				while (v2 < 2)
				{
					++v2;
					/*sub_2E790(
					  v6,
					  (signed __int16)v7,
					  *(unsigned __int8 *)(**filearray_2aa18c[6] + 1060),
					  *(unsigned __int8 *)(**filearray_2aa18c[6] + 1061),
					  v8);*/ //fix it
				}
			}
			//fix it //sub_2BB40_draw_bitmap(v6 + *(unsigned __int8 *)(**filearray_2aa18c[6] + 1060), v7, (Bit8u**)(**filearray_2aa18c[6] + 1062));
			if (!x_BYTE_E37FC)
			{
				v3 = 0;
				while (v3 < 2)
				{
					++v3;
					/*sub_2E790(
					  v6 + *(unsigned __int8 *)(**filearray_2aa18c[6] + 1060),
					  (signed __int16)v7,
					  *(unsigned __int8 *)(**filearray_2aa18c[6] + 1066),
					  *(unsigned __int8 *)(**filearray_2aa18c[6] + 1067),
					  v8);*/ //fix it
				}
			}
			v7 += v4;
			//fix it sub_2BB40_draw_bitmap(v6, v7, (Bit8u**)(**filearray_2aa18c[6] + 1068));
		}
		if (x_WORD_1805C2 == 8
			|| x_WORD_1805C2 == 12
			|| x_WORD_1805C2 == 13
			|| x_WORD_1805C2 == 4
			|| x_WORD_1805C2 == 6
			|| x_WORD_1805C2 == 11
			|| x_WORD_1805C2 == 5)
		{
			//fix it //sub_2BB40_draw_bitmap(x_DWORD_1805B0, x_DWORD_1805B4, (Bit8u**)(**filearray_2aa18c[0] + 6 * (unsigned __int8)x_BYTE_D419E));
		}
		result = (char)x_D41A0_BYTEARRAY_4;
		if (x_D41A0_BYTEARRAY_4_struct.setting_byte4_25 & 0x10)
			result = sub_30870();
	}
	return result;
}
// D419E: using guessed type char x_BYTE_D419E;
// D41A4: using guessed type int x_DWORD_D41A4;
// E3798: using guessed type char x_BYTE_E3798_sound_active2;
// E37FC: using guessed type char x_BYTE_E37FC;
// EA3DC: using guessed type int **filearray_2aa18c[6];
// EB394: using guessed type int **filearray_2aa18c[0];
// 1805B0: using guessed type int x_DWORD_1805B0;
// 1805B4: using guessed type int x_DWORD_1805B4;
// 1805C2: using guessed type __int16 x_WORD_1805C2;

//----- (0002FFE0) --------------------------------------------------------
int *sub_2FFE0(int *a1, int *a2, x_DWORD *a3, x_DWORD *a4)
{
	int v4; // eax
	int v5; // eax
	int v6; // ebx
	int v7; // eax
	int *result; // eax

	/* fix it v4 = **filearray_2aa18c[6];
	*a3 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 1048) + 2;*/
	v4 = 0;  //fix it
	v5 = *(unsigned __int8 *)(v4 + 1049);
	*a4 = v5;
	v6 = (400 - 4 * v5) / 2 - 60;
	v7 = (640 - *a3) / 2;
	LOBYTE(v7) = v7 & 0xFE;
	*a1 = v7;
	result = a2;
	LOBYTE(v6) = v6 & 0xFE;
	*a2 = v6;
	return result;
}
// EA3DC: using guessed type int **filearray_2aa18c[6];

//----- (00030050) --------------------------------------------------------
void sub_30050()
{
	signed int v0; // esi
	int v1; // edx
	int v2; // ebx
	int v3; // eax
	int v4; // eax
	//int v5; // ecx
	//int v6; // edi
	unsigned __int8 v7; // dl
	int v8; // ebx
	int v9; // esi
	int v10; // edi
	int v11; // eax
	unsigned __int8 v12; // dl
	//int result; // eax
	int v14; // [esp+0h] [ebp-20h]
	int v15; // [esp+4h] [ebp-1Ch]
	//int v16; // [esp+8h] [ebp-18h]
	//int v17; // [esp+Ch] [ebp-14h]
	char *v18; // [esp+10h] [ebp-10h]
	int v19; // [esp+14h] [ebp-Ch]
	//int v20; // [esp+18h] [ebp-8h]
	int v21; // [esp+1Ch] [ebp-4h]

	//fix
	v9 = 0;
	v10 = 0;
	//fix

	v0 = 67;
	v1 = 0;
	v2 = (640 - x_D41A0_BYTEARRAY_4[0xBA]) / 2;
	while (1)
	{
		v21 = v1;
		if (v1 >= 17)
			break;
		sub_1A5B0(v21 + 1, &v15, &v14);
		v19 = 1 << v21;
		if ((1 << v21) & x_D41A0_BYTEARRAY_4[0xC0] && (1 << v21) & x_D41A0_BYTEARRAY_4[188])
			v3 = v15;
		else
			v3 = v14;
		v18 = (char *)x_DWORD_E9C4C_langindexbuffer[v3];
		v4 = x_D41A0_BYTEARRAY_4[0xBA];
		/* fix it    v16 = v2 + *(unsigned __int8 *)(**filearray_2aa18c[6] + 1012);
			v5 = v2 + v4 - *(unsigned __int8 *)(**filearray_2aa18c[6] + 1024);
			v17 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 1018);
			v20 = v5;
			sub_2BB40_draw_bitmap(v2, v0, (Bit8u**)(**filearray_2aa18c[6] + 1008));
			v6 = v16;
			sub_2BB40_draw_bitmap(v20, v0, (Bit8u**)(**filearray_2aa18c[6] + 1020));
			while ( v6 < v20 )
			{
			  sub_2BB40_draw_bitmap(v6, v0, (Bit8u**)(**filearray_2aa18c[6] + 1014));
			  v6 += v17;
			}*/
		if (v19 & x_D41A0_BYTEARRAY_4[0xC0])
		{
			if (v2 > x_DWORD_1805B0
				|| v2 + x_D41A0_BYTEARRAY_4[0xBA] <= x_DWORD_1805B0
				|| v0 > x_DWORD_1805B4
				|| v0 + 18 <= x_DWORD_1805B4)
			{
				v7 = x_BYTE_E98FF;
			}
			else
			{
				v7 = x_BYTE_E9800;
			}
		}
		else
		{
			v7 = x_BYTE_E9188;
		}
		sub_2BC10_draw_text((Bit8u*)v18, v2 + ((x_D41A0_BYTEARRAY_4[0xBA] - 8 * strlen(v18)) >> 1), v0 + 2, v7);
		v0 += 18;
		v1 = v21 + 1;
	}
	v8 = (x_D41A0_BYTEARRAY_4[0xBA] - 82) / 2 + (640 - x_D41A0_BYTEARRAY_4[0xBA]) / 2;
	/* fix it v16 = v8 + *(unsigned __int8 *)(**filearray_2aa18c[6] + 1012);
	v9 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 1018);
	v20 = v8 + 82 - *(unsigned __int8 *)(**filearray_2aa18c[6] + 1024);
	sub_2BB40_draw_bitmap(v8, 377, (Bit8u**)(**filearray_2aa18c[6] + 1008));
	v10 = v16;
	sub_2BB40_draw_bitmap(v20, 377, (Bit8u**)(**filearray_2aa18c[6] + 1020));
	while ( v10 < v20 )
	{
	  sub_2BB40_draw_bitmap(v10, 377, (Bit8u**)(**filearray_2aa18c[6] + 1014));
	  v10 += v9;
	}*/
	v11 = (640 - x_D41A0_BYTEARRAY_4[0xBA]) / 2 + (x_D41A0_BYTEARRAY_4[0xBA] - 82) / 2;
	if (v11 > x_DWORD_1805B0 || v11 + 82 <= x_DWORD_1805B0 || x_DWORD_1805B4 < 377 || x_DWORD_1805B4 >= 395)
		v12 = x_BYTE_E98FF;
	else
		v12 = x_BYTE_E9800;
	/*result = */sub_2BC10_draw_text(
		(Bit8u*)"OK",
		(640 - x_D41A0_BYTEARRAY_4[0xBA]) / 2 + (x_D41A0_BYTEARRAY_4[0xBA] - 82) / 2 + 33,
		379,
		v12);
	if (x_WORD_1805C2 == 8
		|| x_WORD_1805C2 == 12
		|| x_WORD_1805C2 == 13
		|| x_WORD_1805C2 == 4
		|| x_WORD_1805C2 == 6
		|| x_WORD_1805C2 == 11
		|| x_WORD_1805C2 == 5)
	{
		// fix it result = sub_2BB40_draw_bitmap(x_DWORD_1805B0, x_DWORD_1805B4, (Bit8u**)(6 * (unsigned __int8)x_BYTE_D419E + **filearray_2aa18c[0]));
	}
	//return result;
}
// D419E: using guessed type char x_BYTE_D419E;
// D41A4: using guessed type int x_DWORD_D41A4;
// E9188: using guessed type char x_BYTE_E9188;
// E9800: using guessed type char x_BYTE_E9800;
// E98FF: using guessed type char x_BYTE_E98FF;
// EA3DC: using guessed type int **filearray_2aa18c[6];
// EB394: using guessed type int **filearray_2aa18c[0];
// 1805B0: using guessed type int x_DWORD_1805B0;
// 1805B4: using guessed type int x_DWORD_1805B4;
// 1805C2: using guessed type __int16 x_WORD_1805C2;

//----- (000303D0) --------------------------------------------------------
void sub_303D0(signed int a1)
{
	int v1; // edx
	unsigned __int8 v2; // bh
	unsigned __int8 v3; // bl
	unsigned __int8 v4; // al
	int v5; // eax
	unsigned __int8 v6; // si
	int v7; // ebx
	int v9; // [esp+0h] [ebp-1Ch]
	int v10; // [esp+4h] [ebp-18h]
	int v11; // [esp+8h] [ebp-14h]
	int v12; // [esp+Ch] [ebp-10h]
	int v13; // [esp+10h] [ebp-Ch]
	int v14; // [esp+14h] [ebp-8h]
	unsigned __int8 v15; // [esp+18h] [ebp-4h]

	v1 = *(unsigned __int8 *)(x_D41A0_BYTEARRAY_0 + 196308);
	v2 = x_BYTE_D94F0[5 * v1];
	v3 = x_BYTE_D94F2[5 * v1];
	v15 = x_BYTE_D94F3[5 * v1];
	sub_2FFE0(&v12, &v11, &v10, &v9);
	v4 = x_D41A0_BYTEARRAY_4[0x96BF];
	if (v4 >= 1u)
	{
		if (v4 <= 1u)
		{
			v5 = x_D41A0_BYTEARRAY_4_struct.dwordindex_6;
		}
		else
		{
			if (v4 != 2)
				goto LABEL_8;
			v5 = x_D41A0_BYTEARRAY_4_struct.dwordindex_8;
		}
		a1 = 127;
		v14 = v5;
	}
LABEL_8:
	v10 -= 2;
	v13 = v2;
	v11 += 4 * v9;
	sub_2BC80(v12, v11, v10, 24, v2);
	sub_2BC80(v12, v11, v10, 2, v3);
	v6 = v15;
	sub_2BC80(v12, v11 + 22, v10, 2, v15);
	sub_2BC80(v12, v11, 2, 22, v3);
	sub_2BC80(v10 + v12 - 2, v11, 2, 24, v6);
	sub_2BC80(v12 + 4, v11 + 4, v10 - 8, 16, v13);
	sub_2BC80(v12 + 4, v11 + 4, v10 - 8, 2, v6);
	sub_2BC80(v12 + 4, v11 + 18, v10 - 8, 2, v3);
	sub_2BC80(v12 + 4, v11 + 4, 2, 14, v6);
	sub_2BC80(v12 + 4 + v10 - 8 - 2, v11 + 4, 2, 16, v3);
	v7 = v14 * (v10 - 12) / a1;
	v11 += 6;
	v12 += 6;
	sub_2BC80(v12, v11, v10 - 12, 12, (unsigned __int8)*xadataclrd0dat.var28_begin_buffer);
	sub_2BC80(v12, v11, v7, 12, x_BYTE_E89F0);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// E89F0: using guessed type char x_BYTE_E89F0;

//----- (00030630) --------------------------------------------------------
int sub_30630()
{
	char v0; // dl
	int result; // eax
	unsigned __int16 v2; // cx
	int v3; // edx
	int v4; // edx
	const char *v5; // ebx
	__int16 v6; // [esp+0h] [ebp-34h]
	__int16 v7; // [esp+2h] [ebp-32h]
	__int16 v8; // [esp+Ch] [ebp-28h]
	__int16 v9; // [esp+Eh] [ebp-26h]
	__int16 v10; // [esp+10h] [ebp-24h]
	__int16 v11; // [esp+12h] [ebp-22h]
	__int16 v12; // [esp+14h] [ebp-20h]
	__int16 v13; // [esp+16h] [ebp-1Eh]
	__int16 v14; // [esp+18h] [ebp-1Ch]
	__int16 v15; // [esp+1Ah] [ebp-1Ah]
	__int16 v16; // [esp+24h] [ebp-10h]
	__int16 v17; // [esp+26h] [ebp-Eh]
	__int16 v18; // [esp+28h] [ebp-Ch]
	__int16 v19; // [esp+2Ah] [ebp-Ah]
	char v20; // [esp+30h] [ebp-4h]
	unsigned __int8 v21; // [esp+31h] [ebp-3h]

	// fix if begin
	v16 = 0;
	v17 = 0;
	v18 = 0;
	v19 = 0;
	// end

	v0 = x_D41A0_BYTEARRAY_4_struct.setting_byte1_22;
	result = 0;
	if (!(v0 & 0x10) && !(v0 & 0x20))
	{
		if (x_D41A0_BYTEARRAY_4[0x17] & 2)
		{
			v4 = 11 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
			if (x_D41A0_BYTEARRAY_0[0x3659C + v4])
				result = (unsigned __int8)x_BYTE_DB526;
			else
				result = (unsigned __int8)x_BYTE_DB520[x_D41A0_BYTEARRAY_0[0x3659D + v4]];
		}
		else if (*(0x36E09 + x_D41A0_BYTEARRAY_0 + 2) & 1)
		{
			result = (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 12226) != 0) + 284;
		}
		else
		{
			v2 = x_D41A0_BYTEARRAY_4_struct.levelnumber_43;
			if (v2 >= 0x1Eu && v2 <= 0x22u)
			{
				if (x_D41A0_BYTEARRAY_0[0x3659C + 11 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12])
					result = (unsigned __int8)x_BYTE_DB511;
				else
					result = (unsigned __int8)x_BYTE_DB4EE[0] + 3;
			}
			else if (x_D41A0_BYTEARRAY_4[38545] & 0x20
				&& !x_D41A0_BYTEARRAY_0[0x3659D + 11 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12])
			{
				*(0x36E03 + x_D41A0_BYTEARRAY_0 + 1) = 0;
			}
			else
			{
				v3 = 11 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
				if (x_D41A0_BYTEARRAY_0[0x3659C + v3])
					result = (unsigned __int8)x_BYTE_DB507[x_D41A0_BYTEARRAY_4_struct.levelnumber_43];
				else
					result = x_D41A0_BYTEARRAY_0[0x3659D + v3]
					+ (unsigned __int8)x_BYTE_DB4EE[x_D41A0_BYTEARRAY_4_struct.levelnumber_43];
			}
		}
		if (result)
		{
			v5 = (const char *)x_DWORD_E9C4C_langindexbuffer[result];
			v10 = 8;
			v9 = 400;
			v12 = 40;
			v13 = 600;
			v11 = 14;
			v15 = 260;
			v20 = x_BYTE_E9800;
			v14 = 80;
			v21 = (unsigned __int8)*xadataclrd0dat.var28_begin_buffer;
			v6 = 320;
			v7 = 300;
			v8 = 320;
			sub_89420(&v6, v5);
			sub_89520(&v6);
			sub_89980(&v6);
			sub_2E790(v16, v17, v18, v19, v21);
			sub_895D0((int)&v6, v5);
			result = sub_89690(&v6);
		}
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// DB511: using guessed type char x_BYTE_DB511;
// DB526: using guessed type char x_BYTE_DB526;
// E9800: using guessed type char x_BYTE_E9800;

//----- (00030870) --------------------------------------------------------
char sub_30870()
{
	const char *v0; // ebx
	__int16 v1; // ax
	//char v3; // [esp+0h] [ebp-32h]
	__int16 v4; // [esp+80h] [ebp+4Eh]
	__int16 v5; // [esp+82h] [ebp+50h]
	__int16 v6; // [esp+8Ch] [ebp+5Ah]
	__int16 v7; // [esp+8Eh] [ebp+5Ch]
	__int16 v8; // [esp+90h] [ebp+5Eh]
	__int16 v9; // [esp+92h] [ebp+60h]
	__int16 v10; // [esp+94h] [ebp+62h]
	__int16 v11; // [esp+96h] [ebp+64h]
	__int16 v12; // [esp+98h] [ebp+66h]
	__int16 v13; // [esp+9Ah] [ebp+68h]
	char v14; // [esp+B0h] [ebp+7Eh]
	char v15; // [esp+B1h] [ebp+7Fh]

	sub_2BC80(4, 286, 632, 190, 0);
	sprintf_s(printbuffer, 512, "%d", x_WORD_D41D4);
	sub_2BC10_draw_text((Bit8u*)printbuffer, 10, 300, x_BYTE_E98FF);
	v7 = 400;
	v10 = 4;
	v8 = 8;
	v9 = 14;
	v11 = 636;
	v0 = (const char *)x_DWORD_E9C4C_langindexbuffer[x_WORD_D41D4];
	v6 = 600;
	v4 = 320;
	v14 = x_BYTE_E9800;
	v15 = (unsigned __int8)*xadataclrd0dat.var28_begin_buffer;
	v12 = 310;
	v13 = 630;
	v5 = 310;
	sub_89420(&v4, v0);
	sub_89520(&v4);
	sub_89980(&v4);
	LOBYTE(v1) = sub_895D0((int)&v4, v0);
	switch (x_BYTE_1806E4)
	{
	case 72:
		if (++x_WORD_D41D4 < 1)
			x_WORD_D41D4 = 1;
		if (x_WORD_D41D4 > 470)
			x_WORD_D41D4 = 470;
		x_BYTE_1806E4 = 0;
		break;
	case 80:
		v1 = x_WORD_D41D4 - 1;
		x_WORD_D41D4 = v1;
		if (v1 < 1)
			x_WORD_D41D4 = 1;
		if (x_WORD_D41D4 > 470)
			x_WORD_D41D4 = 470;
		x_BYTE_1806E4 = 0;
		break;
	case 75:
		x_WORD_D41D4 = 1;
		x_BYTE_1806E4 = 0;
		break;
	case 77:
		x_WORD_D41D4 = 470;
		LOBYTE(v1) = 0;
		x_BYTE_1806E4 = 0;
		break;
	}
	return v1;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// D41D4: using guessed type __int16 x_WORD_D41D4;
// E9800: using guessed type char x_BYTE_E9800;
// E98FF: using guessed type char x_BYTE_E98FF;
// 1806E4: using guessed type char x_BYTE_1806E4;

//----- (00030A60) --------------------------------------------------------
int sub_30A60(__int16 a1, __int16 a2)
{
	int result; // eax
	unsigned __int8 v3; // dl
	__int64 v4; // rax
	//char v5; // [esp+0h] [ebp-Eh]
	int v6; // [esp+80h] [ebp+72h]
	int v7; // [esp+84h] [ebp+76h]

	v7 = a1;
	v6 = a2;
	result = (int)x_D41A0_BYTEARRAY_4;
	v3 = x_D41A0_BYTEARRAY_4[0x9692];
	if (v3)
	{
		if (v3 < 2u)
		{
			if (v3 == 1)
				sprintf_s(printbuffer, 512, "%s?", x_DWORD_E9C4C_langindexbuffer[2]);
		}
		else if (v3 <= 2u)
		{
			sprintf_s(printbuffer, 512, "%s?", x_DWORD_E9C4C_langindexbuffer[423]);
		}
		else if (v3 == 3)
		{
			sprintf_s(printbuffer, 512, "%s?", x_DWORD_E9C4C_langindexbuffer[424]);
		}
		v4 = 4080 * x_D41A0_BYTEARRAY_4[0x7D];
		sub_2BC10_draw_text((Bit8u*)printbuffer, v7, v6, (*xadataclrd0dat.var28_begin_buffer)[256 * ((signed int)(v4 - (__CFSHL__(HIDWORD(v4), 8) + (HIDWORD(v4) << 8))) >> 8)]);
		sub_30BE0(&v7, &v6);
		/* fix it //sub_2BB40_draw_bitmap(v7, v6, (Bit8u**)(**filearray_2aa18c[6] + 1542));
		result = sub_2BB40_draw_bitmap(v7 + 50, v6, (Bit8u**)(**filearray_2aa18c[6] + 1548));*/
		if (x_WORD_1805C2 == 8
			|| x_WORD_1805C2 == 12
			|| x_WORD_1805C2 == 13
			|| x_WORD_1805C2 == 4
			|| x_WORD_1805C2 == 6
			|| x_WORD_1805C2 == 11
			|| x_WORD_1805C2 == 5)
		{
			//fix it result = sub_2BB40_draw_bitmap(x_DWORD_1805B0, x_DWORD_1805B4, (Bit8u**)(6 * (unsigned __int8)x_BYTE_D419E + **filearray_2aa18c[0]));
		}
	}
	return result;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// D419E: using guessed type char x_BYTE_D419E;
// D41A4: using guessed type int x_DWORD_D41A4;
// E9C54: using guessed type int x_DWORD_E9C54;
// EA2E8: using guessed type int x_DWORD_EA2E8;
// EA2EC: using guessed type int x_DWORD_EA2EC;
// EA3DC: using guessed type int **filearray_2aa18c[6];
// EB394: using guessed type int **filearray_2aa18c[0];
// 1805B0: using guessed type int x_DWORD_1805B0;
// 1805B4: using guessed type int x_DWORD_1805B4;
// 1805C2: using guessed type __int16 x_WORD_1805C2;

//----- (00030BE0) --------------------------------------------------------
x_DWORD *sub_30BE0(x_DWORD *a1, x_DWORD *a2)
{
	x_DWORD *result; // eax

	*a1 = 270;
	result = a2;
	*a2 = 104;
	return result;
}

//----- (00030D50) --------------------------------------------------------
void sub_30D50(int a1)
{
	int v1; // eax
	char v2; // dl
	signed int v3; // esi
	char v4; // cl
	char v5; // ch
	__int16 v6; // ax
	Bit8u* v7; // eax
	int v8; // edi
	int v9; // esi
	unsigned __int16 v10; // [esp+0h] [ebp-4h]

	// fix if begin
	v2 = 0;
	v4 = 0;
	// end

	if (*(x_BYTE *)(a1 + 16) & 3)
	{
		--*(x_DWORD *)(a1 + 16);
	}
	else
	{
		v1 = *(x_DWORD *)(a1 + 8);
		*(x_DWORD *)(a1 + 8) = v1 - 1;
		if (v1 >= 0)
		{
			*(x_BYTE *)(a1 + 12) &= 0xFEu;
			v3 = (signed __int16)sub_10C40((__int16 *)(a1 + 76));
			if (!(*(x_BYTE *)(a1 + 12) & 2))
			{
				LOBYTE(v10) = (unsigned __int16)(*(x_WORD *)(a1 + 76) + 128) >> 8;
				v4 = *(x_BYTE *)(a1 + 14);
				HIBYTE(v10) = (unsigned __int16)(*(x_WORD *)(a1 + 78) + 128) >> 8;
				if (!(v4 & 1))
					sub_10C80(a1, 0, *(x_WORD *)(a1 + 42));
				v5 = x_BYTE_10B4E0[v10];
				if (v5)
				{
					switch (v5)
					{
					case 26:
						sub_45DC0(v2, v4, v10, 0x14u);
						break;
					case 10:
						sub_45DC0(v2, v4, v10, 0x15u);
						break;
					case 11:
						sub_45DC0(v2, v4, v10, 0x16u);
						break;
					default:
						if (((unsigned __int8)v5 < 6u || (unsigned __int8)v5 > 0x22u)
							&& (x_BYTE_13B4E0[v10] & 7) != 1
							&& *(signed __int16 *)(a1 + 80) - v3 <= 128
							&& !(sub_104A0(a1 + 76) & 1))
						{
							*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
							sub_572C0((signed __int16 *)a1, 0, 0, 0 - (*(unsigned __int16 *)(a1 + 20) % 7u), 1);
						}
						break;
					}
				}
				v6 = 9377 * *(x_WORD *)(a1 + 20);
				*(x_BYTE *)(a1 + 12) |= 2u;
				*(x_WORD *)(a1 + 20) = v6 + 9439;
				v7 = x_D41A0_BYTEARRAY_0 + 28302;
				*(x_WORD *)(a1 + 44) = *(x_WORD *)(a1 + 20) % 0x41u - 32;
				sub_6E450((a1 - (int)v7) / 168, -1, 3);
			}
			sub_580E0(a1 + 76, v3, 0, 0, *(x_WORD *)(a1 + 44));
			if (x_BYTE_D41B6)
			{
				v8 = *(signed __int16 *)(a1 + 88);
				v9 = (signed __int16)sub_10C60((__int16 *)(a1 + 76)) - v8;
				if (*(signed __int16 *)(a1 + 80) > v9)
					*(x_WORD *)(a1 + 80) = v9;
			}
			sub_585A0(a1);
		}
		else
		{
			sub_57F10(a1);
		}
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41B6: using guessed type char x_BYTE_D41B6;

//----- (00030F60) --------------------------------------------------------
void sub_30F60(int a1)
{
	int v1; // eax
	int result; // eax
	Bit8u* v3; // eax
	int v4; // esi
	int v5; // eax
	unsigned int v6; // edx
	__int16 v7; // [esp+0h] [ebp-10h]
	__int16 v8; // [esp+2h] [ebp-Eh]
	__int16 v9; // [esp+4h] [ebp-Ch]
	int v10; // [esp+8h] [ebp-8h]
	int v11; // [esp+Ch] [ebp-4h]

	v1 = *(x_DWORD *)(a1 + 8);
	*(x_DWORD *)(a1 + 8) = v1 - 1;
	if (v1 < 0)
	{
		sub_57F10(a1);
		return;
	}
	if (!(*(x_BYTE *)(a1 + 12) & 2))
	{
		v3 = x_D41A0_BYTEARRAY_0 + 28302;
		*(x_BYTE *)(a1 + 12) |= 2u;
		sub_6E450((a1 - (int)v3) / 168, -1, 3);
	}
	v4 = sub_10080(*(x_DWORD *)(a1 + 16), *(x_DWORD *)(a1 + 16));
	//v4 = result;
	if (v4)
	{
		while (sub_10130(v4, &v11, &v10) == 1)
		{
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			if (2 * ((signed int)(*(unsigned __int16 *)(a1 + 20) % 0x9Du) / 79) - 1 > 0)
			{
				*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
				v7 = *(x_WORD *)(a1 + 76) - 96 + 192 * v11 + *(x_WORD *)(a1 + 20) % 0x81u - 64;
				*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
				v8 = *(x_WORD *)(a1 + 78) - 96 + 192 * v10 + *(x_WORD *)(a1 + 20) % 0x81u - 64;
				v9 = *(x_WORD *)(a1 + 80);
				v5 = sub_4A190((int)&v7, 10, 0);
				if (v5)
				{
					*(x_WORD *)(v5 + 26) = *(x_WORD *)(a1 + 26);
					*(x_WORD *)(v5 + 28) = *(x_WORD *)(a1 + 28);
					v6 = (unsigned int)sub_10000 & *(x_DWORD *)(a1 + 12);
					LOBYTE(v6) = v6 | 0x80;
					*(x_DWORD *)(v5 + 12) |= v6;
				}
			}
		}
		sub_10100(v4);
	}
	//return result;
}
// 10000: using guessed type void /*__noreturn*/ sub_10000();
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00031100) --------------------------------------------------------
void sub_31100(int a1)
{
	int v1; // eax

	v1 = *(x_DWORD *)(a1 + 8);
	*(x_DWORD *)(a1 + 8) = v1 - 1;
	if (v1 < 0)
		sub_57F10(a1);
	//return result;
}

//----- (00031120) --------------------------------------------------------
void sub_31120(int a1)
{
	int result; // eax
	int v2; // edx
	int v3; // eax
	char v4; // [esp+0h] [ebp-4h]

	v4 = 0;
	result = sub_10C40((__int16 *)(a1 + 76));
	if ((x_WORD)result != *(x_WORD *)(a1 + 80))
		goto LABEL_12;
	if (*(x_DWORD *)(a1 + 4) - 5 == *(x_DWORD *)(a1 + 8))
	{
		sub_4A190(a1 + 76, 10, 87);
		v2 = (int)x_D41A0_BYTEARRAY_0;
		v3 = 9377 * *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8) + 9439;
		*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8) = v3;
		if (!(v3 & 1))
			sub_6E450((a1 - (v2 + 28302)) / 168, -1, *(x_WORD *)(a1 + 90) - 282);
	}
	result = *(x_DWORD *)(a1 + 8);
	*(x_DWORD *)(a1 + 8) = result - 1;
	if (result < 0)
		LABEL_12:
	v4 = 1;
	else
		sub_585A0(a1);
	if (v4)
		sub_57F10(a1);
	//return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (000311E0) --------------------------------------------------------
void sub_311E0(int a1)
{
	unsigned int v1; // eax
	int v2; // eax
	unsigned __int8 v3; // dl
	__int16 v4; // di
	__int16 v5; // si
	__int16 v6; // ax
	signed int v7; // edi
	char v8; // al
	char v9; // al
	signed int v10; // eax
	int v11; // eax
	int v12; // esi
	int v13; // eax
	unsigned int j; // esi
	signed int v15; // eax
	signed int v16; // ecx
	signed int v17; // eax
	signed int v18; // edx
	int v19; // ecx
	int v20; // edx
	int v21; // eax
	unsigned __int8 v22; // dh
	char v23; // cl
	int v24; // eax
	unsigned __int16 v25; // dx
	__int16 v26; // si
	__int16 v28; // [esp+0h] [ebp-50h]
	__int16 v29; // [esp+2h] [ebp-4Eh]
	int v30; // [esp+8h] [ebp-48h]
	unsigned int v31; // [esp+Ch] [ebp-44h]
	int v32; // [esp+10h] [ebp-40h]
	int v33; // [esp+14h] [ebp-3Ch]
	int v34; // [esp+18h] [ebp-38h]
	int v35; // [esp+1Ch] [ebp-34h]
	int v36; // [esp+20h] [ebp-30h]
	int k; // [esp+24h] [ebp-2Ch]
	int v38; // [esp+28h] [ebp-28h]
	int v39; // [esp+2Ch] [ebp-24h]
	int v40; // [esp+30h] [ebp-20h]
	int v41; // [esp+34h] [ebp-1Ch]
	int v42; // [esp+38h] [ebp-18h]
	int v43; // [esp+3Ch] [ebp-14h]
	int v44; // [esp+40h] [ebp-10h]
	int v45; // [esp+44h] [ebp-Ch]
	int v46; // [esp+48h] [ebp-8h]
	unsigned __int16 i; // [esp+4Ch] [ebp-4h]

	v1 = *(x_DWORD *)(a1 + 4);
	if (v1 < 1)
		goto LABEL_78;
	if (v1 <= 1)
	{
		v39 = 5;
		goto LABEL_8;
	}
	if (v1 == 2)
		v39 = 7;
	else
		LABEL_78:
	v39 = 3;
LABEL_8:
	v36 = v39 + 12;
	LOBYTE(v2) = *(x_BYTE *)(a1 + 70);
	if ((unsigned __int8)v2 < 2u)
	{
		if ((x_BYTE)v2)
		{
			return;
		}
		v3 = ((unsigned __int16)(*(x_WORD *)(a1 + 76) + 128) >> 8) - v36;
		BYTE1(v46) = ((unsigned __int16)(*(x_WORD *)(a1 + 78) + 128) >> 8) - v36;
		v4 = BYTE1(v46);
		v5 = v3;
		LOBYTE(v46) = v3;
		*(x_WORD *)(a1 + 80) = sub_48EF0(v3, BYTE1(v46), 2 * v36, 2 * v36);
		v6 = sub_48E60(v5, v4, 2 * v36, 2 * v36);
		*(x_DWORD *)(a1 + 8) = 40;
		*(x_WORD *)(a1 + 44) = 227;
		*(x_WORD *)(a1 + 54) = 0;
		*(x_BYTE *)(a1 + 70) = 2;
		*(x_WORD *)(a1 + 158) = v6;
	}
	else if ((unsigned __int8)v2 > 2u)
	{
		if ((x_BYTE)v2 == 3)
			sub_57F10(a1);
		return;
	}
	v32 = *(signed __int16 *)(a1 + 80);
	v42 = *(signed __int16 *)(a1 + 158);
	v33 = 0;
	v44 = v32 - v42;
	v35 = 0;
	v7 = *(signed __int16 *)(a1 + 44);
	LOBYTE(v2) = v39;
	v44 = ((v32 - v42) >> 1) + v32 - v42;
	v38 = v39;
	while (v33 < 6)
	{
		v43 = v35 - 1024;
		if (v35 - 1024 < 0)
			v43 = 0;
		if (v36 << 8 < v43)
			v43 = v36 << 8;
		v35 = v38 << 8;
		LOBYTE(v2) = 2 * v38;
		v41 = 2 * v38;
		if (v7 > 0 && v7 <= 512)
		{
			v8 = ((unsigned __int16)(*(x_WORD *)(a1 + 78) + 128) >> 8) - v38;
			LOBYTE(v46) = ((unsigned __int16)(*(x_WORD *)(a1 + 76) + 128) >> 8) - v38;
			BYTE1(v46) = v8;
			v34 = 0;
			for (i = v46; ; ++HIBYTE(i))
			{
				LOBYTE(v2) = v34;
				if (v34 >= v41)
					break;
				v40 = 0;
				v9 = v46;
				while (1)
				{
					LOBYTE(i) = v9;
					if (v40 >= v41)
						break;
					v28 = (unsigned __int8)i << 8;
					v29 = HIBYTE(i) << 8;
					v10 = sub_58490((x_WORD *)(a1 + 76), &v28);
					if (v10 < v35 && v10 >= v43)
					{
						v11 = (v44 * ((x_DWORD)((x_DWORD)sub_10000 + (signed int)off_DBF50[(v10 << 10) / v35]) >> 1) >> 16)
							* ((char *)sub_10000 - (char *)off_DBF50[v7]);
						v12 = v11 >> 16;
						v45 = (v11 >> 18) + v42;
						if (x_BYTE_11B4E0[i] < v45)
							sub_570F0(i, HIBYTE(i), v45, 0, 1, 1);
						v13 = x_BYTE_14B4E0[i];
						v45 = v32 - v12;
						if (v32 - v12 < 0)
							v45 = 0;
						if (v13 > v45)
							x_BYTE_14B4E0[i] = v45;
						for (j = x_D41A0_BYTEARRAY_4[0x9677]; j > x_DWORD_EA3E4[0]; j = *(x_DWORD *)j)
						{
							if (!*(x_BYTE *)(j + 64))
							{
								v15 = abs(v28 - *(signed __int16 *)(j + 76));
								v16 = v15;
								if (v15 >= 0x8000)
									v16 = abs(v15 - (x_DWORD)sub_10000);
								v17 = abs(v29 - *(signed __int16 *)(j + 78));
								v18 = v17;
								if (v17 >= 0x8000)
									v18 = abs(v17 - (x_DWORD)sub_10000);
								v19 = v16 * v16;
								v20 = v18 * v18;
								if (v19 + v20 <= (signed int)&loc_64000)
								{
									v31 = sub_7277A((unsigned int)((char *)&loc_64000 - v19 - v20)) >> 5;
									v30 = *(signed __int16 *)(j + 80) >> 5;
									v45 = v30 - v31;
									if ((signed int)(v30 - v31) < 0)
										v45 = 0;
									if (v45 > 254)
										v45 = 254;
									if (x_BYTE_11B4E0[i] > v45)
										sub_570F0((unsigned __int8)i, HIBYTE(i), v45, 0, 0, 1);
									v45 = v31 + v30;
									if ((signed int)(v31 + v30) < 0)
										v45 = 0;
									if (v45 > 254)
										v45 = 254;
									if ((unsigned __int8)x_BYTE_14B4E0[i] < v45)
										x_BYTE_14B4E0[i] = v45;
								}
							}
						}
					}
					v21 = i;
					v22 = x_BYTE_11B4E0[i];
					if ((unsigned __int8)x_BYTE_14B4E0[i] > v22)
					{
						x_BYTE_13B4E0[i] &= 0xF7u;
					}
					else
					{
						v23 = x_BYTE_13B4E0[i] | 8;
						x_BYTE_14B4E0[i] = v22;
						x_BYTE_13B4E0[v21] = v23;
					}
					v9 = i + 1;
					++v40;
				}
				++v34;
			}
		}
		v7 -= 68;
		++v33;
		v38 += 2;
	}
	if (!*(x_WORD *)(a1 + 54) && *(x_WORD *)(a1 + 44) > 455)
	{
		*(x_WORD *)(a1 + 54) = 1;
		for (k = 0; k < 2048; k += 28)
		{
			v24 = (v39 << 8) - 768;
			*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
			*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
			if (v24 < 256)
				v24 = 256;
			if (v24 > 0x2000)
				LOWORD(v24) = 0x2000;
			sub_57FA0((x_WORD*)&x_WORD_EB398, k, 0, v24);
			v2 = sub_4A190((int)&x_WORD_EB398, 10, 13);
			if (v2)
			{
				*(x_WORD *)(v2 + 28) = k;
				v25 = i;
				*(x_WORD *)(v2 + 134) = 512;
				x_WORD_EB39C = 32 * x_BYTE_11B4E0[v25];
				LOBYTE(v2) = sub_57CF0(v2, (int)&x_WORD_EB398);
			}
		}
	}
	v26 = *(x_WORD *)(a1 + 44) + 22;
	*(x_DWORD *)(a1 + 8) += 4;
	*(x_WORD *)(a1 + 44) = v26;
	if (v26 > 1024)
		*(x_BYTE *)(a1 + 70) = 3;
	//return v2;
}
// 10000: using guessed type void /*__noreturn*/ sub_10000();
// D41A4: using guessed type int x_DWORD_D41A4;
// DBF50: using guessed type void (/*__noreturn*/ *off_DBF50[2])();
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (00031760) --------------------------------------------------------
char sub_31760(int a1)
{
	int v1; // eax
	int v2; // esi
	__int16 v3; // cx
	char v4; // ah
	int v5; // eax
	__int16 v6; // dx
	__int16 v7; // di
	int(*v8)(); // eax

	v1 = *(x_DWORD *)(a1 + 8);
	*(x_DWORD *)(a1 + 8) = v1 - 1;
	if (v1 < 0)
		goto LABEL_17;
	sub_5C870(a1);
	if (*(x_DWORD *)(a1 + 8) < 12)
	{
		if (*(x_DWORD *)(a1 + 16) > 0)
		{
			v3 = *(x_WORD *)(a1 + 90);
			--*(x_DWORD *)(a1 + 16);
			v4 = *(x_BYTE *)(a1 + 12);
			*(x_WORD *)(a1 + 90) = v3 - 1;
			if (v4 >= 0)
			{
				*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
				if (!(*(unsigned __int16 *)(a1 + 20) % 7u))
				{
					v5 = sub_4A190(a1 + 76, 10, 14);
					if (v5)
					{
						v6 = *(x_WORD *)(a1 + 26);
						*(x_DWORD *)(v5 + 16) = 100;
						v7 = *(x_WORD *)(v5 + 90);
						*(x_DWORD *)(v5 + 8) = 15;
						*(x_WORD *)(v5 + 26) = v6;
						*(x_WORD *)(v5 + 90) = v7 + 2;
					}
				}
			}
		}
	}
	else if (*(x_DWORD *)(a1 + 16) <= 6)
	{
		v2 = *(x_DWORD *)(a1 + 16) + 1;
		++*(x_WORD *)(a1 + 90);
		*(x_DWORD *)(a1 + 16) = v2;
	}
	*(x_WORD *)(a1 + 80) = *(x_WORD *)(a1 + 44) + sub_10C40((__int16 *)(a1 + 76));
	v8 = sub_104D0((signed __int16 *)(a1 + 76));
	if (v8 == (int(*)())1)
		LABEL_17:
	sub_57F10(a1);
	if (!(*(x_BYTE *)(a1 + 14) & 1))
		LOBYTE(v8) = sub_11400(a1, 0, *(x_WORD *)(a1 + 42));
	return 1;
}

//----- (00031870) --------------------------------------------------------
void sub_31870(int a1)
{
	sub_57F10(a1);
}

//----- (00031890) --------------------------------------------------------
void sub_31890(int a1)
{
	int result; // eax

	result = *(x_DWORD *)(a1 + 8);
	*(x_DWORD *)(a1 + 8) = result - 1;
	if (result < 0)
		sub_57F10(a1);
	//return result;
}

//----- (000318B0) --------------------------------------------------------
void sub_318B0(int a1)
{
	int v1; // edx
	Bit8u* v2; // eax

	v1 = *(x_DWORD *)(a1 + 8);
	*(x_DWORD *)(a1 + 8) = v1 - 1;
	if (v1 >= 0)
	{
		sub_585A0(a1);
		if (!(*(x_BYTE *)(a1 + 12) & 2))
		{
			v2 = x_D41A0_BYTEARRAY_0 + 28302;
			*(x_BYTE *)(a1 + 12) |= 2u;
			sub_6E450((a1 - (int)v2) / 168, -1, 27);
		}
	}
	else
	{
		sub_57F10(a1);
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00031920) --------------------------------------------------------
int sub_31920(int a1)
{
	sub_57F10(a1);
	return 1;
}

//----- (00031940) --------------------------------------------------------
char sub_31940(int a1)
{
	int v1; // eax
	unsigned int v2; // ebx
	__int16 v3; // ST0C_2
	__int16 v4; // ST08_2
	int v5; // esi
	signed int v6; // edi
	int v7; // esi
	int v8; // eax
	unsigned __int16 v9; // bx
	int v10; // edx
	signed int v11; // eax
	int v12; // edx
	int v13; // eax
	int v14; // edx
	int v15; // eax
	unsigned __int16 v16; // bx
	signed int v17; // edx
	signed int v18; // eax
	unsigned __int16 v19; // si
	int v20; // eax
	int v21; // esi
	int v22; // esi
	unsigned __int16 v23; // bx
	int v24; // eax
	signed int v25; // eax
	unsigned __int16 v26; // bx
	int v27; // edx
	signed int v28; // edx
	unsigned __int16 v29; // si
	__int16 v31; // [esp+0h] [ebp-3Ch]
	__int16 v32; // [esp+2h] [ebp-3Ah]
	int v33; // [esp+8h] [ebp-34h]
	int v34; // [esp+Ch] [ebp-30h]
	int v35; // [esp+10h] [ebp-2Ch]
	int v36; // [esp+14h] [ebp-28h]
	int v37; // [esp+18h] [ebp-24h]
	int v38; // [esp+1Ch] [ebp-20h]
	int v39; // [esp+20h] [ebp-1Ch]
	int v40; // [esp+24h] [ebp-18h]
	int v41; // [esp+28h] [ebp-14h]
	int v42; // [esp+2Ch] [ebp-10h]
	int v43; // [esp+30h] [ebp-Ch]
	int v44; // [esp+34h] [ebp-8h]
	int v45; // [esp+38h] [ebp-4h]

	LOBYTE(v45) = (unsigned __int16)(*(x_WORD *)(a1 + 76) + 128) >> 8;
	BYTE1(v45) = (unsigned __int16)(*(x_WORD *)(a1 + 78) + 128) >> 8;
	LOBYTE(v1) = *(x_BYTE *)(a1 + 70);
	v39 = 0;
	if ((unsigned __int8)v1 < 1u)
	{
		if ((x_BYTE)v1)
			return v1;
		v2 = *(x_DWORD *)(a1 + 4);
		LOBYTE(v2) = v2 | 1;
		sub_49EA0((x_WORD *)a1, (x_WORD)v2 << 8, 0x4000);
		LOBYTE(v44) = v45 - v2;
		BYTE1(v44) = BYTE1(v45) - v2;
		v3 = (unsigned __int8)(BYTE1(v45) - v2);
		v4 = (unsigned __int8)(v45 - v2);
		LOWORD(v2) = 2 * v2;
		*(x_WORD *)(a1 + 80) = sub_48E60(v4, v3, v2, v2);
		*(x_WORD *)(a1 + 44) = v2 + 100;
		if (*(signed __int16 *)(a1 + 80) + *(signed __int16 *)(a1 + 44) > 255)
			*(x_WORD *)(a1 + 44) = 255 - *(x_WORD *)(a1 + 80);
		*(x_BYTE *)(a1 + 70) = 1;
	}
	else if ((unsigned __int8)v1 > 1u)
	{
		if ((x_BYTE)v1 == 2)
		{
			v43 = *(signed __int16 *)(a1 + 80) + *(signed __int16 *)(a1 + 44) - 24;
			v20 = *(signed __int16 *)(a1 + 84);
			v21 = v20;
			v20 >>= 8;
			LOBYTE(v44) = v45 - v20;
			BYTE1(v44) = BYTE1(v45) - v20;
			v22 = v21 >> 7;
			HIBYTE(v23) = BYTE1(v45) - v20;
			v24 = 0;
			if (v22 > 0)
			{
				do
				{
					LOBYTE(v23) = v44;
					v27 = 0;
					while (v27 < v22)
					{
						if (x_BYTE_11B4E0[v23] > v43)
							x_BYTE_11B4E0[v23] = v43;
						++v27;
						LOBYTE(v23) = v23 + 1;
					}
					++v24;
					++HIBYTE(v23);
				} while (v24 < v22);
				v25 = 0;
				HIBYTE(v26) = BYTE1(v45) - 1;
			}
			else
			{
				v25 = 0;
				HIBYTE(v26) = BYTE1(v45) - 1;
			}
			while (v25 < 2)
			{
				v28 = 0;
				LOBYTE(v26) = v45 - 1;
				while (v28 < 2)
				{
					x_BYTE_11B4E0[v26] = v43 - 16;
					if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308))
						v36 = 1;
					else
						v36 = 63;
					v29 = v26;
					++v28;
					LOBYTE(v26) = v26 + 1;
					x_BYTE_12B4E0[v29] = v36;
				}
				++v25;
				++HIBYTE(v26);
			}
			sub_57F10(a1);
		}
		return v1;
	}
	LOBYTE(v1) = a1;
	v5 = *(x_DWORD *)(a1 + 8) - 1;
	*(x_DWORD *)(a1 + 8) = v5;
	if (v5 <= 0)
	{
		*(x_BYTE *)(a1 + 70) = 2;
	}
	else
	{
		v6 = *(signed __int16 *)(a1 + 84);
		v7 = v6 >> 7;
		LOBYTE(v44) = v45 - BYTE1(v6);
		v34 = v6 - ((((v6 >> 8) - 7) >> 1 << 8) + 512);
		BYTE1(v44) = BYTE1(v45) - BYTE1(v6);
		v8 = 0;
		for (HIBYTE(v9) = BYTE1(v45) - BYTE1(v6); ; ++HIBYTE(v9))
		{
			v41 = v8;
			if (v7 <= v8)
				break;
			v10 = 0;
			for (LOBYTE(v9) = v44; ; LOBYTE(v9) = v9 + 1)
			{
				v40 = v10;
				if (v7 <= v10)
					break;
				v31 = (unsigned __int8)v9 << 8;
				v32 = HIBYTE(v9) << 8;
				v11 = sub_58490((x_WORD *)(a1 + 76), &v31);
				v33 = v11;
				if (v11 < v6)
				{
					v12 = (*(signed __int16 *)(a1 + 44)
						* ((x_DWORD)((x_DWORD)sub_10000 + (signed int)off_DBF50[(v11 << 10) / v6]) >> 1) >> 16)
						+ *(signed __int16 *)(a1 + 80);
					v43 = v12;
					v42 = x_BYTE_11B4E0[v9];
					v13 = v12;
					v14 = v42;
					if (v13 > v42)
						v14 = (v13 - v42) / *(x_DWORD *)(a1 + 8) + v42;
					v43 = v14;
					sub_570F0((unsigned __int8)v9, HIBYTE(v9), v14, 0, v33 <= v34, 1);
					if (x_BYTE_D41B6)
					{
						v43 += 64;
						if (v43 > 254)
							v43 = 254;
						v37 = v9;
						v38 = (unsigned __int8)x_BYTE_14B4E0[v9];
						if (v43 > v38)
						{
							v15 = (v38 - v43) / *(x_DWORD *)(a1 + 8);
							v43 = v38 - v15;
							x_BYTE_14B4E0[v37] = v38 - v15;
						}
					}
				}
				if (x_BYTE_D41B6)
				{
					if (x_BYTE_14B4E0[v9] > x_BYTE_11B4E0[v9])
						x_BYTE_13B4E0[v9] &= 0xF7u;
					else
						x_BYTE_13B4E0[v9] |= 8u;
				}
				v10 = v40 + 1;
			}
			v8 = v41 + 1;
		}
		if (!*(0x36E03 + x_D41A0_BYTEARRAY_0))
			v39 = (signed __int16)sub_116A0(a1, 0, *(x_WORD *)(a1 + 42));
		if (v39)
			sub_6D8B0(*(x_WORD *)(a1 + 26), 0x12u, v39);
		sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 10);
		if (*(0x36E03 + x_D41A0_BYTEARRAY_0) && !(*(x_BYTE *)(a1 + 62) & 3))
			sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 63);
		LOBYTE(v1) = a1;
		if (*(x_DWORD *)(a1 + 8) == 3)
		{
			HIBYTE(v16) = BYTE1(v45) - 1;
			v17 = 0;
			v43 = *(signed __int16 *)(a1 + 80) + *(signed __int16 *)(a1 + 44) - 24;
			while (v17 < 2)
			{
				v18 = 0;
				LOBYTE(v16) = v45 - 1;
				while (v18 < 2)
				{
					x_BYTE_11B4E0[v16] = v43 - 16;
					if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308))
						v35 = 1;
					else
						v35 = 63;
					v19 = v16;
					++v18;
					LOBYTE(v16) = v16 + 1;
					x_BYTE_12B4E0[v19] = v35;
				}
				++v17;
				++HIBYTE(v16);
			}
			*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
			*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
			x_WORD_EB39C = sub_10C40(&x_WORD_EB398);
			v1 = *(0x36E03 + x_D41A0_BYTEARRAY_0) ? sub_4A190((int)&x_WORD_EB398, 10, 91) : sub_4A190(
				(int)&x_WORD_EB398,
				10,
				18);
			if (v1)
				*(x_WORD *)(v1 + 26) = *(x_WORD *)(a1 + 26);
		}
	}
	return v1;
}
// 10000: using guessed type void /*__noreturn*/ sub_10000();
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41B6: using guessed type char x_BYTE_D41B6;
// DBF50: using guessed type void (/*__noreturn*/ *off_DBF50[2])();
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (00031E90) --------------------------------------------------------
int sub_31E90(signed __int16 *a1)
{
	if (!(sub_104A0((int)(a1 + 38)) & 1))
	{
		a1[10] = 9377 * a1[10] + 9439;
		sub_572C0(
			a1,
			0,
			(a1[42] - (__CFSHL__(a1[42] >> 31, 8) + (a1[42] >> 31 << 8))) >> 8,
			0 - ((unsigned __int16)a1[10] % 7u),
			1);
	}
	sub_57F10((int)a1);
	return 1;
}

//----- (00031F00) --------------------------------------------------------
void sub_31F00(signed __int16 *a1, __int16 a2, __int16 a3)
{
	int v3; // ebx
	int v4; // esi
	int v5; // edi
	//unsigned int result; // eax
	int v7; // ebx
	int v8; // [esp+0h] [ebp-Ch]
	int v9; // [esp+4h] [ebp-8h]
	int v10; // [esp+8h] [ebp-4h]

	LOWORD(v3) = a3;
	v4 = (a1[38] + 128) >> 8;
	v5 = (a1[39] + 128) >> 8;
	if (a3 > (a1[42] - (__CFSHL__(a1[42] >> 31, 8) + (a1[42] >> 31 << 8))) >> 8)
		v3 = (a1[42] - (__CFSHL__(a1[42] >> 31, 8) + (a1[42] >> 31 << 8))) >> 8;
	v10 = -3;
	v7 = sub_10080(a2, (signed __int16)v3);
	//v7 = result;
	if (v7)
	{
		while (sub_10130(v7, &v9, &v8) == 1)
			sub_56F10(v4 + v9, v5 + v8, v10, 0);
		sub_10100(v7);
	}
	//return result;
}

//----- (00031FB0) --------------------------------------------------------
void sub_31FB0(int a1)
{
	int v1; // edx
	unsigned __int16 v2; // ax
	__int16 v3; // ax
	unsigned __int16 v4; // dx
	int v5; // eax
	__int16 v6; // si

	if (!(*(unsigned __int8 *)(a1 + 62) % 3))
		++*(x_DWORD *)(a1 + 16);
	v1 = *(x_DWORD *)(a1 + 8);
	*(x_DWORD *)(a1 + 8) = v1 - 1;
	if (v1 < 0 || sub_104A0(a1 + 76) & 1)
	{
		sub_57F10(a1);
	}
	else
	{
		if (*(x_BYTE *)(a1 + 12) & 2)
			v2 = *(unsigned __int16 *)(a1 + 42) / 25;
		else
			v2 = *(x_WORD *)(a1 + 42);
		v3 = sub_116A0(a1, 0, v2);
		if (v3)
		{
			v4 = *(x_WORD *)(a1 + 38);
			if (v4 >= 0xBu)
			{
				if (v4 <= 0xBu)
				{
					sub_6D8B0(*(x_WORD *)(a1 + 26), 0x10u, v3);
				}
				else if (v4 == 15)
				{
					sub_6D8B0(*(x_WORD *)(a1 + 26), 0x11u, v3);
				}
			}
		}
		v5 = (*(signed __int16 *)(a1 + 84)
			- (__CFSHL__(*(signed __int16 *)(a1 + 84) >> 31, 8)
				+ (*(signed __int16 *)(a1 + 84) >> 31 << 8))) >> 8;
		v6 = *(x_WORD *)(a1 + 16);
		if (v6 > v5 - 1)
		{
			v6 = v5 - 1;
			if (!(*(x_BYTE *)(a1 + 12) & 2))
				sub_31F00((signed __int16 *)a1, v5, v5);
		}
		*(x_BYTE *)(a1 + 12) |= 2u;
		sub_31F00((signed __int16 *)a1, 0, v6);
		sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 10);
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (000320E0) --------------------------------------------------------
int sub_320E0(int a1)
{
	int v1; // eax

	v1 = *(x_DWORD *)(a1 + 8);
	++*(x_DWORD *)(a1 + 16);
	*(x_DWORD *)(a1 + 8) = v1 - 1;
	if (v1 < 0)
	{
		sub_57F10(a1);
		return 0;
	}
	sub_585A0(a1);
	return sub_112D0(a1, 0);
}

//----- (00032120) --------------------------------------------------------
int sub_32120(int a1)
{
	int v1; // eax

	v1 = *(x_DWORD *)(a1 + 8);
	++*(x_DWORD *)(a1 + 16);
	*(x_DWORD *)(a1 + 8) = v1 - 1;
	if (v1 < 0)
	{
		sub_57F10(a1);
		return 0;
	}
	sub_585A0(a1);
	return sub_112D0(a1, 1u);
}

//----- (00032160) --------------------------------------------------------
int sub_32160(int a1)
{
	int v1; // eax
	__int16 v3; // dx
	__int16 v4; // ax
	int v5; // edx
	__int16 v6; // ax
	__int16 v7; // si
	__int16 v8; // ax

	v1 = *(x_DWORD *)(a1 + 8);
	*(x_DWORD *)(a1 + 8) = v1 - 1;
	if (v1 < 0)
	{
		sub_57F10(a1);
		return 1;
	}
	*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
	*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
	v3 = *(x_WORD *)(a1 + 130) - 4;
	*(x_WORD *)(a1 + 130) = v3;
	if (v3 < 64)
		*(x_WORD *)(a1 + 130) = 64;
	if (*(x_WORD *)(a1 + 130) > 128)
		*(x_WORD *)(a1 + 130) = 128;
	x_WORD_EB39C += *(x_WORD *)(a1 + 130);
	v4 = sub_10C40((__int16 *)(a1 + 76));
	if (x_WORD_EB39C < v4)
		x_WORD_EB39C = v4;
	v5 = *(x_DWORD *)(a1 + 16) + 1;
	*(x_DWORD *)(a1 + 16) = v5;
	if (v5 < 16)
	{
		sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), 0, *(x_WORD *)(a1 + 134));
		v6 = *(x_WORD *)(a1 + 134) - 52;
		*(x_WORD *)(a1 + 134) = v6;
		if (v6 < 30)
			*(x_WORD *)(a1 + 134) = 30;
		if (*(x_WORD *)(a1 + 134) > 1024)
			*(x_WORD *)(a1 + 134) = 1024;
		if (!(*(x_BYTE *)(a1 + 16) & 1))
		{
			v7 = *(x_WORD *)(a1 + 90);
			if (v7 < 74)
				*(x_WORD *)(a1 + 90) = v7 + 1;
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 6)
	{
		v8 = *(x_WORD *)(a1 + 90);
		if (v8 > 67)
			*(x_WORD *)(a1 + 90) = v8 - 1;
	}
	return sub_57CF0(a1, (int)&x_WORD_EB398);
}
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (000322A0) --------------------------------------------------------
int sub_322A0(int a1)
{
	int v1; // eax
	__int16 v3; // dx
	__int16 v4; // ax
	int v5; // edx
	__int16 v6; // ax
	__int16 v7; // si
	__int16 v8; // ax

	v1 = *(x_DWORD *)(a1 + 8);
	*(x_DWORD *)(a1 + 8) = v1 - 1;
	if (v1 < 0)
	{
		sub_57F10(a1);
		return 1;
	}
	*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
	*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
	v3 = *(x_WORD *)(a1 + 130) - 4;
	*(x_WORD *)(a1 + 130) = v3;
	if (v3 < 64)
		*(x_WORD *)(a1 + 130) = 64;
	if (*(x_WORD *)(a1 + 130) > 128)
		*(x_WORD *)(a1 + 130) = 128;
	x_WORD_EB39C += *(x_WORD *)(a1 + 130);
	v4 = sub_10C40((__int16 *)(a1 + 76));
	if (x_WORD_EB39C < v4)
		x_WORD_EB39C = v4;
	v5 = *(x_DWORD *)(a1 + 16) + 1;
	*(x_DWORD *)(a1 + 16) = v5;
	if (v5 < 16)
	{
		sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), 0, *(x_WORD *)(a1 + 134));
		v6 = *(x_WORD *)(a1 + 134) - 52;
		*(x_WORD *)(a1 + 134) = v6;
		if (v6 < 30)
			*(x_WORD *)(a1 + 134) = 30;
		if (*(x_WORD *)(a1 + 134) > 1024)
			*(x_WORD *)(a1 + 134) = 1024;
		if (!(*(x_BYTE *)(a1 + 16) & 1))
		{
			v7 = *(x_WORD *)(a1 + 90);
			if (v7 < 16)
				*(x_WORD *)(a1 + 90) = v7 + 1;
		}
	}
	if (*(x_DWORD *)(a1 + 8) < 6)
	{
		v8 = *(x_WORD *)(a1 + 90);
		if (v8 > 9)
			*(x_WORD *)(a1 + 90) = v8 - 1;
	}
	return sub_57CF0(a1, (int)&x_WORD_EB398);
}
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (000323E0) --------------------------------------------------------
char sub_323E0(int a1)
{
	return sub_32420(a1);
}

//----- (00032400) --------------------------------------------------------
char sub_32400(int a1)
{
	return sub_32420(a1);
}

//----- (00032420) --------------------------------------------------------
char sub_32420(int a1)
{
	int v1; // ecx
	int v2; // eax
	int v3; // eax
	__int16 v4; // dx
	__int16 v5; // ax
	__int16 v6; // dx
	__int16 v7; // ax
	int v9; // [esp+0h] [ebp-8h]
	__int16 v10; // [esp+4h] [ebp-4h]

	v2 = *(x_DWORD *)(a1 + 8);
	*(x_DWORD *)(a1 + 8) = v2 - 1;
	if (v2 < 0)
	{
		sub_57F10(a1);
		return 1;
	}
	v9 = *(x_DWORD *)(a1 + 76);
	v10 = *(x_WORD *)(a1 + 80);
	*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
	LOWORD(v9) = *(x_WORD *)(a1 + 20) % 0xA0u + v9;
	*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
	v10 += *(x_WORD *)(a1 + 20) % 0xA0u;
	LOBYTE(v3) = *(x_BYTE *)(a1 + 64);
	if ((unsigned __int8)v3 >= 0x3Bu)
	{
		if ((unsigned __int8)v3 <= 0x3Bu)
		{
			v3 = sub_4E9E0((int)&v9);
		}
		else
		{
			if ((x_BYTE)v3 != 60)
				goto LABEL_10;
			v3 = sub_4EA20((int)&v9);
		}
		v1 = v3;
	}
LABEL_10:
	if (v1)
	{
		*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
		v4 = *(x_WORD *)(a1 + 20) % 0x4Du;
		v5 = *(x_WORD *)(a1 + 130);
		*(x_DWORD *)(v1 + 8) = 32;
		v6 = v5 + v4;
		v7 = *(x_WORD *)(v1 + 130);
		*(x_DWORD *)(v1 + 4) = 32;
		LOWORD(v3) = v6 + v7;
		*(x_WORD *)(v1 + 130) = v3;
	}
	return v3;
}

//----- (00032530) --------------------------------------------------------
int sub_32530(int a1)
{
	int v1; // ecx
	int v2; // eax
	int result; // eax
	__int16 v4; // dx

	if (sub_104A0(a1 + 76) & 1)
	{
		++*(x_DWORD *)(a1 + 16);
	}
	else
	{
		v1 = *(x_DWORD *)(a1 + 16);
		if (v1 > 0)
			*(x_DWORD *)(a1 + 16) = v1 - 1;
	}
	v2 = *(x_DWORD *)(a1 + 8);
	*(x_DWORD *)(a1 + 8) = v2 - 1;
	if (v2 < 0 || *(x_DWORD *)(a1 + 16) > 8)
	{
		sub_57F10(a1);
		return 1;
	}
	*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
	*(x_WORD *)(a1 + 28) = (*(x_WORD *)(a1 + 20) % 0x5Bu + *(x_WORD *)(a1 + 28) - 45) & 0x7FF;
	sub_57FA0((x_WORD *)(a1 + 76), *(x_WORD *)(a1 + 28), 0, 256);
	result = sub_4A190(a1 + 76, 10, 11);
	if (result)
	{
		*(x_DWORD *)(result + 84) = *(x_DWORD *)(a1 + 84);
		*(x_WORD *)(result + 88) = *(x_WORD *)(a1 + 88);
		*(x_DWORD *)(result + 8) = 10;
		v4 = *(x_WORD *)(a1 + 26);
		*(x_WORD *)(result + 38) = 15;
		*(x_WORD *)(result + 26) = v4;
	}
	return result;
}

//----- (00032600) --------------------------------------------------------
void sub_32600(int a1)
{
	int v1; // eax
	int v2; // eax
	char v3; // ah
	__int16 v4; // di
	__int16 v5; // ax
	__int16 v6; // ax
	__int16 v7; // si
	int v8; // edx
	int v9; // eax
	int v10; // eax
	__int16 v11; // cx
	int v12; // eax
	int v13; // edx

	v1 = *(x_DWORD *)(a1 + 8);
	*(x_DWORD *)(a1 + 8) = v1 - 1;
	if (v1 >= 0)
	{
		v3 = *(x_BYTE *)(a1 + 12);
		if (!(v3 & 2))
			*(x_BYTE *)(a1 + 12) = v3 | 2;
		if (*(signed __int16 *)(a1 + 154) < -80)
			*(x_WORD *)(a1 + 154) = -80;
		if (*(x_WORD *)(a1 + 154) > 80)
			*(x_WORD *)(a1 + 154) = 80;
		if (*(signed __int16 *)(a1 + 156) < -80)
			*(x_WORD *)(a1 + 156) = -80;
		if (*(x_WORD *)(a1 + 156) > 80)
			*(x_WORD *)(a1 + 156) = 80;
		*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
		*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
		v4 = *(x_WORD *)(a1 + 156);
		x_WORD_EB398 = *(x_WORD *)(a1 + 154) + *(x_WORD *)(a1 + 76);
		x_WORD_EB39A = v4 + *(x_WORD *)(a1 + 78);
		v5 = *(x_WORD *)(a1 + 44);
		x_WORD_EB39C += v5;
		*(x_WORD *)(a1 + 44) = v5 - 28;
		if ((signed __int16)(v5 - 28) < -384)
			*(x_WORD *)(a1 + 44) = -384;
		if (*(x_WORD *)(a1 + 44) > 256)
			*(x_WORD *)(a1 + 44) = 256;
		v6 = sub_10C40(&x_WORD_EB398);
		v7 = v6;
		if (v6 > x_WORD_EB39C)
		{
			v8 = *(signed __int16 *)(a1 + 44);
			x_WORD_EB39C = v6;
			*(x_WORD *)(a1 + 44) = -((v8 - (__CFSHL__(v8 >> 31, 2) + 4 * (v8 >> 31))) >> 2);
			if (sub_104D0((signed __int16 *)(a1 + 76)) == (int(*)())1)
			{
				v9 = sub_4A190((int)&x_WORD_EB398, 10, 5);
				if (v9)
				{
					*(x_WORD *)(v9 + 26) = *(x_WORD *)(a1 + 26);
					sub_57F10(a1);
				}
			}
			else
			{
				if (!sub_10B70((unsigned __int16 *)&x_WORD_EB398, 10, 6))
				{
					v10 = sub_4A190((int)&x_WORD_EB398, 10, 6);
					if (v10)
					{
						v11 = *(x_WORD *)(v10 + 42);
						*(x_WORD *)(v10 + 26) = *(x_WORD *)(a1 + 26);
						*(x_DWORD *)(v10 + 8) = 30;
						*(x_WORD *)(v10 + 42) = 3 * v11;
						*(x_DWORD *)(a1 + 16) = 0;
					}
				}
				if (*(x_WORD *)(a1 + 44) <= 28)
					*(x_WORD *)(a1 + 44) = 0;
			}
		}
		++*(x_DWORD *)(a1 + 16);
		sub_57CF0(a1, (int)&x_WORD_EB398);
		LOWORD(v2) = x_WORD_EB39C;
		if (v7 == x_WORD_EB39C)
		{
			sub_58030(a1 + 76, &x_WORD_EB398);
			*(x_WORD *)(a1 + 154) += x_WORD_EB398;
			v12 = (250 * *(signed __int16 *)(a1 + 154)
				- (__CFSHL__(250 * *(signed __int16 *)(a1 + 154) >> 31, 8)
					+ (250 * *(signed __int16 *)(a1 + 154) >> 31 << 8))) >> 8;
			*(x_WORD *)(a1 + 156) += x_WORD_EB39A;
			v13 = *(signed __int16 *)(a1 + 156);
			*(x_WORD *)(a1 + 154) = v12;
			v2 = (250 * v13 - (__CFSHL__(250 * v13 >> 31, 8) + (250 * v13 >> 31 << 8))) >> 8;
			*(x_WORD *)(a1 + 156) = v2;
		}
	}
	else
	{
		sub_57F10(a1);
	}
	//return v2;
}
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39A: using guessed type __int16 x_WORD_EB39A;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (00032880) --------------------------------------------------------
int sub_32880(int a1)
{
	int v1; // edx
	int result; // eax
	int v3; // edx
	__int16 v4; // ax
	int v5; // edi
	int v6; // eax
	int v7; // esi
	int v8; // ecx
	__int16 v9; // [esp+0h] [ebp-10h]
	__int16 v10; // [esp+2h] [ebp-Eh]
	__int16 v11; // [esp+4h] [ebp-Ch]
	int v12; // [esp+8h] [ebp-8h]
	int v13; // [esp+Ch] [ebp-4h]

	v1 = *(x_DWORD *)(a1 + 8) - 1;
	*(x_DWORD *)(a1 + 8) = v1;
	if (v1 < 0)
	{
		sub_57F10(a1);
		return 1;
	}
	if (!(*(x_BYTE *)(a1 + 12) & 2))
	{
		v3 = a1 - (x_D41A0_BYTEARRAY_0[28302]);
		*(x_DWORD *)(a1 + 12) |= (unsigned int)&loc_10001 + 1;
		sub_6E450(v3 / 168, -1, 30);
	}
	sub_49EA0(
		(x_WORD *)a1,
		(768 * *(x_DWORD *)(a1 + 16)
			- (__CFSHL__(768 * *(x_DWORD *)(a1 + 16) >> 31, 2)
				+ 4 * (768 * *(x_DWORD *)(a1 + 16) >> 31))) >> 2,
		512);
	v4 = sub_10C80(a1, 0, (signed int)*(unsigned __int16 *)(a1 + 42) / *(x_DWORD *)(a1 + 4));
	if (v4)
		sub_6D8B0(*(x_WORD *)(a1 + 26), 9u, v4);
	v5 = sub_10080(*(x_DWORD *)(a1 + 16), *(x_DWORD *)(a1 + 16));
	if (v5)
	{
		while (sub_10130(v5, &v12, &v13) == 1)
		{
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			v9 = *(x_WORD *)(a1 + 76) - 96 + 160 * v12 + *(x_WORD *)(a1 + 20) % 0x81u - 64;
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			v10 = *(x_WORD *)(a1 + 20) % 0x81u + 160 * v13 + *(x_WORD *)(a1 + 78) - 96 - 64;
			v11 = *(x_WORD *)(a1 + 80);
			v6 = sub_4A190((int)&v9, 10, 0);
			v7 = v6;
			if (v6)
			{
				v8 = *(x_DWORD *)(v6 + 12);
				*(x_WORD *)(v6 + 26) = *(x_WORD *)(a1 + 26);
				*(x_WORD *)(v6 + 28) = *(x_WORD *)(a1 + 28);
				*(x_DWORD *)(v6 + 12) = (unsigned int)sub_10080 | v8;
				sub_49EA0((x_WORD *)v6, 512, 512);
				*(x_DWORD *)(v7 + 16) = 0;
			}
		}
		sub_10100(v5);
	}
	result = (*(x_DWORD *)(a1 + 16) + 2) / 11;
	*(x_DWORD *)(a1 + 16) = (*(x_DWORD *)(a1 + 16) + 2) % 11;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00032A70) --------------------------------------------------------
void sub_32A70(int a1)
{
	__int16 v1; // si
	__int16 v2; // ax
	__int16 v3; // si
	__int16 v4; // ax
	unsigned int v5; // eax
	int v6; // eax
	int v7; // esi
	int v8; // eax
	__int16 v9; // dx
	int v10; // esi
	__int16 v11; // ax
	int v12; // [esp+0h] [ebp-4h]

	if (*(x_DWORD *)(a1 + 16) > 2500)
	{
		*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
		if (!(*(unsigned __int16 *)(a1 + 20) % 0x64u) && !*(x_WORD *)(x_D41A0_BYTEARRAY_0 + 49))
		{
			v1 = *(x_WORD *)(a1 + 80);
			v2 = sub_10C40((__int16 *)(a1 + 76));
			*(x_WORD *)(a1 + 80) = v2;
			if (v1 != v2)
			{
				sub_57F10(a1);
				return;
			}
			*(x_DWORD *)(a1 + 16) = 0;
		}
	}
	if (*(x_DWORD *)(a1 + 16) < 128
		&& *(x_BYTE *)(a1 + 16) & 0xF
		&& (*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439, !(*(unsigned __int16 *)(a1 + 20) % 5u))
		|| !*(x_DWORD *)(a1 + 16))
	{
		v3 = *(x_WORD *)(a1 + 80);
		v4 = sub_10C40((__int16 *)(a1 + 76));
		*(x_WORD *)(a1 + 80) = v4;
		if (v3 != v4)
		{
			sub_57F10(a1);
			*(x_WORD *)(x_D41A0_BYTEARRAY_0 + 49) = 0;
			return;
		}
		if (!*(x_DWORD *)(a1 + 16))
		{
			v5 = x_DWORD_EA3E4[*(unsigned __int16 *)(x_D41A0_BYTEARRAY_0 + 49)];
			if (v5 > x_DWORD_EA3E4[0])
				*(x_DWORD *)(v5 + 16) = 250;
			*(x_WORD *)(x_D41A0_BYTEARRAY_0 + 49) = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
			v6 = sub_4A190(a1 + 76, 10, 19);
			v7 = v6;
			if (v6)
			{
				*(x_WORD *)(v6 + 26) = *(x_WORD *)(a1 + 26);
				if ((unsigned int)x_DWORD_EA3E4[*(unsigned __int16 *)(x_D41A0_BYTEARRAY_0 + 51)] > x_DWORD_EA3E4[0])
					sub_57F10(x_DWORD_EA3E4[*(unsigned __int16 *)(x_D41A0_BYTEARRAY_0 + 51)]);
				*(x_WORD *)(x_D41A0_BYTEARRAY_0 + 51) = (v7 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
			}
		}
		v8 = sub_4A190(a1 + 76, 10, 16);
		if (v8)
		{
			*(x_WORD *)(v8 + 26) = *(x_WORD *)(a1 + 26);
			v9 = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			*(x_WORD *)(a1 + 20) = v9;
			*(x_WORD *)(v8 + 20) = v9;
		}
		v10 = *(x_DWORD *)(a1 + 16);
		*(x_BYTE *)(a1 + 29) += 5;
		if (!v10)
		{
			v12 = sub_4A190(a1 + 76, 9, 0);
			if (v12)
			{
				*(x_WORD *)(v12 + 26) = *(x_WORD *)(a1 + 26);
				v11 = *(x_WORD *)(a1 + 28);
				*(x_WORD *)(v12 + 30) = -386;
				*(x_BYTE *)(v12 + 67) = 10;
				*(x_BYTE *)(v12 + 68) = 17;
				HIBYTE(v11) &= 7u;
				*(x_DWORD *)(v12 + 8) = 1;
				*(x_WORD *)(v12 + 28) = v11;
				*(x_DWORD *)(v12 + 154) = *(x_DWORD *)(a1 + 76);
				*(x_WORD *)(v12 + 158) = *(x_WORD *)(a1 + 80);
				sub_57FA0((x_WORD *)(v12 + 154), *(x_WORD *)(v12 + 28), 0, 1536);
				*(x_WORD *)(v12 + 158) = sub_10C40((__int16 *)(v12 + 154));
			}
		}
		if (*(x_DWORD *)(a1 + 16) >= 127)
		{
			sub_57F10(a1);
			*(x_WORD *)(x_D41A0_BYTEARRAY_0 + 49) = 0;
		}
	}
	++*(x_DWORD *)(a1 + 16);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00032CF0) --------------------------------------------------------
void sub_32CF0(int a1)
{
	int v1; // eax
	int v2; // ecx
	signed int v3; // ebx
	char v4; // ah
	__int16 v5; // dx
	__int16 v6; // ax
	unsigned int v7; // ecx
	signed int v8; // esi
	__int16 v9; // ax
	__int16 v10; // ax
	__int16 v11; // cx
	char *v12; // esi
	signed int v13; // ebx
	int v14; // ST0C_4
	unsigned __int16 v15; // ST08_2
	signed int i; // [esp+0h] [ebp-4h]

	for (i = 0; i < 3; i++)
	{
		v1 = sub_4A190(a1 + 76, 10, 39);
		v2 = v1;
		v3 = v1;
		if (v1)
		{
			v4 = *(x_BYTE *)(v1 + 13) | 0x20;
			*(x_DWORD *)(v2 + 4) = 140;
			*(x_BYTE *)(v2 + 13) = v4;
			*(x_DWORD *)(v2 + 8) = *(x_DWORD *)(v2 + 4);
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			v5 = *(x_WORD *)(a1 + 20) % 0x300u;
			*(x_WORD *)(v2 + 130) = v5;
			if (v5 < 64)
				*(x_WORD *)(v2 + 130) = 64;
			if (*(x_WORD *)(v3 + 130) > 768)
				*(x_WORD *)(v3 + 130) = 768;
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			v6 = *(x_WORD *)(a1 + 20) & 0x7F;
			*(x_WORD *)(v3 + 148) = 0;
			*(x_WORD *)(v3 + 44) = v6 + 128;
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			v7 = *(unsigned __int16 *)(a1 + 20) % 9u - 1;
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			v8 = 0;
			*(x_DWORD *)(v3 + 144) = *(unsigned __int16 *)(a1 + 20) % 0xA00u + 1;
			while (v8 < 7 && *(x_DWORD *)(v3 + 144) > x_DWORD_DB538[v8])
				++v8;
			v9 = sub_36A50(v3, v7);
			sub_49CD0((x_WORD *)v3, v8 + v9);
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			v10 = *(x_WORD *)(a1 + 20) & 0x7FF;
			*(x_WORD *)(v3 + 30) = 0;
			*(x_WORD *)(v3 + 28) = v10;
			*(x_WORD *)(v3 + 32) = *(x_WORD *)(v3 + 28);
			*(x_DWORD *)(v3 + 154) = *(x_DWORD *)(a1 + 76);
			*(x_WORD *)(v3 + 158) = *(x_WORD *)(a1 + 80);
			sub_57FA0((x_WORD *)(v3 + 154), *(x_WORD *)(v3 + 28), 0, *(x_WORD *)(v3 + 130));
			v11 = *(x_WORD *)(v3 + 156) - *(x_WORD *)(v3 + 78);
			*(x_WORD *)(v3 + 154) -= *(x_WORD *)(v3 + 76);
			*(x_WORD *)(v3 + 156) = v11;
			*(x_WORD *)(v3 + 80) = sub_10C40((__int16 *)(v3 + 76)) + 96;
		}
	}
	if (!(*(x_BYTE *)(a1 + 62) & 1))
	{
		v12 = (char*)*xadataspellsdat.var28_begin_buffer;
		v13 = 0;
		while (v13 < 26)
		{
			v14 = (*(x_DWORD *)(v12 + 66) - (__CFSHL__(*(x_DWORD *)(v12 + 66) >> 31, 9) + (*(x_DWORD *)(v12 + 66) >> 31 << 9))) >> 9;
			v15 = v13++;
			v12 += 80;
			sub_6D8B0(*(x_WORD *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240), v15, v14);
		}
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00032F40) --------------------------------------------------------
int sub_32F40(int a1)
{
	int v1; // eax
	int v2; // esi
	int v3; // eax
	__int16 v5; // [esp+0h] [ebp-14h]
	__int16 v6; // [esp+2h] [ebp-12h]
	__int16 v7; // [esp+4h] [ebp-10h]
	int v8; // [esp+8h] [ebp-Ch]
	int v9; // [esp+Ch] [ebp-8h]
	int v10; // [esp+10h] [ebp-4h]

	v1 = *(x_DWORD *)(a1 + 8);
	*(x_DWORD *)(a1 + 8) = v1 - 1;
	if (v1 >= 0)
	{
		*(x_DWORD *)(a1 + 16) = 0;
		v2 = sub_10080(0, *(x_DWORD *)(a1 + 16));
		if (v2)
		{
			while (sub_10130(v2, &v9, &v8) == 1)
			{
				*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
				if (2 * ((signed int)(*(unsigned __int16 *)(a1 + 20) % 0x9Du) / 79) - 1 > 0)
				{
					*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
					v5 = *(x_WORD *)(a1 + 20) % 0x81u + *(x_WORD *)(a1 + 76) - 96 + 192 * v9 - 64;
					*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
					v6 = *(x_WORD *)(a1 + 78) - 96 + 192 * v8 + *(x_WORD *)(a1 + 20) % 0x81u - 64;
					v7 = *(x_WORD *)(a1 + 80);
					if (*(x_BYTE *)(a1 + 8) & 1)
					{
						LOWORD(v10) = (*(x_DWORD *)(a1 + 8) / 2 & 1) << 8;
						while ((unsigned __int16)v10 < 0x800u)
						{
							v3 = sub_4A190((int)&v5, 10, 14);
							if (v3)
							{
								*(x_WORD *)(v3 + 26) = *(x_WORD *)(a1 + 26);
								*(x_WORD *)(v3 + 28) = v10;
							}
							BYTE1(v10) += 2;
						}
					}
				}
			}
			sub_10100(v2);
		}
		*(x_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
	}
	else
	{
		sub_57F10(a1);
		*(x_WORD *)(x_D41A0_BYTEARRAY_0 + 51) = 0;
	}
	return sub_10C80(a1, 0, *(x_WORD *)(a1 + 42));
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00033110) --------------------------------------------------------
void sub_33110(unsigned int a1)
{
	int v1; // edx

	v1 = *(x_DWORD *)(a1 + 8) - 1;
	*(x_DWORD *)(a1 + 8) = v1;
	if (v1 < 0)
	{
		sub_6EAB0((signed __int16)((signed int)(a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168), -1, 49);
		sub_338D0(a1);
	}
	else
	{
		sub_331A0(a1);
		sub_33340((x_WORD *)a1);
		sub_33710(a1);
		sub_6E450((signed int)(a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 49);
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (000331A0) --------------------------------------------------------
x_WORD *sub_331A0(int a1)
{
	__int16 v1; // ax
	__int16 v2; // ax
	x_WORD *result; // eax
	x_WORD *v4; // edi
	signed int v5; // eax
	int v6; // edi
	x_WORD *v7; // [esp+0h] [ebp-4h]

	*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
	*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
	*(x_WORD *)(a1 + 48) = x_WORD_EB39C;
	if (!(*(x_BYTE *)(a1 + 62) & 0xF))
	{
		*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
		if (!(*(x_WORD *)(a1 + 20) & 1))
			*(x_WORD *)(a1 + 46) = -*(x_WORD *)(a1 + 46);
	}
	v1 = *(x_WORD *)(a1 + 32) + 11 * *(x_WORD *)(a1 + 46);
	HIBYTE(v1) &= 7u;
	*(x_WORD *)(a1 + 32) = v1;
	sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 32), 0, 32);
	*(x_DWORD *)(a1 + 154) = *(x_DWORD *)&x_WORD_EB398;
	*(x_WORD *)(a1 + 158) = *(&x_WORD_EB398 + 2);
	v2 = *(x_WORD *)(a1 + 28) + 341;
	HIBYTE(v2) &= 7u;
	*(x_WORD *)(a1 + 28) = v2;
	sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), 0, 120);
	x_WORD_EB39C = sub_10C40(&x_WORD_EB398);
	sub_57CF0(a1, (int)&x_WORD_EB398);
	v7 = (x_WORD *)x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 52)];
	result = (x_WORD *)a1;
	while ((unsigned int)v7 > x_DWORD_EA3E4[0])
	{
		*(x_DWORD *)&x_WORD_EB398 = *((x_DWORD *)v7 + 19);
		*(&x_WORD_EB398 + 2) = v7[40];
		v4 = result + 38;
		v7[14] = sub_581E0((Bit16u *)v7 + 38, (Bit16u *)result + 38);
		v5 = sub_58490(v4, v7 + 38);
		v6 = 72 - 4 * (12 - (signed __int16)v7[22]);
		if (v5 > v6)
			sub_57FA0((x_WORD*)&x_WORD_EB398, v7[14], 0, v5 - v6);
		x_WORD_EB39C = v7[27] + *(x_WORD *)(a1 + 80);
		sub_57CF0((int)v7, (int)&x_WORD_EB398);
		result = v7;
		v7 = (x_WORD *)x_DWORD_EA3E4[(unsigned __int16)v7[26]];
	}
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (00033340) --------------------------------------------------------
void sub_33340(x_WORD *a1)
{
	int i; // ebx
	char v2; // dl
	signed int v3; // eax
	signed int v4; // eax
	int v5; // eax
	__int16 v6; // dx
	int v7; // eax
	__int16 v8; // cx
	int v9; // edi
	__int16 v10; // si
	__int16 v11; // ax
	__int16 v12; // cx
	unsigned int v13; // esi
	__int16 v14; // dx
	__int16 v15; // ax
	__int16 v16; // ax
	char v17; // ch
	int v18; // edx
	int v19; // edi
	int v20; // esi
	int v21; // eax
	__int16 v22; // ST10_2
	int v23; // ST0C_4
	int v24; // ST08_4
	__int16 v25; // ax
	unsigned __int16 v26; // ST10_2
	int v27; // esi
	int v28; // [esp+0h] [ebp-34h]
	int v29; // [esp+4h] [ebp-30h]
	int v30; // [esp+8h] [ebp-2Ch]
	int v31; // [esp+Ch] [ebp-28h]
	int v32; // [esp+10h] [ebp-24h]
	int v33; // [esp+14h] [ebp-20h]
	int v34; // [esp+18h] [ebp-1Ch]
	int v35; // [esp+1Ch] [ebp-18h]
	int v36; // [esp+20h] [ebp-14h]
	int v37; // [esp+24h] [ebp-10h]
	int v38; // [esp+28h] [ebp-Ch]
	char v39; // [esp+2Ch] [ebp-8h]
	bool v40; // [esp+30h] [ebp-4h]

	v31 = 0;
	v32 = ((unsigned __int16)a1[38] + 128) >> 8;
	v36 = ((unsigned __int16)a1[39] + 128) >> 8;
	v35 = sub_10080(0, 12);
	if (v35)
	{
		while (1)
		{
			v27 = v35;
			if (sub_10130(v35, &v29, &v28) != 1)
				break;
			for (i = x_DWORD_EA3E4[x_WORD_15B4E0[(unsigned __int8)(v29 + v32) + ((unsigned __int8)(v28 + v36) << 8)]];
				i != x_DWORD_EA3E4[0];
				i = x_DWORD_EA3E4[*(unsigned __int16 *)(i + 22)])
			{
				if (sub_33810((int)a1, i))
				{
					v2 = *(x_BYTE *)(i + 63);
					v39 = 0;
					v37 = 0;
					v30 = 0;
					v40 = v2 == 3 && !*(x_BYTE *)(i + 64);
					if (v40)
						v3 = 56;
					else
						v3 = 204;
					v38 = v3;
					if (v40)
						v4 = 384;
					else
						v4 = 768;
					v34 = v4;
					v5 = sub_584D0(a1 + 77, (x_WORD *)(i + 76));
					v33 = v5;
					if (v5 >= 3211264)
					{
						*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(i + 76);
						*(&x_WORD_EB398 + 2) = *(x_WORD *)(i + 80);
						if (*(x_BYTE *)(i + 15) & 0x10)
						{
							v17 = *(x_BYTE *)(i + 13) | 8;
							v39 = 1;
							v18 = *(x_DWORD *)(i + 160);
							*(x_BYTE *)(i + 13) = v17;
							v37 = *(signed __int16 *)(v18 + 14);
							LOWORD(v18) = v38 + *(x_WORD *)(i + 28);
							BYTE1(v18) &= 7u;
							v30 = 64;
							*(x_WORD *)(i + 28) = v18;
							if (v5 >= 5308416)
								*(x_BYTE *)(i + 15) &= 0xEFu;
						}
					}
					else
					{
						v6 = sub_581E0((Bit16u *)a1 + 77, (Bit16u *)(i + 76));
						if (*(x_BYTE *)(i + 15) & 0x10)
						{
							*(x_BYTE *)(i + 13) |= 8u;
							v30 = 128;
							*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(i + 76);
							*(&x_WORD_EB398 + 2) = *(x_WORD *)(i + 80);
							v15 = *(x_WORD *)(i + 28);
							v39 = 1;
							v16 = v38 + v15;
							HIBYTE(v16) &= 7u;
							x_WORD_EB39C += 114;
							*(x_WORD *)(i + 28) = v16;
						}
						else
						{
							if (v40)
							{
								v7 = *(x_DWORD *)(i + 164);
								v8 = *(x_WORD *)(v7 + 341);
								if (v8 < 256)
									*(x_WORD *)(v7 + 341) = v8 + 28;
								*(x_WORD *)(i + 130) = 80;
							}
							if (v33 >= (signed int)&loc_40000)
							{
								v14 = v6 + 591;
								HIBYTE(v14) &= 7u;
								*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(i + 76);
								*(&x_WORD_EB398 + 2) = *(x_WORD *)(i + 80);
								*(x_WORD *)(i + 48) = v14;
								*(x_WORD *)(i + 28) = v14;
								v30 = 96;
							}
							else
							{
								*(x_BYTE *)(i + 13) |= 8u;
								*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 77);
								*(&x_WORD_EB398 + 2) = a1[79];
								v9 = *(signed __int16 *)(i + 80) - (signed __int16)a1[24] + 57;
								v10 = sub_10C40(&x_WORD_EB398);
								x_WORD_EB39C = v9 + v10;
								if ((signed __int16)(v9 + v10) < v10)
									x_WORD_EB39C = v10;
								v11 = v38 + *(x_WORD *)(i + 28);
								HIBYTE(v11) &= 7u;
								v12 = *(x_WORD *)(i + 20);
								*(x_WORD *)(i + 28) = v11;
								v13 = v34;
								*(x_WORD *)(i + 20) = 9377 * v12 + 9439;
								if (v9 >= (signed int)(v13 + *(unsigned __int16 *)(i + 20) % v13))
								{
									*(x_BYTE *)(i + 15) |= 0x10u;
									*(x_WORD *)(i + 48) = *(x_WORD *)(i + 28);
								}
							}
						}
					}
					sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(i + 48), 0, v30);
					if (x_BYTE_D41B6)
					{
						v19 = *(signed __int16 *)(i + 88);
						v20 = (signed __int16)sub_10C60(&x_WORD_EB398) - v19;
						if (x_WORD_EB39C > v20)
							x_WORD_EB39C = v20;
					}
					v21 = *(x_DWORD *)(i + 160);
					v22 = v37;
					v23 = *(signed __int16 *)(v21 + 10);
					v24 = *(signed __int16 *)(v21 + 12);
					v25 = sub_10C40(&x_WORD_EB398);
					sub_580E0((int)&x_WORD_EB398, v25, v24, v23, v22);
					sub_57CF0(i, (int)&x_WORD_EB398);
					if (v39)
					{
						v26 = a1[21];
						++v31;
						sub_11900((int)a1, i, 0, v26);
					}
				}
			}
		}
		sub_10100(v27);
		if (v31)
			sub_6D8B0(a1[13], 0x15u, v31);
	}
}
// D41B6: using guessed type char x_BYTE_D41B6;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (00033710) --------------------------------------------------------
void sub_33710(int a1)
{
	int v1; // edi
	x_DWORD *i; // ebx
	unsigned int j; // ebx
	__int16 v4; // ax

	v1 = 0;
	if (!(*(x_BYTE *)(a1 + 62) & 7))
	{
		for (i = (int32*)x_D41A0_BYTEARRAY_4[0x967F]; (unsigned int)i > x_DWORD_EA3E4[0]; i = (x_DWORD *)*i)
		{
			if (sub_10750(a1, (int)i))
				sub_11900(a1, (int)i, 0, *(x_WORD *)(a1 + 42));
		}
		for (j = x_D41A0_BYTEARRAY_4[0x9677]; j > x_DWORD_EA3E4[0]; j = *(x_DWORD *)j)
		{
			if (*(x_BYTE *)(j + 64) == 2 && sub_10750(a1, j))
			{
				v4 = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
				*(x_WORD *)(j + 48) = 30;
				*(x_WORD *)(j + 38) = v4;
				*(x_DWORD *)(j + 94) += *(unsigned __int16 *)(a1 + 42);
				v1 += 2;
				*(x_WORD *)(j + 98) = *(x_WORD *)(a1 + 26);
			}
		}
		if (v1)
			sub_6D8B0(*(x_WORD *)(a1 + 26), 0x15u, v1);
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00033810) --------------------------------------------------------
char sub_33810(int a1, int a2)
{
	char result; // al
	unsigned __int8 v3; // ah
	char v4; // bl
	unsigned __int8 v5; // ah
	unsigned __int8 v6; // ah
	unsigned __int8 v7; // ah

	result = 1;
	v3 = *(x_BYTE *)(a2 + 63) - 2;
	if (v3 > 8u)
		return 0;
	switch (v3)
	{
	case 0u:
		v7 = *(x_BYTE *)(a2 + 64);
		if (v7 < 7u || v7 > 8u)
			return 0;
		return result;
	case 1u:
		if (*(x_WORD *)(a2 + 26) == *(x_WORD *)(a1 + 26))
			return 0;
		if (*(x_BYTE *)(a2 + 64) == 2)
			result = 0;
		return result;
	case 2u:
	case 4u:
	case 5u:
	case 6u:
	case 7u:
		return 0;
	case 3u:
		v4 = *(x_BYTE *)(a2 + 69);
		if (v4 == -24 || v4 == -76)
			return 0;
		v5 = *(x_BYTE *)(a2 + 64);
		if (v5 < 0xFu)
		{
			if (v5 == 10)
				result = 0;
		}
		else if (v5 <= 0xFu || v5 >= 0x12u && (v5 <= 0x12u || v5 >= 0x1Bu && v5 <= 0x1Cu))
		{
			return 0;
		}
		return result;
	case 8u:
		v6 = *(x_BYTE *)(a2 + 64);
		if (v6 < 0x27u)
		{
			if (v6 < 0xDu)
				return 0;
			if (v6 > 0xEu)
				result = 0;
		}
		else if (v6 > 0x27u && v6 != 57)
		{
			result = 0;
		}
		break;
	}
	return result;
}

//----- (000338D0) --------------------------------------------------------
void sub_338D0(unsigned int a1)
{
	int v1; // edi
	int v2; // esi
	//unsigned int result; // eax
	int v4; // edi
	int v5; // ebx
	int i; // eax
	int v7; // eax
	unsigned int j; // ebx
	int v9; // [esp+0h] [ebp-8h]
	int v10; // [esp+4h] [ebp-4h]

	v1 = *(unsigned __int16 *)(a1 + 78) + 128;
	v2 = (*(unsigned __int16 *)(a1 + 76) + 128) >> 8;
	v5 = sub_10080(0, 12);
	v4 = v1 >> 8;
	//v5 = result;
	if (v5)
	{
		while (sub_10130(v5, &v10, &v9) == 1)
		{
			for (i = x_WORD_15B4E0[((unsigned __int8)(v4 + v9) << 8) + (unsigned __int8)(v2 + v10)];
				;
				i = *(unsigned __int16 *)(v7 + 22))
			{
				v7 = x_DWORD_EA3E4[i];
				if (v7 == x_DWORD_EA3E4[0])
					break;
				*(x_DWORD *)(v7 + 12) &= 0xEFFFF7FF;
			}
		}
		sub_10100(v5);
	}
	for (j = a1; j > x_DWORD_EA3E4[0]; j = x_DWORD_EA3E4[*(unsigned __int16 *)(j + 52)])
		sub_57F10(j);
	//return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000339B0) --------------------------------------------------------
char sub_339B0(int a1)
{
	__int16 v1; // ax
	unsigned __int16 v2; // dx
	int v3; // eax
	__int16 v4; // cx
	int v5; // edx
	char v6; // ah
	__int16 v7; // di

	LOBYTE(v1) = *(x_BYTE *)(a1 + 70);
	if ((unsigned __int8)v1 < 1u)
	{
		if ((x_BYTE)v1)
			return v1;
		v2 = *(x_WORD *)(a1 + 150);
		if (v2)
		{
			v3 = x_DWORD_EA3E4[v2];
			*(x_WORD *)(a1 + 134) = *(x_WORD *)(v3 + 84) >> 1;
			v4 = *(x_WORD *)(a1 + 134);
			*(x_WORD *)(a1 + 132) = 6 * *(signed __int16 *)(v3 + 84) >> 2;
			if (v4 < 128)
				*(x_WORD *)(a1 + 134) = 128;
			if (*(x_WORD *)(a1 + 132) > 640)
				*(x_WORD *)(a1 + 132) = 640;
		}
		*(x_BYTE *)(a1 + 70) = 1;
	}
	else if ((unsigned __int8)v1 > 1u)
	{
		if ((x_BYTE)v1 == 2)
		{
			v6 = *(x_BYTE *)(a1 + 61);
			if (v6 < 0)
				*(x_BYTE *)(a1 + 61) = -v6;
			sub_33B20(a1);
			v1 = *(char *)(a1 + 61);
			v7 = *(x_WORD *)(a1 + 44) - v1;
			*(x_WORD *)(a1 + 44) = v7;
			if (v7 < 0)
			{
				sub_4A190(a1 + 76, 10, 0);
				LOBYTE(v1) = sub_33D40(a1);
			}
		}
		return v1;
	}
	sub_33C70(a1);
	sub_33AD0(a1);
	sub_33B20(a1);
	LOBYTE(v1) = sub_33C00(a1);
	v5 = *(x_DWORD *)(a1 + 8) - 1;
	*(x_DWORD *)(a1 + 8) = v5;
	if (v5 < 1)
		*(x_BYTE *)(a1 + 70) = 2;
	return v1;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00033AD0) --------------------------------------------------------
int sub_33AD0(int a1)
{
	int result; // eax
	__int16 v2; // bx
	__int16 v3; // cx
	char v4; // dl
	__int16 v5; // si
	char v6; // dh

	result = a1;
	v2 = *(char *)(a1 + 61) + *(x_WORD *)(a1 + 44);
	v3 = *(x_WORD *)(a1 + 132);
	*(x_WORD *)(a1 + 44) = v2;
	if (v2 <= v3)
	{
		v5 = *(x_WORD *)(a1 + 134);
		if (v2 < v5)
		{
			v6 = *(x_BYTE *)(a1 + 61);
			*(x_WORD *)(a1 + 44) = v5;
			*(x_BYTE *)(a1 + 61) = -v6;
		}
	}
	else
	{
		v4 = *(x_BYTE *)(a1 + 61);
		*(x_WORD *)(a1 + 44) = v3;
		*(x_BYTE *)(a1 + 61) = -v4;
	}
	return result;
}

//----- (00033B20) --------------------------------------------------------
__int16 sub_33B20(int a1)
{
	__int16 v1; // ax
	__int16 v2; // ax
	int i; // eax
	__int16 v4; // ax
	__int16 v5; // ax
	__int16 v6; // ax
	__int16 v7; // ST08_2
	unsigned __int16 v8; // ax
	x_WORD *v9; // ebx

	v1 = *(x_WORD *)(a1 + 28) + 22;
	HIBYTE(v1) &= 7u;
	*(x_WORD *)(a1 + 28) = v1;
	v2 = *(x_WORD *)(a1 + 30) + 16;
	HIBYTE(v2) &= 7u;
	*(x_WORD *)(a1 + 30) = v2;
	for (i = *(unsigned __int16 *)(a1 + 52); ; i = (unsigned __int16)v9[26])
	{
		v9 = (x_WORD *)x_DWORD_EA3E4[i];
		if ((unsigned int)v9 <= x_DWORD_EA3E4[0])
			break;
		v4 = v9[16] + v9[14];
		HIBYTE(v4) &= 7u;
		v9[14] = v4;
		v5 = v9[17] + v9[15];
		HIBYTE(v5) &= 7u;
		v9[15] = v5;
		*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
		*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
		v6 = v9[15] + *(x_WORD *)(a1 + 30);
		HIBYTE(v6) &= 7u;
		v7 = v6;
		v8 = v9[14] + *(x_WORD *)(a1 + 28);
		HIBYTE(v8) &= 7u;
		sub_57FA0((x_WORD*)&x_WORD_EB398, v8, v7, *(x_WORD *)(a1 + 44));
		sub_57CF0((int)v9, (int)&x_WORD_EB398);
	}
	return i;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;

//----- (00033C00) --------------------------------------------------------
int sub_33C00(int a1)
{
	int result; // eax
	unsigned int v2; // ebx

	for (result = *(unsigned __int16 *)(a1 + 52); ; result = *(unsigned __int16 *)(v2 + 52))
	{
		v2 = x_DWORD_EA3E4[result];
		if (v2 <= x_DWORD_EA3E4[0])
			break;
		if (!*(x_BYTE *)(v2 + 68))
		{
			if ((unsigned __int16)sub_10C80(v2, 0, *(x_WORD *)(a1 + 42)))
				sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 3);
		}
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00033C70) --------------------------------------------------------
int sub_33C70(int a1)
{
	unsigned __int16 v1; // dx
	int v2; // eax
	int v3; // esi
	int v4; // edi
	int result; // eax
	int v6; // esi
	int v7; // edi
	int v8; // esi
	char v9; // [esp+4h] [ebp-4h]

	v1 = *(x_WORD *)(a1 + 150);
	v9 = 0;
	if (v1)
	{
		v2 = x_DWORD_EA3E4[v1];
		*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(v2 + 76);
		*(&x_WORD_EB398 + 2) = *(x_WORD *)(v2 + 80);
		v3 = v2;
		x_WORD_EB39C += *(x_WORD *)(v2 + 82);
		sub_57CF0(a1, (int)&x_WORD_EB398);
		if (*(x_DWORD *)(v3 + 8) < 0 || *(x_BYTE *)(v3 + 13) & 4)
			v9 = 1;
	}
	v4 = *(signed __int16 *)(a1 + 44);
	result = sub_10C40((__int16 *)(a1 + 76));
	v6 = v4 + (signed __int16)result;
	if (*(signed __int16 *)(a1 + 80) < v6)
		*(x_WORD *)(a1 + 80) = v6;
	if (x_BYTE_D41B6)
	{
		v7 = *(signed __int16 *)(a1 + 44);
		result = sub_10C60((__int16 *)(a1 + 76));
		v8 = (signed __int16)result - v7;
		if (*(signed __int16 *)(a1 + 80) > v8)
			*(x_WORD *)(a1 + 80) = v8;
	}
	if (v9)
		*(x_BYTE *)(a1 + 70) = 2;
	return result;
}
// D41B6: using guessed type char x_BYTE_D41B6;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (00033D40) --------------------------------------------------------
int sub_33D40(int a1)
{
	int i; // ebx
	unsigned int v2; // ebx

	for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v2 + 52))
	{
		v2 = x_DWORD_EA3E4[i];
		if (v2 <= x_DWORD_EA3E4[0])
			break;
		sub_57F10(v2);
	}
	sub_57F10(a1);
	return 1;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00033D80) --------------------------------------------------------
void sub_33D80(int a1)
{
	int v1; // eax
	__int16 v2; // ax
	char v3; // dl

	v1 = *(x_DWORD *)(a1 + 8);
	++*(x_DWORD *)(a1 + 16);
	*(x_DWORD *)(a1 + 8) = v1 - 1;
	if (v1 >= 0)
	{
		if (!(*(x_BYTE *)(a1 + 12) & 2))
		{
			v2 = sub_10C80(a1, 0, *(x_WORD *)(a1 + 42));
			if (v2)
				sub_6D8B0(*(x_WORD *)(a1 + 26), 7u, v2);
			sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 24);
			v3 = *(x_BYTE *)(a1 + 12);
			*(x_DWORD *)(a1 + 8) = 1;
			*(x_BYTE *)(a1 + 12) = v3 | 2;
		}
	}
	else
	{
		sub_57F10(a1);
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00033E20) --------------------------------------------------------
void sub_33E20(int a1)
{
	int v1; // ecx
	unsigned __int16 v2; // ST08_2

	v1 = *(x_DWORD *)(a1 + 8) - 1;
	++*(x_DWORD *)(a1 + 16);
	*(x_DWORD *)(a1 + 8) = v1;
	if (v1 >= 0)
	{
		if (!(*(x_BYTE *)(a1 + 12) & 2))
		{
			v2 = *(char *)(a1 + 70);
			*(x_BYTE *)(a1 + 12) |= 2u;
			if ((unsigned __int16)sub_10C80(a1, 3u, v2))
				*(x_DWORD *)(a1 + 8) = 0;
		}
	}
	else
	{
		sub_57F10(a1);
	}
}

//----- (00033E80) --------------------------------------------------------
int sub_33E80(int a1)
{
	int v1; // eax
	int result; // eax

	v1 = *(x_DWORD *)(a1 + 8);
	++*(x_DWORD *)(a1 + 16);
	*(x_DWORD *)(a1 + 8) = v1 - 1;
	if (v1 < 0)
	{
		sub_57F10(a1);
		return 1;
	}
	sub_585A0(a1);
	result = sub_10C80(a1, 4u, *(char *)(a1 + 70));
	if ((x_WORD)result)
		*(x_DWORD *)(a1 + 8) = 0;
	return result;
}

//----- (00033F70) --------------------------------------------------------
bool sub_33F70(unsigned __int16 a1)
{
	unsigned __int16 v1; // ax
	signed int v2; // edx
	unsigned __int16 v3; // ax
	bool result; // al

	HIBYTE(v1) = HIBYTE(a1);
	LOBYTE(v1) = a1 - 1;
	result = 1;
	if (x_BYTE_10B4E0[v1] == 8)
	{
		v2 = (unsigned __int16)(x_BYTE_11B4E0[a1] + 30);
		if (x_BYTE_11B4E0[v1] <= (signed int)(unsigned __int16)v2)
		{
			LOBYTE(v1) = v1 + 2;
			if (x_BYTE_11B4E0[v1] <= v2)
			{
				LOBYTE(v3) = v1 - 1;
				HIBYTE(v3) = HIBYTE(a1) + 1;
				if (x_BYTE_11B4E0[v3] <= v2)
				{
					HIBYTE(v3) = HIBYTE(a1) - 1;
					if (x_BYTE_11B4E0[v3] <= v2)
						result = 0;
				}
			}
		}
	}
	return result;
}

//----- (00034000) --------------------------------------------------------
int sub_34000(int a1)
{
	unsigned __int16 v1; // bx
	unsigned __int16 v3; // [esp+0h] [ebp-Ch]
	__int16 i; // [esp+4h] [ebp-8h]
	__int16 v5; // [esp+8h] [ebp-4h]

	LOBYTE(v3) = (unsigned __int16)(*(x_WORD *)(a1 + 76) + 128) >> 8;
	HIBYTE(v3) = (unsigned __int16)(*(x_WORD *)(a1 + 78) + 128) >> 8;
	if (v3 % 2)
		LOBYTE(v3) = v3 + 1;
	LOBYTE(v3) = v3 - *(x_BYTE *)(a1 + 8) + 1;
	v5 = *(x_WORD *)(a1 + 8) + *(x_WORD *)(a1 + 16);
	while (v5)
	{
		HIBYTE(v1) = HIBYTE(v3);
		LOBYTE(v1) = v3 - 1;
		x_BYTE_13B4E0[v1] |= 0x80u;
		LOBYTE(v1) = v3;
		for (i = *(x_WORD *)(a1 + 8); i; i--)
		{
			if (x_BYTE_10B4E0[v1] != 8 || sub_33F70(v1))
				x_BYTE_11B4E0[v1] += 48;
			sub_46180(v1++, 8);
		}
		x_BYTE_13B4E0[v1] |= 0x80u;
		--v5;
		++HIBYTE(v3);
	}
	sub_57F10(a1);
	return 1;
}

//----- (00034110) --------------------------------------------------------
int sub_34110(x_WORD *a1)
{
	unsigned __int16 v1; // bx
	char v3; // [esp+0h] [ebp-Ch]
	char v4; // [esp+1h] [ebp-Bh]
	__int16 i; // [esp+4h] [ebp-8h]
	__int16 v6; // [esp+8h] [ebp-4h]

	v3 = (unsigned __int16)(a1[38] + 128) >> 8;
	v4 = ((unsigned __int16)(a1[39] + 128) >> 8) + 2;
	v6 = a1[4] + a1[8];
	while (v6)
	{
		HIBYTE(v1) = v4;
		LOBYTE(v1) = v3 - 1;
		x_BYTE_13B4E0[v1] |= 0x80u;
		LOBYTE(v1) = v3;
		for (i = a1[4]; i; i--)
		{
			if (x_BYTE_10B4E0[v1] != 8 || sub_33F70(v1))
				x_BYTE_11B4E0[v1] += 48;
			sub_46180(v1++, 8);
		}
		x_BYTE_13B4E0[v1] |= 0x80u;
		--v6;
		--v4;
	}
	sub_57F10((int)a1);
	return 1;
}

//----- (00034210) --------------------------------------------------------
int sub_34210(x_WORD *a1)
{
	int v1; // edx
	int v2; // ebx
	unsigned __int16 v3; // di
	char v4; // cl
	unsigned __int16 v5; // bx
	int v6; // ebx
	__int16 v7; // dx
	unsigned __int16 v8; // di
	char v9; // cl
	int v11; // [esp+0h] [ebp-Ch]
	int v12; // [esp+4h] [ebp-8h]
	__int16 i; // [esp+8h] [ebp-4h]

	LOBYTE(v12) = (unsigned __int16)(a1[38] + 128) >> 8;
	BYTE1(v12) = (unsigned __int16)(a1[39] + 128) >> 8;
	v1 = ((unsigned __int8)v12 + BYTE1(v12)) % 2;
	if (v1)
		LOBYTE(v12) = v12 + 1;
	v2 = v12;
	LOWORD(v1) = a1[8];
	--BYTE1(v2);
	while ((x_WORD)v1)
	{
		v3 = v2;
		--v1;
		v4 = x_BYTE_13B4E0[(unsigned __int16)v2++] | 0x80;
		x_BYTE_13B4E0[v3] = v4;
	}
	for (i = a1[4]; i; i--)
	{
		LOWORD(v1) = a1[8];
		v5 = v12;
		while (1)
		{
			v11 = v1;
			if (!(x_WORD)v1)
				break;
			if (x_BYTE_10B4E0[v5] != 8 || sub_33F70(v5))
				x_BYTE_11B4E0[v5] += 48;
			sub_46180(v5++, 8);
			v1 = v11 - 1;
		}
		++BYTE1(v12);
	}
	v6 = v12;
	v7 = a1[8];
	while (v7)
	{
		v8 = v6;
		--v7;
		v9 = x_BYTE_13B4E0[(unsigned __int16)v6++] | 0x80;
		x_BYTE_13B4E0[v8] = v9;
	}
	sub_57F10((int)a1);
	return 1;
}

//----- (00034330) --------------------------------------------------------
int sub_34330(int a1)
{
	sub_57F10(a1);
	return 1;
}

//----- (00034350) --------------------------------------------------------
int sub_34350(int a1)
{
	sub_57F10(a1);
	return 1;
}

//----- (00034390) --------------------------------------------------------
int sub_34390(int a1)
{
	unsigned int v1; // eax

	v1 = sub_5B070(a1);
	if (v1)
		*(x_DWORD *)(v1 + 8) = 2;
	sub_57F10(a1);
	return 1;
}

//----- (000343C0) --------------------------------------------------------
int sub_343C0(int a1)
{
	unsigned int v1; // eax

	v1 = sub_5B070(a1);
	if (v1)
		*(x_DWORD *)(v1 + 8) = 1;
	sub_57F10(a1);
	return 1;
}

//----- (000343F0) --------------------------------------------------------
int sub_343F0(x_WORD *a1)
{
	unsigned __int16 v1; // bx
	__int16 v2; // di
	__int16 v4; // [esp+0h] [ebp-8h]
	__int16 v5; // [esp+4h] [ebp-4h]

	LOBYTE(v1) = (unsigned __int16)(a1[38] + 128) >> 8;
	HIBYTE(v1) = (unsigned __int16)(a1[39] + 128) >> 8;
	v5 = a1[14];
	v2 = a1[8];
	v4 = a1[15];
	while (v2)
	{
		x_BYTE_13B4E0[v1] = x_BYTE_13B4E0[v1] & 0xF0 | 1;
		--v2;
		sub_462A0(v1, v1);
		LOBYTE(v1) = v5 + v1;
		HIBYTE(v1) += v4;
	}
	sub_57F10((int)a1);
	return 1;
}

//----- (00034480) --------------------------------------------------------
int sub_34480(int a1)
{
	sub_57F10(a1);
	return 1;
}

//----- (000344A0) --------------------------------------------------------
x_WORD *sub_344A0(int a1)
{
	int v1; // eax
	int v3; // eax

	v1 = *(x_DWORD *)(a1 + 8);
	*(x_DWORD *)(a1 + 8) = v1 - 1;
	if (v1 < 0 || sub_104A0(a1 + 76) & 1)
		sub_57F10(a1);
	v3 = sub_4A190(a1 + 76, 10, 11);
	if (v3)
	{
		*(x_WORD *)(v3 + 88) = *(x_WORD *)(a1 + 88);
		*(x_WORD *)(v3 + 26) = *(x_WORD *)(a1 + 26);
		*(x_DWORD *)(v3 + 8) = *(char *)(a1 + 70);
	}
	return sub_57FA0((x_WORD *)(a1 + 76), *(x_WORD *)(a1 + 28), 0, *(x_WORD *)(a1 + 130));
}

//----- (00034520) --------------------------------------------------------
int sub_34520(int a1)
{
	sub_57F10(a1);
	return 1;
}

//----- (00034540) --------------------------------------------------------
int sub_34540(int a1)
{
	int v1; // ebx
	int v2; // eax
	int v3; // edx
	int v4; // esi
	int v5; // edi
	signed int v6; // eax
	signed int v7; // ebx
	signed int v8; // ebx
	signed int v9; // eax
	int v10; // ebx
	int v11; // eax
	unsigned int v12; // ST14_4
	int v13; // ebx
	unsigned int v14; // eax
	int v15; // ebx
	int v16; // ebx
	int v17; // ebx
	unsigned __int8 v18; // ah
	char v19; // dl
	signed int i; // eax
	int v21; // ebx
	int v23; // [esp+0h] [ebp-4Ch]
	__int16 v24; // [esp+4h] [ebp-48h]
	int v25; // [esp+8h] [ebp-44h]
	__int16 v26; // [esp+Ch] [ebp-40h]
	int v27; // [esp+10h] [ebp-3Ch]
	int v28; // [esp+14h] [ebp-38h]
	int v29; // [esp+18h] [ebp-34h]
	int v30; // [esp+1Ch] [ebp-30h]
	unsigned int v31; // [esp+20h] [ebp-2Ch]
	int v32; // [esp+24h] [ebp-28h]
	int v33; // [esp+28h] [ebp-24h]
	int v34; // [esp+2Ch] [ebp-20h]
	int v35; // [esp+30h] [ebp-1Ch]
	int v36; // [esp+34h] [ebp-18h]
	int v37; // [esp+38h] [ebp-14h]
	int v38; // [esp+3Ch] [ebp-10h]
	unsigned __int16 v39; // [esp+40h] [ebp-Ch]
	unsigned __int8 v40; // [esp+44h] [ebp-8h]
	unsigned __int8 v41; // [esp+48h] [ebp-4h]

	v28 = (*(char *)(a1 + 70) >> 4 << 8) + 512;
	v27 = ((*(x_BYTE *)(a1 + 70) & 0xF) << 8) + 512;
	v29 = sub_58490((x_WORD *)(a1 + 76), (x_WORD *)(a1 + 154)) / 0x55;
	v34 = (unsigned __int16)sub_581E0((Bit16u *)(a1 + 76), (Bit16u *)(a1 + 154));
	v33 = 0;
	v25 = *(x_DWORD *)(a1 + 76);
	v26 = *(x_WORD *)(a1 + 80);
	while (v33 < 32)
	{
		LOBYTE(v39) = BYTE1(v25);
		HIBYTE(v39) = HIBYTE(v25);
		v1 = (x_BYTE_11B4E0[v39] + x_BYTE_14B4E0[v39]) / 2;
		if (v1 < 0)
			v1 = 0;
		if (v1 > 254)
			LOBYTE(v1) = -2;
		x_BYTE_F0200[v33++] = v1;
		sub_57FA0((x_WORD*)&v25, v34, 0, 85);
	}
	v30 = 0;
	v23 = *(x_DWORD *)(a1 + 76);
	v24 = *(x_WORD *)(a1 + 80);
	while (v30 < v29)
	{
		v2 = v28 + v30 * ((v27 - v28) / v29);
		v36 = v2 * v2;
		v3 = 2 * v2 + 128;
		v40 = (unsigned __int16)(v23 + 128) >> 8;
		v35 = (unsigned __int8)x_BYTE_F0200[0];
		v4 = v3 >> 8;
		v3 >>= 9;
		v41 = (unsigned __int16)(HIWORD(v23) + 128) >> 8;
		LOBYTE(v37) = v40 - v3;
		BYTE1(v37) = v41 - v3;
		v5 = 0;
		LOWORD(v38) = v37;
		while (v5 < v4)
		{
			v32 = 0;
			v39 = v38;
			while (v4 > v32)
			{
				v6 = abs((unsigned __int8)v39 - v40);
				v7 = v6;
				if (v6 >= 128)
					v7 = abs(v6 - 256);
				v8 = v7 << 8;
				v9 = abs(HIBYTE(v39) - v41);
				if (v9 >= 128)
					v9 = abs(v9 - 256);
				v10 = v8 * v8;
				v11 = (v9 << 8) * (v9 << 8);
				if (v10 + v11 <= v36)
				{
					v12 = v36 - v10 - v11;
					v13 = v35;
					v14 = sub_7277A(v12) >> 5;
					v15 = v13 - v14;
					v31 = v14;
					if (v15 < 0)
						v15 = 0;
					if (v15 > 254)
						v15 = 254;
					if (x_BYTE_11B4E0[v39] > v15)
						sub_570F0(v39, HIBYTE(v39), v15, 0, 0, 1);
					v16 = v31 + v35;
					if ((signed int)(v31 + v35) < 0)
						v16 = 0;
					if (v16 > 254)
						v16 = 254;
					if ((unsigned __int8)x_BYTE_14B4E0[v39] < v16)
						x_BYTE_14B4E0[v39] = v16;
				}
				v17 = v39;
				v18 = x_BYTE_11B4E0[v39];
				if ((unsigned __int8)x_BYTE_14B4E0[v39] > v18)
				{
					x_BYTE_13B4E0[v39] &= 0xF7u;
				}
				else
				{
					v19 = x_BYTE_13B4E0[v39] | 8;
					x_BYTE_14B4E0[v39] = v18 - 1;
					x_BYTE_13B4E0[v17] = v19;
				}
				++v32;
				LOBYTE(v39) = v39 + 1;
			}
			++v5;
			++BYTE1(v38);
		}
		sub_34B00(v37 - 1, BYTE1(v37) - 1, v4 + 1, v4 + 1);
		sub_57FA0((x_WORD*)&v23, v34, 0, 85);
		for (i = 1; i < 32; x_BYTE_F01FE[i] = x_BYTE_F01FF[i])
			++i;
		LOBYTE(v39) = BYTE1(v25);
		HIBYTE(v39) = HIBYTE(v25);
		v21 = (x_BYTE_11B4E0[v39] + x_BYTE_14B4E0[v39]) / 2;
		if (v21 < 0)
			v21 = 0;
		if (v21 > 254)
			LOBYTE(v21) = -2;
		x_BYTE_F021F = v21;
		++v30;
		sub_57FA0((x_WORD*)&v25, v34, 0, 85);
	}
	sub_57F10(a1);
	return 1;
}
// F021F: using guessed type char x_BYTE_F021F;

//----- (00034910) --------------------------------------------------------
int sub_34910(int a1)
{
	int v1; // ebx
	int v2; // esi
	int v3; // ecx
	int v4; // edi
	int v5; // ebx
	int v6; // eax
	int v7; // eax
	unsigned __int8 v8; // dh
	char v9; // cl
	signed int v11; // [esp+8h] [ebp-1Ch]
	signed int v12; // [esp+Ch] [ebp-18h]
	int v13; // [esp+10h] [ebp-14h]
	int v14; // [esp+14h] [ebp-10h]
	int v15; // [esp+18h] [ebp-Ch]
	unsigned __int16 v16; // [esp+1Ch] [ebp-8h]
	unsigned __int16 v17; // [esp+20h] [ebp-4h]

	v13 = 3 * *(char *)(a1 + 70);
	v1 = *(char *)(a1 + 67);
	v2 = 2 * v1;
	v5 = (*(signed __int16 *)(a1 + 76) >> 8) - v1;
	v3 = *(char *)(a1 + 68);
	v4 = 2 * v3;
	BYTE1(v5) = (*(x_WORD *)(a1 + 78) >> 8) - v3;
	v11 = sub_48E60((unsigned __int8)v5, BYTE1(v5), v2, 2 * v3);
	v16 = v5;
	v12 = sub_48E90((unsigned __int8)v5, BYTE1(v5), v2, v4);
	v14 = 0;
	while (v4 > v14)
	{
		v15 = 0;
		v17 = v16;
		while (v2 > v15)
		{
			v6 = v11 - v13;
			if (v11 - v13 < 0)
				v6 = 0;
			if (v6 > 254)
				v6 = 254;
			if (x_BYTE_11B4E0[v17] > v6)
				sub_570F0((unsigned __int8)v17, HIBYTE(v16), v6, 0, 0, 0);
			v7 = v13 + v12;
			if (v13 + v12 < 0)
				v7 = 0;
			if (v7 > 254)
				v7 = 254;
			if (v7 > (unsigned __int8)x_BYTE_14B4E0[v17])
				x_BYTE_14B4E0[v17] = v7;
			v8 = x_BYTE_11B4E0[v17];
			if ((unsigned __int8)x_BYTE_14B4E0[v17] > v8)
			{
				x_BYTE_13B4E0[v17] &= 0xF7u;
			}
			else
			{
				v9 = x_BYTE_13B4E0[v17] | 8;
				x_BYTE_14B4E0[v17] = v8 - 1;
				x_BYTE_13B4E0[v17] = v9;
			}
			++v15;
			LOBYTE(v17) = v17 + 1;
		}
		++v14;
		++HIBYTE(v16);
	}
	sub_34B00(v5 - 1, BYTE1(v5) - 1, v2 + 1, v4 + 1);
	sub_43C60(v5, SBYTE1(v5), (unsigned __int16)v2, (unsigned __int16)v4);
	sub_57F10(a1);
	return 1;
}

//----- (00034B00) --------------------------------------------------------
int sub_34B00(char a1, char a2, __int16 a3, __int16 a4)
{
	unsigned __int16 v4; // bx
	char v5; // dl
	int v6; // eax
	char v7; // ch
	int result; // eax
	unsigned __int16 v9; // bx
	char v10; // dl
	int v11; // eax
	char v12; // ch
	signed int v13; // [esp+0h] [ebp-Ch]
	signed int i; // [esp+4h] [ebp-8h]

	for (i = 0; a3 > i; i++)
	{
		HIBYTE(v4) = a2;
		LOBYTE(v4) = i + a1;
		v5 = x_BYTE_13B4E0[v4];
		if (v5 & 8)
		{
			x_BYTE_13B4E0[v4] = v5 & 0xF8 | 1;
			x_BYTE_10B4E0[v4] = 1;
			sub_462A0(v4, v4);
		}
		HIWORD(v6) = 0;
		HIBYTE(v4) = a4 + a2;
		LOWORD(v6) = v4;
		v7 = x_BYTE_13B4E0[v4];
		if (v7 & 8)
		{
			x_BYTE_13B4E0[v6] = v7 & 0xF8 | 1;
			sub_462A0(v4, v4);
		}
	}
	v13 = 0;
	for (result = a4; a4 > v13; result = a4)
	{
		LOBYTE(v9) = a1;
		HIBYTE(v9) = v13 + a2;
		v10 = x_BYTE_13B4E0[v9];
		if (v10 & 8)
		{
			x_BYTE_13B4E0[v9] = v10 & 0xF8 | 1;
			x_BYTE_10B4E0[v9] = 1;
			sub_462A0(v9, v9);
		}
		HIWORD(v11) = 0;
		LOBYTE(v9) = a3 + v9;
		LOWORD(v11) = v9;
		v12 = x_BYTE_13B4E0[v9];
		if (v12 & 8)
		{
			x_BYTE_13B4E0[v11] = v12 & 0xF8 | 1;
			sub_462A0(v9, v9);
		}
		++v13;
	}
	return result;
}

//----- (00034C40) --------------------------------------------------------
char sub_34C40(int a1)
{
	int v1; // edx
	int v2; // eax
	int v3; // esi
	unsigned __int8 v4; // cl
	unsigned __int8 v5; // dl
	__int16 v6; // di
	signed int v7; // edi
	signed int v8; // eax
	int v9; // ecx
	int v10; // ecx
	__int16 v12; // [esp+0h] [ebp-40h]
	__int16 v13; // [esp+2h] [ebp-3Eh]
	int v14; // [esp+8h] [ebp-38h]
	int v15; // [esp+Ch] [ebp-34h]
	int v16; // [esp+10h] [ebp-30h]
	int v17; // [esp+14h] [ebp-2Ch]
	int v18; // [esp+18h] [ebp-28h]
	int v19; // [esp+1Ch] [ebp-24h]
	int v20; // [esp+20h] [ebp-20h]
	int v21; // [esp+24h] [ebp-1Ch]
	int v22; // [esp+28h] [ebp-18h]
	int v23; // [esp+2Ch] [ebp-14h]
	int v24; // [esp+30h] [ebp-10h]
	int v25; // [esp+34h] [ebp-Ch]
	unsigned __int16 i; // [esp+38h] [ebp-8h]
	int v27; // [esp+3Ch] [ebp-4h]

	v1 = *(x_DWORD *)(a1 + 8) - 1;
	*(x_DWORD *)(a1 + 8) = v1;
	if (v1 <= 0)
	{
		sub_57F10(a1);
	}
	else
	{
		v2 = *(signed __int16 *)(a1 + 154);
		v3 = 2 * v2;
		v4 = ((unsigned __int16)(*(x_WORD *)(a1 + 76) + 128) >> 8) - v2;
		BYTE1(v27) = ((unsigned __int16)(*(x_WORD *)(a1 + 78) + 128) >> 8) - v2;
		v5 = *(x_BYTE *)(a1 + 70);
		LOBYTE(v27) = v4;
		if (v5 < 1u)
		{
			if (!v5)
			{
				v6 = v4;
				v21 = BYTE1(v27);
				*(x_WORD *)(a1 + 80) = sub_48E60(v4, BYTE1(v27), v3, v3);
				LOWORD(v2) = sub_48EF0(v6, v21, v3, v3);
				*(x_WORD *)(a1 + 158) = v2;
				LOBYTE(v2) = ((signed __int16)v2 - *(signed __int16 *)(a1 + 80) <= 0) + 1;
				*(x_BYTE *)(a1 + 70) = v2;
			}
		}
		else if (v5 <= 1u)
		{
			v7 = v2 << 8;
			v23 = *(signed __int16 *)(a1 + 80);
			v2 = *(signed __int16 *)(a1 + 158);
			v24 = v2;
			v17 = 192 * v7 >> 8;
			v14 = v2 - v23;
			LOBYTE(v2) = v27;
			v20 = 0;
			for (i = v27; v3 > v20; ++HIBYTE(i))
			{
				v19 = 0;
				LOBYTE(v2) = v27;
				LOBYTE(i) = v27;
				while (v3 > v19)
				{
					v12 = (unsigned __int8)i << 8;
					v13 = HIBYTE(i) << 8;
					v16 = 0;
					v8 = sub_58490((x_WORD *)(a1 + 76), &v12);
					v15 = v8;
					if (v8 < v7)
					{
						v22 = x_BYTE_11B4E0[i];
						v25 = x_BYTE_14B4E0[i];
						v18 = v14 * ((x_DWORD)((x_DWORD)sub_10000 + (signed int)off_DBF50[(v8 << 10) / v7]) >> 1) >> 16;
						v9 = v18 + v23;
						if (v18 + v23 > 254)
							v9 = 254;
						if (v9 > v22)
							sub_570F0(
							(unsigned __int8)i,
								HIBYTE(i),
								(unsigned int)((v9 - v22) / *(x_DWORD *)(a1 + 8)) + v22,
								0,
								v15 <= v17,
								1);
						v10 = v16 + v24 - v18;
						if (v10 < 0)
							v10 = 0;
						if (v10 < v25)
							x_BYTE_14B4E0[i] = v25 - (unsigned int)((v25 - v10) / *(x_DWORD *)(a1 + 8));
						if ((unsigned __int8)x_BYTE_14B4E0[i] > x_BYTE_11B4E0[i])
							x_BYTE_13B4E0[i] &= 0xF7u;
						else
							x_BYTE_13B4E0[i] |= 8u;
					}
					LOBYTE(v2) = v19++ + 1;
					LOBYTE(i) = i + 1;
				}
				++v20;
			}
		}
		else if (v5 == 2)
		{
			*(x_DWORD *)(a1 + 8) = 0;
		}
	}
	return v2;
}
// 10000: using guessed type void /*__noreturn*/ sub_10000();
// DBF50: using guessed type void (/*__noreturn*/ *off_DBF50[2])();

//----- (00034EE0) --------------------------------------------------------
void sub_34EE0(signed int a1, int a2, int a3)
{
	int v3; // edx
	int v4; // eax
	int v5; // ecx
	int v6; // edx
	unsigned __int8 v7; // dl
	unsigned __int8 v8; // al
	__int16 v9; // dx
	unsigned int v10; // esi
	char v11; // ah
	__int16 v12; // di
	int v13; // edi
	int v14; // esi
	signed int v15; // eax
	int v16; // ecx
	unsigned __int8 v17; // al
	int v18; // ecx
	int v19; // ecx
	int v20; // eax
	int v21; // eax
	int v22; // ecx
	int v23; // ecx
	int v24; // eax
	int v25; // ecx
	unsigned __int8 v26; // dl
	char v27; // dh
	__int16 v28; // [esp+0h] [ebp-34h]
	__int16 v29; // [esp+2h] [ebp-32h]
	int v30; // [esp+8h] [ebp-2Ch]
	int v31; // [esp+Ch] [ebp-28h]
	int v32; // [esp+10h] [ebp-24h]
	int v33; // [esp+14h] [ebp-20h]
	int v34; // [esp+18h] [ebp-1Ch]
	int v35; // [esp+1Ch] [ebp-18h]
	int v36; // [esp+20h] [ebp-14h]
	int v37; // [esp+24h] [ebp-10h]
	int v38; // [esp+28h] [ebp-Ch]
	unsigned int v39; // [esp+2Ch] [ebp-8h]
	unsigned __int16 i; // [esp+30h] [ebp-4h]

	v3 = *(x_DWORD *)(a3 + 8) - 1;
	*(x_DWORD *)(a3 + 8) = v3;
	if (v3 <= 0)
	{
		sub_57F10(a3);
	}
	else
	{
		v4 = *(signed __int16 *)(a3 + 154);
		v5 = *(signed __int16 *)(a3 + 78);
		v38 = 2 * v4;
		v6 = (*(signed __int16 *)(a3 + 76) + 128) >> 8;
		v36 = (v5 + 128) >> 8;
		LOBYTE(v39) = v6 - v4;
		BYTE1(v39) = v36 - v4;
		v7 = *(x_BYTE *)(a3 + 70);
		if (v7 < 1u)
		{
			if (!v7)
			{
				v8 = *(x_BYTE *)(a3 + 64);
				if (v8 >= 0x54u)
				{
					if (v8 <= 0x54u)
					{
						v37 = BYTE1(v39);
						v36 = (unsigned __int8)v39;
						a1 = sub_48EF0((unsigned __int8)v39, BYTE1(v39), v38, v38);
						a2 = a1 - sub_48E90((unsigned __int8)v39, BYTE1(v39), v38, v38) - 1;
					}
					else if (v8 == 85)
					{
						v36 = BYTE1(v39);
						v37 = (unsigned __int8)v39;
						a1 = sub_48E60((unsigned __int8)v39, BYTE1(v39), v38, v38);
						a2 = sub_48EC0((unsigned __int8)v39, BYTE1(v39), v38, v38) - a1 - 1;
					}
				}
				if (a2 <= 0)
				{
					*(x_BYTE *)(a3 + 70) = 2;
				}
				else
				{
					v9 = *(x_WORD *)(a3 + 80);
					if (v9)
					{
						v10 = (51 * v9 * a2 - (__CFSHL__(51 * v9 * a2 >> 31, 8) + (51 * v9 * a2 >> 31 << 8))) >> 8;
					}
					else
					{
						*(x_WORD *)(a3 + 20) = 9377 * *(x_WORD *)(a3 + 20) + 9439;
						v10 = *(unsigned __int16 *)(a3 + 20) % (unsigned int)a2;
					}
					v11 = *(x_BYTE *)(a3 + 64);
					*(x_WORD *)(a3 + 158) = a1;
					if (v11 == 84)
						v12 = a1 - v10;
					else
						v12 = v10 + a1;
					*(x_WORD *)(a3 + 80) = v12;
					*(x_BYTE *)(a3 + 70) = 1;
				}
			}
		}
		else if (v7 <= 1u)
		{
			v35 = v4 << 8;
			v13 = *(signed __int16 *)(a3 + 158);
			v14 = abs(*(signed __int16 *)(a3 + 80) - v13);
			v34 = 0;
			v30 = 49152 * v4 >> 8;
			for (i = v39; v34 < v38; ++HIBYTE(i))
			{
				v33 = 0;
				LOBYTE(i) = v39;
				while (v33 < v38)
				{
					v28 = (unsigned __int8)i << 8;
					v29 = HIBYTE(i) << 8;
					v15 = sub_58490((x_WORD *)(a3 + 76), &v28);
					v31 = v15;
					if (v15 < v35)
					{
						v16 = v14 * ((x_DWORD)((x_DWORD)sub_10000 + (signed int)off_DBF50[(v15 << 10) / v35]) >> 1);
						v17 = *(x_BYTE *)(a3 + 64);
						v18 = v16 >> 16;
						if (v17 >= 0x54u)
						{
							if (v17 <= 0x54u)
							{
								v19 = v13 - v18;
								if (v19 < 0)
									v19 = 0;
								v32 = i;
								v20 = (unsigned __int8)x_BYTE_14B4E0[i];
								v37 = v20;
								v21 = (v20 - v19) / *(x_DWORD *)(a3 + 8);
								if (v37 - v21 < v37)
									x_BYTE_14B4E0[v32] = v37 - v21;
							}
							else if (v17 == 85)
							{
								v22 = v13 + v18;
								if (v22 > 254)
									v22 = 254;
								v23 = v22 - x_BYTE_11B4E0[i];
								v37 = x_BYTE_11B4E0[i];
								v24 = v23 / *(x_DWORD *)(a3 + 8);
								if (v24 + v37 > v37)
									sub_570F0((unsigned __int8)i, HIBYTE(i), v24 + v37, 0, v31 <= v30, 1);
							}
						}
						v25 = i;
						v26 = x_BYTE_11B4E0[i];
						if ((unsigned __int8)x_BYTE_14B4E0[i] > v26)
						{
							x_BYTE_13B4E0[i] &= 0xF7u;
						}
						else
						{
							v27 = x_BYTE_13B4E0[i] | 8;
							x_BYTE_14B4E0[i] = v26 - 1;
							x_BYTE_13B4E0[v25] = v27;
						}
					}
					++v33;
					LOBYTE(i) = i + 1;
				}
				++v34;
			}
		}
		else if (v7 == 2)
		{
			if (*(x_BYTE *)(a3 + 64) == 84)
				sub_43C60(v39, SBYTE1(v39), (unsigned __int16)v38, (unsigned __int16)v38);
			*(x_DWORD *)(a3 + 8) = 0;
		}
	}
}
// 10000: using guessed type void /*__noreturn*/ sub_10000();
// DBF50: using guessed type void (/*__noreturn*/ *off_DBF50[2])();

//----- (000352A0) --------------------------------------------------------
int sub_352A0(int a1)
{
	sub_57F10(a1);
	return 1;
}

//----- (000352C0) --------------------------------------------------------
x_WORD *sub_352C0(int a1)
{
	int v1; // edx

	v1 = *(x_DWORD *)(a1 + 8);
	*(x_DWORD *)(a1 + 8) = v1 - 1;
	if (v1 < 0 || sub_104A0(a1 + 76) & 1)
		sub_57F10(a1);
	*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
	if (!sub_572C0((signed __int16 *)a1, 0, 1024, *(x_WORD *)(a1 + 20) % 0xFu + 10, 0))
	{
		sub_10C80(a1, 0, *(x_WORD *)(a1 + 42));
		sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 10);
	}
	return sub_57FA0((x_WORD *)(a1 + 76), *(x_WORD *)(a1 + 28), 0, *(x_WORD *)(a1 + 130));
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00035390) --------------------------------------------------------
void sub_35390(int a1)
{
	Bit8u* v1; // eax
	int v2; // edx
	Bit8u* v3; // edi
	int v4; // esi
	__int16 v5; // ax
	int v6; // ST0C_4
	__int16 v7; // ax
	int v8; // edx
	__int16 *v9; // [esp+8h] [ebp-8h]
	unsigned __int16 i; // [esp+Ch] [ebp-4h]

	if (!(*(x_BYTE *)(a1 + 12) & 2))
	{
		v1 = x_D41A0_BYTEARRAY_0 + 28302;
		*(x_BYTE *)(a1 + 12) |= 2u;
		sub_6E450((a1 - (int)v1) / 168, -1, 21);
	}
	v2 = *(x_DWORD *)(a1 + 8);
	if (v2 <= 0 || (*(x_DWORD *)(a1 + 8) = v2 - 1, v2 != 1))
	{
		v3 = x_D41A0_BYTEARRAY_0 + 11230;
		for (i = 0; ; i++)
		{
			v9 = (__int16 *)(a1 + 76);
			if (*(x_WORD *)(x_D41A0_BYTEARRAY_0 + 14) <= i)
				break;
			v4 = x_DWORD_EA3E4[*(unsigned __int16 *)(v3 + 10)];
			if (sub_106C0(a1, x_DWORD_EA3E4[*(unsigned __int16 *)(v3 + 10)]))
			{
				v5 = sub_581E0((Bit16u *)(v4 + 76), (Bit16u *)v9);
				if ((unsigned __int16)sub_582B0(*(x_WORD *)(v4 + 28), v5) < 0xAAu)
				{
					v6 = *(x_DWORD *)(a1 + 160);
					v7 = sub_10C40((__int16 *)(a1 + 154));
					v8 = (int)x_D41A0_BYTEARRAY_0;
					*(x_WORD *)(a1 + 158) = *(x_WORD *)(v6 + 12) + v7;
					sub_6E450((a1 - (v8 + 28302)) / 168, -1, 22);
					sub_57CF0(v4, a1 + 154);
					sub_5C800(v4, 6);
				}
			}
			v3 += 2124;
		}
		*(x_WORD *)(a1 + 80) = sub_10C40(v9);
	}
	else
	{
		sub_57F10(a1);
		sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 20);
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00035530) --------------------------------------------------------
unsigned int sub_35530(int a1)
{
	unsigned int result; // eax
	__int16 v2; // ax
	__int16 v3; // ax

	result = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
	if (result > x_DWORD_EA3E4[0])
	{
		if (*(x_DWORD *)(result + 8) == 1)
		{
			sub_57F10(a1);
		}
		else
		{
			*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(result + 76);
			*(&x_WORD_EB398 + 2) = *(x_WORD *)(result + 80);
			sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), *(x_WORD *)(a1 + 30), *(x_WORD *)(a1 + 130));
			v2 = *(x_WORD *)(a1 + 28) + 45;
			HIBYTE(v2) &= 7u;
			*(x_WORD *)(a1 + 28) = v2;
			v3 = sub_10C40(&x_WORD_EB398);
			++HIBYTE(v3);
			x_WORD_EB39C = v3;
			result = sub_57CF0(a1, (int)&x_WORD_EB398);
		}
	}
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (00035600) --------------------------------------------------------
int sub_35600(int a1)
{
	int result; // eax
	int v2; // edx
	char v3; // dl

	result = a1;
	++*(x_DWORD *)(result + 16);
	v2 = *(x_DWORD *)(a1 + 8);
	*(x_DWORD *)(a1 + 8) = v2 - 1;
	if (v2 < 0)
	{
		sub_57F10(a1);
		return 1;
	}
	v3 = *(x_BYTE *)(a1 + 12);
	if (!(v3 & 2))
		*(x_BYTE *)(a1 + 12) = v3 | 2;
	return result;
}

//----- (00035640) --------------------------------------------------------
void sub_35640(int a1)
{
	signed __int16 v1; // si
	__int16 v2; // dx
	int v3; // eax
	__int16 v4; // ax
	__int16 v5; // ax
	int v6; // ST08_4
	int v7; // ST04_4
	int v8; // eax
	int v9; // ecx
	__int16 v10; // ax
	signed int v11; // [esp+0h] [ebp-4h]

	v1 = 0;
	v2 = sub_10C40((__int16 *)(a1 + 76));
	if (*(signed __int16 *)(a1 + 80) < v2 + 1024)
	{
		v1 = 1;
		*(x_WORD *)(a1 + 80) += 64;
	}
	if (*(signed __int16 *)(a1 + 80) > v2 + 1024)
	{
		HIBYTE(v2) += 4;
		v1 = 1;
		*(x_WORD *)(a1 + 80) = v2;
	}
	if (!v1)
	{
		v3 = *(x_DWORD *)(a1 + 8);
		*(x_DWORD *)(a1 + 8) = v3 - 1;
		if (v3 >= 0)
		{
			v4 = 9377 * *(x_WORD *)(a1 + 20);
			*(x_WORD *)(a1 + 30) = 56;
			*(x_WORD *)(a1 + 20) = v4 + 9439;
			v11 = 0;
			*(x_WORD *)(a1 + 28) = *(x_WORD *)(a1 + 20) & 0x7FF;
			do
			{
				v5 = *(x_WORD *)(a1 + 28);
				HIBYTE(v5) = (HIBYTE(v5) + 4) & 7;
				*(x_WORD *)(a1 + 28) = v5;
				*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
				*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
				v6 = *(char *)(a1 + 68);
				v7 = *(char *)(a1 + 67);
				x_WORD_EB39C += *(x_WORD *)(a1 + 82);
				v8 = sub_4A190(a1 + 76, v7, v6);
				v9 = v8;
				if (v8)
				{
					*(x_WORD *)(v8 + 26) = *(x_WORD *)(a1 + 26);
					*(x_DWORD *)(v8 + 8) /= 3;
					*(x_WORD *)(v8 + 28) = *(x_WORD *)(a1 + 28);
					*(x_WORD *)(v8 + 30) = *(x_WORD *)(a1 + 30);
					v10 = *(x_WORD *)(a1 + 42);
					*(x_BYTE *)(v9 + 67) = 10;
					*(x_BYTE *)(v9 + 68) = 23;
					*(x_WORD *)(v9 + 42) = v10;
					if (!v11)
						sub_6E450((v9 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 23);
				}
				++v11;
			} while (v11 < 2);
		}
		else
		{
			sub_57F10(a1);
		}
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (000357C0) --------------------------------------------------------
int sub_357C0(int a1)
{
	signed __int16 v1; // bx
	unsigned __int16 v2; // cx
	unsigned int i; // eax
	int v4; // eax
	int v5; // ecx
	int v7; // [esp+0h] [ebp-10h]
	unsigned __int16 v8; // [esp+4h] [ebp-Ch]
	__int16 v9; // [esp+8h] [ebp-8h]
	int v10; // [esp+Ch] [ebp-4h]

	*(x_WORD *)(a1 + 42) = 10000;
	if (*(x_WORD *)(a1 + 42))
	{
		v1 = sub_4A810();
		if (v1 < 0)
			v1 = 0;
		if (v1 > 8)
			v1 = 8;
		v2 = 0;
		for (i = x_D41A0_BYTEARRAY_4[38439]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
		{
			if (*(unsigned __int16 *)(i + 148) == *(signed __int16 *)(a1 + 26))
				++v2;
		}
		if (v1 < 0)
			v1 = 0;
		if (v1 > 64 - v2)
			v1 = 64 - v2;
		if (v1 > 0)
		{
			HIWORD(v4) = HIWORD(a1);
			LOWORD(v4) = *(x_WORD *)(a1 + 42);
			v7 = v4;
			v10 = (signed __int16)v4 / v1;
			v9 = 2048 / v1;
			v8 = 0;
			while (v1 > 0)
			{
				*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
				*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
				sub_57FA0((x_WORD*)&x_WORD_EB398, v8, 0, 512);
				v5 = sub_4A190((int)&x_WORD_EB398, 5, 9);
				if (v5)
				{
					*(x_DWORD *)(v5 + 144) = (signed __int16)v7 % (signed __int16)v10;
					*(x_WORD *)(v5 + 148) = *(x_WORD *)(a1 + 26);
					*(x_WORD *)(v5 + 26) = *(x_WORD *)(a1 + 26);
					*(x_WORD *)(v5 + 32) = __PAIR__(HIBYTE(v8) + 4, (unsigned __int8)v8) & 0x7FF;
					*(x_WORD *)(v5 + 28) = __PAIR__(HIBYTE(v8) + 4, (unsigned __int8)v8) & 0x7FF;
					v7 -= v10;
				}
				--v1;
				v8 += v9;
			}
		}
	}
	sub_57F10(a1);
	return 1;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;

//----- (00035940) --------------------------------------------------------
void sub_35940(int a1)
{
	char v1; // dh
	__int16 v2; // dx
	__int16 v3; // ax
	__int16 v4; // ax
	unsigned __int16 v5; // si
	__int16 v6; // ST0C_2
	unsigned __int16 v7; // ST04_2
	int v8; // eax
	char v9; // dl
	unsigned __int16 v10; // ax
	signed int v11; // eax
	x_WORD *v12; // eax
	__int16 v13; // si
	__int16 v14; // ax
	__int16 v15; // cx
	__int16 v16; // ax
	__int16 v17; // t0
	signed int v18; // eax
	__int16 v19; // ax
	__int16 v20; // dx
	__int16 v21; // cx
	__int16 v22; // si
	int v23; // eax
	__int16 v24; // cx
	int v25; // eax
	int v26; // eax
	int v27; // edx
	unsigned int v28; // eax
	char v29; // cl
	int v30; // [esp+0h] [ebp-1Ch]
	unsigned __int16 v31; // [esp+4h] [ebp-18h]
	signed int v32; // [esp+8h] [ebp-14h]
	signed __int16 v33; // [esp+Ch] [ebp-10h]
	char v34; // [esp+10h] [ebp-Ch]
	char v35; // [esp+14h] [ebp-8h]
	char v36; // [esp+18h] [ebp-4h]

	v1 = *(x_BYTE *)(a1 + 13);
	v35 = 0;
	v36 = 0;
	if (v1 & 8)
	{
		*(x_BYTE *)(a1 + 13) = v1 & 0xF7;
	}
	else
	{
		v2 = *(x_WORD *)(a1 + 104);
		if (v2)
		{
			if (v2 != *(x_WORD *)(a1 + 148))
			{
				v36 = 1;
				if (*(x_DWORD *)(a1 + 100))
				{
					v4 = *(x_WORD *)(a1 + 104);
					*(x_WORD *)(a1 + 148) = v4;
					sub_6E450(v4, -1, 4);
					*(x_DWORD *)(a1 + 12) &= 0xFFDFFFBF;
					*(x_BYTE *)(a1 + 14) |= 0x20u;
				}
				else if (!(*(x_BYTE *)(a1 + 14) & 0x20))
				{
					v3 = *(x_WORD *)(a1 + 104);
					*(x_WORD *)(a1 + 148) = v3;
					sub_6E450(v3, -1, 4);
					*(x_BYTE *)(a1 + 12) &= 0xBFu;
				}
			}
			*(x_WORD *)(a1 + 104) = 0;
			*(x_DWORD *)(a1 + 100) = 0;
		}
		v5 = *(x_WORD *)(a1 + 122);
		if (v5)
		{
			v35 = 1;
			*(x_WORD *)(a1 + 28) = sub_581E0((Bit16u *)(a1 + 76), (Bit16u *)(x_DWORD_EA3E4[v5] + 76));
			v6 = *(x_WORD *)(a1 + 118);
			v7 = *(x_WORD *)(a1 + 28);
			x_WORD_EB398 = 0;
			x_WORD_EB39A = 0;
			x_WORD_EB39C = 0;
			sub_57FA0((x_WORD*)&x_WORD_EB398, v7, 0, v6);
			*(x_WORD *)(a1 + 154) = x_WORD_EB398;
			*(x_WORD *)(a1 + 156) = x_WORD_EB39A;
			*(x_WORD *)(a1 + 122) = 0;
		}
		if (*(x_BYTE *)(a1 + 12) & 0x40)
		{
			v8 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
			v9 = 1;
			if (*(x_BYTE *)(v8 + 63) != 3 || 3 != *(x_BYTE *)(v8 + 64))
			{
				if (*(x_BYTE *)(v8 + 63) == 5 && *(x_BYTE *)(v8 + 64) == 23)
				{
					v9 = 0;
					v33 = *(x_WORD *)(v8 + 44);
				}
			}
			else
			{
				v9 = 0;
				v33 = 32;
			}
			if (v9)
			{
				*(x_BYTE *)(a1 + 12) &= 0xBFu;
			}
			else
			{
				v10 = *(x_WORD *)(a1 + 150);
				*(x_WORD *)(a1 + 44) = 128;
				*(x_WORD *)(a1 + 28) = sub_581E0((Bit16u *)(a1 + 76), (Bit16u *)(x_DWORD_EA3E4[v10] + 76));
				v11 = sub_58490((x_WORD *)(a1 + 76), (x_WORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)] + 76));
				if (v11 <= 1024)
				{
					if (v11 >= 16)
					{
						*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
						*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
						sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), 0, 16);
					}
					else
					{
						*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
						*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
						v12 = (x_WORD *)x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
						x_WORD_EB398 = v12[38];
						v13 = v12[40];
						x_WORD_EB39A = v12[39];
						if (x_WORD_EB39C >= v13)
						{
							if (x_WORD_EB39C > v13 + 512)
								x_WORD_EB39C -= v33;
						}
						else
						{
							x_WORD_EB39C += v33;
						}
					}
					v14 = sub_10C40(&x_WORD_EB398);
					if (v14 > x_WORD_EB39C)
						x_WORD_EB39C = v14;
					sub_57CF0(a1, (int)&x_WORD_EB398);
				}
				else
				{
					*(x_BYTE *)(a1 + 12) &= 0xBFu;
				}
			}
		}
		else if (*(x_BYTE *)(a1 + 57) || v35)
		{
			if (*(signed __int16 *)(a1 + 154) < -64)
				*(x_WORD *)(a1 + 154) = -64;
			if (*(x_WORD *)(a1 + 154) > 64)
				*(x_WORD *)(a1 + 154) = 64;
			if (*(signed __int16 *)(a1 + 156) < -64)
				*(x_WORD *)(a1 + 156) = -64;
			if (*(x_WORD *)(a1 + 156) > 64)
				*(x_WORD *)(a1 + 156) = 64;
			*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
			*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
			v15 = *(x_WORD *)(a1 + 156);
			x_WORD_EB398 = *(x_WORD *)(a1 + 154) + *(x_WORD *)(a1 + 76);
			x_WORD_EB39A = v15 + *(x_WORD *)(a1 + 78);
			v16 = *(x_WORD *)(a1 + 44);
			x_WORD_EB39C += v16;
			*(x_WORD *)(a1 + 44) = v16 - 16;
			if ((signed __int16)(v16 - 16) < -128)
				*(x_WORD *)(a1 + 44) = -128;
			if (x_BYTE_D41B6 && sub_11E70(a1, &x_WORD_EB398))
			{
				if (v35)
				{
					*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
					*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
				}
				else
				{
					v17 = *(x_WORD *)(a1 + 130);
					*(x_WORD *)(a1 + 130) = 256;
					v32 = 170;
					v34 = 0;
					v30 = 1;
					while (v32 <= 1024)
					{
						*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
						*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
						v31 = (v30 * v32 + *(x_WORD *)(a1 + 28) + 512) & 0x7FF;
						sub_57FA0((x_WORD*)&x_WORD_EB398, v31, 0, *(x_WORD *)(a1 + 130));
						x_WORD_EB39C = sub_10C40(&x_WORD_EB398);
						if (!sub_11E70(a1, &x_WORD_EB398))
						{
							v34 = 1;
							break;
						}
						v30 = -v30;
						if (v30 == 1)
							v18 = 170;
						else
							v18 = 0;
						v32 += v18;
					}
					if (v34)
					{
						*(x_WORD *)(a1 + 32) = v31;
						*(x_WORD *)(a1 + 28) = v31;
					}
					else
					{
						*(x_WORD *)(a1 + 154) = 64;
						v19 = *(x_WORD *)(a1 + 76);
						v20 = *(x_WORD *)(a1 + 154);
						*(x_WORD *)(a1 + 156) = 64;
						v21 = *(x_WORD *)(a1 + 156);
						x_WORD_EB398 = v20 + v19;
						x_WORD_EB39A = v21 + *(x_WORD *)(a1 + 78);
					}
				}
				*(x_WORD *)(a1 + 44) = -128;
			}
			v22 = sub_10C40(&x_WORD_EB398);
			if (v22 > x_WORD_EB39C)
			{
				v23 = -((*(signed __int16 *)(a1 + 44)
					- (__CFSHL__(*(signed __int16 *)(a1 + 44) >> 31, 2)
						+ 4 * (*(signed __int16 *)(a1 + 44) >> 31))) >> 2);
				*(x_WORD *)(a1 + 44) = v23;
				if ((signed __int16)v23 <= 16)
					*(x_WORD *)(a1 + 44) = 0;
				x_WORD_EB39C = v22;
			}
			if (x_BYTE_D41B6)
			{
				v24 = sub_10C60(&x_WORD_EB398) - *(x_WORD *)(a1 + 88);
				if (v24 < x_WORD_EB39C)
				{
					*(x_WORD *)(a1 + 44) = -abs(*(signed __int16 *)(a1 + 44));
					x_WORD_EB39C = v24;
				}
			}
			sub_57CF0(a1, (int)&x_WORD_EB398);
			if (v22 == x_WORD_EB39C)
			{
				v25 = sub_10A50(a1);
				if (v25 && !(*(x_BYTE *)(a1 + 13) & 0x20))
					sub_36D50(a1, v25);
				sub_58030(a1 + 76, &x_WORD_EB398);
				*(x_WORD *)(a1 + 154) += x_WORD_EB398;
				v26 = (250 * *(signed __int16 *)(a1 + 154)
					- (__CFSHL__(250 * *(signed __int16 *)(a1 + 154) >> 31, 8)
						+ (250 * *(signed __int16 *)(a1 + 154) >> 31 << 8))) >> 8;
				*(x_WORD *)(a1 + 156) += x_WORD_EB39A;
				v27 = *(signed __int16 *)(a1 + 156);
				*(x_WORD *)(a1 + 154) = v26;
				*(x_WORD *)(a1 + 156) = (250 * v27 - (__CFSHL__(250 * v27 >> 31, 8) + (250 * v27 >> 31 << 8))) >> 8;
			}
			if (!(*(x_BYTE *)(a1 + 13) & 0x20) || v36)
				sub_36920(a1, a1);
		}
		if (*(x_BYTE *)(a1 + 13) & 0x20)
		{
			v28 = *(x_DWORD *)(a1 + 8) - 1;
			*(x_DWORD *)(a1 + 8) = v28;
			if (v28 < 6)
			{
				if (!v28)
					sub_57F10(a1);
			}
			else if (v28 <= 6)
			{
				v29 = *(x_BYTE *)(a1 + 15) & 0xFE;
				*(x_BYTE *)(a1 + 14) |= 0x80u;
				*(x_BYTE *)(a1 + 15) = v29;
			}
			else if (v28 == 12)
			{
				*(x_BYTE *)(a1 + 15) |= 1u;
			}
		}
	}
}
// D41B6: using guessed type char x_BYTE_D41B6;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39A: using guessed type __int16 x_WORD_EB39A;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (00036680) --------------------------------------------------------
char sub_36680(int a1)
{
	unsigned __int8 v1; // al
	signed int v2; // eax
	int v3; // eax
	char v5; // [esp+0h] [ebp-4h]

	v5 = 0;
	if (*(x_WORD *)(a1 + 40) == *(x_WORD *)(a1 + 104))
	{
		*(x_WORD *)(a1 + 104) = 0;
		*(x_DWORD *)(a1 + 100) = 0;
	}
	else
	{
		v1 = *(x_BYTE *)(a1 + 70);
		if (v1 < 1u)
		{
			if (!v1)
			{
				sub_36770((x_WORD *)a1);
				sub_6D8B0(*(x_WORD *)(a1 + 40), 0x16u, 1);
				v5 = 1;
			}
		}
		else if (v1 <= 1u)
		{
			v2 = *(x_DWORD *)(a1 + 16);
			*(x_DWORD *)(a1 + 16) = v2 + 1;
			if (v2 >= 8)
			{
				sub_6D8B0(*(x_WORD *)(a1 + 40), 0x16u, 1);
				return 1;
			}
			if (!(*(x_BYTE *)(a1 + 16) & 1))
				sub_36770((x_WORD *)a1);
		}
		else if (v1 <= 3u)
		{
			v3 = *(x_DWORD *)(a1 + 16);
			*(x_DWORD *)(a1 + 16) = v3 + 1;
			if (!v3)
			{
				sub_36850(a1);
				return 0;
			}
			if (v3 + 1 > 2)
			{
				sub_6D8B0(*(x_WORD *)(a1 + 40), 0x16u, 1);
				return 1;
			}
		}
	}
	return v5;
}

//----- (00036770) --------------------------------------------------------
void sub_36770(x_WORD *a1)
{
	x_WORD *v1; // ebx
	int v2; // ST08_4
	int v3; // eax

	v1 = (x_WORD *)sub_4A190((int)(a1 + 38), 9, 0);
	if (v1)
	{
		v2 = x_DWORD_EA3E4[(unsigned __int16)a1[52]];
		v1[75] = a1[52];
		sub_655C0(v1, v2);
		v1[14] = v1[16];
		v1[15] = v1[17];
		v1[40] += a1[44];
		v1[21] = a1[21];
		sub_6E450((signed int)((char *)v1 - (char*)x_D41A0_BYTEARRAY_0 - 28302) / 168, -1, 9);
		if (sub_104D0(v1 + 38) == (int(*)())1)
		{
			v3 = sub_4A190((int)(a1 + 38), 10, 5);
			if (v3)
				sub_6E450((v3 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 27);
		}
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00036850) --------------------------------------------------------
char sub_36850(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // esi

	*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
	*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
	v1 = sub_4A190((int)&x_WORD_EB398, 9, 9);
	v2 = v1;
	if (v1)
	{
		v3 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 104)];
		*(x_BYTE *)(v1 + 67) = 10;
		*(x_BYTE *)(v1 + 68) = 23;
		*(x_WORD *)(v1 + 26) = *(x_WORD *)(a1 + 26);
		*(x_WORD *)(v1 + 150) = *(x_WORD *)(a1 + 104);
		sub_655C0((x_WORD *)v1, v3);
		LOWORD(v1) = *(x_WORD *)(v2 + 32);
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&off_D8456;
		*(x_WORD *)(v2 + 28) = v1;
		*(x_WORD *)(v2 + 30) = *(x_WORD *)(v2 + 34);
		*(x_BYTE *)(v2 + 66) = *(x_BYTE *)(v3 + 64);
		LOBYTE(v1) = *(x_BYTE *)(v3 + 63);
		*(x_BYTE *)(v2 + 65) = v1;
		*(x_WORD *)(v2 + 80) += *(x_WORD *)(a1 + 88);
		*(x_WORD *)(v2 + 42) = *(x_WORD *)(a1 + 42);
	}
	return v1;
}
// D8456: using guessed type void *off_D8456;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;

//----- (00036920) --------------------------------------------------------
char sub_36920(signed __int16 a1, int a2)
{
	__int16 i; // si
	__int16 v3; // ax

	for (i = 0; i < 7 && *(x_DWORD *)(a2 + 144) > x_DWORD_DB538[i]; i++)
		;
	v3 = sub_369F0(a1, *(x_WORD *)(a2 + 148));
	if (v3 + i != *(signed __int16 *)(a2 + 90))
	{
		LOBYTE(v3) = sub_49C90(a2, i + v3);
		switch (i)
		{
		case 0:
			a1 = 13;
			break;
		case 1:
			a1 = 28;
			break;
		case 2:
			a1 = 42;
			break;
		case 3:
			a1 = 56;
			break;
		case 4:
			a1 = 70;
			break;
		case 5:
			a1 = 84;
			break;
		case 6:
			a1 = 98;
			break;
		case 7:
			a1 = 112;
			break;
		default:
			break;
		}
		*(x_WORD *)(a2 + 84) = a1;
		*(x_WORD *)(a2 + 86) = a1;
		*(x_WORD *)(a2 + 88) = a1;
		*(x_WORD *)(a2 + 82) = a1;
	}
	return v3;
}

//----- (000369F0) --------------------------------------------------------
signed int sub_369F0(signed int a1, __int16 a2)
{
	unsigned int v2; // eax
	signed int result; // eax

	v2 = x_DWORD_EA3E4[a2];
	if (v2 <= x_DWORD_EA3E4[0] || *(x_BYTE *)(v2 + 63) != 3)
		result = 52;
	else
		result = sub_36A50(a1, *(x_BYTE *)(*(x_DWORD *)(v2 + 164) + 56));
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00036A50) --------------------------------------------------------
signed int sub_36A50(signed int a1, char a2)
{
	char v2; // al
	signed int result; // eax

	v2 = a2;
	if (a2 >= 0)
		v2 = sub_616D0(a2);
	switch (v2 + 1)
	{
	case 0:
		result = 52;
		break;
	case 1:
		result = 105;
		break;
	case 2:
		result = 113;
		break;
	case 3:
		result = 121;
		break;
	case 4:
		result = 129;
		break;
	case 5:
		result = 137;
		break;
	case 6:
		result = 145;
		break;
	case 7:
		result = 153;
		break;
	case 8:
		a1 = 161;
		goto LABEL_13;
	default:
	LABEL_13:
		result = a1;
		break;
	}
	return result;
}

//----- (00036AE0) --------------------------------------------------------
void sub_36AE0(__int16 *a1)
{
	int result; // eax
	unsigned __int16 v2; // dx
	int v3; // edi
	unsigned int i; // ecx

	result = sub_10C40(a1 + 38);
	v2 = a1[52];
	a1[40] = result;
	if (v2)
	{
		v3 = x_DWORD_EA3E4[v2];
		if (*(x_BYTE *)(v3 + 63) == 3 && !a1[74])
		{
			for (i = x_DWORD_EA3E8; i < x_DWORD_EB384; i += 168)
			{
				if ((signed int)((char *)a1 - (char*)x_D41A0_BYTEARRAY_0 - 28302) / 168 == *(unsigned __int16 *)(i + 148))
					*(x_WORD *)(i + 148) = (v3 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
			}
		}
		a1[52] = 0;
		sub_57F10((int)a1);
	}
	//return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EA3E8: using guessed type int x_DWORD_EA3E8;
// EB384: using guessed type int x_DWORD_EB384;

//----- (00036BA0) --------------------------------------------------------
void sub_36BA0(int a1, char a2)
{
	int v2; // edx
	int v3; // edi
	int v4; // eax
	x_WORD *v5; // ebx
	int v6; // edx
	__int16 v7; // cx
	__int16 v8; // dx
	unsigned __int16 v9; // ax
	int v10; // ST14_4
	__int16 v11; // ax
	int v12; // [esp+0h] [ebp-Ch]
	int v13; // [esp+8h] [ebp-4h]

	v2 = *(x_DWORD *)(a1 + 144);
	if (v2 > 0)
	{
		if (a2)
		{
			v3 = v2 / 1000;
			if (v2 / 1000 < 1)
				v3 = 1;
			if (v3 > 16)
				v3 = 16;
			v13 = *(x_DWORD *)(a1 + 144) / v3;
		}
		else
		{
			v3 = 1;
			v13 = *(x_DWORD *)(a1 + 144);
		}
		v12 = 0;
		*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
		while (v3 > v12)
		{
			v4 = sub_4A190(a1 + 76, 10, 39);
			v5 = (x_WORD *)v4;
			if (v4)
			{
				if (v3 - 1 == v12)
					v6 = *(x_DWORD *)(a1 + 144) - (v3 - 1) * v13;
				else
					v6 = v13;
				*(x_DWORD *)(v4 + 144) = v6;
				v7 = *(x_WORD *)(v4 + 20);
				*(x_WORD *)(v4 + 148) = *(x_WORD *)(a1 + 148);
				*(x_WORD *)(v4 + 20) = 9377 * v7 + 9439;
				v8 = *(x_WORD *)(v4 + 20);
				*(x_WORD *)(v4 + 28) = (*(x_WORD *)(v4 + 20) % 0x71u + *(x_WORD *)(a1 + 28) - 56) & 0x7FF;
				*(x_WORD *)(v4 + 20) = 9377 * v8 + 9439;
				v9 = *(x_WORD *)(v4 + 20);
				v5[77] = 0;
				v5[78] = 0;
				v5[65] = v9 % 0x30u + 16;
				v10 = *(signed __int16 *)(a1 + 80);
				v11 = sub_10C40((__int16 *)(a1 + 76));
				v5[22] = (1024 - (v10 - v11) - (__CFSHL__((1024 - (v10 - v11)) >> 31, 3) + 8 * ((1024 - (v10 - v11)) >> 31))) >> 3;
				sub_57FA0(v5 + 77, v5[14], 0, v5[65]);
			}
			++v12;
		}
		*(x_WORD *)(a1 + 148) = 0;
	}
}

//----- (00036D50) --------------------------------------------------------
int sub_36D50(int a1, int a2)
{
	int v3; // edx
	int v4; // eax
	int v5; // eax
	int v6; // eax
	int v7; // edi
	int v8; // edx
	int v9; // eax
	Bit8u* v10; // eax
	__int64 v11; // rtt

	if (*(x_WORD *)(a1 + 148) || *(x_WORD *)(a2 + 148))
	{
		if (!*(x_WORD *)(a1 + 148))
		{
			*(x_DWORD *)(a1 + 144) += *(x_DWORD *)(a2 + 144);
			*(x_WORD *)(a1 + 148) = *(x_WORD *)(a2 + 148);
			if (*(x_BYTE *)(a2 + 14) & 0x20)
			{
				*(x_BYTE *)(a1 + 14) |= 0x20u;
				return sub_57F20(a2);
			}
			return sub_57F20(a2);
		}
		if (!*(x_WORD *)(a2 + 148))
		{
			*(x_DWORD *)(a1 + 144) += *(x_DWORD *)(a2 + 144);
			return sub_57F20(a2);
		}
		v3 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 148)];
		v4 = x_DWORD_EA3E4[*(unsigned __int16 *)(a2 + 148)];
		if (*(x_BYTE *)(v3 + 63) == 10 && *(x_BYTE *)(v4 + 63) == 10)
		{
			*(x_DWORD *)(a1 + 144) += *(x_DWORD *)(a2 + 144);
			return sub_57F20(a2);
		}
		if (*(x_BYTE *)(v3 + 63) == 10)
		{
			v5 = v4 - (x_D41A0_BYTEARRAY_0[28302]);
			*(x_DWORD *)(a1 + 144) += *(x_DWORD *)(a2 + 144);
			v6 = v5 / 168;
		LABEL_22:
			*(x_WORD *)(a1 + 148) = v6;
			return sub_57F20(a2);
		}
		if (*(x_BYTE *)(v4 + 63) == 10)
		{
			v7 = *(x_DWORD *)(a2 + 144) + *(x_DWORD *)(a1 + 144);
			v8 = v3 - (x_D41A0_BYTEARRAY_0[28302]);
			v9 = v8;
		}
		else
		{
			if (v3 == v4)
			{
				*(x_DWORD *)(a1 + 144) += *(x_DWORD *)(a2 + 144);
				return sub_57F20(a2);
			}
			if (*(x_DWORD *)(v3 + 140) > *(x_DWORD *)(v4 + 140))
			{
				v10 = x_D41A0_BYTEARRAY_0 + 28302;
				*(x_DWORD *)(a1 + 144) += *(x_DWORD *)(a2 + 144);
				v6 = (v3 - (int)v10) / 168;
				goto LABEL_22;
			}
			v7 = *(x_DWORD *)(a2 + 144) + *(x_DWORD *)(a1 + 144);
			v9 = v4 - (x_D41A0_BYTEARRAY_0[28302]);
			v8 = v9;
		}
		LODWORD(v11) = v9;
		HIDWORD(v11) = v8 >> 31;
		v6 = v11 / 168;
		*(x_DWORD *)(a1 + 144) = v7;
		goto LABEL_22;
	}
	*(x_DWORD *)(a1 + 144) += *(x_DWORD *)(a2 + 144);
	return sub_57F20(a2);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00036F30) --------------------------------------------------------
int sub_36F30(int a1, int a2)
{
	__int16 v2; // bx

	LOBYTE(v2) = 0;
	if (*(x_BYTE *)(a1 + 70) >= *(x_BYTE *)(a2 + 70))
	{
		if (*(x_WORD *)(a2 + 40) != *(x_WORD *)(a1 + 40))
		{
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			v2 = *(x_WORD *)(a1 + 20) & 1;
		}
	}
	else
	{
		LOBYTE(v2) = 1;
	}
	if ((x_BYTE)v2)
	{
		*(x_WORD *)(a1 + 40) = *(x_WORD *)(a2 + 40);
		*(x_WORD *)(a1 + 148) = *(x_WORD *)(a2 + 148);
		*(x_BYTE *)(a1 + 70) = *(x_BYTE *)(a2 + 70);
		*(x_WORD *)(a1 + 42) = *(x_WORD *)(a2 + 42);
	}
	*(x_DWORD *)(a1 + 144) += *(x_DWORD *)(a2 + 144);
	return sub_57F20(a2);
}

//----- (00036FC0) --------------------------------------------------------
char sub_36FC0(int a1)
{
	unsigned __int8 v1; // bl
	int v2; // eax
	unsigned int v3; // esi
	unsigned int v4; // edi
	char result; // al
	unsigned __int16 v6; // bx
	unsigned __int8 v7; // cl
	char v8; // dl
	__int16 v9; // dx
	int v10; // eax
	int v11; // eax
	unsigned __int8 v12; // cl
	char v13; // ch
	char v14; // cl
	unsigned __int16 v15; // bx
	unsigned __int8 *v16; // [esp+0h] [ebp-2Ch]
	unsigned __int8 *v17; // [esp+4h] [ebp-28h]
	unsigned int v18; // [esp+8h] [ebp-24h]
	unsigned int v19; // [esp+Ch] [ebp-20h]
	unsigned int v20; // [esp+10h] [ebp-1Ch]
	unsigned int v21; // [esp+14h] [ebp-18h]
	unsigned __int8 *v22; // [esp+18h] [ebp-14h]
	unsigned __int16 v23; // [esp+1Ch] [ebp-10h]
	unsigned __int16 v24; // [esp+1Ch] [ebp-10h]
	__int16 v25; // [esp+20h] [ebp-Ch]
	char v26; // [esp+24h] [ebp-8h]
	unsigned __int16 v27; // [esp+24h] [ebp-8h]
	char v28; // [esp+25h] [ebp-7h]
	char v29; // [esp+28h] [ebp-4h]

	v29 = 0;
	v26 = (unsigned __int16)(*(x_WORD *)(a1 + 76) + 128) >> 8;
	v28 = (unsigned __int16)(*(x_WORD *)(a1 + 78) + 128) >> 8;
	v1 = *(x_BYTE *)(a1 + 70);
	v25 = *(x_WORD *)(a1 + 80) >> 5;
	v2 = 6 * v1;
	/*  v3 = *(unsigned __int8 *)(v2 + **filearray_2aa18c[24] + 5);
	  v17 = *(unsigned __int8 **)(v2 + **filearray_2aa18c[24]);
	  v4 = *(unsigned __int8 *)(v2 + **filearray_2aa18c[24] + 4);
	  result = sub_37740(a1);*/ // fix it
	result = 0;v3 = 0;v4 = 0;v17 = 0;  //fix it
	if (!result)
	{
		if (x_WORD_180660_VGA_type_resolution == 1)
		{
			v3 >>= 1;
			v4 >>= 1;
		}
		if (x_BYTE_D41B6 && !(x_BYTE_D93C2[4 * v1] & 4))
			v29 = 1;
		LOBYTE(v27) = v26 - (v4 >> 1);
		HIBYTE(v27) = v28 - (v3 >> 1);
		v23 = v27;
		v20 = 0;
		v22 = v17;
		while (v3 > v20)
		{
			v6 = v23;
			v18 = 0;
			while (v4 > v18)
			{
				sub_57390(v6, *(x_WORD *)(a1 + 26));
				v7 = v22[1];
				if (v7 != -1)
				{
					x_BYTE_11B4E0[v6] = v7 + v25;
					v8 = x_BYTE_13B4E0[v6];
					if (!(v8 & 7))
					{
						x_BYTE_13B4E0[v6] = v8 & 0xF8 | 1;
						sub_462A0(v6, v6);
					}
				}
				if (v29)
				{
					v9 = x_BYTE_11B4E0[v6];
					if (v9 >= v25)
						v10 = (unsigned __int8)v9;
					else
						v10 = v25;
					v11 = v10 + 80;
					if (v11 > 255)
						v11 = 255;
					if (v11 > (unsigned __int8)x_BYTE_14B4E0[v6])
						x_BYTE_14B4E0[v6] = v11;
					v12 = x_BYTE_11B4E0[v6];
					if ((unsigned __int8)x_BYTE_14B4E0[v6] > v12)
					{
						x_BYTE_13B4E0[v6] &= 0xF7u;
					}
					else
					{
						v13 = x_BYTE_13B4E0[v6] | 8;
						x_BYTE_14B4E0[v6] = v12 - 1;
						x_BYTE_13B4E0[v6] = v13;
					}
				}
				LOBYTE(v6) = v6 + 1;
				++v18;
				v22 += 2;
			}
			++v20;
			++HIBYTE(v23);
		}
		v24 = v27;
		result = (char)v17;
		v19 = 0;
		v16 = v17;
		if (v3)
		{
			do
			{
				v14 = 0;
				v15 = v24;
				v21 = 0;
				while (v4 > v21)
				{
					if (*v16 != -1)
						sub_45DC0((char)v16, v14, v15, *v16);
					LOBYTE(v15) = v15 + 1;
					++v21;
					v16 += 2;
				}
				result = v19++ + 1;
				++HIBYTE(v24);
			} while (v3 > v19);
		}
	}
	return result;
}
// D41B6: using guessed type char x_BYTE_D41B6;
// EA3BC: using guessed type int **filearray_2aa18c[24];
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00037240) --------------------------------------------------------
void sub_37240(int a1)
{
	unsigned __int8 v1; // cl
	int v2; // esi
	unsigned int v3; // edi
	unsigned int v4; // esi
	int v5; // ecx
	char v6; // dh
	signed __int16 v7; // dx
	int v8; // eax
	int v9; // eax
	int v10; // edx
	unsigned __int8 v11; // ch
	char v12; // cl
	x_BYTE *v13; // ebx
	unsigned int v14; // edx
	unsigned __int8 *v15; // ebx
	char v16; // dl
	unsigned __int8 v17; // al
	__int16 v18; // ax
	unsigned int v19; // esi
	int v20; // edi
	unsigned int v21; // [esp+0h] [ebp-58h]
	unsigned int v22; // [esp+4h] [ebp-54h]
	unsigned int v23; // [esp+8h] [ebp-50h]
	unsigned int v24; // [esp+Ch] [ebp-4Ch]
	unsigned int v25; // [esp+18h] [ebp-40h]
	x_BYTE *v26; // [esp+1Ch] [ebp-3Ch]
	x_BYTE *v27; // [esp+20h] [ebp-38h]
	unsigned int v28; // [esp+24h] [ebp-34h]
	unsigned int v29; // [esp+28h] [ebp-30h]
	unsigned int v30; // [esp+2Ch] [ebp-2Ch]
	unsigned int v31; // [esp+30h] [ebp-28h]
	unsigned int v32; // [esp+34h] [ebp-24h]
	unsigned int v33; // [esp+38h] [ebp-20h]
	x_BYTE *v34; // [esp+40h] [ebp-18h]
	int v35; // [esp+44h] [ebp-14h]
	char v36; // [esp+48h] [ebp-10h]
	unsigned __int16 v37; // [esp+48h] [ebp-10h]
	__int16 v38; // [esp+48h] [ebp-10h]
	char v39; // [esp+49h] [ebp-Fh]
	unsigned __int16 v40; // [esp+4Ch] [ebp-Ch]
	unsigned __int16 v41; // [esp+4Ch] [ebp-Ch]
	unsigned __int16 v42; // [esp+4Ch] [ebp-Ch]
	unsigned __int16 v43; // [esp+4Ch] [ebp-Ch]
	__int16 v44; // [esp+4Ch] [ebp-Ch]
	unsigned __int16 v45; // [esp+50h] [ebp-8h]
	unsigned __int16 v46; // [esp+50h] [ebp-8h]
	unsigned __int16 v47; // [esp+50h] [ebp-8h]
	unsigned __int16 v48; // [esp+50h] [ebp-8h]
	__int16 v49; // [esp+50h] [ebp-8h]
	char v50; // [esp+54h] [ebp-4h]

	v50 = 0;
	if (*(x_DWORD *)(a1 + 4) == *(x_DWORD *)(a1 + 8))
		sub_49EC0((x_WORD *)a1, *(char *)(a1 + 70));
	if (!sub_37740(a1))
	{
		v36 = (unsigned __int16)(*(x_WORD *)(a1 + 76) + 128) >> 8;
		v1 = *(x_BYTE *)(a1 + 70);
		v39 = (unsigned __int16)(*(x_WORD *)(a1 + 78) + 128) >> 8;
		v35 = *(signed __int16 *)(a1 + 80) >> 5;
		//fix it //v2 = 6 * v1 + **filearray_2aa18c[24];
		v2 = 0;  //fix it
		v3 = *(unsigned __int8 *)(v2 + 5);
		v26 = *(x_BYTE **)v2;
		v4 = *(unsigned __int8 *)(v2 + 4);
		if (x_WORD_180660_VGA_type_resolution == 1)
		{
			v3 >>= 1;
			v4 >>= 1;
		}
		if (x_BYTE_D41B6 && !(x_BYTE_D93C2[4 * v1] & 4))
			v50 = 1;
		v22 = v3 >> 1;
		v5 = *(x_DWORD *)(a1 + 8) - 1;
		*(x_DWORD *)(a1 + 8) = v5;
		v25 = v4 >> 1;
		if (v5 <= 0)
		{
			LOBYTE(v38) = v36 - v25;
			HIBYTE(v38) = v39 - v22;
			v23 = 0;
			v44 = v38;
			v27 = v26;
			while (v3 > v23)
			{
				v21 = 0;
				v49 = v44;
				while (v4 > v21)
				{
					if (*v27 != -1)
						sub_462A0(v49, v49);
					++v21;
					v27 += 2;
					LOBYTE(v49) = v49 + 1;
				}
				++v23;
				++HIBYTE(v44);
			}
			v17 = *(x_BYTE *)(a1 + 69);
			if (v17 >= 0x30u)
			{
				if (v17 <= 0x30u)
				{
					*(x_WORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)] + 46) = 2;
					sub_377A0(a1);
					sub_57F10(a1);
				}
				else if (v17 == 51)
				{
					*(x_DWORD *)(a1 + 8) = 1000 * *(unsigned __int16 *)(a1 + 42);
					v18 = *(x_WORD *)(a1 + 148);
					*(x_BYTE *)(a1 + 69) = 52;
					if (v18)
						*(x_BYTE *)(a1 + 12) &= 0xFEu;
					else
						*(x_BYTE *)(a1 + 12) |= 1u;
					*(x_WORD *)(a1 + 158) = *(x_WORD *)(a1 + 80);
					v19 = v4 >> 1;
					*(x_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
					v20 = (v3 >> 1) & 0xFFFF;
					sub_48A20(v20, v38, SHIBYTE(v38), v20, (unsigned __int16)v19, 2u);
					sub_48A20(v20, v38, SHIBYTE(v38), v20, (unsigned __int16)v19, 5u);
					sub_377A0(a1);
				}
			}
		}
		else
		{
			LOBYTE(v37) = v36 - v25;
			HIBYTE(v37) = v39 - v22;
			if (*(x_DWORD *)(a1 + 4) - 1 == *(x_DWORD *)(a1 + 8))
			{
				v29 = 0;
				v40 = v37;
				while (v3 > v29)
				{
					v30 = 0;
					v45 = v40;
					while (v4 > v30)
					{
						sub_57390(v45, *(x_WORD *)(a1 + 26));
						++v30;
						LOBYTE(v45) = v45 + 1;
					}
					++v29;
					++HIBYTE(v40);
				}
			}
			v41 = v37;
			v28 = 0;
			v34 = v26;
			while (v3 > v28)
			{
				v33 = 0;
				v46 = v41;
				while (v4 > v33)
				{
					if (v34[1] != -1)
					{
						v6 = x_BYTE_13B4E0[v46];
						x_BYTE_11B4E0[v46] += ((unsigned __int8)v34[1] + (signed __int16)v35 - x_BYTE_11B4E0[v46])
							/ *(x_DWORD *)(a1 + 8);
						if (!(v6 & 7))
						{
							x_BYTE_13B4E0[v46] = v6 & 0xF0 | 1;
							sub_462A0(v46, v46);
						}
					}
					if (v50)
					{
						v7 = x_BYTE_11B4E0[v46];
						if (v7 >= (signed __int16)v35)
							v8 = (unsigned __int8)v7;
						else
							v8 = (signed __int16)v35;
						v9 = v8 + 80;
						if (v9 > 255)
							v9 = 255;
						v10 = (unsigned __int8)x_BYTE_14B4E0[v46];
						if (v9 > v10)
							x_BYTE_14B4E0[v46] = v10 + (unsigned int)((v9 - v10) / *(x_DWORD *)(a1 + 8));
						v11 = x_BYTE_11B4E0[v46];
						if ((unsigned __int8)x_BYTE_14B4E0[v46] > v11)
						{
							x_BYTE_13B4E0[v46] &= 0xF7u;
						}
						else
						{
							x_BYTE_14B4E0[v46] = v11 - 1;
							x_BYTE_13B4E0[v46] |= 8u;
						}
					}
					++v33;
					v34 += 2;
					LOBYTE(v46) = v46 + 1;
				}
				++v28;
				++HIBYTE(v41);
			}
			v12 = 5;
			if (!(*(x_DWORD *)(a1 + 8) % 5) || *(x_DWORD *)(a1 + 8) == 1)
			{
				v13 = v26;
				v14 = 0;
				v42 = v37;
				while (v14 < v3)
				{
					v12 = 0;
					v32 = 0;
					v47 = v42;
					while (v4 > v32)
					{
						if (*v13 != -1)
						{
							v12 = x_BYTE_13B4E0[v47] & 0xF0 | 1;
							x_BYTE_13B4E0[v47] = v12;
							x_BYTE_10B4E0[v47] = 1;
						}
						v13 += 2;
						++v32;
						LOBYTE(v47) = v47 + 1;
					}
					++v14;
					++HIBYTE(v42);
				}
				v31 = 0;
				v15 = (unsigned char*)v26;
				v43 = v37;
				if (v3)
				{
					do
					{
						v16 = 0;
						v24 = 0;
						v48 = v43;
						while (v4 > v24)
						{
							if (*v15 != -1)
								sub_45DC0(v16, v12, v48, *v15);
							v15 += 2;
							v12 = v24 + 1;
							v16 = v48 + 1;
							++v24;
							LOBYTE(v48) = v48 + 1;
						}
						++v31;
						++HIBYTE(v43);
					} while (v3 > v31);
				}
			}
		}
	}
}
// D41B6: using guessed type char x_BYTE_D41B6;
// EA3BC: using guessed type int **filearray_2aa18c[24];
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00037740) --------------------------------------------------------
char sub_37740(int a1)
{
	unsigned int v1; // ebx
	char v3; // [esp+0h] [ebp-4h]

	v3 = 0;
	v1 = x_D41A0_BYTEARRAY_4[38535];
	if (v1 <= x_DWORD_EA3E4[0])
		return 0;
	while (*(x_BYTE *)(v1 + 63) != 10 || *(x_BYTE *)(v1 + 64) != 42 || !sub_10750(a1, v1))
	{
		v1 = *(x_DWORD *)v1;
		if (v1 <= x_DWORD_EA3E4[0])
			return v3;
	}
	return 1;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000377A0) --------------------------------------------------------
void sub_377A0(int a1)
{
	__int16 *i; // ebx

	for (i = (short*)x_D41A0_BYTEARRAY_4[0x9677]; (unsigned int)i > x_DWORD_EA3E4[0]; i = *(__int16 **)i)
	{
		if (sub_10750(a1, (int)i))
			sub_5FBD0(i);
	}
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000377F0) --------------------------------------------------------
void sub_377F0(int a1)
{
	__int16 v1; // dx
	//signed int v2; // eax
	unsigned int v3; // esi
	unsigned int v4; // eax
	unsigned int v5; // edi
	char v6; // cl
	__int16 v7; // ax
	int v8; // eax
	int v9; // eax
	int v10; // ecx
	int v11; // edx
	int v12; // edx
	unsigned int v13; // edx
	unsigned __int16 v14; // ax
	char v15; // cl
	unsigned __int8 v16; // ch
	unsigned int k; // ecx
	unsigned int v18; // edx
	unsigned __int8 v19; // ch
	unsigned int l; // [esp+0h] [ebp-28h]
	unsigned int i; // [esp+4h] [ebp-24h]
	int v23; // [esp+8h] [ebp-20h]
	unsigned int j; // [esp+10h] [ebp-18h]
	unsigned __int16 v25; // [esp+18h] [ebp-10h]

	LOBYTE(v1) = (unsigned __int16)(*(x_WORD *)(a1 + 76) + 128) >> 8;
	HIBYTE(v1) = (unsigned __int16)(*(x_WORD *)(a1 + 78) + 128) >> 8;
	/* if ( x_WORD_180660_VGA_type_resolution == 1 )
	   v2 = (signed int)*(unsigned __int8 *)(**filearray_2aa18c[24] + 6 * *(char *)(a1 + 70) + 4) >> 1;
	 else
	   v2 = *(unsigned __int8 *)(**filearray_2aa18c[24] + 6 * *(char *)(a1 + 70) + 4);
	 v3 = v2;
	 if ( x_WORD_180660_VGA_type_resolution == 1 )
	   v4 = (signed int)*(unsigned __int8 *)(**filearray_2aa18c[24] + 6 * *(char *)(a1 + 70) + 5) >> 1;
	 else
	   v4 = *(unsigned __int8 *)(**filearray_2aa18c[24] + 6 * *(char *)(a1 + 70) + 5);
	 v5 = v4;*/ //fix it
	v4 = 0; v3 = 0; //fix it
	if (x_WORD_180660_VGA_type_resolution == 1)
	{
		v5 = v4 >> 1;
		v3 >>= 1;
	}
	LOBYTE(v25) = v1 - (v3 >> 1);
	v6 = *(x_BYTE *)(a1 + 12);
	HIBYTE(v25) = HIBYTE(v1) - (v5 >> 1);
	if (v6 & 2)
	{
		if (!*(x_WORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)] + 48) && *(x_DWORD *)(a1 + 16))
		{
			v9 = *(unsigned __int16 *)(a1 + 42) - *(signed __int16 *)(a1 + 46);
			v10 = *(x_DWORD *)(a1 + 16);
			HIWORD(v11) = (unsigned int)(v9 % v10) >> 16;
			v23 = v9 / v10;
			LOWORD(v11) = *(x_WORD *)(a1 + 46);
			v12 = v9 / v10 + v11;
			v8 = *(x_DWORD *)(a1 + 16);
			*(x_WORD *)(a1 + 46) = v12;
			if (v8 == 1)
			{
				v13 = 0;
				v14 = v25;
				while (v5 > v13)
				{
					for (i = 0; v3 > i; i++)
					{
						v15 = x_BYTE_13B4E0[v14];
						if (v15 < 0)
						{
							x_BYTE_13B4E0[v14] = v15 & 0x7F;
							if (!x_BYTE_D41B6)
								x_BYTE_13B4E0[v14] = v15 & 0x7F | 8;
						}
						v16 = v23 + x_BYTE_11B4E0[v14];
						x_BYTE_11B4E0[v14] = v16;
						if (x_BYTE_D41B6)
						{
							if (v16 < (unsigned __int8)x_BYTE_14B4E0[v14])
							{
								x_BYTE_13B4E0[v14] &= 0xF7u;
							}
							else
							{
								x_BYTE_14B4E0[v14] = v16 - 1;
								x_BYTE_13B4E0[v14] |= 8u;
							}
						}
						LOBYTE(v14) = v14 + 1;
					}
					++v13;
					v14 = __PAIR__(HIBYTE(v14), (unsigned __int8)v25) + 256;
				}
				LOWORD(v8) = -10;
				*(x_DWORD *)(a1 + 16) = -10;
			}
			else if (v8 == -1)
			{
				LOWORD(v8) = v25;
				for (j = 0; v5 > j; j++)
				{
					for (k = 0; k < v3; k++)
					{
						if (!x_BYTE_D41B6 && x_BYTE_13B4E0[(unsigned __int16)v8] & 8)
						{
							x_BYTE_13B4E0[(unsigned __int16)v8] |= 0x80u;
							x_BYTE_13B4E0[(unsigned __int16)v8] &= 0xF7u;
						}
						LOBYTE(v8) = v8 + 1;
					}
					LOWORD(v8) = __PAIR__(BYTE1(v8), (unsigned __int8)v25) + 256;
				}
				++*(x_DWORD *)(a1 + 16);
			}
			else if (v8 <= 0)
			{
				*(x_DWORD *)(a1 + 16) = v8 + 1;
			}
			else
			{
				v18 = 0;
				LOWORD(v8) = v25;
				while (v5 > v18)
				{
					for (l = 0; v3 > l; l++)
					{
						v19 = v23 + x_BYTE_11B4E0[(unsigned __int16)v8];
						x_BYTE_11B4E0[(unsigned __int16)v8] = v19;
						if (x_BYTE_D41B6)
						{
							if (v19 < (unsigned __int8)x_BYTE_14B4E0[(unsigned __int16)v8])
							{
								x_BYTE_13B4E0[(unsigned __int16)v8] &= 0xF7u;
							}
							else
							{
								x_BYTE_14B4E0[(unsigned __int16)v8] = v19 - 1;
								x_BYTE_13B4E0[(unsigned __int16)v8] |= 8u;
							}
						}
						LOBYTE(v8) = v8 + 1;
					}
					++v18;
					LOWORD(v8) = __PAIR__(BYTE1(v8), (unsigned __int8)v25) + 256;
				}
				--*(x_DWORD *)(a1 + 16);
			}
		}
		else
		{
			*(x_WORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)] + 46) = 2;
			*(x_WORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)] + 158) = 32 * *(x_WORD *)(a1 + 46);
			sub_48A20(v5 >> 1, v1, SHIBYTE(v1), (unsigned __int16)(v5 >> 1), (v3 >> 1) & 0xFFFF, 3u);
			sub_57F10(a1);
		}
	}
	else
	{
		*(x_WORD *)(a1 + 46) = *(x_WORD *)(a1 + 80) >> 5;
		*(x_DWORD *)(a1 + 16) = 10;
		*(x_BYTE *)(a1 + 12) = v6 | 2;
		v7 = sub_48DF0(v25 - 1, HIBYTE(v25) - 1, v5 + 2, v3 + 2);
		*(x_WORD *)(a1 + 42) = v7;
		if ((unsigned __int16)v7 > 0xDCu)
			*(x_WORD *)(a1 + 42) = 220;
		v8 = *(signed __int16 *)(a1 + 46);
		if (v8 == *(unsigned __int16 *)(a1 + 42))
			*(x_DWORD *)(a1 + 16) = 0;
	}
	//return v8;
}
// D41B6: using guessed type char x_BYTE_D41B6;
// EA3BC: using guessed type int **filearray_2aa18c[24];
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00037BC0) --------------------------------------------------------
void sub_37BC0(int a1)
{
	int v1; // eax
	int v2; // edx
	//signed int v3; // eax
	unsigned int v4; // eax
	int v5; // eax
	//signed int v6; // eax
	unsigned int v7; // edx
	unsigned int v8; // edx
	unsigned __int16 v9; // ax
	unsigned __int8 *v10; // esi
	int v11; // edi
	unsigned __int8 v12; // ch
	int v13; // edx
	unsigned int v14; // edi
	int v15; // esi
	char v16; // al
	char v17; // dl
	signed __int16 v18; // dx
	int v19; // eax
	int v20; // eax
	int v21; // edx
	unsigned __int8 v22; // ch
	//signed int v23; // eax
	unsigned int v24; // esi
	unsigned int v25; // eax
	unsigned __int16 v26; // ST44_2
	unsigned int v27; // edx
	unsigned int v28; // ecx
	int v30; // [esp+4h] [ebp-54h]
	unsigned int v31; // [esp+10h] [ebp-48h]
	unsigned int v32; // [esp+14h] [ebp-44h]
	int v33; // [esp+18h] [ebp-40h]
	unsigned int k; // [esp+1Ch] [ebp-3Ch]
	int v35; // [esp+20h] [ebp-38h]
	unsigned int v36; // [esp+24h] [ebp-34h]
	unsigned int v37; // [esp+28h] [ebp-30h]
	unsigned int v38; // [esp+2Ch] [ebp-2Ch]
	unsigned int v39; // [esp+30h] [ebp-28h]
	int v40; // [esp+34h] [ebp-24h]
	unsigned __int16 v41; // [esp+38h] [ebp-20h]
	unsigned __int16 v42; // [esp+3Ch] [ebp-1Ch]
	unsigned __int16 j; // [esp+3Ch] [ebp-1Ch]
	unsigned __int16 v44; // [esp+3Ch] [ebp-1Ch]
	unsigned __int16 v45; // [esp+40h] [ebp-18h]
	unsigned __int8 i; // [esp+44h] [ebp-14h]
	char v47; // [esp+48h] [ebp-10h]
	unsigned __int8 v48; // [esp+50h] [ebp-8h]
	char v49; // [esp+54h] [ebp-4h]
	char v50; // [esp+54h] [ebp-4h]

	LOBYTE(v1) = (uint8)x_DWORD_E9C38_smalltit;
	v30 = (int)x_DWORD_E9C38_smalltit;
	BYTE1(v1) = *(x_BYTE *)(a1 + 12);
	if (!(v1 & 0x200))
	{
		*(x_DWORD *)(a1 + 16) = 19;
		*(x_BYTE *)(a1 + 12) = BYTE1(v1) | 2;
	}
	v2 = *(x_DWORD *)(a1 + 16);
	if (v2 <= 0)
	{
		*(x_DWORD *)(a1 + 16) = v2 + 1;
		if (v2 == -1)
		{
			v50 = (unsigned __int16)(*(x_WORD *)(a1 + 76) + 128) >> 8;
			/*if ( x_WORD_180660_VGA_type_resolution == 1 )
			  v23 = (signed int)*(unsigned __int8 *)(**filearray_2aa18c[24] + 6 * *(char *)(a1 + 70) + 4) >> 1;
			else
			  v23 = *(unsigned __int8 *)(**filearray_2aa18c[24] + 6 * *(char *)(a1 + 70) + 4);
			v24 = v23;
			if ( x_WORD_180660_VGA_type_resolution == 1 )
			  v25 = (signed int)*(unsigned __int8 *)(**filearray_2aa18c[24] + 6 * *(char *)(a1 + 70) + 5) >> 1;
			else
			  v25 = *(unsigned __int8 *)(**filearray_2aa18c[24] + 6 * *(char *)(a1 + 70) + 5);*/ // fix it
			v25 = 0;v24 = 0;  //fix it
			if (!x_BYTE_D41B6)
			{
				v27 = 0;
				HIBYTE(v26) = ((unsigned __int16)(*(x_WORD *)(a1 + 78) + 128) >> 8) - (v25 >> 1);
				LOBYTE(v26) = v50 - (v24 >> 1);
				v44 = v26;
				while (v27 < v25)
				{
					v28 = 0;
					while (v28 < v24)
					{
						if (x_BYTE_13B4E0[v44] & 8)
						{
							x_BYTE_13B4E0[v44] |= 0x80u;
							x_BYTE_13B4E0[v44] &= 0xF7u;
						}
						++v28;
						LOBYTE(v44) = v44 + 1;
					}
					LOBYTE(v44) = v50 - (v24 >> 1);
					++v27;
					++HIBYTE(v44);
				}
			}
			*(x_WORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)] + 46) = 2;
			sub_57F10(a1);
		}
	}
	else
	{
		*(x_DWORD *)(a1 + 16) = v2 - 1;
		if (v2 == 1)
		{
			if (*(x_BYTE *)(a1 + 59))
				*(x_DWORD *)(a1 + 16) = -25;
			else
				*(x_DWORD *)(a1 + 16) = -1;
		}
		else
		{
			v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
			if (!*(x_WORD *)(v1 + 48))
			{
				v49 = (unsigned __int16)(*(x_WORD *)(a1 + 76) + 128) >> 8;
				v47 = (unsigned __int16)(*(x_WORD *)(a1 + 78) + 128) >> 8;
				v40 = *(signed __int16 *)(a1 + 80) >> 5;
				/*if ( x_WORD_180660_VGA_type_resolution == 1 )
				  v3 = (signed int)*(unsigned __int8 *)(**filearray_2aa18c[24] + 6 * *(char *)(a1 + 70) + 4) >> 1;
				else
				  v3 = *(unsigned __int8 *)(**filearray_2aa18c[24] + 6 * *(char *)(a1 + 70) + 4);
				v36 = v3;
				if ( x_WORD_180660_VGA_type_resolution == 1 )
				  v4 = (signed int)*(unsigned __int8 *)(**filearray_2aa18c[24] + 6 * *(char *)(a1 + 70) + 5) >> 1;
				else
				  v4 = *(unsigned __int8 *)(**filearray_2aa18c[24] + 6 * *(char *)(a1 + 70) + 5);*/ // fix it
				v4 = 0;v36 = 0;  //fix it
				v37 = v4;
				v48 = v4 >> 1;
				LOBYTE(v41) = v49 - (v36 >> 1);
				HIBYTE(v41) = v47 - v48;
				memset((void*)v30, 0, 2 * v4 * v36);
				for (i = 1; i <= (signed int)*(char *)(a1 + 70); i++)
				{
					v5 = 6 * i;
					/*if ( x_WORD_180660_VGA_type_resolution == 1 )
					  v6 = (signed int)*(unsigned __int8 *)(**filearray_2aa18c[24] + v5 + 4) >> 1;
					else
					  v6 = *(unsigned __int8 *)(**filearray_2aa18c[24] + v5 + 4);
					v31 = v6;
					if ( x_WORD_180660_VGA_type_resolution == 1 )
					  v7 = (signed int)*(unsigned __int8 *)(**filearray_2aa18c[24] + 6 * i + 5) >> 1;
					else
					  v7 = *(unsigned __int8 *)(**filearray_2aa18c[24] + 6 * i + 5);*/ // fix it
					v7 = 0;v31 = 0;  //fix it
					v39 = v7;
					v8 = v7 >> 1;
					LOBYTE(v9) = v49 - v8;
					HIBYTE(v9) = v47 - (v31 >> 1);
					//fix it v10 = *(unsigned __int8 **)(**filearray_2aa18c[24] + 6 * i);
					v10 = 0;  //fix it
					v45 = v9;
					v33 = (unsigned __int8)(v36 >> 1) - v8;
					v38 = 0;
					v11 = v36 * (v48 - (v31 >> 1));
					while (v38 < v31)
					{
						v35 = v11 + v33;
						v32 = 0;
						v42 = v45;
						while (v32 < v39)
						{
							if (*(x_BYTE *)(a1 + 14) & 1)
								sub_57390(v42, *(x_WORD *)(a1 + 26));
							v12 = v10[1];
							if (v12 != -1)
								*(x_WORD *)(v30 + 2 * v35) = v12 + (x_WORD)v40 - x_BYTE_11B4E0[v42];
							v13 = *(x_DWORD *)(a1 + 16) % 7;
							if ((!v13 || *(x_DWORD *)(a1 + 16) == 1) && *v10 != -1)
								sub_45DC0(v13, 7, v42, *v10);
							v10 += 2;
							++v32;
							LOBYTE(v42) = v42 + 1;
							++v35;
						}
						v11 += v36;
						++v38;
						++HIBYTE(v45);
					}
				}
				LOWORD(v1) = v41;
				v14 = 0;
				v15 = 0;
				for (j = v41; v14 < v37; ++HIBYTE(j))
				{
					for (k = 0; k < v36; k++)
					{
						if (*(x_WORD *)(v30 + 2 * v15))
						{
							if (!x_BYTE_11B4E0[j] || sub_57450(x_BYTE_10B4E0[j]))
							{
								x_BYTE_13B4E0[j] = x_BYTE_13B4E0[j] & 0xF8 | 1;
								sub_46570(j, j);
							}
							x_BYTE_11B4E0[j] += (signed int)*(signed __int16 *)(v30 + 2 * v15) / *(x_DWORD *)(a1 + 16);
							if (*(x_DWORD *)(a1 + 16) == 1)
							{
								v16 = x_BYTE_13B4E0[j];
								if (v16 < 0)
								{
									v17 = x_BYTE_D41B6;
									x_BYTE_13B4E0[j] = v16 & 0x7F;
									if (!v17)
										x_BYTE_13B4E0[j] = v16 & 0x7F | 8;
								}
							}
						}
						if (x_BYTE_D41B6)
						{
							v18 = x_BYTE_11B4E0[j];
							if (v18 >= (signed __int16)v40)
								v19 = (unsigned __int8)v18;
							else
								v19 = (signed __int16)v40;
							v20 = v19 + 100;
							if (v20 > 255)
								v20 = 255;
							v21 = (unsigned __int8)x_BYTE_14B4E0[j];
							if (v20 > v21)
								x_BYTE_14B4E0[j] += (v20 - v21) / *(x_DWORD *)(a1 + 16);
							v22 = x_BYTE_11B4E0[j];
							if ((unsigned __int8)x_BYTE_14B4E0[j] > v22)
							{
								x_BYTE_13B4E0[j] &= 0xF7u;
							}
							else
							{
								x_BYTE_14B4E0[j] = v22 - 1;
								x_BYTE_13B4E0[j] |= 8u;
							}
						}
						if (!x_BYTE_D41B6 && *(x_DWORD *)(a1 + 16) == 2)
							x_BYTE_13B4E0[j] &= 0xF7u;
						LOBYTE(j) = j + 1;
						++v15;
					}
					LOBYTE(j) = v49 - (v36 >> 1);
					LOWORD(v1) = __PAIR__(HIBYTE(j), (unsigned __int8)v41) + 256;
					++v14;
				}
			}
		}
	}
	//return v1;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D41B6: using guessed type char x_BYTE_D41B6;
// E9C38: using guessed type int x_DWORD_E9C38_smalltit;
// EA3BC: using guessed type int **filearray_2aa18c[24];
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00038270) --------------------------------------------------------
int sub_38270(int a1)
{
	int v1; // ebx
	int result; // eax
	int v3; // eax

	*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
	v1 = 0;
	switch (*(unsigned __int16 *)(a1 + 20) % 0xCu)
	{
	case 0u:
	case 1u:
		result = sub_4A190((int)&x_WORD_EB398, 5, 4);
		v1 = result;
		if (!result)
			goto LABEL_10;
		*(x_BYTE *)(result + 69) = 33;
		break;
	case 2u:
	case 3u:
		result = sub_4A190((int)&x_WORD_EB398, 5, 14);
		v1 = result;
		if (!result)
			goto LABEL_10;
		*(x_BYTE *)(result + 69) = 113;
		break;
	case 4u:
	case 5u:
	case 6u:
	case 7u:
	case 8u:
		result = sub_4A190((int)&x_WORD_EB398, 5, 13);
		v1 = result;
		if (!result)
			goto LABEL_10;
		*(x_BYTE *)(result + 69) = 105;
		break;
	case 9u:
	case 0xAu:
	case 0xBu:
		v3 = sub_4A190((int)&x_WORD_EB398, 5, 12);
		v1 = v3;
		if (v3)
			*(x_BYTE *)(v3 + 69) = 97;
		goto LABEL_10;
	default:
	LABEL_10:
		result = v1;
		break;
	}
	return result;
}
// EB398: using guessed type __int16 x_WORD_EB398;

//----- (00038330) --------------------------------------------------------
int sub_38330(int a1)
{
	unsigned int v1; // eax
	signed int v2; // edx
	int v3; // eax
	int v4; // eax
	__int16 v5; // dx
	unsigned int v6; // edx
	__int16 v7; // cx
	__int16 v8; // ax
	__int16 v9; // cx
	unsigned int v10; // ecx
	int result; // eax

	v1 = sub_38B00(a1);
	if (v1 < 1)
	{
		if (v1)
			goto LABEL_31;
	}
	else
	{
		if (v1 > 1)
		{
			if (v1 == 2)
				*(x_BYTE *)(a1 + 69) = 53;
			goto LABEL_31;
		}
		v2 = *(x_DWORD *)(a1 + 16);
		if (v2 > 2)
		{
			v3 = *(char *)(a1 + 70);
			*(x_DWORD *)(a1 + 16) = v2 - 1;
			if (x_BYTE_D93C2[4 * v3] & 1)
			{
				*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
				*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
				x_WORD_EB398 += *(x_WORD *)(a1 + 84);
				v4 = sub_4A190((int)&x_WORD_EB398, 5, 4);
				if (v4)
				{
					*(x_BYTE *)(v4 + 69) = 33;
					v5 = *(x_WORD *)(a1 + 38);
					*(x_DWORD *)(v4 + 94) = 1;
					*(x_WORD *)(v4 + 98) = v5;
				}
			}
			v6 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 38)];
			if (v6 > x_DWORD_EA3E4[0] && (!*(x_BYTE *)(v6 + 64) || *(x_BYTE *)(v6 + 64) == 1))
				*(x_WORD *)(*(x_DWORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 38)] + 164) + 584) = 200;
		}
	}
	v7 = *(x_WORD *)(a1 + 104);
	if (v7)
	{
		if (v7 != *(x_WORD *)(a1 + 148))
		{
			if (*(x_DWORD *)(a1 + 100))
			{
				*(x_WORD *)(a1 + 148) = v7;
				sub_6E450(v7, -1, 4);
				*(x_DWORD *)(a1 + 12) &= 0xFFDFFFFE;
				*(x_BYTE *)(a1 + 14) |= 0x20u;
				sub_49CD0((x_WORD *)a1, 177);
				*(x_WORD *)(a1 + 90) += *(x_WORD *)(*(x_DWORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 104)] + 164) + 56);
			}
			else if (!(*(x_BYTE *)(a1 + 14) & 0x20))
			{
				v8 = *(x_WORD *)(a1 + 104);
				*(x_WORD *)(a1 + 148) = v8;
				sub_6E450(v8, -1, 4);
				*(x_BYTE *)(a1 + 12) &= 0xFEu;
				sub_49CD0((x_WORD *)a1, 177);
				*(x_WORD *)(a1 + 90) += *(x_WORD *)(*(x_DWORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 104)] + 164) + 56);
			}
		}
		*(x_WORD *)(a1 + 104) = 0;
		*(x_DWORD *)(a1 + 100) = 0;
	}
	if (!(*(x_BYTE *)(a1 + 62) & 0x1F))
	{
		if (x_BYTE_D93C2[4 * *(char *)(a1 + 70)] & 1)
		{
			v9 = *(x_WORD *)(a1 + 132);
			if (v9 > 5 && v9 == *(x_DWORD *)(a1 + 16))
			{
				v10 = *(signed __int16 *)(a1 + 132);
				*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
				if ((signed int)(*(unsigned __int16 *)(a1 + 20) % v10) > *(signed __int16 *)(a1 + 132)
					- (*(signed __int16 *)(a1 + 132) >> 4)
					- 2)
				{
					*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
					*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
					x_WORD_EB398 += *(x_WORD *)(a1 + 84);
					sub_38270(a1);
				}
			}
		}
	}
	if (x_BYTE_D93C2[4 * *(char *)(a1 + 70)] & 1)
		sub_5C8D0(a1);
LABEL_31:
	result = sub_10C40((__int16 *)(a1 + 76));
	*(x_WORD *)(a1 + 80) = result;
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;

//----- (000385C0) --------------------------------------------------------
int sub_385C0(int a1)
{
	unsigned __int8 v1; // dl
	int v2; // eax
	x_BYTE *v3; // edi
	int v4; // esi
	signed int v5; // edx
	int v6; // eax
	__int16 v7; // dx
	unsigned int v8; // esi
	char v9; // dh
	unsigned __int8 v10; // cl
	char v11; // ch
	int v13; // esi
	__int16 v14; // cx
	char v15; // ah
	unsigned int v16; // edi
	x_BYTE *v17; // eax
	unsigned int v18; // esi
	unsigned int v19; // [esp+0h] [ebp-28h]
	int v20; // [esp+4h] [ebp-24h]
	unsigned int v21; // [esp+8h] [ebp-20h]
	x_BYTE *v22; // [esp+Ch] [ebp-1Ch]
	unsigned int v23; // [esp+10h] [ebp-18h]
	unsigned int v24; // [esp+14h] [ebp-14h]
	__int16 v25; // [esp+18h] [ebp-10h]
	unsigned __int16 v26; // [esp+1Ch] [ebp-Ch]
	unsigned __int16 v27; // [esp+1Ch] [ebp-Ch]
	unsigned __int16 v28; // [esp+20h] [ebp-8h]
	unsigned __int16 v29; // [esp+20h] [ebp-8h]
	unsigned __int16 v30; // [esp+24h] [ebp-4h]

	v1 = *(x_BYTE *)(a1 + 70);
	/*v22 = *(x_BYTE **)(**filearray_2aa18c[24] + 6 * v1);
	v21 = *(unsigned __int8 *)(**filearray_2aa18c[24] + 6 * v1 + 5);
	v24 = *(unsigned __int8 *)(**filearray_2aa18c[24] + 6 * v1 + 4);
	if ( x_WORD_180660_VGA_type_resolution == 1 )
	{
	  v21 >>= 1;
	  v24 = (unsigned int)*(unsigned __int8 *)(**filearray_2aa18c[24] + 6 * v1 + 4) >> 1;
	}*/ // fix it
	v24 = 0;v21 = 0;v22 = 0;  //fix it
	LOBYTE(v30) = ((unsigned __int16)(*(x_WORD *)(a1 + 76) + 128) >> 8) - (v24 >> 1);
	HIBYTE(v30) = ((unsigned __int16)(*(x_WORD *)(a1 + 78) + 128) >> 8) - (v21 >> 1);
	if (!*(x_BYTE *)(a1 + 61))
	{
		if (*(x_BYTE *)(a1 + 64))
			LOWORD(v2) = sub_48DF0(v30, SHIBYTE(v30), v21, v24);
		else
			v2 = *(signed __int16 *)(a1 + 80) >> 5;
		v25 = v2;
		v19 = 0;
		v28 = v30;
		v3 = v22;
		v20 = 0;
		while (v19 < v21)
		{
			v23 = 0;
			v26 = v28;
			while (v23 < v24)
			{
				if (v3[1] != -1 || -1 != *v3)
				{
					x_WORD_EB398 = (unsigned __int8)v26 << 8;
					x_WORD_EB39A = HIBYTE(v28) << 8;
					++v20;
					x_WORD_EB39C = 32 * v25;
					if (!(v20 & 7))
						x_WORD_EB39C = 32 * (v25 - 10);
					v4 = *(x_DWORD *)(a1 + 16);
					if (v4 > 0)
					{
						*(x_DWORD *)(a1 + 16) = v4 - 1;
						if (x_BYTE_D93C2[4 * *(char *)(a1 + 70)] & 1)
						{
							v5 = *(x_DWORD *)(a1 + 16);
							if (v5)
							{
								if (v5 >= 4)
								{
									v6 = sub_38270(a1);
								}
								else
								{
									v6 = sub_4A190((int)&x_WORD_EB398, 5, 4);
									if (v6)
										*(x_BYTE *)(v6 + 69) = 33;
								}
							}
							else
							{
								v6 = sub_4A190((int)&x_WORD_EB398, 5, 12);
								if (v6)
									*(x_BYTE *)(v6 + 69) = 97;
							}
							if (v6)
							{
								v7 = *(x_WORD *)(a1 + 38);
								*(x_DWORD *)(v6 + 94) = 1;
								*(x_WORD *)(v6 + 98) = v7;
							}
						}
					}
					v8 = v26;
					v9 = x_BYTE_13B4E0[v26] & 0x7F;
					x_BYTE_13B4E0[(unsigned __int16)v8] = x_BYTE_13B4E0[(unsigned __int16)v8] & 0x70 | 1;
					sub_46570(v8, v8);
					v10 = v3[1];
					if (v10 != -1)
					{
						if (v10 >= x_BYTE_11B4E0[v26])
						{
							x_BYTE_11B4E0[v26] = 0;
						}
						else
						{
							*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
							if ((signed int)(*(unsigned __int16 *)(a1 + 20) % 0x32u) <= 20)
							{
								x_BYTE_11B4E0[v26] -= v3[1];
							}
							else
							{
								*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
								x_BYTE_11B4E0[v26] -= v3[1] - *(x_WORD *)(a1 + 20) % 0x14u;
							}
						}
					}
				}
				v3 += 2;
				++v23;
				LOBYTE(v26) = v26 + 1;
			}
			++v19;
			++HIBYTE(v28);
		}
		sub_48B50(v30, SHIBYTE(v30), (unsigned __int16)v21, (unsigned __int16)v24);
		v11 = *(x_BYTE *)(a1 + 65);
		if (v11)
			sub_4A1E0(v11, 1);
		if (*(x_BYTE *)(a1 + 70) == 68)
		{
			*(x_WORD *)(x_D41A0_BYTEARRAY_0 + 222538) = 0;
			sub_57F10(a1);
			return 1;
		}
		sub_57F10(a1);
		return 1;
	}
	v13 = sub_4A190(a1 + 76, 10, 45);
	if (!v13)
	{
		*(x_BYTE *)(a1 + 61) = 0;
		sub_57F10(a1);
		return 1;
	}
	sub_49A30(v13, *(char *)(a1 + 61));
	*(x_WORD *)(v13 + 80) = *(x_WORD *)(a1 + 158);
	*(x_BYTE *)(v13 + 65) = *(x_BYTE *)(a1 + 65);
	v14 = *(x_WORD *)(a1 + 148);
	if (v14)
	{
		v15 = *(x_BYTE *)(v13 + 12);
		*(x_WORD *)(v13 + 148) = v14;
		*(x_BYTE *)(v13 + 12) = v15 | 1;
		if (*(x_BYTE *)(a1 + 14) & 0x20)
			*(x_BYTE *)(v13 + 14) |= 0x20u;
		else
			*(x_BYTE *)(v13 + 14) &= 0xDFu;
		sub_49CD0((x_WORD *)v13, 177);
		*(x_WORD *)(v13 + 90) = *(x_WORD *)(a1 + 90);
	}
	sub_59760(a1, v13);
	v16 = 0;
	v29 = v30;
	v17 = v22;
	while (v16 < v21)
	{
		v18 = 0;
		v27 = v29;
		while (v18 < v24)
		{
			if (v17[1] != -1 || -1 != *v17)
				x_BYTE_13B4E0[v27] &= 0x7Fu;
			++v18;
			v17 += 2;
			LOBYTE(v27) = v27 + 1;
		}
		++v16;
		++HIBYTE(v29);
	}
	sub_57F10(a1);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3BC: using guessed type int **filearray_2aa18c[24];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39A: using guessed type __int16 x_WORD_EB39A;
// EB39C: using guessed type __int16 x_WORD_EB39C;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (000389F0) --------------------------------------------------------
int sub_389F0(int a1)
{
	int v1; // eax
	__int16 v2; // dx

	v1 = *(x_DWORD *)(a1 + 8);
	++*(x_DWORD *)(a1 + 16);
	*(x_DWORD *)(a1 + 8) = v1 - 1;
	if (v1 >= 0)
	{
		sub_585A0(a1);
		if (!(*(x_BYTE *)(a1 + 12) & 2))
		{
			*(x_BYTE *)(a1 + 12) |= 2u;
			if ((signed __int16)sub_10C40((__int16 *)(a1 + 76)) > 58880)
				sub_5F890(a1, 0);
			if (sub_106C0(
				a1,
				x_DWORD_EA3E4[*(unsigned __int16 *)(*(x_DWORD *)(x_DWORD_EA3E4[*(signed __int16 *)(a1 + 26)] + 164) + 58)]))
			{
				v2 = *(x_WORD *)(a1 + 26);
				*(x_WORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(*(x_DWORD *)(x_DWORD_EA3E4[*(signed __int16 *)(a1 + 26)] + 164) + 58)]
					+ 128) = v2;
				*(x_DWORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(*(x_DWORD *)(x_DWORD_EA3E4[v2] + 164) + 58)] + 124) = 10;
			}
			else
			{
				sub_5F890(a1, 0);
			}
		}
	}
	sub_57F10(a1);
	return 1;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00038B00) --------------------------------------------------------
signed int sub_38B00(int a1)
{
	signed int v1; // ebx
	int v3; // ecx
	__int16 v4; // bx

	*(x_WORD *)(a1 + 38) = 0;
	v1 = 0;
	if (*(x_DWORD *)(a1 + 8) < 0)
		return 2;
	if (*(x_WORD *)(a1 + 98))
	{
		v3 = *(x_DWORD *)(a1 + 8) - *(x_DWORD *)(a1 + 94);
		*(x_DWORD *)(a1 + 8) = v3;
		if (v3 < 0)
		{
			v4 = *(x_WORD *)(a1 + 98);
			*(x_WORD *)(a1 + 36) = v4;
			*(x_WORD *)(a1 + 38) = v4;
			return 2;
		}
		*(x_WORD *)(a1 + 38) = *(x_WORD *)(a1 + 98);
		*(x_DWORD *)(a1 + 94) = 0;
		v1 = 1;
		*(x_WORD *)(a1 + 98) = 0;
	}
	return v1;
}

//----- (00038B90) --------------------------------------------------------
int sub_38B90(int a1)
{
	int v1; // eax
	int result; // eax
	Bit8u* v3; // eax
	int v4; // edi
	int v5; // eax
	int v6; // esi
	int v7; // edx
	__int16 v8; // [esp+0h] [ebp-10h]
	__int16 v9; // [esp+2h] [ebp-Eh]
	__int16 v10; // [esp+4h] [ebp-Ch]
	int v11; // [esp+8h] [ebp-8h]
	int v12; // [esp+Ch] [ebp-4h]

	v1 = *(x_DWORD *)(a1 + 8);
	*(x_DWORD *)(a1 + 8) = v1 - 1;
	if (v1 < 0)
	{
		return 1;
	}
	if (!(*(x_BYTE *)(a1 + 12) & 2))
	{
		v3 = x_D41A0_BYTEARRAY_0 + 28302;
		*(x_DWORD *)(a1 + 12) |= (unsigned int)&loc_10001 + 1;
		sub_6E450((a1 - (int)v3) / 168, -1, 30);
	}
	sub_49EA0(
		(x_WORD *)a1,
		(768 * *(x_DWORD *)(a1 + 16)
			- (__CFSHL__(768 * *(x_DWORD *)(a1 + 16) >> 31, 2)
				+ 4 * (768 * *(x_DWORD *)(a1 + 16) >> 31))) >> 2,
		512);
	sub_10C80(a1, 0, (signed int)*(unsigned __int16 *)(a1 + 42) / *(x_DWORD *)(a1 + 4));
	v4 = sub_10080(*(x_DWORD *)(a1 + 16), *(x_DWORD *)(a1 + 16));
	if (v4)
	{
		*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
		while (sub_10130(v4, &v12, &v11) == 1)
		{
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			v8 = *(x_WORD *)(a1 + 76) - 96 + 160 * v12 + *(x_WORD *)(a1 + 20) % 0x81u - 64;
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			v9 = *(x_WORD *)(a1 + 20) % 0x81u + *(x_WORD *)(a1 + 78) - 96 + 160 * v11 - 64;
			v10 = *(x_WORD *)(a1 + 80);
			v5 = sub_4A190((int)&v8, 10, 0);
			v6 = v5;
			if (v5)
			{
				*(x_WORD *)(v5 + 26) = *(x_WORD *)(a1 + 26);
				*(x_WORD *)(v5 + 28) = *(x_WORD *)(a1 + 28);
				*(x_DWORD *)(v5 + 12) |= (unsigned int)sub_10080;
				sub_49EA0((x_WORD *)v5, 512, 512);
				*(x_DWORD *)(v6 + 16) = 0;
			}
		}
		sub_10100(v4);
	}
	v7 = *(x_DWORD *)(a1 + 16) + 2;
	result = v7 / 7;
	*(x_DWORD *)(a1 + 16) = v7 % 7;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00038D80) --------------------------------------------------------
unsigned int sub_38D80(int a1)
{
	unsigned int result; // eax
	unsigned int i; // ebx
	unsigned int v3; // ecx

	result = *(x_DWORD *)(a1 + 8);
	*(x_DWORD *)(a1 + 8) = result - 1;
	if ((result & 0x80000000) != 0)
	{
		sub_57F10(a1);
		return 0;
	}
	for (i = x_D41A0_BYTEARRAY_4[0x967B]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
	{
		if (!*(x_WORD *)(i + 122))
		{
			result = sub_584D0((x_WORD *)(a1 + 76), (x_WORD *)(i + 76));
			if (result < *(x_DWORD *)(a1 + 16))
			{
				v3 = sub_7277A(result);
				if (v3 > 0x2A)
					v3 = 42;
				result = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
				*(x_DWORD *)(i + 118) = v3;
				*(x_WORD *)(i + 122) = result;
			}
		}
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00038E20) --------------------------------------------------------
int sub_38E20(int a1)
{
	sub_57F10(a1);
	return 1;
}

//----- (00038E40) --------------------------------------------------------
int sub_38E40(int a1)
{
	sub_57F10(a1);
	return 1;
}

//----- (00038E70) --------------------------------------------------------
int sub_38E70(int a1)
{
	int v1; // ebx
	int v2; // eax
	unsigned __int8 v3; // dh

	if (*(x_WORD *)(a1 + 150))
	{
		v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
		if (*(x_BYTE *)(v1 + 63) == 3 && !*(x_BYTE *)(v1 + 64))
		{
			v2 = *(x_DWORD *)(v1 + 164);
			v3 = *(x_BYTE *)(v2 + 332);
			if (v3 < 3u)
			{
				if (!v3)
				{
					*(x_WORD *)(v2 + 30) = -80;
					*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
					sub_6E450(*(x_WORD *)(a1 + 150), -1, (*(x_WORD *)(a1 + 20) & 3) + 54);
				}
				sub_5C830(v1, 3, 171 * (unsigned __int8)++*(x_BYTE *)(*(x_DWORD *)(v1 + 164) + 332) / 3 + 85);
			}
			*(x_BYTE *)(*(x_DWORD *)(v1 + 164) + 333) = 8;
		}
	}
	sub_57F10(a1);
	return 1;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00038F70) --------------------------------------------------------
int sub_38F70(x_WORD *a1)
{
	int v1; // esi
	int v2; // eax

	if (a1[75])
	{
		v1 = x_DWORD_EA3E4[(unsigned __int16)a1[75]];
		if (*(x_BYTE *)(v1 + 63) == 3 && !*(x_BYTE *)(v1 + 64))
		{
			v2 = *(x_DWORD *)(v1 + 164);
			if (!*(x_BYTE *)(v2 + 334))
			{
				*(x_WORD *)(v2 + 30) = -80;
				a1[10] = 9377 * a1[10] + 9439;
				sub_6E450(a1[75], -1, (a1[10] & 3) + 54);
				sub_11900((int)a1, v1, 0, a1[21]);
			}
			*(x_BYTE *)(*(x_DWORD *)(v1 + 164) + 334) = 1;
			*(x_BYTE *)(*(x_DWORD *)(v1 + 164) + 335) = 10;
		}
	}
	sub_57F10((int)a1);
	return 1;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00039040) --------------------------------------------------------
char sub_39040(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // edx
	unsigned __int8 v4; // bl
	unsigned __int16 v5; // ax
	int v6; // edx
	int v7; // ecx
	unsigned __int16 v8; // bx
	signed int v9; // eax
	__int16 v10; // ax
	int v11; // ecx
	int v12; // ecx
	char v13; // dl
	int v14; // esi
	int v15; // edx
	int v16; // esi
	char v17; // al
	unsigned __int16 v18; // cx
	int v19; // eax
	int v20; // ecx
	int v21; // eax
	char v22; // dh
	unsigned __int16 v23; // dx
	__int16 v24; // ax
	signed int v25; // esi
	unsigned __int16 v26; // bx
	int v27; // ecx
	int v28; // edi
	int v29; // eax
	unsigned __int16 v30; // bx
	signed int v31; // esi
	signed int v32; // edi
	unsigned __int16 v33; // ax
	__int16 v34; // dx
	unsigned __int16 v35; // bx
	signed int v36; // eax
	signed int v37; // edx
	unsigned __int16 v38; // si
	__int16 v40; // [esp+0h] [ebp-3Ch]
	__int16 v41; // [esp+2h] [ebp-3Ah]
	int v42; // [esp+8h] [ebp-34h]
	__int16 v43; // [esp+Ch] [ebp-30h]
	int i; // [esp+10h] [ebp-2Ch]
	int v45; // [esp+14h] [ebp-28h]
	int v46; // [esp+18h] [ebp-24h]
	int v47; // [esp+1Ch] [ebp-20h]
	int v48; // [esp+20h] [ebp-1Ch]
	int v49; // [esp+24h] [ebp-18h]
	int v50; // [esp+28h] [ebp-14h]
	int v51; // [esp+2Ch] [ebp-10h]
	int v52; // [esp+30h] [ebp-Ch]
	int v53; // [esp+34h] [ebp-8h]
	char v54; // [esp+38h] [ebp-4h]

	v54 = 0;
	LOBYTE(v1) = a1;
	v2 = *(x_DWORD *)(a1 + 8) - 1;
	x_DWORD_E9B90 = 0;
	*(x_DWORD *)(a1 + 8) = v2;
	if (v2 <= 0)
	{
		*(x_BYTE *)(a1 + 69) = 74;
		*(x_BYTE *)(a1 + 70) = 0;
	}
	else
	{
		v3 = (*(signed __int16 *)(a1 + 76) + 128) >> 8;
		v1 = (*(signed __int16 *)(a1 + 78) + 128) >> 8;
		LOBYTE(v53) = v3 - 15;
		BYTE1(v53) = v1 - 15;
		LOBYTE(v52) = v3;
		v4 = *(x_BYTE *)(a1 + 70);
		BYTE1(v52) = v1;
		if (v4 <= 3u)
		{
			switch (v4)
			{
			case 0u:
				LOBYTE(v1) = sub_39E40(a1);
				if ((x_BYTE)v1)
					*(x_BYTE *)(a1 + 70) = 1;
				else
					sub_57F10(a1);
				break;
			case 1u:
				v5 = sub_48DF0(v3 - 9, v1 - 9, 18, 18);
				*(x_WORD *)(a1 + 80) = 0;
				*(x_WORD *)(a1 + 44) = 0;
				if ((signed int)v5 > 64)
				{
					*(x_WORD *)(a1 + 80) = v5 - 64;
					if ((signed __int16)(v5 - 64) > 16)
						*(x_WORD *)(a1 + 44) = 32 * (v5 - 80);
				}
				*(x_DWORD *)(a1 + 144) = 0;
				*(x_BYTE *)(a1 + 70) = 2;
				*(x_DWORD *)(a1 + 16) = 12;
				sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 64);
				goto LABEL_11;
			case 2u:
			LABEL_11:
				v6 = *(x_DWORD *)(a1 + 16) - 1;
				*(x_DWORD *)(a1 + 16) = v6;
				if (v6 <= 0)
				{
					*(x_BYTE *)(a1 + 70) = 3;
				}
				else
				{
					v7 = 0;
					for (HIBYTE(v8) = BYTE1(v53); ; ++HIBYTE(v8))
					{
						v51 = v7;
						if (v7 >= 30)
							break;
						LOBYTE(v8) = v53;
						for (i = 0; i < 30; i++)
						{
							v40 = (unsigned __int8)v8 << 8;
							v41 = HIBYTE(v8) << 8;
							v9 = sub_58490((x_WORD *)(a1 + 76), &v40);
							v48 = v9;
							if (v9 < 3840)
							{
								if (v9 >= 2304)
								{
									v10 = sub_581E0((Bit16u *)(a1 + 76), (Bit16u *)&v40);
									v42 = *(x_DWORD *)(a1 + 76);
									v43 = *(x_WORD *)(a1 + 80);
									sub_57FA0((x_WORD*)&v42, v10, 0, 3840);
									v11 = (signed __int16)sub_10C40((__int16 *)&v42) >> 5;
									if (*(signed __int16 *)(a1 + 44) < v11)
										*(x_WORD *)(a1 + 44) = v11;
									v50 = v11
										- (((x_DWORD)((x_DWORD)sub_10000 + (signed int)off_DBF50[((v48 - 2304) << 10) / 1536]) >> 1)
											* (v11 - (*(signed __int16 *)(a1 + 80) + 64)) >> 16);
								}
								else
								{
									v50 = *(signed __int16 *)(a1 + 80)
										+ 64
										- (((char *)sub_10000 - (char *)off_DBF50[((2304 - v9) << 9) / 2304]) << 6 >> 16);
								}
								v12 = (v50 - x_BYTE_11B4E0[v8]) / *(x_DWORD *)(a1 + 16)
									+ x_BYTE_11B4E0[v8];
								if (v12 < 1)
									v12 = 1;
								if (v12 > 255)
									v12 = 255;
								v13 = x_BYTE_D41B6;
								x_BYTE_11B4E0[v8] = v12;
								if (v13)
								{
									v50 = v12 + 64;
									if (v12 + 64 > 254)
										v50 = 254;
									v14 = (unsigned __int8)x_BYTE_14B4E0[v8];
									v15 = (unsigned __int8)x_BYTE_14B4E0[v8];
									v47 = v8;
									v50 = v14 - (v15 - v50) / *(x_DWORD *)(a1 + 16);
									x_BYTE_14B4E0[v47] = v50;
								}
								v16 = *(signed __int16 *)(a1 + 80);
								if (v12 <= v16 + 64 && v12 >= v16 + 6 * *(x_DWORD *)(a1 + 16) && sub_57450(x_BYTE_10B4E0[v8]))
								{
									v17 = x_BYTE_13B4E0[v8] & 0xF8;
									v54 = 1;
									x_BYTE_10B4E0[v8] = 1;
									x_BYTE_13B4E0[v8] = v17 | 1;
								}
							}
							LOBYTE(v8) = v8 + 1;
							++HIBYTE(v8);
							v18 = v8;
							LOBYTE(v8) = v8 - 2;
							HIBYTE(v8) -= 2;
							v19 = x_BYTE_11B4E0[v8];
							LOBYTE(v8) = v8 + 1;
							v20 = v19 - x_BYTE_11B4E0[v18] + 32;
							++HIBYTE(v8);
							if (v20 >= 28)
							{
								if (v20 > 40)
									v20 = (v20 & 7) + 40;
							}
							else
							{
								v20 = (v20 & 3) + 28;
							}
							if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308))
								v21 = 32 - v20 + 32;
							else
								LOBYTE(v21) = v20;
							v22 = x_BYTE_D41B6;
							x_BYTE_12B4E0[v8] = v21;
							if (v22)
							{
								if (x_BYTE_14B4E0[v8] > x_BYTE_11B4E0[v8])
									x_BYTE_13B4E0[v8] &= 0xF7u;
								else
									x_BYTE_13B4E0[v8] |= 8u;
							}
							LOBYTE(v8) = v8 + 1;
						}
						v7 = v51 + 1;
					}
					if (*(x_DWORD *)(a1 + 16) == 5)
					{
						sub_3A090((unsigned __int16 *)a1);
						v54 = 1;
					}
					if (v54)
					{
						LOBYTE(v23) = v52 - 15;
						LOBYTE(v24) = v52 + 15;
						HIBYTE(v23) = BYTE1(v52) - 15;
						HIBYTE(v24) = BYTE1(v52) + 15;
						sub_462A0(v23, v24);
					}
					v25 = 0;
					HIBYTE(v26) = BYTE1(v52) - 1;
					do
					{
						v46 = 0;
						LOBYTE(v26) = v52 - 1;
						while (v46 < 2)
						{
							v27 = x_BYTE_11B4E0[v26] - (signed int)x_BYTE_11B4E0[v26] / *(x_DWORD *)(a1 + 16);
							if (v27 < 0)
								v27 = 0;
							if (v27 > 255)
								LOBYTE(v27) = -1;
							x_BYTE_11B4E0[v26] = v27;
							v28 = *(x_DWORD *)(a1 + 16);
							v29 = 31 / v28 + 32;
							if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308))
								v29 = -31 / v28 + 32;
							x_BYTE_12B4E0[v26] = v29;
							LOBYTE(v26) = v26 + 1;
							++v46;
						}
						++v25;
						++HIBYTE(v26);
					} while (v25 < 2);
				}
				LOBYTE(v1) = a1;
				if (*(x_DWORD *)(a1 + 16) < 6)
					LOBYTE(v1) = sub_39B60(a1);
				break;
			case 3u:
				HIBYTE(v30) = BYTE1(v53);
				v31 = 0;
				while (v31 < 30)
				{
					LOBYTE(v30) = v53;
					v32 = 0;
					while (v32 < 30)
					{
						v49 = v30;
						if (sub_57450(x_BYTE_10B4E0[v30]) || x_BYTE_10B4E0[v49] == 8)
						{
							x_BYTE_10B4E0[v30] = 1;
							x_BYTE_13B4E0[v30] = x_BYTE_13B4E0[v30] & 0xF8 | 1;
						}
						++v32;
						LOBYTE(v30) = v30 + 1;
					}
					++v31;
					++HIBYTE(v30);
				}
				LOBYTE(v33) = v52 - 15;
				LOBYTE(v34) = v52 + 15;
				HIBYTE(v33) = BYTE1(v52) - 15;
				HIBYTE(v34) = BYTE1(v52) + 15;
				sub_46570(v33, v34);
				HIBYTE(v35) = BYTE1(v52) - 1;
				v36 = 0;
				while (v36 < 2)
				{
					v37 = 0;
					LOBYTE(v35) = v52 - 1;
					while (v37 < 2)
					{
						if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308))
							v45 = 1;
						else
							v45 = 63;
						v38 = v35;
						++v37;
						LOBYTE(v35) = v35 + 1;
						x_BYTE_12B4E0[v38] = v45;
					}
					++v36;
					++HIBYTE(v35);
				}
				sub_39B60(a1);
				LOBYTE(v1) = a1;
				*(x_BYTE *)(a1 + 69) = 73;
				break;
			}
		}
	}
	return v1;
}
// 10000: using guessed type void /*__noreturn*/ sub_10000();
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41B6: using guessed type char x_BYTE_D41B6;
// DBF50: using guessed type void (/*__noreturn*/ *off_DBF50[2])();
// E9B90: using guessed type int x_DWORD_E9B90;

//----- (000396A0) --------------------------------------------------------
int sub_396A0(int a1)
{
	int result; // eax
	int v2; // edx

	result = a1;
	v2 = *(x_DWORD *)(a1 + 8) - 1;
	*(x_DWORD *)(a1 + 8) = v2;
	if (v2 > 0)
		return sub_39B60(a1);
	*(x_BYTE *)(a1 + 69) = 74;
	*(x_BYTE *)(a1 + 70) = 0;
	return result;
}

//----- (000396D0) --------------------------------------------------------
unsigned __int8 sub_396D0(int a1)
{
	int v1; // eax
	__int16 v2; // dx
	unsigned __int8 result; // al
	signed int v4; // edi
	__int16 v5; // dx
	unsigned __int16 v6; // bx
	unsigned __int16 v7; // dx
	__int16 v8; // ax
	int v9; // edx
	unsigned __int16 v10; // bx
	__int16 v11; // ax
	__int16 v12; // ax
	int v13; // ecx
	int v14; // edx
	int v15; // ecx
	unsigned __int16 v16; // ax
	int v17; // edx
	int v18; // eax
	int v19; // edx
	char v20; // ch
	unsigned __int16 v21; // bx
	signed int v22; // edi
	signed int v23; // esi
	char v24; // al
	unsigned __int16 v25; // dx
	unsigned int j; // ecx
	char v27; // dl
	int v28; // [esp+0h] [ebp-30h]
	__int16 v29; // [esp+4h] [ebp-2Ch]
	__int16 v30; // [esp+8h] [ebp-28h]
	__int16 v31; // [esp+Ah] [ebp-26h]
	int i; // [esp+10h] [ebp-20h]
	int k; // [esp+14h] [ebp-1Ch]
	int v34; // [esp+18h] [ebp-18h]
	int v35; // [esp+1Ch] [ebp-14h]
	int v36; // [esp+20h] [ebp-10h]
	int v37; // [esp+24h] [ebp-Ch]
	char v38; // [esp+28h] [ebp-8h]
	char v39; // [esp+2Ch] [ebp-4h]

	v1 = (*(signed __int16 *)(a1 + 78) + 128) >> 8;
	v2 = *(x_WORD *)(a1 + 76) + 128;
	v38 = v1;
	BYTE1(v37) = v1 - 15;
	v39 = HIBYTE(v2);
	result = *(x_BYTE *)(a1 + 70);
	LOBYTE(v37) = HIBYTE(v2) - 15;
	if (result < 1u)
	{
		if (result)
			return result;
		sub_39B60(a1);
		sub_3A090((unsigned __int16 *)a1);
		*(x_BYTE *)(a1 + 70) = 1;
		v4 = 0;
		v5 = *(x_WORD *)(a1 + 80);
		*(x_DWORD *)(a1 + 16) = 16;
		*(x_WORD *)(a1 + 80) = v5 + 64;
		HIBYTE(v6) = BYTE1(v37);
		while (v4 < 30)
		{
			LOBYTE(v6) = v37;
			for (i = 0; i < 30; i++)
			{
				if (sub_57450(x_BYTE_10B4E0[v6]))
				{
					x_BYTE_10B4E0[v6] = 1;
					x_BYTE_13B4E0[v6] = x_BYTE_13B4E0[v6] & 0xF8 | 1;
				}
				LOBYTE(v6) = v6 + 1;
			}
			++v4;
			++HIBYTE(v6);
		}
		LOBYTE(v7) = v39 - 15;
		LOBYTE(v8) = v39 + 15;
		HIBYTE(v7) = v38 - 15;
		HIBYTE(v8) = v38 + 15;
		sub_462A0(v7, v8);
		sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 64);
	}
	else if (result > 1u)
	{
		if (result == 2)
		{
			HIBYTE(v21) = BYTE1(v37);
			v22 = 0;
			while (v22 < 30)
			{
				LOBYTE(v21) = v37;
				v23 = 0;
				while (v23 < 30)
				{
					v24 = sub_439A0(v23++, v21);
					v25 = v21;
					LOBYTE(v21) = v21 + 1;
					x_BYTE_11B4E0[v25] = v24;
				}
				++v22;
				++HIBYTE(v21);
			}
			for (j = x_D41A0_BYTEARRAY_4[0x9677]; j > x_DWORD_EA3E4[0]; j = *(x_DWORD *)j)
			{
				if (*(x_BYTE *)(j + 64) == 2
					&& *(x_BYTE *)(j + 14) & 0x10
					&& *(unsigned __int16 *)(j + 38) == (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168)
				{
					v27 = *(x_BYTE *)(j + 14);
					*(x_WORD *)(j + 38) = 0;
					*(x_BYTE *)(j + 14) = v27 & 0xEF;
				}
			}
			sub_57F10(a1);
		}
		return result;
	}
	result = a1;
	if (!(*(x_BYTE *)(a1 + 8) & 3))
	{
		v9 = *(x_DWORD *)(a1 + 16) - 1;
		*(x_DWORD *)(a1 + 16) = v9;
		if (v9 <= 0)
		{
			*(x_BYTE *)(a1 + 70) = 2;
		}
		else
		{
			HIBYTE(v10) = BYTE1(v37);
			v35 = 0;
			do
			{
				LOBYTE(v10) = v37;
				for (k = 0; k < 30; k++)
				{
					v30 = (unsigned __int8)v10 << 8;
					v31 = HIBYTE(v10) << 8;
					v36 = sub_58490((x_WORD *)(a1 + 76), &v30);
					if (v36 < 3840)
					{
						v11 = sub_581E0((Bit16u *)(a1 + 76), (Bit16u *)&v30);
						v28 = *(x_DWORD *)(a1 + 76);
						v29 = *(x_WORD *)(a1 + 80);
						sub_57FA0((x_WORD*)&v28, v11, 0, 3840);
						v12 = sub_10C40((__int16 *)&v28);
						v13 = (v12 >> 5)
							- (((x_DWORD)((x_DWORD)sub_10000 + (signed int)off_DBF50[(v36 << 10) / 3840]) >> 1)
								* ((v12 >> 5) - *(signed __int16 *)(a1 + 80)) >> 16);
						*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
						v14 = (*(x_WORD *)(a1 + 20) & 3) + v13 - 2;
						v34 = x_BYTE_11B4E0[v10];
						v34 += (v14 - v34) / *(x_DWORD *)(a1 + 16);
						if (v34 < 1)
							v34 = 1;
						if (v34 > 255)
							v34 = 255;
						x_BYTE_11B4E0[v10] = v34;
						if (*(x_DWORD *)(a1 + 16) < 3)
							x_BYTE_11B4E0[v10] = sub_439A0(v10, v10);
						if (x_BYTE_D41B6)
						{
							v15 = x_BYTE_11B4E0[v10] + 64;
							if (v15 > 254)
								v15 = 254;
							x_BYTE_14B4E0[v10] -= ((unsigned __int8)x_BYTE_14B4E0[v10] - v15) / *(x_DWORD *)(a1 + 16);
						}
					}
					LOBYTE(v10) = v10 + 1;
					++HIBYTE(v10);
					v16 = v10;
					LOBYTE(v10) = v10 - 2;
					HIBYTE(v10) -= 2;
					v17 = x_BYTE_11B4E0[v10];
					LOBYTE(v10) = v10 + 1;
					v18 = v17 - x_BYTE_11B4E0[v16] + 32;
					++HIBYTE(v10);
					if (v18 >= 28)
					{
						if (v18 > 40)
							v18 = (v18 & 7) + 40;
					}
					else
					{
						v18 = (v18 & 3) + 28;
					}
					if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308))
						v19 = 32 - v18 + 32;
					else
						LOBYTE(v19) = v18;
					v20 = x_BYTE_D41B6;
					x_BYTE_12B4E0[v10] = v19;
					if (v20)
					{
						if (x_BYTE_14B4E0[v10] > x_BYTE_11B4E0[v10])
							x_BYTE_13B4E0[v10] &= 0xF7u;
						else
							x_BYTE_13B4E0[v10] |= 8u;
					}
					result = k + 1;
					LOBYTE(v10) = v10 + 1;
				}
				++HIBYTE(v10);
				++v35;
			} while (v35 < 30);
		}
	}
	return result;
}
// 10000: using guessed type void /*__noreturn*/ sub_10000();
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// D41B6: using guessed type char x_BYTE_D41B6;
// DBF50: using guessed type void (/*__noreturn*/ *off_DBF50[2])();
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00039B60) --------------------------------------------------------
int sub_39B60(int a1)
{
	char v1; // al
	int i; // eax
	signed int v3; // eax
	int v4; // edx
	int v5; // esi
	int v6; // esi
	__int16 v7; // ax
	int v8; // ecx
	int v9; // eax
	int v10; // ebx
	int result; // eax
	__int16 v12; // [esp+0h] [ebp-1Ch]
	__int16 v13; // [esp+2h] [ebp-1Ah]
	int v14; // [esp+8h] [ebp-14h]
	int v15; // [esp+Ch] [ebp-10h]
	unsigned __int16 v16; // [esp+10h] [ebp-Ch]
	int v17; // [esp+14h] [ebp-8h]
	int v18; // [esp+18h] [ebp-4h]

	v1 = ((unsigned __int16)(*(x_WORD *)(a1 + 78) + 128) >> 8) - 13;
	LOBYTE(v15) = ((unsigned __int16)(*(x_WORD *)(a1 + 76) + 128) >> 8) - 13;
	BYTE1(v15) = v1;
	v17 = 0;
	v16 = v15;
	do
	{
		v18 = 0;
		LOBYTE(v16) = v15;
		while ((signed __int16)v18 < 26)
		{
			v12 = (unsigned __int8)v16 << 8;
			v13 = HIBYTE(v16) << 8;
			if ((unsigned int)sub_584D0((x_WORD *)(a1 + 76), &v12) < 0xA90000)
			{
				for (i = x_WORD_15B4E0[v16]; ; i = *(unsigned __int16 *)(v10 + 22))
				{
					v10 = x_DWORD_EA3E4[i];
					if (v10 == x_DWORD_EA3E4[0])
						goto LABEL_35;
					if (sub_39FA0(a1, x_DWORD_EA3E4[i]))
					{
						v3 = sub_58490((x_WORD *)(v10 + 76), (x_WORD *)(a1 + 76));
						v4 = *(signed __int16 *)(a1 + 44);
						v5 = *(signed __int16 *)(v10 + 80) - v4;
						v14 = *(signed __int16 *)(v10 + 80) - v4;
						if (v3 < 3328 && v5 < 4096)
							break;
					}
				LABEL_25:
					if (*(x_BYTE *)(a1 + 69) == 74 && *(x_BYTE *)(v10 + 14) & 0x10)
					{
						if (*(x_BYTE *)(v10 + 63) != 3
							|| *(x_BYTE *)(v10 + 64)
							|| *(x_WORD *)(*(x_DWORD *)(v10 + 164) + 56) != *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12))
						{
							*(x_BYTE *)(v10 + 12) &= 0xFEu;
						}
						else
						{
							*(x_BYTE *)(v10 + 12) |= 1u;
						}
						*(x_BYTE *)(v10 + 14) &= 0xEFu;
					}
				}
				if (v3 <= 32 || v5 <= 96)
				{
					sub_3A200(a1, v10);
					goto LABEL_25;
				}
				*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(v10 + 76);
				*(&x_WORD_EB398 + 2) = *(x_WORD *)(v10 + 80);
				v6 = ((3328 - v3) << 8) / 3328 << 7 >> 8;
				if (v6 < 4)
					v6 = 4;
				if (v6 > 128)
					v6 = 128;
				if (v6 > v3)
					LOWORD(v6) = v3;
				v7 = sub_581E0((Bit16u *)&x_WORD_EB398, (Bit16u *)(a1 + 76));
				sub_57FA0((x_WORD*)&x_WORD_EB398, v7, 0, v6);
				v8 = (signed __int16)sub_10C40(&x_WORD_EB398);
				if (*(x_BYTE *)(v10 + 63) == 3 && !*(x_BYTE *)(v10 + 64))
				{
					v9 = (signed __int16)(x_WORD_EB39C
						- (48
							* ((((4096 - v14) << 8)
								- (__CFSHL__((4096 - v14) << 8 >> 31, 12)
									+ ((4096 - v14) << 8 >> 31 << 12))) >> 12) >> 8));
					x_WORD_EB39C -= 48
						* ((((4096 - v14) << 8)
							- (__CFSHL__((4096 - v14) << 8 >> 31, 12)
								+ ((4096 - v14) << 8 >> 31 << 12))) >> 12) >> 8;
					goto LABEL_21;
				}
				if (*(signed __int16 *)(*(x_DWORD *)(v10 + 160) + 14) < -64)
					goto LABEL_40;
				x_WORD_EB39C -= 48
					* ((((4096 - v14) << 8) - (__CFSHL__((4096 - v14) << 8 >> 31, 12) + ((4096 - v14) << 8 >> 31 << 12))) >> 12) >> 8;
				v9 = x_WORD_EB39C;
			LABEL_21:
				if (v9 < v8)
					LABEL_40 :
					x_WORD_EB39C = v8;
				sub_57CF0(v10, (int)&x_WORD_EB398);
				goto LABEL_25;
			}
		LABEL_35:
			++v18;
			LOBYTE(v16) = v16 + 1;
		}
		result = v17++ + 1;
		++HIBYTE(v16);
	} while ((signed __int16)v17 < 26);
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (00039E40) --------------------------------------------------------
char sub_39E40(int a1)
{
	char v1; // ch
	signed int v2; // edx
	signed int v3; // esi
	unsigned __int16 v4; // ax
	signed int v5; // edi
	char v6; // bl
	signed int v7; // esi
	unsigned __int16 v8; // ax
	int v9; // edx
	int i; // edx
	unsigned __int8 v11; // ch
	char v12; // ch
	int v13; // edx
	int v15; // [esp+4h] [ebp-8h]

	v1 = (unsigned __int16)(*(x_WORD *)(a1 + 76) + 128) >> 8;
	v2 = 0;
	v3 = 0;
	HIBYTE(v4) = ((unsigned __int16)(*(x_WORD *)(a1 + 78) + 128) >> 8) - 15;
	while (v3 < 30)
	{
		v5 = 0;
		LOBYTE(v4) = v1 - 15;
		while (v5 < 30)
		{
			if (!x_BYTE_10B4E0[v4])
				++v2;
			++v5;
			LOBYTE(v4) = v4 + 1;
		}
		++v3;
		++HIBYTE(v4);
	}
	if (v2 >= 225)
		return 0;
	v6 = v1 - 27;
	v7 = 0;
	HIBYTE(v8) = ((unsigned __int16)(*(x_WORD *)(a1 + 78) + 128) >> 8) - 27;
	do
	{
		v9 = 0;
		for (LOBYTE(v8) = v6; ; LOBYTE(v8) = v8 + 1)
		{
			v15 = v9;
			if (v9 >= 54)
				break;
			for (i = x_WORD_15B4E0[v8]; ; i = *(unsigned __int16 *)(v13 + 22))
			{
				v13 = x_DWORD_EA3E4[i];
				if (v13 == x_DWORD_EA3E4[0])
					break;
				if (v13 != a1 && *(x_BYTE *)(v13 + 63) == 10)
				{
					v11 = *(x_BYTE *)(v13 + 64);
					if (v11 >= 0x2Du)
					{
						if (v11 <= 0x2Du)
						{
							v12 = *(x_BYTE *)(v13 + 69);
							if (v12 == 48 || v12 == 51)
								return 0;
						}
						else if (v11 == 67)
						{
							return 0;
						}
					}
				}
			}
			v9 = v15 + 1;
		}
		++v7;
		++HIBYTE(v8);
	} while (v7 < 54);
	return 1;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00039FA0) --------------------------------------------------------
char sub_39FA0(int a1, int a2)
{
	char result; // al
	unsigned __int8 v3; // ah
	char v4; // bl
	unsigned __int8 v5; // ah
	unsigned __int8 v6; // dl
	unsigned __int8 v7; // ah
	unsigned __int8 v8; // dl
	bool v9; // zf

	result = 1;
	v3 = *(x_BYTE *)(a2 + 63) - 1;
	if (v3 <= 0xEu)
	{
		switch (v3)
		{
		case 0u:
		case 3u:
		case 5u:
		case 6u:
		case 7u:
		case 0xAu:
		case 0xBu:
		case 0xCu:
		case 0xEu:
			return 0;
		case 1u:
			return result;
		case 2u:
			v7 = *(x_BYTE *)(a2 + 64);
			if (v7 < 1u)
			{
				if (v7)
					return result;
			}
			else
			{
				if (v7 > 1u)
				{
					if (v7 != 2)
						return result;
					return 0;
				}
				if (*(x_BYTE *)(a2 + 12) & 0x21)
					return 0;
			}
			if (*(x_WORD *)(a1 + 26) == *(x_WORD *)(a2 + 26))
				result = 0;
			break;
		case 4u:
			if (*(x_BYTE *)(a2 + 12) & 0x21)
				return 0;
			v4 = *(x_BYTE *)(a2 + 69);
			if (v4 == -24)
				return 0;
			v5 = *(x_BYTE *)(a2 + 64);
			if (v5 < 0x16u)
				return result;
			if (v5 <= 0x16u)
				return 0;
			if (v5 != 27)
				return result;
			if (v4 == -23)
				return 0;
			if (v4 == -22)
				result = 0;
			return result;
		case 8u:
			v6 = *(x_BYTE *)(a2 + 64);
			if (!v6)
				return result;
			if (v6 < 0xDu)
				return 0;
			if (v6 > 0xEu)
				result = 0;
			return result;
		case 9u:
			v8 = *(x_BYTE *)(a2 + 64);
			if (v8 < 0x27u)
			{
				v9 = v8 == 6;
			}
			else
			{
				if (v8 <= 0x28u)
					return result;
				v9 = v8 == 57;
			}
			if (!v9)
				result = 0;
			return result;
		case 0xDu:
			if (*(x_BYTE *)(a2 + 12) & 0x21 || *(x_BYTE *)(a2 + 64) == 1)
				return 0;
			return result;
		}
	}
	return result;
}

//----- (0003A090) --------------------------------------------------------
void sub_3A090(unsigned __int16 *a1)
{
	unsigned int i; // ebx
	unsigned int j; // ebx
	int v3; // edi
	Bit8u* v4; // eax
	int v5; // eax
	unsigned __int16 v6; // bx
	char v7; // al
	int v8; // [esp+0h] [ebp-10h]
	signed int k; // [esp+4h] [ebp-Ch]
	int v10; // [esp+8h] [ebp-8h]
	char v11; // [esp+Ch] [ebp-4h]

	v8 = 0;
	for (i = x_D41A0_BYTEARRAY_4[0x967F]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
	{
		if (sub_10750((int)a1, i))
		{
			*(x_DWORD *)(i + 8) = -1;
			*(x_BYTE *)(i + 61) = 0;
		}
	}
	for (j = x_D41A0_BYTEARRAY_4[0x9677]; j > x_DWORD_EA3E4[0]; j = *(x_DWORD *)j)
	{
		if (*(x_BYTE *)(j + 64) == 2 && sub_10750((int)a1, j))
		{
			v3 = x_DWORD_E9B90 + 1;
			v4 = x_D41A0_BYTEARRAY_0 + 28302;
			*(x_BYTE *)(j + 14) |= 0x10u;
			x_DWORD_E9B90 = v3;
			*(x_WORD *)(j + 48) = 30;
			*(x_WORD *)(j + 38) = ((signed int)a1 - (int)v4) / 168;
			*(x_DWORD *)(j + 94) += a1[21];
			v8 += 2;
			*(x_WORD *)(j + 98) = a1[13];
		}
	}
	v11 = ((unsigned __int16)(a1[38] + 128) >> 8) - 15;
	v5 = 0;
	for (HIBYTE(v6) = ((unsigned __int16)(a1[39] + 128) >> 8) - 15; ; ++HIBYTE(v6))
	{
		v10 = v5;
		if (v5 >= 30)
			break;
		LOBYTE(v6) = v11;
		for (k = 0; k < 30; k++)
		{
			if ((unsigned int)sub_10590(x_BYTE_10B4E0[v6]) & 0x7F0000)
			{
				v7 = x_BYTE_13B4E0[v6] & 0xF8 | 1;
				x_BYTE_10B4E0[v6] = 1;
				x_BYTE_13B4E0[v6] = v7;
			}
			LOBYTE(v6) = v6 + 1;
		}
		v5 = v10 + 1;
	}
	if (v8)
		sub_6D8B0(a1[13], 0x14u, v8);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// E9B90: using guessed type int x_DWORD_E9B90;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0003A200) --------------------------------------------------------
void sub_3A200(int a1, int a2)
{
	bool v2; // ah
	unsigned __int8 v3; // al
	unsigned __int8 v4; // al
	int v5; // edx
	unsigned __int16 v6; // ax
	char v7; // [esp+0h] [ebp-4h]

	v2 = 0;
	v7 = 0;
	v3 = *(x_BYTE *)(a2 + 63);
	*(x_DWORD *)(a2 + 12) |= (unsigned int)&unk_100001;
	if (v3 < 3u)
		goto LABEL_13;
	if (v3 > 3u)
	{
		if (v3 != 5)
			goto LABEL_13;
		v4 = *(x_BYTE *)(a2 + 64);
		if (v4 < 0x12u)
		{
			if (v4 != 12)
				goto LABEL_13;
		}
		else if (v4 > 0x12u)
		{
			if (v4 == 27)
				v7 = 1;
			goto LABEL_13;
		}
		v2 = 1;
		goto LABEL_13;
	}
	if (!*(x_BYTE *)(a2 + 64))
	{
		v5 = *(x_DWORD *)(a2 + 164);
		*(x_WORD *)(a2 + 30) = 512;
		*(x_WORD *)(v5 + 343) = 512;
	}
LABEL_13:
	if (!v2)
	{
		*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
		v2 = *(unsigned __int16 *)(a1 + 20) % 7u == 0;
	}
	if (v2 && !v7)
	{
		if (*(x_BYTE *)(a2 + 56) & 1)
		{
			*(x_DWORD *)(a2 + 94) += *(x_DWORD *)(a2 + 8) + 1;
			v6 = *(x_WORD *)(a1 + 26);
			*(x_WORD *)(a2 + 98) = v6;
			sub_6D8B0(v6, 0x14u, 1);
		}
	}
}

//----- (0003A2D0) --------------------------------------------------------
void sub_3A2D0(int a1)
{
	unsigned __int8 v1; // al
	int v2; // ecx
	int v3; // edx
	int v4; // esi
	int v5; // edi
	int v6; // esi
	int v7; // edx
	char v8; // dl
	unsigned __int16 v9; // dx
	signed int v10; // ecx
	int v11; // eax
	int v12; // edi
	unsigned __int16 v13; // dx
	int v14; // eax
	__int16 v15; // ax
	char v16; // [esp+0h] [ebp-1Ch]
	char v17; // [esp+4h] [ebp-18h]
	int v18; // [esp+8h] [ebp-14h]
	int v19; // [esp+Ch] [ebp-10h]
	int v20; // [esp+10h] [ebp-Ch]
	char v21; // [esp+14h] [ebp-8h]
	char v22; // [esp+18h] [ebp-4h]

	if (*(x_DWORD *)(a1 + 8) >= 0)
	{
		v1 = *(x_BYTE *)(a1 + 70);
		if (v1)
		{
			if (v1 > 3u)
			{
			LABEL_51:
				--*(x_DWORD *)(a1 + 8);
				return;
			}
		}
		else
		{
			v2 = *(x_DWORD *)(a1 + 4);
			v3 = *(unsigned __int16 *)(a1 + 42);
			*(x_WORD *)(a1 + 44) = *(x_DWORD *)(a1 + 4) >> 3;
			*(x_DWORD *)(a1 + 16) = 0;
			*(x_BYTE *)(a1 + 70) = 1;
			*(x_WORD *)(a1 + 42) = 4 * (unsigned int)(v3 / v2);
		}
		v4 = *(signed __int16 *)(a1 + 44);
		v5 = *(x_DWORD *)(a1 + 8);
		if (*(x_DWORD *)(a1 + 4) - 3 * v4 >= v5)
		{
			if (*(x_DWORD *)(a1 + 4) - 5 * v4 > v5)
			{
				v6 = *(x_DWORD *)(a1 + 16) - 1;
				*(x_DWORD *)(a1 + 16) = v6;
			}
			else
			{
				v6 = 3 * v4;
				*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
				if (!(*(unsigned __int16 *)(a1 + 20) % 5u))
					*(x_BYTE *)(a1 + 70) += 2;
			}
		}
		else
		{
			v6 = *(x_DWORD *)(a1 + 16) + 1;
			*(x_DWORD *)(a1 + 16) = v6;
		}
		if (v6 < 0)
			v6 = 0;
		v7 = *(signed __int16 *)(a1 + 44);
		if (v6 > 3 * v7)
			v6 = 3 * v7;
		if (v6 < 0)
			v6 = 0;
		if (v6 > 15)
			v6 = 15;
		v8 = *(x_BYTE *)(a1 + 70);
		v20 = 0;
		if (v8 > 1)
		{
			v20 = 1;
			*(x_BYTE *)(a1 + 70) = v8 - 1;
		}
		if (v6 > 0)
		{
			v21 = (unsigned __int16)(*(x_WORD *)(a1 + 76) + 128) >> 8;
			v22 = (unsigned __int16)(*(x_WORD *)(a1 + 78) + 128) >> 8;
			v18 = sub_10080(0, v6);
			if (v18)
			{
				while (sub_10130(v18, (x_DWORD*)&v17, (x_DWORD*)&v16) == 1)
				{
					LOBYTE(v9) = v17 + v21;
					HIBYTE(v9) = v16 + v22;
					if (*(x_BYTE *)(a1 + 8) & 1)
						v10 = 1;
					else
						v10 = -1;
					v11 = v10 + x_BYTE_11B4E0[v9];
					if (v11 < 0)
						v11 = 0;
					if (v11 > 255)
						LOBYTE(v11) = -1;
					x_BYTE_11B4E0[v9] = v11;
				}
				sub_10100(v18);
			}
			if (v20)
			{
				v12 = sub_10080(0, v6 >> 1);
				if (v12)
				{
					while (sub_10130(v12, (x_DWORD*)&v17, (x_DWORD*)&v16) == 1)
					{
						LOBYTE(v13) = v17 + v21;
						HIBYTE(v13) = v16 + v22;
						if (*(x_BYTE *)(a1 + 8) & 1)
							v19 = 1;
						else
							v19 = -1;
						v14 = v19 + x_BYTE_11B4E0[v13];
						if (v14 < 0)
							v14 = 0;
						if (v14 > 255)
							LOBYTE(v14) = -1;
						x_BYTE_11B4E0[v13] = v14;
					}
					sub_10100(v12);
				}
			}
			if (!(*(x_BYTE *)(a1 + 8) & 3))
			{
				sub_49EA0((x_WORD *)a1, (x_WORD)v6 << 8, 2048);
				sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 10);
				v15 = sub_10C80(a1, 0, *(x_WORD *)(a1 + 42));
				if (v15)
					sub_6D8B0(*(x_WORD *)(a1 + 26), 0xFu, v15);
			}
		}
		goto LABEL_51;
	}
	sub_57F10(a1);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0003A5B0) --------------------------------------------------------
void sub_3A5B0(int a1)
{
	int v1; // edx
	int v2; // eax
	char v3; // dl
	__int16 v4; // dx

	v1 = *(x_DWORD *)(a1 + 8) - 1;
	*(x_DWORD *)(a1 + 8) = v1;
	if (v1 < 0)
	{
		sub_57F10(a1);
	}
	else if (!v1)
	{
		v2 = sub_4A190(a1 + 76, 5, *(char *)(a1 + 70));
		if (v2)
		{
			v3 = 8 * *(x_BYTE *)(v2 + 64);
			*(x_BYTE *)(v2 + 73) = 13;
			*(x_BYTE *)(v2 + 69) = v3 + 7;
			*(x_WORD *)(v2 + 40) = *(x_WORD *)(a1 + 40);
			v4 = *(x_WORD *)(a1 + 26);
			*(x_WORD *)(v2 + 150) = 0;
			*(x_DWORD *)(v2 + 144) = 0;
			*(x_DWORD *)(v2 + 140) = 0;
			*(x_WORD *)(v2 + 46) = 250;
			*(x_WORD *)(v2 + 26) = v4;
		}
	}
}

//----- (0003A630) --------------------------------------------------------
void sub_3A630(int a1)
{
	//int result; // eax
	int v2; // edx

	//result = a1;
	v2 = *(x_DWORD *)(a1 + 8) - 1;
	*(x_DWORD *)(a1 + 8) = v2;
	if (v2 <= 0)
		sub_57F10(a1);
	//return result;
}

//----- (0003A650) --------------------------------------------------------
int sub_3A650(int a1)
{
	unsigned int v1; // edi
	char v2; // al
	int k; // eax
	__int16 v4; // ax
	__int16 v5; // ax
	unsigned int v6; // ebx
	signed __int16 v8; // [esp+0h] [ebp-14h]
	char v9; // [esp+4h] [ebp-10h]
	char v10; // [esp+8h] [ebp-Ch]
	unsigned __int8 j; // [esp+Ch] [ebp-8h]
	unsigned __int8 i; // [esp+10h] [ebp-4h]

	if (*(x_WORD *)(a1 + 150))
	{
		v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
		if (v1 > x_DWORD_EA3E4[0])
		{
			v2 = *(x_BYTE *)(a1 + 70);
			v10 = ((unsigned __int16)(*(x_WORD *)(v1 + 76) + 128) >> 8) - v2;
			v8 = 2 * *(char *)(a1 + 70);
			v9 = ((unsigned __int16)(*(x_WORD *)(v1 + 78) + 128) >> 8) - v2;
			for (i = 0; i < v8; i++)
			{
				for (j = 0; j < v8; j++)
				{
					for (k = x_WORD_15B4E0[(unsigned __int8)(j + v10) + ((unsigned __int8)(v9 + i) << 8)];
						;
						k = *(unsigned __int16 *)(v6 + 22))
					{
						v6 = x_DWORD_EA3E4[k];
						if (v6 <= x_DWORD_EA3E4[0])
							break;
						if (*(x_BYTE *)(v6 + 63) == *(x_BYTE *)(v1 + 63)
							&& *(x_BYTE *)(v6 + 64) == *(x_BYTE *)(v1 + 64)
							&& sub_3A7F0((x_BYTE *)v6))
						{
							sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 6);
							*(x_BYTE *)(v6 + 73) = 14;
							v4 = *(unsigned __int8 *)(v6 + 72);
							*(x_BYTE *)(v6 + 72) = 0;
							*(x_WORD *)(v6 + 74) = v4;
							*(x_WORD *)(v6 + 40) = *(x_WORD *)(a1 + 26);
							v5 = *(x_WORD *)(a1 + 42);
							*(x_WORD *)(v6 + 46) = v5;
							*(x_WORD *)(v6 + 48) = v5;
							if ((*(x_BYTE *)(v6 + 69) & 7) == 2)
								*(x_WORD *)(v6 + 150) = 0;
							else
								*(x_BYTE *)(v6 + 69) = 8 * *(x_BYTE *)(v6 + 64) + 7;
						}
					}
				}
			}
		}
	}
	sub_57F10(a1);
	return 1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0003A7F0) --------------------------------------------------------
char sub_3A7F0(x_BYTE *a1)
{
	char result; // al
	unsigned __int8 v2; // ah
	char v3; // bh

	result = 1;
	if (a1[63] != 5)
		return 0;
	v2 = a1[64];
	if (v2 < 0x16u)
	{
		if (v2 >= 0xCu && v2 <= 0xFu)
			goto LABEL_12;
	}
	else
	{
		if (v2 <= 0x17u)
			goto LABEL_12;
		if (v2 >= 0x19u)
		{
			if (v2 > 0x19u)
			{
				if (v2 > 0x1Bu)
					goto LABEL_13;
				goto LABEL_12;
			}
			if (a1[70])
			{
			LABEL_12:
				result = 0;
				goto LABEL_13;
			}
		}
	}
LABEL_13:
	if (result)
	{
		v3 = a1[73];
		if (v3 == 14 || v3 == 13 || v3 == 16 || v3 == 17)
			result = 0;
	}
	if (result && a1[69] == -24)
		return 0;
	return result;
}

//----- (0003A8B0) --------------------------------------------------------
char sub_3A8B0(int a1)
{
	__int16 v1; // cx
	int v2; // eax
	char v3; // dh
	char v4; // cl
	int v5; // esi
	char v6; // ah
	int v7; // eax
	__int16 v8; // di
	unsigned int v9; // eax
	signed __int16 v10; // dx
	int v11; // esi
	int v12; // eax
	int v13; // edx
	unsigned int v14; // edx
	int v15; // esi
	unsigned int i; // esi
	unsigned __int16 v17; // di
	int v18; // edi
	x_WORD *v19; // eax
	x_WORD *v20; // esi
	__int16 v21; // ax
	char v22; // ah
	__int16 v23; // ax
	char v24; // al
	char v25; // dl
	int v26; // esi
	char v27; // cl
	void(/*__noreturn*/ *v29)(); // [esp+0h] [ebp-24h]
	__int16 *v30; // [esp+4h] [ebp-20h]
	unsigned int v31; // [esp+8h] [ebp-1Ch]
	x_WORD *v32; // [esp+Ch] [ebp-18h]
	int v33; // [esp+10h] [ebp-14h]
	bool v34; // [esp+14h] [ebp-10h]
	unsigned __int8 v35; // [esp+18h] [ebp-Ch]
	unsigned __int8 v36; // [esp+1Ch] [ebp-8h]
	char v37; // [esp+20h] [ebp-4h]

	v2 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 50)];
	v31 = 0;
	v29 = (void(*)())sub_10000;
	v33 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 50)];
	if (*(x_DWORD *)(v2 + 8) < 0 || *(x_BYTE *)(v2 + 13) & 4)
	{
	LABEL_99:
		sub_57F10(a1);
	}
	else
	{
		v3 = *(x_BYTE *)(a1 + 68);
		if (v3)
		{
			switch (abs(v3))
			{
			case 1:
				v1 = 0;
				break;
			case 2:
				v1 = 153;
				break;
			case 3:
				v1 = 307;
				break;
			case 4:
				v1 = 445;
				break;
			case 5:
				v1 = 491;
				break;
			case 6:
				v1 = 512;
				break;
			default:
				break;
			}
			*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 154);
			*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 158);
			x_WORD_EB39C = *(x_WORD *)(a1 + 80);
			sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), 0, v1);
			sub_57CF0(a1, (int)&x_WORD_EB398);
			v4 = *(x_BYTE *)(a1 + 68) + 1;
			*(x_BYTE *)(a1 + 68) = v4;
			if (v4 > 0 && v4 > 6)
				*(x_BYTE *)(a1 + 68) = -5;
		}
		v5 = (signed __int16)sub_10C40((__int16 *)(a1 + 76));
		v6 = *(x_BYTE *)(a1 + 70);
		if (v6 != 9 && v6 != 7)
		{
			v7 = *(x_DWORD *)(a1 + 8) - 1;
			*(x_DWORD *)(a1 + 8) = v7;
			if (v7 <= 0)
				*(x_BYTE *)(a1 + 70) = 6;
			if (*(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12) == *(x_WORD *)(*(x_DWORD *)(v33 + 164) + 56))
			{
				v8 = *(x_WORD *)(a1 + 54);
				*(x_BYTE *)(a1 + 12) &= 0xFEu;
				if (v8 != -1)
					*(x_BYTE *)(a1 + 14) |= 0x80u;
			}
			else if (!(*(x_BYTE *)(a1 + 62) & 7))
			{
				v9 = x_DWORD_EA3E4[*(signed __int16 *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 13071)];
				if (v9 > x_DWORD_EA3E4[0] && *(x_WORD *)(v9 + 46) && *(x_BYTE *)(v9 + 70) >= 2)
					*(x_BYTE *)(a1 + 12) &= 0xFEu;
				else
					*(x_BYTE *)(a1 + 12) |= 1u;
			}
			if (*(signed __int16 *)(a1 + 80) < v5)
				*(x_WORD *)(a1 + 80) = v5;
			if (!*(x_BYTE *)(a1 + 68) && abs(*(signed __int16 *)(a1 + 80) - (v5 + 1024)) > 96)
			{
				if (*(signed __int16 *)(a1 + 80) - (v5 + 1024) <= 0)
					v10 = 48;
				else
					v10 = -48;
				*(x_WORD *)(a1 + 80) += v10;
			}
			if (x_BYTE_D41B6)
			{
				v11 = *(signed __int16 *)(a1 + 88);
				v5 = (signed __int16)sub_10C60((__int16 *)(a1 + 76)) - v11;
				if (*(signed __int16 *)(a1 + 80) > v5)
					*(x_WORD *)(a1 + 80) = v5;
			}
		}
		LOBYTE(v12) = *(x_BYTE *)(a1 + 70);
		switch ((x_BYTE)v12)
		{
		case 0:
			v12 = (int)&unk_DAF4A + 26 * *(unsigned __int16 *)(a1 + 42);
			v13 = *(x_DWORD *)v12;
			*(x_DWORD *)(a1 + 4) = *(x_DWORD *)v12;
			*(x_DWORD *)(a1 + 8) = v13;
			*(x_DWORD *)(a1 + 154) = *(x_DWORD *)(a1 + 76);
			*(x_WORD *)(a1 + 158) = *(x_WORD *)(a1 + 80);
			LOBYTE(v12) = *(x_BYTE *)(v12 + 24);
			switch ((x_BYTE)v12)
			{
			case 0:
				*(x_BYTE *)(a1 + 67) = 1;
				break;
			case 1:
				*(x_BYTE *)(a1 + 67) = 2;
				break;
			case 2:
				*(x_BYTE *)(a1 + 67) = 4;
				break;
			case 3:
				*(x_BYTE *)(a1 + 67) = 8;
				break;
			default:
				break;
			}
			*(x_BYTE *)(a1 + 70) = 1;
			goto LABEL_45;
		case 1:
		LABEL_45:
			if (*(x_WORD *)(a1 + 54) != -1)
				exit(-1);
			return v12;
		case 2:
			*(x_BYTE *)(a1 + 12) &= 0xF7u;
			*(x_WORD *)(a1 + 26) = *(x_WORD *)(a1 + 50);
			if (*xadataspellsdat.var28_begin_buffer[80 * *(unsigned __int16 *)(a1 + 54) + 27 + 26 * *(unsigned __int16 *)(a1 + 52)] & 1)
				*(x_BYTE *)(a1 + 61) = 6;
			else
				*(x_BYTE *)(a1 + 61) = 1;
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			LOWORD(v12) = *(x_WORD *)(a1 + 20) / 0x32u;
			v14 = *(unsigned __int16 *)(a1 + 20) % 0x32u;
			*(x_BYTE *)(a1 + 70) = 3;
			*(x_DWORD *)(a1 + 16) = v14 + 16;
			return v12;
		case 3:
			v15 = *(x_DWORD *)(a1 + 16) - 1;
			*(x_DWORD *)(a1 + 16) = v15;
			if (!v15)
				*(x_BYTE *)(a1 + 70) = 4;
			return v12;
		case 4:
			if (!(*(x_BYTE *)(a1 + 62) & 0xF))
			{
				for (i = x_D41A0_BYTEARRAY_4[0x9677]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
				{
					LOBYTE(v12) = *(x_BYTE *)(i + 64);
					if ((unsigned __int8)v12 <= 1u && i != v33)
					{
						v12 = sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(i + 76));
						if (v12 < 3584 && v12 < (signed int)v29)
						{
							v31 = i;
							v29 = (void(/*__noreturn*/ *)())v12;
						}
					}
				}
				if (v31)
				{
					v12 = (signed int)(v31 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
					*(x_BYTE *)(a1 + 70) = 5;
					*(x_WORD *)(a1 + 150) = v12;
				}
			}
			return v12;
		case 5:
			*(x_DWORD *)(a1 + 12) &= 0xFF7FFFFE;
			LOBYTE(v12) = 0;
			v17 = *(x_WORD *)(a1 + 150);
			v37 = 0;
			if (!v17
				|| (LOBYTE(v12) = *(x_WORD *)(a1 + 150), v18 = x_DWORD_EA3E4[v17], *(x_DWORD *)(v18 + 8) < 0)
				|| *(x_BYTE *)(v18 + 13) & 4)
			{
				v37 = 1;
			}
			else
			{
				sub_6D8B0(*(x_WORD *)(v33 + 26), 0x17u, 1);
				v30 = (__int16 *)&*xadataspellsdat.var28_begin_buffer[80 * *(unsigned __int16 *)(a1 + 54) + 2 + 26 * *(unsigned __int16 *)(a1 + 52)];
				v34 = *(x_WORD *)(a1 + 54) == 7
					&& *xadataspellsdat.var28_begin_buffer[80 * *(unsigned __int16 *)(a1 + 54) + 26 + 26 * *(unsigned __int16 *)(a1 + 52)] == 2;
				v35 = (v34 != 0) + 1;
				v36 = 0;
				for (LOBYTE(v12) = 0; v36 < v35; LOBYTE(v12) = v36)
				{
					v19 = (x_WORD *)sub_6DCA0(v33, a1 + 76, *(x_WORD *)(a1 + 54), v30, 0, 1);
					v20 = v19;
					v32 = v19;
					if (v19)
					{
						v19[13] = *(x_WORD *)(a1 + 50);
						v19[75] = *(x_WORD *)(a1 + 150);
						sub_655C0(v19, v18);
						v20[14] = v20[16];
						v20[15] = v20[17];
						v21 = v20[14];
						v20[40] += *(x_WORD *)(a1 + 82);
						HIBYTE(v21) = (HIBYTE(v21) + 4) & 7;
						*(x_WORD *)(a1 + 28) = v21;
						v22 = *(x_BYTE *)(a1 + 68);
						if (v22)
						{
							*(x_BYTE *)(a1 + 68) = v22 + 1;
							if ((char)(v22 + 1) > 5)
								*(x_BYTE *)(a1 + 68) = 5;
						}
						else
						{
							*(x_BYTE *)(a1 + 68) = 1;
						}
						if (v34)
						{
							if (v36)
								v23 = v32[14] - 113;
							else
								v23 = v32[14] + 113;
							v32[14] = v23 & 0x7FF;
						}
						v24 = *(x_BYTE *)(a1 + 61) - 1;
						*(x_BYTE *)(a1 + 61) = v24;
						if (!v24)
							v37 = 1;
					}
					++v36;
				}
			}
			if (v37)
			{
				v25 = *(x_BYTE *)(a1 + 67);
				*(x_WORD *)(a1 + 150) = 0;
				*(x_BYTE *)(a1 + 67) = --v25;
				if (v25)
					LABEL_46:
				*(x_BYTE *)(a1 + 70) = 2;
				else
					*(x_BYTE *)(a1 + 70) = 6;
			}
			return v12;
		case 6:
			v27 = *(x_BYTE *)(a1 + 68);
			*(x_DWORD *)(a1 + 12) &= 0xFF7FFFFE;
			if (!v27)
			{
				*(x_BYTE *)(a1 + 70) = 7;
				*(x_DWORD *)(a1 + 16) = 10;
			}
			return v12;
		case 7:
			v12 = *(x_DWORD *)(a1 + 16) - 1;
			*(x_DWORD *)(a1 + 16) = v12;
			if (!v12)
			{
				*(x_BYTE *)(a1 + 70) = 9;
				*(x_DWORD *)(a1 + 16) = 3;
			}
			return v12;
		case 8:
			*(x_BYTE *)(a1 + 70) = 9;
			v26 = *(x_DWORD *)(a1 + 12);
			*(x_DWORD *)(a1 + 16) = 3;
			*(x_DWORD *)(a1 + 12) = v26 & 0xFF7FFFFE;
			return v12;
		case 9:
			v12 = *(x_DWORD *)(a1 + 16);
			*(x_DWORD *)(a1 + 16) = v12 + 1;
			LOWORD(v12) = *(x_WORD *)(a1 + 80) - 32 * v12;
			*(x_WORD *)(a1 + 80) = v12;
			if ((signed __int16)v12 >= v5)
				return v12;
			*(x_WORD *)(a1 + 80) = v5;
			if (sub_104D0((signed __int16 *)(a1 + 76)) == (int(*)())1)
				sub_4A190(a1 + 76, 10, 5);
			else
				sub_4A190(a1 + 76, 10, 0);
			goto LABEL_99;
		default:
			return v12;
		}
	}
	return v12;
}
// 10000: using guessed type void /*__noreturn*/ sub_10000();
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// D41B6: using guessed type char x_BYTE_D41B6;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (0003AF00) --------------------------------------------------------
int sub_3AF00(int a1)
{
	int v1; // edx
	__int16 v2; // dx
	int v3; // esi
	unsigned int v4; // edx
	int v5; // eax
	int i; // ecx
	unsigned __int8 v7; // al
	unsigned __int8 v8; // al
	bool v9; // zf
	int v10; // eax
	int v11; // edx
	__int16 v12; // di
	signed int v13; // edx
	__int16 v14; // ax
	unsigned __int16 v15; // ax
	int v16; // edi
	int v17; // eax
	__int16 v18; // ax
	__int16 v19; // ax
	char v20; // dh
	char v21; // al
	int v22; // eax
	char v23; // dl
	__int16 v24; // ax
	char v25; // dh
	__int16 v26; // ax
	int result; // eax
	int v28; // ecx
	int v29; // ecx
	x_WORD *v30; // esi
	signed int v31; // edx
	int v32; // [esp+0h] [ebp-30h]
	int v33; // [esp+4h] [ebp-2Ch]
	int v34; // [esp+8h] [ebp-28h]
	int v35; // [esp+Ch] [ebp-24h]
	int v36; // [esp+10h] [ebp-20h]
	int v37; // [esp+14h] [ebp-1Ch]
	int v38; // [esp+18h] [ebp-18h]
	char v39; // [esp+1Ch] [ebp-14h]
	unsigned __int8 v40; // [esp+20h] [ebp-10h]
	char v41; // [esp+24h] [ebp-Ch]
	unsigned __int8 v42; // [esp+28h] [ebp-8h]
	char v43; // [esp+2Ch] [ebp-4h]

	v1 = *(x_DWORD *)(a1 + 8);
	v41 = 0;
	if (v1 < 0)
	{
		sub_57F10(a1);
		return 1;
	}
	v2 = *(x_WORD *)(a1 + 26);
	if (!v2)
	{
		sub_57F10(a1);
		return 1;
	}
	v38 = x_DWORD_EA3E4[v2];
	v3 = x_DWORD_EA3E4[*(unsigned __int16 *)(*(x_DWORD *)(v38 + 164) + 58)];
	if (*(x_WORD *)(a1 + 74) <= 1)
		v37 = 384;
	else
		v37 = 224;
	switch (*(x_BYTE *)(a1 + 70))
	{
	case 0:
		*(x_DWORD *)(a1 + 154) = *(x_DWORD *)(a1 + 76);
		*(x_WORD *)(a1 + 158) = *(x_WORD *)(a1 + 80);
		v3 = a1 + 82;
		*(x_BYTE *)(a1 + 70) = 1;
		goto LABEL_74;
	case 1:
		*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
		v4 = *(unsigned __int16 *)(a1 + 20) % 0x30u;
		*(x_BYTE *)(a1 + 70) = 2;
		*(x_DWORD *)(a1 + 16) = v4 + 16;
		goto LABEL_9;
	case 2:
	LABEL_9:
		v5 = *(x_DWORD *)(a1 + 16) - 1;
		*(x_DWORD *)(a1 + 16) = v5;
		if (!v5)
			*(x_BYTE *)(a1 + 70) = 3;
		goto LABEL_74;
	case 3:
		if (*(x_BYTE *)(a1 + 62) & 0x3F)
			goto LABEL_74;
		v36 = (*(unsigned __int16 *)(a1 + 76) + 128) >> 8;
		v35 = (*(unsigned __int16 *)(a1 + 78) + 128) >> 8;
		v3 = sub_10080(3, 12);
		if (!v3)
			goto LABEL_74;
		v39 = 0;
		break;
	case 4:
		*(x_BYTE *)(a1 + 70) = 5;
		*(x_DWORD *)(a1 + 16) = 4;
		goto LABEL_37;
	case 5:
	LABEL_37:
		v11 = *(x_DWORD *)(a1 + 16) - 1;
		*(x_DWORD *)(a1 + 16) = v11;
		if (v11)
		{
			*(x_WORD *)(a1 + 54) += 160;
		}
		else
		{
			*(x_BYTE *)(a1 + 70) = 6;
			*(x_WORD *)(a1 + 54) = 0;
		}
		goto LABEL_74;
	case 6:
		v12 = *(x_WORD *)(a1 + 20);
		*(x_WORD *)(a1 + 158) = *(x_WORD *)(a1 + 80);
		*(x_WORD *)(a1 + 20) = 9377 * v12 + 9439;
		v13 = *(unsigned __int16 *)(a1 + 20) % 0x64u;
		*(x_BYTE *)(a1 + 70) = 7;
		if (v13)
		{
			if (v13 <= 5)
			{
				v14 = (*(x_BYTE *)(a1 + 67) == 1) + 2;
			}
			else
			{
				LOBYTE(v14) = *(x_BYTE *)(a1 + 67) != 1;
				HIBYTE(v14) = 0;
			}
			*(x_WORD *)(a1 + 44) = v14;
		}
		else
		{
			*(x_WORD *)(a1 + 44) = 4;
		}
		v15 = *(x_WORD *)(a1 + 44);
		*(x_BYTE *)(a1 + 61) = 1;
		if (v15 <= 1u)
			*(x_BYTE *)(a1 + 61) = 6;
		goto LABEL_48;
	case 7:
	case 8:
	LABEL_48:
		v43 = 0;
		if (!*(x_WORD *)(a1 + 150))
			goto LABEL_104;
		v16 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
		if (*(x_DWORD *)(v16 + 8) < 0 || *(x_BYTE *)(v16 + 13) & 4)
			goto LABEL_104;
		switch (*(x_WORD *)(a1 + 44))
		{
		case 0:
			v40 = 0;
			v42 = 1;
			break;
		case 1:
			v40 = 7;
			goto LABEL_57;
		case 2:
			v40 = 7;
			v42 = 1;
			break;
		case 3:
			v40 = 0;
			v42 = 2;
			break;
		case 4:
			v40 = 9;
		LABEL_57:
			v42 = 0;
			break;
		default:
			break;
		}
		v17 = sub_6DCA0(v3, a1 + 76, v40, (__int16 *)&*xadataspellsdat.var28_begin_buffer[80 * v40 + 2 + 26 * v42], 0, *(x_BYTE *)(a1 + 70) == 7);
		v3 = v17;
		if (v17)
		{
			*(x_WORD *)(v17 + 26) = *(x_WORD *)(a1 + 26);
			*(x_WORD *)(v17 + 150) = *(x_WORD *)(a1 + 150);
			if (*(x_WORD *)(*(x_DWORD *)(v38 + 164) + 56) == *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12) && !v40)
				sub_49C90(v17, 42);
			sub_655C0((x_WORD *)v3, v16);
			*(x_WORD *)(v3 + 28) = *(x_WORD *)(v3 + 32);
			*(x_WORD *)(v3 + 30) = *(x_WORD *)(v3 + 34);
			v18 = *(x_WORD *)(v3 + 28);
			*(x_WORD *)(v3 + 80) += *(x_WORD *)(a1 + 82);
			HIBYTE(v18) &= 7u;
			*(x_WORD *)(a1 + 28) = v18;
			v19 = *(x_WORD *)(v3 + 30);
			HIBYTE(v19) &= 7u;
			v20 = *(x_BYTE *)(a1 + 68);
			*(x_WORD *)(a1 + 30) = v19;
			if (v20)
			{
				*(x_BYTE *)(a1 + 68) = v20 + 1;
				if ((char)(v20 + 1) > 5)
					*(x_BYTE *)(a1 + 68) = 5;
			}
			else
			{
				*(x_BYTE *)(a1 + 68) = 1;
			}
			v21 = *(x_BYTE *)(a1 + 61) - 1;
			*(x_BYTE *)(a1 + 61) = v21;
			if (!v21)
				LABEL_104:
			v43 = 1;
		}
		if (v43)
		{
			*(x_WORD *)(a1 + 150) = 0;
			*(x_BYTE *)(a1 + 70) = 1;
		}
		else
		{
			*(x_BYTE *)(a1 + 70) = 8;
		}
		goto LABEL_74;
	case 9:
		goto LABEL_73;
	case 0xA:
		v22 = sub_4A190(a1 + 76, 10, 1);
		if (v22)
			*(x_WORD *)(v22 + 26) = *(x_WORD *)(a1 + 26);
	LABEL_73:
		v41 = 1;
		goto LABEL_74;
	default:
		goto LABEL_74;
	}
LABEL_33:
	if (sub_10130(v3, &v33, &v32) == 1 && !v39)
	{
		for (i = x_DWORD_EA3E4[x_WORD_15B4E0[(unsigned __int8)(v33 + v36) + ((unsigned __int8)(v32 + v35) << 8)]];
			;
			i = x_DWORD_EA3E4[*(unsigned __int16 *)(i + 22)])
		{
			if (i == x_DWORD_EA3E4[0] || v39)
				goto LABEL_33;
			v7 = *(x_BYTE *)(i + 63);
			if (v7 >= 3u)
			{
				if (v7 <= 3u)
				{
					v8 = *(x_BYTE *)(i + 64);
					if (v8 <= 1u || v8 == 3)
					{
						v9 = *(x_WORD *)(i + 26) == *(x_WORD *)(a1 + 26);
					LABEL_26:
						if (v9)
							goto LABEL_28;
					LABEL_27:
						v39 = 1;
						goto LABEL_28;
					}
				}
				else if (v7 == 5 && *(x_BYTE *)(i + 64) != 22 && *(x_WORD *)(i + 26) != *(x_WORD *)(a1 + 26))
				{
					if (*(x_BYTE *)(i + 73) == 14)
					{
						v9 = *(unsigned __int16 *)(i + 40) == *(signed __int16 *)(a1 + 26);
						goto LABEL_26;
					}
					goto LABEL_27;
				}
			}
		LABEL_28:
			if (v39)
			{
				v10 = (i - (x_D41A0_BYTEARRAY_0[28302])) / 168;
				*(x_BYTE *)(a1 + 70) = 4;
				*(x_WORD *)(a1 + 150) = v10;
			}
		}
	}
	sub_10100(v3);
LABEL_74:
	if (v41)
		return sub_57F20(a1);
	v23 = *(x_BYTE *)(a1 + 68);
	if (v23)
	{
		switch (abs(v23))
		{
		case 1:
			v34 = 0;
			break;
		case 2:
			v34 = 115;
			break;
		case 3:
			v34 = 230;
			break;
		case 4:
			v34 = 334;
			break;
		case 5:
			v34 = 368;
			break;
		case 6:
			v34 = 384;
			break;
		default:
			break;
		}
		v24 = -(signed __int16)v34;
		*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 154);
		*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 158);
		v3 = a1 + 160;
		sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), *(x_WORD *)(a1 + 30), v24);
		sub_57CF0(a1, (int)&x_WORD_EB398);
		v25 = *(x_BYTE *)(a1 + 68) + 1;
		*(x_BYTE *)(a1 + 68) = v25;
		if (v25 > 0 && v25 > 6)
			*(x_BYTE *)(a1 + 68) = -5;
	}
	v26 = sub_10C40((__int16 *)(a1 + 76));
	result = v37 + v26;
	v28 = *(signed __int16 *)(a1 + 80);
	if (v28 < result)
	{
	LABEL_98:
		*(x_WORD *)(a1 + 80) = result;
		return result;
	}
	LOWORD(v3) = *(x_WORD *)(a1 + 54);
	if ((x_WORD)v3)
	{
		result += v3;
		goto LABEL_98;
	}
	if (!*(x_BYTE *)(a1 + 68))
	{
		v29 = v28 - result;
		result = abs(v29);
		if (result > 32)
		{
			v30 = (x_WORD *)(a1 + 80);
			if (v29 <= 0)
				v31 = 16;
			else
				v31 = -16;
			result = v31 + (signed __int16)*v30;
			*v30 = result;
		}
		if (*(x_BYTE *)(a1 + 62) & 8)
			*(x_WORD *)(a1 + 80) += 6;
		else
			*(x_WORD *)(a1 + 80) -= 6;
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;

//----- (0003B4D0) --------------------------------------------------------
Bit32u*sub_3B4D0_fill_unk_D4350_256(int a1)
{
	Bit32u* result; // eax
	char v2; // bl
	int v3; // edx

	result = (Bit32u*)&unk_D4350;
	v2 = 32;
	v3 = (a1 << 16) - 1;
	do
	{
		if (result[0])
			result[0] = v3;
		if (result[1])
			result[1] = v3;
		if (result[2])
			result[2] = v3;
		if (result[3])
			result[3] = v3;
		if (result[4])
			result[4] = v3;
		if (result[5])
			result[5] = v3;
		if (result[6])
			result[6] = v3;
		if (result[7])
			result[7] = v3;
		result += 8;
		--v2;
	} while (v2);
	return result;
}

//----- (0003B560) --------------------------------------------------------
x_DWORD *sub_3B560(__int16 a1)
{
	int v1; // edx
	x_DWORD *v2; // edi
	signed int *v3; // esi
	int v4; // eax
	__int16 v5; // bx
	signed int v6; // ecx
	int v7; // edx
	unsigned __int8 v8; // cf
	int v9; // eax
	int v10; // esi
	void(/*__noreturn*/ *v11)(); // eax
	x_DWORD *v12; // edi
	signed int *v13; // esi
	int v14; // eax
	signed int v15; // ecx
	int v16; // edx
	x_DWORD *v17; // edi
	signed int *v18; // esi
	int v19; // eax
	__int16 v20; // bx
	signed int v21; // ecx
	int v22; // edx
	x_DWORD *v23; // edi
	signed int *v24; // esi
	int v25; // eax
	__int16 v26; // bx
	signed int v27; // ecx
	int v28; // edx
	x_DWORD *result; // eax
	int v30; // eax
	signed int *v31; // esi
	x_DWORD *v32; // edi
	int v33; // eax
	signed int v34; // ecx
	int v35; // edx
	x_DWORD *v36; // edi
	signed int *v37; // esi
	int v38; // eax
	__int16 v39; // bx
	signed int v40; // ecx
	int v41; // edx
	int v42; // edx
	x_DWORD *v43; // edi
	signed int *v44; // esi
	int v45; // eax
	__int16 v46; // bx
	signed int v47; // ecx
	int v48; // edx
	int v49; // edx
	int v50; // esi
	int v51; // esi
	signed int *v52; // esi
	x_DWORD *v53; // edi
	int v54; // eax
	signed int v55; // ecx
	int v56; // edx
	x_DWORD *v57; // edi
	signed int *v58; // esi
	int v59; // eax
	__int16 v60; // bx
	signed int v61; // ecx
	int v62; // edx
	x_DWORD *v63; // edi
	signed int *v64; // esi
	int v65; // eax
	__int16 v66; // bx
	signed int v67; // ecx
	int v68; // edx
	int v69; // esi
	int v70; // eax
	x_DWORD *v71; // edi
	signed int *v72; // esi
	int v73; // eax
	signed int v74; // ecx
	int v75; // edx
	x_DWORD *v76; // edi
	signed int *v77; // esi
	int v78; // eax
	__int16 v79; // bx
	signed int v80; // ecx
	int v81; // edx
	int v82; // edx
	int v83; // ecx
	int v84; // [esp+0h] [ebp-10h]
	int v85; // [esp+0h] [ebp-10h]
	int v86; // [esp+0h] [ebp-10h]
	int v87; // [esp+0h] [ebp-10h]
	int v88; // [esp+4h] [ebp-Ch]
	int v89; // [esp+4h] [ebp-Ch]
	int v90; // [esp+4h] [ebp-Ch]
	int v91; // [esp+4h] [ebp-Ch]
	int v92; // [esp+8h] [ebp-8h]
	int v93; // [esp+8h] [ebp-8h]
	int v94; // [esp+8h] [ebp-8h]
	int v95; // [esp+8h] [ebp-8h]
	int v96; // [esp+8h] [ebp-8h]
	int v97; // [esp+8h] [ebp-8h]
	int v98; // [esp+8h] [ebp-8h]
	int v99; // [esp+8h] [ebp-8h]
	int v100; // [esp+8h] [ebp-8h]
	__int16 v101; // [esp+Ch] [ebp-4h]
	__int16 v102; // [esp+Ch] [ebp-4h]
	__int16 v103; // [esp+Ch] [ebp-4h]
	__int16 v104; // [esp+Ch] [ebp-4h]
	__int16 v105; // [esp+Ch] [ebp-4h]
	__int16 v106; // [esp+Ch] [ebp-4h]
	__int16 v107; // [esp+Ch] [ebp-4h]
	__int16 v108; // [esp+Ch] [ebp-4h]

	v1 = a1 & 0x7FF;
	x_DWORD_F2C98 = v1 >> 8;
	switch (v1 >> 8)
	{
	case 0:
		x_DWORD_F2CBC = x_DWORD_DB750[v1];
		x_DWORD_F2C8C = (int)off_DBF50[v1];
		v88 = x_DWORD_DE560;
		v92 = (unsigned __int16)x_DWORD_DE564;
		x_DWORD_F2C9C = (x_DWORD_F2CBC << 8) / (x_DWORD_F2C8C >> 8);
		v101 = (x_DWORD_F2CBC << 8) / (x_DWORD_F2C8C >> 8);
		v2 = (x_DWORD*)&unk_F0E20;
		v3 = (signed int *)(x_DWORD_E9C38_smalltit + 59360);
		v4 = 0;
		v5 = 0;
		v6 = 1;
		v7 = 0;
		do
		{
			v2[1] = v4;
			v2[2] = v7;
			v8 = __CFADD__(v101, v5);
			v5 += v101;
			if (v8)
			{
				v4 += v88;
				++v7;
				*v3 = v6;
				++v3;
			}
			v2 += 3;
			++v4;
			++v6;
			--v92;
		} while (v92);
		x_DWORD_F2C94 = v7;
		x_DWORD_F2CA4 = -v7;
		x_DWORD_F2CB4 = (unsigned __int16)x_DWORD_DE568;
		x_DWORD_F2CB8 = (unsigned __int16)x_DWORD_DE564;
		x_DWORD_F2C90 = (unsigned __int16)x_DWORD_DE568 + (unsigned __int16)x_DWORD_DE564;
		x_DWORD_F2C88 = 4 * (v7 - 1) + x_DWORD_E9C38_smalltit[59360];
		v9 = x_DWORD_DE560;
		x_DWORD_F2C84 = (unsigned __int16)x_DWORD_DE568 - v7;
		goto LABEL_66;
	case 1:
		v10 = x_DWORD_DB750[v1];
		v11 = off_DBF50[v1];
		x_DWORD_F2CBC = x_DWORD_DB750[v1];
		x_DWORD_F2C8C = (int)v11;
		v84 = x_DWORD_DE560;
		v93 = (unsigned __int16)x_DWORD_DE568;
		if (v1 == 256)
		{
			x_DWORD_F2C9C = (int)sub_10000;
			v12 = (x_DWORD*)&unk_F0E20;
			v13 = (signed int *)x_DWORD_E9C38_smalltit[59360];
			v14 = 0;
			v15 = 1;
			v16 = 0;
			do
			{
				v12[1] = v14;
				v12[2] = v16++;
				*v13 = v15;
				++v13;
				v12 += 3;
				v14 += v84 + 1;
				++v15;
				--v93;
			} while (v93);
			x_DWORD_F2C94 = (unsigned __int16)x_DWORD_DE568;
			x_DWORD_F2CA4 = -(unsigned __int16)x_DWORD_DE568;
		}
		else
		{
			x_DWORD_F2C9C = (x_DWORD_F2C8C << 8) / (v10 >> 8);
			v102 = (x_DWORD_F2C8C << 8) / (v10 >> 8);
			v17 = (x_DWORD*)&unk_F0E20;
			v18 = (signed int *)(x_DWORD_E9C38_smalltit + 59360);
			v19 = 0;
			v20 = 0;
			v21 = 1;
			v22 = 0;
			do
			{
				v17[1] = v19;
				v17[2] = v22;
				v8 = __CFADD__(v102, v20);
				v20 += v102;
				if (v8)
				{
					++v19;
					++v22;
					*v18 = v21;
					++v18;
				}
				v17 += 3;
				v19 += v84;
				++v21;
				--v93;
			} while (v93);
			x_DWORD_F2C94 = v22;
			x_DWORD_F2CA4 = -v22;
		}
		x_DWORD_F2CB4 = (unsigned __int16)x_DWORD_DE564;
		x_DWORD_F2CB8 = (unsigned __int16)x_DWORD_DE568;
		x_DWORD_F2C90 = (unsigned __int16)x_DWORD_DE568 + (unsigned __int16)x_DWORD_DE564;
		x_DWORD_F2C88 = 4 * (-1 - x_DWORD_F2CA4) + x_DWORD_E9C38_smalltit[59360];
		v9 = -1;
		x_DWORD_F2C84 = (unsigned __int16)x_DWORD_DE564 + x_DWORD_F2CA4;
		goto LABEL_66;
	case 2:
		x_DWORD_F2CBC = x_DWORD_DAF50[v1];
		x_DWORD_F2C8C = x_DWORD_DB750[v1];
		v85 = x_DWORD_DE560;
		v94 = (unsigned __int16)x_DWORD_DE568;
		x_DWORD_F2C9C = (x_DWORD_F2CBC << 8) / (x_DWORD_F2C8C >> 8);
		v103 = (x_DWORD_F2CBC << 8) / (x_DWORD_F2C8C >> 8);
		v23 = (x_DWORD*)&unk_F0E20;
		v24 = (signed int *)x_DWORD_E9C38_smalltit[59360];
		v25 = 0;
		v26 = 0;
		v27 = 1;
		v28 = 0;
		do
		{
			v23[1] = v25;
			v23[2] = v28;
			v8 = __CFADD__(v103, v26);
			v26 += v103;
			if (v8)
			{
				--v25;
				++v28;
				*v24 = v27;
				++v24;
			}
			v23 += 3;
			v25 += v85;
			++v27;
			--v94;
		} while (v94);
		x_DWORD_F2C94 = v28;
		x_DWORD_F2CA4 = -v28;
		x_DWORD_F2CB4 = (unsigned __int16)x_DWORD_DE564;
		x_DWORD_F2C90 = (unsigned __int16)x_DWORD_DE568 + (unsigned __int16)x_DWORD_DE564;
		x_DWORD_F2CB8 = (unsigned __int16)x_DWORD_DE568;
		x_DWORD_F2CAC = -1;
		x_DWORD_F2C84 = (unsigned __int16)x_DWORD_DE564 - v28;
		x_DWORD_F2C88 = 4 * (v28 - 1) + x_DWORD_E9C38_smalltit[59360];
		v95 = (unsigned __int16)x_DWORD_DE568 - 1;
		result = (x_DWORD*)&unk_F0E20;
		if (v95 < 0)
			return result;
		goto LABEL_68;
	case 3:
		v30 = x_DWORD_DB750[v1];
		x_DWORD_F2CBC = x_DWORD_DAF50[v1];
		x_DWORD_F2C8C = v30;
		v89 = x_DWORD_DE560;
		v96 = (unsigned __int16)x_DWORD_DE564;
		if (v1 == 768)
		{
			x_DWORD_F2C9C = (int)sub_10000;
			v31 = (signed int *)x_DWORD_E9C38_smalltit[59360];
			v32 = (x_DWORD*)&unk_F0E20;
			v33 = 0;
			v34 = 1;
			v35 = 0;
			do
			{
				v32[1] = v33;
				v32[2] = v35++;
				*v31 = v34;
				++v31;
				v32 += 3;
				v33 = v89 + v33 - 1;
				++v34;
				--v96;
			} while (v96);
			x_DWORD_F2C94 = (unsigned __int16)x_DWORD_DE564;
			x_DWORD_F2CA4 = -(unsigned __int16)x_DWORD_DE564;
		}
		else
		{
			x_DWORD_F2C9C = (x_DWORD_F2C8C << 8) / (x_DWORD_F2CBC >> 8);
			v104 = (x_DWORD_F2C8C << 8) / (x_DWORD_F2CBC >> 8);
			v36 = (x_DWORD*)&unk_F0E20;
			v37 = (signed int *)(x_DWORD_E9C38_smalltit + 59360);
			v38 = 0;
			v39 = 0;
			v40 = 1;
			v41 = 0;
			do
			{
				v36[1] = v38;
				v36[2] = v41;
				v8 = __CFADD__(v104, v39);
				v39 += v104;
				if (v8)
				{
					v38 += v89;
					++v41;
					*v37 = v40;
					++v37;
				}
				v36 += 3;
				--v38;
				++v40;
				--v96;
			} while (v96);
			x_DWORD_F2C94 = v41;
			x_DWORD_F2CA4 = -v41;
		}
		x_DWORD_F2CB4 = (unsigned __int16)x_DWORD_DE568;
		x_DWORD_F2CB8 = (unsigned __int16)x_DWORD_DE564;
		x_DWORD_F2C90 = (unsigned __int16)x_DWORD_DE568 + (unsigned __int16)x_DWORD_DE564;
		v42 = 4 * (-1 - x_DWORD_F2CA4) + x_DWORD_E9C38_smalltit[59360];
		x_DWORD_F2C84 = (unsigned __int16)x_DWORD_DE568 + x_DWORD_F2CA4;
		v9 = -x_DWORD_DE560;
		goto LABEL_65;
	case 4:
		x_DWORD_F2CBC = x_DWORD_DA750[v1];
		x_DWORD_F2C8C = x_DWORD_DAF50[v1];
		v90 = -x_DWORD_DE560;
		v97 = (unsigned __int16)x_DWORD_DE564;
		x_DWORD_F2C9C = (x_DWORD_F2CBC << 8) / (x_DWORD_F2C8C >> 8);
		v105 = (x_DWORD_F2CBC << 8) / (x_DWORD_F2C8C >> 8);
		v43 = (x_DWORD*)&unk_F0E20;
		v44 = (signed int *)x_DWORD_E9C38_smalltit[59360];
		v45 = 0;
		v46 = 0;
		v47 = 1;
		v48 = 0;
		do
		{
			v43[1] = v45;
			v43[2] = v48;
			v8 = __CFADD__(v105, v46);
			v46 += v105;
			if (v8)
			{
				v45 += v90;
				++v48;
				*v44 = v47;
				++v44;
			}
			v43 += 3;
			--v45;
			++v47;
			--v97;
		} while (v97);
		x_DWORD_F2C94 = v48;
		v49 = -v48;
		x_DWORD_F2CA4 = v49;
		v50 = (unsigned __int16)x_DWORD_DE568 + v49;
		x_DWORD_F2CB4 = (unsigned __int16)x_DWORD_DE568;
		x_DWORD_F2CB8 = (unsigned __int16)x_DWORD_DE564;
		x_DWORD_F2C90 = (unsigned __int16)x_DWORD_DE568 + (unsigned __int16)x_DWORD_DE564;
		v42 = 4 * (-1 - v49) + x_DWORD_E9C38_smalltit[59360];
		x_DWORD_F2C84 = v50;
		v9 = -x_DWORD_DE560;
		goto LABEL_65;
	case 5:
		v51 = x_DWORD_DA750[v1];
		x_DWORD_F2C8C = x_DWORD_DAF50[v1];
		x_DWORD_F2CBC = v51;
		v86 = -x_DWORD_DE560;
		v98 = (unsigned __int16)x_DWORD_DE568;
		if (v1 == 1280)
		{
			x_DWORD_F2C9C = (int)sub_10000;
			v52 = (signed int *)x_DWORD_E9C38_smalltit[59360];
			v53 = (x_DWORD*)&unk_F0E20;
			v54 = 0;
			v55 = 1;
			v56 = 0;
			do
			{
				v53[1] = v54;
				v53[2] = v56++;
				*v52 = v55;
				++v52;
				v53 += 3;
				v54 = v86 + v54 - 1;
				++v55;
				--v98;
			} while (v98);
			x_DWORD_F2C94 = (unsigned __int16)x_DWORD_DE568;
			x_DWORD_F2CA4 = -(unsigned __int16)x_DWORD_DE568;
		}
		else
		{
			x_DWORD_F2C9C = (x_DWORD_F2C8C << 8) / (x_DWORD_F2CBC >> 8);
			v106 = (x_DWORD_F2C8C << 8) / (x_DWORD_F2CBC >> 8);
			v57 = (x_DWORD*)&unk_F0E20;
			v58 = (signed int *)(x_DWORD_E9C38_smalltit + 59360);
			v59 = 0;
			v60 = 0;
			v61 = 1;
			v62 = 0;
			do
			{
				v57[1] = v59;
				v57[2] = v62;
				v8 = __CFADD__(v106, v60);
				v60 += v106;
				if (v8)
				{
					--v59;
					++v62;
					*v58 = v61;
					++v58;
				}
				v57 += 3;
				v59 += v86;
				++v61;
				--v98;
			} while (v98);
			x_DWORD_F2C94 = v62;
			x_DWORD_F2CA4 = -v62;
		}
		x_DWORD_F2CB4 = (unsigned __int16)x_DWORD_DE564;
		x_DWORD_F2CB8 = (unsigned __int16)x_DWORD_DE568;
		x_DWORD_F2C90 = (unsigned __int16)x_DWORD_DE568 + (unsigned __int16)x_DWORD_DE564;
		x_DWORD_F2CAC = 1;
		x_DWORD_F2C84 = (unsigned __int16)x_DWORD_DE564 + x_DWORD_F2CA4;
		x_DWORD_F2C88 = 4 * (-1 - x_DWORD_F2CA4) + x_DWORD_E9C38_smalltit[59360];
		v95 = (unsigned __int16)x_DWORD_DE568 - 1;
		result = (x_DWORD*)&unk_F0E20;
		if (v95 < 0)
			return result;
		goto LABEL_68;
	case 6:
		x_DWORD_F2CBC = x_DWORD_D9F50[v1];
		x_DWORD_F2C8C = x_DWORD_DA750[v1];
		v87 = -x_DWORD_DE560;
		v99 = (unsigned __int16)x_DWORD_DE568;
		x_DWORD_F2C9C = (x_DWORD_F2CBC << 8) / (x_DWORD_F2C8C >> 8);
		v107 = (x_DWORD_F2CBC << 8) / (x_DWORD_F2C8C >> 8);
		v63 = (x_DWORD*)&unk_F0E20;
		v64 = (signed int *)x_DWORD_E9C38_smalltit[59360];
		v65 = 0;
		v66 = 0;
		v67 = 1;
		v68 = 0;
		do
		{
			v63[1] = v65;
			v63[2] = v68;
			v8 = __CFADD__(v107, v66);
			v66 += v107;
			if (v8)
			{
				++v65;
				++v68;
				*v64 = v67;
				++v64;
			}
			v63 += 3;
			v65 += v87;
			++v67;
			--v99;
		} while (v99);
		x_DWORD_F2C94 = v68;
		x_DWORD_F2CA4 = -v68;
		x_DWORD_F2C84 = (unsigned __int16)x_DWORD_DE564 - v68;
		x_DWORD_F2CB4 = (unsigned __int16)x_DWORD_DE564;
		x_DWORD_F2C90 = (unsigned __int16)x_DWORD_DE568 + (unsigned __int16)x_DWORD_DE564;
		x_DWORD_F2CB8 = (unsigned __int16)x_DWORD_DE568;
		x_DWORD_F2CAC = 1;
		x_DWORD_F2C88 = 4 * (v68 - 1) + x_DWORD_E9C38_smalltit[59360];
		v95 = (unsigned __int16)x_DWORD_DE568 - 1;
		result = (x_DWORD*)&unk_F0E20;
		if (v95 < 0)
			return result;
		goto LABEL_68;
	case 7:
		v69 = x_DWORD_D9F50[v1];
		v70 = x_DWORD_DA750[v1];
		x_DWORD_F2CBC = x_DWORD_D9F50[v1];
		x_DWORD_F2C8C = v70;
		v91 = -x_DWORD_DE560;
		v100 = (unsigned __int16)x_DWORD_DE564;
		if (v1 == 1792)
		{
			v71 = (x_DWORD*)&unk_F0E20;
			v72 = (signed int *)x_DWORD_E9C38_smalltit[59360];
			x_DWORD_F2C9C = (int)sub_10000;
			v73 = 0;
			v74 = 1;
			v75 = 0;
			do
			{
				v71[1] = v73;
				v71[2] = v75++;
				*v72 = v74;
				++v72;
				v71 += 3;
				v73 += v91 + 1;
				++v74;
				--v100;
			} while (v100);
			x_DWORD_F2C94 = (unsigned __int16)x_DWORD_DE564;
			x_DWORD_F2CA4 = -(unsigned __int16)x_DWORD_DE564;
		}
		else
		{
			x_DWORD_F2C9C = (x_DWORD_F2C8C << 8) / (v69 >> 8);
			v108 = (x_DWORD_F2C8C << 8) / (v69 >> 8);
			v76 = (x_DWORD*)&unk_F0E20;
			v77 = (signed int *)(x_DWORD_E9C38_smalltit + 59360);
			v78 = 0;
			v79 = 0;
			v80 = 1;
			v81 = 0;
			do
			{
				v76[1] = v78;
				v76[2] = v81;
				v8 = __CFADD__(v108, v79);
				v79 += v108;
				if (v8)
				{
					v78 += v91;
					++v81;
					*v77 = v80;
					++v77;
				}
				v76 += 3;
				++v78;
				++v80;
				--v100;
			} while (v100);
			x_DWORD_F2C94 = v81;
			x_DWORD_F2CA4 = -v81;
		}
		x_DWORD_F2CB4 = (unsigned __int16)x_DWORD_DE568;
		x_DWORD_F2CB8 = (unsigned __int16)x_DWORD_DE564;
		x_DWORD_F2C90 = (unsigned __int16)x_DWORD_DE568 + (unsigned __int16)x_DWORD_DE564;
		x_DWORD_F2C84 = (unsigned __int16)x_DWORD_DE568 + x_DWORD_F2CA4;
		v42 = 4 * (-1 - x_DWORD_F2CA4) + x_DWORD_E9C38_smalltit[59360];
		v9 = x_DWORD_DE560;
	LABEL_65:
		x_DWORD_F2C88 = v42;
	LABEL_66:
		x_DWORD_F2CAC = v9;
		break;
	default:
		break;
	}
	v95 = x_DWORD_F2CB8 - 1;
	for (result = (x_DWORD*)&unk_F0E20; v95 >= 0; --v95)
	{
	LABEL_68:
		v82 = result[1];
		v83 = *(result - 2);
		result += 3;
		*(result - 3) = v82 - v83;
	}
	return result;
}
// 10000: using guessed type void /*__noreturn*/ sub_10000();
// D9F50: using guessed type int x_DWORD_D9F50[];
// DA750: using guessed type int x_DWORD_DA750[];
// DBF50: using guessed type void (/*__noreturn*/ *off_DBF50[2])();
// DE560: using guessed type int x_DWORD_DE560;
// DE564: using guessed type int x_DWORD_DE564;
// DE568: using guessed type int x_DWORD_DE568;
// E9C38: using guessed type int x_DWORD_E9C38_smalltit;
// F2C84: using guessed type int x_DWORD_F2C84;
// F2C88: using guessed type int x_DWORD_F2C88;
// F2C8C: using guessed type int x_DWORD_F2C8C;
// F2C90: using guessed type int x_DWORD_F2C90;
// F2C94: using guessed type int x_DWORD_F2C94;
// F2C98: using guessed type int x_DWORD_F2C98;
// F2C9C: using guessed type int x_DWORD_F2C9C;
// F2CA4: using guessed type int x_DWORD_F2CA4;
// F2CAC: using guessed type int x_DWORD_F2CAC;
// F2CB4: using guessed type int x_DWORD_F2CB4;
// F2CB8: using guessed type int x_DWORD_F2CB8;
// F2CBC: using guessed type int x_DWORD_F2CBC;

//----- (0003C080) --------------------------------------------------------
char sub_3C080(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, signed int a6, int a7, __int16 a8, int a9)
{
	int v9; // eax
	int v10; // edx
	int v11; // ecx
	int v12; // edx
	int v13; // edi
	char v14; // dh
	int v15; // eax
	char v16; // dl
	char v17; // dl
	x_DWORD *v18; // eax
	char v19; // dh
	int v20; // ebx
	int v21; // ecx
	char v22; // ch
	int v23; // eax
	int v24; // edx
	x_DWORD *v25; // edi
	unsigned __int16 v26; // dx
	int v27; // ebx
	int v28; // eax
	__int16 v29; // si
	int v30; // edx
	__int16 v31; // cx
	int v32; // eax
	int v33; // ecx
	signed int v34; // esi
	int v35; // ebx
	unsigned __int16 v36; // dx
	int v37; // eax
	__int16 v38; // ax
	int v39; // eax
	int v40; // edi
	int v41; // edx
	unsigned __int16 v42; // bx
	int v43; // edx
	x_BYTE *v44; // eax
	char v45; // bh
	signed int v46; // edx
	int v47; // eax
	int v48; // esi
	int v49; // ecx
	int v50; // ecx
	int v51; // ebx
	int v52; // ecx
	int v53; // ebx
	signed int v54; // esi
	signed int v55; // esi
	int v56; // eax
	int v57; // esi
	char v58; // ah
	int j; // ebx
	char v60; // dl
	char v61; // dh
	char v62; // ch
	char v63; // ah
	char v64; // dl
	char v65; // dh
	char v66; // ch
	char v67; // dl
	int v68; // ebx
	int v69; // eax
	int *v70; // edx
	char v71; // dl
	char v72; // dh
	char v73; // ch
	char v74; // ah
	char v75; // dl
	char v76; // dh
	char v77; // ch
	char v78; // dl
	char v79; // dh
	int v80; // ebx
	int *v81; // edx
	unsigned int v82; // edi
	unsigned int v83; // ebx
	char v84; // dl
	char v85; // cl
	char v86; // dh
	char v87; // al
	char v88; // dl
	char v89; // dh
	int v90; // eax
	int v91; // ebx
	char v92; // cl
	char v93; // dl
	int v94; // ebx
	int *v95; // edx
	char v96; // al
	char v97; // dl
	char v98; // dh
	char v99; // ah
	char v100; // dl
	char v101; // dh
	char v102; // ch
	int v103; // eax
	int v104; // ebx
	char v105; // dl
	char v106; // dh
	int v107; // ebx
	int *v108; // edx
	signed int v109; // esi
	int v110; // ebx
	unsigned __int16 v111; // dx
	__int16 v112; // ax
	int v113; // eax
	x_DWORD *v114; // ecx
	signed int v115; // edx
	int v116; // eax
	int v117; // edx
	unsigned __int16 v118; // bx
	unsigned __int8 v119; // al
	int v120; // edx
	x_BYTE *v121; // eax
	char v122; // bh
	signed int v123; // ebx
	int v124; // eax
	int v125; // esi
	int v126; // ecx
	int v127; // ecx
	int v128; // edx
	int v129; // ecx
	int v130; // edx
	signed int v131; // esi
	signed int v132; // esi
	int v133; // esi
	int v134; // ebx
	int v135; // eax
	char v136; // dl
	char v137; // ch
	char v138; // dl
	int v139; // eax
	int v140; // ebx
	int v141; // eax
	char v142; // ch
	int v143; // ebx
	char v144; // dl
	int v145; // eax
	int *v146; // edx
	unsigned int v147; // ebx
	char v148; // dl
	char v149; // dl
	int v150; // eax
	int v151; // ebx
	int v152; // eax
	char v153; // cl
	int v154; // eax
	int v155; // ebx
	char v156; // dl
	int v157; // eax
	int *v158; // edx
	int v159; // eax
	int v160; // esi
	int v161; // ebx
	int v162; // eax
	char v163; // dl
	char v164; // dh
	char v165; // ah
	char v166; // dl
	char v167; // dh
	int v168; // eax
	int v169; // ebx
	char v170; // ch
	int v171; // eax
	int v172; // ebx
	char v173; // dl
	char v174; // dh
	int *v175; // edx
	int *v176; // edx
	unsigned int v177; // edi
	unsigned int v178; // ebx
	char v179; // dl
	char v180; // ch
	char v181; // dh
	char v182; // ah
	char v183; // dl
	char v184; // dh
	int v185; // eax
	int v186; // ebx
	int v187; // eax
	int v188; // eax
	char v189; // ch
	int v190; // ebx
	char v191; // dl
	char v192; // dh
	int *v193; // edx
	char v194; // ch
	int *v195; // edx
	char v196; // ch
	int v197; // ecx
	signed int v198; // esi
	int v199; // ebx
	unsigned __int16 v200; // di
	__int16 v201; // ax
	int v202; // eax
	int v203; // eax
	unsigned __int16 v204; // bx
	unsigned __int8 *v205; // ecx
	int v206; // edx
	x_BYTE *v207; // eax
	int v208; // eax
	signed int v209; // ebx
	int v210; // edx
	void(/*__noreturn*/ *v211)(); // eax
	int v212; // ecx
	int v213; // edx
	int v214; // ecx
	int v215; // edx
	signed int v216; // esi
	int v217; // esi
	int v218; // ebx
	char v219; // dl
	char v220; // dh
	char v221; // al
	char v222; // dl
	char v223; // dh
	int v224; // eax
	int v225; // ebx
	char v226; // cl
	int v227; // ebx
	char v228; // dl
	char v229; // dh
	int *v230; // edx
	unsigned int v231; // edi
	unsigned int v232; // ebx
	char v233; // dl
	char v234; // ch
	char v235; // dh
	char v236; // ah
	char v237; // dl
	char v238; // dh
	int v239; // eax
	int v240; // ebx
	int v241; // eax
	char v242; // ch
	int v243; // ebx
	char v244; // dl
	char v245; // dh
	int *v246; // edx
	int v248; // [esp+0h] [ebp-62h]
	int v249; // [esp+4h] [ebp-5Eh]
	int v250; // [esp+8h] [ebp-5Ah]
	int v251; // [esp+Ch] [ebp-56h]
	int v252; // [esp+10h] [ebp-52h]
	int v253; // [esp+18h] [ebp-4Ah]
	int v254; // [esp+1Ch] [ebp-46h]
	int v255; // [esp+20h] [ebp-42h]
	int v256; // [esp+24h] [ebp-3Eh]
	x_DWORD *v257; // [esp+28h] [ebp-3Ah]
	int v258; // [esp+30h] [ebp-32h]
	int v259; // [esp+34h] [ebp-2Eh]
	int v260; // [esp+38h] [ebp-2Ah]
	int v261; // [esp+3Ch] [ebp-26h]
	int v262; // [esp+40h] [ebp-22h]
	int v263; // [esp+48h] [ebp-1Ah]
	int v264; // [esp+4Ch] [ebp-16h]
	int v265; // [esp+50h] [ebp-12h]
	int v266; // [esp+54h] [ebp-Eh]
	int v267; // [esp+58h] [ebp-Ah]
	int v268; // [esp+60h] [ebp-2h]
	int v269; // [esp+64h] [ebp+2h]
	int v270; // [esp+68h] [ebp+6h]
	int v271; // [esp+6Ch] [ebp+Ah]
	int v272; // [esp+70h] [ebp+Eh]
	int v273; // [esp+74h] [ebp+12h]
	void(/*__noreturn*/ *v274)(); // [esp+78h] [ebp+16h]
	int v275; // [esp+7Ch] [ebp+1Ah]
	int v276; // [esp+80h] [ebp+1Eh]
	x_BYTE *v277; // [esp+84h] [ebp+22h]
	int v278; // [esp+88h] [ebp+26h]
	unsigned __int16 v279; // [esp+8Ch] [ebp+2Ah]
	char l; // [esp+90h] [ebp+2Eh]
	char v281; // [esp+94h] [ebp+32h]
	char v282; // [esp+98h] [ebp+36h]
	char v283; // [esp+9Ch] [ebp+3Ah]
	char k; // [esp+A0h] [ebp+3Eh]
	char v285; // [esp+A4h] [ebp+42h]
	char i; // [esp+A8h] [ebp+46h]
	char jj; // [esp+ACh] [ebp+4Ah]
	char m; // [esp+B0h] [ebp+4Eh]
	char v289; // [esp+B4h] [ebp+52h]
	char n; // [esp+B8h] [ebp+56h]
	char ii; // [esp+BCh] [ebp+5Ah]
	char kk; // [esp+C0h] [ebp+5Eh]
	char v293; // [esp+C4h] [ebp+62h]

	x_BYTE_F2CC7 = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8587);
	x_BYTE_D4320 = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308) != 0;
	x_DWORD_F2C60 = (signed int)(unsigned __int16)x_DWORD_DE568 >> 1;
	x_WORD_F2CC4 = a3;
	x_WORD_F2CC0 = a5 & 0x7FF;
	x_WORD_F2CC2 = a4;
	v9 = (a5 & 0x7FF) + 256;
	x_DWORD_F2CA0 = a6;
	v10 = x_DWORD_DBB50[v9];
	x_DWORD_F2CB0 = x_DWORD_D4324 + ((signed int)(unsigned __int16)x_DWORD_DE564 >> 1);
	x_DWORD_F2C5C = v10;
	v11 = x_DWORD_DB350[v9];
	v12 = ((((a5 & 0x7FF) + 256) & 0x1FF) - 256) & 0x7FF;
	v276 = (v9 >> 9) & 3;
	v274 = off_DBF50[v12];
	x_DWORD_F2C7C = v11;
	v13 = x_DWORD_DB750[v12];
	sub_3B560(-a8 & 0x7FF);
	x_DWORD_F2C80 = 7
		* sub_7277A(
		(unsigned __int16)x_DWORD_DE564 * (unsigned __int16)x_DWORD_DE564
			+ (unsigned __int16)x_DWORD_DE568 * (unsigned __int16)x_DWORD_DE568)
		* a9 >> 11;
	v277 = (char *)&unk_D4328 + 10 * v276;
	switch ((unsigned __int8)a4)
	{
	case 0u:
		a2 = (unsigned __int8)a4 - 256;
		a1 = -(unsigned __int8)a3 - 4864;
		break;
	case 1u:
		a1 = -(unsigned __int8)a4 - 4864;
		a2 = -(unsigned __int8)a3;
		break;
	case 2u:
		a1 = (unsigned __int8)a3 - 4864;
		a2 = -(unsigned __int8)a4;
		break;
	case 3u:
		a1 = (unsigned __int8)a4 - 4864;
		a2 = (unsigned __int8)a3 - 256;
		break;
	default:
		break;
	}
	v14 = 40;
	v15 = (int)x_DWORD_E9C38_smalltit;
	do
	{
		v273 = a1 * v13 >> 16;
		v16 = 21;
		v272 = a1 * (signed int)v274 >> 16;
		while (v16)
		{
			*(x_DWORD *)v15 = v272;
			*(x_DWORD *)(v15 + 12) = v273;
			if (a1 < 0)
				*(x_WORD *)(v15 + 38) = 0;
			else
				*(x_WORD *)(v15 + 38) = 4;
			v15 += 1760;
			--v16;
		}
		v15 -= 36916;
		a1 += 256;
		--v14;
	} while (v14);
	v17 = 21;
	v18 = (x_DWORD *)x_DWORD_E9C38_smalltit;
	while (v17)
	{
		v271 = a2 * v13 >> 16;
		v19 = 40;
		v20 = a2 * (signed int)v274 >> 16;
		while (v19)
		{
			*v18 -= v271;
			v21 = v18[3];
			v18 += 11;
			--v19;
			*(v18 - 8) = v20 + v21;
		}
		a2 += 256;
		--v17;
	}
	x_DWORD_F2C74 = 26214400;
	v278 = (int)x_DWORD_E9C38_smalltit;
	x_DWORD_F2C68 = 8912896;
	v22 = *v277;
	x_DWORD_F2CA8 = a7 * (unsigned __int16)x_DWORD_DE564 >> 8;
	LOBYTE(v279) = v22 + HIBYTE(a3);
	HIBYTE(v279) = v277[1] + HIBYTE(a4);
	v23 = a8 & 0x7FF;
	v24 = x_DWORD_DB750[v23];
	v25 = (x_DWORD *)14745600;
	x_DWORD_F2C64 = (int)off_DBF50[v23];
	x_DWORD_F2C78 = 23658496;
	x_DWORD_F2C54 = v24;
	LOBYTE(v24) = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8588);
	x_DWORD_F2C6C = 14745600;
	if (!(x_BYTE)v24 || x_BYTE_D41B6)
	{
		v26 = x_DWORD_DE564;
		v27 = x_DWORD_DE560 - (unsigned __int16)x_DWORD_DE564;
		v28 = (v26 - (__CFSHL__((signed int)v26 >> 31, 2) + 4 * ((signed int)v26 >> 31))) >> 2;
		v29 = x_DWORD_DE568;
		v25 = (x_DWORD *)x_DWORD_DE558;
		v30 = (v26 - (__CFSHL__((signed int)v26 >> 31, 2) + 4 * ((signed int)v26 >> 31))) >> 2;
		LOBYTE(v28) = x_WORD_D4B7C;
		BYTE1(v28) = x_WORD_D4B7C;
		v31 = v28;
		v32 = v28 << 16;
		LOWORD(v32) = v31;
		do
		{
			memset32(v25, v32, v30);
			v25 = (x_DWORD *)((char *)v25 + 4 * v30 + v27);
			--v29;
		} while (v29);
	}
	else
	{
		sub_40950(a8);
	}
	if (x_BYTE_D41B6)
	{
		for (i = 21; ; i--)
		{
			if (!i)
			{
				v46 = 840;
				v47 = (int)x_DWORD_E9C38_smalltit;
				while (v46)
				{
					v48 = ((*(x_DWORD *)(v47 + 16) * x_DWORD_F2C64 - x_DWORD_F2C54 * *(x_DWORD *)(v47 + 20)) >> 16) + x_DWORD_F2CB0;
					v269 = ((*(x_DWORD *)(v47 + 16) * x_DWORD_F2C64 - x_DWORD_F2C54 * *(x_DWORD *)(v47 + 28)) >> 16) + x_DWORD_F2CB0;
					v49 = *(x_DWORD *)(v47 + 16) * x_DWORD_F2C54;
					v268 = x_DWORD_F2C60 - ((v49 + x_DWORD_F2C64 * *(x_DWORD *)(v47 + 20)) >> 16);
					v50 = x_DWORD_F2C60 - ((v49 + x_DWORD_F2C64 * *(x_DWORD *)(v47 + 28)) >> 16);
					*(x_DWORD *)(v47 + 16) = v48;
					v51 = v50;
					v52 = v268;
					*(x_DWORD *)(v47 + 28) = v51;
					*(x_DWORD *)(v47 + 20) = v52;
					v53 = *(x_DWORD *)(v47 + 16);
					*(x_DWORD *)(v47 + 24) = v269;
					if (v53 >= 0)
					{
						if ((signed int)(unsigned __int16)x_DWORD_DE564 <= *(x_DWORD *)(v47 + 16))
							*(x_BYTE *)(v47 + 38) |= 0x10u;
					}
					else
					{
						*(x_BYTE *)(v47 + 38) |= 8u;
					}
					v54 = *(x_DWORD *)(v47 + 20);
					if (v54 >= 0)
					{
						if ((unsigned __int16)x_DWORD_DE568 <= v54)
							*(x_BYTE *)(v47 + 38) |= 0x40u;
					}
					else
					{
						*(x_BYTE *)(v47 + 38) |= 0x20u;
					}
					if (*(x_DWORD *)(v47 + 24) >= 0)
					{
						if ((signed int)(unsigned __int16)x_DWORD_DE564 <= *(x_DWORD *)(v47 + 24))
							*(x_BYTE *)(v47 + 39) |= 2u;
					}
					else
					{
						*(x_BYTE *)(v47 + 39) |= 1u;
					}
					v55 = *(x_DWORD *)(v47 + 28);
					if (v55 >= 0)
					{
						if ((unsigned __int16)x_DWORD_DE568 <= v55)
							*(x_BYTE *)(v47 + 39) |= 8u;
					}
					else
					{
						*(x_BYTE *)(v47 + 39) |= 4u;
					}
					v47 += 44;
					--v46;
				}
				LOBYTE(v56) = 20;
				v57 = x_DWORD_E9C38_smalltit[35200];
				v281 = 20;
				do
				{
					v58 = 39;
					for (j = v57; ; j = v80 + 44)
					{
						v293 = v58;
						if (!v58)
							break;
						v263 = *(x_DWORD *)(j + 24);
						v264 = *(x_DWORD *)(j + 28);
						v56 = *(x_DWORD *)(j + 32);
						j += 44;
						v267 = v56;
						v60 = *(x_BYTE *)(j - 6);
						v61 = *(x_BYTE *)(j - 6);
						if (*(x_BYTE *)(j + 38) & 4)
							break;
						v258 = *(x_DWORD *)(j + 24);
						v259 = *(x_DWORD *)(j + 28);
						v262 = *(x_DWORD *)(j + 32);
						v62 = *(x_BYTE *)(j + 38);
						v253 = *(x_DWORD *)(j - 1736);
						v254 = *(x_DWORD *)(j - 1732);
						v257 = *(x_DWORD **)(j - 1728);
						v63 = *(x_BYTE *)(j - 1722);
						v64 = v63 | v62 | v60;
						v65 = v63 & v62 & v61;
						v248 = *(x_DWORD *)(j - 1780);
						v249 = *(x_DWORD *)(j - 1776);
						v252 = *(x_DWORD *)(j - 1772);
						v66 = *(x_BYTE *)(j - 1766);
						v67 = v66 | v64;
						v68 = j - 1804 + 1760;
						if ((v66 & v65 & 0x80u) == 0)
						{
							if (*(x_BYTE *)(v68 + 39) & 0x10)
							{
								x_BYTE_E126D = 7;
								x_BYTE_E126C = ((signed int)v257 + v262 + v267 + v252) >> 18;
							}
							else
							{
								x_BYTE_E126D = 5;
							}
							if (!(v67 & 2))
							{
								v69 = 0;
								if (!(v69 & 0xF00))
								{
									LOBYTE(v69) = *(x_BYTE *)(v68 + 42);
									v70 = (int *)((char *)&unk_D4350 + 32 * v69);
									v265 = *v70;
									v266 = v70[1];
									v260 = v70[2];
									v261 = v70[3];
									v255 = v70[4];
									v256 = v70[5];
									v250 = v70[6];
									v251 = v70[7];
									x_DWORD_DE55C = x_DWORD_DDF54;
									x_BYTE_E126D = 5;
									if (*(x_BYTE *)(v68 + 38) & 1)
									{
										sub_B6253(&v263, &v248, &v258);
										sub_B6253(&v248, &v253, &v258);
									}
									else
									{
										sub_B6253(&v263, &v253, &v258);
										sub_B6253(&v263, &v248, &v253);
									}
								}
							}
						}
						v263 = *(x_DWORD *)(v68 + 16);
						v264 = *(x_DWORD *)(v68 + 20);
						v56 = *(x_DWORD *)(v68 + 32);
						j = v68 + 44;
						v267 = v56;
						v71 = *(x_BYTE *)(j - 6);
						v72 = *(x_BYTE *)(j - 6);
						if (*(x_BYTE *)(j + 38) & 4)
							break;
						v258 = *(x_DWORD *)(j + 16);
						v259 = *(x_DWORD *)(j + 20);
						v262 = *(x_DWORD *)(j + 32);
						v73 = *(x_BYTE *)(j + 38);
						v253 = *(x_DWORD *)(j - 1744);
						v254 = *(x_DWORD *)(j - 1740);
						v257 = *(x_DWORD **)(j - 1728);
						v74 = *(x_BYTE *)(j - 1722);
						v75 = v74 | v73 | v71;
						v76 = v74 & v73 & v72;
						v248 = *(x_DWORD *)(j - 1788);
						v249 = *(x_DWORD *)(j - 1784);
						v56 = *(x_DWORD *)(j - 1772);
						v252 = *(x_DWORD *)(j - 1772);
						v77 = *(x_BYTE *)(j - 1766);
						v78 = v77 | v75;
						v79 = v77 & v76;
						v80 = j - 1804 + 1760;
						if (v79 >= 0)
						{
							if (*(x_BYTE *)(v80 + 39) & 0x10)
							{
								x_BYTE_E126D = 7;
								v56 = ((signed int)v257 + v262 + v267 + v252) >> 18;
								x_BYTE_E126C = v56;
							}
							else
							{
								x_BYTE_E126D = 5;
							}
							if (!(v78 & 2) && !(v79 & 0x78))
							{
								v81 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v80 + 42));
								v265 = *v81;
								v266 = v81[1];
								v260 = v81[2];
								v261 = v81[3];
								v255 = v81[4];
								v256 = v81[5];
								v250 = v81[6];
								v251 = v81[7];
								x_DWORD_DE55C = x_DWORD_DDF50[*(unsigned __int8 *)(v80 + 41)];
								if (*(x_BYTE *)(v80 + 38) & 1)
								{
									sub_B6253(&v263, &v258, &v248);
									v56 = (int)&v248;
									sub_B6253(&v248, &v258, &v253);
								}
								else
								{
									sub_B6253(&v263, &v258, &v253);
									v56 = (int)&v263;
									sub_B6253(&v263, &v253, &v248);
								}
							}
							if (*(x_WORD *)(v80 + 36))
								LOBYTE(v56) = sub_3E360(v57, v80);
						}
						v58 = v293 - 1;
					}
					if (v293)
					{
						v82 = j - 44;
						v83 = v57 + 1672;
						do
						{
							v263 = *(x_DWORD *)(v83 + 24);
							v264 = *(x_DWORD *)(v83 + 28);
							v267 = *(x_DWORD *)(v83 + 32);
							v84 = *(x_BYTE *)(v83 + 38);
							v258 = *(x_DWORD *)(v83 + 68);
							v259 = *(x_DWORD *)(v83 + 72);
							v262 = *(x_DWORD *)(v83 + 76);
							v85 = *(x_BYTE *)(v83 + 82);
							v253 = *(x_DWORD *)(v83 - 1692);
							v254 = *(x_DWORD *)(v83 - 1688);
							v86 = v84;
							v257 = *(x_DWORD **)(v83 - 1684);
							v87 = *(x_BYTE *)(v83 - 1678);
							v88 = v87 | v85 | v84;
							v89 = v87 & v85 & v86;
							v248 = *(x_DWORD *)(v83 - 1736);
							v249 = *(x_DWORD *)(v83 - 1732);
							v90 = *(x_DWORD *)(v83 - 1728);
							v91 = v83 + 44;
							v252 = v90;
							v92 = *(x_BYTE *)(v91 - 1766);
							v93 = v92 | v88;
							v94 = v91 - 1804 + 1760;
							if ((v92 & v89 & 0x80u) == 0)
							{
								if (*(x_BYTE *)(v94 + 39) & 0x10)
								{
									x_BYTE_E126D = 7;
									x_BYTE_E126C = ((signed int)v257 + v262 + v267 + v252) >> 18;
								}
								else
								{
									x_BYTE_E126D = 5;
								}
								if (!(v93 & 2))
								{
									v95 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v94 + 42));
									v265 = *v95;
									v266 = v95[1];
									v260 = v95[2];
									v261 = v95[3];
									v255 = v95[4];
									v256 = v95[5];
									v250 = v95[6];
									v251 = v95[7];
									x_DWORD_DE55C = x_DWORD_DDF54;
									v96 = *(x_BYTE *)(v94 + 38);
									x_BYTE_E126D = 5;
									if (v96 & 1)
									{
										sub_B6253(&v263, &v248, &v258);
										sub_B6253(&v248, &v253, &v258);
									}
									else
									{
										sub_B6253(&v263, &v253, &v258);
										sub_B6253(&v263, &v248, &v253);
									}
								}
							}
							v263 = *(x_DWORD *)(v94 + 16);
							v264 = *(x_DWORD *)(v94 + 20);
							v267 = *(x_DWORD *)(v94 + 32);
							v97 = *(x_BYTE *)(v94 + 38);
							v258 = *(x_DWORD *)(v94 + 60);
							v259 = *(x_DWORD *)(v94 + 64);
							v262 = *(x_DWORD *)(v94 + 76);
							v98 = v97;
							v99 = *(x_BYTE *)(v94 + 82);
							v100 = v99 | v97;
							v101 = v99 & v98;
							v253 = *(x_DWORD *)(v94 - 1700);
							v254 = *(x_DWORD *)(v94 - 1696);
							v257 = *(x_DWORD **)(v94 - 1684);
							v102 = *(x_BYTE *)(v94 - 1678);
							v248 = *(x_DWORD *)(v94 - 1744);
							v103 = *(x_DWORD *)(v94 - 1740);
							v104 = v94 + 44;
							v249 = v103;
							v56 = *(x_DWORD *)(v104 - 1772);
							v252 = *(x_DWORD *)(v104 - 1772);
							BYTE1(v56) = *(x_BYTE *)(v104 - 1766);
							v105 = BYTE1(v56) | v102 | v100;
							v106 = BYTE1(v56) & v102 & v101;
							v107 = v104 - 1804 + 1760;
							if (v106 >= 0)
							{
								if (*(x_BYTE *)(v107 + 39) & 0x10)
								{
									x_BYTE_E126D = 7;
									v56 = ((signed int)v257 + v262 + v267 + v252) >> 18;
									x_BYTE_E126C = v56;
								}
								else
								{
									x_BYTE_E126D = 5;
								}
								if (!(v105 & 2) && !(v106 & 0x78))
								{
									v108 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v107 + 42));
									v265 = *v108;
									v266 = v108[1];
									v260 = v108[2];
									v261 = v108[3];
									v255 = v108[4];
									v256 = v108[5];
									v250 = v108[6];
									v251 = v108[7];
									LOBYTE(v108) = *(x_BYTE *)(v107 + 38);
									x_DWORD_DE55C = x_DWORD_DDF50[*(unsigned __int8 *)(v107 + 41)];
									if ((unsigned __int8)v108 & 1)
									{
										sub_B6253(&v263, &v258, &v248);
										v56 = (int)&v248;
										sub_B6253(&v248, &v258, &v253);
									}
									else
									{
										sub_B6253(&v263, &v258, &v253);
										v56 = (int)&v263;
										sub_B6253(&v263, &v253, &v248);
									}
								}
								if (*(x_WORD *)(v107 + 36))
									LOBYTE(v56) = sub_3E360(v57, v107);
							}
							v83 = v107 - 44;
						} while (v83 >= v82);
					}
					v57 -= 1760;
					--v281;
				} while (v281);
				return v56;
			}
			for (k = 40; k; k--)
			{
				v33 = ((unsigned __int8)x_BYTE_12B4E0[v279] << 8) + 128;
				v34 = *(x_DWORD *)(v278 + 12);
				v35 = v34 * v34 + *(x_DWORD *)v278 * *(x_DWORD *)v278;
				*(x_WORD *)(v278 + 36) = 0;
				if (v34 <= -256 || v35 >= x_DWORD_F2C74)
				{
					*(x_BYTE *)(v278 + 38) |= 2u;
					exit(-1);
				}
				if (v34 < 128)
					v34 = 128;
				*(x_DWORD *)(v278 + 16) = x_DWORD_F2C80 * *(x_DWORD *)v278 / v34;
				v36 = v279;
				*(x_DWORD *)(v278 + 4) = 32 * x_BYTE_11B4E0[v279] - a6;
				*(x_DWORD *)(v278 + 8) = ((unsigned __int8)x_BYTE_14B4E0[v36] << 15 >> 10) - a6;
				v37 = 0;
				if (!x_BYTE_10B4E0[v36])
				{
					v38 = 32 * *(unsigned int *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11248);
					v37 = (x_DWORD_DB750[(v38 + (HIBYTE(v279) << 7)) & 0x7FF] >> 8)
						* (x_DWORD_DB750[(((unsigned __int8)v279 << 7) + v38) & 0x7FF] >> 8);
					*(x_DWORD *)(v278 + 4) -= v37 >> 13;
					if (v33 >= 14464)
						v37 = 0;
				}
				v39 = (v33 << 8) + 8 * v37;
				if (v35 <= x_DWORD_F2C6C)
					goto LABEL_39;
				if (v35 < x_DWORD_F2C78)
				{
					v39 = v39 * (signed __int64)(x_DWORD_F2C78 - v35) / x_DWORD_F2C68;
				LABEL_39:
					*(x_DWORD *)(v278 + 32) = v39;
					goto LABEL_40;
				}
				*(x_DWORD *)(v278 + 32) = 0;
			LABEL_40:
				if (x_BYTE_13B4E0[v279] & 8)
					*(x_BYTE *)(v278 + 38) |= 0x80u;
				v40 = x_DWORD_F2C80;
				v41 = v278;
				*(x_DWORD *)(v278 + 20) = x_DWORD_F2CA8 + x_DWORD_F2C80 * *(x_DWORD *)(v278 + 4) / v34;
				*(x_DWORD *)(v278 + 28) = x_DWORD_F2CA8 + v40 * *(x_DWORD *)(v41 + 8) / v34;
				LOBYTE(v42) = v277[2] + v279;
				HIBYTE(v42) = v277[3] + HIBYTE(v279);
				v43 = v278;
				*(x_BYTE *)(v278 + 41) = x_BYTE_10B4E0[v42];
				if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8601))
					*(x_BYTE *)(v43 + 39) |= 0x10u;
				*(x_BYTE *)(v278 + 43) = x_BYTE_D41D8[*(unsigned __int8 *)(v278 + 41)];
				*(x_BYTE *)(v278 + 42) = v276 + (((signed int)(unsigned __int8)x_BYTE_13B4E0[v42] >> 2) & 0x1C);
				LOBYTE(v42) = v277[4] + v42;
				HIBYTE(v42) += v277[5];
				*(x_WORD *)(v278 + 36) = x_WORD_15B4E0[v42];
			LABEL_46:
				v44 = v277;
				*(x_WORD *)(v278 + 38) |= ((x_BYTE)v279 + HIBYTE(v279)) & 1;
				LOBYTE(v279) = v44[8] + v279;
				HIBYTE(v279) += v277[9];
				v278 += 44;
			}
			v45 = v277[6] + v279;
			HIBYTE(v279) += v277[7];
			LOBYTE(v279) = v45;
		}
	}
	if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8586))
	{
		for (l = 21; ; l--)
		{
			if (!l)
			{
				v123 = 840;
				v124 = (int)x_DWORD_E9C38_smalltit;
				while (v123)
				{
					v125 = ((x_DWORD_F2C64 * *(x_DWORD *)(v124 + 16) - x_DWORD_F2C54 * *(x_DWORD *)(v124 + 20)) >> 16) + x_DWORD_F2CB0;
					v269 = ((x_DWORD_F2C64 * *(x_DWORD *)(v124 + 16) - x_DWORD_F2C54 * *(x_DWORD *)(v124 + 28)) >> 16) + x_DWORD_F2CB0;
					v126 = *(x_DWORD *)(v124 + 16) * x_DWORD_F2C54;
					v25 = (x_DWORD *)(x_DWORD_F2C60 - ((v126 + x_DWORD_F2C64 * *(x_DWORD *)(v124 + 20)) >> 16));
					v268 = x_DWORD_F2C60 - ((v126 + x_DWORD_F2C64 * *(x_DWORD *)(v124 + 20)) >> 16);
					v127 = x_DWORD_F2C60 - ((v126 + x_DWORD_F2C64 * *(x_DWORD *)(v124 + 28)) >> 16);
					*(x_DWORD *)(v124 + 16) = v125;
					v128 = v127;
					v129 = v268;
					*(x_DWORD *)(v124 + 28) = v128;
					*(x_DWORD *)(v124 + 20) = v129;
					v130 = *(x_DWORD *)(v124 + 16);
					*(x_DWORD *)(v124 + 24) = v269;
					if (v130 >= 0)
					{
						if ((signed int)(unsigned __int16)x_DWORD_DE564 <= *(x_DWORD *)(v124 + 16))
							*(x_BYTE *)(v124 + 38) |= 0x10u;
					}
					else
					{
						*(x_BYTE *)(v124 + 38) |= 8u;
					}
					v131 = *(x_DWORD *)(v124 + 20);
					if (v131 >= 0)
					{
						if ((unsigned __int16)x_DWORD_DE568 <= v131)
							*(x_BYTE *)(v124 + 38) |= 0x40u;
					}
					else
					{
						*(x_BYTE *)(v124 + 38) |= 0x20u;
					}
					if (*(x_DWORD *)(v124 + 24) >= 0)
					{
						if ((signed int)(unsigned __int16)x_DWORD_DE564 <= *(x_DWORD *)(v124 + 24))
							*(x_BYTE *)(v124 + 39) |= 2u;
					}
					else
					{
						*(x_BYTE *)(v124 + 39) |= 1u;
					}
					v132 = *(x_DWORD *)(v124 + 28);
					if (v132 >= 0)
					{
						if ((unsigned __int16)x_DWORD_DE568 <= v132)
							*(x_BYTE *)(v124 + 39) |= 8u;
					}
					else
					{
						*(x_BYTE *)(v124 + 39) |= 4u;
					}
					v124 += 44;
					--v123;
				}
				if (a6 < 4096)
				{
					v133 = x_DWORD_E9C38_smalltit[35200];
					for (m = 20; m; --m)
					{
						v134 = v133;
						for (n = 39; n; --n)
						{
							v263 = *(x_DWORD *)(v134 + 24);
							v264 = *(x_DWORD *)(v134 + 28);
							v135 = *(x_DWORD *)(v134 + 32);
							v134 += 44;
							v267 = v135;
							v136 = *(x_BYTE *)(v134 - 6);
							if (*(x_BYTE *)(v134 + 38) & 4)
								break;
							v258 = *(x_DWORD *)(v134 + 24);
							v259 = *(x_DWORD *)(v134 + 28);
							v262 = *(x_DWORD *)(v134 + 32);
							v137 = *(x_BYTE *)(v134 + 38);
							v253 = *(x_DWORD *)(v134 - 1736);
							v254 = *(x_DWORD *)(v134 - 1732);
							v257 = *(x_DWORD **)(v134 - 1728);
							v138 = *(x_BYTE *)(v134 - 1722) | v137 | v136;
							v248 = *(x_DWORD *)(v134 - 1780);
							v139 = *(x_DWORD *)(v134 - 1776);
							v140 = v134 - 1760;
							v249 = v139;
							v141 = *(x_DWORD *)(v140 - 12);
							v140 -= 44;
							v252 = v141;
							v142 = *(x_BYTE *)(v140 + 38);
							v143 = v140 + 1760;
							v144 = v142 | v138;
							if (*(x_BYTE *)(v143 + 41))
							{
								if (*(x_BYTE *)(v143 + 39) & 0x10)
								{
									x_BYTE_E126D = 7;
									v25 = v257;
									x_BYTE_E126C = ((signed int)v257 + v262 + v267 + v252) >> 18;
								}
								else
								{
									x_BYTE_E126D = 5;
								}
								if (!(v144 & 2))
								{
									v145 = 0;
									if (!(v145 & 0xF00))
									{
										LOBYTE(v145) = *(x_BYTE *)(v143 + 42);
										v146 = (int *)((char *)&unk_D4350 + 32 * v145);
										v265 = *v146;
										v266 = v146[1];
										v260 = v146[2];
										v261 = v146[3];
										v255 = v146[4];
										v256 = v146[5];
										v250 = v146[6];
										v251 = v146[7];
										x_DWORD_DE55C = x_DWORD_DDF50[*(unsigned __int8 *)(v143 + 41)];
										LOBYTE(v146) = *(x_BYTE *)(v143 + 38);
										x_BYTE_E126D = 5;
										if ((unsigned __int8)v146 & 1)
										{
											sub_B6253(&v263, &v248, &v258);
											sub_B6253(&v248, &v253, &v258);
										}
										else
										{
											sub_B6253(&v263, &v253, &v258);
											sub_B6253(&v263, &v248, &v253);
										}
									}
								}
							}
							if (*(x_WORD *)(v143 + 36))
								sub_3FD60((int)v25, v143);
							v134 = v143 + 44;
						}
						if (n)
						{
							v25 = (x_DWORD *)(v134 - 44);
							v147 = v133 + 1672;
							do
							{
								v263 = *(x_DWORD *)(v147 + 24);
								v264 = *(x_DWORD *)(v147 + 28);
								v267 = *(x_DWORD *)(v147 + 32);
								v148 = *(x_BYTE *)(v147 + 38);
								v258 = *(x_DWORD *)(v147 + 68);
								v259 = *(x_DWORD *)(v147 + 72);
								v262 = *(x_DWORD *)(v147 + 76);
								v149 = *(x_BYTE *)(v147 + 82) | v148;
								v253 = *(x_DWORD *)(v147 - 1692);
								v150 = *(x_DWORD *)(v147 - 1688);
								v151 = v147 + 44;
								v254 = v150;
								v152 = *(x_DWORD *)(v151 - 1728);
								v151 -= 1760;
								v257 = (x_DWORD *)v152;
								v153 = *(x_BYTE *)(v151 + 38);
								v248 = *(x_DWORD *)(v151 - 20);
								v154 = *(x_DWORD *)(v151 - 16);
								v151 -= 44;
								v249 = v154;
								v252 = *(x_DWORD *)(v151 + 32);
								LOBYTE(v154) = *(x_BYTE *)(v151 + 38);
								v155 = v151 + 1760;
								v156 = v154 | v153 | v149;
								if (*(x_BYTE *)(v155 + 41))
								{
									if (*(x_BYTE *)(v155 + 39) & 0x10)
									{
										x_BYTE_E126D = 7;
										x_BYTE_E126C = ((signed int)v257 + v262 + v267 + v252) >> 18;
									}
									else
									{
										x_BYTE_E126D = 5;
									}
									if (!(v156 & 2))
									{
										v157 = 0;
										if (!(v157 & 0xF00))
										{
											LOBYTE(v157) = *(x_BYTE *)(v155 + 42);
											v158 = (int *)((char *)&unk_D4350 + 32 * v157);
											v265 = *v158;
											v266 = v158[1];
											v260 = v158[2];
											v261 = v158[3];
											v255 = v158[4];
											v256 = v158[5];
											v250 = v158[6];
											v251 = v158[7];
											v159 = *(unsigned __int8 *)(v155 + 41);
											x_BYTE_E126D = 5;
											BYTE1(v158) = *(x_BYTE *)(v155 + 38);
											x_DWORD_DE55C = x_DWORD_DDF50[v159];
											if (BYTE1(v158) & 1)
											{
												sub_B6253(&v263, &v248, &v258);
												sub_B6253(&v248, &v253, &v258);
											}
											else
											{
												sub_B6253(&v263, &v253, &v258);
												sub_B6253(&v263, &v248, &v253);
											}
										}
									}
								}
								if (*(x_WORD *)(v155 + 36))
									sub_3FD60((int)v25, v155);
								v147 = v155 - 44;
							} while (v147 >= (unsigned int)v25);
						}
						v133 -= 1760;
					}
				}
				v160 = x_DWORD_E9C38_smalltit[35200];
				v282 = 20;
				do
				{
					v161 = v160;
					for (ii = 39; ii; --ii)
					{
						v263 = *(x_DWORD *)(v161 + 16);
						v264 = *(x_DWORD *)(v161 + 20);
						v162 = *(x_DWORD *)(v161 + 32);
						v161 += 44;
						v267 = v162;
						v163 = *(x_BYTE *)(v161 - 6);
						v164 = *(x_BYTE *)(v161 - 6);
						if (*(x_BYTE *)(v161 + 38) & 4)
							break;
						v258 = *(x_DWORD *)(v161 + 16);
						v259 = *(x_DWORD *)(v161 + 20);
						v262 = *(x_DWORD *)(v161 + 32);
						v165 = *(x_BYTE *)(v161 + 38);
						v166 = v165 | v163;
						v167 = v165 & v164;
						v253 = *(x_DWORD *)(v161 - 1744);
						v254 = *(x_DWORD *)(v161 - 1740);
						v168 = *(x_DWORD *)(v161 - 1728);
						v169 = v161 - 1760;
						v257 = (x_DWORD *)v168;
						v170 = *(x_BYTE *)(v169 + 38);
						v248 = *(x_DWORD *)(v169 - 28);
						v171 = *(x_DWORD *)(v169 - 24);
						v169 -= 44;
						v249 = v171;
						v252 = *(x_DWORD *)(v169 + 32);
						BYTE1(v171) = *(x_BYTE *)(v169 + 38);
						v172 = v169 + 1760;
						v173 = BYTE1(v171) | v170 | v166;
						v174 = BYTE1(v171) & v170 & v167;
						if (*(x_BYTE *)(v172 + 38) >= 0)
						{
							if (*(x_BYTE *)(v172 + 39) & 0x10)
							{
								x_BYTE_E126D = 7;
								x_BYTE_E126C = ((signed int)v257 + v262 + v267 + v252) >> 18;
							}
							else
							{
								x_BYTE_E126D = 5;
							}
							if (!(v173 & 2) && !(v174 & 0x78))
							{
								v176 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v172 + 42));
								v265 = *v176;
								v266 = v176[1];
								v260 = v176[2];
								v261 = v176[3];
								v255 = v176[4];
								v256 = v176[5];
								v250 = v176[6];
								v251 = v176[7];
								x_DWORD_DE55C = x_DWORD_DDF50[*(unsigned __int8 *)(v172 + 41)];
								if (*(x_BYTE *)(v172 + 38) & 1)
								{
									sub_B6253(&v263, &v258, &v248);
									sub_B6253(&v248, &v258, &v253);
								}
								else
								{
									sub_B6253(&v263, &v258, &v253);
									sub_B6253(&v263, &v253, &v248);
								}
							}
						}
						else
						{
							x_BYTE_E126D = 26;
							if (!(v173 & 2) && !(v174 & 0x78))
							{
								v175 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v172 + 42));
								v265 = *v175;
								v266 = v175[1];
								v260 = v175[2];
								v261 = v175[3];
								v255 = v175[4];
								v256 = v175[5];
								v250 = v175[6];
								v251 = v175[7];
								x_DWORD_DE55C = x_DWORD_DDF50[*(unsigned __int8 *)(v172 + 41)];
								if (*(x_BYTE *)(v172 + 38) & 1)
								{
									sub_B6253(&v263, &v258, &v248);
									sub_B6253(&v248, &v258, &v253);
								}
								else
								{
									sub_B6253(&v263, &v258, &v253);
									sub_B6253(&v263, &v253, &v248);
								}
							}
						}
						if (*(x_WORD *)(v172 + 36))
							sub_3E360(v160, v172);
						v161 = v172 + 44;
					}
					if (ii)
					{
						v177 = v161 - 44;
						v178 = v160 + 1672;
						do
						{
							v263 = *(x_DWORD *)(v178 + 16);
							v264 = *(x_DWORD *)(v178 + 20);
							v267 = *(x_DWORD *)(v178 + 32);
							v179 = *(x_BYTE *)(v178 + 38);
							v258 = *(x_DWORD *)(v178 + 60);
							v259 = *(x_DWORD *)(v178 + 64);
							v262 = *(x_DWORD *)(v178 + 76);
							v180 = *(x_BYTE *)(v178 + 82);
							v253 = *(x_DWORD *)(v178 - 1700);
							v254 = *(x_DWORD *)(v178 - 1696);
							v181 = v179;
							v257 = *(x_DWORD **)(v178 - 1684);
							v182 = *(x_BYTE *)(v178 - 1678);
							v183 = v182 | v180 | v179;
							v184 = v182 & v180 & v181;
							v185 = *(x_DWORD *)(v178 - 1744);
							v186 = v178 + 44;
							v248 = v185;
							v187 = *(x_DWORD *)(v186 - 1784);
							v186 -= 1760;
							v249 = v187;
							v188 = *(x_DWORD *)(v186 - 12);
							v186 -= 44;
							v252 = v188;
							v189 = *(x_BYTE *)(v186 + 38);
							v190 = v186 + 1760;
							v191 = v189 | v183;
							v192 = v189 & v184;
							if (*(x_BYTE *)(v190 + 38) >= 0)
							{
								if (*(x_BYTE *)(v190 + 39) & 0x10)
								{
									x_BYTE_E126D = 7;
									x_BYTE_E126C = ((signed int)v257 + v262 + v267 + v252) >> 18;
								}
								else
								{
									x_BYTE_E126D = 5;
								}
								if (!(v191 & 2) && !(v192 & 0x78))
								{
									v195 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v190 + 42));
									v265 = *v195;
									v266 = v195[1];
									v260 = v195[2];
									v261 = v195[3];
									v255 = v195[4];
									v256 = v195[5];
									v250 = v195[6];
									v251 = v195[7];
									v196 = *(x_BYTE *)(v190 + 38);
									x_DWORD_DE55C = x_DWORD_DDF50[*(unsigned __int8 *)(v190 + 41)];
									if (v196 & 1)
									{
										sub_B6253(&v263, &v258, &v248);
										sub_B6253(&v248, &v258, &v253);
									}
									else
									{
										sub_B6253(&v263, &v258, &v253);
										sub_B6253(&v263, &v253, &v248);
									}
								}
							}
							else
							{
								x_BYTE_E126D = 26;
								if (!(v191 & 2) && !(v192 & 0x78))
								{
									v193 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v190 + 42));
									v265 = *v193;
									v266 = v193[1];
									v260 = v193[2];
									v261 = v193[3];
									v255 = v193[4];
									v256 = v193[5];
									v250 = v193[6];
									v251 = v193[7];
									v194 = *(x_BYTE *)(v190 + 38);
									x_DWORD_DE55C = x_DWORD_DDF50[*(unsigned __int8 *)(v190 + 41)];
									if (v194 & 1)
									{
										sub_B6253(&v263, &v258, &v248);
										sub_B6253(&v248, &v258, &v253);
									}
									else
									{
										sub_B6253(&v263, &v258, &v253);
										sub_B6253(&v263, &v253, &v248);
									}
								}
							}
							if (*(x_WORD *)(v190 + 36))
								sub_3E360(v160, v190);
							v178 = v190 - 44;
						} while (v178 >= v177);
					}
					LOBYTE(v56) = v282 - 1;
					v160 -= 1760;
					--v282;
				} while (v282);
				return v56;
			}
			for (jj = 40; jj; --jj)
			{
				v275 = ((unsigned __int8)x_BYTE_12B4E0[v279] << 8) + 128;
				v109 = *(x_DWORD *)(v278 + 12);
				v110 = v109 * v109 + *(x_DWORD *)v278 * *(x_DWORD *)v278;
				*(x_WORD *)(v278 + 36) = 0;
				if (v109 <= -256 || v110 >= x_DWORD_F2C74)
				{
					*(x_BYTE *)(v278 + 38) |= 2u;
					goto LABEL_140;
				}
				if (v109 < 128)
					v109 = 128;
				*(x_DWORD *)(v278 + 16) = x_DWORD_F2C80 * *(x_DWORD *)v278 / v109;
				v111 = v279;
				*(x_DWORD *)(v278 + 4) = 32 * x_BYTE_11B4E0[v279] - a6;
				v112 = (unsigned __int16)*(x_DWORD *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11248) << 6;
				v270 = x_DWORD_DB750[(v112 + (HIBYTE(v279) << 7)) & 0x7FF] >> 8;
				v113 = v270 * (x_DWORD_DB750[(((unsigned __int8)v279 << 7) + v112) & 0x7FF] >> 8);
				v270 = x_BYTE_11B4E0[v111];
				v25 = (x_DWORD *)v278;
				*(x_DWORD *)(v278 + 8) = -(v270 * ((v113 >> 4) + 0x8000) >> 10) - a6;
				if (!(x_BYTE_13B4E0[v111] & 8)
					|| (v114 = v25, v25 = (x_DWORD *)(v25[1] - (v113 >> 10)), v115 = v275, v114[1] = (x_DWORD)v25, v115 >= 14464))
				{
					v113 = 0;
				}
				v116 = (v275 << 8) + 8 * v113;
				if (v110 <= x_DWORD_F2C6C)
					goto LABEL_133;
				v25 = (x_DWORD *)x_DWORD_F2C78;
				if (v110 < x_DWORD_F2C78)
				{
					v116 = v116 * (signed __int64)(x_DWORD_F2C78 - v110) / x_DWORD_F2C68;
				LABEL_133:
					*(x_DWORD *)(v278 + 32) = v116;
					goto LABEL_134;
				}
				*(x_DWORD *)(v278 + 32) = 0;
			LABEL_134:
				v117 = v278;
				*(x_DWORD *)(v278 + 20) = x_DWORD_F2CA8 + x_DWORD_F2C80 * *(x_DWORD *)(v278 + 4) / v109;
				*(x_DWORD *)(v278 + 28) = x_DWORD_F2CA8 + x_DWORD_F2C80 * *(x_DWORD *)(v117 + 8) / v109;
				LOBYTE(v118) = v277[2] + v279;
				HIBYTE(v118) = v277[3] + HIBYTE(v279);
				v119 = x_BYTE_10B4E0[v118];
				*(x_BYTE *)(v278 + 41) = v119;
				if (x_BYTE_D427C[v119])
					*(x_BYTE *)(v278 + 38) |= 0x80u;
				if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8601))
					*(x_BYTE *)(v278 + 39) |= 0x10u;
				v120 = v278;
				*(x_BYTE *)(v278 + 43) = x_BYTE_D41D8[*(unsigned __int8 *)(v278 + 41)];
				*(x_BYTE *)(v120 + 42) = v276 + (((signed int)(unsigned __int8)x_BYTE_13B4E0[v118] >> 2) & 0x1C);
				LOBYTE(v118) = v277[4] + v118;
				HIBYTE(v118) += v277[5];
				*(x_WORD *)(v278 + 36) = x_WORD_15B4E0[v118];
			LABEL_140:
				v121 = v277;
				*(x_WORD *)(v278 + 38) |= ((x_BYTE)v279 + HIBYTE(v279)) & 1;
				LOBYTE(v279) = v121[8] + v279;
				HIBYTE(v279) += v277[9];
				v278 += 44;
			}
			v122 = v277[6] + v279;
			HIBYTE(v279) += v277[7];
			LOBYTE(v279) = v122;
		}
	}
	v283 = 21;
LABEL_259:
	if (v283)
	{
		v285 = 40;
		while (1)
		{
			if (!v285)
			{
				LOBYTE(v279) = v277[6] + v279;
				HIBYTE(v279) += v277[7];
				--v283;
				goto LABEL_259;
			}
			v197 = ((unsigned __int8)x_BYTE_12B4E0[v279] << 8) + 128;
			v198 = *(x_DWORD *)(v278 + 12);
			v199 = v198 * v198 + *(x_DWORD *)v278 * *(x_DWORD *)v278;
			*(x_WORD *)(v278 + 36) = 0;
			if (v198 > -256 && v199 < x_DWORD_F2C74)
				break;
			*(x_BYTE *)(v278 + 38) |= 2u;
		LABEL_256:
			v206 = v278;
			v207 = v277;
			*(x_WORD *)(v278 + 38) |= ((x_BYTE)v279 + HIBYTE(v279)) & 1;
			LOBYTE(v279) = v207[8] + v279;
			HIBYTE(v279) += v277[9];
			--v285;
			v278 = v206 + 44;
		}
		if (v198 < 128)
			v198 = 128;
		v200 = v279;
		*(x_DWORD *)(v278 + 16) = x_DWORD_F2C80 * *(x_DWORD *)v278 / v198;
		*(x_DWORD *)(v278 + 4) = 32 * x_BYTE_11B4E0[v200] - a6;
		v201 = (unsigned __int16)*(x_DWORD *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11248) << 6;
		v270 = x_DWORD_DB750[(v201 + (HIBYTE(v279) << 7)) & 0x7FF] >> 8;
		v202 = v270 * (x_DWORD_DB750[(((unsigned __int8)v279 << 7) + v201) & 0x7FF] >> 8);
		if (!(x_BYTE_13B4E0[v200] & 8) || (*(x_DWORD *)(v278 + 4) -= v202 >> 10, v197 >= 14464))
			v202 = 0;
		v203 = (v197 << 8) + 8 * v202;
		if (v199 > x_DWORD_F2C6C)
		{
			if (v199 >= x_DWORD_F2C78)
			{
				*(x_DWORD *)(v278 + 32) = 0;
			LABEL_254:
				*(x_DWORD *)(v278 + 20) = x_DWORD_F2CA8 + x_DWORD_F2C80 * *(x_DWORD *)(v278 + 4) / v198;
				LOBYTE(v204) = v277[2] + v279;
				HIBYTE(v204) = v277[3] + HIBYTE(v279);
				v205 = (unsigned __int8 *)v278;
				*(x_BYTE *)(v278 + 41) = x_BYTE_10B4E0[v204];
				v205[43] = x_BYTE_D41D8[v205[41]];
				v205[42] = v276 + (((signed int)(unsigned __int8)x_BYTE_13B4E0[v204] >> 2) & 0x1C);
				LOBYTE(v204) = v277[4] + v204;
				HIBYTE(v204) += v277[5];
				*(x_WORD *)(v278 + 36) = x_WORD_15B4E0[v204];
				goto LABEL_256;
			}
			v203 = v203 * (signed __int64)(x_DWORD_F2C78 - v199) / x_DWORD_F2C68;
		}
		*(x_DWORD *)(v278 + 32) = v203;
		goto LABEL_254;
	}
	v208 = a8 & 0x7FF;
	v209 = 840;
	v210 = x_DWORD_DB750[v208];
	v211 = off_DBF50[v208];
	x_DWORD_F2C54 = v210;
	x_DWORD_F2C64 = (int)v211;
	v56 = (int)x_DWORD_E9C38_smalltit;
	while (v209)
	{
		v212 = x_DWORD_F2C60;
		v213 = (x_DWORD_F2C54 * *(x_DWORD *)(v56 + 16) + x_DWORD_F2C64 * *(x_DWORD *)(v56 + 20)) >> 16;
		*(x_DWORD *)(v56 + 16) = ((*(x_DWORD *)(v56 + 16) * x_DWORD_F2C64 - x_DWORD_F2C54 * *(x_DWORD *)(v56 + 20)) >> 16)
			+ x_DWORD_F2CB0;
		v214 = v212 - v213;
		v215 = *(x_DWORD *)(v56 + 16);
		*(x_DWORD *)(v56 + 20) = v214;
		if (v215 >= 0)
		{
			if ((signed int)(unsigned __int16)x_DWORD_DE564 <= *(x_DWORD *)(v56 + 16))
				*(x_BYTE *)(v56 + 38) |= 0x10u;
		}
		else
		{
			*(x_BYTE *)(v56 + 38) |= 8u;
		}
		v216 = *(x_DWORD *)(v56 + 20);
		if (v216 >= 0)
		{
			if ((unsigned __int16)x_DWORD_DE568 <= v216)
				*(x_BYTE *)(v56 + 38) |= 0x40u;
		}
		else
		{
			*(x_BYTE *)(v56 + 38) |= 0x20u;
		}
		v56 += 44;
		--v209;
	}
	v217 = x_DWORD_E9C38_smalltit[35200];
	v289 = 20;
	do
	{
		v218 = v217;
		for (kk = 39; kk; --kk)
		{
			v263 = *(x_DWORD *)(v218 + 16);
			v264 = *(x_DWORD *)(v218 + 20);
			v56 = *(x_DWORD *)(v218 + 32);
			v218 += 44;
			v267 = v56;
			v219 = *(x_BYTE *)(v218 - 6);
			v220 = *(x_BYTE *)(v218 - 6);
			if (*(x_BYTE *)(v218 + 38) & 4)
				break;
			v258 = *(x_DWORD *)(v218 + 16);
			v259 = *(x_DWORD *)(v218 + 20);
			v262 = *(x_DWORD *)(v218 + 32);
			v221 = *(x_BYTE *)(v218 + 38);
			v222 = v221 | v219;
			v223 = v221 & v220;
			v253 = *(x_DWORD *)(v218 - 1744);
			v254 = *(x_DWORD *)(v218 - 1740);
			v224 = *(x_DWORD *)(v218 - 1728);
			v225 = v218 - 1760;
			v257 = (x_DWORD *)v224;
			v226 = *(x_BYTE *)(v225 + 38);
			v248 = *(x_DWORD *)(v225 - 28);
			v56 = *(x_DWORD *)(v225 - 24);
			v225 -= 44;
			v249 = v56;
			v252 = *(x_DWORD *)(v225 + 32);
			LOBYTE(v56) = *(x_BYTE *)(v225 + 38);
			v227 = v225 + 1760;
			v228 = v56 | v226 | v222;
			v229 = v56 & v226 & v223;
			if (*(x_BYTE *)(v227 + 39) & 0x10)
			{
				x_BYTE_E126D = 7;
				v56 = ((signed int)v257 + v262 + v267 + v252) >> 18;
				x_BYTE_E126C = v56;
			}
			else
			{
				x_BYTE_E126D = 5;
			}
			if (!(v228 & 2) && !(v229 & 0x78))
			{
				v230 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v227 + 42));
				v265 = *v230;
				v266 = v230[1];
				v260 = v230[2];
				v261 = v230[3];
				v255 = v230[4];
				v256 = v230[5];
				v250 = v230[6];
				v251 = v230[7];
				x_DWORD_DE55C = x_DWORD_DDF50[*(unsigned __int8 *)(v227 + 41)];
				if (*(x_BYTE *)(v227 + 38) & 1)
				{
					sub_B6253(&v263, &v258, &v248);
					v56 = (int)&v248;
					sub_B6253(&v248, &v258, &v253);
				}
				else
				{
					sub_B6253(&v263, &v258, &v253);
					v56 = (int)&v263;
					sub_B6253(&v263, &v253, &v248);
				}
			}
			if (*(x_WORD *)(v227 + 36))
				LOBYTE(v56) = sub_3E360(v217, v227);
			v218 = v227 + 44;
		}
		if (kk)
		{
			v231 = v218 - 44;
			v232 = v217 + 1672;
			do
			{
				v263 = *(x_DWORD *)(v232 + 16);
				v264 = *(x_DWORD *)(v232 + 20);
				v267 = *(x_DWORD *)(v232 + 32);
				v233 = *(x_BYTE *)(v232 + 38);
				v258 = *(x_DWORD *)(v232 + 60);
				v259 = *(x_DWORD *)(v232 + 64);
				v262 = *(x_DWORD *)(v232 + 76);
				v234 = *(x_BYTE *)(v232 + 82);
				v253 = *(x_DWORD *)(v232 - 1700);
				v254 = *(x_DWORD *)(v232 - 1696);
				v235 = v233;
				v257 = *(x_DWORD **)(v232 - 1684);
				v236 = *(x_BYTE *)(v232 - 1678);
				v237 = v236 | v234 | v233;
				v238 = v236 & v234 & v235;
				v239 = *(x_DWORD *)(v232 - 1744);
				v240 = v232 + 44;
				v248 = v239;
				v241 = *(x_DWORD *)(v240 - 1784);
				v240 -= 1760;
				v249 = v241;
				v56 = *(x_DWORD *)(v240 - 12);
				v240 -= 44;
				v252 = v56;
				v242 = *(x_BYTE *)(v240 + 38);
				v243 = v240 + 1760;
				v244 = v242 | v237;
				v245 = v242 & v238;
				if (*(x_BYTE *)(v243 + 39) & 0x10)
				{
					x_BYTE_E126D = 7;
					v56 = ((signed int)v257 + v262 + v267 + v252) >> 18;
					x_BYTE_E126C = v56;
				}
				else
				{
					x_BYTE_E126D = 5;
				}
				if (!(v244 & 2) && !(v245 & 0x78))
				{
					v246 = (int *)((char *)&unk_D4350 + 32 * *(unsigned __int8 *)(v243 + 42));
					v265 = *v246;
					v266 = v246[1];
					v260 = v246[2];
					v261 = v246[3];
					v255 = v246[4];
					v256 = v246[5];
					v250 = v246[6];
					v251 = v246[7];
					x_DWORD_DE55C = x_DWORD_DDF50[*(unsigned __int8 *)(v243 + 41)];
					if (*(x_BYTE *)(v243 + 38) & 1)
					{
						sub_B6253(&v263, &v258, &v248);
						v56 = (int)&v248;
						sub_B6253(&v248, &v258, &v253);
					}
					else
					{
						sub_B6253(&v263, &v258, &v253);
						v56 = (int)&v263;
						sub_B6253(&v263, &v253, &v248);
					}
				}
				if (*(x_WORD *)(v243 + 36))
					LOBYTE(v56) = sub_3E360(v217, v243);
				v232 = v243 - 44;
			} while (v232 >= v231);
		}
		v217 -= 1760;
		--v289;
	} while (v289);
	return v56;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41B6: using guessed type char x_BYTE_D41B6;
// D4320: using guessed type char x_BYTE_D4320;
// D4324: using guessed type int x_DWORD_D4324;
// D4B7C: using guessed type __int16 x_WORD_D4B7C;
// DBF50: using guessed type void (/*__noreturn*/ *off_DBF50[2])();
// DDF50: using guessed type int x_DWORD_DDF50[];
// DDF54: using guessed type int x_DWORD_DDF54;
// DE558: using guessed type int x_DWORD_DE558;
// DE55C: using guessed type int x_DWORD_DE55C;
// DE560: using guessed type int x_DWORD_DE560;
// DE564: using guessed type int x_DWORD_DE564;
// DE568: using guessed type int x_DWORD_DE568;
// E126C: using guessed type char x_BYTE_E126C;
// E126D: using guessed type char x_BYTE_E126D;
// E9C38: using guessed type int x_DWORD_E9C38_smalltit;
// F2C54: using guessed type int x_DWORD_F2C54;
// F2C5C: using guessed type int x_DWORD_F2C5C;
// F2C60: using guessed type int x_DWORD_F2C60;
// F2C64: using guessed type int x_DWORD_F2C64;
// F2C68: using guessed type int x_DWORD_F2C68;
// F2C6C: using guessed type int x_DWORD_F2C6C;
// F2C74: using guessed type int x_DWORD_F2C74;
// F2C78: using guessed type int x_DWORD_F2C78;
// F2C7C: using guessed type int x_DWORD_F2C7C;
// F2C80: using guessed type int x_DWORD_F2C80;
// F2CA0: using guessed type int x_DWORD_F2CA0;
// F2CA4: using guessed type int x_DWORD_F2CA4;
// F2CA8: using guessed type int x_DWORD_F2CA8;
// F2CB0: using guessed type int x_DWORD_F2CB0;
// F2CC0: using guessed type __int16 x_WORD_F2CC0;
// F2CC2: using guessed type __int16 x_WORD_F2CC2;
// F2CC4: using guessed type __int16 x_WORD_F2CC4;
// F2CC7: using guessed type char x_BYTE_F2CC7;

//----- (0003E360) --------------------------------------------------------
unsigned __int16 sub_3E360(int a1, int a2)
{
	unsigned __int16 result; // ax
	int v3; // eax
	__int16 v4; // cx
	int v5; // ecx
	int v6; // edx
	__int16 *v7; // edi
	int v8; // ecx
	int v9; // ST18_4
	char v10; // al
	int v11; // ebx
	int v12; // eax
	int v13; // ebx
	int v14; // ebx
	int v15; // eax
	int v16; // ebx
	int v17; // ebx
	int v18; // ebx
	int v19; // eax
	int v20; // eax
	int v21; // eax
	int v22; // edx
	int v23; // eax
	int v24; // eax
	int v25; // ebx
	int v26; // edx
	unsigned __int16 v27; // ax
	int v28; // eax
	int v29; // edx
	unsigned __int16 v30; // ax
	int v31; // eax
	int v32; // ebx
	int v33; // eax
	int v34; // edx
	int v35; // eax
	int v36; // eax
	int v37; // ebx
	int v38; // edx
	int v39; // eax
	int v40; // eax
	int v41; // eax
	int v42; // eax
	int v43; // ebx
	char v44; // ch
	unsigned __int8 v45; // al
	int v46; // ecx
	int v47; // eax
	int v48; // eax
	int v49; // ecx
	signed __int16 *v50; // ebx
	int v51; // edx
	__int16 *v52; // edi
	int v53; // ecx
	int v54; // ST1C_4
	char v55; // al
	int v56; // ebx
	int v57; // eax
	int v58; // ebx
	int v59; // ebx
	int *v60; // esi
	int v61; // ebx
	int v62; // ebx
	int v63; // eax
	int v64; // edx
	unsigned __int16 v65; // ax
	int v66; // eax
	int v67; // eax
	int v68; // eax
	int v69; // edx
	int v70; // eax
	int v71; // eax
	int v72; // ebx
	int v73; // eax
	int v74; // edx
	int v75; // eax
	int v76; // eax
	int v77; // eax
	int v78; // eax
	int v79; // ebx
	int v80; // eax
	int v81; // eax
	int v82; // ebx
	int v83; // edx
	int v84; // eax
	int v85; // eax
	int v86; // eax
	int v87; // edx
	unsigned __int16 v88; // ax
	int v89; // eax
	int v90; // ebx
	__int16 v91; // cx
	unsigned __int8 v92; // al
	char v93; // cl
	int v94; // eax
	int v95; // eax
	int v96; // [esp+0h] [ebp-20h]
	int v97; // [esp+8h] [ebp-18h]
	int v98; // [esp+10h] [ebp-10h]
	int v99; // [esp+18h] [ebp-8h]
	int v100; // [esp+1Ch] [ebp-4h]

	result = *(x_WORD *)(a2 + 36);
	do
	{
		v3 = x_DWORD_EA3E4[result];
		x_DWORD_F2C70 = v3;
		if (!(*(x_BYTE *)(v3 + 12) & 0x21))
		{
			v4 = *(x_WORD *)(v3 + 78);
			v96 = (signed __int16)(*(x_WORD *)(v3 + 76) - x_WORD_F2CC4);
			v97 = (signed __int16)(x_WORD_F2CC2 - v4);
			if (x_BYTE_F2CC7)
			{
				if (!*(x_BYTE *)(a2 + 43) && !(*(x_WORD *)(v3 + 14) & 0x808))
				{
					v98 = sub_B5C60(*(x_WORD *)(v3 + 76), v4) - x_DWORD_F2CA0;
					v5 = (x_DWORD_F2C5C * v96 - x_DWORD_F2C7C * v97) >> 16;
					v99 = (x_DWORD_F2C7C * v96 + x_DWORD_F2C5C * v97) >> 16;
					v6 = v99 * v99 + v5 * v5;
					if (v99 > 64 && v6 < x_DWORD_F2C74)
					{
						if (v6 <= x_DWORD_F2C6C)
							x_DWORD_F2C20 = 0x2000;
						else
							x_DWORD_F2C20 = v6 < x_DWORD_F2C78 ? 32 * (x_DWORD_F2C78 - (v99 * v99 + v5 * v5)) / x_DWORD_F2C68 << 8 : 0;
						v7 = (short*)&x_WORD_D951C[7 * *(signed __int16 *)(x_DWORD_F2C70 + 90)];
						if (!*((x_BYTE *)v7 + 10))
						{
							v8 = v5 * x_DWORD_F2C80 / v99;
							v9 = x_DWORD_F2C80 * v98 / v99 + x_DWORD_F2CA8;
							x_DWORD_F2C30 = ((v8 * x_DWORD_F2C64 - x_DWORD_F2C54 * v9) >> 16) + x_DWORD_F2CB0;
							x_DWORD_F2C2C = x_DWORD_F2C60 - ((x_DWORD_F2C54 * v8 + v9 * x_DWORD_F2C64) >> 16);
							v10 = *((x_BYTE *)v7 + 12);
							x_BYTE_F2CC6 = 0;
							switch (v10)
							{
							case 0:
								v11 = (unsigned __int16)*v7;
								if (x_DWORD_F66F0[v11])
								{
									v12 = (unsigned __int16)*v7;
									v13 = 4 * v11;
								}
								else
								{
									if (!sub_71520(v11))
										goto LABEL_178;
									v12 = (unsigned __int16)*v7;
									v13 = 4 * v12;
								}
								x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 2 * (v12 + v13) + 8)] = x_D41A0_BYTEARRAY_4[26];
								a1 = *(x_DWORD *)x_DWORD_F66F0[(unsigned __int16)*v7];
								goto LABEL_51;
							case 1:
								if (!x_DWORD_F66F0[(unsigned __int16)*v7] && !sub_71520(*v7))
									goto LABEL_178;
								x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * (unsigned __int16)*v7 + 8)] = x_D41A0_BYTEARRAY_4[26];
								a1 = *(x_DWORD *)x_DWORD_F66F0[(unsigned __int16)*v7];
								goto LABEL_51;
							case 2:
							case 3:
							case 4:
							case 5:
							case 6:
							case 7:
							case 8:
							case 9:
							case 10:
							case 11:
							case 12:
							case 13:
							case 14:
							case 15:
							case 16:
								goto LABEL_29;
							case 17:
								v25 = (((*(unsigned __int16 *)(x_DWORD_F2C70 + 28) - (unsigned __int16)x_WORD_F2CC0) >> 3) & 0xF0) >> 4;
								if (v25 < 8)
								{
									if (x_DWORD_F66F0[v25 + (unsigned __int16)*v7])
									{
										v26 = (int)x_D41A0_BYTEARRAY_4;
										v27 = *(x_WORD *)(TMAPS00TAB_BEGIN_BUFFER + 10 * (v25 + (unsigned __int16)*v7) + 8);
									}
									else
									{
										if (!sub_71520(v25 + *v7))
											goto LABEL_178;
										v26 = (int)x_D41A0_BYTEARRAY_4;
										v27 = *(x_WORD *)(TMAPS00TAB_BEGIN_BUFFER + 10 * (v25 + (unsigned __int16)*v7) + 8);
									}
									x_DWORD_F5730[v27] = *(x_DWORD *)(v26 + 26);
									a1 = *(x_DWORD *)x_DWORD_F66F0[v25 + (unsigned __int16)*v7];
									goto LABEL_51;
								}
								if (x_DWORD_F66F0[(unsigned __int16)*v7 + 15 - v25])
								{
									v29 = (int)x_D41A0_BYTEARRAY_4;
									v30 = *(x_WORD *)(TMAPS00TAB_BEGIN_BUFFER + 10 * ((unsigned __int16)*v7 + 15 - v25) + 8);
								}
								else
								{
									if (!sub_71520(*v7 + 15 - v25))
										goto LABEL_178;
									v29 = (int)x_D41A0_BYTEARRAY_4;
									v30 = *(x_WORD *)(TMAPS00TAB_BEGIN_BUFFER + 10 * ((unsigned __int16)*v7 + 15 - v25) + 8);
								}
								x_DWORD_F5730[v30] = *(x_DWORD *)(v29 + 26);
								a1 = *(x_DWORD *)x_DWORD_F66F0[(unsigned __int16)*v7 + 15 - v25];
								x_DWORD_F2C40 = *(unsigned __int16 *)(a1 + 2);
								x_DWORD_F2C38 = *(unsigned __int16 *)(a1 + 4);
								v31 = (signed __int64)(x_DWORD_F2C80 * (unsigned __int64)(unsigned __int16)v7[4]) / v99;
								x_DWORD_F2C50 = v31;
								x_DWORD_F2C44 = v31 * x_DWORD_F2C40 / x_DWORD_F2C38;
								v21 = -x_DWORD_F2C40;
								goto LABEL_72;
							case 18:
								v32 = (((*(unsigned __int16 *)(x_DWORD_F2C70 + 28) - (unsigned __int16)x_WORD_F2CC0) >> 3) & 0xF0) >> 4;
								v33 = v32 + (unsigned __int16)*v7;
								if (x_DWORD_F66F0[v33])
								{
									v35 = *(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * v33 + 8);
									v34 = (int)x_D41A0_BYTEARRAY_4;
								}
								else
								{
									if (!sub_71520(v32 + *v7))
										goto LABEL_178;
									v34 = (int)x_D41A0_BYTEARRAY_4;
									v35 = *(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * (v32 + (unsigned __int16)*v7) + 8);
								}
								x_DWORD_F5730[v35] = *(x_DWORD *)(v34 + 26);
								a1 = *(x_DWORD *)x_DWORD_F66F0[v32 + (unsigned __int16)*v7];
								x_DWORD_F2C40 = *(unsigned __int16 *)(a1 + 2);
								x_DWORD_F2C38 = *(unsigned __int16 *)(a1 + 4);
								v36 = (signed __int64)(x_DWORD_F2C80 * (unsigned __int64)(unsigned __int16)v7[4]) / v99;
								x_DWORD_F2C50 = v36;
								x_DWORD_F2C44 = v36 * x_DWORD_F2C40 / x_DWORD_F2C38;
								v21 = x_DWORD_F2C40;
								goto LABEL_72;
							case 19:
								v18 = (((*(unsigned __int16 *)(x_DWORD_F2C70 + 28) - (unsigned __int16)x_WORD_F2CC0) >> 3) & 0xF0) >> 4;
								if (v18 >= 8)
								{
									v22 = (unsigned __int8)x_BYTE_D475C[v18];
									v23 = v22 + (unsigned __int16)*v7;
									if (x_DWORD_F66F0[v23])
									{
										x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * v23 + 8)] = x_D41A0_BYTEARRAY_4[26];
									}
									else
									{
										if (!sub_71520(*v7 + (unsigned __int8)v22))
											goto LABEL_178;
										x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER
											+ 10 * ((unsigned __int16)*v7 + (unsigned __int8)x_BYTE_D475C[v18])
											+ 8)] = x_D41A0_BYTEARRAY_4[26];
									}
									a1 = *(x_DWORD *)x_DWORD_F66F0[(unsigned __int16)*v7 + (unsigned __int8)x_BYTE_D475C[v18]];
									x_DWORD_F2C40 = *(unsigned __int16 *)(a1 + 2);
									x_DWORD_F2C38 = *(unsigned __int16 *)(a1 + 4);
									v24 = (signed __int64)(x_DWORD_F2C80 * (unsigned __int64)(unsigned __int16)v7[4]) / v99;
									x_DWORD_F2C50 = v24;
									x_DWORD_F2C44 = v24 * x_DWORD_F2C40 / x_DWORD_F2C38;
									v21 = -x_DWORD_F2C40;
								}
								else
								{
									v19 = (unsigned __int8)x_BYTE_D475C[v18] + (unsigned __int16)*v7;
									if (x_DWORD_F66F0[v19])
									{
										x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * v19 + 8)] = x_D41A0_BYTEARRAY_4[26];
									}
									else
									{
										if (!sub_71520(*v7 + (unsigned __int8)x_BYTE_D475C[v18]))
											goto LABEL_178;
										x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER
											+ 10 * ((unsigned __int16)*v7 + (unsigned __int8)x_BYTE_D475C[v18])
											+ 8)] = x_D41A0_BYTEARRAY_4[26];
									}
									a1 = *(x_DWORD *)x_DWORD_F66F0[(unsigned __int16)*v7 + (unsigned __int8)x_BYTE_D475C[v18]];
									x_DWORD_F2C40 = *(unsigned __int16 *)(a1 + 2);
									x_DWORD_F2C38 = *(unsigned __int16 *)(a1 + 4);
									v20 = (signed __int64)(x_DWORD_F2C80 * (unsigned __int64)(unsigned __int16)v7[4]) / v99;
									x_DWORD_F2C50 = v20;
									x_DWORD_F2C44 = v20 * x_DWORD_F2C40 / x_DWORD_F2C38;
									v21 = x_DWORD_F2C40;
								}
								goto LABEL_72;
							case 20:
								v37 = (((*(unsigned __int16 *)(x_DWORD_F2C70 + 28) - (unsigned __int16)x_WORD_F2CC0) >> 3) & 0xF0) >> 4;
								if (v37 >= 8)
								{
									v41 = (unsigned __int16)*v7 + (unsigned __int8)x_BYTE_D476C[v37];
									if (!x_DWORD_F66F0[v41])
									{
										if (!sub_71520(*v7 + (unsigned __int8)x_BYTE_D476C[v37]))
											goto LABEL_178;
										v41 = (unsigned __int8)x_BYTE_D476C[v37] + (unsigned __int16)*v7;
									}
									x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * v41 + 8)] = x_D41A0_BYTEARRAY_4[26];
									a1 = *(x_DWORD *)x_DWORD_F66F0[(unsigned __int16)*v7 + (unsigned __int8)x_BYTE_D476C[v37]];
									x_DWORD_F2C40 = *(unsigned __int16 *)(a1 + 2);
									x_DWORD_F2C38 = *(unsigned __int16 *)(a1 + 4);
									v42 = (signed __int64)(x_DWORD_F2C80 * (unsigned __int64)(unsigned __int16)v7[4]) / v99;
									x_DWORD_F2C50 = v42;
									x_DWORD_F2C44 = v42 * x_DWORD_F2C40 / x_DWORD_F2C38;
									v21 = -x_DWORD_F2C40;
								}
								else
								{
									v38 = (unsigned __int8)x_BYTE_D476C[v37];
									v39 = v38 + (unsigned __int16)*v7;
									if (x_DWORD_F66F0[v39])
									{
										x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * v39 + 8)] = x_D41A0_BYTEARRAY_4[26];
									}
									else
									{
										if (!sub_71520(*v7 + (unsigned __int8)v38))
											goto LABEL_178;
										x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER
											+ 10 * ((unsigned __int16)*v7 + (unsigned __int8)x_BYTE_D476C[v37])
											+ 8)] = x_D41A0_BYTEARRAY_4[26];
									}
									a1 = *(x_DWORD *)x_DWORD_F66F0[(unsigned __int16)*v7 + (unsigned __int8)x_BYTE_D476C[v37]];
									x_DWORD_F2C40 = *(unsigned __int16 *)(a1 + 2);
									x_DWORD_F2C38 = *(unsigned __int16 *)(a1 + 4);
									v40 = (signed __int64)(x_DWORD_F2C80 * (unsigned __int64)(unsigned __int16)v7[4]) / v99;
									x_DWORD_F2C50 = v40;
									x_DWORD_F2C44 = v40 * x_DWORD_F2C40 / x_DWORD_F2C38;
									v21 = x_DWORD_F2C40;
								}
								goto LABEL_72;
							case 21:
								v14 = (unsigned __int16)*v7;
								if (x_DWORD_F66F0[v14])
								{
									v15 = (unsigned __int16)*v7;
									v16 = 4 * v14;
								}
								else
								{
									if (!sub_71520(v14))
										goto LABEL_178;
									v15 = (unsigned __int16)*v7;
									v16 = 4 * v15;
								}
								x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 2 * (v15 + v16) + 8)] = x_D41A0_BYTEARRAY_4[26];
								a1 = *(x_DWORD *)x_DWORD_F66F0[(unsigned __int16)*v7];
								goto LABEL_51;
							case 22:
							case 23:
							case 24:
							case 25:
							case 26:
							case 27:
							case 28:
							case 29:
							case 30:
							case 31:
							case 32:
							case 33:
							case 34:
							case 35:
							case 36:
								x_BYTE_F2CC6 = 1;
							LABEL_29:
								v17 = (unsigned __int16)*v7 + *(unsigned __int8 *)(x_DWORD_F2C70 + 92);
								if (x_DWORD_F66F0[v17])
								{
									x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * v17 + 8)] = x_D41A0_BYTEARRAY_4[26];
								}
								else
								{
									if (!sub_71520(*v7 + *(unsigned __int8 *)(x_DWORD_F2C70 + 92)))
										goto LABEL_178;
									x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER
										+ 10
										* ((unsigned __int16)*v7 + *(unsigned __int8 *)(x_DWORD_F2C70 + 92))
										+ 8)] = x_D41A0_BYTEARRAY_4[26];
								}
								a1 = *(x_DWORD *)x_DWORD_F66F0[(unsigned __int16)*v7 + *(unsigned __int8 *)(x_DWORD_F2C70 + 92)];
							LABEL_51:
								x_DWORD_F2C40 = *(unsigned __int16 *)(a1 + 2);
								x_DWORD_F2C38 = *(unsigned __int16 *)(a1 + 4);
								v28 = (signed __int64)(x_DWORD_F2C80 * (unsigned __int64)(unsigned __int16)v7[4]) / v99;
								x_DWORD_F2C50 = v28;
								x_DWORD_F2C44 = v28 * x_DWORD_F2C40 / x_DWORD_F2C38;
								v21 = x_DWORD_F2C40;
							LABEL_72:
								x_DWORD_F2C34 = v21;
							LABEL_73:
								v43 = x_DWORD_F2C20;
								v44 = *(x_BYTE *)a1 | 8;
								x_DWORD_F2C28 = a1 + 6;
								*(x_BYTE *)a1 = v44;
								if (v43 == 0x2000)
									v45 = x_BYTE_D4750[*((unsigned __int8 *)v7 + 10)];
								else
									v45 = x_BYTE_D4756[*((unsigned __int8 *)v7 + 10)];
								x_DWORD_F2C24 = v45;
								v46 = x_DWORD_F2C50 >> 2;
								x_DWORD_F2C50 >>= 2;
								if (x_DWORD_F2C44 > 0 && v46 > 0)
								{
									v47 = x_DWORD_F2C20 >> 2;
									if (x_BYTE_D4320)
										x_DWORD_F2C20 = 0x2000 - v47;
									else
										x_DWORD_F2C20 = v47 + 0x2000;
									x_DWORD_F2C24 = 8;
									sub_41BD3(0);
								}
								break;
							default:
								goto LABEL_73;
							}
						}
					}
				}
			}
			if (*(x_BYTE *)(x_DWORD_F2C70 + 15) >= 0)
				v48 = *(signed __int16 *)(x_DWORD_F2C70 + 80);
			else
				v48 = *(signed __int16 *)(x_DWORD_F2C70 + 80) - 160;
			v100 = (x_DWORD_F2C7C * v96 + x_DWORD_F2C5C * v97) >> 16;
			v49 = (x_DWORD_F2C5C * v96 - x_DWORD_F2C7C * v97) >> 16;
			if (*(x_BYTE *)(x_DWORD_F2C70 + 15) & 0x20)
			{
				v50 = (signed __int16 *)((char *)&off_D404C + 22 * *(unsigned __int8 *)(x_DWORD_F2C70 + 59));
				switch ((((*(unsigned __int16 *)(x_DWORD_EA3E4[*(unsigned __int16 *)(x_DWORD_F2C70 + 50)] + 28)
					- (unsigned __int16)x_WORD_F2CC0) >> 3) & 0xF0) >> 4)
				{
				case 0:
				case 15:
					v100 -= v50[8];
					break;
				case 1:
				case 14:
					v100 -= v50[9];
					break;
				case 2:
				case 13:
					v100 -= v50[10];
					break;
				case 5:
				case 10:
					v100 += v50[10];
					break;
				case 6:
				case 9:
					v100 += v50[9];
					break;
				case 7:
				case 8:
					v100 += v50[8];
					break;
				default:
					break;
				}
			}
			v51 = v100 * v100 + v49 * v49;
			if (v100 > 64 && v51 < x_DWORD_F2C74)
			{
				if (v51 <= x_DWORD_F2C6C)
				{
					x_DWORD_F2C20 = 0x2000;
				}
				else if (v51 < x_DWORD_F2C78)
				{
					x_DWORD_F2C20 = 32 * (x_DWORD_F2C78 - (v100 * v100 + v49 * v49)) / x_DWORD_F2C68 << 8;
				}
				else
				{
					x_DWORD_F2C20 = 0;
				}
				v52 = (short*)&x_WORD_D951C[7 * *(signed __int16 *)(x_DWORD_F2C70 + 90)];
				v53 = v49 * x_DWORD_F2C80 / v100;
				v54 = x_DWORD_F2C80 * (v48 - x_DWORD_F2CA0) / v100 + x_DWORD_F2CA8;
				x_DWORD_F2C30 = ((v53 * x_DWORD_F2C64 - x_DWORD_F2C54 * v54) >> 16) + x_DWORD_F2CB0;
				x_DWORD_F2C2C = x_DWORD_F2C60 - ((x_DWORD_F2C54 * v53 + v54 * x_DWORD_F2C64) >> 16);
				v55 = *((x_BYTE *)v52 + 12);
				x_BYTE_F2CC6 = 0;
				switch (v55)
				{
				case 0:
					v56 = (unsigned __int16)*v52;
					if (x_DWORD_F66F0[v56])
					{
						v57 = (unsigned __int16)*v52;
						v58 = 4 * v56;
						goto LABEL_105;
					}
					if (sub_71520(v56))
					{
						v57 = (unsigned __int16)*v52;
						v58 = 4 * v57;
					LABEL_105:
						x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 2 * (v57 + v58) + 8)] = x_D41A0_BYTEARRAY_4[26];
						a1 = *(x_DWORD *)x_DWORD_F66F0[(unsigned __int16)*v52];
						goto LABEL_141;
					}
					break;
				case 1:
					if (x_DWORD_F66F0[(unsigned __int16)*v52])
					{
						x_DWORD_F5730[*(unsigned __int16 *)(10 * (unsigned __int16)*v52 + TMAPS00TAB_BEGIN_BUFFER + 8)] = x_D41A0_BYTEARRAY_4[26];
					}
					else
					{
						if (!sub_71520(*v52))
							break;
						x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * (unsigned __int16)*v52 + 8)] = x_D41A0_BYTEARRAY_4[26];
					}
					a1 = *(x_DWORD *)x_DWORD_F66F0[(unsigned __int16)*v52];
					goto LABEL_141;
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
				case 7:
				case 8:
				case 9:
				case 10:
				case 11:
				case 12:
				case 13:
				case 14:
				case 15:
				case 16:
					goto LABEL_117;
				case 17:
					v72 = (((*(unsigned __int16 *)(x_DWORD_F2C70 + 28) - (unsigned __int16)x_WORD_F2CC0) >> 3) & 0xF0) >> 4;
					if (*(x_BYTE *)(x_DWORD_F2C70 + 15) & 0x40)
						v72 = (unsigned __int8)x_BYTE_D477C[v72];
					if (v72 < 8)
					{
						v73 = v72 + (unsigned __int16)*v52;
						if (x_DWORD_F66F0[v73])
						{
							v74 = (int)x_D41A0_BYTEARRAY_4;
							v75 = *(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * v73 + 8);
						}
						else
						{
							if (!sub_71520(v72 + *v52))
								break;
							v74 = (int)x_D41A0_BYTEARRAY_4;
							v75 = *(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * (v72 + (unsigned __int16)*v52) + 8);
						}
						x_DWORD_F5730[v75] = *(x_DWORD *)(v74 + 26);
						a1 = *(x_DWORD *)x_DWORD_F66F0[(unsigned __int16)*v52 + v72];
						goto LABEL_141;
					}
					v77 = (unsigned __int16)*v52 + 15 - v72;
					if (x_DWORD_F66F0[v77])
					{
						x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * v77 + 8)] = x_D41A0_BYTEARRAY_4[26];
					}
					else
					{
						if (!sub_71520(*v52 + 15 - v72))
							break;
						x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * ((unsigned __int16)*v52 + 15 - v72) + 8)] = x_D41A0_BYTEARRAY_4[26];
					}
					a1 = *(x_DWORD *)x_DWORD_F66F0[(unsigned __int16)*v52 + 15 - v72];
					x_DWORD_F2C40 = *(unsigned __int16 *)(a1 + 2);
					x_DWORD_F2C38 = *(unsigned __int16 *)(a1 + 4);
					v78 = (signed __int64)(x_DWORD_F2C80 * (unsigned __int64)(unsigned __int16)v52[4]) / v100;
					x_DWORD_F2C50 = v78;
					x_DWORD_F2C44 = v78 * x_DWORD_F2C40 / x_DWORD_F2C38;
					v67 = -x_DWORD_F2C40;
					goto LABEL_163;
				case 18:
					v79 = (((*(unsigned __int16 *)(x_DWORD_F2C70 + 28) - (unsigned __int16)x_WORD_F2CC0) >> 3) & 0xF0) >> 4;
					v80 = v79 + (unsigned __int16)*v52;
					if (x_DWORD_F66F0[v80])
					{
						x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * v80 + 8)] = x_D41A0_BYTEARRAY_4[26];
					}
					else
					{
						if (!sub_71520(v79 + *v52))
							break;
						x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * (v79 + (unsigned __int16)*v52) + 8)] = x_D41A0_BYTEARRAY_4[26];
					}
					a1 = *(x_DWORD *)x_DWORD_F66F0[v79 + (unsigned __int16)*v52];
					x_DWORD_F2C40 = *(unsigned __int16 *)(a1 + 2);
					x_DWORD_F2C38 = *(unsigned __int16 *)(a1 + 4);
					v81 = (signed __int64)(x_DWORD_F2C80 * (unsigned __int64)(unsigned __int16)v52[4]) / v100;
					x_DWORD_F2C50 = v81;
					x_DWORD_F2C44 = v81 * x_DWORD_F2C40 / x_DWORD_F2C38;
					v67 = x_DWORD_F2C40;
					goto LABEL_163;
				case 19:
					v62 = (((*(unsigned __int16 *)(x_DWORD_F2C70 + 28) - (unsigned __int16)x_WORD_F2CC0) >> 3) & 0xF0) >> 4;
					if (v62 >= 8)
					{
						v68 = (unsigned __int16)*v52 + (unsigned __int8)x_BYTE_D475C[v62];
						if (x_DWORD_F66F0[v68])
						{
							v70 = *(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * v68 + 8);
							v69 = (int)x_D41A0_BYTEARRAY_4;
						}
						else
						{
							if (!sub_71520(*v52 + (unsigned __int8)x_BYTE_D475C[v62]))
								break;
							v69 = (int)x_D41A0_BYTEARRAY_4;
							v70 = *(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER
								+ 10 * ((unsigned __int16)*v52 + (unsigned __int8)x_BYTE_D475C[v62])
								+ 8);
						}
						x_DWORD_F5730[v70] = *(x_DWORD *)(v69 + 26);
						a1 = *(x_DWORD *)x_DWORD_F66F0[(unsigned __int16)*v52 + (unsigned __int8)x_BYTE_D475C[v62]];
						x_DWORD_F2C40 = *(unsigned __int16 *)(a1 + 2);
						x_DWORD_F2C38 = *(unsigned __int16 *)(a1 + 4);
						v71 = (signed __int64)(x_DWORD_F2C80 * (unsigned __int64)(unsigned __int16)v52[4]) / v100;
						x_DWORD_F2C50 = v71;
						x_DWORD_F2C44 = v71 * x_DWORD_F2C40 / x_DWORD_F2C38;
						v67 = -x_DWORD_F2C40;
					}
					else
					{
						v63 = (unsigned __int16)*v52 + (unsigned __int8)x_BYTE_D475C[v62];
						if (x_DWORD_F66F0[v63])
						{
							v64 = (int)x_D41A0_BYTEARRAY_4;
							v65 = *(x_WORD *)(TMAPS00TAB_BEGIN_BUFFER + 10 * v63 + 8);
						}
						else
						{
							if (!sub_71520(*v52 + (unsigned __int8)x_BYTE_D475C[v62]))
								break;
							v64 = (int)x_D41A0_BYTEARRAY_4;
							v65 = *(x_WORD *)(TMAPS00TAB_BEGIN_BUFFER + 10 * ((unsigned __int8)x_BYTE_D475C[v62] + (unsigned __int16)*v52) + 8);
						}
						x_DWORD_F5730[v65] = *(x_DWORD *)(v64 + 26);
						a1 = *(x_DWORD *)x_DWORD_F66F0[(unsigned __int16)*v52 + (unsigned __int8)x_BYTE_D475C[v62]];
						x_DWORD_F2C40 = *(unsigned __int16 *)(a1 + 2);
						x_DWORD_F2C38 = *(unsigned __int16 *)(a1 + 4);
						v66 = (signed __int64)(x_DWORD_F2C80 * (unsigned __int64)(unsigned __int16)v52[4]) / v100;
						x_DWORD_F2C50 = v66;
						x_DWORD_F2C44 = v66 * x_DWORD_F2C40 / x_DWORD_F2C38;
						v67 = x_DWORD_F2C40;
					}
					goto LABEL_163;
				case 20:
					v82 = (((*(unsigned __int16 *)(x_DWORD_F2C70 + 28) - (unsigned __int16)x_WORD_F2CC0) >> 3) & 0xF0) >> 4;
					if (v82 >= 8)
					{
						v86 = (unsigned __int8)x_BYTE_D476C[v82] + (unsigned __int16)*v52;
						if (x_DWORD_F66F0[v86])
						{
							v87 = (int)x_D41A0_BYTEARRAY_4;
							v88 = *(x_WORD *)(TMAPS00TAB_BEGIN_BUFFER + 10 * v86 + 8);
						}
						else
						{
							if (!sub_71520(*v52 + (unsigned __int8)x_BYTE_D476C[v82]))
								break;
							v87 = (int)x_D41A0_BYTEARRAY_4;
							v88 = *(x_WORD *)(TMAPS00TAB_BEGIN_BUFFER + 10 * ((unsigned __int16)*v52 + (unsigned __int8)x_BYTE_D476C[v82]) + 8);
						}
						x_DWORD_F5730[v88] = *(x_DWORD *)(v87 + 26);
						a1 = *(x_DWORD *)x_DWORD_F66F0[(unsigned __int16)*v52 + (unsigned __int8)x_BYTE_D476C[v82]];
						x_DWORD_F2C40 = *(unsigned __int16 *)(a1 + 2);
						x_DWORD_F2C38 = *(unsigned __int16 *)(a1 + 4);
						v89 = (signed __int64)(x_DWORD_F2C80 * (unsigned __int64)(unsigned __int16)v52[4]) / v100;
						x_DWORD_F2C50 = v89;
						x_DWORD_F2C44 = v89 * x_DWORD_F2C40 / x_DWORD_F2C38;
						v67 = -x_DWORD_F2C40;
					}
					else
					{
						v83 = (unsigned __int8)x_BYTE_D476C[v82];
						v84 = v83 + (unsigned __int16)*v52;
						if (x_DWORD_F66F0[v84])
						{
							x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * v84 + 8)] = x_D41A0_BYTEARRAY_4[26];
						}
						else
						{
							if (!sub_71520(*v52 + (unsigned __int8)v83))
								break;
							x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER
								+ 10 * ((unsigned __int16)*v52 + (unsigned __int8)x_BYTE_D476C[v82])
								+ 8)] = x_D41A0_BYTEARRAY_4[26];
						}
						a1 = *(x_DWORD *)x_DWORD_F66F0[(unsigned __int16)*v52 + (unsigned __int8)x_BYTE_D476C[v82]];
						x_DWORD_F2C40 = *(unsigned __int16 *)(a1 + 2);
						x_DWORD_F2C38 = *(unsigned __int16 *)(a1 + 4);
						v85 = (signed __int64)(x_DWORD_F2C80 * (unsigned __int64)(unsigned __int16)v52[4]) / v100;
						x_DWORD_F2C50 = v85;
						x_DWORD_F2C44 = v85 * x_DWORD_F2C40 / x_DWORD_F2C38;
						v67 = x_DWORD_F2C40;
					}
					goto LABEL_163;
				case 21:
					v59 = (unsigned __int16)*v52;
					if (x_DWORD_F66F0[v59])
					{
						x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * v59 + 8)] = x_D41A0_BYTEARRAY_4[26];
					}
					else
					{
						if (!sub_71520(v59))
							break;
						x_DWORD_F5730[*(unsigned __int16 *)(10 * (unsigned __int16)*v52 + TMAPS00TAB_BEGIN_BUFFER + 8)] = x_D41A0_BYTEARRAY_4[26];
					}
					v60 = (int *)x_DWORD_F66F0[(unsigned __int16)*v52];
					x_BYTE_F2CC6 = 1;
					a1 = *v60;
					goto LABEL_141;
				case 22:
				case 23:
				case 24:
				case 25:
				case 26:
				case 27:
				case 28:
				case 29:
				case 30:
				case 31:
				case 32:
				case 33:
				case 34:
				case 35:
				case 36:
					x_BYTE_F2CC6 = 1;
				LABEL_117:
					v61 = (unsigned __int16)*v52 + *(unsigned __int8 *)(x_DWORD_F2C70 + 92);
					if (x_DWORD_F66F0[v61])
					{
						x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * v61 + 8)] = x_D41A0_BYTEARRAY_4[26];
					}
					else
					{
						if (!sub_71520(*v52 + *(unsigned __int8 *)(x_DWORD_F2C70 + 92)))
							break;
						x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER
							+ 10 * ((unsigned __int16)*v52 + *(unsigned __int8 *)(x_DWORD_F2C70 + 92))
							+ 8)] = x_D41A0_BYTEARRAY_4[26];
					}
					a1 = *(x_DWORD *)x_DWORD_F66F0[(unsigned __int16)*v52 + *(unsigned __int8 *)(x_DWORD_F2C70 + 92)];
				LABEL_141:
					x_DWORD_F2C40 = *(unsigned __int16 *)(a1 + 2);
					x_DWORD_F2C38 = *(unsigned __int16 *)(a1 + 4);
					v76 = (signed __int64)(x_DWORD_F2C80 * (unsigned __int64)(unsigned __int16)v52[4]) / v100;
					x_DWORD_F2C50 = v76;
					x_DWORD_F2C44 = v76 * x_DWORD_F2C40 / x_DWORD_F2C38;
					v67 = x_DWORD_F2C40;
				LABEL_163:
					x_DWORD_F2C34 = v67;
				LABEL_164:
					v90 = x_DWORD_F2C70;
					*(x_BYTE *)a1 |= 8u;
					v91 = *(x_WORD *)(v90 + 14);
					x_DWORD_F2C28 = a1 + 6;
					if (v91 & 0x380)
					{
						v93 = *(x_BYTE *)(v90 + 15);
						if (v93 & 2)
						{
							v94 = (unsigned __int8)x_BYTE_E88E2[3
								* *(signed __int16 *)(*(x_DWORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(v90 + 40)]
									+ 164)
									+ 56)];
							x_DWORD_F2C24 = 4;
							x_DWORD_F2C3C = v94;
						}
						else if (v93 & 4)
						{
							v95 = (unsigned __int8)x_BYTE_E88E2[3
								* *(signed __int16 *)(*(x_DWORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(v90 + 40)]
									+ 164)
									+ 56)];
							x_DWORD_F2C24 = 5;
							x_DWORD_F2C3C = v95;
						}
						else if (*(x_BYTE *)(v90 + 14) >= 0)
						{
							if (v93 & 1)
								x_DWORD_F2C24 = 3;
						}
						else
						{
							x_DWORD_F2C24 = 2;
						}
					}
					else
					{
						if (x_DWORD_F2C20 == 0x2000)
							v92 = x_BYTE_D4750[*((unsigned __int8 *)v52 + 10)];
						else
							v92 = x_BYTE_D4756[*((unsigned __int8 *)v52 + 10)];
						x_DWORD_F2C24 = v92;
					}
					++x_DWORD_F2C44;
					++x_DWORD_F2C50;
					sub_41BD3(1u);
					break;
				default:
					goto LABEL_164;
				}
			}
		}
	LABEL_178:
		result = *(x_WORD *)(x_DWORD_F2C70 + 22);
	} while (result);
	return result;
}
// D404C: using guessed type void *off_D404C;
// D41A4: using guessed type int x_DWORD_D41A4;
// D4320: using guessed type char x_BYTE_D4320;
// D951C: using guessed type __int16 x_WORD_D951C[];
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// F2C20: using guessed type int x_DWORD_F2C20;
// F2C24: using guessed type int x_DWORD_F2C24;
// F2C28: using guessed type int x_DWORD_F2C28;
// F2C2C: using guessed type int x_DWORD_F2C2C;
// F2C30: using guessed type int x_DWORD_F2C30;
// F2C34: using guessed type int x_DWORD_F2C34;
// F2C38: using guessed type int x_DWORD_F2C38;
// F2C3C: using guessed type int x_DWORD_F2C3C;
// F2C40: using guessed type int x_DWORD_F2C40;
// F2C44: using guessed type int x_DWORD_F2C44;
// F2C50: using guessed type int x_DWORD_F2C50;
// F2C54: using guessed type int x_DWORD_F2C54;
// F2C5C: using guessed type int x_DWORD_F2C5C;
// F2C60: using guessed type int x_DWORD_F2C60;
// F2C64: using guessed type int x_DWORD_F2C64;
// F2C68: using guessed type int x_DWORD_F2C68;
// F2C6C: using guessed type int x_DWORD_F2C6C;
// F2C70: using guessed type int x_DWORD_F2C70;
// F2C74: using guessed type int x_DWORD_F2C74;
// F2C78: using guessed type int x_DWORD_F2C78;
// F2C7C: using guessed type int x_DWORD_F2C7C;
// F2C80: using guessed type int x_DWORD_F2C80;
// F2CA0: using guessed type int x_DWORD_F2CA0;
// F2CA4: using guessed type int x_DWORD_F2CA4;
// F2CA8: using guessed type int x_DWORD_F2CA8;
// F2CB0: using guessed type int x_DWORD_F2CB0;
// F2CC0: using guessed type __int16 x_WORD_F2CC0;
// F2CC2: using guessed type __int16 x_WORD_F2CC2;
// F2CC4: using guessed type __int16 x_WORD_F2CC4;
// F2CC6: using guessed type char x_BYTE_F2CC6;
// F2CC7: using guessed type char x_BYTE_F2CC7;
// F6ED0: using guessed type int TMAPS00TAB_BEGIN_BUFFER;

//----- (0003FD60) --------------------------------------------------------
unsigned __int16 sub_3FD60(int a1, int a2)
{
	unsigned __int16 result; // ax
	int v3; // eax
	int v4; // edx
	int v5; // eax
	int v6; // ecx
	int v7; // esi
	int v8; // edx
	__int16 *v9; // esi
	int v10; // ecx
	int v11; // ST0C_4
	char v12; // al
	int v13; // ebx
	int v14; // eax
	int v15; // ebx
	int v16; // ebx
	int *v17; // edi
	int v18; // eax
	int v19; // ebx
	int v20; // edx
	int v21; // eax
	int v22; // eax
	int v23; // eax
	int v24; // eax
	int v25; // eax
	int v26; // ebx
	int v27; // eax
	int v28; // eax
	int v29; // ebx
	int v30; // eax
	int v31; // eax
	int v32; // ebx
	int v33; // eax
	int v34; // eax
	int v35; // eax
	int v36; // eax
	char v37; // cl
	int v38; // eax
	unsigned __int8 v39; // al
	int v40; // [esp+0h] [ebp-Ch]
	int v41; // [esp+4h] [ebp-8h]
	int v42; // [esp+8h] [ebp-4h]

	result = *(x_WORD *)(a2 + 36);
	do
	{
		if (result < 0x3E8u)
		{
			v3 = x_DWORD_EA3E4[result];
			v41 = v3;
			if (!(*(x_BYTE *)(v3 + 12) & 0x21))
			{
				v4 = (signed __int16)(*(x_WORD *)(v3 + 76) - x_WORD_F2CC4);
				v5 = (signed __int16)(x_WORD_F2CC2 - *(x_WORD *)(v3 + 78));
				v42 = -*(signed __int16 *)(v41 + 80) - x_DWORD_F2CA0;
				v6 = (v4 * x_DWORD_F2C5C - v5 * x_DWORD_F2C7C) >> 16;
				v40 = (x_DWORD_F2C7C * v4 + x_DWORD_F2C5C * v5) >> 16;
				v7 = (x_DWORD_F2C7C * v4 + x_DWORD_F2C5C * v5) >> 16;
				v8 = v40 * v40 + v6 * v6;
				if (v7 > 64 && v8 < x_DWORD_F2C74)
				{
					if (v8 <= x_DWORD_F2C6C)
					{
						x_DWORD_F2C20 = 0x2000;
					}
					else if (v8 < x_DWORD_F2C78)
					{
						x_DWORD_F2C20 = 32 * (x_DWORD_F2C78 - (v40 * v40 + v6 * v6)) / x_DWORD_F2C68 << 8;
					}
					else
					{
						x_DWORD_F2C20 = 0;
					}
					v9 = (short*)&x_WORD_D951C[7 * *(signed __int16 *)(v41 + 90)];
					v10 = v6 * x_DWORD_F2C80 / v40;
					v11 = x_DWORD_F2C80 * v42 / v40 + x_DWORD_F2CA8;
					x_DWORD_F2C30 = ((v10 * x_DWORD_F2C64 - x_DWORD_F2C54 * v11) >> 16) + x_DWORD_F2CB0;
					x_DWORD_F2C2C = x_DWORD_F2C60 - ((x_DWORD_F2C54 * v10 + v11 * x_DWORD_F2C64) >> 16);
					v12 = *((x_BYTE *)v9 + 12);
					x_BYTE_F2CC6 = 0;
					switch (v12)
					{
					case 0:
						v13 = (unsigned __int16)*v9;
						if (x_DWORD_F66F0[v13])
						{
							v14 = (unsigned __int16)*v9;
							v15 = 4 * v13;
							goto LABEL_16;
						}
						if (sub_71520(v13))
						{
							v14 = (unsigned __int16)*v9;
							v15 = 4 * v14;
						LABEL_16:
							x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 2 * (v14 + v15) + 8)] = x_D41A0_BYTEARRAY_4[26];
							a1 = *(x_DWORD *)x_DWORD_F66F0[(unsigned __int16)*v9];
							goto LABEL_47;
						}
						break;
					case 1:
						if (!x_DWORD_F66F0[(unsigned __int16)*v9] && !sub_71520(*v9))
							break;
						x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * (unsigned __int16)*v9 + 8)] = x_D41A0_BYTEARRAY_4[26];
						a1 = *(x_DWORD *)x_DWORD_F66F0[(unsigned __int16)*v9];
						goto LABEL_47;
					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
					case 7:
					case 8:
					case 9:
					case 10:
					case 11:
					case 12:
					case 13:
					case 14:
					case 15:
					case 16:
						goto LABEL_26;
					case 17:
						v26 = (((*(unsigned __int16 *)(v41 + 28) - (unsigned __int16)x_WORD_F2CC0) >> 3) & 0xF0) >> 4;
						if (v26 < 8)
						{
							if (x_DWORD_F66F0[v26 + (unsigned __int16)*v9])
							{
								x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * (v26 + (unsigned __int16)*v9) + 8)] = x_D41A0_BYTEARRAY_4[26];
							}
							else
							{
								if (!sub_71520(v26 + *v9))
									break;
								x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * (v26 + (unsigned __int16)*v9) + 8)] = x_D41A0_BYTEARRAY_4[26];
							}
							a1 = *(x_DWORD *)x_DWORD_F66F0[v26 + (unsigned __int16)*v9];
							goto LABEL_47;
						}
						if (x_DWORD_F66F0[(unsigned __int16)*v9 + 15 - v26])
						{
							x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * ((unsigned __int16)*v9 + 15 - v26) + 8)] = x_D41A0_BYTEARRAY_4[26];
						}
						else
						{
							if (!sub_71520(*v9 + 15 - v26))
								break;
							x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * ((unsigned __int16)*v9 + 15 - v26) + 8)] = x_D41A0_BYTEARRAY_4[26];
						}
						a1 = *(x_DWORD *)x_DWORD_F66F0[(unsigned __int16)*v9 + 15 - v26];
						x_DWORD_F2C40 = *(unsigned __int16 *)(a1 + 2);
						x_DWORD_F2C38 = *(unsigned __int16 *)(a1 + 4);
						v28 = (signed __int64)(x_DWORD_F2C80 * (unsigned __int64)(unsigned __int16)v9[4]) / v40;
						x_DWORD_F2C50 = v28;
						x_DWORD_F2C44 = v28 * x_DWORD_F2C40 / x_DWORD_F2C38;
						v23 = -x_DWORD_F2C40;
						goto LABEL_69;
					case 18:
						v29 = (((*(unsigned __int16 *)(v41 + 28) - (unsigned __int16)x_WORD_F2CC0) >> 3) & 0xF0) >> 4;
						v30 = v29 + (unsigned __int16)*v9;
						if (x_DWORD_F66F0[v30])
						{
							x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * v30 + 8)] = x_D41A0_BYTEARRAY_4[26];
						}
						else
						{
							if (!sub_71520(v29 + *v9))
								break;
							x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * (v29 + (unsigned __int16)*v9) + 8)] = x_D41A0_BYTEARRAY_4[26];
						}
						a1 = *(x_DWORD *)x_DWORD_F66F0[(unsigned __int16)*v9 + v29];
						x_DWORD_F2C40 = *(unsigned __int16 *)(a1 + 2);
						x_DWORD_F2C38 = *(unsigned __int16 *)(a1 + 4);
						v31 = (signed __int64)(x_DWORD_F2C80 * (unsigned __int64)(unsigned __int16)v9[4]) / v40;
						x_DWORD_F2C50 = v31;
						x_DWORD_F2C44 = v31 * x_DWORD_F2C40 / x_DWORD_F2C38;
						v23 = x_DWORD_F2C40;
						goto LABEL_69;
					case 19:
						v19 = (((*(unsigned __int16 *)(v41 + 28) - (unsigned __int16)x_WORD_F2CC0) >> 3) & 0xF0) >> 4;
						if (v19 >= 8)
						{
							v24 = (unsigned __int16)*v9 + (unsigned __int8)x_BYTE_D475C[v19];
							if (!x_DWORD_F66F0[v24])
							{
								if (!sub_71520(*v9 + (unsigned __int8)x_BYTE_D475C[v19]))
									break;
								v24 = (unsigned __int16)*v9 + (unsigned __int8)x_BYTE_D475C[v19];
							}
							x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * v24 + 8)] = x_D41A0_BYTEARRAY_4[26];
							a1 = *(x_DWORD *)x_DWORD_F66F0[(unsigned __int16)*v9 + (unsigned __int8)x_BYTE_D475C[v19]];
							x_DWORD_F2C40 = *(unsigned __int16 *)(a1 + 2);
							x_DWORD_F2C38 = *(unsigned __int16 *)(a1 + 4);
							v25 = (signed __int64)(x_DWORD_F2C80 * (unsigned __int64)(unsigned __int16)v9[4]) / v40;
							x_DWORD_F2C50 = v25;
							x_DWORD_F2C44 = v25 * x_DWORD_F2C40 / x_DWORD_F2C38;
							v23 = -x_DWORD_F2C40;
						}
						else
						{
							v20 = (unsigned __int8)x_BYTE_D475C[v19];
							v21 = v20 + (unsigned __int16)*v9;
							if (x_DWORD_F66F0[v21])
							{
								x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * v21 + 8)] = x_D41A0_BYTEARRAY_4[26];
							}
							else
							{
								if (!sub_71520(*v9 + (unsigned __int8)v20))
									break;
								x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER
									+ 10 * ((unsigned __int16)*v9 + (unsigned __int8)x_BYTE_D475C[v19])
									+ 8)] = x_D41A0_BYTEARRAY_4[26];
							}
							a1 = *(x_DWORD *)x_DWORD_F66F0[(unsigned __int16)*v9 + (unsigned __int8)x_BYTE_D475C[v19]];
							x_DWORD_F2C40 = *(unsigned __int16 *)(a1 + 2);
							x_DWORD_F2C38 = *(unsigned __int16 *)(a1 + 4);
							v22 = (signed __int64)(x_DWORD_F2C80 * (unsigned __int64)(unsigned __int16)v9[4]) / v40;
							x_DWORD_F2C50 = v22;
							x_DWORD_F2C44 = v22 * x_DWORD_F2C40 / x_DWORD_F2C38;
							v23 = x_DWORD_F2C40;
						}
						goto LABEL_69;
					case 20:
						v32 = (((*(unsigned __int16 *)(v41 + 28) - (unsigned __int16)x_WORD_F2CC0) >> 3) & 0xF0) >> 4;
						if (v32 >= 8)
						{
							v35 = (unsigned __int16)*v9 + (unsigned __int8)x_BYTE_D476C[v32];
							if (x_DWORD_F66F0[v35])
							{
								x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * v35 + 8)] = x_D41A0_BYTEARRAY_4[26];
							}
							else
							{
								if (!sub_71520(*v9 + (unsigned __int8)x_BYTE_D476C[v32]))
									break;
								x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER
									+ 10 * ((unsigned __int16)*v9 + (unsigned __int8)x_BYTE_D476C[v32])
									+ 8)] = x_D41A0_BYTEARRAY_4[26];
							}
							a1 = *(x_DWORD *)x_DWORD_F66F0[(unsigned __int8)x_BYTE_D476C[v32] + (unsigned __int16)*v9];
							x_DWORD_F2C40 = *(unsigned __int16 *)(a1 + 2);
							x_DWORD_F2C38 = *(unsigned __int16 *)(a1 + 4);
							v36 = (signed __int64)(x_DWORD_F2C80 * (unsigned __int64)(unsigned __int16)v9[4]) / v40;
							x_DWORD_F2C50 = v36;
							x_DWORD_F2C44 = v36 * x_DWORD_F2C40 / x_DWORD_F2C38;
							v23 = -x_DWORD_F2C40;
						}
						else
						{
							v33 = (unsigned __int16)*v9 + (unsigned __int8)x_BYTE_D476C[v32];
							if (x_DWORD_F66F0[v33])
							{
								x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * v33 + 8)] = x_D41A0_BYTEARRAY_4[26];
							}
							else
							{
								if (!sub_71520(*v9 + (unsigned __int8)x_BYTE_D476C[v32]))
									break;
								x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER
									+ 10 * ((unsigned __int16)*v9 + (unsigned __int8)x_BYTE_D476C[v32])
									+ 8)] = x_D41A0_BYTEARRAY_4[26];
							}
							a1 = *(x_DWORD *)x_DWORD_F66F0[(unsigned __int16)*v9 + (unsigned __int8)x_BYTE_D476C[v32]];
							x_DWORD_F2C40 = *(unsigned __int16 *)(a1 + 2);
							x_DWORD_F2C38 = *(unsigned __int16 *)(a1 + 4);
							v34 = (signed __int64)(x_DWORD_F2C80 * (unsigned __int64)(unsigned __int16)v9[4]) / v40;
							x_DWORD_F2C50 = v34;
							x_DWORD_F2C44 = v34 * x_DWORD_F2C40 / x_DWORD_F2C38;
							v23 = x_DWORD_F2C40;
						}
						goto LABEL_69;
					case 21:
						v16 = (unsigned __int16)*v9;
						if (x_DWORD_F66F0[v16])
						{
							x_DWORD_F5730[*(unsigned __int16 *)(10 * v16 + TMAPS00TAB_BEGIN_BUFFER + 8)] = x_D41A0_BYTEARRAY_4[26];
						}
						else
						{
							if (!sub_71520(v16))
								break;
							x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * (unsigned __int16)*v9 + 8)] = x_D41A0_BYTEARRAY_4[26];
						}
						v17 = (int *)x_DWORD_F66F0[(unsigned __int16)*v9];
						x_BYTE_F2CC6 = 1;
						a1 = *v17;
						goto LABEL_47;
					case 22:
					case 23:
					case 24:
					case 25:
					case 26:
					case 27:
					case 28:
					case 29:
					case 30:
					case 31:
					case 32:
					case 33:
					case 34:
					case 35:
					case 36:
						x_BYTE_F2CC6 = 1;
					LABEL_26:
						v18 = *(unsigned __int8 *)(v41 + 92) + (unsigned __int16)*v9;
						if (x_DWORD_F66F0[v18])
						{
							x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * v18 + 8)] = x_D41A0_BYTEARRAY_4[26];
						}
						else
						{
							if (!sub_71520(*v9 + *(unsigned __int8 *)(v41 + 92)))
								break;
							x_DWORD_F5730[*(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER
								+ 10 * ((unsigned __int16)*v9 + *(unsigned __int8 *)(v41 + 92))
								+ 8)] = x_D41A0_BYTEARRAY_4[26];
						}
						a1 = *(x_DWORD *)x_DWORD_F66F0[(unsigned __int16)*v9 + *(unsigned __int8 *)(v41 + 92)];
					LABEL_47:
						x_DWORD_F2C40 = *(unsigned __int16 *)(a1 + 2);
						x_DWORD_F2C38 = *(unsigned __int16 *)(a1 + 4);
						v27 = (signed __int64)(x_DWORD_F2C80 * (unsigned __int64)(unsigned __int16)v9[4]) / v40;
						x_DWORD_F2C50 = v27;
						x_DWORD_F2C44 = v27 * x_DWORD_F2C40 / x_DWORD_F2C38;
						v23 = x_DWORD_F2C40;
					LABEL_69:
						x_DWORD_F2C34 = v23;
					LABEL_70:
						v37 = *(x_BYTE *)a1 | 8;
						x_DWORD_F2C28 = a1 + 6;
						v38 = x_DWORD_F2C20;
						*(x_BYTE *)a1 = v37;
						if (v38 == 0x2000)
							v39 = x_BYTE_D4750[*((unsigned __int8 *)v9 + 10)];
						else
							v39 = x_BYTE_D4756[*((unsigned __int8 *)v9 + 10)];
						x_DWORD_F2C24 = v39;
						++x_DWORD_F2C44;
						++x_DWORD_F2C50;
						sub_41BD3(2u);
						break;
					default:
						goto LABEL_70;
					}
				}
			}
		}
		result = *(x_WORD *)(v41 + 22);
	} while (result);
	return result;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// D951C: using guessed type __int16 x_WORD_D951C[];
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// F2C20: using guessed type int x_DWORD_F2C20;
// F2C24: using guessed type int x_DWORD_F2C24;
// F2C28: using guessed type int x_DWORD_F2C28;
// F2C2C: using guessed type int x_DWORD_F2C2C;
// F2C30: using guessed type int x_DWORD_F2C30;
// F2C34: using guessed type int x_DWORD_F2C34;
// F2C38: using guessed type int x_DWORD_F2C38;
// F2C3C: using guessed type int x_DWORD_F2C3C;
// F2C40: using guessed type int x_DWORD_F2C40;
// F2C44: using guessed type int x_DWORD_F2C44;
// F2C50: using guessed type int x_DWORD_F2C50;
// F2C54: using guessed type int x_DWORD_F2C54;
// F2C5C: using guessed type int x_DWORD_F2C5C;
// F2C60: using guessed type int x_DWORD_F2C60;
// F2C64: using guessed type int x_DWORD_F2C64;
// F2C68: using guessed type int x_DWORD_F2C68;
// F2C6C: using guessed type int x_DWORD_F2C6C;
// F2C74: using guessed type int x_DWORD_F2C74;
// F2C78: using guessed type int x_DWORD_F2C78;
// F2C7C: using guessed type int x_DWORD_F2C7C;
// F2C80: using guessed type int x_DWORD_F2C80;
// F2CA0: using guessed type int x_DWORD_F2CA0;
// F2CA4: using guessed type int x_DWORD_F2CA4;
// F2CA8: using guessed type int x_DWORD_F2CA8;
// F2CB0: using guessed type int x_DWORD_F2CB0;
// F2CC0: using guessed type __int16 x_WORD_F2CC0;
// F2CC2: using guessed type __int16 x_WORD_F2CC2;
// F2CC4: using guessed type __int16 x_WORD_F2CC4;
// F2CC6: using guessed type char x_BYTE_F2CC6;
// F6ED0: using guessed type int TMAPS00TAB_BEGIN_BUFFER;

//----- (00040950) --------------------------------------------------------
__int16 sub_40950(__int16 a1)
{
	int v1; // ebx
	int v2; // edx
	int v3; // esi
	int v4; // ebx
	char *v5; // edx
	int v6; // eax
	int v7; // edx
	int v8; // eax
	int v9; // ecx
	int v10; // edx
	__int16 result; // ax
	int v12; // eax
	char *v13; // esi
	int *v14; // edi
	Bit8u* v15; // edx
	int v16; // ecx
	int v17; // ebx
	int v18; // eax
	char v19; // [esp+0h] [ebp-52Ch]
	int v20; // [esp+500h] [ebp-2Ch]
	int v21; // [esp+504h] [ebp-28h]
	int *v22; // [esp+508h] [ebp-24h]
	int v23; // [esp+50Ch] [ebp-20h]
	int v24; // [esp+510h] [ebp-1Ch]
	int v25; // [esp+514h] [ebp-18h]
	int v26; // [esp+518h] [ebp-14h]
	int v27; // [esp+51Ch] [ebp-10h]
	char v28; // [esp+520h] [ebp-Ch]
	char v29; // [esp+524h] [ebp-8h]
	unsigned __int8 v30; // [esp+528h] [ebp-4h]

	v1 = a1 & 0x7FF;
	v2 = (x_DWORD)off_DBF50[v1] << 8;
	v26 = (x_DWORD_DB750[v1] << 8) / (unsigned __int16)x_DWORD_DE564;
	v3 = 0;
	v25 = v2 / (unsigned __int16)x_DWORD_DE564;
	v4 = 0;
	v29 = 0;
	v5 = &v19;
	v30 = 0;
	v6 = (unsigned __int16)x_DWORD_DE564;
	while (v6)
	{
		v28 = BYTE2(v3);
		*v5 = BYTE2(v3) - v29;
		v21 = BYTE2(v4);
		v20 = BYTE2(v4) - v30;
		v5 += 2;
		--v6;
		*(v5 - 1) = BYTE2(v4) - v30;
		v29 = v28;
		v30 = BYTE2(v4);
		v4 += v26;
		v3 += v25;
	}
	v7 = (-(x_DWORD_F2C54 * x_DWORD_F2CA8) >> 16) + x_DWORD_F2CB0;
	v8 = x_DWORD_F2C60 - (x_DWORD_F2C64 * x_DWORD_F2CA8 >> 16);
	v9 = v7 * v25 - v8 * v26;
	v10 = v25 * v8 + v26 * v7;
	v23 = ((unsigned __int16)x_WORD_F2CC0 << 15) - v9;
	v22 = (int *)x_DWORD_DE558;
	result = x_DWORD_DE568;
	v27 = -v10;
	v24 = (unsigned __int16)x_DWORD_DE568;
	if ((x_WORD)x_DWORD_DE568)
	{
		do
		{
			v12 = ((unsigned __int16)x_DWORD_DE564
				- (__CFSHL__((signed int)(unsigned __int16)x_DWORD_DE564 >> 31, 2)
					+ 4 * ((signed int)(unsigned __int16)x_DWORD_DE564 >> 31))) >> 2;
			v13 = &v19;
			v20 = v27 >> 16;
			v14 = v22;
			v21 = v23 >> 16;
			v15 = off_D41A8;
			BYTE1(v17) = BYTE2(v27);
			v16 = ((unsigned __int16)x_DWORD_DE564
				- (__CFSHL__((signed int)(unsigned __int16)x_DWORD_DE564 >> 31, 2)
					+ 4 * ((signed int)(unsigned __int16)x_DWORD_DE564 >> 31))) >> 2;
			LOBYTE(v17) = BYTE2(v23);
			v17 = (unsigned __int16)v17;
			do
			{
				LOBYTE(v12) = v15[v17];
				LOBYTE(v17) = *v13 + v17;
				BYTE1(v17) += v13[1];
				BYTE1(v12) = v15[v17];
				LOBYTE(v17) = v13[2] + v17;
				BYTE1(v17) += v13[3];
				v18 = v12 << 16;
				LOBYTE(v18) = v15[v17];
				LOBYTE(v17) = v13[4] + v17;
				BYTE1(v17) += v13[5];
				BYTE1(v18) = v15[v17];
				LOBYTE(v17) = v13[6] + v17;
				BYTE1(v17) += v13[7];
				v12 = __ROL4__(v18, 16);
				*v14 = v12;
				++v14;
				v13 += 8;
				--v16;
			} while (v16);
			v22 = (int *)((char *)v22 + x_DWORD_DE560);
			result = v25;
			--v24;
			v23 -= v26;
			v27 += v25;
		} while (v24);
	}
	return result;
}
// D41A8: using guessed type char *off_D41A8;
// DBF50: using guessed type void (/*__noreturn*/ *off_DBF50[2])();
// DE558: using guessed type int x_DWORD_DE558;
// DE560: using guessed type int x_DWORD_DE560;
// DE564: using guessed type int x_DWORD_DE564;
// DE568: using guessed type int x_DWORD_DE568;
// F2C54: using guessed type int x_DWORD_F2C54;
// F2C60: using guessed type int x_DWORD_F2C60;
// F2C64: using guessed type int x_DWORD_F2C64;
// F2CA8: using guessed type int x_DWORD_F2CA8;
// F2CB0: using guessed type int x_DWORD_F2CB0;
// F2CC0: using guessed type __int16 x_WORD_F2CC0;

//----- (00040BF0) --------------------------------------------------------
int sub_40BF0(int a1, int a2, int a3, int a4)
{
	int v4; // ebx
	int v5; // eax
	int v6; // ecx
	int v7; // edx
	int result; // eax

	v4 = a1;
	v5 = a2;
	LOWORD(v6) = a3;
	LOWORD(v7) = a4;
	if (x_WORD_180660_VGA_type_resolution & 1)
	{
		v4 = a1 >> 1;
		v5 = a2 >> 1;
		v6 = a3 >> 1;
		v7 = a4 >> 1;
	}
	x_DWORD_F2C58 = v4 + x_DWORD_18062C_resolution_x * v5;
	result = x_DWORD_F2C58 + (int)x_DWORD_180628b_screen_buffer;
	sub_BCD45(x_DWORD_F2C58 + (int)x_DWORD_180628b_screen_buffer, 0, x_DWORD_18062C_resolution_x, (unsigned __int16)v6, (unsigned __int16)v7);
	return result;
}
// F2C58: using guessed type int x_DWORD_F2C58;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 18062C: using guessed type int x_DWORD_18062C_resolution_x;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00040C50) --------------------------------------------------------
int sub_40C50(int a1)
{
	int v1; // eax
	int v2; // esi
	int v3; // eax
	unsigned __int16 v4; // bx
	int v5; // ST10_4
	int result; // eax

	v1 = 40 - a1;
	if (x_WORD_180660_VGA_type_resolution & 1)
	{
		v2 = x_DWORD_18062C_resolution_x * (5 * v1 / 2) + 4 * v1;
		v3 = (unsigned __int16)(5 * a1);
		v4 = 8 * a1;
	}
	else
	{
		v2 = x_DWORD_18062C_resolution_x * (12 * v1 / 2) + 8 * v1;
		v3 = (unsigned __int16)(12 * a1);
		v4 = 16 * a1;
	}
	v5 = v3;
	result = v2 + (int)x_DWORD_180628b_screen_buffer;
	x_DWORD_F2C58 = v2;
	sub_BCD45(v2 + (int)x_DWORD_180628b_screen_buffer, 0, x_DWORD_18062C_resolution_x, v4, v5);
	return result;
}
// F2C58: using guessed type int x_DWORD_F2C58;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 18062C: using guessed type int x_DWORD_18062C_resolution_x;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00040D10) --------------------------------------------------------
int /*__fastcall*/ sub_40D10(int a1)//fix vga
{
	int v1; // ebx
	signed int v2; // ecx
	x_BYTE *v3; // esi
	int *v4; // edi
	signed int v5; // ecx
	x_BYTE *v6; // esi
	int *v7; // edi
	signed int v8; // ecx
	int *v9; // edi
	x_BYTE *v10; // esi
	signed int v11; // ecx
	int *v12; // edi
	x_BYTE *v13; // esi
	signed int v14; // ecx
	int *v15; // edi
	x_BYTE *v16; // esi
	signed int v17; // ecx
	int *v18; // edi
	x_BYTE *v19; // esi
	signed int v20; // ecx
	int *v21; // edi
	x_BYTE *v22; // esi
	signed int v23; // ecx
	int *v24; // edi
	x_BYTE *v25; // esi
	int result; // eax
	signed int v27; // [esp+4h] [ebp-10h]
	int v28; // [esp+8h] [ebp-Ch]
	int v29; // [esp+Ch] [ebp-8h]
	int *v30; // [esp+10h] [ebp-4h]

	//__outx_WORD(0x3CEu, 0xFF08u);
	HIWORD(v1) = 0;
	v30 = (int *)&loc_A0000_vga_buffer;
	v28 = (int)x_DWORD_180628b_screen_buffer;
	v27 = 200;
	v29 = (Bit8u)x_DWORD_E9C3C;
	while (v27)
	{
		v2 = 10;
		v3 = (x_BYTE *)v28;
		v4 = v30;
		//__outx_WORD(0x3C4u, 0x102u);
		do
		{
			LOBYTE(a1) = v3[8];
			LOBYTE(v1) = v3[24];
			BYTE1(a1) = v3[12];
			BYTE1(v1) = v3[28];
			a1 = __ROL4__(a1, 16);
			v1 = __ROL4__(v1, 16);
			LOBYTE(a1) = *v3;
			LOBYTE(v1) = v3[16];
			BYTE1(a1) = v3[4];
			BYTE1(v1) = v3[20];
			*v4 = a1;
			v4[1] = v1;
			v3 += 32;
			v4 += 2;
			--v2;
		} while (v2);
		v5 = 10;
		v6 = (x_BYTE *)v29;
		v7 = v30 + 20;
		do
		{
			LOBYTE(a1) = v6[8];
			LOBYTE(v1) = v6[24];
			BYTE1(a1) = v6[12];
			BYTE1(v1) = v6[28];
			a1 = __ROL4__(a1, 16);
			v1 = __ROL4__(v1, 16);
			LOBYTE(a1) = *v6;
			LOBYTE(v1) = v6[16];
			BYTE1(a1) = v6[4];
			BYTE1(v1) = v6[20];
			*v7 = a1;
			v7[1] = v1;
			v6 += 32;
			v7 += 2;
			--v5;
		} while (v5);
		v8 = 10;
		v9 = v30;
		v10 = (x_BYTE *)(v28 + 1);
		//__outx_WORD(0x3C4u, 0x202u);
		do
		{
			LOBYTE(a1) = v10[8];
			LOBYTE(v1) = v10[24];
			BYTE1(a1) = v10[12];
			BYTE1(v1) = v10[28];
			a1 = __ROL4__(a1, 16);
			v1 = __ROL4__(v1, 16);
			LOBYTE(a1) = *v10;
			LOBYTE(v1) = v10[16];
			BYTE1(a1) = v10[4];
			BYTE1(v1) = v10[20];
			*v9 = a1;
			v9[1] = v1;
			v10 += 32;
			v9 += 2;
			--v8;
		} while (v8);
		v11 = 10;
		v12 = v30 + 20;
		v13 = (x_BYTE *)(v29 + 1);
		do
		{
			LOBYTE(a1) = v13[8];
			LOBYTE(v1) = v13[24];
			BYTE1(a1) = v13[12];
			BYTE1(v1) = v13[28];
			a1 = __ROL4__(a1, 16);
			v1 = __ROL4__(v1, 16);
			LOBYTE(a1) = *v13;
			LOBYTE(v1) = v13[16];
			BYTE1(a1) = v13[4];
			BYTE1(v1) = v13[20];
			*v12 = a1;
			v12[1] = v1;
			v13 += 32;
			v12 += 2;
			--v11;
		} while (v11);
		v14 = 10;
		v15 = v30;
		v16 = (x_BYTE *)(v28 + 2);
		//__outx_WORD(0x3C4u, 0x402u);
		do
		{
			LOBYTE(a1) = v16[8];
			LOBYTE(v1) = v16[24];
			BYTE1(a1) = v16[12];
			BYTE1(v1) = v16[28];
			a1 = __ROL4__(a1, 16);
			v1 = __ROL4__(v1, 16);
			LOBYTE(a1) = *v16;
			LOBYTE(v1) = v16[16];
			BYTE1(a1) = v16[4];
			BYTE1(v1) = v16[20];
			*v15 = a1;
			v15[1] = v1;
			v16 += 32;
			v15 += 2;
			--v14;
		} while (v14);
		v17 = 10;
		v18 = v30 + 20;
		v19 = (x_BYTE *)(v29 + 2);
		do
		{
			LOBYTE(a1) = v19[8];
			LOBYTE(v1) = v19[24];
			BYTE1(a1) = v19[12];
			BYTE1(v1) = v19[28];
			a1 = __ROL4__(a1, 16);
			v1 = __ROL4__(v1, 16);
			LOBYTE(a1) = *v19;
			LOBYTE(v1) = v19[16];
			BYTE1(a1) = v19[4];
			BYTE1(v1) = v19[20];
			*v18 = a1;
			v18[1] = v1;
			v19 += 32;
			v18 += 2;
			--v17;
		} while (v17);
		v20 = 10;
		v21 = v30;
		v22 = (x_BYTE *)(v28 + 3);
		//__outx_WORD(0x3C4u, 0x802u);
		do
		{
			LOBYTE(a1) = v22[8];
			LOBYTE(v1) = v22[24];
			BYTE1(a1) = v22[12];
			BYTE1(v1) = v22[28];
			a1 = __ROL4__(a1, 16);
			v1 = __ROL4__(v1, 16);
			LOBYTE(a1) = *v22;
			LOBYTE(v1) = v22[16];
			BYTE1(a1) = v22[4];
			BYTE1(v1) = v22[20];
			*v21 = a1;
			v21[1] = v1;
			v22 += 32;
			v21 += 2;
			--v20;
		} while (v20);
		v23 = 10;
		v24 = v30 + 20;
		v25 = (x_BYTE *)(v29 + 3);
		do
		{
			LOBYTE(a1) = v25[8];
			LOBYTE(v1) = v25[24];
			BYTE1(a1) = v25[12];
			BYTE1(v1) = v25[28];
			a1 = __ROL4__(a1, 16);
			v1 = __ROL4__(v1, 16);
			LOBYTE(a1) = *v25;
			LOBYTE(v1) = v25[16];
			BYTE1(a1) = v25[4];
			BYTE1(v1) = v25[20];
			*v24 = a1;
			v24[1] = v1;
			v25 += 32;
			v24 += 2;
			--v23;
		} while (v23);
		a1 = v27 - 1;
		v28 += 320;
		v29 += 320;
		v30 += 40;
		--v27;
	}
	result = 0;
	memset((void *)x_DWORD_180628b_screen_buffer, 0, 0xFA00u);
	return result;
}
// E9C3C: using guessed type int x_DWORD_E9C3C;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;

//----- (00040F80) --------------------------------------------------------
void sub_40F80()
{
	int v0; // eax
	signed int v1; // ecx
	x_BYTE *v2; // esi
	x_BYTE *v3; // edi
	int v4; // edx
	int v5; // ebx
	int v6; // eax
	signed int v7; // ecx
	x_BYTE *v8; // esi
	x_BYTE *v9; // edi
	int v10; // edx
	int v11; // ebx
	char v12; // bl
	signed int v13; // [esp+0h] [ebp-10h]
	int i; // [esp+4h] [ebp-Ch]
	int v15; // [esp+8h] [ebp-8h]
	int v16; // [esp+8h] [ebp-8h]
	int v17; // [esp+Ch] [ebp-4h]
	int v18; // [esp+Ch] [ebp-4h]

	if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8592) == 2 && !x_BYTE_D478C)
	{
		v13 = (signed int)(unsigned __int16)x_DWORD_DE564 >> 2;
		v15 = (Bit8u)x_DWORD_E9C3C;
		v17 = x_DWORD_DE558;
		v0 = (unsigned __int16)x_DWORD_DE568 / 2;
		for (i = (unsigned __int16)x_DWORD_DE568 / 2; i; i--)
		{
			v1 = v13;
			v2 = (x_BYTE *)v15;
			v3 = (x_BYTE *)v17;
			v4 = 0;
			v5 = 0;
			do
			{
				LOBYTE(v5) = v2[2];
				LOBYTE(v4) = v3[2];
				LOBYTE(v0) = x_BYTE_F0520[v4] + x_BYTE_F0620[v5];
				LOBYTE(v5) = v2[3];
				LOBYTE(v4) = v3[3];
				BYTE1(v0) = x_BYTE_F0920[v4] + x_BYTE_F0220[v5];
				v0 <<= 16;
				LOBYTE(v5) = *v2;
				LOBYTE(v4) = *v3;
				LOBYTE(v0) = x_BYTE_F0520[v4] + x_BYTE_F0620[v5];
				LOBYTE(v5) = v2[1];
				LOBYTE(v4) = v3[1];
				BYTE1(v0) = x_BYTE_F0920[v4] + x_BYTE_F0220[v5];
				*(x_DWORD *)v3 = v0;
				v3 += 4;
				v2 += 4;
				--v1;
			} while (v1);
			HIWORD(v6) = HIWORD(x_DWORD_DE560);
			v7 = v13;
			v16 = x_DWORD_DE560 + v15;
			v18 = x_DWORD_DE560 + v17;
			v8 = (x_BYTE *)v16;
			v9 = (x_BYTE *)v18;
			v10 = 0;
			v11 = 0;
			do
			{
				LOBYTE(v11) = v8[2];
				LOBYTE(v10) = v9[2];
				LOBYTE(v6) = x_BYTE_F0820[v10] + x_BYTE_F0320[v11];
				LOBYTE(v11) = v8[3];
				LOBYTE(v10) = v9[3];
				BYTE1(v6) = x_BYTE_F0720[v10] + x_BYTE_F0420[v11];
				v6 <<= 16;
				LOBYTE(v11) = *v8;
				LOBYTE(v10) = *v9;
				LOBYTE(v6) = x_BYTE_F0820[v10] + x_BYTE_F0320[v11];
				LOBYTE(v11) = v8[1];
				LOBYTE(v10) = v9[1];
				BYTE1(v6) = x_BYTE_F0720[v10] + x_BYTE_F0420[v11];
				*(x_DWORD *)v9 = v6;
				v9 += 4;
				v8 += 4;
				--v7;
			} while (v7);
			HIWORD(v0) = HIWORD(x_DWORD_DE560);
			v15 = x_DWORD_DE560 + v16;
			v17 = x_DWORD_DE560 + v18;
		}
	}
	v12 = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8592);
	if (v12 == 1)
	{
		sub_40D10((int)x_D41A0_BYTEARRAY_0);
	}
	else if (x_WORD_180660_VGA_type_resolution & 1)
	{
		if (x_BYTE_D478C)
		{
			sub_BD2CB((int)&unk_F0A20);
		}
		else if (x_WORD_180660_VGA_type_resolution & 1)
		{
			sub_90478_VGA_Blit320();
		}
		else
		{
			sub_75200_VGA_Blit640(480);
		}
	}
	else if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8595) && v12)
	{
		sub_BD3DD();
	}
	else if (x_BYTE_D478C)
	{
		sub_BD1B6((int)&unk_F0A20);
	}
	else if (x_WORD_180660_VGA_type_resolution & 1)
	{
		sub_90478_VGA_Blit320();
	}
	else
	{
		sub_75200_VGA_Blit640(480);
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D478C: using guessed type char x_BYTE_D478C;
// DE558: using guessed type int x_DWORD_DE558;
// DE560: using guessed type int x_DWORD_DE560;
// DE564: using guessed type int x_DWORD_DE564;
// DE568: using guessed type int x_DWORD_DE568;
// E9C3C: using guessed type int x_DWORD_E9C3C;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (000411A0) --------------------------------------------------------
char sub_411A0(int a1, int a2, int a3, __int16 a4, signed int a5, int a6, __int16 a7, int a8)
{
	unsigned __int16 v8; // ax
	int v9; // ecx
	int v10; // ebx
	int v11; // edx
	int v12; // ecx
	int v13; // ebx
	int v14; // edx
	int v15; // ecx
	int v16; // ebx
	int v17; // edx
	int v18; // ecx
	int v19; // ebx
	int v20; // edx
	int v21; // esi
	int v22; // edx
	int v23; // ebx
	void(/*__noreturn*/ *v24)(); // edx
	int v25; // ebx
	int v26; // edi
	char result; // al
	int v28; // ebx
	void(/*__noreturn*/ *v29)(); // edx
	int v30; // ebx
	int v31; // edi
	int v32; // ST2C_4
	Bit8u* v33; // edx
	__int64 v34; // rax
	x_BYTE *v35; // edi
	int v36; // eax
	x_BYTE *v37; // esi
	signed int v38; // ecx
	unsigned __int16 v39; // bx
	unsigned __int16 v40; // dx
	unsigned __int16 v41; // bx
	unsigned __int16 v42; // dx
	x_BYTE *v43; // edi
	int v44; // esi
	int v45; // ecx
	int v46; // eax
	int v47; // ebx
	int v48; // edx
	int v49; // [esp+0h] [ebp-1Ch]
	int v50; // [esp+4h] [ebp-18h]
	signed int v51; // [esp+8h] [ebp-14h]
	char v52; // [esp+Ch] [ebp-10h]
	int v53; // [esp+14h] [ebp-8h]
	int i; // [esp+18h] [ebp-4h]
	int v55; // [esp+34h] [ebp+18h]
	int v56; // [esp+38h] [ebp+1Ch]

	LOBYTE(v8) = BYTE1(a2);
	HIBYTE(v8) = BYTE1(a3);
	if ((signed int)(unsigned __int8)a2 < 128)
		LOBYTE(v8) = BYTE1(a2) - 1;
	if ((signed int)(unsigned __int8)a3 < 128)
		HIBYTE(v8) = BYTE1(a3) - 1;
	v9 = x_BYTE_11B4E0[v8];
	LOBYTE(v8) = v8 + 2;
	v10 = v9;
	v11 = v9;
	v12 = x_BYTE_11B4E0[v8];
	HIBYTE(v8) += 2;
	v13 = v10 - v12;
	v14 = v12 + v11;
	v15 = x_BYTE_11B4E0[v8];
	LOBYTE(v8) = v8 - 2;
	v16 = v13 - v15;
	v17 = v14 - v15;
	v18 = x_BYTE_11B4E0[v8];
	v19 = 2 * (v18 + v16);
	v20 = 2 * (v17 - v18);
	if (v19 <= 100)
	{
		if (v19 < -100)
			v19 = -100;
	}
	else
	{
		v19 = 100;
	}
	if (v20 <= 100)
	{
		if (v20 < -100)
			v20 = -100;
	}
	else
	{
		v20 = 100;
	}
	v21 = a4 & 0x7FF;
	x_DWORD_D4794 += (v19 - x_DWORD_D4794) >> 3;
	x_DWORD_D4798 += (v20 - x_DWORD_D4798) >> 3;
	v55 = x_DWORD_D4794 + a2;
	v56 = x_DWORD_D4798 + a3;
	if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8595) && *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8592) && x_DWORD_18062C_resolution_x == 640)
	{
		sub_BCD45(
			(int)x_DWORD_180628b_screen_buffer,
			0,
			2 * x_DWORD_18062C_resolution_x,
			(unsigned __int16)(x_DWORD_18062C_resolution_x / 2 - 8),
			(unsigned __int16)(x_DWORD_180624_resolution_y / 2 - 40));
		v22 = x_DWORD_DB750[v21];
		x_DWORD_D4790 = 20;
		v23 = 5 * v22;
		v24 = off_DBF50[v21];
		x_DWORD_D4324 = -5;
		v25 = 4 * v23 >> 16;
		v26 = 20 * (signed int)v24 >> 16;
		sub_3C080(v25, v21, v55 - v26, v56 - v25, v21, a5, a6, a7, a8);
		sub_BCD45((int)x_DWORD_180628b_screen_buffer + x_DWORD_18062C_resolution_x / 2, 0, 0, 0, 0);
		x_DWORD_D4324 = 5;
		sub_3C080(v56 + v25, v21, v55 + v26, v56 + v25, v21, a5, a6, a7, a8);
		result = x_DWORD_18062C_resolution_x;
		x_DWORD_D4324 = 0;
		sub_BCD45((int)x_DWORD_180628b_screen_buffer, 0, x_DWORD_18062C_resolution_x, (unsigned __int16)x_DWORD_18062C_resolution_x, (unsigned __int16)x_DWORD_180624_resolution_y);
	}
	else if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8592) != 1 || *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8595))
	{
		v52 = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8593);
		if (x_WORD_180660_VGA_type_resolution == 1)
		{
			v33 = x_D41A0_BYTEARRAY_0 + 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
			if (!*(x_BYTE *)(v33 + 12221))
			{
				if (x_D41A0_BYTEARRAY_4[34])
				{
					if (x_DWORD_E9C3C)
					{
						if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8589) == 40)
						{
							v34 = *(signed __int16 *)(x_DWORD_EA3E4[*(unsigned __int16 *)(v33 + 11240)] + 130);
							if ((signed int)((HIDWORD(v34) ^ v34) - HIDWORD(v34)) > 80)
								*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8593) = 1;
						}
					}
				}
			}
		}
		if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8625) && *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8593) && x_DWORD_E9C3C)
		{
			v35 = (x_BYTE *)x_DWORD_DE558;
			sub_BCD45((int)x_DWORD_E9C3C, 0, 0, 0, 0);
			sub_3C080(v55, v21, v55, v56, v21, a5, a6, a7, a8);
			sub_BCD45((int)v35, 0, 0, 0, 0);
			v51 = (signed int)(unsigned __int16)x_DWORD_DE564 >> 2;
			v49 = x_DWORD_DE560 - (unsigned __int16)x_DWORD_DE564;
			v50 = (unsigned __int16)x_DWORD_DE568;
			HIWORD(v36) = HIWORD(x_D41A0_BYTEARRAY_0);
			if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8593) != 1)
			{
				v37 = (x_BYTE *)x_DWORD_E9C3C;
				goto LABEL_33;
			}
			v37 = (x_BYTE *)x_DWORD_E9C3C;
			v38 = (signed int)(unsigned __int16)x_DWORD_DE564 >> 2;
			LOBYTE(v39) = *(x_BYTE *)(x_DWORD_E9C3C + 2);
			HIBYTE(v39) = v35[2];
			LOBYTE(v40) = *(x_BYTE *)(x_DWORD_E9C3C + 3);
			LOBYTE(v36) = x_BYTE_FAEE0[v39];
			HIBYTE(v40) = v35[3];
			BYTE1(v36) = x_BYTE_FAEE0[v40];
			v36 <<= 16;
			LOBYTE(v39) = *(x_BYTE *)x_DWORD_E9C3C;
			HIBYTE(v39) = *v35;
			LOBYTE(v40) = *(x_BYTE *)(x_DWORD_E9C3C + 1);
			LOBYTE(v36) = x_BYTE_FAEE0[v39];
			HIBYTE(v40) = v35[1];
			for (BYTE1(v36) = x_BYTE_FAEE0[v40]; ; BYTE1(v36) = x_BYTE_FAEE0[v42])
			{
				*(x_DWORD *)v35 = v36;
				v35 += 4;
				v37 += 4;
				if (!--v38)
				{
					HIWORD(v36) = HIWORD(v49);
					v37 += v49;
					v35 += v49;
					if (!--v50)
						goto LABEL_44;
				LABEL_33:
					v38 = v51;
				}
				HIBYTE(v41) = v37[2];
				LOBYTE(v41) = v35[2];
				HIBYTE(v42) = v37[3];
				LOBYTE(v36) = x_BYTE_FAEE0[v41];
				LOBYTE(v42) = v35[3];
				BYTE1(v36) = x_BYTE_FAEE0[v42];
				v36 <<= 16;
				HIBYTE(v41) = *v37;
				LOBYTE(v41) = *v35;
				HIBYTE(v42) = v37[1];
				LOBYTE(v36) = x_BYTE_FAEE0[v41];
				LOBYTE(v42) = v35[1];
			}
		}
		sub_3C080(v56, v21, v55, v56, v21, a5, a6, a7, a8);
		if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8594))
		{
			v53 = x_DWORD_DE558;
			for (i = (unsigned __int16)x_DWORD_DE568 - 1; i; i--)
			{
				v43 = (x_BYTE *)v53;
				v44 = x_DWORD_DE560;
				v45 = (unsigned __int16)x_DWORD_DE564 - 1;
				HIWORD(v46) = 0;
				HIWORD(v47) = 0;
				HIWORD(v48) = 0;
				do
				{
					LOBYTE(v46) = *v43;
					LOBYTE(v47) = v43[1];
					BYTE1(v46) = v43[v44];
					LOBYTE(v48) = x_BYTE_FAEE0[v46];
					BYTE1(v47) = v43[v44 + 1];
					BYTE1(v48) = x_BYTE_FAEE0[v47];
					*v43++ = x_BYTE_FAEE0[v48];
					--v45;
				} while (v45);
				v53 += x_DWORD_DE560;
			}
		}
	LABEL_44:
		result = (int)x_D41A0_BYTEARRAY_0;
		*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8593) = v52;
	}
	else
	{
		v28 = 5 * x_DWORD_DB750[v21];
		v29 = off_DBF50[v21];
		x_DWORD_D4790 = 20;
		x_DWORD_D4324 = x_DWORD_DE560 / 0x28u;
		v30 = 4 * v28 >> 16;
		v31 = 20 * (signed int)v29 >> 16;
		sub_3C080(v30, v21, v31 + v55, v30 + v56, v21, a5, a6, a7, a8);
		v32 = x_DWORD_DE558;
		sub_BCD45((int)x_DWORD_E9C3C, 0, 0, 0, 0);
		x_DWORD_D4324 = 0 - (x_DWORD_DE560 / 0x28u);
		result = sub_3C080(v30, v21, v55 - v31, v56 - v30, v21, a5, a6, a7, a8);
		sub_BCD45(v32, 0, 0, 0, 0);
		x_DWORD_D4324 = 0;
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// D4324: using guessed type int x_DWORD_D4324;
// D4790: using guessed type int x_DWORD_D4790;
// D4794: using guessed type int x_DWORD_D4794;
// D4798: using guessed type int x_DWORD_D4798;
// DBF50: using guessed type void (/*__noreturn*/ *off_DBF50[2])();
// DE558: using guessed type int x_DWORD_DE558;
// DE560: using guessed type int x_DWORD_DE560;
// DE564: using guessed type int x_DWORD_DE564;
// DE568: using guessed type int x_DWORD_DE568;
// E9C3C: using guessed type int x_DWORD_E9C3C;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// 180624: using guessed type int x_DWORD_180624_resolution_y;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 18062C: using guessed type int x_DWORD_18062C_resolution_x;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (000417A0) --------------------------------------------------------
__int16 sub_417A0_install_pal_and_mouse_minmax()
{
	sub_90810();
	sub_41A90_VGA_pallette_install(*xadatapald0dat2.var28_begin_buffer);
	return sub_6EF10_set_mouse_minmax(0, 640, 0, 400);
}
// EA3D8: using guessed type int *xadatapald0dat2.var28_begin_buffer;

//----- (000417D0) --------------------------------------------------------
__int16 sub_417D0_install_pal_and_mouse_minmax2()
{
	sub_906B4();
	sub_41A90_VGA_pallette_install(*xadatapald0dat2.var28_begin_buffer);
	return sub_6EF10_set_mouse_minmax(0, 640, 0, 800);
}
// EA3D8: using guessed type int *xadatapald0dat2.var28_begin_buffer;

void sub_41A90_VGA_pallette_install(Bit8u* buffer)//222a90
{
	//354f24 - 000000 00002a 002a00 002a2a 2a0000
	//debug
	//loadfromsnapshot((char*)"0160-00222A90-x", a1, 0x1a7358, 0x300);//4c
	//loadfromsnapshot((char*)"0160-00222A90-x", a1, 0x3aa0a4, 0x300);//4c
	//debug
	VGA_Set_pallette(buffer);
}
//----- (00041A90) --------------------------------------------------------
/*char sub_41A90_VGA_pallette_install_orig(unsigned __int8 *a1)//insgtalace palety viz:http://www.hoschl.cz/cyril/voxel5.c
{
  char result; // al
  unsigned __int8 *v2; // ebx
  unsigned __int16 v3; // cx
  unsigned __int8 v4; // al
  unsigned __int8 *v5; // ebx
  unsigned __int8 v6; // al

  result = -1;
  v2 = a1;
  __outx_BYTE(0x3C6u, 0xFFu);
  v3 = 0;
  while ( v3 < 0x100u )
  {
	__outx_BYTE(0x3C8u, v3);
	v4 = *v2;
	v5 = v2 + 1;
	__outx_BYTE(0x3C9u, v4);
	v6 = *v5++;
	__outx_BYTE(0x3C9u, v6);
	++v3;
	result = *v5;
	v2 = v5 + 1;
	__outx_BYTE(0x3C9u, result);
  }
  if ( x_BYTE_E12EC )
	result = sub_75A10(2, a1);//256a10
  return result;
}
// E12EC: using guessed type char x_BYTE_E12EC;*/

//----- (00041AF0) --------------------------------------------------------
void sub_41AF0()
{
	//char result; // al
	unsigned __int8 *v1; // ST00_4

	if (!x_BYTE_D47D9)
	{
		//result = (int)x_D41A0_BYTEARRAY_0;
		if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8592))
		{
			if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8595) && x_DWORD_DE560 == 640)
				sub_75C50();
			x_BYTE_D47D8 = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8592);
			sub_417A0_install_pal_and_mouse_minmax();
			v1 = *xadatapald0dat2.var28_begin_buffer;
			*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8592) = 0;
			sub_41A90_VGA_pallette_install(v1);
		}
	}
	++x_BYTE_D47D9;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D47D8: using guessed type char x_BYTE_D47D8;
// D47D9: using guessed type char x_BYTE_D47D9;
// DE560: using guessed type int x_DWORD_DE560;
// EA3D8: using guessed type int *xadatapald0dat2.var28_begin_buffer;

//----- (00041B60) --------------------------------------------------------
char sub_41B60()
{
	char v0; // dl
	char result; // al

	if (x_BYTE_D47D9 == 1)
	{
		v0 = x_BYTE_D47D8;
		*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8592) = x_BYTE_D47D8;
		result = v0;
		if ((unsigned __int8)v0 >= 1u && (unsigned __int8)v0 <= 1u)
			result = sub_417D0_install_pal_and_mouse_minmax2();
		x_BYTE_D47D8 = 0;
	}
	if (x_BYTE_D47D9)
		--x_BYTE_D47D9;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D47D8: using guessed type char x_BYTE_D47D8;
// D47D9: using guessed type char x_BYTE_D47D9;

//----- (00041BC0) --------------------------------------------------------
__int64 sub_41BC0()
{
	__int64 result; // rax

	BYTE1(result) = 0;
	x_BYTE_D47D9 = 0;
	x_BYTE_D47D8 = 0;
	return result;
}
// D47D8: using guessed type char x_BYTE_D47D8;
// D47D9: using guessed type char x_BYTE_D47D9;

//----- (00041BD3) --------------------------------------------------------
__int16 sub_41BD3(unsigned int a1)
{
	int v1; // eax
	char *v2; // ebx
	x_DWORD *v3; // esi
	x_BYTE *v4; // edi
	int v5; // ecx
	char v6; // cf
	int v7; // ecx
	int v8; // ecx
	char v9; // al
	char v10; // al
	char v11; // al
	char v12; // al
	int v13; // eax
	x_BYTE *v14; // ebx
	x_DWORD *v15; // esi
	x_BYTE *v16; // edi
	int v17; // ecx
	x_BYTE *v18; // ebx
	x_DWORD *v19; // esi
	x_BYTE *v20; // edi
	int v21; // eax
	int v22; // ecx
	x_BYTE *v23; // ebx
	x_DWORD *v24; // esi
	x_BYTE *v25; // edi
	int v26; // eax
	int v27; // ecx
	x_BYTE *v28; // ebx
	x_DWORD *v29; // esi
	x_BYTE *v30; // edi
	int v31; // eax
	int v32; // ecx
	int v33; // eax
	x_BYTE *v34; // ebx
	x_DWORD *v35; // esi
	x_BYTE *v36; // edi
	int v37; // ecx
	int v38; // edx
	x_BYTE *v39; // ebx
	x_DWORD *v40; // esi
	x_BYTE *v41; // edi
	int v42; // eax
	int v43; // ecx
	int v44; // edx
	x_BYTE *v45; // ebx
	x_DWORD *v46; // esi
	x_BYTE *v47; // edi
	int v48; // eax
	int v49; // ecx
	int v50; // ST4C_4
	char *v51; // ebx
	x_BYTE *v52; // edx
	x_DWORD *v53; // esi
	char *v54; // edi
	int v55; // ecx
	int v56; // ecx
	int v57; // ecx
	char v58; // al
	char v59; // al
	char v60; // al
	char v61; // al
	x_BYTE *v62; // ebx
	int v63; // eax
	x_BYTE *v64; // edx
	x_DWORD *v65; // esi
	x_DWORD *v66; // edi
	int v67; // ecx
	x_BYTE *v68; // ebx
	x_BYTE *v69; // edx
	x_DWORD *v70; // esi
	x_DWORD *v71; // edi
	int v72; // eax
	int v73; // ecx
	x_BYTE *v74; // ebx
	x_BYTE *v75; // edx
	x_DWORD *v76; // esi
	x_DWORD *v77; // edi
	int v78; // eax
	int v79; // ecx
	x_BYTE *v80; // ebx
	x_BYTE *v81; // edx
	x_DWORD *v82; // esi
	x_DWORD *v83; // edi
	int v84; // eax
	int v85; // ecx
	x_BYTE *v86; // ebx
	int v87; // eax
	x_BYTE *v88; // edx
	x_DWORD *v89; // esi
	x_DWORD *v90; // edi
	int v91; // ecx
	int v92; // ecx
	x_BYTE *v93; // ebx
	x_BYTE *v94; // edx
	int v95; // eax
	x_DWORD *v96; // esi
	x_DWORD *v97; // edi
	int v98; // ecx
	x_BYTE *v99; // ebx
	x_BYTE *v100; // edx
	int v101; // eax
	x_DWORD *v102; // esi
	x_DWORD *v103; // edi
	char *v104; // ebx
	int v105; // eax
	x_BYTE *v106; // edx
	x_DWORD *v107; // esi
	x_DWORD *v108; // edi
	int v109; // ecx
	char v110; // al
	char v111; // al
	int v112; // eax
	int v113; // edx
	int v114; // edx
	signed int v116; // [esp+10h] [ebp-54h]
	x_DWORD *v117; // [esp+14h] [ebp-50h]
	x_DWORD *v118; // [esp+14h] [ebp-50h]
	x_DWORD *v119; // [esp+14h] [ebp-50h]
	x_DWORD *v120; // [esp+14h] [ebp-50h]
	int v121; // [esp+1Ch] [ebp-48h]
	int v122; // [esp+20h] [ebp-44h]
	int v123; // [esp+20h] [ebp-44h]
	int v124; // [esp+24h] [ebp-40h]
	int v125; // [esp+24h] [ebp-40h]
	int i; // [esp+24h] [ebp-40h]
	int j; // [esp+24h] [ebp-40h]
	int k; // [esp+24h] [ebp-40h]
	int v129; // [esp+24h] [ebp-40h]
	int v130; // [esp+24h] [ebp-40h]
	int l; // [esp+28h] [ebp-3Ch]
	int v132; // [esp+28h] [ebp-3Ch]
	int v133; // [esp+28h] [ebp-3Ch]
	int v134; // [esp+34h] [ebp-30h]
	int v135; // [esp+34h] [ebp-30h]
	int v136; // [esp+38h] [ebp-2Ch]
	int v137; // [esp+38h] [ebp-2Ch]
	int v138; // [esp+3Ch] [ebp-28h]
	int v139; // [esp+3Ch] [ebp-28h]
	int v140; // [esp+3Ch] [ebp-28h]
	int v141; // [esp+3Ch] [ebp-28h]
	int v142; // [esp+3Ch] [ebp-28h]
	int v143; // [esp+3Ch] [ebp-28h]
	int v144; // [esp+3Ch] [ebp-28h]
	int v145; // [esp+3Ch] [ebp-28h]
	int v146; // [esp+3Ch] [ebp-28h]
	int v147; // [esp+3Ch] [ebp-28h]
	int v148; // [esp+3Ch] [ebp-28h]
	int v149; // [esp+3Ch] [ebp-28h]
	int v150; // [esp+3Ch] [ebp-28h]
	int v151; // [esp+3Ch] [ebp-28h]
	int v152; // [esp+3Ch] [ebp-28h]
	x_DWORD *v153; // [esp+40h] [ebp-24h]
	x_DWORD *v154; // [esp+40h] [ebp-24h]
	int v155; // [esp+40h] [ebp-24h]
	int v156; // [esp+44h] [ebp-20h]
	int v157; // [esp+48h] [ebp-1Ch]
	int v158; // [esp+48h] [ebp-1Ch]
	int v159; // [esp+4Ch] [ebp-18h]
	int v160; // [esp+50h] [ebp-14h]
	int v161; // [esp+50h] [ebp-14h]
	int *v162; // [esp+54h] [ebp-10h]
	x_DWORD *v163; // [esp+54h] [ebp-10h]
	x_DWORD *v164; // [esp+54h] [ebp-10h]
	x_DWORD *v165; // [esp+54h] [ebp-10h]
	int *v166; // [esp+54h] [ebp-10h]
	x_DWORD *v167; // [esp+54h] [ebp-10h]
	x_DWORD *v168; // [esp+54h] [ebp-10h]
	char *v169; // [esp+58h] [ebp-Ch]
	int v170; // [esp+5Ch] [ebp-8h]
	int v171; // [esp+5Ch] [ebp-8h]
	int v172; // [esp+60h] [ebp-4h]
	int v173; // [esp+60h] [ebp-4h]
	int v174; // [esp+60h] [ebp-4h]
	int v175; // [esp+60h] [ebp-4h]

	if (!x_BYTE_F2CC6)
	{
		if (a1 < 1)
		{
			if (a1)
				goto LABEL_126;
		}
		else
		{
			if (a1 <= 1)
			{
				x_DWORD_F2C30 -= ((x_DWORD_F2C64 * x_DWORD_F2C44 >> 1) + x_DWORD_F2C54 * x_DWORD_F2C50) >> 16;
				x_DWORD_F2C2C -= (x_DWORD_F2C64 * x_DWORD_F2C50 - (x_DWORD_F2C54 * x_DWORD_F2C44 >> 1)) >> 16;
				goto LABEL_126;
			}
			if (a1 != 2)
			{
			LABEL_126:
				LOWORD(v1) = x_DWORD_F2C98;
				if ((unsigned int)x_DWORD_F2C98 <= 7)
				{
					switch (x_DWORD_F2C98)
					{
					case 0:
						v1 = x_DWORD_F2C8C * x_DWORD_F2C44 >> 16;
						v156 = x_DWORD_F2C8C * x_DWORD_F2C44 >> 16;
						if (v156 <= 0)
							break;
						v1 = (x_DWORD_F2C50 << 16) / x_DWORD_F2C8C;
						v159 = (x_DWORD_F2C50 << 16) / x_DWORD_F2C8C;
						if (v159 <= 0)
							break;
						v135 = (x_DWORD_F2C38 << 16) / v159;
						if (a1 == 1)
						{
							x_DWORD_F2C48 = 0;
						}
						else
						{
							x_DWORD_F2C48 = (v159 - 1) * v135;
							v135 = -v135;
						}
						v160 = x_DWORD_F2CBC * x_DWORD_F2C50 / v159;
						v162 = (int *)(x_DWORD_E9C38_smalltit[45920]);
						v157 = x_DWORD_F2C30 << 16;
						v170 = x_DWORD_F2C2C - (x_DWORD_F2C9C * x_DWORD_F2C30 >> 16);
						if (x_DWORD_F2C2C - (x_DWORD_F2C9C * x_DWORD_F2C30 >> 16) >= x_DWORD_F2CA4)
							goto LABEL_136;
						v139 = x_DWORD_F2CA4 - v170;
						LOWORD(v1) = x_DWORD_F2CA4 - v170;
						v159 -= x_DWORD_F2CA4 - v170;
						if (v159 > 0)
						{
							x_DWORD_F2C48 += v139 * v135;
							v157 -= v139 * v160;
							v170 = x_DWORD_F2CA4;
						LABEL_136:
							v123 = x_DWORD_DE560 * v170 + x_DWORD_DE558;
							goto LABEL_137;
						}
						break;
					case 1:
						v1 = x_DWORD_F2CBC * x_DWORD_F2C44 >> 16;
						v156 = x_DWORD_F2CBC * x_DWORD_F2C44 >> 16;
						if (v156 <= 0)
							break;
						v1 = (x_DWORD_F2C50 << 16) / x_DWORD_F2CBC;
						v159 = (x_DWORD_F2C50 << 16) / x_DWORD_F2CBC;
						if (v159 <= 0)
							break;
						v135 = (x_DWORD_F2C38 << 16) / v159;
						if (a1 == 1)
						{
							x_DWORD_F2C48 = 0;
						}
						else
						{
							x_DWORD_F2C48 = (v159 - 1) * v135;
							v135 = -v135;
						}
						v161 = x_DWORD_F2C8C * x_DWORD_F2C50 / v159;
						v166 = (int *)(x_DWORD_E9C38_smalltit[45920]);
						v158 = x_DWORD_F2C2C << 16;
						v171 = x_DWORD_F2C30 - (x_DWORD_F2C9C * x_DWORD_F2C2C >> 16);
						if (x_DWORD_F2C30 - (x_DWORD_F2C9C * x_DWORD_F2C2C >> 16) < x_DWORD_F2CB4)
						{
							LOWORD(v1) = x_DWORD_F2C30 - ((unsigned int)(x_DWORD_F2C9C * x_DWORD_F2C2C) >> 16);
							if (v171 >= x_DWORD_F2CA4)
								goto LABEL_284;
						}
						else
						{
							v141 = v171 - x_DWORD_F2CB4;
							LOWORD(v1) = v171 - x_DWORD_F2CB4;
							v159 -= v171 - x_DWORD_F2CB4;
							if (v159 > 0)
							{
								x_DWORD_F2C48 += v141 * v135;
								v158 += v141 * v161;
								v171 = x_DWORD_F2CB4;
							LABEL_284:
								v123 = v171 + x_DWORD_DE558;
								goto LABEL_285;
							}
						}
						break;
					case 2:
						v1 = x_DWORD_F2C8C * x_DWORD_F2C44 >> 16;
						v156 = x_DWORD_F2C8C * x_DWORD_F2C44 >> 16;
						if (v156 <= 0)
							break;
						v1 = (x_DWORD_F2C50 << 16) / x_DWORD_F2C8C;
						v159 = (x_DWORD_F2C50 << 16) / x_DWORD_F2C8C;
						if (v159 <= 0)
							break;
						v135 = (x_DWORD_F2C38 << 16) / v159;
						if (a1 == 1)
						{
							x_DWORD_F2C48 = 0;
						}
						else
						{
							x_DWORD_F2C48 = (v159 - 1) * v135;
							v135 = -v135;
						}
						v160 = x_DWORD_F2CBC * x_DWORD_F2C50 / v159;
						v162 = (int *)(x_DWORD_E9C38_smalltit[45920]);
						v157 = x_DWORD_F2C2C << 16;
						v170 = x_DWORD_F2CB4 - x_DWORD_F2C30 - (x_DWORD_F2C9C * x_DWORD_F2C2C >> 16);
						if (v170 >= x_DWORD_F2CA4)
							goto LABEL_329;
						v147 = x_DWORD_F2CA4 - v170;
						LOWORD(v1) = x_DWORD_F2CA4 - v170;
						v159 -= x_DWORD_F2CA4 - v170;
						if (v159 <= 0)
							break;
						x_DWORD_F2C48 += v147 * v135;
						v157 -= v147 * v160;
						v170 = x_DWORD_F2CA4;
					LABEL_329:
						v123 = x_DWORD_F2CB4 + x_DWORD_DE558 - 1 - v170;
						goto LABEL_137;
					case 3:
						v1 = x_DWORD_F2CBC * x_DWORD_F2C44 >> 16;
						v156 = x_DWORD_F2CBC * x_DWORD_F2C44 >> 16;
						if (v156 <= 0)
							break;
						v1 = (x_DWORD_F2C50 << 16) / x_DWORD_F2CBC;
						v159 = (x_DWORD_F2C50 << 16) / x_DWORD_F2CBC;
						if (v159 <= 0)
							break;
						v135 = (x_DWORD_F2C38 << 16) / v159;
						if (a1 == 1)
						{
							x_DWORD_F2C48 = 0;
						}
						else
						{
							x_DWORD_F2C48 = (v159 - 1) * v135;
							v135 = -v135;
						}
						v161 = x_DWORD_F2C8C * x_DWORD_F2C50 / v159;
						v166 = (int *)(x_DWORD_E9C38_smalltit[45920]);
						v158 = (x_DWORD_F2CB8 - x_DWORD_F2C30) << 16;
						v171 = x_DWORD_F2C2C - (x_DWORD_F2C9C * (x_DWORD_F2CB8 - x_DWORD_F2C30) >> 16);
						if (x_DWORD_F2C2C - (x_DWORD_F2C9C * (x_DWORD_F2CB8 - x_DWORD_F2C30) >> 16) < x_DWORD_F2CB4)
						{
							LOWORD(v1) = x_DWORD_F2C2C - ((unsigned int)(x_DWORD_F2C9C * (x_DWORD_F2CB8 - x_DWORD_F2C30)) >> 16);
							if (v171 < x_DWORD_F2CA4)
								break;
						}
						else
						{
							v148 = v171 - x_DWORD_F2CB4;
							LOWORD(v1) = v171 - x_DWORD_F2CB4;
							v159 -= v171 - x_DWORD_F2CB4;
							if (v159 <= 0)
								break;
							x_DWORD_F2C48 += v148 * v135;
							v158 += v148 * v161;
							v171 = x_DWORD_F2CB4;
						}
						v123 = x_DWORD_F2CB8 + x_DWORD_DE560 * v171 - 1 + x_DWORD_DE558;
						goto LABEL_285;
					case 4:
						v1 = x_DWORD_F2C8C * x_DWORD_F2C44 >> 16;
						v156 = x_DWORD_F2C8C * x_DWORD_F2C44 >> 16;
						if (v156 <= 0)
							break;
						v1 = (x_DWORD_F2C50 << 16) / x_DWORD_F2C8C;
						v159 = (x_DWORD_F2C50 << 16) / x_DWORD_F2C8C;
						if (v159 <= 0)
							break;
						v135 = (x_DWORD_F2C38 << 16) / v159;
						if (a1 == 1)
						{
							x_DWORD_F2C48 = 0;
						}
						else
						{
							x_DWORD_F2C48 = (v159 - 1) * v135;
							v135 = -v135;
						}
						v160 = x_DWORD_F2CBC * x_DWORD_F2C50 / v159;
						v162 = (int *)(x_DWORD_E9C38_smalltit[45920]);
						v157 = (x_DWORD_F2CB8 - x_DWORD_F2C30) << 16;
						v170 = x_DWORD_F2CB4 - x_DWORD_F2C2C - (x_DWORD_F2C9C * (x_DWORD_F2CB8 - x_DWORD_F2C30) >> 16);
						if (v170 >= x_DWORD_F2CA4)
							goto LABEL_348;
						v149 = x_DWORD_F2CA4 - v170;
						LOWORD(v1) = x_DWORD_F2CA4 - v170;
						v159 -= x_DWORD_F2CA4 - v170;
						if (v159 <= 0)
							break;
						x_DWORD_F2C48 += v149 * v135;
						v157 -= v149 * v160;
						v170 = x_DWORD_F2CA4;
					LABEL_348:
						v123 = x_DWORD_F2CB8 + x_DWORD_DE558 + x_DWORD_DE560 * (x_DWORD_F2CB4 - v170 - 1) - 1;
						goto LABEL_137;
					case 5:
						v1 = x_DWORD_F2CBC * x_DWORD_F2C44 >> 16;
						v156 = x_DWORD_F2CBC * x_DWORD_F2C44 >> 16;
						if (v156 <= 0)
							break;
						v1 = (x_DWORD_F2C50 << 16) / x_DWORD_F2CBC;
						v159 = (x_DWORD_F2C50 << 16) / x_DWORD_F2CBC;
						if (v159 <= 0)
							break;
						v135 = (x_DWORD_F2C38 << 16) / v159;
						if (a1 == 1)
						{
							x_DWORD_F2C48 = 0;
						}
						else
						{
							x_DWORD_F2C48 = (v159 - 1) * v135;
							v135 = -v135;
						}
						v161 = x_DWORD_F2C8C * x_DWORD_F2C50 / v159;
						v166 = (int *)(x_DWORD_E9C38_smalltit[45920]);
						v158 = (x_DWORD_F2CB8 - x_DWORD_F2C2C) << 16;
						v113 = x_DWORD_F2C9C * (x_DWORD_F2CB8 - x_DWORD_F2C2C) >> 16;
						v171 = x_DWORD_F2CB4 - x_DWORD_F2C30 - v113;
						if (v171 < x_DWORD_F2CB4)
						{
							LOWORD(v1) = x_DWORD_F2CB4 - x_DWORD_F2C30 - v113;
							if (v171 < x_DWORD_F2CA4)
								break;
						}
						else
						{
							v150 = v171 - x_DWORD_F2CB4;
							LOWORD(v1) = v171 - x_DWORD_F2CB4;
							v159 -= v171 - x_DWORD_F2CB4;
							if (v159 <= 0)
								break;
							x_DWORD_F2C48 += v150 * v135;
							v158 += v150 * v161;
							v171 = x_DWORD_F2CB4;
						}
						v123 = (x_DWORD_F2CB8 - 1) * x_DWORD_DE560 + x_DWORD_F2CB4 + x_DWORD_DE558 - 1 - v171;
						goto LABEL_285;
					case 6:
						v1 = x_DWORD_F2C8C * x_DWORD_F2C44 >> 16;
						v156 = x_DWORD_F2C8C * x_DWORD_F2C44 >> 16;
						if (v156 <= 0)
							break;
						v1 = (x_DWORD_F2C50 << 16) / x_DWORD_F2C8C;
						v159 = (x_DWORD_F2C50 << 16) / x_DWORD_F2C8C;
						if (v159 <= 0)
							break;
						v135 = (x_DWORD_F2C38 << 16) / v159;
						if (a1 == 1)
						{
							x_DWORD_F2C48 = 0;
						}
						else
						{
							x_DWORD_F2C48 = (v159 - 1) * v135;
							v135 = -v135;
						}
						v160 = x_DWORD_F2CBC * x_DWORD_F2C50 / v159;
						v162 = (int *)(x_DWORD_E9C38_smalltit[45920]);
						v157 = (x_DWORD_F2CB8 - x_DWORD_F2C2C) << 16;
						v170 = x_DWORD_F2C30 - (x_DWORD_F2C9C * (x_DWORD_F2CB8 - x_DWORD_F2C2C) >> 16);
						if (x_DWORD_F2C30 - (x_DWORD_F2C9C * (x_DWORD_F2CB8 - x_DWORD_F2C2C) >> 16) >= x_DWORD_F2CA4)
							goto LABEL_367;
						v151 = x_DWORD_F2CA4 - v170;
						LOWORD(v1) = x_DWORD_F2CA4 - v170;
						v159 -= x_DWORD_F2CA4 - v170;
						if (v159 <= 0)
							break;
						x_DWORD_F2C48 += v151 * v135;
						v157 -= v151 * v160;
						v170 = x_DWORD_F2CA4;
					LABEL_367:
						v123 = x_DWORD_DE558 + x_DWORD_DE560 * (x_DWORD_F2CB8 - 1) + v170;
					LABEL_137:
						v140 = x_DWORD_F2CB4 - x_DWORD_F2CA4;
						if (v170 <= 0)
						{
							if (v159 > v140)
								v159 = x_DWORD_F2CB4 - x_DWORD_F2CA4;
						}
						else if (v170 + v159 > v140)
						{
							LOWORD(v1) = v140 - v170;
							v159 = v140 - v170;
							if (v140 - v170 <= 0)
								break;
						}
						v116 = 9999999;
						v124 = v159;
						while (2)
						{
							if (!v124)
								goto LABEL_154;
							v172 = v157 >> 16;
							if (v157 >> 16 >= 0)
							{
								*v162 = v172;
								v162[1] = v156;
								v162[2] = 0;
								v116 = 0;
							LABEL_151:
								if (v162[1] + *v162 > x_DWORD_F2CB8)
									v162[1] = x_DWORD_F2CB8 - *v162;
								v157 -= v160;
								v162 += 3;
								--v124;
								continue;
							}
							break;
						}
						v173 = -v172;
						*v162 = 0;
						v162[1] = v156 - v173;
						if (v162[1] > 0)
						{
							v162[2] = v173;
							if (v173 < v116)
								v116 = v173;
							goto LABEL_151;
						}
						v159 -= v124;
					LABEL_154:
						if (v170 + v159 > x_DWORD_F2C84)
						{
							if (x_DWORD_F2C84 - v170 <= 0)
							{
								v163 = (x_DWORD *)(x_DWORD_E9C38_smalltit[45920]);
								v117 = (x_DWORD *)(4 * (x_DWORD_F2C84 - v170) + x_DWORD_F2C88);
								v125 = v159;
							}
							else
							{
								v163 = (x_DWORD *)(12 * (x_DWORD_F2C84 - v170) + x_DWORD_E9C38_smalltit[45920]);
								v117 = (x_DWORD *)x_DWORD_F2C88;
								v125 = v170 + v159 - x_DWORD_F2C84;
							}
							while (v125)
							{
								if (*v163 + v163[1] > *v117)
								{
									if (*v163 >= *v117)
									{
										v159 -= v125;
										break;
									}
									v163[1] = *v117 - *v163;
								}
								v163 += 3;
								--v117;
								--v125;
							}
						}
						if (v170 < 0)
						{
							v118 = (x_DWORD *)(4 * (-1 - v170) + x_DWORD_E9C38_smalltit + 59360);
							v164 = (x_DWORD *)(x_DWORD_E9C38_smalltit[45920]);
							while (v170)
							{
								if (*v118 > *v164)
								{
									if (v164[1] + *v164 >= *v118)
									{
										v50 = *v118 - *v164;
										*v164 = *v118;
										v164[2] += v50;
										v164[1] -= v50;
									}
									else
									{
										v164[1] = 0;
									}
								}
								--v118;
								v164 += 3;
								++v170;
							}
						}
					LABEL_172:
						v137 = (x_DWORD_F2C34 << 16) / v156;
						x_DWORD_F2C4C = 0;
						if (x_DWORD_F2C34 < 0)
							x_DWORD_F2C4C -= v137 * (v156 - 1);
						LOWORD(v1) = v156 - v116;
						v132 = v156 - v116;
						if (v156 - v116 > 0)
						{
							if (v132 > x_DWORD_F2C90)
								v132 = x_DWORD_F2C90;
							x_DWORD_F2C4C += v137 * v116;
							v154 = (x_DWORD *)(x_DWORD_E9C38_smalltit[36960]);
							while (v132 >= 0)
							{
								v154[1] = x_DWORD_F2C4C >> 16;
								*v154 = v154[1] - *(v154 - 1);
								x_DWORD_F2C4C += v137;
								v154 += 2;
								--v132;
							}
							v165 = (x_DWORD *)(x_DWORD_E9C38_smalltit[45920]);
							LOWORD(v1) = v159;
							for (i = v159; i; i--)
							{
								v133 = v165[1];
								if (v133 > 0)
								{
									v169 = (char *)&unk_F0E20 + 12 * *v165;
									v155 = 8 * (v165[2] - v116) + x_DWORD_E9C38_smalltit[36960];
									v121 = x_DWORD_F2C40 * (x_DWORD_F2C48 >> 16) + x_DWORD_F2C28;
									if ((unsigned int)x_DWORD_F2C24 <= 8)
									{
										switch (x_DWORD_F2C24)
										{
										case 0:
											v51 = (char *)(*(x_DWORD *)(v155 + 4) + v121);
											v52 = (x_BYTE *)(*((x_DWORD *)v169 + 1) + v123);
											v53 = (x_DWORD *)(8 * (v165[2] - v116) + x_DWORD_E9C38_smalltit[36960]);
											v54 = (char *)&unk_F0E20 + 12 * *v165;
											v55 = v133 >> 1;
											if (!(v133 & 1))
											{
												v6 = v55 & 1;
												v56 = v133 >> 2;
												if (v6)
												{
													++v56;
													v53 = (x_DWORD *)(v155 - 8);
													v54 = v169 - 12;
													goto LABEL_197;
												}
												v53 = (x_DWORD *)(v155 + 8);
												v54 = v169 + 12;
												goto LABEL_191;
											}
											v57 = v55 + 2;
											v6 = v57 & 1;
											v56 = v57 >> 1;
											if (!v6)
											{
												v53 = (x_DWORD *)(v155 - 16);
												v54 = v169 - 24;
												goto LABEL_200;
											}
											while (1)
											{
												v59 = *v51;
												v51 += v53[2];
												if (v59)
													*v52 = v59;
												v52 += *((x_DWORD *)v54 + 3);
											LABEL_197:
												v60 = *v51;
												v51 += v53[4];
												if (v60)
													*v52 = v60;
												v52 += *((x_DWORD *)v54 + 6);
											LABEL_200:
												v61 = *v51;
												v51 += v53[6];
												if (v61)
													*v52 = v61;
												v52 += *((x_DWORD *)v54 + 9);
												v53 += 8;
												v54 += 48;
												if (!--v56)
													break;
											LABEL_191:
												v58 = *v51;
												v51 += *v53;
												if (v58)
													*v52 = v58;
												v52 += *(x_DWORD *)v54;
											}
											break;
										case 1:
											v62 = (x_BYTE *)(*(x_DWORD *)(v155 + 4) + v121);
											v63 = x_DWORD_F2C20;
											v64 = (x_BYTE *)(*((x_DWORD *)v169 + 1) + v123);
											v65 = (x_DWORD *)(8 * (v165[2] - v116) + x_DWORD_E9C38_smalltit[36960]);
											v66 = (x_DWORD *)((char *)&unk_F0E20 + 12 * *v165);
											v67 = v133 >> 1;
											if (!(v133 & 1))
											{
												v65 = (x_DWORD *)(v155 + 8);
												v66 = (x_DWORD*)(v169 + 12);
												goto LABEL_207;
											}
											++v67;
											while (1)
											{
												LOBYTE(v63) = *v62;
												v62 += v65[2];
												if ((x_BYTE)v63)
													*v64 = x_BYTE_F6EE0_tables[v63];
												v64 += v66[3];
												v65 += 4;
												v66 += 6;
												if (!--v67)
													break;
											LABEL_207:
												LOBYTE(v63) = *v62;
												v62 += *v65;
												if ((x_BYTE)v63)
													*v64 = x_BYTE_F6EE0_tables[v63];
												v64 += *v66;
											}
											break;
										case 2:
											v68 = (x_BYTE *)(*(x_DWORD *)(v155 + 4) + v121);
											v69 = (x_BYTE *)(*((x_DWORD *)v169 + 1) + v123);
											v70 = (x_DWORD *)(8 * (v165[2] - v116) + x_DWORD_E9C38_smalltit[36960]);
											v71 = (x_DWORD *)((char *)&unk_F0E20 + 12 * *v165);
											HIWORD(v72) = 0;
											v73 = v133 >> 1;
											if (!(v133 & 1))
											{
												v70 = (x_DWORD *)(v155 + 8);
												v71 = (x_DWORD*)(v169 + 12);
												goto LABEL_217;
											}
											++v73;
											while (1)
											{
												BYTE1(v72) = *v68;
												v68 += v70[2];
												if (BYTE1(v72))
												{
													LOBYTE(v72) = *v69;
													*v69 = x_BYTE_FAEE0[v72];
												}
												v69 += v71[3];
												v70 += 4;
												v71 += 6;
												if (!--v73)
													break;
											LABEL_217:
												BYTE1(v72) = *v68;
												v68 += *v70;
												if (BYTE1(v72))
												{
													LOBYTE(v72) = *v69;
													*v69 = x_BYTE_FAEE0[v72];
												}
												v69 += *v71;
											}
											break;
										case 3:
											v74 = (x_BYTE *)(*(x_DWORD *)(v155 + 4) + v121);
											v75 = (x_BYTE *)(*((x_DWORD *)v169 + 1) + v123);
											v76 = (x_DWORD *)(8 * (v165[2] - v116) + x_DWORD_E9C38_smalltit[36960]);
											v77 = (x_DWORD *)((char *)&unk_F0E20 + 12 * *v165);
											HIWORD(v78) = 0;
											v79 = v133 >> 1;
											if (!(v133 & 1))
											{
												v76 = (x_DWORD *)(v155 + 8);
												v77 = (x_DWORD*)(v169 + 12);
												goto LABEL_227;
											}
											++v79;
											while (1)
											{
												LOBYTE(v78) = *v74;
												v74 += v76[2];
												if ((x_BYTE)v78)
												{
													BYTE1(v78) = *v75;
													*v75 = x_BYTE_FAEE0[v78];
												}
												v75 += v77[3];
												v76 += 4;
												v77 += 6;
												if (!--v79)
													break;
											LABEL_227:
												LOBYTE(v78) = *v74;
												v74 += *v76;
												if ((x_BYTE)v78)
												{
													BYTE1(v78) = *v75;
													*v75 = x_BYTE_FAEE0[v78];
												}
												v75 += *v77;
											}
											break;
										case 4:
											v80 = (x_BYTE *)(*(x_DWORD *)(v155 + 4) + v121);
											HIWORD(v84) = HIWORD(x_DWORD_F2C3C);
											v81 = (x_BYTE *)(*((x_DWORD *)v169 + 1) + v123);
											v82 = (x_DWORD *)(8 * (v165[2] - v116) + x_DWORD_E9C38_smalltit[36960]);
											v83 = (x_DWORD *)((char *)&unk_F0E20 + 12 * *v165);
											BYTE1(v84) = x_DWORD_F2C3C;
											v85 = v133 >> 1;
											if (!(v133 & 1))
											{
												v82 = (x_DWORD *)(v155 + 8);
												v83 = (x_DWORD*)(v169 + 12);
												goto LABEL_237;
											}
											++v85;
											while (1)
											{
												LOBYTE(v84) = *v80;
												v80 += v82[2];
												if ((x_BYTE)v84)
													*v81 = x_BYTE_FAEE0[v84];
												v81 += v83[3];
												v82 += 4;
												v83 += 6;
												if (!--v85)
													break;
											LABEL_237:
												LOBYTE(v84) = *v80;
												v80 += *v82;
												if ((x_BYTE)v84)
													*v81 = x_BYTE_FAEE0[v84];
												v81 += *v83;
											}
											break;
										case 5:
											v86 = (x_BYTE *)(*(x_DWORD *)(v155 + 4) + v121);
											v87 = x_DWORD_F2C3C;
											v88 = (x_BYTE *)(*((x_DWORD *)v169 + 1) + v123);
											v89 = (x_DWORD *)(8 * (v165[2] - v116) + x_DWORD_E9C38_smalltit[36960]);
											v90 = (x_DWORD *)((char *)&unk_F0E20 + 12 * *v165);
											v91 = v133 >> 1;
											if (!(v133 & 1))
											{
												v89 = (x_DWORD *)(v155 + 8);
												v90 = (x_DWORD*)(v169 + 12);
												goto LABEL_247;
											}
											++v91;
											while (1)
											{
												BYTE1(v87) = *v86;
												v86 += v89[2];
												if (BYTE1(v87))
													*v88 = x_BYTE_FAEE0[v87];
												v88 += v90[3];
												v89 += 4;
												v90 += 6;
												if (!--v91)
													break;
											LABEL_247:
												BYTE1(v87) = *v86;
												v86 += *v89;
												if (BYTE1(v87))
													*v88 = x_BYTE_FAEE0[v87];
												v88 += *v90;
											}
											break;
										case 6:
											v92 = x_DWORD_F2C20;
											v93 = (x_BYTE *)(*(x_DWORD *)(v155 + 4) + v121);
											v94 = (x_BYTE *)(*((x_DWORD *)v169 + 1) + v123);
											HIWORD(v95) = 0;
											v96 = (x_DWORD *)(v155 + 8);
											v97 = (x_DWORD*)(v169 + 12);
											do
											{
												BYTE1(v95) = *v93;
												v93 += *v96;
												if (BYTE1(v95))
												{
													LOBYTE(v95) = *v94;
													LOBYTE(v92) = x_BYTE_FAEE0[v95];
													*v94 = x_BYTE_F6EE0_tables[v92];
												}
												v94 += *v97;
												v96 += 2;
												v97 += 3;
												--v133;
											} while (v133);
											break;
										case 7:
											v98 = x_DWORD_F2C20;
											v99 = (x_BYTE *)(*(x_DWORD *)(v155 + 4) + v121);
											v100 = (x_BYTE *)(*((x_DWORD *)v169 + 1) + v123);
											HIWORD(v101) = 0;
											v102 = (x_DWORD *)(v155 + 8);
											v103 = (x_DWORD*)(v169 + 12);
											do
											{
												LOBYTE(v101) = *v99;
												v99 += *v102;
												if ((x_BYTE)v101)
												{
													BYTE1(v101) = *v100;
													LOBYTE(v98) = x_BYTE_FAEE0[v101];
													*v100 = x_BYTE_F6EE0_tables[v98];
												}
												v100 += *v103;
												v102 += 2;
												v103 += 3;
												--v133;
											} while (v133);
											break;
										case 8:
											v104 = (char *)(*(x_DWORD *)(v155 + 4) + v121);
											v105 = x_DWORD_F2C20;
											v106 = (x_BYTE *)(*((x_DWORD *)v169 + 1) + v123);
											v107 = (x_DWORD *)(8 * (v165[2] - v116) + x_DWORD_E9C38_smalltit[36960]);
											v108 = (x_DWORD *)((char *)&unk_F0E20 + 12 * *v165);
											v109 = v133 >> 1;
											if (!(v133 & 1))
											{
												v107 = (x_DWORD *)(v155 + 8);
												v108 = (x_DWORD*)(v169 + 12);
												goto LABEL_267;
											}
											++v109;
											while (1)
											{
												v111 = *v104;
												v104 += v107[2];
												if (v111)
												{
													LOBYTE(v105) = *v106;
													*v106 = x_BYTE_F6EE0_tables[v105];
												}
												v106 += v108[3];
												v107 += 4;
												v108 += 6;
												if (!--v109)
													break;
											LABEL_267:
												v110 = *v104;
												v104 += *v107;
												if (v110)
												{
													LOBYTE(v105) = *v106;
													*v106 = x_BYTE_F6EE0_tables[v105];
												}
												v106 += *v108;
											}
											break;
										}
									}
								}
								x_DWORD_F2C48 += v135;
								v123 += x_DWORD_F2CAC;
								v165 += 3;
								LOWORD(v1) = i;
							}
						}
						break;
					case 7:
						v1 = x_DWORD_F2CBC * x_DWORD_F2C44 >> 16;
						v156 = x_DWORD_F2CBC * x_DWORD_F2C44 >> 16;
						if (v156 <= 0)
							break;
						v1 = (x_DWORD_F2C50 << 16) / x_DWORD_F2CBC;
						v159 = (x_DWORD_F2C50 << 16) / x_DWORD_F2CBC;
						if (v159 <= 0)
							break;
						LOWORD(v1) = x_DWORD_F2C30;
						if (x_DWORD_F2C30 >= x_DWORD_F2CB8)
							break;
						v135 = (x_DWORD_F2C38 << 16) / v159;
						if (a1 == 1)
						{
							x_DWORD_F2C48 = 0;
						}
						else
						{
							x_DWORD_F2C48 = (v159 - 1) * v135;
							v135 = -v135;
						}
						v161 = x_DWORD_F2C8C * x_DWORD_F2C50 / v159;
						v166 = (int *)(x_DWORD_E9C38_smalltit[45920]);
						v158 = x_DWORD_F2C30 << 16;
						v114 = x_DWORD_F2C9C * x_DWORD_F2C30 >> 16;
						v171 = x_DWORD_F2CB4 - x_DWORD_F2C2C - v114;
						if (v171 < x_DWORD_F2CB4)
						{
							LOWORD(v1) = x_DWORD_F2CB4 - x_DWORD_F2C2C - v114;
							if (v171 < x_DWORD_F2CA4)
								break;
						}
						else
						{
							v152 = v171 - x_DWORD_F2CB4;
							LOWORD(v1) = v171 - x_DWORD_F2CB4;
							v159 -= v171 - x_DWORD_F2CB4;
							if (v159 <= 0)
								break;
							x_DWORD_F2C48 += v152 * v135;
							v158 += v152 * v161;
							v171 = x_DWORD_F2CB4;
						}
						v123 = x_DWORD_DE560 * (x_DWORD_F2CB4 - 1 - v171) + x_DWORD_DE558;
					LABEL_285:
						v142 = x_DWORD_F2CB4 - x_DWORD_F2CA4;
						if (v171 < x_DWORD_F2CB4)
						{
							if (v159 > v142)
								v159 = x_DWORD_F2CB4 - x_DWORD_F2CA4;
						}
						else if (v171 + v159 - x_DWORD_F2CB4 > v142)
						{
							LOWORD(v1) = v142 - v171;
							v159 = v142 - v171 + x_DWORD_F2CB4;
							if (v159 <= 0)
								break;
						}
						v116 = 9999999;
						for (j = v159; j; j--)
						{
							v174 = v158 >> 16;
							if (v158 >> 16 < 0)
							{
								v175 = -v174;
								*v166 = 0;
								v166[1] = v156 - v175;
								v166[2] = v175;
								if (v175 < v116)
									v116 = v175;
							}
							else
							{
								*v166 = v174;
								v166[1] = v156;
								v166[2] = 0;
								v116 = 0;
							}
							if (v166[1] + *v166 > x_DWORD_F2CB8)
								v166[1] = x_DWORD_F2CB8 - *v166;
							v158 += v161;
							v166 += 3;
						}
						v143 = v171 + x_DWORD_F2C94 - x_DWORD_F2CB4 + 1;
						if (v143 > 0)
						{
							v167 = (x_DWORD *)(12 * v143 + x_DWORD_E9C38_smalltit[45920]);
							v119 = (x_DWORD *)x_DWORD_F2C88;
							for (k = v171 + x_DWORD_F2C94 - x_DWORD_F2CB4 + 2; k; k--)
							{
								v167 -= 3;
								if (x_DWORD_E9C38_smalltit[45920] > (unsigned int)v167)
									break;
								v144 = v167[1] + *v167 - *v119;
								if (v144 > 0)
								{
									v167[1] -= v144;
									if (v167[1] < 0)
										v167[1] = 0;
								}
								--v119;
							}
						}
						if (v171 - v159 < 0)
						{
							v129 = v159 - v171;
							v168 = (x_DWORD *)(12 * v171 + x_DWORD_E9C38_smalltit[45920]);
							v120 = (x_DWORD *)(x_DWORD_E9C38_smalltit + 59360);
							v145 = v171 - v159 - x_DWORD_F2CA4;
							if (v145 < 0)
							{
								LOWORD(v1) = v171 - v159 - x_DWORD_F2CA4;
								v159 = v171 - x_DWORD_F2CA4;
								if (v171 - x_DWORD_F2CA4 <= 0)
									break;
								v129 += v145;
							}
							v112 = v129;
							v130 = v129 - 1;
							if (v112 > 0)
							{
								while (v130)
								{
									v168 += 3;
									if (x_DWORD_E9C38_smalltit[45920] <= (unsigned int)v168)
									{
										v146 = *v120 - *v168;
										if (v146 > 0)
										{
											*v168 = *v120;
											v168[1] -= v146;
											if (v168[1] < 0)
												v168[1] = 0;
											v168[2] += v146;
										}
									}
									++v120;
									--v130;
								}
							}
						}
						goto LABEL_172;
					}
				}
				if (a1 == 1)
				{
					if (!x_D41A0_BYTEARRAY_4[0xCF]
						&& *(x_BYTE *)(x_DWORD_F2C70 + 63) == 3
						&& (!*(x_BYTE *)(x_DWORD_F2C70 + 64) || *(x_BYTE *)(x_DWORD_F2C70 + 64) == 1))
					{
						sub_2CB30((x_DWORD *)x_DWORD_F2C70, x_DWORD_F2C30, (signed __int16)x_DWORD_F2C2C, x_DWORD_F2C44);
					}
					if (x_D41A0_BYTEARRAY_4_struct.byteindex_A)
						sub_88740(
							x_DWORD_F2C70,
							(signed __int16)(x_DWORD_F2C30 + (x_DWORD_F2C44 >> 1)),
							(signed __int16)(x_DWORD_F2C2C + (x_DWORD_F2C50 >> 1)));
					LOWORD(v1) = x_DWORD_F2C70;
					if (*(x_BYTE *)(x_DWORD_F2C70 + 15) & 0x40)
					{
						v1 = x_DWORD_F2C70;
						*(x_BYTE *)(v1 + 42) |= 0x40u;
					}
				}
				return v1;
			}
		}
		x_DWORD_F2C30 -= x_DWORD_F2C64 * x_DWORD_F2C44 >> 17;
		x_DWORD_F2C2C -= -(x_DWORD_F2C54 * x_DWORD_F2C44) >> 17;
		goto LABEL_126;
	}
	v138 = (x_DWORD_F2C50 + x_DWORD_F2C44) >> 2;
	if (a1 >= 1)
	{
		if (a1 <= 1)
		{
			x_DWORD_F2C30 += -(x_DWORD_F2C54 * v138 >> 16) - v138;
			x_DWORD_F2C2C += -(x_DWORD_F2C64 * v138 >> 16) - v138;
		}
		else if (a1 == 2)
		{
			x_DWORD_F2C30 += (x_DWORD_F2C54 * v138 >> 16) - v138;
			x_DWORD_F2C2C += (x_DWORD_F2C64 * v138 >> 16) - v138;
		}
	}
	LOWORD(v1) = x_DWORD_DE564;
	if ((unsigned __int16)x_DWORD_DE564 > x_DWORD_F2C30)
	{
		v136 = (x_DWORD_F2C34 << 16) / x_DWORD_F2C44;
		if (-x_DWORD_F2C30 < 0 || x_DWORD_F2C30 == 0)
		{
			x_DWORD_F2C4C = 0;
			if (x_DWORD_F2C44 + x_DWORD_F2C30 - (unsigned __int16)x_DWORD_DE564 > 0)
				x_DWORD_F2C44 -= x_DWORD_F2C44 + x_DWORD_F2C30 - (unsigned __int16)x_DWORD_DE564;
		}
		else
		{
			LOWORD(v1) = -(signed __int16)x_DWORD_F2C30;
			x_DWORD_F2C44 += x_DWORD_F2C30;
			if (x_DWORD_F2C44 <= 0)
				return v1;
			x_DWORD_F2C4C = v136 * -x_DWORD_F2C30;
			x_DWORD_F2C30 = 0;
			if ((unsigned __int16)x_DWORD_DE564 <= x_DWORD_F2C44)
				x_DWORD_F2C44 = (unsigned __int16)x_DWORD_DE564;
		}
		LOWORD(v1) = x_DWORD_DE568;
		if ((unsigned __int16)x_DWORD_DE568 > x_DWORD_F2C2C)
		{
			v134 = (x_DWORD_F2C38 << 16) / x_DWORD_F2C50;
			if (-x_DWORD_F2C2C < 0 || x_DWORD_F2C2C == 0)
			{
				x_DWORD_F2C48 = 0;
				if (x_DWORD_F2C50 + x_DWORD_F2C2C - (unsigned __int16)x_DWORD_DE568 > 0)
					x_DWORD_F2C50 -= x_DWORD_F2C50 + x_DWORD_F2C2C - (unsigned __int16)x_DWORD_DE568;
			}
			else
			{
				LOWORD(v1) = -(signed __int16)x_DWORD_F2C2C;
				x_DWORD_F2C50 += x_DWORD_F2C2C;
				if (x_DWORD_F2C50 <= 0)
					return v1;
				x_DWORD_F2C48 = v134 * -x_DWORD_F2C2C;
				x_DWORD_F2C2C = 0;
				if ((unsigned __int16)x_DWORD_DE568 <= x_DWORD_F2C50)
					x_DWORD_F2C50 = (unsigned __int16)x_DWORD_DE568;
			}
			v153 = (x_DWORD *)(x_DWORD_E9C38_smalltit[36960]);
			for (l = x_DWORD_F2C44; l; l--)
			{
				v153[1] = x_DWORD_F2C4C >> 16;
				if ((x_DWORD *)(x_DWORD_E9C38_smalltit[36960]) == v153)
					*v153 = 22;
				else
					*v153 = v153[1] - *(v153 - 1);
				x_DWORD_F2C4C += v136;
				v153 += 2;
			}
			if (a1 == 1 && x_D41A0_BYTEARRAY_4_struct.byteindex_A)
				sub_88740(
					x_DWORD_F2C70,
					(signed __int16)(x_DWORD_F2C30 + (x_DWORD_F2C44 >> 1)),
					(signed __int16)(x_DWORD_F2C2C + (x_DWORD_F2C50 >> 1)));
			v1 = x_DWORD_F2C2C * x_DWORD_DE560 + x_DWORD_F2C30 + x_DWORD_DE558;
			v122 = x_DWORD_F2C2C * x_DWORD_DE560 + x_DWORD_F2C30 + x_DWORD_DE558;
			while (x_DWORD_F2C50)
			{
				if ((unsigned int)x_DWORD_F2C24 <= 7)
				{
					switch (x_DWORD_F2C24)
					{
					case 0:
						v2 = (char *)(x_DWORD_F2C40 * (x_DWORD_F2C48 >> 16) + x_DWORD_F2C28 + *(x_DWORD *)(x_DWORD_E9C38_smalltit + 36964));
						v3 = (x_DWORD *)(x_DWORD_E9C38_smalltit[36960]);
						v4 = (x_BYTE *)v122;
						v5 = x_DWORD_F2C44 >> 1;
						if (!(x_DWORD_F2C44 & 1))
						{
							v6 = v5 & 1;
							v7 = x_DWORD_F2C44 >> 2;
							if (v6)
							{
								++v7;
								v3 = (x_DWORD *)(x_DWORD_E9C38_smalltit + 36952);
								v4 = (x_BYTE *)(v122 - 2);
								goto LABEL_49;
							}
							v3 = (x_DWORD *)(x_DWORD_E9C38_smalltit + 36968);
							goto LABEL_45;
						}
						v8 = v5 + 2;
						v6 = v8 & 1;
						v7 = v8 >> 1;
						if (!v6)
						{
							v3 = (x_DWORD *)(x_DWORD_E9C38_smalltit + 36944);
							v4 = (x_BYTE *)(v122 - 3);
							goto LABEL_51;
						}
						v4 = (x_BYTE *)(v122 - 1);
						while (1)
						{
							v10 = *v2;
							v2 += v3[2];
							if (v10)
								v4[1] = v10;
						LABEL_49:
							v11 = *v2;
							v2 += v3[4];
							if (v11)
								v4[2] = v11;
						LABEL_51:
							v12 = *v2;
							v2 += v3[6];
							if (v12)
								v4[3] = v12;
							v4 += 4;
							v3 += 8;
							if (!--v7)
								break;
						LABEL_45:
							v9 = *v2;
							v2 += *v3;
							if (v9)
								*v4 = v9;
						}
						break;
					case 1:
						v13 = x_DWORD_F2C20;
						v14 = (x_BYTE *)(x_DWORD_F2C40 * (x_DWORD_F2C48 >> 16) + x_DWORD_F2C28 + *(x_DWORD *)(x_DWORD_E9C38_smalltit + 36964));
						v15 = (x_DWORD *)(x_DWORD_E9C38_smalltit[36960]);
						v16 = (x_BYTE *)v122;
						v17 = x_DWORD_F2C44 >> 1;
						if (!(x_DWORD_F2C44 & 1))
						{
							v15 = (x_DWORD *)(x_DWORD_E9C38_smalltit + 36968);
							goto LABEL_58;
						}
						++v17;
						v16 = (x_BYTE *)(v122 - 1);
						while (1)
						{
							LOBYTE(v13) = *v14;
							v14 += v15[2];
							if ((x_BYTE)v13)
								v16[1] = x_BYTE_F6EE0_tables[v13];
							v16 += 2;
							v15 += 4;
							if (!--v17)
								break;
						LABEL_58:
							LOBYTE(v13) = *v14;
							v14 += *v15;
							if ((x_BYTE)v13)
								*v16 = x_BYTE_F6EE0_tables[v13];
						}
						break;
					case 2:
						v18 = (x_BYTE *)(x_DWORD_F2C40 * (x_DWORD_F2C48 >> 16) + x_DWORD_F2C28 + *(x_DWORD *)(x_DWORD_E9C38_smalltit + 36964));
						v19 = (x_DWORD *)(x_DWORD_E9C38_smalltit[36960]);
						v20 = (x_BYTE *)v122;
						HIWORD(v21) = 0;
						v22 = x_DWORD_F2C44 >> 1;
						if (!(x_DWORD_F2C44 & 1))
						{
							v19 = (x_DWORD *)(x_DWORD_E9C38_smalltit + 36968);
							goto LABEL_67;
						}
						++v22;
						v20 = (x_BYTE *)(v122 - 1);
						while (1)
						{
							BYTE1(v21) = *v18;
							v18 += v19[2];
							if (BYTE1(v21))
							{
								LOBYTE(v21) = v20[1];
								v20[1] = x_BYTE_FAEE0[v21];
							}
							v20 += 2;
							v19 += 4;
							if (!--v22)
								break;
						LABEL_67:
							BYTE1(v21) = *v18;
							v18 += *v19;
							if (BYTE1(v21))
							{
								LOBYTE(v21) = *v20;
								*v20 = x_BYTE_FAEE0[v21];
							}
						}
						break;
					case 3:
						v23 = (x_BYTE *)(x_DWORD_F2C40 * (x_DWORD_F2C48 >> 16) + x_DWORD_F2C28 + *(x_DWORD *)(x_DWORD_E9C38_smalltit + 36964));
						v24 = (x_DWORD *)(x_DWORD_E9C38_smalltit[36960]);
						v25 = (x_BYTE *)v122;
						HIWORD(v26) = 0;
						v27 = x_DWORD_F2C44 >> 1;
						if (!(x_DWORD_F2C44 & 1))
						{
							v24 = (x_DWORD *)(x_DWORD_E9C38_smalltit + 36968);
							goto LABEL_76;
						}
						++v27;
						v25 = (x_BYTE *)(v122 - 1);
						while (1)
						{
							LOBYTE(v26) = *v23;
							v23 += v24[2];
							if ((x_BYTE)v26)
							{
								BYTE1(v26) = v25[1];
								v25[1] = x_BYTE_FAEE0[v26];
							}
							v25 += 2;
							v24 += 4;
							if (!--v27)
								break;
						LABEL_76:
							LOBYTE(v26) = *v23;
							v23 += *v24;
							if ((x_BYTE)v26)
							{
								BYTE1(v26) = *v25;
								*v25 = x_BYTE_FAEE0[v26];
							}
						}
						break;
					case 4:
						HIWORD(v31) = HIWORD(x_DWORD_F2C3C);
						v28 = (x_BYTE *)(x_DWORD_F2C40 * (x_DWORD_F2C48 >> 16) + x_DWORD_F2C28 + *(x_DWORD *)(x_DWORD_E9C38_smalltit + 36964));
						v29 = (x_DWORD *)(x_DWORD_E9C38_smalltit[36960]);
						v30 = (x_BYTE *)v122;
						BYTE1(v31) = x_DWORD_F2C3C;
						v32 = x_DWORD_F2C44 >> 1;
						if (!(x_DWORD_F2C44 & 1))
						{
							v29 = (x_DWORD *)(x_DWORD_E9C38_smalltit + 36968);
							goto LABEL_85;
						}
						++v32;
						v30 = (x_BYTE *)(v122 - 1);
						while (1)
						{
							LOBYTE(v31) = *v28;
							v28 += v29[2];
							if ((x_BYTE)v31)
								v30[1] = x_BYTE_FAEE0[v31];
							v30 += 2;
							v29 += 4;
							if (!--v32)
								break;
						LABEL_85:
							LOBYTE(v31) = *v28;
							v28 += *v29;
							if ((x_BYTE)v31)
								*v30 = x_BYTE_FAEE0[v31];
						}
						break;
					case 5:
						v33 = x_DWORD_F2C3C;
						v34 = (x_BYTE *)(x_DWORD_F2C40 * (x_DWORD_F2C48 >> 16) + x_DWORD_F2C28 + *(x_DWORD *)(x_DWORD_E9C38_smalltit + 36964));
						v35 = (x_DWORD *)(x_DWORD_E9C38_smalltit[36960]);
						v36 = (x_BYTE *)v122;
						v37 = x_DWORD_F2C44 >> 1;
						if (!(x_DWORD_F2C44 & 1))
						{
							v35 = (x_DWORD *)(x_DWORD_E9C38_smalltit + 36968);
							goto LABEL_94;
						}
						++v37;
						v36 = (x_BYTE *)(v122 - 1);
						while (1)
						{
							BYTE1(v33) = *v34;
							v34 += v35[2];
							if (BYTE1(v33))
								v36[1] = x_BYTE_FAEE0[v33];
							v36 += 2;
							v35 += 4;
							if (!--v37)
								break;
						LABEL_94:
							BYTE1(v33) = *v34;
							v34 += *v35;
							if (BYTE1(v33))
								*v36 = x_BYTE_FAEE0[v33];
						}
						break;
					case 6:
						v38 = x_DWORD_F2C20;
						v39 = (x_BYTE *)(x_DWORD_F2C40 * (x_DWORD_F2C48 >> 16) + x_DWORD_F2C28 + *(x_DWORD *)(x_DWORD_E9C38_smalltit + 36964));
						v40 = (x_DWORD *)(x_DWORD_E9C38_smalltit[36960]);
						v41 = (x_BYTE *)v122;
						HIWORD(v42) = 0;
						v43 = x_DWORD_F2C44 >> 1;
						if (!(x_DWORD_F2C44 & 1))
						{
							v40 = (x_DWORD *)(x_DWORD_E9C38_smalltit + 36968);
							goto LABEL_103;
						}
						++v43;
						v41 = (x_BYTE *)(v122 - 1);
						while (1)
						{
							BYTE1(v42) = *v39;
							v39 += v40[2];
							if (BYTE1(v42))
							{
								LOBYTE(v42) = v41[1];
								LOBYTE(v38) = x_BYTE_FAEE0[v42];
								v41[1] = x_BYTE_F6EE0_tables[v38];
							}
							v41 += 2;
							v40 += 4;
							if (!--v43)
								break;
						LABEL_103:
							BYTE1(v42) = *v39;
							v39 += *v40;
							if (BYTE1(v42))
							{
								LOBYTE(v42) = *v41;
								LOBYTE(v38) = x_BYTE_FAEE0[v42];
								*v41 = x_BYTE_F6EE0_tables[v38];
							}
						}
						break;
					case 7:
						v44 = x_DWORD_F2C20;
						v45 = (x_BYTE *)(x_DWORD_F2C40 * (x_DWORD_F2C48 >> 16) + x_DWORD_F2C28 + *(x_DWORD *)(x_DWORD_E9C38_smalltit + 36964));
						v46 = (x_DWORD *)(x_DWORD_E9C38_smalltit[36960]);
						v47 = (x_BYTE *)v122;
						HIWORD(v48) = 0;
						v49 = x_DWORD_F2C44 >> 1;
						if (!(x_DWORD_F2C44 & 1))
						{
							v46 = (x_DWORD *)(x_DWORD_E9C38_smalltit + 36968);
							goto LABEL_112;
						}
						++v49;
						v47 = (x_BYTE *)(v122 - 1);
						while (1)
						{
							LOBYTE(v48) = *v45;
							v45 += v46[2];
							if ((x_BYTE)v48)
							{
								BYTE1(v48) = v47[1];
								LOBYTE(v44) = x_BYTE_FAEE0[v48];
								v47[1] = x_BYTE_F6EE0_tables[v44];
							}
							v47 += 2;
							v46 += 4;
							if (!--v49)
								break;
						LABEL_112:
							LOBYTE(v48) = *v45;
							v45 += *v46;
							if ((x_BYTE)v48)
							{
								BYTE1(v48) = *v47;
								LOBYTE(v44) = x_BYTE_FAEE0[v48];
								*v47 = x_BYTE_F6EE0_tables[v44];
							}
						}
						break;
					}
				}
				x_DWORD_F2C48 += v134;
				LOWORD(v1) = x_DWORD_DE560;
				v122 += x_DWORD_DE560;
				--x_DWORD_F2C50;
			}
		}
	}
	return v1;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// DE558: using guessed type int x_DWORD_DE558;
// DE55C: using guessed type int x_DWORD_DE55C;
// DE560: using guessed type int x_DWORD_DE560;
// DE564: using guessed type int x_DWORD_DE564;
// DE568: using guessed type int x_DWORD_DE568;
// E9C38: using guessed type int x_DWORD_E9C38_smalltit;
// F2C20: using guessed type int x_DWORD_F2C20;
// F2C24: using guessed type int x_DWORD_F2C24;
// F2C28: using guessed type int x_DWORD_F2C28;
// F2C2C: using guessed type int x_DWORD_F2C2C;
// F2C30: using guessed type int x_DWORD_F2C30;
// F2C34: using guessed type int x_DWORD_F2C34;
// F2C38: using guessed type int x_DWORD_F2C38;
// F2C3C: using guessed type int x_DWORD_F2C3C;
// F2C40: using guessed type int x_DWORD_F2C40;
// F2C44: using guessed type int x_DWORD_F2C44;
// F2C48: using guessed type int x_DWORD_F2C48;
// F2C4C: using guessed type int x_DWORD_F2C4C;
// F2C50: using guessed type int x_DWORD_F2C50;
// F2C54: using guessed type int x_DWORD_F2C54;
// F2C64: using guessed type int x_DWORD_F2C64;
// F2C70: using guessed type int x_DWORD_F2C70;
// F2C84: using guessed type int x_DWORD_F2C84;
// F2C88: using guessed type int x_DWORD_F2C88;
// F2C8C: using guessed type int x_DWORD_F2C8C;
// F2C90: using guessed type int x_DWORD_F2C90;
// F2C94: using guessed type int x_DWORD_F2C94;
// F2C98: using guessed type int x_DWORD_F2C98;
// F2C9C: using guessed type int x_DWORD_F2C9C;
// F2CA4: using guessed type int x_DWORD_F2CA4;
// F2CAC: using guessed type int x_DWORD_F2CAC;
// F2CB4: using guessed type int x_DWORD_F2CB4;
// F2CB8: using guessed type int x_DWORD_F2CB8;
// F2CBC: using guessed type int x_DWORD_F2CBC;
// F2CC6: using guessed type char x_BYTE_F2CC6;

//----- (00043830) --------------------------------------------------------
int sub_43830_generate_level_map(unsigned int a1, Bit8u* a2)//224830
{
	Bit8u* v2; // ebx
	Bit32s v3; // ST0C_4

	v2 = a2;
	x_WORD_17B4E0 = *(x_WORD *)(a2 + 23);
	*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8) = *(x_DWORD *)(a2 + 23);
	memset((void*)x_WORD_15B4E0, 0, 0x20000);
	v3 = *(unsigned __int16 *)(v2 + 35);
	sub_B5E70_decompress_terrain_map_level(x_WORD_17B4E0, *(x_WORD *)(v2 + 27), *(x_WORD *)(v2 + 31), v3);
	sub_44DB0();//225db0
	memset((void*)x_WORD_15B4E0, 0, 0x20000);
	sub_44E40(*(x_DWORD *)(v2 + 39), *(x_WORD *)(v2 + 43));//225e40
	sub_45AA0();//226aa0
	sub_440D0(*(x_WORD *)(v2 + 51));//2250d0
	sub_45060(*(x_WORD *)(v2 + 55), *(x_WORD *)(v2 + 59));//226060
	sub_44320();//225320
	sub_45210(*(x_WORD *)(v2 + 55), *(x_WORD *)(v2 + 59));//226210
	sub_454F0(*(x_WORD *)(v2 + 47), *(x_WORD *)(v2 + 67));//2264f0
	sub_45600(*(x_WORD *)(v2 + 63));//226600
	sub_43FC0();//224fc0
	memset((void*)x_BYTE_10B4E0, 0, 0x10000);
	sub_43970(a1);//224970
	sub_43EE0();//224ee0
	sub_44580();//225580
	if (x_BYTE_D41B6)
		sub_43B40();//224b40
	else
		sub_43D50();//224d50
	return sub_44D00();//225d00
}
// 10000: using guessed type void /*__noreturn*/ sub_10000();
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41B6: using guessed type char x_BYTE_D41B6;
// 17B4E0: using guessed type __int16 x_WORD_17B4E0;

//----- (00043970) --------------------------------------------------------
unsigned int sub_43970(unsigned int a1)
{
	unsigned __int16 v1; // bx
	unsigned int result; // eax

	v1 = 0;
	do
	{
		result = sub_439A0(a1, v1);
		x_BYTE_11B4E0[v1++] = result;
	} while (v1);
	return result;
}

//----- (000439A0) --------------------------------------------------------
unsigned int sub_439A0(unsigned int a1, unsigned __int16 a2)
{
	unsigned __int16 v2; // ax
	unsigned __int8 v3; // dl
	unsigned __int8 v4; // dh
	unsigned __int8 v5; // ch
	unsigned __int8 v6; // cl
	int v7; // ebx
	unsigned __int8 v8; // cl
	int v9; // ebx
	unsigned __int8 v10; // cl
	int v11; // ebx
	unsigned __int8 v12; // cl
	int v13; // ebx
	unsigned __int8 v14; // cl
	int v15; // ebx
	unsigned __int8 v16; // cl
	int v17; // ebx
	unsigned __int8 v18; // cl
	int v19; // ebx
	unsigned __int8 v20; // al
	unsigned int v21; // ebx
	unsigned int v22; // ebx

	LOBYTE(v2) = a2;
	LOWORD(a1) = x_BYTE_11B4E0[a2];
	if (x_BYTE_13B4E0[a2] & 7)
	{
		HIBYTE(v2) = HIBYTE(a2) - 1;
		v3 = x_BYTE_11B4E0[a2];
		v4 = v3;
		v5 = x_BYTE_11B4E0[a2];
		v6 = x_BYTE_11B4E0[v2];
		v7 = v6;
		if (v6 > v3)
			v3 = x_BYTE_11B4E0[v2];
		if (v6 < v4)
			v4 = x_BYTE_11B4E0[v2];
		LOBYTE(v2) = a2 + 1;
		v8 = x_BYTE_11B4E0[v2];
		v9 = v8 + v7;
		if (v8 > v3)
			v3 = x_BYTE_11B4E0[v2];
		if (v8 < v4)
			v4 = x_BYTE_11B4E0[v2];
		HIBYTE(v2) = HIBYTE(a2);
		v10 = x_BYTE_11B4E0[v2];
		v11 = v10 + v9;
		if (v10 > v3)
			v3 = x_BYTE_11B4E0[v2];
		if (v10 < v4)
			v4 = x_BYTE_11B4E0[v2];
		HIBYTE(v2) = HIBYTE(a2) + 1;
		v12 = x_BYTE_11B4E0[v2];
		v13 = v12 + v11;
		if (v12 > v3)
			v3 = x_BYTE_11B4E0[v2];
		if (v12 < v4)
			v4 = x_BYTE_11B4E0[v2];
		LOBYTE(v2) = a2;
		v14 = x_BYTE_11B4E0[v2];
		v15 = v14 + v13;
		if (v14 > v3)
			v3 = x_BYTE_11B4E0[v2];
		if (v14 < v4)
			v4 = x_BYTE_11B4E0[v2];
		LOBYTE(v2) = a2 - 1;
		v16 = x_BYTE_11B4E0[v2];
		v17 = v16 + v15;
		if (v16 > v3)
			v3 = x_BYTE_11B4E0[v2];
		if (v16 < v4)
			v4 = x_BYTE_11B4E0[v2];
		HIBYTE(v2) = HIBYTE(a2);
		v18 = x_BYTE_11B4E0[v2];
		v19 = v18 + v17;
		if (v18 > v3)
			v3 = x_BYTE_11B4E0[v2];
		if (v18 < v4)
			v4 = x_BYTE_11B4E0[v2];
		HIBYTE(v2) = HIBYTE(a2) - 1;
		v20 = x_BYTE_11B4E0[v2];
		v21 = v20 + v19;
		if (v20 > v3)
			v3 = v20;
		if (v20 < v4)
			v4 = v20;
		v22 = v21 >> 3;
		if ((unsigned __int8)(v5 - v4) <= 4u)
		{
			if ((unsigned __int8)(v3 - v5) <= 4u)
				return a1;
			if ((unsigned __int8)(v3 - v5) <= 0xAu)
				v22 = (v5 + v22) >> 1;
		}
		else if ((unsigned __int8)(v5 - v4) <= 0xAu)
		{
			return (v22 + v5) >> 1;
		}
		a1 = v22;
	}
	return a1;
}

//----- (00043B40) --------------------------------------------------------
__int16 sub_43B40()
{
	unsigned __int16 v0; // dx
	signed int v1; // eax
	unsigned __int8 v2; // bl
	unsigned __int8 v3; // bh
	char v4; // cl

	v0 = 0;
	do
	{
		v1 = x_BYTE_11B4E0[v0];
		if (v1 > (unsigned __int8)x_BYTE_D41B7)
			LOBYTE(v1) = x_BYTE_D41B7;
		v2 = x_BYTE_D41B7 - v1;
		x_BYTE_14B4E0[v0] = x_BYTE_D41B7 - v1;
		v3 = x_BYTE_11B4E0[v0];
		if (v2 > v3)
		{
			x_BYTE_13B4E0[v0] &= 0xF7u;
		}
		else
		{
			v4 = x_BYTE_13B4E0[v0] | 8;
			x_BYTE_14B4E0[v0] = v3 - 1;
			x_BYTE_13B4E0[v0] = v4;
		}
		++v0;
	} while (v0);
	return sub_43BB0();
}
// D41B7: using guessed type char x_BYTE_D41B7;

//----- (00043BB0) --------------------------------------------------------
__int16 sub_43BB0()
{
	unsigned int v0; // esi
	unsigned __int16 v1; // cx
	signed int v2; // ebx
	unsigned __int16 v3; // bx
	int v4; // eax
	unsigned __int8 v5; // dh
	char v6; // cl

	v0 = 37487429;
	v1 = 0;
	do
	{
		if (!(x_BYTE_13B4E0[v1] & 8))
		{
			v0 = 9377 * v0 + 9439;
			v2 = v0 % 7 - 3 + (unsigned __int8)x_BYTE_14B4E0[v1];
			if (v2 < 0)
				v2 = 0;
			if (v2 > 254)
				LOBYTE(v2) = -2;
			x_BYTE_14B4E0[v1] = v2;
		}
		++v1;
	} while (v1);
	v3 = 0;
	do
	{
		v4 = v3;
		v5 = x_BYTE_11B4E0[v3];
		if ((unsigned __int8)x_BYTE_14B4E0[v3] > v5)
		{
			x_BYTE_13B4E0[v3] &= 0xF7u;
		}
		else
		{
			v6 = x_BYTE_13B4E0[v3] | 8;
			x_BYTE_14B4E0[v3] = v5 - 1;
			x_BYTE_13B4E0[v3] = v6;
		}
		++v3;
	} while (v3);
	return v4;
}

//----- (00043C60) --------------------------------------------------------
void sub_43C60(unsigned __int8 a1, char a2, int a3, int a4)
{
	unsigned int v4; // ecx
	int v5; // esi
	unsigned __int16 v6; // bx
	int v7; // edi
	int v8; // ecx
	unsigned __int16 v9; // bx
	int v10; // esi
	unsigned __int8 v11; // dh

	v4 = 37487429;
	LOBYTE(v6) = a1;
	v5 = a3;
	HIBYTE(v6) = a2;
	while ((x_WORD)--v5 != -1)
	{
		v7 = a4;
		while ((x_WORD)--v7 != -1)
		{
			if (!(x_BYTE_13B4E0[v6] & 8))
			{
				v4 = 9377 * v4 + 9439;
				x_BYTE_14B4E0[v6] += v4 % 7 - 3;
			}
			LOBYTE(v6) = v6 + 1;
		}
		v6 = __PAIR__(HIBYTE(v6), a1) + 256;
	}
	LOBYTE(v9) = a1;
	v8 = a3;
	HIBYTE(v9) = a2;
	while ((x_WORD)--v8 != -1)
	{
		v10 = a4;
		while ((x_WORD)--v10 != -1)
		{
			v11 = x_BYTE_11B4E0[v9];
			if ((unsigned __int8)x_BYTE_14B4E0[v9] > v11)
			{
				x_BYTE_13B4E0[v9] &= 0xF7u;
			}
			else
			{
				x_BYTE_14B4E0[v9] = v11 - 1;
				x_BYTE_13B4E0[v9] |= 8u;
			}
			LOBYTE(v9) = v9 + 1;
		}
		v9 = __PAIR__(HIBYTE(v9), a1) + 256;
	}
}

//----- (00043D50) --------------------------------------------------------
unsigned __int16 sub_43D50()
{
	unsigned __int16 result; // ax
	unsigned __int16 v1; // dx
	unsigned __int16 v2; // bx
	unsigned __int16 v3; // bx
	unsigned __int16 v4; // bx
	unsigned __int16 v5; // bx
	unsigned __int16 v6; // bx
	unsigned __int16 v7; // bx
	unsigned __int16 v8; // dx
	unsigned __int16 v9; // bx
	unsigned __int16 v10; // bx

	result = 0;
	do
	{
		x_BYTE_13B4E0[result] &= 0xF7u;
		if (!x_BYTE_11B4E0[result])
		{
			--HIBYTE(result);
			v1 = result;
			LOBYTE(result) = result + 1;
			v2 = result;
			++HIBYTE(result);
			LOBYTE(v1) = (x_BYTE_11B4E0[v2] != 0) + (x_BYTE_11B4E0[v1] != 0);
			v3 = result;
			++HIBYTE(result);
			LOBYTE(v1) = (x_BYTE_11B4E0[v3] != 0) + v1;
			v4 = result;
			LOBYTE(result) = result - 1;
			LOBYTE(v1) = (x_BYTE_11B4E0[v4] != 0) + v1;
			v5 = result;
			LOBYTE(result) = result - 1;
			LOBYTE(v1) = (x_BYTE_11B4E0[v5] != 0) + v1;
			v6 = result;
			--HIBYTE(result);
			LOBYTE(v1) = (x_BYTE_11B4E0[v6] != 0) + v1;
			v7 = result;
			--HIBYTE(result);
			LOBYTE(v1) = (x_BYTE_11B4E0[v7] != 0) + v1;
			LOBYTE(v7) = x_BYTE_11B4E0[result] != 0;
			LOBYTE(result) = result + 1;
			++HIBYTE(result);
			if (!((x_BYTE)v7 + (x_BYTE)v1))
			{
				v8 = result;
				LOBYTE(result) = result - 1;
				v9 = result;
				--HIBYTE(result);
				LOBYTE(v8) = (x_BYTE_10B4E0[v9] != 0) + (x_BYTE_10B4E0[v8] != 0);
				v10 = result;
				LOBYTE(result) = result + 1;
				LOBYTE(v8) = (x_BYTE_10B4E0[result] != 0) + (x_BYTE_10B4E0[v10] != 0) + v8;
				++HIBYTE(result);
				if (!(x_BYTE)v8)
					x_BYTE_13B4E0[result] |= 8u;
			}
		}
		++result;
	} while (result);
	return result;
}

//----- (00043EE0) --------------------------------------------------------
unsigned __int16 sub_43EE0()
{
	unsigned __int16 result; // ax
	unsigned __int16 v1; // cx
	char v2; // dh
	unsigned __int8 v3; // dl
	int v4; // ecx
	char v5; // bl
	char v6; // bh
	unsigned __int8 v7; // cl
	char v8; // bh
	char v9; // bh
	unsigned __int16 v10; // cx
	unsigned __int16 v11; // cx
	unsigned __int16 v12; // cx
	unsigned __int16 v13; // cx

	result = 0;
	do
	{
		v1 = result;
		v2 = 0;
		LOBYTE(result) = result + 1;
		v3 = x_BYTE_11B4E0[v1];
		v4 = v1;
		LOWORD(v4) = result;
		v5 = 0;
		v6 = x_BYTE_13B4E0[result];
		if (v6)
		{
			if (v6 == 4)
				v2 = 1;
		}
		else
		{
			v7 = x_BYTE_11B4E0[v4];
			v5 = 1;
			if (v7 < v3)
				v3 = v7;
		}
		++HIBYTE(result);
		v8 = x_BYTE_13B4E0[result];
		if (v8)
		{
			if (v8 == 4)
				++v2;
		}
		else
		{
			++v5;
			if (x_BYTE_11B4E0[result] < v3)
				v3 = x_BYTE_11B4E0[result];
		}
		LOBYTE(result) = result - 1;
		v9 = x_BYTE_13B4E0[result];
		if (v9)
		{
			if (v9 == 4)
				++v2;
		}
		else
		{
			++v5;
			if (x_BYTE_11B4E0[result] < v3)
				v3 = x_BYTE_11B4E0[result];
		}
		--HIBYTE(result);
		if (v2 && v5 && !v3)
		{
			v10 = result;
			LOBYTE(result) = result + 1;
			x_BYTE_11B4E0[v10] = 0;
			v11 = result;
			++HIBYTE(result);
			x_BYTE_11B4E0[v11] = 0;
			v12 = result;
			LOBYTE(result) = result - 1;
			x_BYTE_11B4E0[v12] = 0;
			v13 = result;
			--HIBYTE(result);
			x_BYTE_11B4E0[v13] = 0;
		}
		++result;
	} while (result);
	return result;
}

//----- (00043FC0) --------------------------------------------------------
unsigned __int16 sub_43FC0()
{
	unsigned __int16 result; // ax
	unsigned __int16 v1; // dx
	char v2; // dh
	unsigned __int16 v3; // bx
	unsigned __int16 v4; // bx
	unsigned __int16 v5; // bx
	unsigned __int16 v6; // bx
	unsigned __int16 v7; // bx
	char v8; // bl
	unsigned __int16 v9; // ax

	result = 0;
	do
	{
		--HIBYTE(result);
		v1 = result;
		LOBYTE(result) = result + 1;
		v2 = x_BYTE_13B4E0[v1];
		LOBYTE(v1) = v2 == x_BYTE_13B4E0[result];
		++HIBYTE(result);
		v3 = result;
		++HIBYTE(result);
		LOBYTE(v1) = (v2 == x_BYTE_13B4E0[v3]) + v1;
		v4 = result;
		LOBYTE(result) = result - 1;
		LOBYTE(v1) = (v2 == x_BYTE_13B4E0[v4]) + v1;
		v5 = result;
		LOBYTE(result) = result - 1;
		LOBYTE(v1) = (v2 == x_BYTE_13B4E0[v5]) + v1;
		v6 = result;
		--HIBYTE(result);
		LOBYTE(v1) = (v2 == x_BYTE_13B4E0[v6]) + v1;
		v7 = result;
		--HIBYTE(result);
		v8 = (v2 == x_BYTE_13B4E0[result]) + (v2 == x_BYTE_13B4E0[v7]) + v1;
		LOBYTE(result) = result + 1;
		HIBYTE(v9) = HIBYTE(result) + 1;
		if (v2)
		{
			if (v8 == 7)
				x_BYTE_13B4E0[v9] = v2;
		}
		result = v9 + 1;
	} while (result);
	return result;
}

//----- (000440D0) --------------------------------------------------------
void sub_440D0(unsigned __int16 a1)//2250d0
{
	unsigned __int16 i; // ax
	unsigned __int8 v2; // dh
	unsigned __int8 v3; // dl
	unsigned __int16 v4; // ax
	unsigned __int16 v5; // ax
	int v6; // ebx
	char v7; // bl
	char v8; // dl
	char v9; // dh

	// fix if begin
	v4 = 0;
	v5 = 0;
	// end

	i = 0;
	do
	{
		if (x_BYTE_13B4E0[i] == 5)
		{
			v2 = 0;
			v3 = -1;
			if (x_BYTE_11B4E0[i])
				v2 = x_BYTE_11B4E0[i];
			if (x_BYTE_11B4E0[i] < 0xFFu)
				v3 = x_BYTE_11B4E0[i];
			--HIBYTE(i);
			if (v2 < x_BYTE_11B4E0[i])
				v2 = x_BYTE_11B4E0[i];
			if (v3 > x_BYTE_11B4E0[i])
				v3 = x_BYTE_11B4E0[i];
			LOBYTE(i) = i + 1;
			++HIBYTE(i);
			if (v2 < x_BYTE_11B4E0[i])
				v2 = x_BYTE_11B4E0[v4];
			if (v3 > x_BYTE_11B4E0[v4])
				v3 = x_BYTE_11B4E0[v4];
			LOBYTE(v4) = v4 - 1;
			++HIBYTE(v4);
			if (v2 < x_BYTE_11B4E0[v4])
				v2 = x_BYTE_11B4E0[v5];
			if (v3 > x_BYTE_11B4E0[v5])
				v3 = x_BYTE_11B4E0[v5];
			LOBYTE(i) = v5 - 1;
			--HIBYTE(i);
			if (v2 < x_BYTE_11B4E0[i])
				v2 = x_BYTE_11B4E0[i];
			if (v3 > x_BYTE_11B4E0[i])
				v3 = x_BYTE_11B4E0[i];
			v6 = v2 - v3;
			LOBYTE(i) = i + 1;
			if (v6 <= a1)
			{
				if (v6 == a1)
					x_BYTE_13B4E0[i] = 4;
				else
					x_BYTE_13B4E0[i] = 3;
			}
		}
		i++;
	} while (i);
	do
	{
		v7 = 0;
		v8 = 0;
		v9 = 0;
		if (x_BYTE_13B4E0[i] == 3)
			v7 = 1;
		if (x_BYTE_13B4E0[i] == 2)
			v8 = 1;
		if (x_BYTE_13B4E0[i] == 5)
			v9 = 1;
		LOBYTE(i) = i + 1;
		if (x_BYTE_13B4E0[i] == 3)
			++v7;
		if (x_BYTE_13B4E0[i] == 2)
			++v8;
		if (x_BYTE_13B4E0[i] == 5)
			++v9;
		++HIBYTE(i);
		if (x_BYTE_13B4E0[i] == 3)
			++v7;
		if (x_BYTE_13B4E0[i] == 2)
			++v8;
		if (x_BYTE_13B4E0[i] == 5)
			++v9;
		LOBYTE(i) = i - 1;
		if (x_BYTE_13B4E0[i] == 3)
			++v7;
		if (x_BYTE_13B4E0[i] == 2)
			++v8;
		if (x_BYTE_13B4E0[i] == 5)
			++v9;
		--HIBYTE(i);
		if (!v8 && v7 && v9)
		{
			if (x_BYTE_13B4E0[i] == 3)
				x_BYTE_13B4E0[i] = 4;
			LOBYTE(i) = i + 1;
			if (x_BYTE_13B4E0[i] == 3)
				x_BYTE_13B4E0[i] = 4;
			++HIBYTE(i);
			if (x_BYTE_13B4E0[i] == 3)
				x_BYTE_13B4E0[i] = 4;
			LOBYTE(i) = i - 1;
			if (x_BYTE_13B4E0[i] == 3)
				x_BYTE_13B4E0[i] = 4;
			--HIBYTE(i);
		}
		i++;
	} while (i);
	//  return result;
}

//----- (00044320) --------------------------------------------------------
unsigned __int16 sub_44320()
{
	unsigned __int16 result; // ax
	char v1; // bl
	char v2; // dh
	char v3; // dl

	result = 0;
	do
	{
		v1 = 0;
		v2 = 0;
		v3 = 0;
		if (!x_BYTE_13B4E0[result])
			v1 = 1;
		if (x_BYTE_13B4E0[result] == 5)
			v3 = 1;
		if (x_BYTE_13B4E0[result] == 3)
			v2 = 1;
		LOBYTE(result) = result + 1;
		if (!x_BYTE_13B4E0[result])
			++v1;
		if (x_BYTE_13B4E0[result] == 5)
			++v3;
		if (x_BYTE_13B4E0[result] == 3)
			++v2;
		++HIBYTE(result);
		if (!x_BYTE_13B4E0[result])
			++v1;
		if (x_BYTE_13B4E0[result] == 5)
			++v3;
		if (x_BYTE_13B4E0[result] == 3)
			++v2;
		LOBYTE(result) = result - 1;
		if (!x_BYTE_13B4E0[result])
			++v1;
		if (x_BYTE_13B4E0[result] == 5)
			++v3;
		if (x_BYTE_13B4E0[result] == 3)
			++v2;
		--HIBYTE(result);
		if (v2 && v3)
		{
			if (x_BYTE_13B4E0[result] == 5)
				x_BYTE_13B4E0[result] = 4;
			LOBYTE(result) = result + 1;
			if (x_BYTE_13B4E0[result] == 5)
				x_BYTE_13B4E0[result] = 4;
			++HIBYTE(result);
			if (x_BYTE_13B4E0[result] == 5)
				x_BYTE_13B4E0[result] = 4;
			LOBYTE(result) = result - 1;
			if (x_BYTE_13B4E0[result] == 5)
				x_BYTE_13B4E0[result] = 4;
			--HIBYTE(result);
		}
		if (v2 && v1)
		{
			if (x_BYTE_13B4E0[result] == 3)
				x_BYTE_13B4E0[result] = 4;
			LOBYTE(result) = result + 1;
			if (x_BYTE_13B4E0[result] == 3)
				x_BYTE_13B4E0[result] = 4;
			++HIBYTE(result);
			if (x_BYTE_13B4E0[result] == 3)
				x_BYTE_13B4E0[result] = 4;
			LOBYTE(result) = result - 1;
			if (x_BYTE_13B4E0[result] == 3)
				x_BYTE_13B4E0[result] = 4;
			--HIBYTE(result);
		}
		if (v1 && v3)
		{
			if (x_BYTE_13B4E0[result])
				x_BYTE_13B4E0[result] = 4;
			LOBYTE(result) = result + 1;
			if (x_BYTE_13B4E0[result])
				x_BYTE_13B4E0[result] = 4;
			++HIBYTE(result);
			if (x_BYTE_13B4E0[result])
				x_BYTE_13B4E0[result] = 4;
			LOBYTE(result) = result - 1;
			if (x_BYTE_13B4E0[result])
				x_BYTE_13B4E0[result] = 4;
			--HIBYTE(result);
		}
		++result;
	} while (result);
	return result;
}

//----- (00044580) --------------------------------------------------------
__int16 sub_44580()
{
	x_BYTE *v0; // eax
	unsigned __int16 v1; // bx
	unsigned __int16 v2; // bx
	char v3; // al
	char v4; // dl
	char v5; // cl
	char v6; // ah
	int v7; // edi
	unsigned __int8 *v8; // esi
	unsigned __int8 v9; // dh
	int v10; // esi
	char v11; // dh
	char v12; // al
	char v13; // dl
	char v14; // dh
	int v15; // ST00_4
	char v16; // ah
	unsigned __int8 *v17; // esi
	char v18; // cl
	unsigned __int8 v19; // dh
	int v20; // esi
	char v21; // dh
	char v22; // al
	char v23; // ah
	char v24; // dh
	char v25; // dl
	int v26; // edi
	unsigned __int8 *v27; // esi
	char v28; // cl
	unsigned __int8 v29; // dh
	int v30; // esi
	char v31; // dh
	char v32; // al
	char v33; // dl
	char v34; // dh
	int v35; // ST00_4
	char v36; // ah
	unsigned __int8 *v37; // esi
	char v38; // cl
	unsigned __int8 v39; // dh
	int v40; // esi
	char v41; // dh
	int v42; // edi
	int v43; // esi
	char v44; // al
	unsigned __int8 *v45; // esi
	char v46; // cl
	unsigned __int8 v47; // dh
	int v48; // esi
	char v49; // dh
	char v50; // al
	char v51; // dl
	char v52; // dh
	int v53; // edi
	int v54; // esi
	char v55; // ah
	unsigned __int8 *v56; // esi
	char v57; // cl
	unsigned __int8 v58; // dh
	int v59; // esi
	char v60; // dh
	char v61; // al
	char v62; // ah
	char v63; // dh
	char v64; // dl
	int v65; // edi
	unsigned __int8 *v66; // esi
	char v67; // cl
	unsigned __int8 v68; // dh
	int v69; // esi
	x_BYTE *v70; // eax
	int v71; // edx
	char *v72; // esi
	char i; // bl
	char j; // ch
	char k; // cl
	char l; // bh
	x_BYTE *v77; // eax
	unsigned __int16 v78; // cx
	int v79; // eax
	char v80; // ST14_1
	unsigned __int16 v81; // ax
	char v82; // bh
	unsigned __int16 v83; // ax
	int v84; // esi
	unsigned __int8 v85; // al
	unsigned __int8 v86; // bl
	int v87; // edx
	char *v89; // [esp+8h] [ebp-10h]
	int v90; // [esp+Ch] [ebp-Ch]

	v0 = (x_BYTE *)x_DWORD_180628b_screen_buffer;
	v1 = 0;
	while (v1 < 0x961u)
	{
		++v1;
		*v0 = 0;
		v0 += 25;
	}
	v2 = 0;
	v90 = (int)x_DWORD_180628b_screen_buffer;
	v89 = (char *)&unk_D47E0;
	while (v2 < 0x94u)
	{
		v3 = *v89;
		if (*v89 >= 0)
		{
			v4 = v89[1];
			if (v4 >= 0)
			{
				v5 = v89[2];
				if (v5 >= 0)
				{
					v6 = v89[3];
					if (v6 >= 0)
					{
						v7 = 49 * v4 + 7 * v5 + v6 + 343 * v3;
						v8 = (unsigned __int8 *)(v90 + 25 * v7);
						v9 = *v8;
						if (*v8 < 0xCu)
						{
							*v8 = v9 + 1;
							v10 = (int)&v8[v9];
							*(x_BYTE *)(v10 + 13) = 0;
							*(x_BYTE *)(v10 + 1) = v2;
						}
						v11 = v3;
						v12 = v4;
						v13 = v11;
						v14 = v6;
						v15 = 7 * v6;
						v16 = v5;
						v17 = (unsigned __int8 *)(v90 + 25 * (49 * v13 + v5 + v15 + 343 * v12));
						v18 = v14;
						v19 = *v17;
						if (*v17 < 0xCu)
						{
							*v17 = v19 + 1;
							v20 = (int)&v17[v19];
							*(x_BYTE *)(v20 + 13) = 16;
							*(x_BYTE *)(v20 + 1) = v2;
						}
						v21 = v12;
						v22 = v16;
						v23 = v21;
						v24 = v13;
						v25 = v18;
						v26 = 49 * v18 + v23 + 7 * v24 + 343 * v22;
						v27 = (unsigned __int8 *)(v90 + 25 * v26);
						v28 = v24;
						v29 = *v27;
						if (*v27 < 0xCu)
						{
							*v27 = v29 + 1;
							v30 = (int)&v27[v29];
							*(x_BYTE *)(v30 + 13) = 48;
							*(x_BYTE *)(v30 + 1) = v2;
						}
						v31 = v22;
						v32 = v25;
						v33 = v31;
						v34 = v23;
						v35 = 7 * v23;
						v36 = v28;
						v37 = (unsigned __int8 *)(v90 + 25 * (49 * v33 + v28 + v35 + 343 * v32));
						v38 = v34;
						v39 = *v37;
						if (*v37 < 0xCu)
						{
							*v37 = v39 + 1;
							v40 = (int)&v37[v39];
							*(x_BYTE *)(v40 + 13) = 32;
							*(x_BYTE *)(v40 + 1) = v2;
						}
						v41 = v32;
						v42 = v32;
						v43 = 8 * v32;
						v44 = v38;
						v45 = (unsigned __int8 *)(v90 + 25 * (49 * v33 + v43 - v42 + v36 + 343 * v38));
						v46 = v41;
						v47 = *v45;
						if (*v45 < 0xCu)
						{
							*v45 = v47 + 1;
							v48 = (int)&v45[v47];
							*(x_BYTE *)(v48 + 13) = 96;
							*(x_BYTE *)(v48 + 1) = v2;
						}
						v49 = v44;
						v50 = v33;
						v51 = v49;
						v52 = v36;
						v53 = v36;
						v54 = 8 * v36;
						v55 = v46;
						v56 = (unsigned __int8 *)(v90 + 25 * (49 * v51 + v54 - v53 + v46 + 343 * v50));
						v57 = v52;
						v58 = *v56;
						if (*v56 < 0xCu)
						{
							*v56 = v58 + 1;
							v59 = (int)&v56[v58];
							*(x_BYTE *)(v59 + 13) = 112;
							*(x_BYTE *)(v59 + 1) = v2;
						}
						v60 = v50;
						v61 = v55;
						v62 = v60;
						v63 = v51;
						v64 = v57;
						v65 = 49 * v57 + 7 * v63 + v62 + 343 * v61;
						v66 = (unsigned __int8 *)(v90 + 25 * v65);
						v67 = v63;
						v68 = *v66;
						if (*v66 < 0xCu)
						{
							*v66 = v68 + 1;
							v69 = (int)&v66[v68];
							*(x_BYTE *)(v69 + 13) = 80;
							*(x_BYTE *)(v69 + 1) = v2;
						}
						v70 = (x_BYTE *)(v90 + 25 * (343 * v64 + 7 * v62 + v67 + 49 * v61));
						LOBYTE(v71) = *v70;
						if (*v70 < 0xCu)
						{
							*v70 = v71 + 1;
							v71 = (unsigned __int8)v71;
							v70[v71 + 13] = 64;
							v70[v71 + 1] = v2;
						}
					}
				}
			}
		}
		++v2;
		v89 += 4;
	}
	v72 = x_BYTE_F2CD0;
	for (i = 0; i < 7; i++)
	{
		for (j = 0; j < 7; j++)
		{
			for (k = 0; k < 7; k++)
			{
				for (l = 0; l < 7; l++)
				{
					v77 = (x_BYTE *)(v90 + 25 * (49 * j + 7 * k + l + 343 * i));
					if (*v77)
					{
						*v72 = v77[1];
						v72[1] = v77[13];
					}
					else
					{
						*v72 = 1;
						v72[1] = 0;
					}
					v72 += 2;
				}
			}
		}
	}
	v78 = 0;
	do
	{
		v79 = v78;
		if (!x_BYTE_10B4E0[v78])
		{
			LOBYTE(v78) = v78 + 1;
			v80 = x_BYTE_13B4E0[v79] & 7;
			v81 = v78;
			++HIBYTE(v78);
			v82 = x_BYTE_13B4E0[v81];
			v83 = v78;
			LOBYTE(v78) = v78 - 1;
			v84 = 343 * v80 + 49 * (v82 & 7) + (x_BYTE_13B4E0[v78] & 7) + 7 * (x_BYTE_13B4E0[v83] & 7);
			v85 = *(x_BYTE *)(v90 + 25 * v84);
			--HIBYTE(v78);
			if (v85)
			{
				x_WORD_17B4E0 = 9377 * x_WORD_17B4E0 + 9439;
				v86 = (unsigned __int16)x_WORD_17B4E0 % (unsigned __int16)(v85 + 1);
				if (v86 >= v85)
					v86 = 0;
				v87 = v86 + 25 * v84 + v90;
				LOWORD(v79) = v78;
				x_BYTE_10B4E0[v78] = *(x_BYTE *)(v87 + 1);
				x_BYTE_13B4E0[v78] = (x_BYTE_13B4E0[v78] & 7) + *(x_BYTE *)(v87 + 13);
			}
			else
			{
				LOWORD(v79) = v78;
				x_BYTE_10B4E0[v78] = 1;
			}
		}
		++v78;
	} while (v78);
	return v79;
}
// 17B4E0: using guessed type __int16 x_WORD_17B4E0;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;

//----- (00044D00) --------------------------------------------------------
int sub_44D00()
{
	unsigned __int16 v0; // cx
	unsigned __int16 v1; // dx
	int result; // eax
	unsigned __int16 v3; // cx
	unsigned int v4; // et2
	char v5; // dl

	v0 = 0;
	x_WORD_17B4E0 = 0;
	do
	{
		LOBYTE(v0) = v0 + 1;
		HIWORD(result) = 0;
		++HIBYTE(v0);
		LOWORD(result) = v0;
		LOBYTE(v0) = v0 - 2;
		HIBYTE(v0) -= 2;
		v1 = v0;
		LOBYTE(v0) = v0 + 1;
		LOBYTE(result) = x_BYTE_11B4E0[v1] - x_BYTE_11B4E0[(unsigned __int16)result] + 32;
		HIBYTE(v3) = HIBYTE(v0) + 1;
		if ((x_BYTE)result == 32)
		{
			result = 9377 * (unsigned __int16)x_WORD_17B4E0;
			LOWORD(result) = result + 9439;
			x_WORD_17B4E0 = result;
			v4 = (unsigned __int16)result;
			BYTE1(result) = (unsigned __int16)((unsigned __int16)result / 9u) >> 8;
			LOBYTE(result) = v4 % 9 + 28;
		}
		else if ((char)result >= 28)
		{
			if ((char)result > 40)
				LOBYTE(result) = (result & 7) + 40;
		}
		else
		{
			LOBYTE(result) = (result & 3) + 28;
		}
		if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308))
		{
			result = 32 - (char)result;
			v5 = result + 32;
		}
		else
		{
			v5 = result;
		}
		LOBYTE(result) = v5;
		x_BYTE_12B4E0[v3] = v5;
		v0 = v3 + 1;
	} while (v0);
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// 17B4E0: using guessed type __int16 x_WORD_17B4E0;

//----- (00044DB0) --------------------------------------------------------
void sub_44DB0()//225db0
{
	__int16 v0; // dx
	__int16 v1; // cx
	Bit16u v2; // bx
	__int16 v3; // ax
	int v4; // edx
	int x; // eax

	v0 = -32000;
	v1 = 32000;
	v2 = 0;
	do
	{
		v3 = x_WORD_15B4E0[v2];
		if (v3 > v0)
			v0 = x_WORD_15B4E0[v2];
		if (v3 < v1)
			v1 = x_WORD_15B4E0[v2];
		v2++;
	} while (v2);
	if (v0)
		v4 = 12845056 / v0;
	else
		v4 = 0;
	do
	{
		x = v4 * x_WORD_15B4E0[v2] >> 16;
		x_WORD_15B4E0[v2] = 0;
		if ((x & 0x8000u) != 0)
			x = 0;
		if (x > 196)
			x = 196;
		x_BYTE_11B4E0[v2++] = x;
	} while (v2);
	//return result;
}

//----- (00044E40) --------------------------------------------------------
void sub_44E40(int a1, unsigned __int8 a2)//225e40
{
	int v2; // edi
	unsigned __int16 v3; // si
	signed int v4; // ecx
	unsigned __int16 v5; // ax
	unsigned __int16 v6; // dx
	Bit16s v7; // eax
	Bit8u v8; // ebx
	//unsigned __int16 i; // ax

	v2 = a1;
	v3 = 0;
	do
	{
		if (x_BYTE_11B4E0[v3])
			x_BYTE_13B4E0[v3] = 5;
		else
			x_BYTE_13B4E0[v3] = 0;
		v3++;
	} while (v3);
LABEL_12:
	if (v2 > 0)
	{
		v4 = 1000;
		while (1)
		{
			v8 = -1;
			v5 = 9377 * x_WORD_17B4E0 + 9439;
			x_WORD_17B4E0 = v5;
			v6 = v5 % -1;
			v7 = v5;
			v7 %= -1;
			v8 = x_BYTE_11B4E0[v7];
			if (!--v4)
				break;
			if (v8 > a2 && x_BYTE_13B4E0[v7])
			{
				v2--;
				sub_44EE0(v8, v6);
				goto LABEL_12;
			}
		}
	}
	do
	{
		//i = v3;
		x_BYTE_10B4E0[v3++] = -1;
	} while (v3);
}
// 17B4E0: using guessed type __int16 x_WORD_17B4E0;

//----- (00044EE0) --------------------------------------------------------
unsigned __int16 sub_44EE0(int a1, int a2)//225ee0
{
	int v2; // eax
	unsigned __int16 v3; // dx
	unsigned __int8 v4; // dh
	unsigned __int16 v5; // si
	int v6; // esi
	unsigned __int8 v7; // dl
	unsigned __int16 result; // ax

	v2 = a2;
	v3 = 0;
	do
		x_BYTE_10B4E0[v3++] = 3;
	while (v3);
	v4 = x_BYTE_11B4E0[(unsigned __int16)a2];
	do
	{
		v5 = v2;
		--BYTE1(v2);
		x_BYTE_10B4E0[v5] = 0;
		v6 = v5;
		LOWORD(v6) = v2;
		v7 = -1;
		if (x_BYTE_10B4E0[(unsigned __int16)v2] && x_BYTE_11B4E0[v6] < 0xFFu)
		{
			v7 = x_BYTE_11B4E0[v6];
			a1 = v2;
		}
		LOBYTE(v2) = v2 + 1;
		if (x_BYTE_10B4E0[(unsigned __int16)v2] && v7 > x_BYTE_11B4E0[(unsigned __int16)v2])
		{
			v7 = x_BYTE_11B4E0[(unsigned __int16)v2];
			a1 = v2;
		}
		++BYTE1(v2);
		if (x_BYTE_10B4E0[(unsigned __int16)v2] && v7 > x_BYTE_11B4E0[(unsigned __int16)v2])
		{
			v7 = x_BYTE_11B4E0[(unsigned __int16)v2];
			a1 = v2;
		}
		++BYTE1(v2);
		if (x_BYTE_10B4E0[(unsigned __int16)v2] && v7 > x_BYTE_11B4E0[(unsigned __int16)v2])
		{
			v7 = x_BYTE_11B4E0[(unsigned __int16)v2];
			a1 = v2;
		}
		LOBYTE(v2) = v2 - 1;
		if (x_BYTE_10B4E0[(unsigned __int16)v2] && v7 > x_BYTE_11B4E0[(unsigned __int16)v2])
		{
			v7 = x_BYTE_11B4E0[(unsigned __int16)v2];
			a1 = v2;
		}
		LOBYTE(v2) = v2 - 1;
		if (x_BYTE_10B4E0[(unsigned __int16)v2] && v7 > x_BYTE_11B4E0[(unsigned __int16)v2])
		{
			v7 = x_BYTE_11B4E0[(unsigned __int16)v2];
			a1 = v2;
		}
		--BYTE1(v2);
		if (x_BYTE_10B4E0[(unsigned __int16)v2] && v7 > x_BYTE_11B4E0[(unsigned __int16)v2])
		{
			v7 = x_BYTE_11B4E0[(unsigned __int16)v2];
			a1 = v2;
		}
		--BYTE1(v2);
		if (x_BYTE_10B4E0[(unsigned __int16)v2] && v7 > x_BYTE_11B4E0[(unsigned __int16)v2])
		{
			v7 = x_BYTE_11B4E0[(unsigned __int16)v2];
			a1 = v2;
		}
		if (!x_BYTE_13B4E0[(unsigned __int16)a1] || v7 == -1)
			break;
		if (v7 > v4)
			x_BYTE_11B4E0[(unsigned __int16)a1] = v4;
		v4 = x_BYTE_11B4E0[(unsigned __int16)a1];
		v2 = a1;
	} while (v4);
	result = 0;
	do
	{
		if (!x_BYTE_10B4E0[result])
			x_BYTE_13B4E0[result] = 0;
		++result;
	} while (result);
	return result;
}

//----- (00045060) --------------------------------------------------------
unsigned __int8 sub_45060(unsigned __int8 a1, unsigned __int8 a2)//226060
{
	unsigned __int16 v2; // dx
	unsigned __int8 result; // al
	unsigned __int8 v4; // ah
	unsigned __int16 v5; // dx

	qmemcpy(x_BYTE_10B4E0, x_BYTE_13B4E0, (unsigned int)sub_10000);
	v2 = 0;
	do
	{
		result = 0;
		v4 = -1;
		if (x_BYTE_11B4E0[v2])
			result = x_BYTE_11B4E0[v2];
		if (x_BYTE_11B4E0[v2] < 0xFFu)
			v4 = x_BYTE_11B4E0[v2];
		--HIBYTE(v2);
		if (result < x_BYTE_11B4E0[v2])
			result = x_BYTE_11B4E0[v2];
		if (v4 > x_BYTE_11B4E0[v2])
			v4 = x_BYTE_11B4E0[v2];
		LOBYTE(v2) = v2 + 1;
		if (result < x_BYTE_11B4E0[v2])
			result = x_BYTE_11B4E0[v2];
		if (v4 > x_BYTE_11B4E0[v2])
			v4 = x_BYTE_11B4E0[v2];
		++HIBYTE(v2);
		if (result < x_BYTE_11B4E0[v2])
			result = x_BYTE_11B4E0[v2];
		if (v4 > x_BYTE_11B4E0[v2])
			v4 = x_BYTE_11B4E0[v2];
		++HIBYTE(v2);
		if (result < x_BYTE_11B4E0[v2])
			result = x_BYTE_11B4E0[v2];
		if (v4 > x_BYTE_11B4E0[v2])
			v4 = x_BYTE_11B4E0[v2];
		LOBYTE(v2) = v2 - 1;
		if (result < x_BYTE_11B4E0[v2])
			result = x_BYTE_11B4E0[v2];
		if (v4 > x_BYTE_11B4E0[v2])
			v4 = x_BYTE_11B4E0[v2];
		LOBYTE(v2) = v2 - 1;
		if (result < x_BYTE_11B4E0[v2])
			result = x_BYTE_11B4E0[v2];
		if (v4 > x_BYTE_11B4E0[v2])
			v4 = x_BYTE_11B4E0[v2];
		--HIBYTE(v2);
		if (result < x_BYTE_11B4E0[v2])
			result = x_BYTE_11B4E0[v2];
		if (v4 > x_BYTE_11B4E0[v2])
			v4 = x_BYTE_11B4E0[v2];
		--HIBYTE(v2);
		if (result < x_BYTE_11B4E0[v2])
			result = x_BYTE_11B4E0[v2];
		if (v4 > x_BYTE_11B4E0[v2])
			v4 = x_BYTE_11B4E0[v2];
		LOBYTE(v2) = v2 + 1;
		HIBYTE(v5) = HIBYTE(v2) + 1;
		if (result < a1 && result - v4 <= a2)
		{
			if (x_BYTE_13B4E0[v5])
				x_BYTE_13B4E0[v5] = 5;
		}
		v2 = v5 + 1;
	} while (v2);
	return result;
}
// 10000: using guessed type void /*__noreturn*/ sub_10000();

//----- (00045210) --------------------------------------------------------
char sub_45210(unsigned __int8 a1, unsigned __int8 a2)//226210
{
	unsigned __int16 v2; // dx
	int v3; // eax
	char v4; // t1
	unsigned __int8 v5; // bl
	unsigned __int8 v6; // bh
	unsigned __int16 v7; // dx
	int v8; // ecx

	qmemcpy(x_BYTE_10B4E0, x_BYTE_13B4E0, (unsigned int)sub_10000);
	v2 = 0;
	do
	{
		LOWORD(v3) = -256;
		v4 = x_BYTE_13B4E0[v2];
		v5 = 0;
		v6 = 0;
		if (x_BYTE_11B4E0[v2] > 0u)
			LOBYTE(v3) = x_BYTE_11B4E0[v2];
		if (x_BYTE_11B4E0[v2] < 0xFFu)
			BYTE1(v3) = x_BYTE_11B4E0[v2];
		--HIBYTE(v2);
		if ((unsigned __int8)v3 < x_BYTE_11B4E0[v2])
			LOBYTE(v3) = x_BYTE_11B4E0[v2];
		if (BYTE1(v3) > x_BYTE_11B4E0[v2])
			BYTE1(v3) = x_BYTE_11B4E0[v2];
		if (x_BYTE_13B4E0[v2] == 5)
			v6 = 1;
		if (x_BYTE_13B4E0[v2] == 2)
			v5 = 1;
		LOBYTE(v2) = v2 + 1;
		if ((unsigned __int8)v3 < x_BYTE_11B4E0[v2])
			LOBYTE(v3) = x_BYTE_11B4E0[v2];
		if (BYTE1(v3) > x_BYTE_11B4E0[v2])
			BYTE1(v3) = x_BYTE_11B4E0[v2];
		if (x_BYTE_13B4E0[v2] == 5)
			++v6;
		if (x_BYTE_13B4E0[v2] == 2)
			++v5;
		++HIBYTE(v2);
		if ((unsigned __int8)v3 < x_BYTE_11B4E0[v2])
			LOBYTE(v3) = x_BYTE_11B4E0[v2];
		if (BYTE1(v3) > x_BYTE_11B4E0[v2])
			BYTE1(v3) = x_BYTE_11B4E0[v2];
		if (x_BYTE_13B4E0[v2] == 5)
			++v6;
		if (x_BYTE_13B4E0[v2] == 2)
			++v5;
		++HIBYTE(v2);
		if ((unsigned __int8)v3 < x_BYTE_11B4E0[v2])
			LOBYTE(v3) = x_BYTE_11B4E0[v2];
		if (BYTE1(v3) > x_BYTE_11B4E0[v2])
			BYTE1(v3) = x_BYTE_11B4E0[v2];
		if (x_BYTE_13B4E0[v2] == 5)
			++v6;
		if (x_BYTE_13B4E0[v2] == 2)
			++v5;
		LOBYTE(v2) = v2 - 1;
		if ((unsigned __int8)v3 < x_BYTE_11B4E0[v2])
			LOBYTE(v3) = x_BYTE_11B4E0[v2];
		if (BYTE1(v3) > x_BYTE_11B4E0[v2])
			BYTE1(v3) = x_BYTE_11B4E0[v2];
		if (x_BYTE_13B4E0[v2] == 5)
			++v6;
		if (x_BYTE_13B4E0[v2] == 2)
			++v5;
		LOBYTE(v2) = v2 - 1;
		if ((unsigned __int8)v3 < x_BYTE_11B4E0[v2])
			LOBYTE(v3) = x_BYTE_11B4E0[v2];
		if (BYTE1(v3) > x_BYTE_11B4E0[v2])
			BYTE1(v3) = x_BYTE_11B4E0[v2];
		if (x_BYTE_13B4E0[v2] == 5)
			++v6;
		if (x_BYTE_13B4E0[v2] == 2)
			++v5;
		--HIBYTE(v2);
		if ((unsigned __int8)v3 < x_BYTE_11B4E0[v2])
			LOBYTE(v3) = x_BYTE_11B4E0[v2];
		if (BYTE1(v3) > x_BYTE_11B4E0[v2])
			BYTE1(v3) = x_BYTE_11B4E0[v2];
		if (x_BYTE_13B4E0[v2] == 5)
			++v6;
		if (x_BYTE_13B4E0[v2] == 2)
			++v5;
		--HIBYTE(v2);
		if ((unsigned __int8)v3 < x_BYTE_11B4E0[v2])
			LOBYTE(v3) = x_BYTE_11B4E0[v2];
		if (BYTE1(v3) > x_BYTE_11B4E0[v2])
			BYTE1(v3) = x_BYTE_11B4E0[v2];
		if (x_BYTE_13B4E0[v2] == 5)
			++v6;
		if (x_BYTE_13B4E0[v2] == 2)
			++v5;
		LOBYTE(v2) = v2 + 1;
		HIBYTE(v7) = HIBYTE(v2) + 1;
		if ((unsigned __int8)v3 < a1)
		{
			v8 = (unsigned __int8)v3 - BYTE1(v3);
			LOBYTE(v3) = a2;
			if (v8 <= a2 && x_BYTE_13B4E0[v7] == 5)
			{
				v3 = v6 + v5;
				if (v3 == 8)
					x_BYTE_13B4E0[v7] = 2;
			}
		}
		v2 = v7 + 1;
	} while (v2);
	return v3;
}
// 10000: using guessed type void /*__noreturn*/ sub_10000();

//----- (000454F0) --------------------------------------------------------
unsigned __int16 sub_454F0(unsigned __int8 a1, unsigned __int8 a2)//2264f0
{
	unsigned __int16 result; // ax
	unsigned __int8 v3; // dh
	unsigned __int8 v4; // dl
	unsigned __int16 v5; // ax
	unsigned __int16 v6; // ax

	// fix if begin
	v5 = 0;
	v6 = 0;
	// end

	result = 0;
	do
	{
		if (x_BYTE_11B4E0[result] > a1)
		{
			v3 = 0;
			v4 = -1;
			if (x_BYTE_11B4E0[result])
				v3 = x_BYTE_11B4E0[result];
			if (x_BYTE_11B4E0[result] < 0xFFu)
				v4 = x_BYTE_11B4E0[result];
			--HIBYTE(result);
			if (v3 < x_BYTE_11B4E0[result])
				v3 = x_BYTE_11B4E0[result];
			if (v4 > x_BYTE_11B4E0[result])
				v4 = x_BYTE_11B4E0[result];
			LOBYTE(result) = result + 1;
			++HIBYTE(result);
			if (v3 < x_BYTE_11B4E0[result])
				v3 = x_BYTE_11B4E0[v5];
			if (v4 > x_BYTE_11B4E0[v5])
				v4 = x_BYTE_11B4E0[v5];
			++HIBYTE(v5);
			LOBYTE(v5) = v5 - 1;
			if (v3 < x_BYTE_11B4E0[v5])
				v3 = x_BYTE_11B4E0[v6];
			if (v4 > x_BYTE_11B4E0[v6])
				v4 = x_BYTE_11B4E0[v6];
			LOBYTE(result) = v6 - 1;
			--HIBYTE(result);
			if (v3 < x_BYTE_11B4E0[result])
				v3 = x_BYTE_11B4E0[result];
			if (v4 > x_BYTE_11B4E0[result])
				v4 = x_BYTE_11B4E0[result];
			LOBYTE(result) = result + 1;
			if (x_BYTE_13B4E0[result])
			{
				if (v3 - v4 < a2)
					x_BYTE_13B4E0[result] = 6;
			}
		}
		++result;
	} while (result);
	return result;
}

//----- (00045600) --------------------------------------------------------
unsigned __int16 sub_45600(unsigned __int8 a1)//226600
{
	unsigned __int16 result; // ax
	unsigned __int8 v2; // dh
	unsigned __int8 v3; // dl
	unsigned __int16 v4; // ax
	unsigned __int16 v5; // ax
	unsigned __int16 v6; // ax
	__int16 v7; // bx
	char v8; // dh
	char v9; // dl
	char v10; // t0
	char v11; // t0
	char v12; // t0
	char v13; // t0
	char v14; // t0
	char v15; // t0
	char v16; // t0
	char v17; // t0
	char v18; // t0
	char v19; // t0
	char v20; // t0
	char v21; // t0
	char v22; // t0
	char v23; // t0
	char v24; // t0
	char v25; // t0
	char v26; // t0
	char v27; // t0
	char v28; // t0
	char v29; // t0
	char v30; // t0
	char v31; // t0
	char v32; // t0
	char v33; // t0

	// fix if begin
	v4 = 0;
	v5 = 0;
	v6 = 0;
	// end

	qmemcpy(x_BYTE_10B4E0, x_BYTE_13B4E0, (unsigned int)sub_10000);
	result = 0;
	do
	{
		v2 = 0;
		v3 = -1;
		if (x_BYTE_11B4E0[result])
			v2 = x_BYTE_11B4E0[result];
		if (x_BYTE_11B4E0[result] < 0xFFu)
			v3 = x_BYTE_11B4E0[result];
		--HIBYTE(result);
		if (v2 < x_BYTE_11B4E0[result])
			v2 = x_BYTE_11B4E0[result];
		if (v3 > x_BYTE_11B4E0[result])
			v3 = x_BYTE_11B4E0[result];
		LOBYTE(result) = result + 1;
		++HIBYTE(result);
		if (v2 < x_BYTE_11B4E0[result])
			v2 = x_BYTE_11B4E0[v4];
		if (v3 > x_BYTE_11B4E0[v4])
			v3 = x_BYTE_11B4E0[v4];
		++HIBYTE(v4);
		LOBYTE(v4) = v4 - 1;
		if (v2 < x_BYTE_11B4E0[v4])
			v2 = x_BYTE_11B4E0[v5];
		if (v3 > x_BYTE_11B4E0[v5])
			v3 = x_BYTE_11B4E0[v5];
		LOBYTE(v5) = v5 - 1;
		--HIBYTE(v5);
		if (v2 < x_BYTE_11B4E0[v5])
			v2 = x_BYTE_11B4E0[v6];
		if (v3 > x_BYTE_11B4E0[v6])
			v3 = x_BYTE_11B4E0[v6];
		LOBYTE(v6) = v6 + 1;
		if (x_BYTE_13B4E0[v6] && v2 - v3 >= a1)
			x_BYTE_13B4E0[v6] = 1;
		result = v6 + 1;
	} while (result);
	do
	{
		if (x_BYTE_13B4E0[result] != 6)
			goto LABEL_100;
		v7 = 0;
		--HIBYTE(result);
		v8 = 0;
		v9 = 0;
		if (x_BYTE_13B4E0[result] == 3)
			HIBYTE(v7) = 1;
		if (x_BYTE_13B4E0[result] == 2)
			v9 = 1;
		if (x_BYTE_13B4E0[result] == 5)
			LOBYTE(v7) = 1;
		v10 = x_BYTE_13B4E0[result];
		v11 = x_BYTE_13B4E0[result];
		if (x_BYTE_13B4E0[result] == 4)
			v8 = 1;
		v12 = x_BYTE_13B4E0[result];
		LOBYTE(result) = result + 1;
		if (x_BYTE_13B4E0[result] == 3)
			++HIBYTE(v7);
		if (x_BYTE_13B4E0[result] == 2)
			++v9;
		if (x_BYTE_13B4E0[result] == 5)
			LOBYTE(v7) = v7 + 1;
		v13 = x_BYTE_13B4E0[result];
		v14 = x_BYTE_13B4E0[result];
		if (x_BYTE_13B4E0[result] == 4)
			++v8;
		v15 = x_BYTE_13B4E0[result];
		++HIBYTE(result);
		if (x_BYTE_13B4E0[result] == 3)
			++HIBYTE(v7);
		if (x_BYTE_13B4E0[result] == 2)
			++v9;
		if (x_BYTE_13B4E0[result] == 5)
			LOBYTE(v7) = v7 + 1;
		v16 = x_BYTE_13B4E0[result];
		v17 = x_BYTE_13B4E0[result];
		if (x_BYTE_13B4E0[result] == 4)
			++v8;
		v18 = x_BYTE_13B4E0[result];
		++HIBYTE(result);
		if (x_BYTE_13B4E0[result] == 3)
			++HIBYTE(v7);
		if (x_BYTE_13B4E0[result] == 2)
			++v9;
		if (x_BYTE_13B4E0[result] == 5)
			LOBYTE(v7) = v7 + 1;
		v19 = x_BYTE_13B4E0[result];
		v20 = x_BYTE_13B4E0[result];
		if (x_BYTE_13B4E0[result] == 4)
			++v8;
		v21 = x_BYTE_13B4E0[result];
		LOBYTE(result) = result - 1;
		if (x_BYTE_13B4E0[result] == 3)
			++HIBYTE(v7);
		if (x_BYTE_13B4E0[result] == 2)
			++v9;
		if (x_BYTE_13B4E0[result] == 5)
			LOBYTE(v7) = v7 + 1;
		v22 = x_BYTE_13B4E0[result];
		v23 = x_BYTE_13B4E0[result];
		if (x_BYTE_13B4E0[result] == 4)
			++v8;
		v24 = x_BYTE_13B4E0[result];
		LOBYTE(result) = result - 1;
		if (x_BYTE_13B4E0[result] == 3)
			++HIBYTE(v7);
		if (x_BYTE_13B4E0[result] == 2)
			++v9;
		if (x_BYTE_13B4E0[result] == 5)
			LOBYTE(v7) = v7 + 1;
		v25 = x_BYTE_13B4E0[result];
		v26 = x_BYTE_13B4E0[result];
		if (x_BYTE_13B4E0[result] == 4)
			++v8;
		v27 = x_BYTE_13B4E0[result];
		--HIBYTE(result);
		if (x_BYTE_13B4E0[result] == 3)
			++HIBYTE(v7);
		if (x_BYTE_13B4E0[result] == 2)
			++v9;
		if (x_BYTE_13B4E0[result] == 5)
			LOBYTE(v7) = v7 + 1;
		v28 = x_BYTE_13B4E0[result];
		v29 = x_BYTE_13B4E0[result];
		if (x_BYTE_13B4E0[result] == 4)
			++v8;
		v30 = x_BYTE_13B4E0[result];
		--HIBYTE(result);
		if (x_BYTE_13B4E0[result] == 3)
			++HIBYTE(v7);
		if (x_BYTE_13B4E0[result] == 2)
			++v9;
		if (x_BYTE_13B4E0[result] == 5)
			LOBYTE(v7) = v7 + 1;
		v31 = x_BYTE_13B4E0[result];
		v32 = x_BYTE_13B4E0[result];
		if (x_BYTE_13B4E0[result] == 4)
			++v8;
		v33 = x_BYTE_13B4E0[result];
		LOBYTE(result) = result + 1;
		++HIBYTE(result);
		if (HIBYTE(v7))
		{
			if (v9 || (x_BYTE)v7 || v8)
				goto LABEL_99;
		}
		else if (v9 || (x_BYTE)v7 && v8)
		{
		LABEL_99:
			x_BYTE_13B4E0[result] = 1;
			goto LABEL_100;
		}
	LABEL_100:
		++result;
	} while (result);
	return result;
}
// 10000: using guessed type void /*__noreturn*/ sub_10000();

//----- (00045AA0) --------------------------------------------------------
unsigned __int16 sub_45AA0()//226aa0
{
	unsigned __int16 result; // ax
	char v1; // dh
	unsigned __int16 v2; // cx
	unsigned __int8 v3; // dl
	unsigned __int8 v4; // bl
	unsigned __int16 v5; // cx
	unsigned __int16 v6; // cx
	unsigned __int16 v7; // cx
	unsigned __int16 v8; // cx
	char v9; // [esp+0h] [ebp-4h]

	do
	{
		result = 0;
		v9 = 0;
		do
		{
			v1 = 0;
			if (!x_BYTE_13B4E0[result])
				v1 = 1;
			v2 = result;
			LOBYTE(result) = result + 1;
			v3 = x_BYTE_11B4E0[v2];
			v4 = x_BYTE_11B4E0[v2];
			if (!x_BYTE_13B4E0[result])
				++v1;
			if (v3 > x_BYTE_11B4E0[result])
				v3 = x_BYTE_11B4E0[result];
			if (v4 < x_BYTE_11B4E0[result])
				v4 = x_BYTE_11B4E0[result];
			++HIBYTE(result);
			if (!x_BYTE_13B4E0[result])
				++v1;
			if (v3 > x_BYTE_11B4E0[result])
				v3 = x_BYTE_11B4E0[result];
			if (v4 < x_BYTE_11B4E0[result])
				v4 = x_BYTE_11B4E0[result];
			LOBYTE(result) = result - 1;
			if (!x_BYTE_13B4E0[result])
				++v1;
			if (v3 > x_BYTE_11B4E0[result])
				v3 = x_BYTE_11B4E0[result];
			if (v4 < x_BYTE_11B4E0[result])
				v4 = x_BYTE_11B4E0[result];
			--HIBYTE(result);
			if (v4 != v3 && v1 == 4)
			{
				v9 = 1;
				v5 = result;
				LOBYTE(result) = result + 1;
				x_BYTE_11B4E0[v5] = v3;
				v6 = result;
				++HIBYTE(result);
				x_BYTE_11B4E0[v6] = v3;
				v7 = result;
				LOBYTE(result) = result - 1;
				x_BYTE_11B4E0[v7] = v3;
				v8 = result;
				--HIBYTE(result);
				x_BYTE_11B4E0[v8] = v3;
			}
			++result;
		} while (result);
	} while (v9);
	return result;
}

//----- (00045BE0) --------------------------------------------------------
char sub_45BE0(char a1, char a2, unsigned __int16 a3)//226be0
{
	unsigned __int16 v3; // ax
	unsigned __int8 v4; // bl
	unsigned __int8 v5; // dh
	unsigned __int8 v6; // bh
	unsigned __int8 v7; // al
	signed int v8; // edi
	char result; // al

	HIBYTE(v3) = HIBYTE(a3);
	v4 = -1;
	v5 = 0;
	if (x_BYTE_11B4E0[a3])
	{
		v5 = x_BYTE_11B4E0[a3];
		a1 = 0;
	}
	if (x_BYTE_11B4E0[a3] < 0xFFu)
		v4 = x_BYTE_11B4E0[a3];
	LOBYTE(v3) = a3 + 1;
	if (x_BYTE_11B4E0[v3] > v5)
	{
		v5 = x_BYTE_11B4E0[v3];
		a1 = 1;
	}
	if (x_BYTE_11B4E0[v3] < v4)
		v4 = x_BYTE_11B4E0[v3];
	HIBYTE(v3) = HIBYTE(a3) + 1;
	if (x_BYTE_11B4E0[v3] > v5)
	{
		v5 = x_BYTE_11B4E0[v3];
		a1 = 2;
	}
	if (x_BYTE_11B4E0[v3] < v4)
		v4 = x_BYTE_11B4E0[v3];
	LOBYTE(v3) = a3;
	if (x_BYTE_11B4E0[v3] > v5)
	{
		v5 = x_BYTE_11B4E0[v3];
		a1 = 3;
	}
	if (x_BYTE_11B4E0[v3] < v4)
		v4 = x_BYTE_11B4E0[v3];
	HIBYTE(v3) = HIBYTE(a3);
	v6 = 0;
	if (a1 && x_BYTE_11B4E0[v3])
	{
		v6 = x_BYTE_11B4E0[v3];
		a2 = 0;
	}
	LOBYTE(v3) = a3 + 1;
	if (a1 != 1 && x_BYTE_11B4E0[v3] > v6)
	{
		v6 = x_BYTE_11B4E0[v3];
		a2 = 1;
	}
	HIBYTE(v3) = HIBYTE(a3) + 1;
	if (a1 != 2 && x_BYTE_11B4E0[v3] > v6)
	{
		v6 = x_BYTE_11B4E0[v3];
		a2 = 2;
	}
	LOBYTE(v3) = a3;
	if (a1 != 3)
	{
		v7 = x_BYTE_11B4E0[v3];
		if (v7 > v6)
		{
			a2 = 3;
			v6 = v7;
		}
	}
	v8 = 0;
	if (v5 - v4 <= 8)
		v8 = 1;
	if (v5 - v6 >= 8)
	{
		result = a1;
	LABEL_44:
		x_DWORD_D47DC = v8;
		return result;
	}
	if ((unsigned __int8)a1 > 3u)
	{
		result = 0;
		goto LABEL_44;
	}
	switch (a1)
	{
	case 0:
		if (a2 != 1)
			goto LABEL_42;
		goto LABEL_36;
	case 1:
		if (a2 == 2)
			goto LABEL_38;
	LABEL_36:
		result = 4;
		x_DWORD_D47DC = v8;
		return result;
	case 2:
		if (a2 == 3)
			goto LABEL_40;
	LABEL_38:
		result = 5;
		x_DWORD_D47DC = v8;
		break;
	case 3:
		if (a2)
		{
		LABEL_40:
			result = 6;
			x_DWORD_D47DC = v8;
		}
		else
		{
		LABEL_42:
			result = 7;
			x_DWORD_D47DC = v8;
		}
		break;
	}
	return result;
}
// D47DC: using guessed type int x_DWORD_D47DC;

//----- (00045DC0) --------------------------------------------------------
char sub_45DC0(char a1, char a2, unsigned __int16 a3, unsigned __int8 a4)//226dc0
{
	unsigned __int16 v4; // bx
	int v5; // eax
	char v6; // ch
	char *v7; // eax
	char v8; // al
	char v9; // ah
	unsigned __int8 v10; // al
	char v11; // cl
	unsigned __int8 v12; // dh
	unsigned __int8 v13; // dh
	char v14; // cl
	unsigned __int8 v15; // dh
	char v16; // cl
	unsigned __int8 v17; // dh
	char v18; // bl
	unsigned __int16 v19; // ax
	char v20; // ch
	unsigned __int16 v21; // ax
	char v22; // dl
	unsigned __int8 v24; // [esp+0h] [ebp-4h]

	HIBYTE(v4) = HIBYTE(a3);
	v24 = 8 * ((HIBYTE(a3) + a3) & 1);
	if (a4 >= 8u)
	{
		switch (a4)
		{
		case 8u:
			x_BYTE_10B4E0[a3] = 8;
			break;
		case 9u:
			x_BYTE_10B4E0[a3] = 9;
			break;
		case 0xAu:
			v8 = sub_45BE0(a1, a2, a3);
			v9 = v8;
			if (x_DWORD_D47DC)
				v9 = v8 + 8;
			v10 = v9;
			goto LABEL_28;
		case 0xBu:
			v10 = sub_45BE0(a1, a2, a3) + 16;
			if (x_DWORD_D47DC)
				v10 += 8;
			goto LABEL_28;
		case 0xCu:
			v10 = sub_45BE0(a1, a2, a3) + 32;
			if (x_DWORD_D47DC)
				v10 += 8;
			goto LABEL_28;
		case 0xDu:
			v10 = sub_45BE0(a1, a2, a3) + 48;
			if (x_DWORD_D47DC)
				v10 += 8;
			goto LABEL_28;
		case 0xEu:
			v10 = sub_45BE0(a1, a2, a3) + 64;
			if (x_DWORD_D47DC)
				v10 += 8;
		LABEL_28:
			v7 = (char *)&unk_D4AB0 + 2 * v10;
			goto LABEL_29;
		case 0xFu:
			x_BYTE_10B4E0[a3] = 11;
			break;
		case 0x10u:
			v6 = x_BYTE_10B4E0[a3];
			if (v6 == 10 || v6 == 11 || v6 == 12)
				break;
			v7 = (char *)&unk_D4A30 + 2 * (unsigned __int8)sub_45BE0(a1, a2, a3);
			goto LABEL_29;
		case 0x11u:
			v7 = (char *)&unk_D4A70 + 2 * (unsigned __int8)sub_45BE0(a1, a2, a3);
			goto LABEL_29;
		case 0x12u:
			v7 = (char *)&unk_D4A80 + 2 * (v24 + (unsigned __int8)sub_45BE0(a1, a2, a3));
			goto LABEL_29;
		case 0x13u:
			v7 = (char *)&unk_D4A80 + 2 * ((unsigned __int8)sub_45BE0(a1, a2, a3) + v24) + 16;
			goto LABEL_29;
		case 0x14u:
			v7 = (char *)&unk_D4A40 + 2 * (unsigned __int8)sub_45BE0(a1, a2, a3);
			goto LABEL_29;
		case 0x15u:
			v7 = (char *)&unk_D4A40 + 2 * (unsigned __int8)sub_45BE0(a1, a2, a3) + 16;
			goto LABEL_29;
		case 0x16u:
			v7 = (char *)&unk_D4A40 + 2 * (unsigned __int8)sub_45BE0(a1, a2, a3) + 32;
		LABEL_29:
			x_BYTE_10B4E0[a3] = *v7;
			x_BYTE_13B4E0[a3] = x_BYTE_13B4E0[a3] & 0x8F | v7[1];
			break;
		default:
			break;
		}
		v11 = x_BYTE_13B4E0[a3] | 0x80;
		x_BYTE_13B4E0[a3] = v11;
		if (x_BYTE_D41B6)
		{
			v12 = x_BYTE_11B4E0[a3];
			if ((unsigned __int8)x_BYTE_14B4E0[a3] > v12)
			{
				x_BYTE_13B4E0[a3] = v11 & 0xF7;
			}
			else
			{
				x_BYTE_13B4E0[a3] = v11 | 8;
				x_BYTE_14B4E0[a3] = v12 - 1;
			}
			LOBYTE(v4) = a3 + 1;
			v13 = x_BYTE_11B4E0[v4];
			if ((unsigned __int8)x_BYTE_14B4E0[v4] > v13)
			{
				x_BYTE_13B4E0[v4] &= 0xF7u;
			}
			else
			{
				v14 = x_BYTE_13B4E0[v4] | 8;
				x_BYTE_14B4E0[v4] = v13 - 1;
				x_BYTE_13B4E0[v4] = v14;
			}
			HIBYTE(v4) = HIBYTE(a3) + 1;
			v15 = x_BYTE_11B4E0[v4];
			if ((unsigned __int8)x_BYTE_14B4E0[v4] > v15)
			{
				x_BYTE_13B4E0[v4] &= 0xF7u;
			}
			else
			{
				v16 = x_BYTE_13B4E0[v4] | 8;
				x_BYTE_14B4E0[v4] = v15 - 1;
				x_BYTE_13B4E0[v4] = v16;
			}
			LOBYTE(v4) = a3;
			v5 = v4;
			v17 = x_BYTE_11B4E0[v4];
			if ((unsigned __int8)x_BYTE_14B4E0[v4] <= v17)
			{
				v18 = x_BYTE_13B4E0[v4] | 8;
				x_BYTE_14B4E0[v5] = v17 - 1;
				x_BYTE_13B4E0[v5] = v18;
				return v5;
			}
		}
		else
		{
			LOBYTE(v4) = a3 + 1;
			x_BYTE_13B4E0[a3] = v11 & 0xF7;
			v19 = v4;
			v20 = x_BYTE_13B4E0[v4] & 0xF7;
			HIBYTE(v4) = HIBYTE(a3) + 1;
			x_BYTE_13B4E0[v19] = v20;
			v21 = v4;
			v22 = x_BYTE_13B4E0[v4] & 0xF7;
			LOBYTE(v4) = a3;
			x_BYTE_13B4E0[v21] = v22;
			v5 = v21;
			LOWORD(v5) = v4;
		}
		x_BYTE_13B4E0[v5] &= 0xF7u;
		return v5;
	}
	x_BYTE_13B4E0[a3] = a4 | x_BYTE_13B4E0[a3] & 0xF0;
	LOBYTE(v5) = sub_462A0(a3, a3);
	return v5;
}
// D41B6: using guessed type char x_BYTE_D41B6;
// D47DC: using guessed type int x_DWORD_D47DC;

//----- (00046180) --------------------------------------------------------
unsigned __int16 sub_46180(unsigned __int16 a1, char a2)//227180
{
	unsigned __int16 v2; // ax
	unsigned __int16 v3; // bx
	unsigned __int16 v4; // bx
	unsigned __int16 v5; // bx
	unsigned __int16 result; // ax
	char v7; // bl
	char i; // bh
	unsigned __int16 v9; // si
	int v10; // edx

	HIBYTE(v2) = HIBYTE(a1);
	LOBYTE(v2) = a1 - 1;
	x_BYTE_10B4E0[a1] = a2;
	v3 = v2;
	HIBYTE(result) = HIBYTE(a1) - 1;
	x_BYTE_10B4E0[v3] = a2;
	v4 = result;
	LOBYTE(result) = a1;
	x_BYTE_10B4E0[v4] = a2;
	v5 = result;
	LOBYTE(result) = a1 - 1;
	x_BYTE_10B4E0[v5] = a2;
	v7 = 3;
	do
	{
		for (i = 3; i; i--)
		{
			LOBYTE(result) = result + 1;
			++HIBYTE(result);
			LOWORD(v10) = result;
			LOBYTE(result) = result - 2;
			HIBYTE(result) -= 2;
			v9 = result;
			LOBYTE(result) = result + 1;
			LOBYTE(v10) = x_BYTE_11B4E0[v9] - x_BYTE_11B4E0[(unsigned __int16)v10] + 32;
			++HIBYTE(result);
			if ((char)v10 >= 28)
			{
				if ((char)v10 > 40)
					LOBYTE(v10) = (v10 & 7) + 40;
			}
			else
			{
				LOBYTE(v10) = (v10 & 3) + 28;
			}
			if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308))
				v10 = 32 - (char)v10 + 32;
			x_BYTE_12B4E0[result] = v10;
			if (x_BYTE_D41B6 && (unsigned __int8)x_BYTE_14B4E0[result] <= x_BYTE_11B4E0[result])
			{
				x_BYTE_14B4E0[result] = x_BYTE_11B4E0[result] - 1;
				x_BYTE_13B4E0[result] |= 8u;
			}
			else
			{
				x_BYTE_13B4E0[result] &= 0xF7u;
			}
			LOBYTE(result) = result + 1;
		}
		LOBYTE(result) = result - 3;
		--v7;
		++HIBYTE(result);
	} while (v7);
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41B6: using guessed type char x_BYTE_D41B6;

//----- (000462A0) --------------------------------------------------------
char sub_462A0(unsigned __int16 a1, __int16 a2)//2272a0
{
	unsigned __int16 v2; // cx
	bool v3; // zf
	int v4; // eax
	unsigned __int16 v5; // cx
	int v6; // edx
	unsigned __int16 v7; // ax
	int v8; // edx
	int v9; // ebx
	int v10; // eax
	int v11; // edx
	char v12; // ST10_1
	unsigned __int16 v13; // cx
	char v14; // dh
	char j; // dl
	unsigned __int16 v16; // ax
	unsigned __int16 v17; // bx
	char v18; // al
	char v19; // bl
	unsigned __int8 v20; // bh
	char i; // [esp+0h] [ebp-14h]
	char v23; // [esp+4h] [ebp-10h]
	char v24; // [esp+4h] [ebp-10h]
	char v25; // [esp+8h] [ebp-Ch]
	char v26; // [esp+8h] [ebp-Ch]
	char v27; // [esp+8h] [ebp-Ch]
	char v28; // [esp+Ch] [ebp-8h]
	unsigned __int16 v29; // [esp+24h] [ebp+10h]

	// fix if begin
	v29 = 0;
	// end

	LOBYTE(v4) = a2 - a1 + 1;
	v2 = a1;
	v25 = a2 - a1 + 1;
	BYTE1(v4) = HIBYTE(a2) - HIBYTE(a1) + 1;
	v3 = BYTE1(v4) == 0;
	v23 = HIBYTE(a2) - HIBYTE(a1) + 1;
	while (!v3)
	{
		LOBYTE(v4) = a2 - a1 + 1;
		while ((x_BYTE)v4)
		{
			if (x_BYTE_13B4E0[v2] >= 0)
				x_BYTE_10B4E0[v2] = 1;
			LOBYTE(v2) = v2 - 1;
			if (x_BYTE_13B4E0[v2] >= 0)
				x_BYTE_10B4E0[v2] = 1;
			--HIBYTE(v2);
			if (x_BYTE_13B4E0[v2] >= 0)
				x_BYTE_10B4E0[v2] = 1;
			LOBYTE(v2) = v2 + 1;
			if (x_BYTE_13B4E0[v2] >= 0)
				x_BYTE_10B4E0[v2] = 1;
			++HIBYTE(v2);
			LOBYTE(v4) = v4 - 1;
			LOBYTE(v2) = v2 + 1;
		}
		LOBYTE(v2) = v2 - v25;
		++HIBYTE(v2);
		v3 = --BYTE1(v4) == 0;
	}
	LOBYTE(a1) = a1 - 1;
	--HIBYTE(a1);
	v24 = v23 + 1;
	v28 = v24;
	v5 = a1;
	v26 = v25 + 1;
	while (v28)
	{
		LOBYTE(v4) = v26;
		for (i = v26; i; i--)
		{
			v4 = v5;
			if (x_BYTE_10B4E0[v5] == 1)
			{
				LOBYTE(v5) = v5 + 1;
				v6 = 343 * (x_BYTE_13B4E0[v4] & 7);
				v7 = v5;
				++HIBYTE(v5);
				v8 = 49 * (x_BYTE_13B4E0[v7] & 7) + v6;
				v9 = x_BYTE_13B4E0[v5] & 7;
				LOBYTE(v5) = v5 - 1;
				v10 = x_BYTE_13B4E0[v5] & 7;
				--HIBYTE(v5);
				v11 = 2 * (v10 + 7 * v9 + v8);
				LOBYTE(v10) = x_BYTE_F2CD0[v11];
				x_BYTE_10B4E0[v5] = v10;
				if ((unsigned __int8)v10 >= 8u)
				{
					LOBYTE(v4) = x_BYTE_F2CD1[v11] + (x_BYTE_13B4E0[v5] & 0x87);
				}
				else
				{
					v12 = x_BYTE_13B4E0[v5] & 0x87;
					x_WORD_17B4E0 = 9377 * x_WORD_17B4E0 + 9439;
					LOBYTE(v4) = v12 + 16 * ((unsigned __int16)x_WORD_17B4E0 % 7u);
				}
				x_BYTE_13B4E0[v5] = v4;
			}
			LOBYTE(v5) = v5 + 1;
		}
		LOBYTE(v5) = v5 - v26;
		++HIBYTE(v5);
		--v28;
	}
	v27 = v26 + 1;
	v13 = v29;
	v14 = v24 + 1;
	if (v24 != -1)
	{
		do
		{
			for (j = v27; j; j--)
			{
				LOBYTE(v13) = v13 + 1;
				++HIBYTE(v13);
				v16 = v13;
				LOBYTE(v13) = v13 - 2;
				HIBYTE(v13) -= 2;
				v17 = v13;
				LOBYTE(v13) = v13 + 1;
				v18 = x_BYTE_11B4E0[v17] - x_BYTE_11B4E0[v16] + 32;
				++HIBYTE(v13);
				if (v18 >= 28)
				{
					if (v18 > 40)
						v18 = (v18 & 7) + 40;
				}
				else
				{
					v18 = (v18 & 3) + 28;
				}
				if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308))
					v19 = 32 - v18 + 32;
				else
					v19 = v18;
				v4 = v13;
				x_BYTE_12B4E0[v13] = v19;
				if (x_BYTE_D41B6 && (v20 = x_BYTE_11B4E0[v13], (unsigned __int8)x_BYTE_14B4E0[v13] <= v20))
				{
					x_BYTE_14B4E0[v13] = v20 - 1;
					x_BYTE_13B4E0[v13] |= 8u;
				}
				else
				{
					x_BYTE_13B4E0[v13] &= 0xF7u;
				}
				LOBYTE(v13) = v13 + 1;
			}
			LOBYTE(v13) = v13 - v27;
			--v14;
			++HIBYTE(v13);
		} while (v14);
	}
	return v4;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41B6: using guessed type char x_BYTE_D41B6;
// 17B4E0: using guessed type __int16 x_WORD_17B4E0;

//----- (00046570) --------------------------------------------------------
char sub_46570(unsigned __int16 a1, __int16 a2)//227570
{
	unsigned __int16 v2; // cx
	bool v3; // zf
	int v4; // eax
	unsigned __int16 v5; // dx
	unsigned __int16 v6; // dx
	unsigned __int16 v7; // dx
	unsigned __int16 v8; // dx
	unsigned __int16 v9; // cx
	int v10; // edx
	unsigned __int16 v11; // ax
	int v12; // edx
	int v13; // ebx
	int v14; // eax
	int v15; // edx
	char v16; // ST0C_1
	unsigned __int16 v17; // cx
	char v18; // dh
	char j; // dl
	unsigned __int16 v20; // ax
	unsigned __int16 v21; // bx
	char v22; // al
	char v23; // bl
	unsigned __int8 v24; // bh
	char i; // [esp+0h] [ebp-14h]
	char v27; // [esp+4h] [ebp-10h]
	char v28; // [esp+4h] [ebp-10h]
	char v29; // [esp+8h] [ebp-Ch]
	char v30; // [esp+8h] [ebp-Ch]
	char v31; // [esp+8h] [ebp-Ch]
	char v32; // [esp+10h] [ebp-4h]
	unsigned __int16 v33; // [esp+24h] [ebp+10h]

	// fix if begin
	v33 = 0;
	// end

	LOBYTE(v4) = a2 - a1 + 1;
	v2 = a1;
	v29 = a2 - a1 + 1;
	BYTE1(v4) = HIBYTE(a2) - HIBYTE(a1) + 1;
	v3 = BYTE1(v4) == 0;
	v27 = HIBYTE(a2) - HIBYTE(a1) + 1;
	while (!v3)
	{
		LOBYTE(v4) = a2 - a1 + 1;
		while ((x_BYTE)v4)
		{
			v5 = v2;
			LOBYTE(v2) = v2 - 1;
			x_BYTE_10B4E0[v5] = 1;
			v6 = v2;
			--HIBYTE(v2);
			x_BYTE_10B4E0[v6] = 1;
			v7 = v2;
			LOBYTE(v2) = v2 + 1;
			x_BYTE_10B4E0[v7] = 1;
			v8 = v2;
			LOBYTE(v4) = v4 - 1;
			++HIBYTE(v2);
			x_BYTE_10B4E0[v8] = 1;
			LOBYTE(v2) = v2 + 1;
		}
		LOBYTE(v2) = v2 - v29;
		++HIBYTE(v2);
		v3 = --BYTE1(v4) == 0;
	}
	LOBYTE(a1) = a1 - 1;
	--HIBYTE(a1);
	v28 = v27 + 1;
	v32 = v28;
	v9 = a1;
	v30 = v29 + 1;
	while (v32)
	{
		LOBYTE(v4) = v30;
		for (i = v30; i; i--)
		{
			v4 = v9;
			if (x_BYTE_10B4E0[v9] == 1)
			{
				LOBYTE(v9) = v9 + 1;
				v10 = 343 * (x_BYTE_13B4E0[v4] & 7);
				v11 = v9;
				++HIBYTE(v9);
				v12 = 49 * (x_BYTE_13B4E0[v11] & 7) + v10;
				v13 = x_BYTE_13B4E0[v9] & 7;
				LOBYTE(v9) = v9 - 1;
				v14 = x_BYTE_13B4E0[v9] & 7;
				--HIBYTE(v9);
				v15 = 2 * (v14 + 7 * v13 + v12);
				LOBYTE(v14) = x_BYTE_F2CD0[v15];
				x_BYTE_10B4E0[v9] = v14;
				if ((unsigned __int8)v14 >= 8u)
				{
					LOBYTE(v4) = x_BYTE_F2CD1[v15] + (x_BYTE_13B4E0[v9] & 0x87);
				}
				else
				{
					v16 = x_BYTE_13B4E0[v9] & 0x87;
					x_WORD_17B4E0 = 9377 * x_WORD_17B4E0 + 9439;
					LOBYTE(v4) = v16 + 16 * ((unsigned __int16)x_WORD_17B4E0 % 7u);
				}
				x_BYTE_13B4E0[v9] = v4;
			}
			LOBYTE(v9) = v9 + 1;
		}
		LOBYTE(v9) = v9 - v30;
		++HIBYTE(v9);
		--v32;
	}
	v31 = v30 + 1;
	v17 = v33;
	v18 = v28 + 1;
	if (v28 != -1)
	{
		do
		{
			for (j = v31; j; j--)
			{
				LOBYTE(v17) = v17 + 1;
				++HIBYTE(v17);
				v20 = v17;
				LOBYTE(v17) = v17 - 2;
				HIBYTE(v17) -= 2;
				v21 = v17;
				LOBYTE(v17) = v17 + 1;
				v22 = x_BYTE_11B4E0[v21] - x_BYTE_11B4E0[v20] + 32;
				++HIBYTE(v17);
				if (v22 >= 28)
				{
					if (v22 > 40)
						v22 = (v22 & 7) + 40;
				}
				else
				{
					v22 = (v22 & 3) + 28;
				}
				if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308))
					v23 = 32 - v22 + 32;
				else
					v23 = v22;
				v4 = v17;
				x_BYTE_12B4E0[v17] = v23;
				if (x_BYTE_D41B6 && (v24 = x_BYTE_11B4E0[v17], (unsigned __int8)x_BYTE_14B4E0[v17] <= v24))
				{
					x_BYTE_14B4E0[v17] = v24 - 1;
					x_BYTE_13B4E0[v17] |= 8u;
				}
				else
				{
					x_BYTE_13B4E0[v17] &= 0xF7u;
				}
				LOBYTE(v17) = v17 + 1;
			}
			LOBYTE(v17) = v17 - v31;
			--v18;
			++HIBYTE(v17);
		} while (v18);
	}
	return v4;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41B6: using guessed type char x_BYTE_D41B6;
// 17B4E0: using guessed type __int16 x_WORD_17B4E0;

//----- (00046820) --------------------------------------------------------
void sub_46820_simple_timer(HMDIDRIVER user)//227820
{
	x_DWORD_17DB54_game_turn2++;
	//return 0;
}
// 17DB54: using guessed type int x_DWORD_17DB54_game_turn2;

//----- (00046830) --------------------------------------------------------
void sub_46830_main_loop(Bit16s* a1, signed int a2, unsigned __int16 a3)//227830
{//grafika jiz inicialovana
  //int result; // eax

  //Bit8s* v4; // eax
	int v5; // edx
	unsigned __int16 v6; // dx
	bool v7; // al
	unsigned __int8 v8; // dl
	unsigned __int8 v9; // al
	unsigned __int8 v10; // al
	Bit8u* v11; // eax
	char v12; // ch
	x_WORD *v13; // eax

	// fix if begin
	v5 = 0;
	// end


	x_D41A0_BYTEARRAY_4_struct.setting_30 = 0;//2a51a4
	x_D41A0_BYTEARRAY_0[2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 11234] = 0;
	//	  * (_BYTE *)(2124 * *(signed __int16 *)(dword_D41A0 + 12) + dword_D41A0 + 11234) = 0;
	x_D41A0_BYTEARRAY_0[2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 11234] = 0;//fix it
	while (1)
	{
		//result = (int)x_D41A0_BYTEARRAY_0;
		if (x_D41A0_BYTEARRAY_0[2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 11234])
			return;
		sub_48350(); //fix it //229350
		//v4=0; //fix it
		sub_76930_menus_and_intros(v5, 0/*a1*/);//set language, intro, menu, atd. //257930
		if (!x_D41A0_BYTEARRAY_0[2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 11234])
		{
			v6 = x_D41A0_BYTEARRAY_4_struct.levelnumber_43;
			v7 = v6 > 0x18u && v6 < 0x32u;
			sub_47FC0(v7);//vga smaltitle
			sub_56A30_init_game_level(a3);
			sub_47160();
			while (!x_D41A0_BYTEARRAY_0[2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 11234])
			{
				if (x_BYTE_E37FC && x_BYTE_E37FD && x_WORD_E3804)
				{
					v8 = x_D41A0_BYTEARRAY_0[196308];
					if (v8 < 1u)
					{
						if (!v8)
							x_D41A0_BYTEARRAY_4[0x235] = 2;
					}
					else if (v8 <= 1u)
					{
						x_D41A0_BYTEARRAY_4[0x235] = 1;
					}
					else if (v8 == 2)
					{
						x_D41A0_BYTEARRAY_4[0x235] = 3;
					}
				}
				sub_6EDB0_set_mouse_position_by_res();
				sub_47320(a2);
				sub_53CC0();
				sub_8D8F0_sound_proc3_endsample();
				sub_8E020_sound_proc14_stopsequence();
				sub_86860(x_WORD_1803EC);
				sub_59BF0_sound_proc11_volume();
				sub_90B27_VGA_pal_fadein_fadeout(0, 0x10u, 0);
				if (x_WORD_180660_VGA_type_resolution & 1)
				{
					v9 = sub_5BE80_test_pallette(*xadatapald0dat2.var28_begin_buffer, 0, 0, 0);
					a1 = (signed __int16 *)x_DWORD_180628b_screen_buffer;
					sub_72883_clear_text_mode(/*v9, */(void *)x_DWORD_180628b_screen_buffer, 0xC8u, v9);
				}
				else
				{
					v10 = sub_5BE80_test_pallette(*xadatapald0dat2.var28_begin_buffer, 0, 0, 0);
					a3 = (int)x_DWORD_180628b_screen_buffer;
					sub_728A9_clear_graphics_mode((void *)x_DWORD_180628b_screen_buffer, 0x1E0u, v10);
				}
				if (x_WORD_180660_VGA_type_resolution & 1)
					sub_90478_VGA_Blit320();
				else
					sub_75200_VGA_Blit640(480);
				if (x_D41A0_BYTEARRAY_0[2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 11234] & 2
					&& !(x_D41A0_BYTEARRAY_4_struct.setting_38545 & 4))
				{
					sub_6DB50(1, 0);
				}
				sub_713A0();
				v11 = 2124 * x_D41A0_BYTEARRAY_4[0xC] + x_D41A0_BYTEARRAY_0;
				v12 = *(x_BYTE *)(v11 + 11232);
				if (v12 & 4)
				{
					sub_56D60(a3, 0);
					x_D41A0_BYTEARRAY_0[2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 11234] = 4;
				}
				else if (v12 & 2)
				{
					sub_5C530();
					if (x_D41A0_BYTEARRAY_4_struct.setting_38545 & 0x20)
						sub_6E0D0();
				}
				else
				{
					LOBYTE(a1) = v12 | 8;
					*(x_BYTE *)(v11 + 11232) = v12 | 8;
				}
				BYTE1(a1) = x_D41A0_BYTEARRAY_0[2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 11234];
				if (BYTE1(a1) & 0x10)
				{
					a3 = x_D41A0_BYTEARRAY_4_struct.levelnumber_43;
					if (a3 >= 0x18u)
					{
						if (BYTE1(a1) & 2)
							sub_5C530();
						break;
					}
					if (BYTE1(a1) & 2)
					{
						v13 = sub_824B0(a3);
						if (v13)
						{
							x_D41A0_BYTEARRAY_4_struct.levelnumber_43 = v13[3];
							sub_47FC0(1);
							sub_56A30_init_game_level(a3);
							sub_47160();
						}
					}
				}
				else if (BYTE1(a1) & 0xA)
				{
					break;
				}
			}
			x_WORD_E29D8 = 4;
		}
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// E29D8: using guessed type __int16 x_WORD_E29D8;
// E37FC: using guessed type char x_BYTE_E37FC;
// E37FD: using guessed type char x_BYTE_E37FD;
// E3804: using guessed type __int16 x_WORD_E3804;
// EA3D8: using guessed type int *xadatapald0dat2.var28_begin_buffer;
// 1803EC: using guessed type __int16 x_WORD_1803EC;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00046B40) --------------------------------------------------------
void sub_46B40()//227b40
{
	//int v0; // kr00_4
	char v1; // al
	unsigned __int8 v2; // al
	unsigned __int8 v3; // al

	Bit16s v0_tempmousex = x_WORD_E3760_mousex;
	Bit16s v0_tempmousey = x_WORD_E3762_mousey;
	if (x_BYTE_D41B4_vesa_driver_finded)
	{
		sub_90B27_VGA_pal_fadein_fadeout(0, 0x10u, 0);
		sub_417A0_install_pal_and_mouse_minmax();
		memset((void*)*xadatapald0dat2.var28_begin_buffer, 0, 768);
		sub_41A90_VGA_pallette_install(*xadatapald0dat2.var28_begin_buffer);
		if (x_DWORD_E9C3C)
		{
			sub_83E80_sound_proc_99(x_DWORD_E9C3C);
			x_DWORD_E9C3C = 0;
		}
		sub_54600_mouse_reset();
		/*sub_6EBF0((Bit8u**)&*filearray_2aa18c);
		sub_6EBF0((Bit8u**)&*filearray_2aa18c[6]);
		sub_6EBF0((Bit8u**)&*filearray_2aa18c[24]);*/ // fix it
		sub_47130();
		if (x_WORD_180660_VGA_type_resolution == 1)
		{
			sub_90D3F_unload_file_array(psxadatamsprd00dat);
			x_WORD_180660_VGA_type_resolution = 8;
		}
		else
		{
			// fix it sub_6EBF0((Bit8u**)&*filearray_2aa18c[18]);
			sub_90D3F_unload_file_array(psxadatahsprd00dat);
			x_WORD_180660_VGA_type_resolution = 1;
		}
		sub_47160();
		/*sub_6EB90(&*filearray_2aa18c[0]);
		sub_6EB90(&*filearray_2aa18c[24]);*/ // fix it
		memset((void*)*xadatapald0dat2.var28_begin_buffer, 0, 768);
		if (x_WORD_180660_VGA_type_resolution & 1)
		{
			v1 = sub_5BE80_test_pallette(*xadatapald0dat2.var28_begin_buffer, 0, 0, 0);
			sub_72883_clear_text_mode((void *)x_DWORD_180628b_screen_buffer, 0xC8u, v1);
		}
		else
		{
			v2 = sub_5BE80_test_pallette(*xadatapald0dat2.var28_begin_buffer, 0, 0, 0);
			sub_728A9_clear_graphics_mode((void *)x_DWORD_180628b_screen_buffer, 0x1E0u, v2);
		}
		memset((void*)*xadatapald0dat2.var28_begin_buffer, 0, 768);
		sub_41A90_VGA_pallette_install(*xadatapald0dat2.var28_begin_buffer);
		if (x_WORD_180660_VGA_type_resolution & 1)
			sub_90D6E_VGA_set_video_mode_320x200_and_pallette(*xadatapald0dat2.var28_begin_buffer);
		else
			sub_90E07_VGA_set_video_mode_640x480_and_pallette(*xadatapald0dat2.var28_begin_buffer);
		sub_41A90_VGA_pallette_install(*xadatapald0dat2.var28_begin_buffer);
		v3 = sub_5BE80_test_pallette(*xadatapald0dat2.var28_begin_buffer, 0, 0, 0);
		x_BYTE_EB3A8 = v3;
		if (x_WORD_180660_VGA_type_resolution & 1)
			sub_72883_clear_text_mode((void *)x_DWORD_180628b_screen_buffer, 0xC8u, v3);
		else
			sub_728A9_clear_graphics_mode((void *)x_DWORD_180628b_screen_buffer, 0x1E0u, v3);
		sub_8CEDF_install_mouse();
		sub_8CD27_set_cursor(*filearray_2aa18c[0].posistruct);
		x_D41A0_BYTEARRAY_4[0x33] = 2;
		if (x_WORD_180660_VGA_type_resolution == 1)
			x_BYTE_D419D = 1;
		else
			x_BYTE_D419D = 3;
		sub_5BDC0_set_mouse_position(v0_tempmousex, v0_tempmousey);
	}
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D419D: using guessed type char x_BYTE_D419D;
// D41A4: using guessed type int x_DWORD_D41A4;
// D41B4: using guessed type char x_BYTE_D41B4_vesa_driver_finded;
// D918C: using guessed type int **filearray_2aa18c;
// D91BC: using guessed type int *off_D91BC[2];
// D91D4: using guessed type void *off_D91D4;
// D91EC: using guessed type int *off_D91EC;
// E3760: using guessed type int x_DWORD_E3760;
// E9C3C: using guessed type int x_DWORD_E9C3C;
// EA3D8: using guessed type int *xadatapald0dat2.var28_begin_buffer;
// EB394: using guessed type int **filearray_2aa18c[0];
// EB3A8: using guessed type char x_BYTE_EB3A8;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00046DD0) --------------------------------------------------------
void /*__fastcall*/ sub_46DD0_init_sound_and_music(/*int a1, int a2, char* a3*/)//227DD0
{
	char* v3; // eax
	int v4; // edx
	char v5; // bl
	char v6; // dl
	//char v8[512]; // [esp+0h] [ebp-40h]
	// fix if begin
	v4 = 0;
	// end

	sub_83CC0(20);
	if (!x_BYTE_D4B50)
	{
		x_BYTE_D4B50 = 1;
		if ((x_D41A0_BYTEARRAY_4_struct.setting_byte1_22) & 0x40)//fix it
		{
			sub_70910_print_string((char*)"Sound Disabled\0");
			x_BYTE_E37FD = 0;
			x_BYTE_E3799 = 0;
			x_BYTE_E37FC = 0;
			x_BYTE_E3798_sound_active2 = 0;
		}
		else
		{
			//&v8, sizeof(&v8)
			//v8 - 355204
		  //sprintf_s(sounddir, 512, "%s/%s", "/netherw", "sound");
			sprintf_s(printbuffer, 512, "%s/%s", "/netherw", "sound");
			sub_90EA0(x_D41A0_BYTEARRAY_4_struct.harddiskchar_byte4_182 - 64, printbuffer);
			v3 = sub_70910_print_string((char*)"Initialise Sound\0");
			sub_90FD0(v3/*v3, v4, a3*/); //fix it sound off here!
			if (!x_WORD_E2A14_sound_activel)
				myprintf("ERROR: NOT ENOUGH MEMORY FOR SOUNDS\n");
			if ((x_D41A0_BYTEARRAY_4_struct.setting_byte4_25) & 0x40)//fix it
				sub_8EAD0_load_music(1);
		}
		if (x_BYTE_E3798_sound_active2 || x_BYTE_E37FC)
		{
			x_DWORD_F42A4_sound_timer = sub_92600_AIL_register_timer(sub_46820_simple_timer);
			sub_92930_AIL_set_timer_frequency(x_DWORD_F42A4_sound_timer, 0x78u);
			sub_92BA0_AIL_start_timer(x_DWORD_F42A4_sound_timer);
			x_BYTE_D4B51 = 1;
		}
		else
		{
			sub_6FDA0();
		}
		v5 = x_BYTE_E3798_sound_active2;
		if (!x_BYTE_E3798_sound_active2 && !x_BYTE_E37FC && x_BYTE_E2A28)
		{
			sub_86860(x_WORD_1803EC);
			sub_86BD0_freemem1();
			//v6 = x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 0xBF;
			x_BYTE_E2A28 = v5;
			(x_D41A0_BYTEARRAY_4_struct.setting_byte3_24) &= 0xBF;
		}
	}
	sub_83CC0(21);
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// D41A4: using guessed type int x_DWORD_D41A4;
// D4B50: using guessed type char x_BYTE_D4B50;
// D4B51: using guessed type char x_BYTE_D4B51;
// E2A14: using guessed type __int16 x_WORD_E2A14_sound_active;
// E2A28: using guessed type char x_BYTE_E2A28;
// E3798: using guessed type char x_BYTE_E3798_sound_active2;
// E3799: using guessed type char x_BYTE_E3799;
// E37FC: using guessed type char x_BYTE_E37FC;
// E37FD: using guessed type char x_BYTE_E37FD;
// F42A4: using guessed type int x_DWORD_F42A4_sound_timer;
// 1803EC: using guessed type __int16 x_WORD_1803EC;

//----- (00046F50) --------------------------------------------------------
void sub_46F50_sound_proc7()
{
	if (x_BYTE_D4B51)
		sub_92DC0_AIL_release_timer_handle(x_DWORD_F42A4_sound_timer);
	else
		sub_6FE20();
	sub_986E0();
}
// D4B51: using guessed type char x_BYTE_D4B51;
// F42A4: using guessed type int x_DWORD_F42A4_sound_timer;

//----- (00046F80) --------------------------------------------------------
void sub_46F80()
{
	unsigned __int8 v0; // al
	char *v1; // esi
	int v2; // esi
	char *result; // eax
	int v4; // eax
	char *v5; // ebx
	unsigned int v6; // esi
	unsigned int v7; // esi
	int v8; // [esp+0h] [ebp-2h]
	int v9; // [esp+4h] [ebp+2h]
	int v10; // [esp+8h] [ebp+6h]
	int v11; // [esp+Ch] [ebp+Ah]
	__int16 v12; // [esp+10h] [ebp+Eh]
	char v13; // [esp+40h] [ebp+3Eh]
	int v14; // [esp+80h] [ebp+7Eh]

	sub_47130();
	v0 = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308);
	if (v0 >= 1u)
	{
		if (v0 <= 1u)
		{
			if (x_WORD_180660_VGA_type_resolution == 1)
			{
				strcpy_s(&v13, sizeof(&v13), "data/mwebn0-0.dat");
				v1 = (char*)"data/mwebn0-0.tab";
			}
			else
			{
				strcpy_s(&v13, sizeof(&v13), "data/hwebn0-0.dat");
				v1 = (char*)"data/hwebn0-0.tab";
			}
		}
		else
		{
			if (v0 != 2)
				goto LABEL_16;
			if (x_WORD_180660_VGA_type_resolution == 1)
			{
				strcpy_s(&v13, sizeof(&v13), "data/mwebc0-0.dat");
				v1 = (char*)"data/mwebc0-0.tab";
			}
			else
			{
				strcpy_s(&v13, sizeof(&v13), "data/hwebc0-0.dat");
				v1 = (char*)"data/hwebc0-0.tab";
			}
		}
		goto LABEL_15;
	}
	if (!v0)
	{
		if (x_WORD_180660_VGA_type_resolution == 1)
		{
			strcpy_s(&v13, sizeof(&v13), "data/mwebd0-0.dat");
			v1 = (char*)"data/mwebd0-0.tab";
		}
		else
		{
			strcpy_s(&v13, sizeof(&v13), "data/hwebd0-0.dat");
			v1 = (char*)"data/hwebd0-0.tab";
		}
	LABEL_15:
		v8 = *(x_DWORD *)v1;
		v2 = (int)(v1 + 4);
		v9 = *(x_DWORD *)v2;
		v2 += 4;
		v10 = *(x_DWORD *)v2;
		v2 += 4;
		v11 = *(x_DWORD *)v2;
		v12 = *(x_WORD *)(v2 + 4);
	}
LABEL_16:
	result = (char *)sub_53E60_readfile_and_decompress(&v13, &x_DWORD_180628b_screen_buffer);
	if ((signed int)result > 0)
	{
		v4 = (int)(result + 8);
		LOBYTE(v4) = v4 & 0xF8;
		v14 = v4;
		//result = (char *)sub_53E60_readfile_and_decompress((char*)&v8, &(&(x_DWORD_180628b_screen_buffer[v4])); //fix it
		v5 = result;
		if ((signed int)result > 0)
		{
			v6 = (unsigned int)&result[v14];
			result = (char *)sub_83CD0_malloc2((int)&result[v14]);
			x_DWORD_D4188 = (Bit8u*)result;
			if (result)
			{
				qmemcpy(result, (void *)x_DWORD_180628b_screen_buffer, v6);
				x_DWORD_D418C = (int)x_DWORD_D4188 + v14;
				v7 = (unsigned int)&v5[(int)x_DWORD_D4188 + v14];
				x_DWORD_D4190 = (int)&v5[(int)x_DWORD_D4188 + v14];
				posistruct tempposistruct;//fix it
				if (x_WORD_180660_VGA_type_resolution & 1)
					sub_98709_create_index_dattab_power((Bit8u*)x_DWORD_D4188 + v14, (Bit8u*)v7, (Bit8u*)x_DWORD_D4188, (posistruct*)&tempposistruct);
				else
					sub_9874D_create_index_dattab((Bit8u*)(x_DWORD_D4188 + v14), (Bit8u*)v7, (Bit8u*)x_DWORD_D4188, (new posistruct));
			}
		}
	}
	//return result;
}
// D4188: using guessed type int x_DWORD_D4188;
// D418C: using guessed type int x_DWORD_D418C;
// D4190: using guessed type int x_DWORD_D4190;
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00047130) --------------------------------------------------------
void sub_47130()//228130
{
	if (x_DWORD_D4188)
	{
		sub_83E80_sound_proc_99(x_DWORD_D4188);
		x_DWORD_D4188 = 0;
		x_DWORD_D418C = 0;
		x_DWORD_D4190 = 0;
	}
}
// D4188: using guessed type int x_DWORD_D4188;
// D418C: using guessed type int x_DWORD_D418C;
// D4190: using guessed type int x_DWORD_D4190;




//----- (00047160) --------------------------------------------------------
void sub_47160()//228160
{
	unsigned __int8 v0; // al

	v0 = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308);
	if (v0 < 1u)
	{
		if (!v0)
		{
			sprintf_s((char*)"data/msprd0-0.dat", 512, "%s", "data/msprd0-0.dat");
			sprintf_s((char*)"data/msprd0-0.tab", 512, "%s", "data/msprd0-0.tab");
			sprintf_s((char*)"data/hsprd0-0.dat", 512, "%s", "data/hsprd0-0.dat");
			sprintf_s((char*)"data/hsprd0-0.tab", 512, "%s", "data/hsprd0-0.tab");
		}
	}
	else if (v0 <= 1u)
	{
		sprintf_s((char*)"data/msprd0-0.dat", 512, "%s", "data/msprn0-0.dat");
		sprintf_s((char*)"data/msprd0-0.tab", 512, "%s", "data/msprn0-0.tab");
		sprintf_s((char*)"data/hsprd0-0.dat", 512, "%s", "data/hsprn0-0.dat");
		sprintf_s((char*)"data/hsprd0-0.tab", 512, "%s", "data/hsprn0-0.tab");
	}
	else if (v0 == 2)
	{
		sprintf_s((char*)"data/msprd0-0.dat", 512, "%s", "data/msprc0-0.dat");
		sprintf_s((char*)"data/msprd0-0.tab", 512, "%s", "data/msprc0-0.tab");
		sprintf_s((char*)"data/hsprd0-0.dat", 512, "%s", "data/hsprc0-0.dat");
		sprintf_s((char*)"data/hsprd0-0.tab", 512, "%s", "data/hsprc0-0.tab");
	}
	if (x_WORD_180660_VGA_type_resolution == 1)
	{
		sub_84250_load_file_array(psxadatamsprd00dat);
		if (x_DWORD_E9C3C)
			sub_83E80_sound_proc_99(x_DWORD_E9C3C);
		x_DWORD_E9C3C = (Bit8u*)sub_83CD0_malloc2(64000);
	}
	else
	{
		sub_84250_load_file_array(psxadatahsprd00dat);
		if (x_DWORD_E9C3C)
			sub_83E80_sound_proc_99(x_DWORD_E9C3C);
		x_DWORD_E9C3C = (Bit8u*)sub_83CD0_malloc2((int)&loc_4AFFE + 2);
		// fix it//sub_6EB90(&*filearray_2aa18c[18]);
	}
	// fix it//sub_6EB90(&*filearray_2aa18c[6]);
	return sub_46F80();
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D91BC: using guessed type int *off_D91BC[2];
// D91D4: using guessed type void *off_D91D4;
// E9C3C: using guessed type int x_DWORD_E9C3C;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00047320) --------------------------------------------------------
int sub_47320(signed int a1)//228320
{
	x_BYTE *v1; // ebx
	int v2; // esi
	unsigned int v3; // esi
	int v4; // edx
	Bit8u* result; // eax

	x_D41A0_BYTEARRAY_4[0x33] = 0;
	v1 = 0;
	*(x_WORD *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11232) = 0;
	while (1)
	{
		v4 = 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
		result = v4 + x_D41A0_BYTEARRAY_0;
		if (*(x_BYTE *)(v4 + x_D41A0_BYTEARRAY_0 + 11234) || *(x_BYTE *)(result + 11232) & 8)
			break;
		v2 = x_DWORD_17DB54_game_turn2;
		sub_47560((int)result, v4, v1, a1, x_DWORD_17DB54_game_turn2);
		v3 = v2 + 5;
		while (v3 > x_DWORD_17DB54_game_turn2)
			;
		if ((unsigned __int16)v1 < 2u)
		{
			sub_8E020_sound_proc14_stopsequence();
			if ((x_WORD)v1 == 1)
				sub_8E160_sound_proc15_startsequence(*(x_WORD *)(x_D41A0_BYTEARRAY_0 + 565), 0x7Fu);
			++v1;
		}
	}
	return (int)result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// 17DB54: using guessed type int x_DWORD_17DB54_game_turn2;

//----- (000473B0) --------------------------------------------------------
void sub_473B0()//2283b0
{
	//int result; // eax

	x_DWORD_EA3B4 = 0;
	//result = (unsigned __int8)x_BYTE_1806E4;
	x_WORD_F42AE = x_BYTE_1806E4;
	x_WORD_F42A8 = 64;
	//return result;
}
// EA3B4: using guessed type int x_DWORD_EA3B4;
// F42A8: using guessed type __int16 x_WORD_F42A8;
// F42AE: using guessed type __int16 x_WORD_F42AE;
// 1806E4: using guessed type char x_BYTE_1806E4;

//----- (000473E0) --------------------------------------------------------
int sub_473E0()//2283e0
{
	char v0; // bl
	__int16 v1; // ax

	v0 = 0;
	if (x_DWORD_EA3B4)
		return x_DWORD_EA3B4;
	if (x_WORD_F42A8)
		--x_WORD_F42A8;
	if (!x_WORD_18074C && !x_WORD_18074A)
	{
		if (x_BYTE_18068E || x_BYTE_18069A)
		{
			if (x_BYTE_1806E4 < 0x36u)
			{
				if (x_BYTE_1806E4 != 42)
					goto LABEL_24;
			}
			else if (x_BYTE_1806E4 > 0x36u
				&& (x_BYTE_1806E4 < 0x3Bu || x_BYTE_1806E4 > 0x3Fu && x_BYTE_1806E4 != 66))
			{
				goto LABEL_24;
			}
		}
		else if (x_BYTE_1806E4 < 0x3Bu)
		{
			if (x_BYTE_1806E4 != 19)
				goto LABEL_24;
		}
		else if (x_BYTE_1806E4 > 0x3Bu
			&& (x_BYTE_1806E4 < 0x3Fu || x_BYTE_1806E4 > 0x41u))
		{
		LABEL_24:
			HIBYTE(v1) = HIBYTE(x_WORD_F42A8);
			if (x_WORD_F42A8)
			{
				x_WORD_F42AE = x_BYTE_1806E4;
			}
			else
			{
				LOBYTE(v1) = x_BYTE_1806E4;
				if (v1 != x_WORD_F42AE)
					v0 = 1;
			}
			goto LABEL_28;
		}
		sub_473B0();
		goto LABEL_24;
	}
	v0 = 1;
LABEL_28:
	if (v0)
		x_DWORD_EA3B4 = 1;
	return x_DWORD_EA3B4;
}
// EA3B4: using guessed type int x_DWORD_EA3B4;
// F42A8: using guessed type __int16 x_WORD_F42A8;
// F42AE: using guessed type __int16 x_WORD_F42AE;
// 18068E: using guessed type char x_BYTE_18068E;
// 18069A: using guessed type char x_BYTE_18069A;
// 1806E4: using guessed type char x_BYTE_1806E4;
// 18074A: using guessed type __int16 x_WORD_18074A;
// 18074C: using guessed type __int16 x_WORD_18074C;

//----- (00047560) --------------------------------------------------------
void sub_47560(int a1, int a2, x_BYTE *a3, signed int a4, __int16 a5)//228560
{
	unsigned __int8 v5; // al
	signed int j; // ebx
	signed int i; // ebx
	int v8; // eax

	sub_47760(/*a1, a2, (int)a3*/(Bit32u)a3);
	if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 1))
		sub_715B0();
	sub_89D10();
	sub_17A00(a3, a4, a5);
	sub_51BB0(a4);
	sub_848A0();
	v5 = x_D41A0_BYTEARRAY_4[0xB2];
	if (v5 < 1u)
	{
		if (!v5)
			sub_57730();
	}
	else if (v5 <= 1u)
	{
		for (i = 0; i < 4; i++)
			sub_57730();
	}
	else if (v5 == 2)
	{
		for (j = 0; j < 8; j++)
			sub_57730();
	}
	sub_84B80();
	sub_58F00();
	sub_59820();
	if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 1))
		sub_57570();
	sub_575C0();
	sub_6E150();
	sub_2BE30();
	if (x_D41A0_BYTEARRAY_4_struct.byteindex_A)
		sub_871F0();
	x_D41A0_BYTEARRAY_4[196] = x_DWORD_17DB54_game_turn2 - x_D41A0_BYTEARRAY_4[196];
	sub_6FEC0();
	v8 = (int)x_D41A0_BYTEARRAY_4;
	x_D41A0_BYTEARRAY_4[196] = x_DWORD_17DB54_game_turn2;
	if (*(x_BYTE *)(v8 + 51) >= 3u)
		sub_40F80();
}
// D41A4: using guessed type int x_DWORD_D41A4;
// 17DB54: using guessed type int x_DWORD_17DB54_game_turn2;

//----- (00047650) --------------------------------------------------------
int /*__fastcall*/ sub_47650(int a1, int a2)//228650
{
	unsigned __int8 v2; // al
	signed int v3; // esi
	int v4; // edx
	signed int v5; // ebx
	int v6; // ecx
	int v7; // eax
	int result; // eax

	qmemcpy((void *)*xadatapald0dat2.var28_begin_buffer, (void *)x_DWORD_EA3B8, 0x300u);
	v2 = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308);
	if (v2 < 1u)
	{
		if (!v2)
			a2 = x_D41A0_BYTEARRAY_4[0xB];
	}
	else if (v2 <= 1u)
	{
		a2 = *(char *)(x_D41A0_BYTEARRAY_4[0xC]);
	}
	else if (v2 == 2)
	{
		a2 = x_D41A0_BYTEARRAY_4[0xD];
	}
	v3 = 0;
	v4 = 6 * a2;
	while (v3 < 256)
	{
		v5 = 0;
		while (v5 < 3)
		{
			v6 = v4 + *(*xadatapald0dat2.var28_begin_buffer + v5 + 3 * v3);
			if (v6 < 0)
				v6 = 0;
			if (v6 > 63)
				LOBYTE(v6) = 63;
			v7 = v5++ + 3 * v3;
			*(x_BYTE *)(*xadatapald0dat2.var28_begin_buffer + v7) = v6;
		}
		++v3;
	}
	result = (int)x_D41A0_BYTEARRAY_4;
	x_D41A0_BYTEARRAY_4[0xB4] = 1;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3B8: using guessed type int x_DWORD_EA3B8;
// EA3D8: using guessed type int *xadatapald0dat2.var28_begin_buffer;

//----- (00047760) --------------------------------------------------------
char /*__fastcall*/ sub_47760(/*int a1,*/Bit32u user/* int a2, int a3*/)//228760
{
	x_BYTE *v3; // eax
	unsigned __int8 v4; // dl
	Bit8u* v5; // ST00_4
	int v6; // edx
	unsigned __int8 v7; // al
	char *v8; // ST00_4
	char *v9; // ST00_4
	char *v10; // ST00_4
	signed int v11; // eax
	int v12; // edx
	signed int v13; // eax
	int v14; // ebx
	int v15; // ebx
	int v16; // ebx
	signed int v17; // edx
	Bit8u* v18; // ebx
	int v19; // eax
	int v20; // ecx
	signed int v21; // eax
	int v22; // ebx
	signed int v23; // ebx
	int v24; // ecx
	__int64 v25; // rtt
	char v26; // al
	signed int v27; // eax
	int v28; // ebx

	v3 = (x_BYTE *)x_D41A0_BYTEARRAY_4;
	v4 = x_D41A0_BYTEARRAY_4[0x33];
	x_D41A0_BYTEARRAY_4[181] = 0;
	if (v4 < 2u)
	{
		sub_480A0((int)v3, v4, user);
		v3 = (x_BYTE *)x_D41A0_BYTEARRAY_4;
		++v3[51];
	}
	else if (v4 <= 2u)
	{
		v3[51] = v4 + 1;
		v5 = *xadatapald0dat2.var28_begin_buffer;
		v3[180] = 1;
		memset((void*)v5, 0, 768);
		sub_41A90_VGA_pallette_install(*xadatapald0dat2.var28_begin_buffer);
		v6 = (int)x_D41A0_BYTEARRAY_0;
		v7 = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308);
		if (v7 < 1u)
		{
			if (!v7)
			{
				sub_53E60_readfile_and_decompress("data/pald-0.dat", xadatapald0dat2.var28_begin_buffer);
				sub_53E60_readfile_and_decompress("data/clrd-0.dat", xadataclrd0dat.var28_begin_buffer);
			}
		}
		else if (v7 <= 1u)
		{
			if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196306) & 2)
				sub_53E60_readfile_and_decompress("data/palf-0.dat", xadatapald0dat2.var28_begin_buffer);
			else
				sub_53E60_readfile_and_decompress("data/paln-0.dat", xadatapald0dat2.var28_begin_buffer);
			sub_53E60_readfile_and_decompress("data/clrn-0.dat", xadataclrd0dat.var28_begin_buffer);
		}
		else if (v7 == 2)
		{
			sub_53E60_readfile_and_decompress("data/palc-0.dat", xadatapald0dat2.var28_begin_buffer);
			sub_53E60_readfile_and_decompress("data/clrc-0.dat", xadataclrd0dat.var28_begin_buffer);
		}
		qmemcpy((void *)x_DWORD_EA3B8, (void *)*xadatapald0dat2.var28_begin_buffer, 0x300u);
		sub_47650(768, v6);
		sub_90D27();
		x_BYTE_EB3A8 = (unsigned __int8)*xadataclrd0dat.var28_begin_buffer;
		LOBYTE(v3) = sub_57640();
	}
	else if (v4 == 3)
	{
		switch (v3[180])
		{
		case 1:
			v8 = (char *)*xadatapald0dat2.var28_begin_buffer;
			v3[181] = 1;
			/*LOWORD(v3) = */sub_90B27_VGA_pal_fadein_fadeout((Bit8u*)v8, 4u, 1);
			if ((x_WORD)v3 == 4)
			{
				LOBYTE(v3) = (uint8)x_D41A0_BYTEARRAY_4;
				x_D41A0_BYTEARRAY_4[0xB4] = 0;
			}
			break;
		case 2:
			v11 = 1;
			while (v11 < 256)
			{
				x_DWORD_F42A0 = *(3 * v11 + *xadatapald0dat2.var28_begin_buffer) + 40;
				if (x_DWORD_F42A0 < 0)
					x_DWORD_F42A0 = 0;
				if (x_DWORD_F42A0 > 63)
					x_DWORD_F42A0 = 63;
				x_BYTE_F3FA0[3 * v11] = x_DWORD_F42A0;
				x_DWORD_F42A0 = *(3 * v11 + *xadatapald0dat2.var28_begin_buffer + 1);
				if (x_DWORD_F42A0 < 0)
					x_DWORD_F42A0 = 0;
				if (x_DWORD_F42A0 > 63)
					x_DWORD_F42A0 = 63;
				x_BYTE_F3FA1[3 * v11] = x_DWORD_F42A0;
				x_DWORD_F42A0 = *(3 * v11 + *xadatapald0dat2.var28_begin_buffer + 2);
				if (x_DWORD_F42A0 < 0)
					x_DWORD_F42A0 = 0;
				if (x_DWORD_F42A0 > 63)
					x_DWORD_F42A0 = 63;
				v12 = 3 * v11++;
				x_BYTE_F3FA2[v12] = x_DWORD_F42A0;
			}
			sub_90D27();
			sub_41A90_VGA_pallette_install((unsigned __int8 *)x_BYTE_F3FA0);
			v3 = (x_BYTE *)x_D41A0_BYTEARRAY_4;
			x_D41A0_BYTEARRAY_4[0xB4] = 1;
			v3[181] = 1;
			break;
		case 3:
			v13 = 1;
			while (v13 < 256)
			{
				v14 = x_D41A0_BYTEARRAY_4[184];
				x_DWORD_F42A0 = *(3 * v13 + *xadatapald0dat2.var28_begin_buffer);
				x_DWORD_F42A0 += -56 * v14 >> 8;
				if (x_DWORD_F42A0 < 0)
					x_DWORD_F42A0 = 0;
				if (x_DWORD_F42A0 > 63)
					x_DWORD_F42A0 = 63;
				x_BYTE_F3FA0[3 * v13] = x_DWORD_F42A0;
				x_DWORD_F42A0 = *(3 * v13 + *xadatapald0dat2.var28_begin_buffer + 1);
				if (x_DWORD_F42A0 < 0)
					x_DWORD_F42A0 = 0;
				if (x_DWORD_F42A0 > 63)
					x_DWORD_F42A0 = 63;
				x_BYTE_F3FA1[3 * v13] = x_DWORD_F42A0;
				v15 = x_D41A0_BYTEARRAY_4[184];
				x_DWORD_F42A0 = *(3 * v13 + *xadatapald0dat2.var28_begin_buffer + 2);
				x_DWORD_F42A0 += -56 * v15 >> 8;
				if (x_DWORD_F42A0 < 0)
					x_DWORD_F42A0 = 0;
				if (x_DWORD_F42A0 > 63)
					x_DWORD_F42A0 = 63;
				v16 = 3 * v13++;
				x_BYTE_F3FA2[v16] = x_DWORD_F42A0;
			}
			sub_90D27();
			sub_41A90_VGA_pallette_install((unsigned __int8 *)x_BYTE_F3FA0);
			v3 = (x_BYTE *)x_D41A0_BYTEARRAY_4;
			x_D41A0_BYTEARRAY_4[0xB4] = 1;
			v3[181] = 1;
			break;
		case 4:
			v17 = 1;
			while (v17 < 256)
			{
				v18 = *xadatapald0dat2.var28_begin_buffer;
				v19 = 3 * v17;
				v20 = *(*xadatapald0dat2.var28_begin_buffer + 3 * v17 + 2);
				x_DWORD_F42A0 = 255;
				x_BYTE_F3FA0[v19] = *(x_BYTE *)(*xadatapald0dat2.var28_begin_buffer + 3 * v17);
				x_BYTE_F3FA1[v19] = *(x_BYTE *)(v18 + 3 * v17++ + 1);
				x_BYTE_F3FA2[v19] = 63;
			}
			sub_90D27();
			sub_41A90_VGA_pallette_install((unsigned __int8 *)x_BYTE_F3FA0);
			v3 = (x_BYTE *)x_D41A0_BYTEARRAY_4;
			x_D41A0_BYTEARRAY_4[0xB4] = 1;
			v3[181] = 1;
			break;
		case 5:
			memset((void*)*xadatapald0dat2.var28_begin_buffer, 0, 768);
			v3 = (x_BYTE *)x_D41A0_BYTEARRAY_4;
			x_D41A0_BYTEARRAY_4[0xB4] = 10;
			v3[181] = 1;
			break;
		case 6:
			v21 = 1;
			while (v21 < 256)
			{
				x_DWORD_F42A0 = *(3 * v21 + *xadatapald0dat2.var28_begin_buffer + 2) + 48;
				if (x_DWORD_F42A0 < 0)
					x_DWORD_F42A0 = 0;
				if (x_DWORD_F42A0 > 63)
					x_DWORD_F42A0 = 63;
				x_BYTE_F3FA0[3 * v21] = x_DWORD_F42A0;
				x_DWORD_F42A0 = *(3 * v21 + *xadatapald0dat2.var28_begin_buffer + 1) + 32;
				if (x_DWORD_F42A0 < 0)
					x_DWORD_F42A0 = 0;
				if (x_DWORD_F42A0 > 63)
					x_DWORD_F42A0 = 63;
				x_BYTE_F3FA1[3 * v21] = x_DWORD_F42A0;
				x_DWORD_F42A0 = *(3 * v21 + *xadatapald0dat2.var28_begin_buffer + 2) + 32;
				if (x_DWORD_F42A0 < 0)
					x_DWORD_F42A0 = 0;
				if (x_DWORD_F42A0 > 63)
					x_DWORD_F42A0 = 63;
				v22 = 3 * v21++;
				x_BYTE_F3FA2[v22] = x_DWORD_F42A0;
			}
			sub_90D27();
			sub_41A90_VGA_pallette_install((unsigned __int8 *)x_BYTE_F3FA0);
			v3 = (x_BYTE *)x_D41A0_BYTEARRAY_4;
			x_D41A0_BYTEARRAY_4[0xB4] = 1;
			v3[181] = 1;
			break;
		case 7:
			v23 = 1;
			while (v23 < 256)
			{
				v24 = 3 * v23;
				v25 = *(3 * v23 + *xadatapald0dat2.var28_begin_buffer)
					+ *(3 * v23 + *xadatapald0dat2.var28_begin_buffer + 1)
					+ *(3 * v23 + *xadatapald0dat2.var28_begin_buffer + 2);
				x_DWORD_F42A0 = (*(3 * v23 + *xadatapald0dat2.var28_begin_buffer)
					+ *(3 * v23 + *xadatapald0dat2.var28_begin_buffer + 1)
					+ *(3 * v23 + *xadatapald0dat2.var28_begin_buffer + 2))
					/ 3;
				v26 = v25 / 3;
				x_BYTE_F3FA0[v24] = v26;
				x_BYTE_F3FA1[v24] = v26;
				++v23;
				x_BYTE_F3FA2[v24] = v26;
			}
			sub_90D27();
			sub_41A90_VGA_pallette_install((unsigned __int8 *)x_BYTE_F3FA0);
			v3 = (x_BYTE *)x_D41A0_BYTEARRAY_4;
			x_D41A0_BYTEARRAY_4[0xB4] = 1;
			v3[181] = 1;
			break;
		case 8:
			v27 = 1;
			while (v27 < 256)
			{
				x_DWORD_F42A0 = *(3 * v27 + *xadatapald0dat2.var28_begin_buffer) + 48;
				if (x_DWORD_F42A0 < 0)
					x_DWORD_F42A0 = 0;
				if (x_DWORD_F42A0 > 63)
					x_DWORD_F42A0 = 63;
				x_BYTE_F3FA0[3 * v27] = x_DWORD_F42A0;
				x_DWORD_F42A0 = *(3 * v27 + *xadatapald0dat2.var28_begin_buffer + 1) + 48;
				if (x_DWORD_F42A0 < 0)
					x_DWORD_F42A0 = 0;
				if (x_DWORD_F42A0 > 63)
					x_DWORD_F42A0 = 63;
				x_BYTE_F3FA1[3 * v27] = x_DWORD_F42A0;
				x_DWORD_F42A0 = *(3 * v27 + *xadatapald0dat2.var28_begin_buffer + 2) + 48;
				if (x_DWORD_F42A0 < 0)
					x_DWORD_F42A0 = 0;
				if (x_DWORD_F42A0 > 63)
					x_DWORD_F42A0 = 63;
				v28 = 3 * v27++;
				x_BYTE_F3FA2[v28] = x_DWORD_F42A0;
			}
			sub_90D27();
			sub_41A90_VGA_pallette_install((unsigned __int8 *)x_BYTE_F3FA0);
			v3 = (x_BYTE *)x_D41A0_BYTEARRAY_4;
			x_D41A0_BYTEARRAY_4[0xB4] = 9;
			v3[181] = 1;
			break;
		case 9:
			v9 = (char *)*xadatapald0dat2.var28_begin_buffer;
			v3[181] = 1;
			/*LOWORD(v3) = */sub_90B27_VGA_pal_fadein_fadeout((Bit8u*)v9, 0x10u, 1);
			if ((x_WORD)v3 == 16)
			{
				LOBYTE(v3) = (uint8)x_D41A0_BYTEARRAY_4;
				x_D41A0_BYTEARRAY_4[0xB4] = 0;
			}
			break;
		case 0xA:
			v10 = (char *)*xadatapald0dat2.var28_begin_buffer;
			v3[181] = 1;
			/*LOWORD(v3) = */sub_90B27_VGA_pal_fadein_fadeout((Bit8u*)v10, 0x1Cu, 1);
			if ((x_WORD)v3 == 28)
			{
				LOBYTE(v3) = (uint8)x_D41A0_BYTEARRAY_4;
				x_D41A0_BYTEARRAY_4[0xB4] = 0;
			}
			break;
		default:
			return (char)v3;
		}
	}
	return (char)v3;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3B8: using guessed type int x_DWORD_EA3B8;
// EA3D8: using guessed type int *xadatapald0dat2.var28_begin_buffer;
// EB3A8: using guessed type char x_BYTE_EB3A8;
// F42A0: using guessed type int x_DWORD_F42A0;

//----- (00047FC0) --------------------------------------------------------
int sub_47FC0(char a1)//228fc0
{
	int result; // eax

	sub_90B27_VGA_pal_fadein_fadeout(0, 0x10u, 0);
	if (a1)
		sub_53E60_readfile_and_decompress("data/smatitl2.dat", &x_DWORD_E9C38_smalltit);
	else
		sub_53E60_readfile_and_decompress("data/smatitle.dat", &x_DWORD_E9C38_smalltit);
	sub_85B20((x_BYTE *)x_DWORD_E9C38_smalltit, (x_WORD *)x_DWORD_180628b_screen_buffer, 0x190u);
	if (x_WORD_180660_VGA_type_resolution & 1)
		sub_90478_VGA_Blit320();
	else
		sub_75200_VGA_Blit640(480);
	if (a1)
		sub_53E60_readfile_and_decompress("data/smatitl2.pal", xadatapald0dat2.var28_begin_buffer);
	else
		sub_53E60_readfile_and_decompress("data/smatitle.pal", xadatapald0dat2.var28_begin_buffer);
	sub_90B27_VGA_pal_fadein_fadeout((Bit8u*)*xadatapald0dat2.var28_begin_buffer, 0x20u, 0);
	result = (int)x_D41A0_BYTEARRAY_0;
	*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 570) = 1;
	*(x_DWORD *)(result + 574) = 0;
	*(x_DWORD *)(result + 578) = 0;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// E9C38: using guessed type int x_DWORD_E9C38_smalltit;
// EA3D8: using guessed type int *xadatapald0dat2.var28_begin_buffer;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (000480A0) --------------------------------------------------------
unsigned __int8 /*__fastcall*/ sub_480A0(int a1, int a2, int a3)//2280a0
{
	long v3; // ebx
	unsigned int v4; // eax
	int v5; // edx

	// fix if begin
	v4 = 0;
	v5 = 0;
	// end

	v3 = j___clock();
	sub_98790(0x1F4u, 0);
	do
		v4 = j___clock() - v3;
	while (v4 < 0x32);
	sub_90B27_VGA_pal_fadein_fadeout(0, 0x10u, 0);
	*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 570) = 0;
	sub_53E60_readfile_and_decompress("data/pald-0.dat", xadatapald0dat2.var28_begin_buffer);
	sub_53E60_readfile_and_decompress("data/clrd-0.dat", xadataclrd0dat.var28_begin_buffer);
	return sub_48120();
}
// 98786: using guessed type int /*__fastcall*/ j___clock(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3D8: using guessed type int *xadatapald0dat2.var28_begin_buffer;

//----- (00048120) --------------------------------------------------------
unsigned __int8 sub_48120()//229120
{
	unsigned __int8 result; // al

	result = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308);
	if (result >= 1u)
	{
		if (result <= 1u)
		{
			x_BYTE_E88E0[0] = -92;
			x_BYTE_E88E1[0] = -86;
			x_BYTE_E88E3 = 119;
			x_BYTE_E88E2[0] = 123;
			x_BYTE_E88E4 = 125;
			x_BYTE_E88E5 = 123;
			x_BYTE_E88E7 = -58;
			x_BYTE_E88E8 = 123;
			x_BYTE_E88E6 = -64;
			x_BYTE_E88EC = -105;
			x_BYTE_E88EF = -41;
			x_BYTE_E88EB = 123;
			x_BYTE_E88F0 = -35;
			x_BYTE_E88E9 = 88;
		}
		else
		{
			if (result != 2)
				return result;
			x_BYTE_E88E0[0] = -32;
			x_BYTE_E88E1[0] = 88;
			x_BYTE_E88E3 = 119;
			x_BYTE_E88E2[0] = 123;
			x_BYTE_E88E4 = 125;
			x_BYTE_E88E5 = 123;
			x_BYTE_E88E7 = -58;
			x_BYTE_E88E8 = 123;
			x_BYTE_E88E9 = 88;
			x_BYTE_E88E6 = -64;
			x_BYTE_E88EC = -105;
			x_BYTE_E88EF = -41;
			x_BYTE_E88EB = 123;
			x_BYTE_E88F0 = -35;
		}
		x_BYTE_E88F3 = 98;
		x_BYTE_E88EA = 93;
		x_BYTE_E88F1 = 123;
		x_BYTE_E88ED = -99;
		x_BYTE_E88EE = 123;
		x_BYTE_E88F2 = 105;
		result = 123;
		x_BYTE_E88F4 = 123;
		x_BYTE_E88F5 = -55;
		x_BYTE_E88F7 = 123;
		x_BYTE_E88F6 = -49;
		return result;
	}
	if (!result)
	{
		x_BYTE_E88E0[0] = 96;
		x_BYTE_E88E1[0] = 100;
		x_BYTE_E88E6 = 28;
		x_BYTE_E88E2[0] = 123;
		x_BYTE_E88E3 = 123;
		x_BYTE_E88E5 = 123;
		x_BYTE_E88E7 = 24;
		x_BYTE_E88E8 = 123;
		x_BYTE_E88ED = -105;
		result = -37;
		x_BYTE_E88E4 = 119;
		x_BYTE_E88E9 = 91;
		x_BYTE_E88EB = 123;
		x_BYTE_E88EF = -37;
		x_BYTE_E88F5 = 61;
		x_BYTE_E88EA = 87;
		x_BYTE_E88EC = -102;
		x_BYTE_E88EE = 123;
		x_BYTE_E88F0 = -40;
		x_BYTE_E88F1 = 123;
		x_BYTE_E88F6 = 58;
		x_BYTE_E88F2 = 118;
		x_BYTE_E88F3 = -96;
		x_BYTE_E88F7 = 123;
		x_BYTE_E88F4 = 123;
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// E88E3: using guessed type char x_BYTE_E88E3;
// E88E4: using guessed type char x_BYTE_E88E4;
// E88E5: using guessed type char x_BYTE_E88E5;
// E88E6: using guessed type char x_BYTE_E88E6;
// E88E7: using guessed type char x_BYTE_E88E7;
// E88E8: using guessed type char x_BYTE_E88E8;
// E88E9: using guessed type char x_BYTE_E88E9;
// E88EA: using guessed type char x_BYTE_E88EA;
// E88EB: using guessed type char x_BYTE_E88EB;
// E88EC: using guessed type char x_BYTE_E88EC;
// E88ED: using guessed type char x_BYTE_E88ED;
// E88EE: using guessed type char x_BYTE_E88EE;
// E88EF: using guessed type char x_BYTE_E88EF;
// E88F0: using guessed type char x_BYTE_E88F0;
// E88F1: using guessed type char x_BYTE_E88F1;
// E88F2: using guessed type char x_BYTE_E88F2;
// E88F3: using guessed type char x_BYTE_E88F3;
// E88F4: using guessed type char x_BYTE_E88F4;
// E88F5: using guessed type char x_BYTE_E88F5;
// E88F6: using guessed type char x_BYTE_E88F6;
// E88F7: using guessed type char x_BYTE_E88F7;

//----- (00048350) --------------------------------------------------------
void sub_48350()//229350
{
	//Bit8s* result; // eax

	x_D41A0_BYTEARRAY_4_struct.setting_38545 &= 0x43u;
	//result = (Bit8s*)x_D41A0_BYTEARRAY_0;
	x_D41A0_BYTEARRAY_0[0x36E0B] &= 0xFEu;
	//return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (00048370) --------------------------------------------------------
int sub_48370(__int16 a1, __int16 a2, __int16 a3)//229370
{
	int result; // eax
	int v4; // ebx
	int v5; // edx

	LOWORD(result) = a2 - a1;
	v4 = (signed __int16)(a2 - a1);
	v5 = a3 >> 1;
	if (v4 > v5)
		return (signed __int16)(result - a3);
	if (v4 < -v5)
		LOWORD(result) = a3 + result;
	return (signed __int16)result;
}

//----- (000483A0) --------------------------------------------------------
int sub_483A0(__int16 a1, int a2, char a3, char a4)//2293a0
{
	unsigned __int16 v4; // ax
	__int16 v5; // bx
	unsigned __int16 v6; // ax
	signed int v7; // ecx
	int result; // eax

	LOBYTE(v4) = a1;
	HIBYTE(v4) = a2;
	LOBYTE(v5) = x_BYTE_11B4E0[v4];
	LOBYTE(v6) = a3;
	v5 = (unsigned __int8)v5;
	HIBYTE(v6) = a4;
	v7 = x_BYTE_11B4E0[v6];
	if (v7 > (unsigned __int8)v5)
		LOBYTE(v5) = x_BYTE_11B4E0[v6];
	x_WORD_EB398 = a1 << 8;
	result = a2 << 8;
	x_WORD_EB39C = 32 * v5;
	x_WORD_EB39A = (x_WORD)a2 << 8;
	return result;
}
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39A: using guessed type __int16 x_WORD_EB39A;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (00048400) --------------------------------------------------------
int sub_48400(int a1, int a2, int a3, int a4)//229400
{
	int v4; // eax
	int v5; // esi
	int v6; // ebx
	int result; // eax
	int v8; // ecx
	int v9; // eax
	int v10; // eax
	int v11; // edi
	int v12; // esi
	int v13; // eax
	int v14; // eax
	int v15; // ebx
	int v16; // edx
	int v17; // eax
	int v18; // edi
	int v19; // eax
	int v20; // esi
	int v21; // ecx
	int v22; // eax
	int v23; // ebx
	int v24; // eax
	int v25; // [esp+8h] [ebp-Ch]
	int i; // [esp+8h] [ebp-Ch]
	int v27; // [esp+Ch] [ebp-8h]
	int v28; // [esp+Ch] [ebp-8h]
	int v29; // [esp+10h] [ebp-4h]
	int v30; // [esp+10h] [ebp-4h]

	v4 = sub_48370(a1, a3, 256);
	v5 = v4;
	v6 = v4;
	result = sub_48370(a2, a4, 256);
	v8 = result;
	if (v5 || result)
	{
		if (v6 < 0)
		{
			v9 = a1;
			v6 = -v6;
			v8 = -v8;
			a1 = a3;
			a3 = v9;
			v10 = a2;
			a2 = a4;
			a4 = v10;
		}
		if (v6 <= abs(v8))
		{
			v17 = abs(v8 / 10);
			v18 = v17 + 1;
			v19 = v8 / (v17 + 1);
			v20 = v19;
			v21 = v8 - v18 * v19;
			v30 = v6 / v18;
			result = v18 * (v6 / v18);
			v28 = v21;
			for (i = v6 - result; v18; v28 = 0)
			{
				sub_483A0(a1, (unsigned __int16)a2, a3, a4);
				v22 = sub_4A190((int)&x_WORD_EB398, 10, 27);
				if (v20 >= 0)
				{
					*(x_BYTE *)(v22 + 69) = 28;
					v23 = v20 + v28;
				}
				else
				{
					*(x_BYTE *)(v22 + 69) = 27;
					v23 = -v20 - v28;
				}
				*(x_DWORD *)(v22 + 16) = v23;
				sub_483A0(a1, (unsigned __int16)(v20 + v28 + a2), a3, a4);
				--v18;
				a2 += v20 + v28;
				v24 = sub_4A190((int)&x_WORD_EB398, 10, 27);
				*(x_BYTE *)(v24 + 69) = 29;
				*(x_DWORD *)(v24 + 16) = i + v30;
				result = 0;
				a1 += i + v30;
				i = 0;
			}
		}
		else
		{
			v11 = v6 / 10 + 1;
			v29 = v6 / v11;
			v12 = v8 / v11;
			result = v11 * (v8 / v11);
			v25 = v6 - v11 * (v6 / v11);
			v27 = v8 - result;
			if (v6 / 10 != -1)
			{
				do
				{
					sub_483A0(a1, (unsigned __int16)a2, a3, a4);
					v13 = sub_4A190((int)&x_WORD_EB398, 10, 27);
					*(x_BYTE *)(v13 + 69) = 29;
					*(x_DWORD *)(v13 + 16) = v25 + v29;
					a1 += v25 + v29;
					sub_483A0(a1, (unsigned __int16)a2, a3, a4);
					v14 = sub_4A190((int)&x_WORD_EB398, 10, 27);
					if (v12 >= 0)
					{
						*(x_BYTE *)(v14 + 69) = 28;
						v15 = v12 + v27;
					}
					else
					{
						*(x_BYTE *)(v14 + 69) = 27;
						v15 = -v12 - v27;
					}
					*(x_DWORD *)(v14 + 16) = v15;
					--v11;
					result = v12 + v27;
					v25 = 0;
					v16 = v12 + v27 + a2;
					v27 = 0;
					a2 = v16;
				} while (v11);
			}
		}
	}
	return result;
}
// EB398: using guessed type __int16 x_WORD_EB398;

//----- (00048690) --------------------------------------------------------
int sub_48690(__int16 a1, __int16 a2, __int16 a3, __int16 a4)//229690
{
	int v4; // eax
	int v5; // ebx
	signed __int16 v6; // si
	int v7; // eax
	signed __int16 v8; // bx
	int v9; // edi
	int v10; // eax
	int result; // eax
	int v12; // [esp+0h] [ebp-14h]
	int v13; // [esp+4h] [ebp-10h]
	signed __int16 v14; // [esp+8h] [ebp-Ch]
	signed __int16 v15; // [esp+Ch] [ebp-8h]
	int v16; // [esp+10h] [ebp-4h]

	v4 = sub_48370(a1, a3, 256);
	v5 = v4;
	v13 = v4;
	v6 = 0;
	v7 = sub_48370(a2, a4, 256);
	if (v5)
	{
		v6 = -1;
		if (v5 > 0)
			v6 = 1;
	}
	v8 = 0;
	if (v7)
	{
		v8 = -1;
		if (v7 > 0)
			v8 = 1;
	}
	v16 = abs(v7);
	v9 = abs(v13);
	v12 = abs(v16 - v9);
	if (v9 <= v16)
	{
		v15 = v8;
		v14 = 0;
	}
	else
	{
		v9 = v16;
		v14 = v6;
		v15 = 0;
	}
	x_WORD_EB398 = a1 << 8;
	x_WORD_EB39A = a2 << 8;
	v10 = sub_4A190((int)&x_WORD_EB398, 10, 30);
	if (v10)
	{
		*(x_DWORD *)(v10 + 16) = v9;
		*(x_WORD *)(v10 + 28) = v6;
		*(x_WORD *)(v10 + 30) = v8;
	}
	x_WORD_EB398 = ((x_WORD)v9 * v6 + a1) << 8;
	x_WORD_EB39A = ((x_WORD)v9 * v8 + a2) << 8;
	result = sub_4A190((int)&x_WORD_EB398, 10, 30);
	if (result)
	{
		*(x_DWORD *)(result + 16) = v12;
		*(x_WORD *)(result + 28) = v14;
		*(x_WORD *)(result + 30) = v15;
	}
	return result;
}
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39A: using guessed type __int16 x_WORD_EB39A;

//----- (000487D0) --------------------------------------------------------
int sub_487D0(unsigned __int16 a1, unsigned __int16 a2, __int16 a3, __int16 a4, char a5)//2297d0
{
	__int16 v5; // si
	unsigned __int16 v6; // bx
	int result; // eax
	__int16 v8; // [esp+0h] [ebp-10h]
	__int16 v9; // [esp+2h] [ebp-Eh]
	__int16 v10; // [esp+4h] [ebp-Ch]
	__int16 v11; // [esp+8h] [ebp-8h]
	__int16 v12; // [esp+Ah] [ebp-6h]

	v8 = a1 << 8;
	v9 = a2 << 8;
	v10 = 32 * x_BYTE_11B4E0[256 * a2 + a1];
	v11 = a3 << 8;
	v12 = a4 << 8;
	v5 = sub_581E0((Bit16u *)&v8, (Bit16u *)&v11);
	v6 = sub_58490(&v8, &v11);
	result = sub_4A190((int)&v8, 10, 32);
	if (result)
	{
		*(x_WORD *)(result + 28) = v5;
		*(x_DWORD *)(result + 8) = (signed int)v6 >> 8;
		*(x_BYTE *)(result + 70) = a5;
	}
	return result;
}

//----- (00048880) --------------------------------------------------------
int sub_48880(unsigned __int16 a1, unsigned __int16 a2, __int16 a3, __int16 a4)//229880
{
	__int16 v4; // si
	unsigned __int16 v5; // di
	int result; // eax
	int v7; // ebx
	int v8; // ecx
	__int16 v9; // [esp+0h] [ebp-10h]
	__int16 v10; // [esp+2h] [ebp-Eh]
	__int16 v11; // [esp+4h] [ebp-Ch]
	__int16 v12; // [esp+8h] [ebp-8h]
	__int16 v13; // [esp+Ah] [ebp-6h]

	v9 = a1 << 8;
	v10 = a2 << 8;
	v11 = 16 * x_BYTE_11B4E0[256 * a2 + a1];
	v12 = a3 << 8;
	v13 = a4 << 8;
	v4 = sub_581E0((Bit16u *)&v9, (Bit16u *)&v12);
	v5 = sub_58490(&v9, &v12);
	result = sub_4A190((int)&v9, 10, 51);
	v7 = result;
	if (result)
	{
		v8 = *(signed __int16 *)(result + 130);
		*(x_WORD *)(result + 28) = v4;
		result = v5 / v8;
		*(x_DWORD *)(v7 + 8) = result;
	}
	return result;
}

//----- (00048990) --------------------------------------------------------
int sub_48990(char a1, char a2, char a3, char a4)//229990
{
	unsigned __int16 v4; // ax
	unsigned __int16 v5; // dx
	unsigned int v6; // eax
	unsigned int v7; // ebx
	unsigned int v8; // ecx
	unsigned int v9; // ecx
	unsigned int v10; // ecx

	LOBYTE(v4) = a1;
	HIBYTE(v4) = a2;
	HIBYTE(v5) = a2;
	LOBYTE(v5) = a4 + a1;
	v6 = x_BYTE_11B4E0[v4];
	v7 = v6;
	v8 = x_BYTE_11B4E0[v5];
	if (v8 <= v6)
	{
		if (v8 < v6)
			v7 = x_BYTE_11B4E0[v5];
	}
	else
	{
		v6 = x_BYTE_11B4E0[v5];
	}
	HIBYTE(v5) = a3 + a2;
	v9 = x_BYTE_11B4E0[v5];
	if (v9 <= v6)
	{
		if (v9 < v7)
			v7 = x_BYTE_11B4E0[v5];
	}
	else
	{
		v6 = x_BYTE_11B4E0[v5];
	}
	LOBYTE(v5) = a1;
	v10 = x_BYTE_11B4E0[v5];
	if (v10 > v6)
		return v10 - v7;
	if (v10 < v7)
		v7 = x_BYTE_11B4E0[v5];
	return v6 - v7;
}

//----- (00048A20) --------------------------------------------------------
__int16 sub_48A20(int a1, char a2, char a3, int a4, int a5, unsigned __int8 a6)//229a20
{
	int v6; // eax
	int v7; // esi
	unsigned __int16 v8; // bx
	unsigned __int16 v9; // bx
	int v10; // eax
	int v11; // edi
	char v13; // [esp+0h] [ebp-8h]
	char v14; // [esp+1h] [ebp-7h]
	__int16 v15; // [esp+2h] [ebp-6h]
	unsigned __int16 v16; // [esp+4h] [ebp-4h]
	unsigned __int16 v17; // [esp+4h] [ebp-4h]

	// fix if begin
	v15 = 0;
	// end

	v13 = a2 - a5;
	v14 = a3 - a4;
	HIWORD(v6) = v15;
	HIBYTE(v16) = a3 - a4;
	HIBYTE(v8) = a3 - a4;
	v7 = 2 * a4;
	LOBYTE(v8) = a2 - a5 - a6;
	LOBYTE(v16) = 2 * a5 + a2 - a5;
	while ((x_WORD)--v7 != -1)
	{
		LOWORD(a1) = a6;
		++a1;
		while ((x_WORD)--a1 != -1)
		{
			sub_48B90(v8);
			sub_48B90(v16);
			LOBYTE(v8) = v8 + 1;
			LOBYTE(v16) = v16 + 1;
		}
		LOBYTE(v16) = 2 * a5 + v13;
		LOBYTE(v8) = v13 - a6;
		++HIBYTE(v8);
		++HIBYTE(v16);
	}
	LOBYTE(v9) = v13 - a6;
	LOBYTE(v17) = v13 - a6;
	HIBYTE(v9) = v14 - a6;
	HIBYTE(v17) = 2 * a4 + v14;
	LOWORD(v6) = a6;
	v10 = 2 * v6;
	v11 = v10 + 2 * a5;
	while ((x_WORD)--v11 != -1)
	{
		LOWORD(v7) = a6;
		++v7;
		while ((x_WORD)--v7 != -1)
		{
			sub_48B90(v9);
			sub_48B90(v17);
			++HIBYTE(v9);
			++HIBYTE(v17);
		}
		LOBYTE(v10) = 2 * a4;
		HIBYTE(v9) = v14 - a6;
		LOBYTE(v9) = v9 + 1;
		BYTE1(v10) = 2 * a4 + v14;
		HIBYTE(v17) = 2 * a4 + v14;
		LOBYTE(v17) = v17 + 1;
	}
	return v10;
}

//----- (00048B50) --------------------------------------------------------
__int16 sub_48B50(unsigned __int8 a1, char a2, int a3, int a4)//229b50
{
	int v4; // edi
	unsigned __int16 v5; // bx
	int v6; // esi
	__int16 result; // ax

	LOBYTE(v5) = a1;
	v4 = a3;
	HIBYTE(v5) = a2;
	while ((x_WORD)--v4 != -1)
	{
		v6 = a4;
		while ((x_WORD)--v6 != -1)
		{
			result = sub_48B90(v5);
			LOBYTE(v5) = v5 + 1;
		}
		v5 = __PAIR__(HIBYTE(v5), a1) + 256;
	}
	return result;
}

//----- (00048B90) --------------------------------------------------------
__int16 sub_48B90(int a1)//229b90
{
	int i; // eax
	unsigned int v2; // ecx
	unsigned int v3; // ebx
	char v4; // dl
	char v5; // dh
	unsigned __int8 v6; // dh
	char v7; // bl

	LOWORD(i) = a1;
	v2 = 0;
	v3 = 0;
	if (x_BYTE_13B4E0[(unsigned __int16)a1] & 7
		&& x_BYTE_11B4E0[(unsigned __int16)a1]
		&& ((unsigned __int8)x_BYTE_10B3DF[(unsigned __int16)a1] <= 5u
			|| (unsigned __int8)x_BYTE_10B3DF[(unsigned __int16)a1] > 0x22u)
		&& ((unsigned __int8)x_BYTE_10B3E0[(unsigned __int16)a1] <= 5u
			|| (unsigned __int8)x_BYTE_10B3E0[(unsigned __int16)a1] > 0x22u)
		&& ((unsigned __int8)x_BYTE_10B4DF[(unsigned __int16)a1] <= 5u
			|| (unsigned __int8)x_BYTE_10B4DF[(unsigned __int16)a1] > 0x22u)
		&& ((unsigned __int8)x_BYTE_10B4E0[(unsigned __int16)a1] <= 5u
			|| (unsigned __int8)x_BYTE_10B4E0[(unsigned __int16)a1] > 0x22u))
	{
		v4 = 3;
		for (i = a1 - 257; --v4 != -1; i += 253)
		{
			v5 = 3;
			while (--v5 != -1)
			{
				if ((unsigned __int8)x_BYTE_10B4E0[(unsigned __int16)i] <= 5u
					|| (unsigned __int8)x_BYTE_10B4E0[(unsigned __int16)i] > 0x22u)
				{
					++v3;
					v2 += x_BYTE_11B4E0[(unsigned __int16)i];
				}
				++i;
			}
		}
		if (v3)
		{
			i = (unsigned __int16)a1;
			x_BYTE_11B4E0[(unsigned __int16)a1] = v2 / v3;
			if (x_BYTE_D41B6)
			{
				v6 = x_BYTE_11B4E0[(unsigned __int16)a1];
				if ((unsigned __int8)x_BYTE_14B4E0[(unsigned __int16)a1] > v6)
				{
					x_BYTE_13B4E0[(unsigned __int16)a1] &= 0xF7u;
				}
				else
				{
					v7 = x_BYTE_13B4E0[(unsigned __int16)a1] | 8;
					x_BYTE_14B4E0[(unsigned __int16)a1] = v6 - 1;
					x_BYTE_13B4E0[(unsigned __int16)a1] = v7;
				}
			}
		}
	}
	return i;
}
// D41B6: using guessed type char x_BYTE_D41B6;

//----- (00048D20) --------------------------------------------------------
__int16 sub_48D20(int a1, unsigned __int16 a2)//229d20
{
	unsigned int v2; // esi
	unsigned int v3; // ecx
	signed int v4; // eax
	int v5; // ebx
	unsigned __int8 v6; // bl
	unsigned __int8 v7; // dh
	char v9; // [esp+8h] [ebp-8h]
	char v10; // [esp+Ch] [ebp-4h]

	v2 = 0;
	v3 = 0;
	LOBYTE(v4) = x_BYTE_14B4E0[(unsigned __int16)a1];
	BYTE1(v4) = 3;
	v5 = a1 - 257;
	v9 = 3;
	while (--v9 != -1)
	{
		v10 = 3;
		while (1)
		{
			BYTE1(v4) = v10 - 1;
			v10 = BYTE1(v4);
			if (BYTE1(v4) == -1)
				break;
			v4 = abs((unsigned __int8)x_BYTE_14B4E0[(unsigned __int16)v5] - (unsigned __int8)x_BYTE_14B4E0[(unsigned __int16)a1]);
			if (v4 > a2)
			{
				v4 = (unsigned __int8)x_BYTE_14B4E0[(unsigned __int16)v5];
				++v3;
				v2 += v4;
			}
			++v5;
		}
		v5 += 253;
	}
	if (v3)
	{
		v6 = v2 / v3;
		v4 = (unsigned __int16)a1;
		v7 = x_BYTE_11B4E0[(unsigned __int16)a1];
		x_BYTE_14B4E0[(unsigned __int16)a1] = v6;
		if (v6 > v7)
		{
			x_BYTE_13B4E0[(unsigned __int16)a1] &= 0xF7u;
		}
		else
		{
			x_BYTE_14B4E0[(unsigned __int16)a1] = v7 - 1;
			x_BYTE_13B4E0[(unsigned __int16)a1] |= 8u;
		}
	}
	return v4;
}

//----- (00048DF0) --------------------------------------------------------
__int16 sub_48DF0(char a1, char a2, char a3, char a4)//229df0
{
	unsigned __int16 v4; // ax
	unsigned __int16 v5; // dx
	int v6; // eax
	unsigned __int16 v7; // bx

	LOBYTE(v4) = a1;
	HIBYTE(v4) = a2;
	HIBYTE(v5) = a2;
	LOBYTE(v5) = a4 + a1;
	v6 = x_BYTE_11B4E0[v5] + x_BYTE_11B4E0[v4];
	HIBYTE(v5) = a3 + a2;
	v7 = v5;
	LOBYTE(v5) = a1;
	return (x_BYTE_11B4E0[v5] + (unsigned int)x_BYTE_11B4E0[v7] + v6) >> 2;
}

//----- (00048E60) --------------------------------------------------------
signed int sub_48E60(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4)//229e60
{
	return sub_48F20(a1, a2, a3, a4, (int)x_BYTE_11B4E0);
}

//----- (00048E90) --------------------------------------------------------
signed int sub_48E90(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4)//229e90
{
	return sub_48FD0(a1, a2, a3, a4, (int)x_BYTE_11B4E0);
}

//----- (00048EC0) --------------------------------------------------------
signed int sub_48EC0(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4)//229ec0
{
	return sub_48F20(a1, a2, a3, a4, (int)x_BYTE_14B4E0);
}

//----- (00048EF0) --------------------------------------------------------
signed int sub_48EF0(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4)//229ef0
{
	return sub_48FD0(a1, a2, a3, a4, (int)x_BYTE_14B4E0);
}

//----- (00048F20) --------------------------------------------------------
signed int sub_48F20(char a1, char a2, __int16 a3, unsigned __int16 a4, int a5)//229f20
{
	signed int result; // eax
	unsigned __int16 v6; // dx
	int v7; // esi
	int v8; // ebx
	signed int v9; // ebx
	int v10; // ebx
	signed int v11; // ebx

	LOBYTE(v6) = a1;
	result = 250;
	HIBYTE(v6) = a2;
	v7 = a4;
	if (a4)
	{
		do
		{
			LOBYTE(v8) = v6;
			if (result > *(unsigned __int8 *)(a5 + v6))
				result = *(unsigned __int8 *)(a5 + v6);
			BYTE1(v8) = a3 + a2;
			v9 = *(unsigned __int8 *)(a5 + (unsigned __int16)v8);
			if (v9 < result)
				result = v9;
			LOBYTE(v6) = v6 + 1;
			--v7;
		} while (v7);
		LOWORD(v7) = a3;
		if (a3)
			goto LABEL_9;
	}
	else
	{
		LOWORD(v7) = a3;
		while (v7)
		{
		LABEL_9:
			BYTE1(v10) = HIBYTE(v6);
			if (result > *(unsigned __int8 *)(a5 + v6))
				result = *(unsigned __int8 *)(a5 + v6);
			LOBYTE(v10) = v6 - a4;
			v11 = *(unsigned __int8 *)(a5 + (unsigned __int16)v10);
			if (v11 < result)
				result = v11;
			++HIBYTE(v6);
			--v7;
		}
	}
	return result;
}

//----- (00048FD0) --------------------------------------------------------
signed int sub_48FD0(char a1, char a2, __int16 a3, unsigned __int16 a4, int a5)//229fd0
{
	signed int result; // eax
	unsigned __int16 v6; // dx
	int v7; // esi
	int v8; // ebx
	signed int v9; // ebx
	int v10; // ebx
	signed int v11; // ebx

	LOBYTE(v6) = a1;
	result = 0;
	HIBYTE(v6) = a2;
	v7 = a4;
	if (a4)
	{
		do
		{
			LOBYTE(v8) = v6;
			if (result < *(unsigned __int8 *)(a5 + v6))
				result = *(unsigned __int8 *)(a5 + v6);
			BYTE1(v8) = a3 + a2;
			v9 = *(unsigned __int8 *)(a5 + (unsigned __int16)v8);
			if (v9 > result)
				result = v9;
			LOBYTE(v6) = v6 + 1;
			--v7;
		} while (v7);
		LOWORD(v7) = a3;
		if (a3)
			goto LABEL_9;
	}
	else
	{
		LOWORD(v7) = a3;
		while (v7)
		{
		LABEL_9:
			BYTE1(v10) = HIBYTE(v6);
			if (result < *(unsigned __int8 *)(a5 + v6))
				result = *(unsigned __int8 *)(a5 + v6);
			LOBYTE(v10) = v6 - a4;
			v11 = *(unsigned __int8 *)(a5 + (unsigned __int16)v10);
			if (v11 > result)
				result = v11;
			++HIBYTE(v6);
			--v7;
		}
	}
	return result;
}

//----- (00049090) --------------------------------------------------------
void sub_49090(int a1, x_WORD *a2)
{
	x_WORD *v2; // ebx
	unsigned __int16 v3; // si
	__int16 v4; // di
	unsigned __int16 v5; // dx
	__int16 v6; // dx
	unsigned __int16 v7; // cx
	unsigned int v8; // eax
	int(*v9)(); // [esp+4h] [ebp-10h]
	unsigned __int16 v10; // [esp+8h] [ebp-Ch]

	v2 = a2;
	v3 = a2[1];
	v4 = *a2;
	v9 = 0;
	if (*a2 == 10)
	{
		if (v3 < 0x1Fu)
		{
			if (v3 >= 0x1Cu)
			{
				if (v3 <= 0x1Cu)
				{
					v9 = (int(*)())sub_48400;
				}
				else if (v3 == 29)
				{
					v9 = (int(*)())sub_48690;
				}
			}
		}
		else if (v3 <= 0x1Fu)
		{
			v9 = (int(*)())sub_487D0;
		}
		else if (v3 >= 0x32u)
		{
			if (v3 <= 0x32u)
			{
				v9 = (int(*)())sub_48880;
			}
			else if (v3 == 80)
			{
				v9 = sub_48930;
			}
		}
	}
	if (v9)
	{
		while (1)
		{
			v5 = v2[7];
			if (!v5)
				break;
			v2 = (x_WORD *)(20 * v5 + a1 + 1091);
		}
		do
		{
			if (v4 != *v2)
				break;
			if (v3 != v2[1])
				break;
			v6 = v2[8];
			v2[6] = 0;
			if (!v6)
				break;
			v7 = v2[3];
			v10 = v2[2];
			v8 = (unsigned __int16)v2[9];
			v2 = (x_WORD *)(20 * (unsigned __int16)v2[8] + a1 + 1091);
			if (v3 >= 0x1Fu)
			{
				if (v3 <= 0x1Fu)
				{
					if (v8 <= 3)
					{
						switch (v8)
						{
						case 0u:
							v8 = 2;
							break;
						case 1u:
							v8 = 6;
							break;
						case 2u:
							v8 = 16;
							break;
						case 3u:
							v8 = 32;
							break;
						}
					}
				}
				else if (v3 == 80)
				{
					v8 = v2[9] & 0xF | 16 * (v8 & 0xF);
				}
			}
			((void(*)(x_DWORD, x_DWORD, x_DWORD, x_DWORD, unsigned int))v9)(
				v10,
				v7,
				(unsigned __int16)v2[2],
				(unsigned __int16)v2[3],
				v8);
		} while (v2);
	}
}
// 48930: using guessed type int sub_48930();

//----- (00049270) --------------------------------------------------------
void sub_49270_generate_level_features(Bit8u* a1)
{
	sub_49830((int)a1);
	sub_49290((int)a1, 1);
}

//----- (00049290) --------------------------------------------------------
int sub_49290(int a1, char a2)
{
	__int16 *i; // ebx
	__int16 v3; // ax
	__int16 *j; // ebx
	__int16 v5; // cx
	__int16 v6; // ax
	__int16 *k; // ebx
	__int16 v8; // dx
	__int16 v9; // ax
	__int16 *l; // ebx
	__int16 v11; // ax
	__int16 *m; // ebx
	__int16 v13; // ax
	__int16 v14; // ax
	__int16 *n; // ebx
	__int16 v16; // ax
	__int16 *ii; // ebx
	__int16 v18; // ax

	for (i = (__int16 *)(a1 + 1111); (unsigned int)i < a1 + 25091; i += 10)
	{
		if (i[4] == -1 && *i == 10 && i[1] == 82)
		{
			sub_49540(a1, (int)i);
			if (a2)
				v3 = 0;
			else
				v3 = *i;
			*i = v3;
		}
	}
	sub_498A0();
	for (j = (__int16 *)(a1 + 1111); (unsigned int)j < a1 + 25091; j += 10)
	{
		if (j[4] == -1 && *j == 10)
		{
			v5 = j[1];
			if (v5 == 9
				|| v5 == 83
				|| v5 == 84
				|| v5 == 85
				|| v5 == 11
				|| v5 == 15
				|| v5 == 30
				|| v5 == 29
				|| v5 == 32
				|| v5 == 31
				|| v5 == 51
				|| v5 == 50
				|| v5 == 88)
			{
				sub_49540(a1, (int)j);
				if (a2)
					v6 = 0;
				else
					v6 = *j;
				*j = v6;
			}
		}
	}
	sub_498A0();
	for (k = (__int16 *)(a1 + 1111); (unsigned int)k < a1 + 25091; k += 10)
	{
		if (k[4] == -1 && *k == 10)
		{
			v8 = k[1];
			if (v8 == 81 || v8 == 80)
			{
				sub_49540(a1, (int)k);
				if (a2)
					v9 = 0;
				else
					v9 = *k;
				*k = v9;
			}
		}
	}
	sub_498A0();
	for (l = (__int16 *)(a1 + 1111); (unsigned int)l < a1 + 25091; l += 10)
	{
		if (l[4] == -1 && *l == 14 && l[1] == 2)
		{
			sub_49540(a1, (int)l);
			if (a2)
				v11 = 0;
			else
				v11 = *l;
			*l = v11;
		}
	}
	sub_498A0();
	for (m = (__int16 *)(a1 + 1111); (unsigned int)m < a1 + 25091; m += 10)
	{
		if (m[4] == -1 && *m == 10)
		{
			v13 = m[1];
			if (v13 == 27 || v13 == 28)
			{
				sub_49540(a1, (int)m);
				if (a2)
					v14 = 0;
				else
					v14 = *m;
				*m = v14;
			}
		}
	}
	sub_498A0();
	for (n = (__int16 *)(a1 + 1111); (unsigned int)n < a1 + 25091; n += 10)
	{
		if (n[4] == -1 && *n == 10 && n[1] == 45 && x_BYTE_D93C2[4 * (unsigned __int16)n[7]] & 0x10)
		{
			sub_49540(a1, (int)n);
			if (a2)
				v16 = 0;
			else
				v16 = *n;
			*n = v16;
		}
	}
	sub_498A0();
	for (ii = (__int16 *)(a1 + 1111); (unsigned int)ii < a1 + 25091; ii += 10)
	{
		if (ii[4] == -1 && *ii == 10 && ii[1] == 45 && !(x_BYTE_D93C2[4 * (unsigned __int16)ii[7]] & 0x10))
		{
			sub_49540(a1, (int)ii);
			if (a2)
				v18 = 0;
			else
				v18 = *ii;
			*ii = v18;
		}
	}
	return sub_498A0();
}

//----- (00049540) --------------------------------------------------------
void sub_49540(int a1, int a2)
{
	unsigned __int16 v2; // ax
	__int16 v3; // ax
	unsigned __int16 v4; // dx
	int v5; // eax
	__int16 v6; // ax
	unsigned __int16 v7; // dx
	int v8; // eax
	int v9; // esi
	unsigned __int16 v10; // dx
	char *v11; // eax
	__int16 v12; // ax
	unsigned __int16 v13; // dx
	int v14; // eax

	if (*(x_WORD *)a2 < 0xAu)
		return;
	if (*(x_WORD *)a2 > 0xAu)
	{
		if (*(x_WORD *)a2 == 14 && *(x_WORD *)(a2 + 2) == 2)
		{
			x_WORD_EB398 = *(x_WORD *)(a2 + 4) << 8;
			x_WORD_EB39A = *(x_WORD *)(a2 + 6) << 8;
			v12 = sub_10C40(&x_WORD_EB398);
			v13 = *(x_WORD *)(a2 + 2);
			x_WORD_EB39C = v12;
			if (*(int(**)(int))((char *)&off_D7B7A + 14 * v13))
			{
				v14 = (*(int(**)(int))((char *)&off_D7B7A + 14 * v13))((int)&x_WORD_EB398);
				if (v14)
				{
					*(x_WORD *)(v14 + 44) = *(x_WORD *)(a2 + 14);
					*(x_WORD *)(v14 + 150) = *(x_WORD *)(a2 + 18);
				}
			}
		}
		return;
	}
	v2 = *(x_WORD *)(a2 + 2);
	if (v2 < 0x2Du)
	{
		if (v2 < 0x1Cu || v2 > 0x1Du && v2 != 31)
			goto LABEL_20;
	LABEL_18:
		if (*(x_WORD *)(a2 + 12))
			sub_49090(a1, (x_WORD *)a2);
		return;
	}
	if (v2 <= 0x2Du)
	{
		x_WORD_EB398 = *(x_WORD *)(a2 + 4) << 8;
		x_WORD_EB39A = *(x_WORD *)(a2 + 6) << 8;
		v3 = sub_10C40(&x_WORD_EB398);
		v4 = *(x_WORD *)(a2 + 2);
		x_WORD_EB39C = v3;
		if (*(int(**)(int))((char *)&off_D697E + 14 * v4))
		{
			v5 = (*(int(**)(int))((char *)&off_D697E + 14 * v4))((int)&x_WORD_EB398);
			if (v5)
				sub_49A30(v5, *(x_WORD *)(a2 + 14));
		}
		return;
	}
	if (v2 >= 0x32u && (v2 <= 0x32u || v2 == 80))
		goto LABEL_18;
LABEL_20:
	x_WORD_EB398 = *(x_WORD *)(a2 + 4) << 8;
	x_WORD_EB39A = *(x_WORD *)(a2 + 6) << 8;
	v6 = sub_10C40(&x_WORD_EB398);
	v7 = *(x_WORD *)(a2 + 2);
	x_WORD_EB39C = v6;
	if (*(int(**)(int))((char *)&off_D697E + 14 * v7))
	{
		v8 = (*(int(**)(int))((char *)&off_D697E + 14 * v7))((int)&x_WORD_EB398);
		v9 = v8;
		if (v8)
		{
			v10 = *(x_WORD *)(a2 + 2);
			if (v10 < 0x52u)
			{
				if (v10 < 0xBu)
				{
					if (v10 != 9)
						return;
				}
				else if (v10 > 0xBu && v10 != 15)
				{
					return;
				}
				v11 = (char*)*xadataspellsdat.var28_begin_buffer[80 * (unsigned __int8)sub_6E020(*(x_WORD *)(a2 + 2)) + 2 + 26 * *(unsigned __int16 *)(a2 + 14)];
				*(x_WORD *)(v9 + 42) = *(x_WORD *)v11;
				if (*(x_WORD *)(a2 + 2) == 9)
					*(x_DWORD *)(v9 + 4) = (unsigned __int8)v11[24];
				else
					*(x_DWORD *)(v9 + 8) = (unsigned __int8)v11[24];
				return;
			}
			if (v10 <= 0x52u)
			{
				*(x_BYTE *)(v8 + 70) = *(x_BYTE *)(a2 + 18);
				*(x_BYTE *)(v8 + 67) = *(x_BYTE *)(a2 + 14);
				*(x_BYTE *)(v8 + 68) = *(x_BYTE *)(a2 + 16);
			}
			else if (v10 < 0x54u)
			{
				*(x_WORD *)(v8 + 154) = *(x_WORD *)(a2 + 10);
			}
			else if (v10 <= 0x55u)
			{
				*(x_WORD *)(v8 + 154) = *(x_WORD *)(a2 + 10);
				*(x_WORD *)(v8 + 80) = *(x_WORD *)(a2 + 18);
			}
			else if (v10 == 88)
			{
				*(x_WORD *)(v8 + 84) = *(x_WORD *)(a2 + 14);
				*(x_WORD *)(v8 + 86) = *(x_WORD *)(a2 + 16);
			}
		}
	}
}
// D697E: using guessed type int (*off_D697E)(int);
// D7B7A: using guessed type int (*off_D7B7A)(int);
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39A: using guessed type __int16 x_WORD_EB39A;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (00049830) --------------------------------------------------------
int sub_49830(int a1)
{
	x_WORD *v1; // edx
	int result; // eax
	unsigned __int16 v3; // ax

	v1 = (x_WORD *)(a1 + 1111);
	result = a1 + 25091;
	if (a1 + 1111 < (unsigned int)(a1 + 25091))
	{
		do
		{
			if (v1[4] != -1 || *v1 != 10)
				goto LABEL_13;
			v3 = v1[1];
			if (v3 < 0x1Fu)
			{
				if (v3 < 0x1Cu || v3 > 0x1Du)
					goto LABEL_13;
			}
			else if (v3 > 0x1Fu && (v3 < 0x32u || v3 > 0x32u && v3 != 80))
			{
				goto LABEL_13;
			}
			v1[6] = 1;
		LABEL_13:
			v1 += 10;
			result = a1 + 25091;
		} while ((unsigned int)v1 < a1 + 25091);
	}
	return result;
}

//----- (000498A0) --------------------------------------------------------
int sub_498A0()
{
	Bit8u* result; // eax
	signed int v1; // esi
	Bit8u* i; // ebx
	char v3; // ah
	unsigned __int8 v4; // al
	int v5; // eax
	int v6; // eax
	void(*v7)(unsigned int); // [esp+0h] [ebp-8h]
	void(*v8)(unsigned int, void(*)(unsigned int)); // [esp+4h] [ebp-4h]

	// fix if begin
	v7 = 0;
	// end

	result = x_D41A0_BYTEARRAY_0;
	v1 = 1;
	*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8) = 9377 * *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8) + 9439;
LABEL_2:
	if (v1)
	{
		v1 = 0;
		for (i = x_D41A0_BYTEARRAY_0 + 28470; ; i += 168)
		{
			result = x_D41A0_BYTEARRAY_0 + 196302;
			if (i >= x_D41A0_BYTEARRAY_0 + 196302)
				goto LABEL_2;
			v3 = *(x_BYTE *)(i + 63);
			if (v3)
				break;
		LABEL_37:
			;
		}
		if (v3 != 10)
		{
			if (v3 == 14)
			{
				if (*(x_BYTE *)(i + 64) == 2 && !*(x_DWORD *)(i + 8))
				{
					v6 = *(int *)((char *)&x_DWORD_D4C52 + 18 * *(char *)(i + 63)) + 14 * *(unsigned __int8 *)(i + 69);
					v1 = 1;
					v7 = *(void(**)(unsigned int))(v6 + 6);
					if (v7)
					{
						if (*(x_DWORD *)(v6 + 10))
							v7((int)i);
					}
				}
			}
			else
			{
				sub_57F10((int)i);
			}
			goto LABEL_35;
		}
		v4 = *(x_BYTE *)(i + 64);
		if (v4 < 0x1Bu)
		{
			if (v4 >= 0xBu)
			{
				if (v4 > 0xBu && v4 != 15)
					goto LABEL_26;
				goto LABEL_23;
			}
			if (v4 == 9)
				goto LABEL_23;
		}
		else
		{
			if (v4 <= 0x20u)
				goto LABEL_23;
			if (v4 >= 0x32u)
			{
				if (v4 > 0x33u && (v4 < 0x50u || v4 > 0x55u && v4 != 88))
					goto LABEL_26;
			LABEL_23:
				v5 = *(int *)((char *)&x_DWORD_D4C52 + 18 * *(char *)(i + 63)) + 14 * *(unsigned __int8 *)(i + 69);
				v1 = 1;
				v8 = *(void(**)(unsigned int, void(*)(unsigned int)))(v5 + 6);
				if (v8 && *(x_DWORD *)(v5 + 10))
					v8((int)i, v7);
				goto LABEL_27;
			}
			if (v4 == 45)
			{
				if (*(x_BYTE *)(i + 69) != 51)
				{
				LABEL_27:
					++*(x_BYTE *)(i + 62);
				LABEL_35:
					if (*(x_BYTE *)(i + 13) & 4)
						sub_57F20((int)i);
					goto LABEL_37;
				}
				goto LABEL_23;
			}
		}
	LABEL_26:
		sub_57F10((int)i);
		goto LABEL_27;
	}
	return (int)result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D4C52: using guessed type int x_DWORD_D4C52;

//----- (00049A20) --------------------------------------------------------
int sub_49A20(int a1)
{
	int result; // eax

	result = *(x_DWORD *)(a1 + 4);
	*(x_DWORD *)(a1 + 8) = result;
	return result;
}

//----- (00049A30) --------------------------------------------------------
__int16 sub_49A30(int a1, unsigned __int16 a2)
{
	int v2; // eax
	__int16 v3; // dx
	int v4; // eax
	char v5; // dl
	int v6; // edx
	unsigned __int16 v8; // [esp+0h] [ebp-10h]
	unsigned __int16 v9; // [esp+4h] [ebp-Ch]
	unsigned __int8 v10; // [esp+8h] [ebp-8h]
	unsigned __int8 v11; // [esp+Ch] [ebp-4h]

						 // fix it//v2 = **filearray_2aa18c[24] + 6 * a2;
	v2 = 0;  //fix it
	v8 = *(unsigned __int8 *)(v2 + 5);
	v9 = *(unsigned __int8 *)(v2 + 4);
	*(x_DWORD *)(a1 + 16) = 2;
	v3 = x_WORD_180660_VGA_type_resolution;
	*(x_WORD *)(a1 + 132) = (unsigned __int8)v9 * (unsigned __int8)v8 >> 4;
	if (v3 == 1)
	{
		v8 >>= 1;
		v9 >>= 1;
	}
	*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
	*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
	x_WORD_EB398 = *(x_WORD *)(a1 + 76) >> 8 << 8;
	x_WORD_EB39A = *(x_WORD *)(a1 + 78) >> 8 << 8;
	sub_57CF0(a1, (int)&x_WORD_EB398);
	v10 = (*(x_WORD *)(a1 + 76) >> 8) - ((signed int)v9 >> 1);
	v11 = (*(x_WORD *)(a1 + 78) >> 8) - ((signed int)v8 >> 1);
	if ((v10 + v11) % 2)
	{
		*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
		*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
		++HIBYTE(x_WORD_EB398);
		sub_57CF0(a1, (int)&x_WORD_EB398);
		++v10;
	}
	sub_49EC0((x_WORD *)a1, a2);
	*(x_WORD *)(a1 + 80) = 32 * sub_48DF0(v10, v11, v8, v9);
	*(x_BYTE *)(a1 + 70) = a2;
	LOWORD(v4) = a2;
	*(x_DWORD *)(a1 + 8) = 30;
	*(x_WORD *)(a1 + 42) = x_WORD_D93C0_bldgprmbuffer[2 * a2];
	v5 = x_BYTE_D93C3[4 * a2];
	*(x_BYTE *)(a1 + 65) = 0;
	*(x_DWORD *)(a1 + 144) = 0;
	*(x_BYTE *)(a1 + 61) = v5;
	if (!(x_BYTE_D93C2[4 * a2] & 8))
	{
		v6 = *(x_DWORD *)(a1 + 144);
		*(x_BYTE *)(a1 + 56) |= 2u;
		if (v6 < 0)
			*(x_DWORD *)(a1 + 144) = 0;
		if (*(x_DWORD *)(a1 + 144) > 1000)
			*(x_DWORD *)(a1 + 144) = 1000;
		v4 = 1000 * *(unsigned __int16 *)(a1 + 42) >> 7;
		*(x_DWORD *)(a1 + 144) = v4;
	}
	if (a2 == 68)
	{
		v4 = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
		*(x_WORD *)(x_D41A0_BYTEARRAY_0 + 222538) = v4;
	}
	return v4;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D93C0: using guessed type __int16 x_WORD_D93C0_bldgprmbuffer[];
// EA3BC: using guessed type int **filearray_2aa18c[24];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39A: using guessed type __int16 x_WORD_EB39A;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00049C70) --------------------------------------------------------
int sub_49C70(int a1)
{
	int result; // eax

	result = *(x_DWORD *)(a1 + 4) >> 1;
	*(x_DWORD *)(a1 + 144) = result;
	return result;
}

//----- (00049C90) --------------------------------------------------------
char sub_49C90(int a1, __int16 a2)
{
	char result; // al

	*(x_WORD *)(a1 + 90) = a2;
	*(x_BYTE *)(a1 + 92) = 0;
	result = x_BYTE_D8A2E[(unsigned __int8)x_BYTE_D9528[14 * a2]];
	*(x_BYTE *)(a1 + 93) = result;
	return result;
}

//----- (00049CD0) --------------------------------------------------------
int sub_49CD0(x_WORD *a1, __int16 a2)
{
	int v2; // ebx
	int result; // eax

	sub_49C90((int)a1, a2);
	v2 = 7 * a2;
	a1[41] = (unsigned __int16)x_WORD_D9524[v2] / 2;
	a1[42] = (unsigned __int16)x_WORD_D9522[v2] / 2;
	a1[43] = (unsigned __int16)x_WORD_D9522[v2] / 2;
	result = (unsigned __int16)x_WORD_D9524[v2] / 2;
	a1[44] = result;
	return result;
}
// D9522: using guessed type __int16 x_WORD_D9522[];
// D9524: using guessed type __int16 x_WORD_D9524[];

//----- (00049D50) --------------------------------------------------------
int sub_49D50(int a1, __int16 a2)
{
	int result; // eax

	*(x_WORD *)(a1 + 90) = a2;
	*(x_BYTE *)(a1 + 93) = x_BYTE_D8A2E[(unsigned __int8)x_BYTE_D9528[14 * a2]];
	result = (unsigned __int16)x_WORD_D9524[7 * a2] / 2;
	*(x_WORD *)(a1 + 82) = result;
	return result;
}
// D9524: using guessed type __int16 x_WORD_D9524[];

//----- (00049DA0) --------------------------------------------------------
int sub_49DA0(x_WORD *a1, __int16 a2)
{
	int v2; // ebx
	int result; // eax

	sub_49CD0(a1, a2);
	v2 = 7 * a2;
	a1[42] = (unsigned __int16)x_WORD_D9522[v2] / 2;
	a1[43] = (unsigned __int16)x_WORD_D9522[v2] / 2;
	result = (unsigned __int16)x_WORD_D9524[v2] / 2;
	a1[44] = result;
	return result;
}
// D9522: using guessed type __int16 x_WORD_D9522[];
// D9524: using guessed type __int16 x_WORD_D9524[];

//----- (00049E10) --------------------------------------------------------
int sub_49E10(x_WORD *a1, __int16 a2)
{
	int result; // eax
	__int16 v3; // cx
	__int16 v4; // si

	result = sub_49CD0(a1, a2);
	v3 = a1[43];
	v4 = a1[44];
	a1[42] *= 2;
	a1[43] = 2 * v3;
	a1[44] = 2 * v4;
	return result;
}

//----- (00049EA0) --------------------------------------------------------
x_WORD *sub_49EA0(x_WORD *a1, __int16 a2, __int16 a3)
{
	x_WORD *result; // eax

	result = a1;
	a1[42] = a2;
	a1[43] = a2;
	a1[44] = a3;
	return result;
}

//----- (00049EC0) --------------------------------------------------------
unsigned int sub_49EC0(x_WORD *a1, __int16 a2)
{
	int v2; // eax
	unsigned int v3; // edx
	unsigned int v4; // eax
	unsigned int result; // eax

						 // fix it//v2 = **filearray_2aa18c[24] + 6 * a2;
	v2 = 0;  //fix it
	v3 = *(unsigned __int8 *)(v2 + 5);
	v4 = *(unsigned __int8 *)(v2 + 4);
	if (x_WORD_180660_VGA_type_resolution == 1)
	{
		v3 >>= 1;
		v4 >>= 1;
	}
	a1[42] = ((v4 << 8) + 1280) >> 1;
	a1[41] = 0;
	a1[44] = 256;
	result = ((v3 << 8) + 1280) >> 1;
	a1[43] = result;
	return result;
}
// EA3BC: using guessed type int **filearray_2aa18c[24];
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00049F30) --------------------------------------------------------
signed int sub_49F30()
{
	int v0; // eax
	signed int result; // eax
	int v2; // edx
	int v3; // ebx
	int v4; // ebx
	int v5; // edx

	v0 = (int)x_D41A0_BYTEARRAY_0;
	*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 28466) = (x_DWORD)&unk_F42B0;
	*(x_DWORD *)(v0 + 53) = -1;
	*(x_DWORD *)(v0 + 4582) = -1;
	result = 999;
	do
	{
		v2 = (int)x_D41A0_BYTEARRAY_0;
		v3 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 53) + 1;
		*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 53) = v3;
		v4 = v2 + 4 * v3;
		v5 = x_DWORD_EA3E4[result--];
		*(x_DWORD *)(v4 + 582) = v5;
	} while (result > 0);
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00049F90) --------------------------------------------------------
int sub_49F90()
{
	unsigned int i; // ebx
	int v1; // eax
	signed int v2; // ebx
	signed int v3; // edx
	int result; // eax
	int v5; // eax
	int v6; // ecx
	int v7; // ecx
	int v8; // eax
	int v9; // esi
	int v10; // ecx

	for (i = x_DWORD_EA3E8; i < x_DWORD_EB384; i += 168)
	{
		if (*(x_BYTE *)(i + 63) && *(x_BYTE *)(i + 13) & 4)
			sub_57F20(i);
	}
	v1 = (int)x_D41A0_BYTEARRAY_0;
	*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 53) = -1;
	v2 = 999;
	*(x_DWORD *)(v1 + 4582) = -1;
	do
	{
		v3 = v2;
		result = x_DWORD_EA3E4[v2];
		if (*(x_BYTE *)(result + 63))
		{
			if (*(x_BYTE *)(result + 14) & 2)
			{
				v8 = (int)x_D41A0_BYTEARRAY_0;
				v9 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 4582) + 1;
				*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 4582) = v9;
				v10 = v8 + 4 * v9;
				result = x_DWORD_EA3E4[v3];
				*(x_DWORD *)(v10 + 4586) = result;
			}
		}
		else
		{
			v5 = (int)x_D41A0_BYTEARRAY_0;
			v6 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 53) + 1;
			*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 53) = v6;
			v7 = v5 + 4 * v6;
			result = x_DWORD_EA3E4[v3];
			*(x_DWORD *)(v7 + 582) = result;
		}
		v2--;
	} while (v2 > 0);
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EA3E8: using guessed type int x_DWORD_EA3E8;
// EB384: using guessed type int x_DWORD_EB384;

//----- (0004A050) --------------------------------------------------------
int sub_4A050()
{
	int v0; // edx
	int v1; // ebx
	int v2; // eax
	int v3; // eax
	int v4; // ecx
	int v5; // eax
	int v6; // edx
	int result; // eax

	v0 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 53);
	if (v0 >= 0)
	{
		v1 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 4 * v0 + 582);
		*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 53) = v0 - 1;
	LABEL_5:
		memset((void*)v1, 0, 168);
		v4 = (int)x_D41A0_BYTEARRAY_0;
		v5 = (v1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
		*(x_DWORD *)(v1 + 4) = 300;
		*(x_DWORD *)(v1 + 12) = 8;
		*(x_WORD *)(v1 + 130) = 16;
		*(x_WORD *)(v1 + 42) = 100;
		*(x_WORD *)(v1 + 26) = v5;
		v6 = *(x_DWORD *)(v4 + 8);
		*(x_BYTE *)(v1 + 65) = -1;
		*(x_BYTE *)(v1 + 66) = -1;
		*(x_DWORD *)(v1 + 160) = (x_DWORD)&unk_D83AC;
		*(x_DWORD *)(v1 + 164) = (x_DWORD)&unk_F42B0;
		*(x_BYTE *)(v1 + 67) = 10;
		*(x_BYTE *)(v1 + 57) = -6;
		LOWORD(v6) = v5 + v6;
		*(x_BYTE *)(v1 + 62) = v5;
		result = v1;
		*(x_WORD *)(v1 + 20) = v6;
		return result;
	}
	if (*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 4582) >= 0)
	{
		memset((void*)(x_D41A0_BYTEARRAY_4[0x9603]), 0, 116);
		v2 = (int)x_D41A0_BYTEARRAY_4;
		x_D41A0_BYTEARRAY_4[0x967B] = 0;
		*(x_DWORD *)(v2 + 38527) = 0;
		*(x_DWORD *)(v2 + 38519) = 0;
		*(x_DWORD *)(v2 + 38531) = 0;
		*(x_DWORD *)(v2 + 38535) = 0;
		v1 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 4 * *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 4582) + 4586);
		sub_57E50(v1);
		v3 = (int)x_D41A0_BYTEARRAY_0;
		*(x_BYTE *)(v1 + 63) = 0;
		--*(x_DWORD *)(v3 + 4582);
		goto LABEL_5;
	}
	return 0;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (0004A190) --------------------------------------------------------
int sub_4A190(int a1, int a2, int a3)
{
	int v3; // eax
	int result; // eax

	v3 = *(int *)((char *)&x_DWORD_D4C56 + 18 * a2) + 14 * a3;
	if (*(x_DWORD *)(v3 + 10) && *(signed __int16 *)(v3 + 4) == a3)
		result = (*(int(**)(int))(v3 + 6))(a1);
	else
		result = 0;
	return result;
}
// D4C56: using guessed type int x_DWORD_D4C56;

//----- (0004A1E0) --------------------------------------------------------
int sub_4A1E0(int a1, char a2)
{
	Bit8u* v2; // ebx
	unsigned __int16 *v3; // ebx
	unsigned __int16 v4; // ST04_2
	unsigned __int16 v5; // ST00_2
	unsigned __int16 *i; // ebx
	unsigned __int16 v7; // ax
	int result; // eax

	if (!a1)
	{
		v2 = x_D41A0_BYTEARRAY_0 + 222422;
		*(x_DWORD *)(v2 - 4) = 0;
		memset((void*)v2, 0, 104);
		sub_716A0();
		v3 = (unsigned __int16 *)(0x30325 + x_D41A0_BYTEARRAY_0);
		while ((Bit8u*)v3 < x_D41A0_BYTEARRAY_0 + 221393)
		{
			v4 = v3[1];
			v5 = *v3;
			v3 += 10;
			sub_716C0(v5, v4, 0xFFFFu);
		}
		sub_71780();
	}
	sub_49F90();
	sub_122C0(a1);
	for (i = (unsigned __int16 *)(0x30325 + x_D41A0_BYTEARRAY_0); (Bit8u*)i < x_D41A0_BYTEARRAY_0 + 221393; i += 10)
	{
		if (*i && i[4] == a1)
		{
			sub_4A310(i);
			if (*i == 5)
			{
				v7 = i[1];
				if (v7 < 0xCu || v7 > 0xFu && v7 != 22)
					++*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 222418);
			}
			if (a2)
				*i = 0;
		}
	}
	sub_12870();
	result = (int)x_D41A0_BYTEARRAY_0;
	*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 4582) = -1;
	return result;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004A310) --------------------------------------------------------
int sub_4A310(unsigned __int16 *a1)
{
	int result; // eax
	int v2; // edx
	int v3; // ebx
	unsigned __int8 v4; // al
	int v5; // eax
	__int16 v6; // di
	char *v7; // edx
	unsigned __int8 v8; // al
	int v9; // eax
	unsigned __int8 v10; // al
	__int16 v11; // [esp+0h] [ebp-8h]
	__int16 v12; // [esp+2h] [ebp-6h]
	__int16 v13; // [esp+4h] [ebp-4h]

	result = *(int *)((char *)&x_DWORD_D4C56 + 18 * *a1);
	if (!*(x_DWORD *)(result + 14 * a1[1] + 10))
		return result;
	v11 = (a1[2] << 8) + 128;
	v12 = (a1[3] << 8) + 128;
	v13 = sub_10C40(&v11);
	result = sub_4A190((int)&v11, *a1, a1[1]);
	v2 = result;
	v3 = result;
	if (!result)
		return result;
	switch (*(x_BYTE *)(result + 63))
	{
	case 5:
		if (*(x_BYTE *)(result + 64) == 22)
		{
			*(x_BYTE *)(result + 70) = *((x_BYTE *)a1 + 14);
			sub_4CB60(result);
		}
		sub_12100((int)a1, v3, *(x_BYTE *)(v3 + 64) == 9);
		return sub_58DA0((int)a1, v3);
	case 0xA:
		v4 = *(x_BYTE *)(result + 64);
		if (v4 < 0x22u)
		{
			if (v4 < 0xBu)
			{
				if (v4 < 4u)
					return sub_58DA0((int)a1, v3);
				if (v4 <= 4u)
				{
					*(x_WORD *)(v2 + 26) = a1[6];
					sub_49EA0((x_WORD *)v2, a1[5] << 8, a1[5] << 8);
					sub_49A20(v3);
					return sub_58DA0((int)a1, v3);
				}
				if (v4 != 9)
					return sub_58DA0((int)a1, v3);
			}
			else if (v4 > 0xBu)
			{
				if (v4 < 0x11u)
				{
					if (v4 != 15)
						return sub_58DA0((int)a1, v3);
				}
				else if (v4 > 0x11u && v4 != 22)
				{
					return sub_58DA0((int)a1, v3);
				}
			}
		}
		else
		{
			if (v4 <= 0x22u)
			{
				*(x_WORD *)(v2 + 154) = (a1[8] << 8) + 128;
				*(x_WORD *)(v2 + 156) = (a1[7] << 8) + 128;
				return sub_58DA0((int)a1, v3);
			}
			if (v4 < 0x43u)
			{
				if (v4 < 0x36u)
				{
					if (v4 == 45)
					{
						sub_49A30(v2, a1[7]);
						*(x_BYTE *)(v3 + 65) = *((x_BYTE *)a1 + 16);
					}
					result = sub_58DA0((int)a1, v3);
				}
				else if (v4 <= 0x36u)
				{
					*(x_DWORD *)(v3 + 16) = (a1[6] << 8) * (a1[6] << 8);
					v5 = 8 * a1[6] + 16;
					*(x_DWORD *)(v3 + 4) = v5;
					if (v5 < 128)
						*(x_DWORD *)(v3 + 4) = 128;
					sub_49A20(v3);
					result = sub_58DA0((int)a1, v3);
				}
				else
				{
					if (v4 < 0x3Du)
						return sub_58DA0((int)a1, v3);
					if (v4 <= 0x3Eu)
						goto LABEL_49;
					result = sub_58DA0((int)a1, v3);
				}
				return result;
			}
			if (v4 > 0x43u)
			{
				if (v4 >= 0x53u)
				{
					if (v4 <= 0x53u)
					{
						*(x_WORD *)(v2 + 154) = a1[5];
						result = sub_58DA0((int)a1, v3);
					}
					else
					{
						if (v4 <= 0x55u)
						{
							v6 = *(x_WORD *)(v2 + 78);
							*(x_WORD *)(v2 + 76) -= 128;
							*(x_WORD *)(v2 + 78) = v6 - 128;
							*(x_WORD *)(v2 + 154) = a1[5];
							*(x_WORD *)(v2 + 80) = a1[9];
						}
						result = sub_58DA0((int)a1, v3);
					}
					return result;
				}
				if (v4 != 71)
					return sub_58DA0((int)a1, v3);
			}
		}
		v7 = (char*)*xadataspellsdat.var28_begin_buffer[80 * (unsigned __int16)sub_6E020(*(char *)(v3 + 64)) + 2 + 26 * a1[7]];
		*(x_WORD *)(v3 + 42) = *(x_WORD *)v7;
		v8 = *(x_BYTE *)(v3 + 64);
		if (v8 >= 0x11u)
		{
			if (v8 <= 0x11u)
			{
				v9 = (unsigned __int8)v7[24];
			}
			else
			{
				if (v8 >= 0x43u)
				{
					if (v8 > 0x43u && v8 != 71)
						return sub_58DA0((int)a1, v3);
				LABEL_65:
					v9 = (unsigned __int8)v7[24];
				LABEL_69:
					*(x_DWORD *)(v3 + 8) = v9;
					return sub_58DA0((int)a1, v3);
				}
				if (v8 != 22)
					return sub_58DA0((int)a1, v3);
				v9 = 8 * (unsigned __int8)v7[24];
			}
			*(x_DWORD *)(v3 + 4) = v9;
			goto LABEL_69;
		}
		if (v8 >= 0xBu)
		{
			if (v8 > 0xBu && v8 != 15)
				return sub_58DA0((int)a1, v3);
			goto LABEL_65;
		}
		if (v8 != 9)
			return sub_58DA0((int)a1, v3);
		*(x_DWORD *)(v3 + 4) = (unsigned __int8)v7[24];
		return sub_58DA0((int)a1, v3);
	case 0xB:
		*(x_WORD *)(result + 26) = a1[6];
		if (*(x_BYTE *)(result + 64) == 32)
			*(x_BYTE *)(result + 70) = *((x_BYTE *)a1 + 14);
		else
			sub_49EA0((x_WORD *)result, a1[5] << 8, 4096);
		sub_49A20(v3);
		*(x_BYTE *)(v3 + 12) |= 1u;
		return sub_58DA0((int)a1, v3);
	case 0xC:
	case 0xF:
		*(x_BYTE *)(result + 69) += *((x_BYTE *)a1 + 12);
		if (a1[6] < 3u)
			return sub_58DA0((int)a1, v3);
		*(x_BYTE *)(result + 69) -= 3;
		return sub_58DA0((int)a1, result);
	case 0xE:
		v10 = *(x_BYTE *)(result + 64);
		if (v10 < 1u)
			return sub_58DA0((int)a1, v3);
		if (v10 <= 1u)
		{
		LABEL_49:
			*(x_BYTE *)(v2 + 70) = *((x_BYTE *)a1 + 14);
			*(x_DWORD *)(v2 + 16) = a1[8];
			result = sub_58DA0((int)a1, v3);
		}
		else
		{
			if (v10 == 2)
			{
				*(x_WORD *)(v2 + 44) = a1[7];
				*(x_WORD *)(v2 + 150) = a1[9];
				return sub_58DA0((int)a1, v3);
			}
			result = sub_58DA0((int)a1, v3);
		}
		return result;
	default:
		return sub_58DA0((int)a1, v3);
	}
}
// D4C56: using guessed type int x_DWORD_D4C56;

//----- (0004A810) --------------------------------------------------------
int sub_4A810()
{
	return *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 53) + 1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004A820) --------------------------------------------------------
int sub_4A820(int a1)
{
	Bit8u* v1; // edi
	int result; // eax

	v1 = x_D41A0_BYTEARRAY_0 + 9058;
	result = 0;
	*(x_DWORD *)v1 = *(x_DWORD *)a1;
	*(x_WORD *)(v1 + 4) = *(x_WORD *)(a1 + 4);
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004A840) --------------------------------------------------------
int sub_4A840(int a1)
{
	Bit8u* v1; // edi
	int result; // eax

	v1 = x_D41A0_BYTEARRAY_0 + 9064;
	result = 0;
	*(x_DWORD *)v1 = *(x_DWORD *)a1;
	*(x_WORD *)(v1 + 4) = *(x_WORD *)(a1 + 4);
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004A860) --------------------------------------------------------
int sub_4A860(int a1)
{
	Bit8u* v1; // edi
	int result; // eax

	v1 = x_D41A0_BYTEARRAY_0 + 9070;
	result = 0;
	*(x_DWORD *)v1 = *(x_DWORD *)a1;
	*(x_WORD *)(v1 + 4) = *(x_WORD *)(a1 + 4);
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004A880) --------------------------------------------------------
int sub_4A880(int a1)
{
	Bit8u* v1; // edi
	int result; // eax

	v1 = x_D41A0_BYTEARRAY_0 + 9076;
	result = 0;
	*(x_DWORD *)v1 = *(x_DWORD *)a1;
	*(x_WORD *)(v1 + 4) = *(x_WORD *)(a1 + 4);
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004A8A0) --------------------------------------------------------
int sub_4A8A0(int a1)
{
	Bit8u* v1; // edi
	int result; // eax

	v1 = x_D41A0_BYTEARRAY_0 + 9082;
	result = 0;
	*(x_DWORD *)v1 = *(x_DWORD *)a1;
	*(x_WORD *)(v1 + 4) = *(x_WORD *)(a1 + 4);
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004A8C0) --------------------------------------------------------
int sub_4A8C0(int a1)
{
	Bit8u* v1; // edi
	int result; // eax

	v1 = x_D41A0_BYTEARRAY_0 + 9088;
	result = 0;
	*(x_DWORD *)v1 = *(x_DWORD *)a1;
	*(x_WORD *)(v1 + 4) = *(x_WORD *)(a1 + 4);
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004A8E0) --------------------------------------------------------
int sub_4A8E0(int a1)
{
	Bit8u* v1; // edi
	int result; // eax

	v1 = x_D41A0_BYTEARRAY_0 + 9094;
	result = 0;
	*(x_DWORD *)v1 = *(x_DWORD *)a1;
	*(x_WORD *)(v1 + 4) = *(x_WORD *)(a1 + 4);
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004A900) --------------------------------------------------------
int sub_4A900(int a1)
{
	Bit8u* v1; // edi
	int result; // eax

	v1 = x_D41A0_BYTEARRAY_0 + 9100;
	result = 0;
	*(x_DWORD *)v1 = *(x_DWORD *)a1;
	*(x_WORD *)(v1 + 4) = *(x_WORD *)(a1 + 4);
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004A920) --------------------------------------------------------
x_WORD *sub_4A920(int a1)
{
	int v1; // eax
	x_WORD *v2; // esi
	int v3; // ecx

	v1 = sub_4A050();
	v2 = (x_WORD *)v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 0;
		*(x_BYTE *)(v1 + 63) = 3;
		v3 = (int)x_D41A0_BYTEARRAY_0;
		*(x_BYTE *)(v1 + 64) = 0;
		*(x_DWORD *)(v1 + 4) = 10000;
		*(x_WORD *)(v1 + 132) = 80;
		*(x_BYTE *)(v1 + 56) = 29;
		*(x_WORD *)(v1 + 26) = (v1 - (v3 + 28302)) / 168;
		if (*(x_BYTE *)(v3 + 196308) == 2)
			*(x_DWORD *)(v1 + 160) = (x_DWORD)&unk_D89A6;
		else
			*(x_DWORD *)(v1 + 160) = (x_DWORD)&unk_D849A;
		sub_57D70(v1, a1);
		sub_49CD0(v2, 44);
		sub_49A20((int)v2);
	}
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004A9C0) --------------------------------------------------------
x_WORD *sub_4A9C0(int a1)
{
	int v1; // eax
	x_WORD *v2; // ebx
	int v3; // edx

	v1 = sub_4A050();
	v2 = (x_WORD *)v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 1;
		*(x_BYTE *)(v1 + 63) = 3;
		v3 = (int)x_D41A0_BYTEARRAY_0;
		*(x_BYTE *)(v1 + 64) = 1;
		*(x_DWORD *)(v1 + 4) = 10000;
		*(x_WORD *)(v1 + 132) = 80;
		*(x_DWORD *)(v1 + 160) = (x_DWORD)&unk_D84BC;
		*(x_BYTE *)(v1 + 56) = 29;
		*(x_WORD *)(v1 + 26) = (v1 - (v3 + 28302)) / 168;
		sub_57D70(v1, a1);
		sub_49CD0(v2, 44);
		sub_49A20((int)v2);
	}
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004AA40) --------------------------------------------------------
int sub_4AA40(int a1)
{
	int result; // eax
	int v2; // ebx
	int v3; // edx
	unsigned __int16 v4; // ax
	unsigned __int16 v5; // cx
	int v6; // [esp+0h] [ebp-Ch]
	__int16 v7; // [esp+4h] [ebp-8h]
	int v8; // [esp+8h] [ebp-4h]

	*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)a1;
	*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 4);
	result = sub_4A050();
	v2 = result;
	if (result)
	{
		*(x_BYTE *)(result + 69) = 5;
		*(x_BYTE *)(result + 63) = 3;
		*(x_BYTE *)(result + 64) = 2;
		*(x_DWORD *)(result + 4) = 40000;
		*(x_DWORD *)(result + 16) = 0;
		*(x_BYTE *)(result + 56) = 33;
		v6 = *(x_DWORD *)&x_WORD_EB398;
		v7 = *(&x_WORD_EB398 + 2);
		LOWORD(v6) = BYTE1(v6);
		HIWORD(v6) = HIBYTE(x_WORD_EB39A);
		v7 = sub_10C40(&x_WORD_EB398);
		if (((signed __int16)v6 + SHIWORD(v6)) % 2)
			LOWORD(v6) = v6 + 1;
		LOWORD(v6) = (x_WORD)v6 << 8;
		HIWORD(v6) <<= 8;
		// fix it//v3 = **filearray_2aa18c[24];
		v3 = 0;  //fix it
		HIBYTE(v4) = 0;
		*(x_DWORD *)(v2 + 154) = v6;
		*(x_WORD *)(v2 + 158) = v7;
		LOBYTE(v4) = *(x_BYTE *)(v3 + 10);
		v5 = *(unsigned __int8 *)(v3 + 11);
		if (x_WORD_180660_VGA_type_resolution == 1)
		{
			v5 >>= 1;
			v4 >>= 1;
		}
		v8 = ((signed __int16)v6 >> 8) - v4 / 2;
		*(x_WORD *)(v2 + 158) = 32 * sub_48E60(((signed __int16)v6 >> 8) - v4 / 2, (SHIWORD(v6) >> 8) - v5 / 2, v4, v5);
		sub_57D70(v2, (int)&v6);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 177);
		result = v2;
	}
	return result;
}
// EA3BC: using guessed type int **filearray_2aa18c[24];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39A: using guessed type __int16 x_WORD_EB39A;
// EB39C: using guessed type __int16 x_WORD_EB39C;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0004ABA0) --------------------------------------------------------
int sub_4ABA0(int a1)
{
	int result; // eax
	x_WORD *v2; // ebx
	int v3; // esi

	result = sub_4A050();
	v2 = (x_WORD *)result;
	v3 = result;
	if (result)
	{
		*(x_BYTE *)(result + 69) = 7;
		*(x_BYTE *)(result + 63) = 3;
		*(x_BYTE *)(result + 64) = 3;
		*(x_DWORD *)(result + 4) = 10000;
		*(x_WORD *)(result + 130) = 48;
		*(x_DWORD *)(result + 140) = 10000;
		*(x_DWORD *)(result + 144) = 0;
		*(x_BYTE *)(result + 56) = 1;
		*(x_DWORD *)(result + 160) = (x_DWORD)&unk_D84DE;
		sub_57D70(result, a1);
		sub_49A20((int)v2);
		sub_49CD0(v2, 169);
		if (x_BYTE_D41B6)
			sub_49EA0(v2, 256, 768);
		result = v3;
	}
	return result;
}
// D41B6: using guessed type char x_BYTE_D41B6;

//----- (0004AC40) --------------------------------------------------------
int sub_4AC40(int a1)
{
	int result; // eax
	int v2; // ebx
	unsigned __int16 v3; // ax
	int v4; // eax
	int v5; // [esp+0h] [ebp-Ch]
	__int16 v6; // [esp+4h] [ebp-8h]
	int v7; // [esp+8h] [ebp-4h]

	result = sub_4A050();
	v2 = result;
	v7 = result;
	if (result)
	{
		*(x_BYTE *)(result + 69) = 0;
		*(x_BYTE *)(result + 63) = 2;
		*(x_BYTE *)(result + 64) = 0;
		*(x_DWORD *)(result + 16) = (result - (x_D41A0_BYTEARRAY_0[28302])) / 168 % 11;
		*(x_WORD *)(result + 20) = 9377 * *(x_WORD *)(result + 20) + 9439;
		v3 = *(x_WORD *)(result + 20);
		*(x_BYTE *)(v2 + 56) = 1;
		*(x_DWORD *)(v2 + 8) = v3 % 0x1388u + 2500;
		v5 = *(x_DWORD *)a1;
		v6 = *(x_WORD *)(a1 + 4);
		*(x_WORD *)(v2 + 20) = 9377 * *(x_WORD *)(v2 + 20) + 9439;
		LOWORD(v5) = (*(x_WORD *)(v2 + 20) & 0x3F) - 32 + v5;
		*(x_WORD *)(v2 + 20) = 9377 * *(x_WORD *)(v2 + 20) + 9439;
		HIWORD(v5) += (*(x_WORD *)(v2 + 20) & 0x3F) - 32;
		sub_57D70(v2, (int)&v5);
		sub_49A20(v2);
		*(x_WORD *)(v2 + 20) = 9377 * *(x_WORD *)(v2 + 20) + 9439;
		v4 = *(x_WORD *)(v2 + 20) & 1;
		if (v4)
		{
			if (v4 == 1)
				sub_49DA0((x_WORD *)v2, 84);
		}
		else
		{
			sub_49DA0((x_WORD *)v2, 83);
		}
		result = v7;
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004AD70) --------------------------------------------------------
x_WORD *sub_4AD70(int a1)
{
	int v1; // eax
	x_WORD *v2; // ebx
	int v3; // ecx

	v1 = sub_4A050();
	v2 = (x_WORD *)v1;
	if (v1)
	{
		v3 = v1 - (x_D41A0_BYTEARRAY_0[28302]);
		*(x_BYTE *)(v1 + 12) &= 0xF7u;
		*(x_DWORD *)(v1 + 16) = v3 / 168 % 11;
		*(x_BYTE *)(v1 + 69) = 3;
		*(x_BYTE *)(v1 + 63) = 2;
		*(x_BYTE *)(v1 + 64) = 1;
		sub_57D70(v1, a1);
		sub_49A20((int)v2);
		sub_49DA0(v2, 79);
	}
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004ADF0) --------------------------------------------------------
x_WORD *sub_4ADF0(int a1)
{
	int v1; // eax
	x_WORD *v2; // ebx
	int v3; // ecx

	v1 = sub_4A050();
	v2 = (x_WORD *)v1;
	if (v1)
	{
		v3 = v1 - (x_D41A0_BYTEARRAY_0[28302]);
		*(x_BYTE *)(v1 + 12) &= 0xF7u;
		*(x_DWORD *)(v1 + 16) = v3 / 168 % 11;
		*(x_BYTE *)(v1 + 69) = 6;
		*(x_BYTE *)(v1 + 63) = 2;
		*(x_BYTE *)(v1 + 64) = 2;
		sub_57D70(v1, a1);
		sub_49A20((int)v2);
		sub_49DA0(v2, 39);
		sub_49EA0(v2, 1024, 1024);
	}
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004AE80) --------------------------------------------------------
x_WORD *sub_4AE80(int a1)
{
	int v1; // eax
	x_WORD *v2; // ebx
	int v3; // ecx

	v1 = sub_4A050();
	v2 = (x_WORD *)v1;
	if (v1)
	{
		v3 = v1 - (x_D41A0_BYTEARRAY_0[28302]);
		*(x_BYTE *)(v1 + 12) &= 0xF7u;
		*(x_DWORD *)(v1 + 16) = v3 / 168 % 11;
		*(x_BYTE *)(v1 + 69) = 9;
		*(x_BYTE *)(v1 + 63) = 2;
		*(x_BYTE *)(v1 + 64) = 3;
		sub_57D70(v1, a1);
		sub_49A20((int)v2);
		sub_49DA0(v2, 270);
	}
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004AF00) --------------------------------------------------------
x_WORD *sub_4AF00(int a1)
{
	int v1; // eax
	x_WORD *v2; // ebx
	int v3; // edx

	v1 = sub_4A050();
	v2 = (x_WORD *)v1;
	if (v1)
	{
		v3 = (int)x_D41A0_BYTEARRAY_0;
		*(x_BYTE *)(v1 + 69) = 12;
		*(x_BYTE *)(v1 + 63) = 2;
		*(x_BYTE *)(v1 + 64) = 4;
		*(x_DWORD *)(v1 + 16) = (v1 - (v3 + 28302)) / 168 % 11;
		sub_57D70(v1, a1);
		sub_49A20((int)v2);
		sub_49DA0(v2, 48);
	}
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004AF70) --------------------------------------------------------
x_WORD *sub_4AF70(int a1)
{
	int v1; // eax
	x_WORD *v2; // ebx
	int v3; // edx

	v1 = sub_4A050();
	v2 = (x_WORD *)v1;
	if (v1)
	{
		v3 = (int)x_D41A0_BYTEARRAY_0;
		*(x_BYTE *)(v1 + 69) = 15;
		*(x_BYTE *)(v1 + 63) = 2;
		*(x_BYTE *)(v1 + 64) = 5;
		*(x_DWORD *)(v1 + 16) = (v1 - (v3 + 28302)) / 168 % 11;
		sub_57D70(v1, a1);
		sub_49A20((int)v2);
		sub_49DA0(v2, 48);
	}
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004AFE0) --------------------------------------------------------
int sub_4AFE0(int a1)
{
	int v1; // eax
	int v2; // ebx
	__int16 v3; // dx
	unsigned __int16 v4; // ax
	int v6; // [esp+0h] [ebp-8h]
	__int16 v7; // [esp+4h] [ebp-4h]

	if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308) != 2)
		return 0;
	v1 = sub_4A050();
	v2 = v1;
	if (!v1)
		return 0;
	*(x_BYTE *)(v1 + 69) = 18;
	*(x_BYTE *)(v1 + 63) = 2;
	v3 = *(x_WORD *)(v1 + 20);
	*(x_BYTE *)(v1 + 64) = 6;
	*(x_WORD *)(v1 + 20) = 9377 * v3 + 9439;
	v4 = *(x_WORD *)(v1 + 20);
	*(x_BYTE *)(v2 + 56) = 1;
	*(x_DWORD *)(v2 + 4) = v4 % 0x50u + 100;
	v6 = *(x_DWORD *)a1;
	v7 = *(x_WORD *)(a1 + 4);
	LOBYTE(v3) = -95 * *(x_BYTE *)(v2 + 20) - 33;
	*(x_WORD *)(v2 + 20) = 9377 * *(x_WORD *)(v2 + 20) + 9439;
	LOWORD(v6) = (v3 & 0x3F) - 32 + v6;
	*(x_WORD *)(v2 + 20) = 9377 * *(x_WORD *)(v2 + 20) + 9439;
	HIWORD(v6) += (*(x_WORD *)(v2 + 20) & 0x3F) - 32;
	sub_57D70(v2, (int)&v6);
	sub_49A20(v2);
	*(x_WORD *)(v2 + 20) = 9377 * *(x_WORD *)(v2 + 20) + 9439;
	sub_49DA0((x_WORD *)v2, (*(x_WORD *)(v2 + 20) & 3) + 324);
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004B0F0) --------------------------------------------------------
int sub_4B0F0(int a1)
{
	int result; // eax

	if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308) == 2)
		result = 0;
	else
		result = sub_4B150(a1, 7, 20, 322);
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004B120) --------------------------------------------------------
int sub_4B120(int a1)
{
	int result; // eax

	if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308) == 2)
		result = 0;
	else
		result = sub_4B150(a1, 8, 21, 323);
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004B150) --------------------------------------------------------
int sub_4B150(int a1, char a2, char a3, __int16 a4)
{
	int v4; // eax
	int v5; // ebx
	__int16 v6; // dx
	unsigned __int16 v7; // ax
	int v9; // [esp+0h] [ebp-8h]
	__int16 v10; // [esp+4h] [ebp-4h]

	v4 = sub_4A050();
	v5 = v4;
	if (v4)
	{
		*(x_BYTE *)(v4 + 69) = a3;
		v6 = *(x_WORD *)(v4 + 20);
		*(x_BYTE *)(v4 + 64) = a2;
		*(x_WORD *)(v4 + 20) = 9377 * v6 + 9439;
		v7 = *(x_WORD *)(v4 + 20);
		*(x_BYTE *)(v5 + 63) = 2;
		*(x_BYTE *)(v5 + 56) = 1;
		*(x_BYTE *)(v5 + 70) = 0;
		*(x_WORD *)(v5 + 44) = -128;
		*(x_WORD *)(v5 + 130) = 0;
		*(x_DWORD *)(v5 + 4) = v7 % 0x7D0u + 400;
		v9 = *(x_DWORD *)a1;
		v10 = *(x_WORD *)(a1 + 4);
		*(x_WORD *)(v5 + 20) = 9377 * *(x_WORD *)(v5 + 20) + 9439;
		LOWORD(v9) = (*(x_WORD *)(v5 + 20) & 0x3F) - 32 + v9;
		LOBYTE(v6) = -95 * *(x_BYTE *)(v5 + 20) - 33;
		*(x_WORD *)(v5 + 20) = 9377 * *(x_WORD *)(v5 + 20) + 9439;
		HIWORD(v9) += (v6 & 0x3F) - 32;
		sub_57D70(v5, (int)&v9);
		sub_49A20(v5);
		sub_49DA0((x_WORD *)v5, a4);
	}
	return v5;
}

//----- (0004B240) --------------------------------------------------------
x_DWORD *sub_4B240(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // eax
	__int16 v4; // dx
	int v5; // ecx
	Bit8u* v6; // edx
	int v7; // eax
	int v8; // eax
	int v9; // ebx
	int v10; // edx
	x_DWORD *v12; // [esp+0h] [ebp-10h]
	int v13; // [esp+4h] [ebp-Ch]
	int v14; // [esp+8h] [ebp-8h]
	signed int v15; // [esp+Ch] [ebp-4h]

	if (sub_4A810() < 16)
		return 0;
	v1 = sub_4A050();
	v2 = v1;
	v12 = (x_DWORD *)v1;
	if (!v1)
		return 0;
	*(x_BYTE *)(v1 + 69) = 1;
	*(x_BYTE *)(v1 + 63) = 5;
	*(x_BYTE *)(v1 + 64) = 0;
	*(x_WORD *)(v1 + 132) = 80;
	*(x_WORD *)(v1 + 134) = 16;
	*(x_WORD *)(v1 + 130) = 30;
	*(x_DWORD *)(v1 + 4) = 4000;
	*(x_DWORD *)(v1 + 144) = 4500;
	v3 = *(x_DWORD *)(v1 + 144);
	*(x_DWORD *)(v2 + 140) = v3;
	v4 = *(x_WORD *)(v2 + 20);
	*(x_DWORD *)(v2 + 144) = v3 / 2;
	*(x_WORD *)(v2 + 20) = 9377 * v4 + 9439;
	LOWORD(v3) = (*(x_WORD *)(v2 + 20) & 0x7FF) - 1;
	*(x_WORD *)(v2 + 32) = v3;
	*(x_WORD *)(v2 + 28) = v3;
	v5 = (int)x_D41A0_BYTEARRAY_0;
	v6 = x_D41A0_BYTEARRAY_0 + 28302;
	*(x_WORD *)(v2 + 30) = *(x_WORD *)(v2 + 32);
	*(x_WORD *)(v2 + 34) = 0;
	*(x_WORD *)(v2 + 54) = 96;
	*(x_BYTE *)(v2 + 56) = 1;
	v7 = *(char *)(v2 + 64);
	*(x_DWORD *)(v2 + 16) = (v2 - (int)v6) / 168 % 100;
	LOBYTE(v6) = (*(x_BYTE *)(v5 + v7 + 16))++;
	*(x_DWORD *)(v2 + 160) = (x_DWORD)&unk_D8544;
	*(x_BYTE *)(v2 + 62) = (int)v6;
	LOWORD(v5) = *(x_WORD *)(*(x_DWORD *)(v2 + 160) + 26);
	LOWORD(v6) = (signed __int16)*(unsigned __int8 *)(v2 + 62) % *(x_WORD *)(*(x_DWORD *)(v2 + 160) + 26);
	*(x_BYTE *)(v2 + 65) = 3;
	*(x_WORD *)(v2 + 44) = 0;
	*(x_BYTE *)(v2 + 70) = 0;
	v14 = v2;
	*(x_BYTE *)(v2 + 61) = 0;
	v15 = 0;
	*(x_BYTE *)(v2 + 57) = v5 - (int)v6 + 4;
	while (v15 <= 15)
	{
		v8 = sub_4A050();
		v9 = v8;
		v13 = v8;
		if (v8)
		{
			qmemcpy((void *)v8, v12, 0xA8u);
			v10 = v8 - (x_D41A0_BYTEARRAY_0[28302]);
			*(x_WORD *)(v8 + 50) = (v14 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
			*(x_WORD *)(v14 + 52) = v10 / 168;
			*(x_WORD *)(v8 + 52) = 0;
			*(x_BYTE *)(v8 + 69) = -24;
			v12[36] = (v12[35] - (__CFSHL__(v12[35] >> 31, 5) + 32 * (v12[35] >> 31))) >> 5;
			*(x_BYTE *)(v8 + 62) = v15;
			sub_49CD0((x_WORD *)v8, v15 + 19);
			*(x_WORD *)(v9 + 54) = *(x_WORD *)(v9 + 84);
			sub_57D70(v9, a1);
			sub_49A20(v9);
		}
		v14 = v13;
		++v15;
	}
	sub_57D70((int)v12, a1);
	sub_49A20((int)v12);
	sub_49CD0((x_WORD*)v12, 40);
	return v12;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004B490) --------------------------------------------------------
int sub_4B490(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // ecx
	int v4; // edx
	int v5; // ecx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 9;
		*(x_BYTE *)(v1 + 63) = 5;
		*(x_BYTE *)(v1 + 64) = 1;
		*(x_WORD *)(v1 + 132) = 54;
		*(x_WORD *)(v1 + 134) = 18;
		*(x_DWORD *)(v1 + 4) = 600;
		*(x_WORD *)(v1 + 130) = *(x_WORD *)(v1 + 134);
		sub_49C70(v1);
		*(x_WORD *)(v2 + 32) = 0;
		*(x_WORD *)(v2 + 28) = *(x_WORD *)(v2 + 32);
		v3 = (int)x_D41A0_BYTEARRAY_0;
		*(x_WORD *)(v2 + 30) = *(x_WORD *)(v2 + 32);
		*(x_DWORD *)(v2 + 16) = (v2 - (v3 + 28302)) / 168 % 100;
		v4 = *(char *)(v2 + 64);
		*(x_WORD *)(v2 + 34) = 0;
		v5 = v4 + v3;
		*(x_BYTE *)(v2 + 56) = 1;
		LOBYTE(v4) = (*(x_BYTE *)(v5 + 16))++;
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&unk_D88DA;
		*(x_BYTE *)(v2 + 62) = v4;
		*(x_BYTE *)(v2 + 57) = *(x_BYTE *)(*(x_DWORD *)(v2 + 160) + 26) + 1;
		*(x_BYTE *)(v2 + 65) = 3;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 238);
	}
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004B590) --------------------------------------------------------
int sub_4B590(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // edx
	__int16 v4; // ax
	int v5; // ecx
	Bit8u* v6; // edx
	int v7; // edx
	int v8; // ecx

	if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308))
		return 0;
	v1 = sub_4A050();
	v2 = v1;
	if (!v1)
		return 0;
	*(x_BYTE *)(v1 + 69) = 17;
	*(x_BYTE *)(v1 + 63) = 5;
	*(x_BYTE *)(v1 + 64) = 2;
	*(x_WORD *)(v1 + 132) = 64;
	v3 = *(signed __int16 *)(v1 + 132);
	*(x_WORD *)(v1 + 134) = 30;
	*(x_DWORD *)(v1 + 4) = 3000;
	*(x_WORD *)(v1 + 130) = v3 / 2;
	sub_49C70(v1);
	*(x_WORD *)(v2 + 20) = 9377 * *(x_WORD *)(v2 + 20) + 9439;
	v4 = (*(x_WORD *)(v2 + 20) & 0x7FF) - 1;
	*(x_WORD *)(v2 + 32) = v4;
	*(x_WORD *)(v2 + 28) = v4;
	v5 = (int)x_D41A0_BYTEARRAY_0;
	v6 = x_D41A0_BYTEARRAY_0 + 28302;
	*(x_WORD *)(v2 + 30) = *(x_WORD *)(v2 + 32);
	*(x_WORD *)(v2 + 34) = 0;
	*(x_WORD *)(v2 + 42) = 200;
	*(x_BYTE *)(v2 + 65) = 3;
	*(x_BYTE *)(v2 + 66) = 0;
	*(x_DWORD *)(v2 + 16) = (v2 - (int)v6) / 168 % 100;
	v7 = *(char *)(v2 + 64);
	*(x_BYTE *)(v2 + 56) = 1;
	LOBYTE(v4) = (*(x_BYTE *)(v5 + v7 + 16))++;
	*(x_DWORD *)(v2 + 160) = (x_DWORD)&unk_D8588;
	*(x_BYTE *)(v2 + 62) = v4;
	v8 = *(signed __int16 *)(*(x_DWORD *)(v2 + 160) + 26)
		- *(unsigned __int8 *)(v2 + 62) % *(signed __int16 *)(*(x_DWORD *)(v2 + 160) + 26);
	*(x_BYTE *)(v2 + 65) = 3;
	*(x_BYTE *)(v2 + 57) = v8 + 4;
	sub_57D70(v2, a1);
	sub_49A20(v2);
	sub_49CD0((x_WORD *)v2, 3);
	sub_49EA0((x_WORD *)v2, 128, 128);
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004B6F0) --------------------------------------------------------
int sub_4B6F0(int a1)
{
	int result; // eax
	int v2; // ebx
	__int64 v3; // rax
	int v4; // ecx
	int v5; // eax
	x_WORD *v6; // ebx
	int v7; // edx
	unsigned __int16 v8; // ax
	int v9; // [esp+0h] [ebp-10h]
	int v10; // [esp+4h] [ebp-Ch]
	int v11; // [esp+8h] [ebp-8h]
	signed int v12; // [esp+Ch] [ebp-4h]

	result = sub_4A050();
	v2 = result;
	v9 = result;
	if (result)
	{
		*(x_BYTE *)(result + 69) = 25;
		*(x_BYTE *)(result + 63) = 5;
		*(x_BYTE *)(result + 64) = 3;
		*(x_WORD *)(result + 132) = 64;
		*(x_WORD *)(result + 134) = 16;
		*(x_WORD *)(result + 130) = 30;
		*(x_DWORD *)(result + 4) = 9000;
		sub_49C70(result);
		v3 = *(signed int *)(v2 + 144);
		*(x_DWORD *)(v2 + 140) = v3;
		LODWORD(v3) = ((signed int)v3 - HIDWORD(v3)) >> 1;
		WORD2(v3) = *(x_WORD *)(v2 + 20);
		*(x_DWORD *)(v2 + 144) = v3;
		*(x_WORD *)(v2 + 20) = 9377 * WORD2(v3) + 9439;
		LOWORD(v3) = (*(x_WORD *)(v2 + 20) & 0x7FF) - 1;
		*(x_WORD *)(v2 + 32) = v3;
		*(x_WORD *)(v2 + 28) = v3;
		v4 = (int)x_D41A0_BYTEARRAY_0;
		HIDWORD(v3) = (int)x_D41A0_BYTEARRAY_0 + 28302;
		*(x_WORD *)(v2 + 30) = *(x_WORD *)(v2 + 32);
		*(x_WORD *)(v2 + 34) = 0;
		*(x_WORD *)(v2 + 54) = 96;
		*(x_BYTE *)(v2 + 56) = 1;
		LODWORD(v3) = *(char *)(v2 + 64);
		*(x_DWORD *)(v2 + 16) = (v2 - HIDWORD(v3)) / 168 % 100;
		BYTE4(v3) = (*(x_BYTE *)(v4 + v3 + 16))++;
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&unk_D85AA;
		*(x_BYTE *)(v2 + 62) = BYTE4(v3);
		LOWORD(v4) = *(x_WORD *)(*(x_DWORD *)(v2 + 160) + 26);
		WORD2(v3) = (signed __int16)*(unsigned __int8 *)(v2 + 62) % *(x_WORD *)(*(x_DWORD *)(v2 + 160) + 26);
		v11 = v2;
		*(x_BYTE *)(v2 + 65) = 3;
		v12 = 0;
		*(x_BYTE *)(v2 + 57) = v4 - BYTE4(v3) + 4;
		while (v12 <= 15)
		{
			v5 = sub_4A050();
			v6 = (x_WORD *)v5;
			v10 = v5;
			if (v5)
			{
				qmemcpy((void *)v5, (void *)v9, 0xA8u);
				v7 = v5 - (x_D41A0_BYTEARRAY_0[28302]);
				*(x_WORD *)(v5 + 50) = (v11 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
				*(x_WORD *)(v11 + 52) = v7 / 168;
				*(x_WORD *)(v5 + 52) = 0;
				*(x_BYTE *)(v5 + 69) = -24;
				*(x_DWORD *)(v5 + 144) = (*(x_DWORD *)(v9 + 140)
					- (__CFSHL__(*(x_DWORD *)(v9 + 140) >> 31, 5)
						+ 32 * (*(x_DWORD *)(v9 + 140) >> 31))) >> 5;
				*(x_BYTE *)(v5 + 62) = v12;
				sub_49CD0((x_WORD *)v5, v12 + 89);
				v6[42] = 65 * (unsigned __int16)x_WORD_D9522[7 * (v12 + 89)] / 100;
				v6[43] = 65 * (unsigned __int16)x_WORD_D9522[7 * (v12 + 89)] / 100;
				v6[44] = 65 * (unsigned __int16)x_WORD_D9524[7 * (v12 + 89)] / 100;
				v8 = v6[42];
				v6[27] = v8;
				if (!v12)
					v6[27] = 125 * v8 / 100;
				sub_57D70(v10, a1);
				sub_49A20(v10);
			}
			v11 = v10;
			++v12;
		}
		sub_57D70(v9, a1);
		sub_49A20(v9);
		sub_49CD0((x_WORD *)v9, 88);
		*(x_WORD *)(v9 + 84) = 60 * (unsigned __int16)x_WORD_D99F2 / 100;
		*(x_WORD *)(v9 + 86) = 60 * (unsigned __int16)x_WORD_D99F2 / 100;
		*(x_WORD *)(v9 + 88) = 60 * (unsigned __int16)x_WORD_D99F4 / 100;
		result = v9;
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D9522: using guessed type __int16 x_WORD_D9522[];
// D9524: using guessed type __int16 x_WORD_D9524[];
// D99F2: using guessed type __int16 x_WORD_D99F2;
// D99F4: using guessed type __int16 x_WORD_D99F4;

//----- (0004BA10) --------------------------------------------------------
int sub_4BA10(int a1)
{
	int v1; // eax
	int v2; // ebx
	__int16 v3; // dx
	int v4; // ecx
	int v5; // edx
	int v6; // ecx
	int v7; // ecx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 33;
		*(x_BYTE *)(v1 + 63) = 5;
		*(x_BYTE *)(v1 + 64) = 4;
		*(x_WORD *)(v1 + 132) = 30;
		*(x_WORD *)(v1 + 134) = 0;
		*(x_DWORD *)(v1 + 4) = 1000;
		*(x_WORD *)(v1 + 130) = *(x_WORD *)(v1 + 132);
		sub_49C70(v1);
		*(x_WORD *)(v2 + 20) = 9377 * *(x_WORD *)(v2 + 20) + 9439;
		v3 = (*(x_WORD *)(v2 + 20) & 0x7FF) - 1;
		*(x_WORD *)(v2 + 32) = v3;
		*(x_WORD *)(v2 + 28) = v3;
		v4 = (int)x_D41A0_BYTEARRAY_0;
		*(x_WORD *)(v2 + 30) = *(x_WORD *)(v2 + 32);
		*(x_WORD *)(v2 + 34) = 0;
		*(x_DWORD *)(v2 + 16) = (v2 - (v4 + 28302)) / 168 % 100;
		v5 = *(char *)(v2 + 64);
		*(x_WORD *)(v2 + 42) = 500;
		v6 = v5 + v4;
		*(x_BYTE *)(v2 + 56) = 1;
		LOBYTE(v5) = (*(x_BYTE *)(v6 + 16))++;
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&off_D85CC;
		*(x_BYTE *)(v2 + 62) = v5;
		v7 = *(signed __int16 *)(*(x_DWORD *)(v2 + 160) + 26)
			- *(unsigned __int8 *)(v2 + 62) % *(signed __int16 *)(*(x_DWORD *)(v2 + 160) + 26);
		*(x_BYTE *)(v2 + 65) = 3;
		*(x_BYTE *)(v2 + 57) = v7 + 4;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 0);
		sub_49EA0((x_WORD *)v2, 128, 256);
	}
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D85CC: using guessed type void *off_D85CC;

//----- (0004BBB0) --------------------------------------------------------
int sub_4BBB0(int a1)
{
	int v1; // eax
	int v2; // ebx
	__int16 v3; // ax
	unsigned __int16 v4; // ax
	__int16 v5; // dx
	int v6; // edx
	int v7; // eax
	int v8; // eax
	int v9; // esi

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 72;
		*(x_BYTE *)(v1 + 63) = 5;
		*(x_BYTE *)(v1 + 64) = 9;
		*(x_WORD *)(v1 + 132) = 20;
		*(x_WORD *)(v1 + 134) = 0;
		v3 = *(x_WORD *)(v1 + 132);
		*(x_DWORD *)(v2 + 4) = 1000;
		*(x_WORD *)(v2 + 130) = v3;
		sub_49C70(v2);
		*(x_WORD *)(v2 + 20) = 9377 * *(x_WORD *)(v2 + 20) + 9439;
		v4 = *(x_WORD *)(v2 + 20);
		*(x_WORD *)(v2 + 34) = 0;
		v5 = v4 % 0x832u - 1;
		*(x_WORD *)(v2 + 32) = v5;
		*(x_WORD *)(v2 + 28) = v5;
		*(x_WORD *)(v2 + 30) = *(x_WORD *)(v2 + 32);
		v6 = (int)x_D41A0_BYTEARRAY_0;
		v7 = *(char *)(v2 + 64);
		*(x_WORD *)(v2 + 42) = 500;
		v8 = v6 + v7;
		*(x_BYTE *)(v2 + 56) = 1;
		LOBYTE(v6) = (*(x_BYTE *)(v8 + 16))++;
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&off_D8676;
		*(x_BYTE *)(v2 + 62) = v6;
		v9 = *(signed __int16 *)(*(x_DWORD *)(v2 + 160) + 26)
			- *(unsigned __int8 *)(v2 + 62) % *(signed __int16 *)(*(x_DWORD *)(v2 + 160) + 26);
		*(x_BYTE *)(v2 + 65) = 3;
		*(x_DWORD *)(v2 + 16) = 16;
		*(x_BYTE *)(v2 + 57) = v9 + 4;
		sub_57D70(v2, a1);
		*(x_WORD *)(v2 + 80) = sub_10C40((__int16 *)(v2 + 76));
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 220);
		sub_49EA0((x_WORD *)v2, 128, 128);
		if (sub_102D0(v2, (__int16 *)(v2 + 76), 1))
		{
			sub_57F20(v2);
			v2 = 0;
		}
	}
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D8676: using guessed type void *off_D8676;

//----- (0004BD00) --------------------------------------------------------
int sub_4BD00(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // eax
	int v4; // edx
	int v5; // eax

	if (!(*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196306) & 2))
		return 0;
	v1 = sub_4A050();
	v2 = v1;
	if (!v1)
		return 0;
	*(x_BYTE *)(v1 + 69) = 80;
	*(x_BYTE *)(v1 + 63) = 5;
	*(x_BYTE *)(v1 + 64) = 10;
	*(x_DWORD *)(v1 + 4) = 300000;
	sub_49C70(v1);
	*(x_DWORD *)(v2 + 12) |= 0x48800001u;
	v3 = (int)x_D41A0_BYTEARRAY_0;
	v4 = *(char *)(v2 + 64);
	*(x_WORD *)(v2 + 42) = 0;
	v5 = v4 + v3;
	*(x_BYTE *)(v2 + 56) = 1;
	LOBYTE(v4) = (*(x_BYTE *)(v5 + 16))++;
	*(x_DWORD *)(v2 + 160) = (x_DWORD)&off_D89C8;
	*(x_BYTE *)(v2 + 57) = 64;
	*(x_BYTE *)(v2 + 65) = 3;
	*(x_DWORD *)(v2 + 16) = 0;
	*(x_BYTE *)(v2 + 70) = 0;
	*(x_BYTE *)(v2 + 62) = v4;
	sub_57D70(v2, a1);
	*(x_WORD *)(v2 + 80) = sub_10C40((__int16 *)(v2 + 76));
	sub_49A20(v2);
	sub_49C90(v2, 341);
	*(x_WORD *)(v2 + 82) = 512;
	sub_49EA0((x_WORD *)v2, 1024, 1280);
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D89C8: using guessed type void *off_D89C8;

//----- (0004BDF0) --------------------------------------------------------
int sub_4BDF0(int a1)
{
	int v1; // eax
	int v2; // ebx
	__int16 v3; // cx
	__int16 v4; // dx
	__int16 v5; // dx
	int v6; // ecx
	int v7; // edx
	int v8; // edx
	char v9; // al

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_WORD *)(v1 + 134) = 24;
		v3 = *(x_WORD *)(v1 + 20);
		*(x_WORD *)(v1 + 130) = *(x_WORD *)(v1 + 134);
		*(x_BYTE *)(v1 + 69) = 97;
		*(x_BYTE *)(v1 + 63) = 5;
		*(x_BYTE *)(v1 + 64) = 12;
		*(x_WORD *)(v1 + 20) = 9377 * v3 + 9439;
		v4 = *(x_WORD *)(v1 + 20);
		*(x_WORD *)(v1 + 132) = 54;
		*(x_DWORD *)(v1 + 4) = 1000;
		v5 = (v4 & 0x7FF) - 1;
		*(x_WORD *)(v1 + 32) = v5;
		*(x_WORD *)(v1 + 28) = v5;
		v6 = (int)x_D41A0_BYTEARRAY_0;
		*(x_WORD *)(v1 + 30) = *(x_WORD *)(v1 + 32);
		*(x_DWORD *)(v1 + 144) = 0;
		*(x_WORD *)(v1 + 34) = 0;
		*(x_DWORD *)(v1 + 16) = (v1 - (v6 + 28302)) / 168 % 100;
		v7 = *(char *)(v1 + 64);
		*(x_WORD *)(v1 + 42) = 500;
		v8 = v6 + v7;
		*(x_BYTE *)(v1 + 56) = 1;
		v9 = (*(x_BYTE *)(v8 + 16))++;
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&off_D8940;
		*(x_BYTE *)(v2 + 57) = 64;
		*(x_BYTE *)(v2 + 65) = 3;
		*(x_DWORD *)(v2 + 16) = 2;
		*(x_BYTE *)(v2 + 62) = v9;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 221);
		sub_49EA0((x_WORD *)v2, 128, 128);
	}
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D8940: using guessed type void *off_D8940;

//----- (0004BF40) --------------------------------------------------------
x_WORD *sub_4BF40(int a1)
{
	int v1; // eax
	int v2; // ebx
	x_WORD *v3; // esi
	__int16 v4; // dx
	__int16 v5; // ax
	int v6; // ecx
	int v7; // edx
	int v8; // edx

	v1 = sub_4A050();
	v2 = v1;
	v3 = (x_WORD *)v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 105;
		*(x_BYTE *)(v1 + 63) = 5;
		*(x_BYTE *)(v1 + 64) = 13;
		*(x_WORD *)(v1 + 132) = 54;
		*(x_WORD *)(v1 + 134) = 18;
		v4 = *(x_WORD *)(v1 + 20);
		*(x_WORD *)(v1 + 130) = *(x_WORD *)(v1 + 134);
		*(x_WORD *)(v1 + 20) = 9377 * v4 + 9439;
		v5 = (*(x_WORD *)(v1 + 20) & 0x7FF) - 1;
		*(x_WORD *)(v2 + 32) = v5;
		*(x_WORD *)(v2 + 28) = v5;
		v6 = (int)x_D41A0_BYTEARRAY_0;
		v7 = (int)x_D41A0_BYTEARRAY_0 + 28302;
		*(x_WORD *)(v2 + 30) = *(x_WORD *)(v2 + 32);
		*(x_DWORD *)(v2 + 4) = 1000;
		*(x_DWORD *)(v2 + 144) = 0;
		*(x_WORD *)(v2 + 34) = 0;
		*(x_WORD *)(v2 + 42) = 500;
		*(x_DWORD *)(v2 + 16) = (v2 - v7) / 168 % 100;
		v8 = *(char *)(v2 + 64);
		*(x_BYTE *)(v2 + 56) = 1;
		LOBYTE(v5) = (*(x_BYTE *)(v6 + v8 + 16))++;
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&off_D891E;
		*(x_BYTE *)(v2 + 57) = 64;
		*(x_BYTE *)(v2 + 65) = 3;
		*(x_DWORD *)(v2 + 16) = 2;
		*(x_BYTE *)(v2 + 62) = v5;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		*(x_WORD *)(v2 + 20) = 9377 * *(x_WORD *)(v2 + 20) + 9439;
		switch (*(unsigned __int16 *)(v2 + 20) % 9u)
		{
		case 0u:
		case 1u:
		case 2u:
			sub_49CD0(v3, 242);
			break;
		case 3u:
		case 4u:
		case 5u:
			sub_49CD0(v3, 271);
			break;
		case 6u:
		case 7u:
			sub_49CD0(v3, 241);
			break;
		case 8u:
			sub_49CD0((x_WORD *)v2, 239);
			break;
		default:
			break;
		}
		sub_49EA0(v3, 128, 128);
	}
	return v3;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D891E: using guessed type void *off_D891E;

//----- (0004C0B0) --------------------------------------------------------
int sub_4C0B0(int a1)
{
	int v1; // eax
	int v2; // ebx
	__int16 v3; // cx
	__int16 v4; // dx
	__int16 v5; // dx
	int v6; // ecx
	int v7; // edx
	int v8; // edx
	char v9; // al

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_WORD *)(v1 + 134) = 18;
		v3 = *(x_WORD *)(v1 + 20);
		*(x_WORD *)(v1 + 130) = *(x_WORD *)(v1 + 134);
		*(x_BYTE *)(v1 + 69) = 113;
		*(x_BYTE *)(v1 + 63) = 5;
		*(x_BYTE *)(v1 + 64) = 14;
		*(x_WORD *)(v1 + 20) = 9377 * v3 + 9439;
		v4 = *(x_WORD *)(v1 + 20);
		*(x_WORD *)(v1 + 132) = 54;
		*(x_DWORD *)(v1 + 4) = 1000;
		v5 = (v4 & 0x7FF) - 1;
		*(x_WORD *)(v1 + 32) = v5;
		*(x_WORD *)(v1 + 28) = v5;
		v6 = (int)x_D41A0_BYTEARRAY_0;
		*(x_WORD *)(v1 + 30) = *(x_WORD *)(v1 + 32);
		*(x_DWORD *)(v1 + 144) = 0;
		*(x_WORD *)(v1 + 34) = 0;
		*(x_DWORD *)(v1 + 16) = (v1 - (v6 + 28302)) / 168 % 100;
		v7 = *(char *)(v1 + 64);
		*(x_WORD *)(v1 + 42) = 500;
		v8 = v6 + v7;
		*(x_BYTE *)(v1 + 56) = 1;
		v9 = (*(x_BYTE *)(v8 + 16))++;
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&off_D891E;
		*(x_BYTE *)(v2 + 57) = 64;
		*(x_BYTE *)(v2 + 65) = 3;
		*(x_DWORD *)(v2 + 16) = 2;
		*(x_BYTE *)(v2 + 62) = v9;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 219);
		sub_49EA0((x_WORD *)v2, 128, 128);
	}
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D891E: using guessed type void *off_D891E;

//----- (0004C1E0) --------------------------------------------------------
int sub_4C1E0(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // ecx
	int v4; // edx
	int v5; // ecx
	char v6; // ah

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 121;
		*(x_BYTE *)(v1 + 63) = 5;
		*(x_BYTE *)(v1 + 64) = 15;
		*(x_WORD *)(v1 + 132) = 30;
		*(x_WORD *)(v1 + 134) = 0;
		*(x_DWORD *)(v1 + 4) = 1000;
		*(x_WORD *)(v1 + 32) = 0;
		*(x_WORD *)(v1 + 130) = *(x_WORD *)(v1 + 132);
		*(x_WORD *)(v1 + 28) = *(x_WORD *)(v1 + 32);
		v3 = (int)x_D41A0_BYTEARRAY_0;
		*(x_WORD *)(v1 + 30) = *(x_WORD *)(v1 + 32);
		*(x_DWORD *)(v1 + 144) = 0;
		*(x_WORD *)(v1 + 34) = 0;
		*(x_DWORD *)(v1 + 16) = (v1 - (v3 + 28302)) / 168 % 100;
		v4 = *(char *)(v1 + 64);
		*(x_WORD *)(v1 + 42) = 500;
		v5 = v4 + v3;
		*(x_BYTE *)(v1 + 56) = 1;
		LOBYTE(v4) = (*(x_BYTE *)(v5 + 16))++;
		*(x_DWORD *)(v1 + 160) = (x_DWORD)&off_D86DC;
		*(x_BYTE *)(v1 + 62) = v4;
		LOWORD(v5) = *(x_WORD *)(*(x_DWORD *)(v1 + 160) + 26);
		LOWORD(v4) = (signed __int16)*(unsigned __int8 *)(v1 + 62) % *(x_WORD *)(*(x_DWORD *)(v1 + 160) + 26);
		*(x_BYTE *)(v1 + 65) = 3;
		v6 = *(x_BYTE *)(v1 + 14) | 2;
		*(x_BYTE *)(v2 + 57) = v5 - v4 + 4;
		*(x_BYTE *)(v2 + 14) = v6;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 0);
		sub_49EA0((x_WORD *)v2, 128, 128);
	}
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D86DC: using guessed type void *off_D86DC;

//----- (0004C310) --------------------------------------------------------
int sub_4C310(int a1)
{
	int v1; // eax
	int v2; // ebx
	__int16 v3; // ax
	__int16 v4; // ax
	int v5; // ecx
	int v6; // edx
	int v7; // eax
	int v8; // ecx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = -127;
		*(x_BYTE *)(v1 + 63) = 5;
		*(x_BYTE *)(v1 + 64) = 16;
		*(x_WORD *)(v1 + 132) = 60;
		*(x_WORD *)(v1 + 134) = 20;
		v3 = *(x_WORD *)(v1 + 132);
		*(x_DWORD *)(v2 + 4) = 60000;
		*(x_WORD *)(v2 + 130) = v3;
		sub_49C70(v2);
		*(x_WORD *)(v2 + 20) = 9377 * *(x_WORD *)(v2 + 20) + 9439;
		v4 = (*(x_WORD *)(v2 + 20) & 0x7FF) - 1;
		*(x_WORD *)(v2 + 32) = v4;
		*(x_WORD *)(v2 + 28) = v4;
		v5 = (int)x_D41A0_BYTEARRAY_0;
		v6 = (int)x_D41A0_BYTEARRAY_0 + 28302;
		*(x_WORD *)(v2 + 30) = *(x_WORD *)(v2 + 32);
		*(x_WORD *)(v2 + 34) = 0;
		*(x_WORD *)(v2 + 42) = 500;
		v7 = *(char *)(v2 + 64);
		*(x_BYTE *)(v2 + 56) = 1;
		v8 = v7 + v5;
		*(x_DWORD *)(v2 + 16) = (v2 - v6) / 168 % 100;
		LOBYTE(v7) = (*(x_BYTE *)(v8 + 16))++;
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&unk_D86FE;
		*(x_BYTE *)(v2 + 57) = 64;
		*(x_BYTE *)(v2 + 65) = 3;
		*(x_DWORD *)(v2 + 16) = 0;
		*(x_BYTE *)(v2 + 62) = v7;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 207);
		*(x_WORD *)(v2 + 82) = (5 * (unsigned __int16)x_WORD_DA076
			- (__CFSHL__(5 * (unsigned __int16)x_WORD_DA076 >> 31, 3)
				+ 8 * (5 * (unsigned __int16)x_WORD_DA076 >> 31))) >> 3;
		sub_49EA0((x_WORD *)v2, 128, 128);
	}
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// DA076: using guessed type __int16 x_WORD_DA076;

//----- (0004C460) --------------------------------------------------------
int sub_4C460(int a1)
{
	int v1; // eax
	int v2; // ebx
	__int16 v3; // dx
	int v4; // ecx
	int v5; // edx
	int v6; // edx
	char v7; // al

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = -119;
		*(x_BYTE *)(v1 + 63) = 5;
		*(x_BYTE *)(v1 + 64) = 17;
		*(x_WORD *)(v1 + 132) = 68;
		*(x_WORD *)(v1 + 134) = 20;
		*(x_DWORD *)(v1 + 4) = 10000;
		*(x_WORD *)(v1 + 130) = *(x_WORD *)(v1 + 132);
		sub_49C70(v1);
		*(x_WORD *)(v2 + 20) = 9377 * *(x_WORD *)(v2 + 20) + 9439;
		v3 = (*(x_WORD *)(v2 + 20) & 0x7FF) - 1;
		*(x_WORD *)(v2 + 32) = v3;
		*(x_WORD *)(v2 + 28) = v3;
		v4 = (int)x_D41A0_BYTEARRAY_0;
		*(x_WORD *)(v2 + 30) = *(x_WORD *)(v2 + 32);
		*(x_WORD *)(v2 + 34) = 0;
		*(x_DWORD *)(v2 + 16) = (v2 - (v4 + 28302)) / 168 % 100;
		v5 = *(char *)(v2 + 64);
		*(x_WORD *)(v2 + 42) = 350;
		v6 = v4 + v5;
		*(x_BYTE *)(v2 + 56) = 1;
		v7 = (*(x_BYTE *)(v6 + 16))++;
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&unk_D8720;
		*(x_BYTE *)(v2 + 57) = 64;
		*(x_BYTE *)(v2 + 65) = 3;
		*(x_DWORD *)(v2 + 16) = 0;
		*(x_BYTE *)(v2 + 62) = v7;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 285);
		sub_49EA0((x_WORD *)v2, 128, 128);
	}
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004C590) --------------------------------------------------------
int sub_4C590(int a1)
{
	int v1; // eax
	int v2; // ebx
	__int16 v3; // dx
	int v4; // ecx
	int v5; // edx
	int v6; // edx
	char v7; // al

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = -109;
		*(x_BYTE *)(v1 + 63) = 5;
		*(x_BYTE *)(v1 + 64) = 18;
		*(x_WORD *)(v1 + 132) = 10;
		*(x_WORD *)(v1 + 134) = 6;
		*(x_DWORD *)(v1 + 4) = 36000;
		*(x_WORD *)(v1 + 130) = *(x_WORD *)(v1 + 132);
		sub_49C70(v1);
		*(x_WORD *)(v2 + 20) = 9377 * *(x_WORD *)(v2 + 20) + 9439;
		v3 = (*(x_WORD *)(v2 + 20) & 0x7FF) - 1;
		*(x_WORD *)(v2 + 32) = v3;
		*(x_WORD *)(v2 + 28) = v3;
		v4 = (int)x_D41A0_BYTEARRAY_0;
		*(x_WORD *)(v2 + 30) = *(x_WORD *)(v2 + 32);
		*(x_WORD *)(v2 + 34) = 0;
		*(x_DWORD *)(v2 + 16) = (v2 - (v4 + 28302)) / 168 % 100;
		v5 = *(char *)(v2 + 64);
		*(x_WORD *)(v2 + 42) = 500;
		v6 = v4 + v5;
		*(x_BYTE *)(v2 + 56) = 1;
		v7 = (*(x_BYTE *)(v6 + 16))++;
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&off_D8742;
		*(x_BYTE *)(v2 + 57) = 64;
		*(x_BYTE *)(v2 + 65) = 3;
		*(x_BYTE *)(v2 + 62) = v7;
		*(x_DWORD *)(v2 + 16) = 100;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 286);
		sub_49EA0((x_WORD *)v2, 512, 512);
	}
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D8742: using guessed type void *off_D8742;

//----- (0004C6B0) --------------------------------------------------------
int sub_4C6B0(int a1)
{
	int v1; // eax
	int v2; // ebx
	__int16 v3; // dx
	int v4; // ecx
	int v5; // edx
	int v6; // ecx
	int v7; // ecx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = -103;
		*(x_BYTE *)(v1 + 63) = 5;
		*(x_BYTE *)(v1 + 64) = 19;
		*(x_WORD *)(v1 + 132) = 76;
		*(x_WORD *)(v1 + 134) = 8;
		*(x_DWORD *)(v1 + 4) = 600;
		*(x_WORD *)(v1 + 130) = *(x_WORD *)(v1 + 132);
		sub_49C70(v1);
		*(x_WORD *)(v2 + 20) = 9377 * *(x_WORD *)(v2 + 20) + 9439;
		v3 = (*(x_WORD *)(v2 + 20) & 0x7FF) - 1;
		*(x_WORD *)(v2 + 32) = v3;
		*(x_WORD *)(v2 + 28) = v3;
		v4 = (int)x_D41A0_BYTEARRAY_0;
		*(x_WORD *)(v2 + 30) = *(x_WORD *)(v2 + 32);
		*(x_WORD *)(v2 + 34) = 0;
		*(x_WORD *)(v2 + 42) = 300;
		*(x_BYTE *)(v2 + 65) = 3;
		*(x_DWORD *)(v2 + 16) = (v2 - (v4 + 28302)) / 168 % 100;
		v5 = *(char *)(v2 + 64);
		*(x_BYTE *)(v2 + 66) = 0;
		v6 = v5 + v4;
		*(x_BYTE *)(v2 + 56) = 1;
		LOBYTE(v5) = (*(x_BYTE *)(v6 + 16))++;
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&unk_D8786;
		*(x_BYTE *)(v2 + 62) = v5;
		v7 = *(signed __int16 *)(*(x_DWORD *)(v2 + 160) + 26)
			- *(unsigned __int8 *)(v2 + 62) % *(signed __int16 *)(*(x_DWORD *)(v2 + 160) + 26);
		*(x_BYTE *)(v2 + 65) = 3;
		*(x_BYTE *)(v2 + 57) = v7 + 4;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 287);
		sub_49EA0((x_WORD *)v2, 85, 51);
	}
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004C7F0) --------------------------------------------------------
int sub_4C7F0(int a1)
{
	int v1; // eax
	int v2; // ebx
	__int16 v3; // dx
	int v4; // eax
	int v5; // edx
	int v6; // edx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = -95;
		*(x_BYTE *)(v1 + 63) = 5;
		*(x_BYTE *)(v1 + 64) = 20;
		*(x_WORD *)(v1 + 132) = 32;
		*(x_WORD *)(v1 + 134) = 20;
		*(x_DWORD *)(v1 + 4) = 5500;
		*(x_WORD *)(v1 + 130) = *(x_WORD *)(v1 + 132);
		sub_49C70(v1);
		*(x_WORD *)(v2 + 20) = 9377 * *(x_WORD *)(v2 + 20) + 9439;
		v3 = *(x_WORD *)(v2 + 20) & 0x7FF;
		*(x_WORD *)(v2 + 34) = 0;
		*(x_WORD *)(v2 + 32) = --v3;
		*(x_WORD *)(v2 + 28) = v3;
		v4 = *(char *)(v2 + 64);
		*(x_WORD *)(v2 + 30) = *(x_WORD *)(v2 + 32);
		v5 = (int)x_D41A0_BYTEARRAY_0;
		*(x_WORD *)(v2 + 42) = 100;
		v6 = v4 + v5;
		*(x_BYTE *)(v2 + 56) = 1;
		LOBYTE(v4) = (*(x_BYTE *)(v6 + 16))++;
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&unk_D87A8;
		*(x_BYTE *)(v2 + 57) = 64;
		*(x_BYTE *)(v2 + 65) = 3;
		*(x_BYTE *)(v2 + 62) = v4;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 288);
		sub_49EA0((x_WORD *)v2, 384, 512);
	}
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004C8F0) --------------------------------------------------------
int sub_4C8F0(int a1)
{
	int v1; // eax
	int v2; // ebx
	__int16 v3; // cx
	__int16 v4; // dx
	__int16 v5; // dx
	int v6; // eax
	int v7; // edx
	int v8; // eax

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		v3 = *(x_WORD *)(v1 + 20);
		*(x_WORD *)(v1 + 130) = *(x_WORD *)(v1 + 134);
		*(x_BYTE *)(v1 + 69) = -87;
		*(x_BYTE *)(v1 + 63) = 5;
		*(x_BYTE *)(v1 + 64) = 21;
		*(x_WORD *)(v1 + 132) = 96;
		*(x_DWORD *)(v1 + 4) = 1000;
		*(x_DWORD *)(v1 + 144) = 1000;
		*(x_WORD *)(v1 + 34) = 0;
		*(x_WORD *)(v1 + 20) = 9377 * v3 + 9439;
		v4 = *(x_WORD *)(v1 + 20);
		*(x_WORD *)(v1 + 42) = 400;
		*(x_BYTE *)(v1 + 56) = 1;
		v5 = (v4 & 0x7FF) - 1;
		*(x_WORD *)(v1 + 32) = v5;
		*(x_WORD *)(v1 + 28) = v5;
		*(x_WORD *)(v1 + 30) = *(x_WORD *)(v1 + 32);
		v6 = *(char *)(v1 + 64);
		v7 = v6 + (int)x_D41A0_BYTEARRAY_0;
		LOBYTE(v6) = *(x_BYTE *)(v6 + x_D41A0_BYTEARRAY_0 + 16);
		*(x_BYTE *)(v7 + 16) = v6 + 1;
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&unk_D8896;
		*(x_BYTE *)(v2 + 57) = 64;
		*(x_BYTE *)(v2 + 65) = 3;
		*(x_BYTE *)(v2 + 70) = 0;
		*(x_WORD *)(v2 + 44) = 0;
		*(x_BYTE *)(v2 + 68) = 0;
		*(x_BYTE *)(v2 + 67) = 0;
		*(x_BYTE *)(v2 + 62) = v6;
		sub_57D70(v2, a1);
		v8 = sub_49A20(v2);
		sub_26500(v8, v2);
		sub_268F0(v2, 1u);
		sub_49EA0((x_WORD *)v2, 128, 128);
	}
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004CA00) --------------------------------------------------------
int sub_4CA00(int a1)
{
	int v1; // eax
	int v2; // ebx
	__int16 v3; // dx
	__int16 v4; // ax
	int v5; // ecx
	int v6; // eax
	int v7; // ecx
	__int16 v8; // dx

	if (sub_4A810() < 15)
		return 0;
	v1 = sub_4A050();
	v2 = v1;
	if (!v1)
		return 0;
	*(x_BYTE *)(v1 + 69) = -80;
	*(x_BYTE *)(v1 + 63) = 5;
	*(x_BYTE *)(v1 + 64) = 22;
	*(x_WORD *)(v1 + 132) = 128;
	*(x_WORD *)(v1 + 134) = 16;
	v3 = *(x_WORD *)(v1 + 20);
	*(x_WORD *)(v1 + 130) = *(x_WORD *)(v1 + 134);
	*(x_WORD *)(v1 + 20) = 9377 * v3 + 9439;
	v4 = (*(x_WORD *)(v1 + 20) & 0x7FF) - 1;
	*(x_WORD *)(v2 + 32) = v4;
	*(x_WORD *)(v2 + 28) = v4;
	v5 = *(char *)(v2 + 64);
	*(x_WORD *)(v2 + 30) = *(x_WORD *)(v2 + 32);
	v6 = (int)x_D41A0_BYTEARRAY_0;
	*(x_DWORD *)(v2 + 4) = 2000;
	v7 = v6 + v5;
	*(x_WORD *)(v2 + 34) = 0;
	LOBYTE(v3) = (*(x_BYTE *)(v7 + 16))++;
	*(x_DWORD *)(v2 + 160) = (x_DWORD)&unk_D87CA;
	*(x_BYTE *)(v2 + 62) = v3;
	LOWORD(v7) = *(x_WORD *)(*(x_DWORD *)(v2 + 160) + 26);
	v8 = (signed __int16)*(unsigned __int8 *)(v2 + 62) % *(x_WORD *)(*(x_DWORD *)(v2 + 160) + 26);
	*(x_BYTE *)(v2 + 65) = 3;
	*(x_BYTE *)(v2 + 56) = 3;
	*(x_WORD *)(v2 + 148) = 0;
	*(x_WORD *)(v2 + 82) = 0;
	*(x_BYTE *)(v2 + 92) = 0;
	*(x_WORD *)(v2 + 44) = 11;
	*(x_WORD *)(v2 + 42) = 0;
	*(x_WORD *)(v2 + 54) = 0;
	*(x_WORD *)(v2 + 150) = 1024;
	*(x_WORD *)(v2 + 36) = 0;
	*(x_BYTE *)(v2 + 70) = 15;
	*(x_BYTE *)(v2 + 57) = v7 - v8 + 4;
	*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)a1;
	*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 4);
	x_WORD_EB39C = sub_10C40(&x_WORD_EB398) + 384;
	sub_57D70(v2, (int)&x_WORD_EB398);
	sub_49C70(v2);
	sub_49A20(v2);
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (0004CB60) --------------------------------------------------------
signed int sub_4CB60(int a1)
{
	signed int v1; // ebx
	__int16 v2; // di
	int v3; // eax
	x_WORD *v5; // [esp+0h] [ebp-8h]
	int v6; // [esp+4h] [ebp-4h]

	v1 = 1;
	v5 = (x_WORD *)a1;
	while ((signed __int16)v1 <= *(char *)(a1 + 70) / 2)
	{
		v2 = 0;
		while (v2 < 2)
		{
			v6 = sub_4A050();
			if (v6)
			{
				if (v2)
					v3 = -(signed __int16)v1;
				else
					LOWORD(v3) = v1;
				sub_274C0(a1, v6, v5, v3);
			}
			++v2;
			v5 = (x_WORD *)v6;
		}
		++v1;
	}
	sub_27590(v1, a1);
	sub_27610(v1, a1);
	return sub_276E0(a1);
}

//----- (0004CBF0) --------------------------------------------------------
int sub_4CBF0(int a1)
{
	int v1; // eax
	int v2; // ebx
	__int16 v3; // dx
	__int16 v4; // ax
	__int16 v5; // ax
	int v6; // edx
	int v7; // eax
	int v8; // eax

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = -72;
		*(x_BYTE *)(v1 + 63) = 5;
		*(x_BYTE *)(v1 + 64) = 23;
		*(x_WORD *)(v1 + 132) = 24;
		*(x_WORD *)(v1 + 134) = 14;
		v3 = *(x_WORD *)(v1 + 20);
		*(x_WORD *)(v1 + 130) = *(x_WORD *)(v1 + 132);
		*(x_WORD *)(v1 + 20) = 9377 * v3 + 9439;
		v4 = *(x_WORD *)(v1 + 20);
		*(x_DWORD *)(v2 + 4) = 10000;
		*(x_DWORD *)(v2 + 144) = 100;
		v5 = (v4 & 0x7FF) - 1;
		*(x_WORD *)(v2 + 32) = v5;
		v6 = *(char *)(v2 + 64);
		*(x_WORD *)(v2 + 28) = v5;
		v7 = (int)x_D41A0_BYTEARRAY_0;
		*(x_WORD *)(v2 + 42) = 500;
		v8 = v6 + v7;
		*(x_BYTE *)(v2 + 56) = 1;
		LOBYTE(v6) = (*(x_BYTE *)(v8 + 16))++;
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&unk_D87EC;
		*(x_BYTE *)(v2 + 57) = 64;
		*(x_BYTE *)(v2 + 65) = 3;
		*(x_WORD *)(v2 + 44) = 0x2000;
		*(x_BYTE *)(v2 + 62) = v6;
		*(x_WORD *)(a1 + 4) = *(x_WORD *)(v2 + 44);
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 289);
		sub_49EA0((x_WORD *)v2, 384, 384);
	}
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004CCF0) --------------------------------------------------------
int sub_4CCF0(int a1)
{
	int v1; // eax
	int v2; // ebx
	__int16 v3; // ax
	__int16 v4; // ax
	int v5; // edx
	int v6; // eax
	int v7; // eax

	if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308) != 2)
		return 0;
	v1 = sub_4A050();
	v2 = v1;
	if (!v1)
		return 0;
	*(x_BYTE *)(v1 + 69) = -63;
	*(x_BYTE *)(v1 + 63) = 5;
	*(x_BYTE *)(v1 + 64) = 24;
	*(x_BYTE *)(v1 + 70) = 0;
	*(x_WORD *)(v1 + 132) = 80;
	*(x_WORD *)(v1 + 134) = 24;
	v3 = *(x_WORD *)(v1 + 134);
	*(x_DWORD *)(v2 + 4) = 16000;
	*(x_WORD *)(v2 + 130) = v3;
	sub_49C70(v2);
	*(x_WORD *)(v2 + 20) = 9377 * *(x_WORD *)(v2 + 20) + 9439;
	v4 = *(x_WORD *)(v2 + 20) & 0x7FF;
	*(x_WORD *)(v2 + 34) = 0;
	*(x_WORD *)(v2 + 32) = --v4;
	*(x_WORD *)(v2 + 28) = v4;
	v5 = *(char *)(v2 + 64);
	*(x_WORD *)(v2 + 30) = *(x_WORD *)(v2 + 32);
	v6 = (int)x_D41A0_BYTEARRAY_0;
	*(x_WORD *)(v2 + 42) = 1500;
	v7 = v5 + v6;
	*(x_BYTE *)(v2 + 56) = 1;
	LOBYTE(v5) = (*(x_BYTE *)(v7 + 16))++;
	*(x_BYTE *)(v2 + 62) = v5;
	*(x_DWORD *)(v2 + 160) = (x_DWORD)&unk_D8962;
	*(x_BYTE *)(v2 + 57) = 64;
	*(x_BYTE *)(v2 + 65) = 3;
	sub_57D70(v2, a1);
	sub_49A20(v2);
	sub_49CD0((x_WORD *)v2, 335);
	sub_49EA0((x_WORD *)v2, 256, 640);
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004CE00) --------------------------------------------------------
int sub_4CE00(int a1)
{
	int v1; // eax
	int v2; // ebx
	__int16 v3; // dx
	int v4; // eax
	int v5; // edx
	int v6; // edx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = -55;
		*(x_BYTE *)(v1 + 63) = 5;
		*(x_BYTE *)(v1 + 64) = 25;
		*(x_BYTE *)(v1 + 70) = 0;
		*(x_WORD *)(v1 + 132) = 60;
		*(x_WORD *)(v1 + 134) = 20;
		*(x_DWORD *)(v1 + 4) = 7500;
		*(x_WORD *)(v1 + 130) = *(x_WORD *)(v1 + 132);
		sub_49C70(v1);
		*(x_WORD *)(v2 + 20) = 9377 * *(x_WORD *)(v2 + 20) + 9439;
		v3 = *(x_WORD *)(v2 + 20) & 0x7FF;
		*(x_WORD *)(v2 + 34) = 0;
		*(x_WORD *)(v2 + 32) = --v3;
		*(x_WORD *)(v2 + 28) = v3;
		v4 = *(char *)(v2 + 64);
		*(x_WORD *)(v2 + 30) = *(x_WORD *)(v2 + 32);
		v5 = (int)x_D41A0_BYTEARRAY_0;
		*(x_WORD *)(v2 + 42) = 300;
		v6 = v4 + v5;
		*(x_BYTE *)(v2 + 56) = 1;
		LOBYTE(v4) = (*(x_BYTE *)(v6 + 16))++;
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&unk_D880E;
		*(x_BYTE *)(v2 + 57) = 64;
		*(x_BYTE *)(v2 + 65) = 3;
		*(x_BYTE *)(v2 + 62) = v4;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 290);
		sub_49EA0((x_WORD *)v2, 384, 384);
	}
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004CF00) --------------------------------------------------------
int sub_4CF00(int a1)
{
	int v1; // eax
	int v2; // ebx
	__int16 v3; // dx
	int v4; // eax
	int v5; // edx
	int v6; // edx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = -47;
		*(x_BYTE *)(v1 + 63) = 5;
		*(x_BYTE *)(v1 + 64) = 26;
		*(x_WORD *)(v1 + 132) = 25;
		*(x_WORD *)(v1 + 134) = 25;
		*(x_DWORD *)(v1 + 4) = 4400;
		*(x_WORD *)(v1 + 130) = *(x_WORD *)(v1 + 134);
		sub_49C70(v1);
		*(x_WORD *)(v2 + 20) = 9377 * *(x_WORD *)(v2 + 20) + 9439;
		v3 = *(x_WORD *)(v2 + 20) & 0x7FF;
		*(x_WORD *)(v2 + 34) = 0;
		*(x_WORD *)(v2 + 32) = --v3;
		*(x_WORD *)(v2 + 28) = v3;
		v4 = *(char *)(v2 + 64);
		*(x_WORD *)(v2 + 30) = *(x_WORD *)(v2 + 32);
		v5 = (int)x_D41A0_BYTEARRAY_0;
		*(x_WORD *)(v2 + 42) = 300;
		v6 = v4 + v5;
		*(x_BYTE *)(v2 + 56) = 1;
		LOBYTE(v4) = (*(x_BYTE *)(v6 + 16))++;
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&unk_D88FC;
		*(x_BYTE *)(v2 + 57) = 64;
		*(x_BYTE *)(v2 + 65) = 3;
		*(x_BYTE *)(v2 + 62) = v4;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 318);
		sub_49EA0((x_WORD *)v2, 256, 384);
		sub_293D0(v2);
	}
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004D000) --------------------------------------------------------
unsigned int sub_4D000(unsigned int a1, int a2)
{
	x_BYTE *v2; // eax
	x_BYTE *v3; // ebx
	int v4; // edi
	int v5; // eax
	__int64 v6; // rtt
	x_BYTE *v7; // eax
	x_WORD *v8; // ebx
	int v9; // eax
	x_BYTE *v11; // [esp+0h] [ebp-14h]
	signed int i; // [esp+4h] [ebp-10h]
	x_BYTE *v13; // [esp+8h] [ebp-Ch]
	int v14; // [esp+8h] [ebp-Ch]
	signed int v15; // [esp+Ch] [ebp-8h]
	char v16; // [esp+10h] [ebp-4h]

	v16 = 0;
	if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308) == 2)
	{
		v16 = 1;
	}
	else
	{
		if (sub_4A810() >= 51)
		{
			v2 = (x_BYTE *)sub_4A050();
			v3 = v2;
			a1 = (unsigned int)v2;
			if (v2)
			{
				v2[69] = -39;
				v2[63] = 5;
				v2[64] = 27;
				sub_57D70((int)v2, a2);
				v13 = v3;
				v15 = 0;
				v4 = (signed int)&v3[-(int)x_D41A0_BYTEARRAY_0 - 28302] / 168;
				while (v15 < 5 && !v16)
				{
					v5 = sub_4A050();
					v11 = (x_BYTE *)v5;
					if (v5)
					{
						*(x_BYTE *)(v5 + 69) = -23;
						*(x_BYTE *)(v5 + 63) = 5;
						*(x_BYTE *)(v5 + 64) = 27;
						*(x_BYTE *)(v5 + 59) = v15;
						v6 = v5 - (x_D41A0_BYTEARRAY_0[28302]);
						*(x_WORD *)(v5 + 26) = v4;
						*(x_WORD *)(v5 + 50) = v4;
						*((x_WORD *)v13 + 26) = v6 / 168;
						v14 = v5;
						*(x_WORD *)(v5 + 52) = 0;
						sub_57D70(v5, a2);
						for (i = 0; i < 9 && !v16; i++)
						{
							v7 = (x_BYTE *)sub_4A050();
							v8 = (x_WORD*)v7;
							v11 = v7;
							if (v7)
							{
								v7[69] = -22;
								v7[63] = 5;
								v7[64] = 27;
								v7[59] = v15;
								v9 = (signed int)&v7[-(int)x_D41A0_BYTEARRAY_0 - 28302] / 168;
								v8[13] = v4;
								v8[25] = v4;
								*(x_WORD *)(v14 + 52) = v9;
								v8[26] = 0;
								sub_57D70((int)v8, a2);
							}
							else
							{
								v16 = 1;
							}
							v14 = (int)v11;
						}
					}
					else
					{
						v16 = 1;
					}
					v13 = v11;
					++v15;
				}
			}
		}
		if (!a1 || v16)
		{
			sub_2AE80(a1);
		}
		else
		{
			sub_2AC50(a1);
			sub_2AD40(a1);
			sub_2AE30(a1);
		}
	}
	if (v16)
		a1 = 0;
	return a1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004D1D0) --------------------------------------------------------
int sub_4D1D0(int a1)
{
	int v1; // eax
	int v2; // ebx
	__int16 v3; // dx
	__int16 v4; // ax
	int v5; // edx
	int v6; // eax
	int v7; // edx
	char v8; // cl
	int v9; // ecx
	int v10; // eax

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = -31;
		*(x_BYTE *)(v1 + 63) = 5;
		*(x_BYTE *)(v1 + 64) = 28;
		*(x_WORD *)(v1 + 132) = 120;
		*(x_WORD *)(v1 + 134) = 64;
		*(x_DWORD *)(v1 + 4) = 8000;
		sub_49C70(v1);
		v3 = *(x_WORD *)(v2 + 20);
		*(x_BYTE *)(v2 + 15) |= 8u;
		*(x_WORD *)(v2 + 20) = 9377 * v3 + 9439;
		v4 = *(x_WORD *)(v2 + 20) & 0x7FF;
		*(x_WORD *)(v2 + 34) = 0;
		*(x_WORD *)(v2 + 32) = --v4;
		*(x_WORD *)(v2 + 28) = v4;
		v5 = *(char *)(v2 + 64);
		*(x_WORD *)(v2 + 30) = *(x_WORD *)(v2 + 32);
		v6 = (int)x_D41A0_BYTEARRAY_0;
		*(x_WORD *)(v2 + 42) = 2000;
		v7 = v6 + v5;
		*(x_BYTE *)(v2 + 56) = 1;
		v8 = (*(x_BYTE *)(v7 + 16))++;
		*(x_BYTE *)(v2 + 62) = v8;
		v9 = *(signed __int16 *)(v2 + 134);
		v10 = (*(signed __int16 *)(v2 + 132) - v9) / 2;
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&unk_D8830;
		*(x_BYTE *)(v2 + 57) = 64;
		*(x_BYTE *)(v2 + 65) = 3;
		*(x_WORD *)(v2 + 130) = v9 + v10;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 292);
		sub_49EA0((x_WORD *)v2, 85, 42);
	}
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004D2E0) --------------------------------------------------------
int sub_4D2E0(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // eax

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 0;
		*(x_BYTE *)(v1 + 63) = 9;
		*(x_BYTE *)(v1 + 64) = 0;
		*(x_WORD *)(v1 + 130) = 384;
		*(x_WORD *)(v1 + 132) = 384;
		v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
		*(x_DWORD *)(v2 + 144) = 50;
		*(x_DWORD *)(v2 + 4) = v3;
		BYTE1(v3) = *(x_BYTE *)(v2 + 12);
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&off_D8456;
		*(x_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 340);
		sub_847D0(v2, 128, 1, 0);
	}
	return v2;
}
// D8456: using guessed type void *off_D8456;

//----- (0004D380) --------------------------------------------------------
int sub_4D380(int a1)
{
	int result; // eax

	result = sub_4D2E0(a1);
	if (result)
	{
		*(x_BYTE *)(result + 69) = 29;
		*(x_BYTE *)(result + 64) = 28;
	}
	return result;
}

//----- (0004D3B0) --------------------------------------------------------
int sub_4D3B0(int a1)
{
	int result; // eax
	int v2; // ebx
	int v3; // eax

	result = sub_4A050();
	v2 = result;
	if (result)
	{
		*(x_BYTE *)(result + 69) = 1;
		*(x_BYTE *)(result + 63) = 9;
		*(x_BYTE *)(result + 64) = 1;
		*(x_WORD *)(result + 130) = 384;
		*(x_WORD *)(result + 132) = 384;
		v3 = 4096 / *(signed __int16 *)(result + 130);
		*(x_DWORD *)(v2 + 144) = 50;
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&unk_D83F0;
		*(x_DWORD *)(v2 + 4) = v3;
		BYTE1(v3) = *(x_BYTE *)(v2 + 12);
		*(x_BYTE *)(v2 + 65) = 10;
		*(x_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 209);
		sub_49EA0((x_WORD *)v2, 2 * *(x_WORD *)(v2 + 84), 5 * *(signed __int16 *)(v2 + 88) / 2);
		result = v2;
	}
	return result;
}

//----- (0004D470) --------------------------------------------------------
int sub_4D470(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // eax

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 2;
		*(x_BYTE *)(v1 + 63) = 9;
		*(x_BYTE *)(v1 + 64) = 2;
		*(x_WORD *)(v1 + 130) = 384;
		*(x_WORD *)(v1 + 132) = 384;
		v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
		*(x_DWORD *)(v2 + 144) = 50;
		*(x_DWORD *)(v2 + 4) = v3;
		BYTE1(v3) = *(x_BYTE *)(v2 + 12);
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&off_D83CE;
		*(x_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 211);
	}
	return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004D500) --------------------------------------------------------
int sub_4D500(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // eax

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 3;
		*(x_BYTE *)(v1 + 63) = 9;
		*(x_BYTE *)(v1 + 64) = 3;
		*(x_WORD *)(v1 + 130) = 384;
		*(x_WORD *)(v1 + 132) = 384;
		v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
		*(x_DWORD *)(v2 + 144) = 50;
		*(x_DWORD *)(v2 + 4) = v3;
		BYTE1(v3) = *(x_BYTE *)(v2 + 12);
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&off_D83CE;
		*(x_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 76);
	}
	return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004D590) --------------------------------------------------------
int sub_4D590(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // eax

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 4;
		*(x_BYTE *)(v1 + 63) = 9;
		*(x_BYTE *)(v1 + 64) = 4;
		*(x_WORD *)(v1 + 130) = 384;
		*(x_WORD *)(v1 + 132) = 384;
		v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
		*(x_DWORD *)(v2 + 144) = 50;
		*(x_DWORD *)(v2 + 4) = v3;
		BYTE1(v3) = *(x_BYTE *)(v2 + 12);
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&off_D83CE;
		*(x_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 210);
	}
	return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004D620) --------------------------------------------------------
int sub_4D620(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // eax

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 5;
		*(x_BYTE *)(v1 + 63) = 9;
		*(x_BYTE *)(v1 + 64) = 5;
		*(x_WORD *)(v1 + 130) = 384;
		*(x_WORD *)(v1 + 132) = 384;
		v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
		*(x_DWORD *)(v2 + 144) = 50;
		*(x_DWORD *)(v2 + 4) = v3;
		BYTE1(v3) = *(x_BYTE *)(v2 + 12);
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&off_D83CE;
		*(x_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 211);
	}
	return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004D6B0) --------------------------------------------------------
int sub_4D6B0(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // eax

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 6;
		*(x_BYTE *)(v1 + 63) = 9;
		*(x_BYTE *)(v1 + 64) = 6;
		*(x_WORD *)(v1 + 130) = 384;
		*(x_WORD *)(v1 + 132) = 384;
		v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
		*(x_DWORD *)(v2 + 144) = 50;
		*(x_DWORD *)(v2 + 4) = v3;
		BYTE1(v3) = *(x_BYTE *)(v2 + 12);
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&off_D83CE;
		*(x_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 212);
	}
	return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004D740) --------------------------------------------------------
int sub_4D740(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // eax

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 7;
		*(x_BYTE *)(v1 + 63) = 9;
		*(x_BYTE *)(v1 + 64) = 7;
		*(x_WORD *)(v1 + 130) = 384;
		*(x_WORD *)(v1 + 132) = 384;
		v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
		*(x_DWORD *)(v2 + 144) = 50;
		*(x_DWORD *)(v2 + 4) = v3;
		BYTE1(v3) = *(x_BYTE *)(v2 + 12);
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&off_D83CE;
		*(x_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 213);
	}
	return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004D7D0) --------------------------------------------------------
int sub_4D7D0(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // eax

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 8;
		*(x_BYTE *)(v1 + 63) = 9;
		*(x_BYTE *)(v1 + 64) = 8;
		*(x_WORD *)(v1 + 130) = 384;
		*(x_WORD *)(v1 + 132) = 384;
		v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
		*(x_DWORD *)(v2 + 144) = 50;
		*(x_DWORD *)(v2 + 4) = v3;
		BYTE1(v3) = *(x_BYTE *)(v2 + 12);
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&off_D8434;
		*(x_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 214);
	}
	return v2;
}
// D8434: using guessed type void *off_D8434;

//----- (0004D860) --------------------------------------------------------
int sub_4D860(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // eax

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 9;
		*(x_BYTE *)(v1 + 63) = 9;
		*(x_BYTE *)(v1 + 64) = 9;
		*(x_WORD *)(v1 + 130) = 384;
		*(x_WORD *)(v1 + 132) = 384;
		v3 = 3584 / *(signed __int16 *)(v1 + 130);
		*(x_DWORD *)(v2 + 144) = 50;
		*(x_DWORD *)(v2 + 4) = v3;
		BYTE1(v3) = *(x_BYTE *)(v2 + 12);
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&off_D8434;
		*(x_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 216);
		sub_847D0(v2, 128, 9, 0);
	}
	return v2;
}
// D8434: using guessed type void *off_D8434;

//----- (0004D900) --------------------------------------------------------
int sub_4D900(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // eax

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 10;
		*(x_BYTE *)(v1 + 63) = 9;
		*(x_BYTE *)(v1 + 64) = 10;
		*(x_WORD *)(v1 + 130) = 384;
		*(x_WORD *)(v1 + 132) = 384;
		v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
		*(x_DWORD *)(v2 + 144) = 50;
		*(x_DWORD *)(v2 + 4) = v3;
		BYTE1(v3) = *(x_BYTE *)(v2 + 12);
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&off_D83CE;
		*(x_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 18);
	}
	return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004D990) --------------------------------------------------------
int sub_4D990(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // eax

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 11;
		*(x_BYTE *)(v1 + 63) = 9;
		*(x_BYTE *)(v1 + 64) = 11;
		*(x_WORD *)(v1 + 130) = 384;
		*(x_WORD *)(v1 + 132) = 384;
		v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
		*(x_DWORD *)(v2 + 144) = 50;
		*(x_DWORD *)(v2 + 4) = v3;
		BYTE1(v3) = *(x_BYTE *)(v2 + 12);
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&off_D83CE;
		*(x_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 281);
	}
	return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004DA20) --------------------------------------------------------
int sub_4DA20(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // eax

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 12;
		*(x_BYTE *)(v1 + 63) = 9;
		*(x_BYTE *)(v1 + 64) = 12;
		*(x_WORD *)(v1 + 130) = 384;
		*(x_WORD *)(v1 + 132) = 384;
		v3 = 2048 / *(signed __int16 *)(v1 + 130);
		*(x_DWORD *)(v2 + 144) = 50;
		*(x_DWORD *)(v2 + 4) = v3;
		BYTE1(v3) = *(x_BYTE *)(v2 + 12);
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&off_D83CE;
		*(x_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 216);
	}
	return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004DAB0) --------------------------------------------------------
x_WORD *sub_4DAB0(int a1)
{
	int v1; // eax
	x_WORD *v2; // ebx

	v1 = sub_4A050();
	v2 = (x_WORD *)v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 13;
		*(x_BYTE *)(v1 + 63) = 9;
		*(x_BYTE *)(v1 + 64) = 13;
		*(x_WORD *)(v1 + 130) = 384;
		*(x_WORD *)(v1 + 132) = 384;
		*(x_DWORD *)(v1 + 4) = 5120 / *(signed __int16 *)(v1 + 130);
		*(x_BYTE *)(v1 + 12) &= 0xF7u;
		sub_57D70(v1, a1);
		sub_49A20((int)v2);
		sub_49E10(v2, 195);
	}
	return v2;
}

//----- (0004DBC0) --------------------------------------------------------
x_WORD *sub_4DBC0(int a1)
{
	int v1; // eax
	x_WORD *v2; // ebx

	v1 = sub_4A050();
	v2 = (x_WORD *)v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 15;
		*(x_BYTE *)(v1 + 63) = 9;
		*(x_BYTE *)(v1 + 64) = 14;
		*(x_WORD *)(v1 + 130) = 128;
		*(x_WORD *)(v1 + 132) = 128;
		*(x_DWORD *)(v1 + 4) = 4096 / *(signed __int16 *)(v1 + 130);
		*(x_BYTE *)(v1 + 12) &= 0xF7u;
		sub_57D70(v1, a1);
		sub_49A20((int)v2);
		sub_49CD0(v2, 196);
	}
	return v2;
}

//----- (0004DC40) --------------------------------------------------------
x_WORD *sub_4DC40(int a1)
{
	int v1; // eax
	x_WORD *v2; // ebx

	v1 = sub_4A050();
	v2 = (x_WORD *)v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 21;
		*(x_BYTE *)(v1 + 63) = 9;
		*(x_BYTE *)(v1 + 64) = 20;
		*(x_WORD *)(v1 + 130) = 394;
		*(x_WORD *)(v1 + 132) = *(x_WORD *)(v1 + 130);
		*(x_DWORD *)(v1 + 4) = 7680 / *(signed __int16 *)(v1 + 130);
		*(x_BYTE *)(v1 + 12) &= 0xF7u;
		sub_57D70(v1, a1);
		sub_49A20((int)v2);
		sub_49CD0(v2, 196);
	}
	return v2;
}

//----- (0004DCC0) --------------------------------------------------------
x_WORD *sub_4DCC0(int a1)
{
	int v1; // eax
	x_WORD *v2; // ebx

	v1 = sub_4A050();
	v2 = (x_WORD *)v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 22;
		*(x_BYTE *)(v1 + 63) = 9;
		*(x_BYTE *)(v1 + 64) = 21;
		*(x_WORD *)(v1 + 130) = 394;
		*(x_WORD *)(v1 + 132) = *(x_WORD *)(v1 + 130);
		*(x_DWORD *)(v1 + 4) = 7680 / *(signed __int16 *)(v1 + 130);
		*(x_BYTE *)(v1 + 12) &= 0xF7u;
		sub_57D70(v1, a1);
		sub_49A20((int)v2);
		sub_49CD0(v2, 319);
		sub_49EA0(v2, 256, 512);
	}
	return v2;
}

//----- (0004DD50) --------------------------------------------------------
x_WORD *sub_4DD50(int a1)
{
	int v1; // eax
	x_WORD *v2; // ebx

	v1 = sub_4A050();
	v2 = (x_WORD *)v1;
	if (v1)
	{
		*(x_DWORD *)(v1 + 4) = 80;
		*(x_BYTE *)(v1 + 69) = 16;
		*(x_BYTE *)(v1 + 63) = 9;
		*(x_BYTE *)(v1 + 64) = 15;
		*(x_WORD *)(v1 + 130) = 128;
		*(x_WORD *)(v1 + 132) = 128;
		*(x_BYTE *)(v1 + 12) &= 0xF7u;
		sub_57D70(v1, a1);
		sub_49A20((int)v2);
		sub_49CD0(v2, 215);
	}
	return v2;
}

//----- (0004DDD0) --------------------------------------------------------
int sub_4DDD0(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // eax

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 18;
		*(x_BYTE *)(v1 + 63) = 9;
		*(x_BYTE *)(v1 + 64) = 17;
		*(x_WORD *)(v1 + 130) = 384;
		*(x_WORD *)(v1 + 132) = 384;
		v3 = 4096 / *(signed __int16 *)(v1 + 130);
		*(x_DWORD *)(v2 + 144) = 50;
		*(x_DWORD *)(v2 + 4) = v3;
		BYTE1(v3) = *(x_BYTE *)(v2 + 12);
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&unk_D83F0;
		*(x_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 209);
		sub_49EA0((x_WORD *)v2, 2 * *(x_WORD *)(v2 + 84), 2 * *(x_WORD *)(v2 + 88));
	}
	return v2;
}

//----- (0004DEA0) --------------------------------------------------------
int sub_4DEA0(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // eax

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 23;
		*(x_BYTE *)(v1 + 63) = 9;
		*(x_BYTE *)(v1 + 64) = 22;
		*(x_WORD *)(v1 + 130) = 384;
		*(x_WORD *)(v1 + 132) = 384;
		v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
		*(x_DWORD *)(v2 + 144) = 50;
		*(x_DWORD *)(v2 + 4) = v3;
		BYTE1(v3) = *(x_BYTE *)(v2 + 12);
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&off_D83CE;
		*(x_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 211);
	}
	return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004DF30) --------------------------------------------------------
int sub_4DF30(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // eax

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 28;
		*(x_BYTE *)(v1 + 63) = 9;
		*(x_BYTE *)(v1 + 64) = 27;
		*(x_WORD *)(v1 + 130) = 384;
		*(x_WORD *)(v1 + 132) = 384;
		v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
		*(x_DWORD *)(v2 + 144) = 50;
		*(x_DWORD *)(v2 + 4) = v3;
		BYTE1(v3) = *(x_BYTE *)(v2 + 12);
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&off_D83CE;
		*(x_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 215);
	}
	return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004DFC0) --------------------------------------------------------
int sub_4DFC0(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // esi
	int v4; // eax

	v1 = sub_4A050();
	v2 = v1;
	v3 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 24;
		*(x_BYTE *)(v1 + 63) = 9;
		*(x_BYTE *)(v1 + 64) = 23;
		*(x_WORD *)(v1 + 130) = 384;
		*(x_WORD *)(v1 + 132) = 384;
		v4 = 0x2000 / *(signed __int16 *)(v1 + 130);
		*(x_DWORD *)(v2 + 144) = 50;
		*(x_DWORD *)(v2 + 4) = v4;
		BYTE1(v4) = *(x_BYTE *)(v2 + 12);
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&off_D83CE;
		*(x_BYTE *)(v2 + 12) = BYTE1(v4) & 0xF7;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 211);
	}
	return v3;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004E050) --------------------------------------------------------
int sub_4E050(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // eax
	char v4; // dl

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 25;
		*(x_BYTE *)(v1 + 63) = 9;
		*(x_BYTE *)(v1 + 64) = 24;
		*(x_WORD *)(v1 + 130) = 384;
		*(x_WORD *)(v1 + 132) = 384;
		v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
		*(x_DWORD *)(v2 + 144) = 50;
		v4 = *(x_BYTE *)(v2 + 12);
		*(x_DWORD *)(v2 + 4) = v3;
		*(x_BYTE *)(v2 + 12) = v4 & 0xF7;
		BYTE1(v3) = *(x_BYTE *)(v2 + 4);
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&off_D83CE;
		*(x_BYTE *)(v2 + 4) = BYTE1(v3) & 0xFC;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 281);
	}
	return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004E0F0) --------------------------------------------------------
int sub_4E0F0(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // eax

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 26;
		*(x_BYTE *)(v1 + 63) = 9;
		*(x_BYTE *)(v1 + 64) = 25;
		*(x_WORD *)(v1 + 130) = 384;
		*(x_WORD *)(v1 + 132) = 384;
		v3 = 4096 / *(signed __int16 *)(v1 + 130);
		*(x_DWORD *)(v2 + 144) = 50;
		*(x_DWORD *)(v2 + 4) = v3;
		BYTE1(v3) = *(x_BYTE *)(v2 + 12);
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&unk_D83F0;
		*(x_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 321);
	}
	return v2;
}

//----- (0004E180) --------------------------------------------------------
int sub_4E180(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // eax

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 27;
		*(x_BYTE *)(v1 + 63) = 9;
		*(x_BYTE *)(v1 + 64) = 26;
		*(x_WORD *)(v1 + 130) = 384;
		*(x_WORD *)(v1 + 132) = 384;
		v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
		*(x_DWORD *)(v2 + 144) = 50;
		*(x_DWORD *)(v2 + 4) = v3;
		BYTE1(v3) = *(x_BYTE *)(v2 + 12);
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&off_D83CE;
		*(x_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 320);
	}
	return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004E210) --------------------------------------------------------
int sub_4E210(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // eax

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 31;
		*(x_BYTE *)(v1 + 63) = 9;
		*(x_BYTE *)(v1 + 64) = 30;
		*(x_WORD *)(v1 + 130) = 384;
		*(x_WORD *)(v1 + 132) = 384;
		v3 = 0x2000 / *(signed __int16 *)(v1 + 130);
		*(x_DWORD *)(v2 + 144) = 50;
		*(x_DWORD *)(v2 + 4) = v3;
		BYTE1(v3) = *(x_BYTE *)(v2 + 12);
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&off_D83CE;
		*(x_BYTE *)(v2 + 12) = BYTE1(v3) & 0xF7;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 211);
	}
	return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004E2A0) --------------------------------------------------------
int sub_4E2A0(int a1)
{
	int v1; // eax
	int v2; // ebx
	char v3; // ah

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 30;
		*(x_BYTE *)(v1 + 63) = 9;
		*(x_BYTE *)(v1 + 64) = 29;
		*(x_WORD *)(v1 + 130) = 384;
		*(x_WORD *)(v1 + 132) = 384;
		*(x_DWORD *)(v1 + 4) = 10;
		v3 = *(x_BYTE *)(v1 + 12);
		*(x_DWORD *)(v2 + 144) = 50;
		*(x_DWORD *)(v2 + 160) = (x_DWORD)&off_D83CE;
		*(x_BYTE *)(v2 + 12) = v3 & 0xF7;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 66);
	}
	return v2;
}
// D83CE: using guessed type void *off_D83CE;

//----- (0004E320) --------------------------------------------------------
x_WORD *sub_4E320(int a1)
{
	int v1; // eax
	x_WORD *v2; // ebx
	int v3; // edx

	v1 = sub_4A050();
	v2 = (x_WORD *)v1;
	if (v1)
	{
		*(x_DWORD *)(v1 + 4) = 8;
		*(x_BYTE *)(v1 + 69) = 0;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 0;
		*(x_WORD *)(v1 + 42) = 400;
		v3 = *(x_DWORD *)(v1 + 12);
		*(x_BYTE *)(v1 + 56) = 0;
		*(x_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
		*(x_BYTE *)(v1 + 14) |= 2u;
		sub_57D70(v1, a1);
		sub_49A20((int)v2);
		sub_49CD0(v2, 7);
		sub_49EA0(v2, 128, 128);
		sub_847D0((int)v2, 128, 7, 1);
	}
	return v2;
}

//----- (0004E3B0) --------------------------------------------------------
x_WORD *sub_4E3B0(int a1)
{
	int v1; // eax
	x_WORD *v2; // ebx
	int v3; // edx

	v1 = sub_4A050();
	v2 = (x_WORD *)v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 1;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 1;
		*(x_DWORD *)(v1 + 4) = 1;
		v3 = *(x_DWORD *)(v1 + 12);
		*(x_WORD *)(v1 + 42) = 400;
		*(x_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
		*(x_BYTE *)(v1 + 14) |= 2u;
		sub_57D70(v1, a1);
		sub_49A20((int)v2);
		sub_49CD0(v2, 41);
		sub_847D0((int)v2, 128, 7, 1);
	}
	return v2;
}

//----- (0004E430) --------------------------------------------------------
int sub_4E430(int a1)
{
	int v1; // eax
	int v2; // ebx
	unsigned int v3; // edx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_DWORD *)(v1 + 4) = 8;
		*(x_BYTE *)(v1 + 69) = 2;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 2;
		*(x_DWORD *)(v1 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v1 + 80) = *(x_WORD *)(a1 + 4);
		v3 = *(x_DWORD *)(v1 + 12) & 0xFFFDFFF6;
		*(x_DWORD *)(v1 + 16) = 0;
		*(x_DWORD *)(v1 + 12) = v3 | 0x20001;
		sub_49A20(v1);
	}
	return v2;
}

//----- (0004E490) --------------------------------------------------------
int sub_4E490(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // edx
	char v4; // ah

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_DWORD *)(v1 + 4) = 7;
		*(x_BYTE *)(v1 + 69) = 3;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 3;
		v3 = *(x_DWORD *)(v1 + 12);
		*(x_WORD *)(v1 + 42) = 0;
		*(x_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
		v4 = *(x_BYTE *)(v1 + 14) | 2;
		*(x_DWORD *)(v2 + 16) = 0;
		*(x_BYTE *)(v2 + 14) = v4;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 36);
	}
	return v2;
}

//----- (0004E500) --------------------------------------------------------
int sub_4E500(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // edx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_DWORD *)(v1 + 4) = 100;
		*(x_BYTE *)(v1 + 69) = 4;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 4;
		v3 = *(x_DWORD *)(v1 + 12);
		*(x_WORD *)(v1 + 42) = 0;
		*(x_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
		*(x_BYTE *)(v1 + 14) |= 2u;
		*(x_DWORD *)(v1 + 16) = 0;
		*(x_DWORD *)(v1 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v1 + 80) = *(x_WORD *)(a1 + 4);
		*(x_WORD *)(v1 + 80) = sub_10C40((__int16 *)(v1 + 76));
		sub_49A20(v2);
	}
	return v2;
}

//----- (0004E570) --------------------------------------------------------
int sub_4E570(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // edx
	char v4; // ah

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_DWORD *)(v1 + 4) = 8;
		*(x_BYTE *)(v1 + 69) = 5;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 5;
		v3 = *(x_DWORD *)(v1 + 12);
		*(x_WORD *)(v1 + 42) = 0;
		*(x_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
		v4 = *(x_BYTE *)(v1 + 14) | 2;
		*(x_DWORD *)(v2 + 16) = 0;
		*(x_BYTE *)(v2 + 14) = v4;
		sub_57D70(v2, a1);
		*(x_WORD *)(v2 + 80) = sub_10C40((__int16 *)(v2 + 76));
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 244);
	}
	return v2;
}

//----- (0004E5F0) --------------------------------------------------------
int sub_4E5F0(__int16 *a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // edx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 6;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 6;
		*(x_WORD *)(v1 + 42) = 50;
		*(x_DWORD *)(v1 + 4) = 240;
		v3 = *(x_DWORD *)(v1 + 12);
		*(x_WORD *)(v1 + 44) = 0;
		*(x_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
		*(x_BYTE *)(v1 + 14) |= 2u;
		sub_57D70(v1, (int)a1);
		*(x_WORD *)(v2 + 80) = sub_10C40(a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 228);
		sub_49EA0((x_WORD *)v2, 272, 1536);
		*(x_DWORD *)(v2 + 16) = 0;
		sub_847D0(v2, 80, 11, 1);
	}
	return v2;
}

//----- (0004E6A0) --------------------------------------------------------
int sub_4E6A0(__int16 *a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // edx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 7;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 7;
		v3 = *(x_DWORD *)(v1 + 12);
		*(x_DWORD *)(v1 + 4) = 12;
		*(x_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
		LOWORD(v3) = *(x_WORD *)(v1 + 20);
		*(x_BYTE *)(v1 + 14) |= 2u;
		*(x_WORD *)(v1 + 20) = 9377 * v3 + 9439;
		LOWORD(v3) = *(x_WORD *)(v1 + 20) % 0x14u;
		*(x_BYTE *)(v1 + 65) = 10;
		*(x_BYTE *)(v1 + 66) = 7;
		*(x_WORD *)(v1 + 130) = v3 + 20;
		sub_57D70(v1, (int)a1);
		*(x_WORD *)(v2 + 80) = sub_10C40(a1);
		sub_49DA0((x_WORD *)v2, 78);
		sub_49A20(v2);
		*(x_BYTE *)(v2 + 12) |= 1u;
	}
	return v2;
}

//----- (0004E760) --------------------------------------------------------
int sub_4E760(int a1)
{
	int v1; // eax
	int v2; // ebx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 9;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 9;
		*(x_DWORD *)(v1 + 4) = 11;
		*(x_DWORD *)(v1 + 8) = 17;
		*(x_DWORD *)(v1 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v1 + 80) = *(x_WORD *)(a1 + 4);
		*(x_WORD *)(v1 + 42) = 2000;
		*(x_BYTE *)(v1 + 12) &= 0xF7u;
		sub_49EA0((x_WORD *)v1, 7, 0x4000);
		*(0x36E03 + x_D41A0_BYTEARRAY_0) = 0;
	}
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004E7D0) --------------------------------------------------------
x_WORD *sub_4E7D0(int a1)
{
	int v1; // eax
	x_WORD *v2; // ebx
	int v3; // edx

	v1 = sub_4A050();
	v2 = (x_WORD *)v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 10;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 10;
		*(x_DWORD *)(v1 + 4) = 1;
		*(x_DWORD *)(v1 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v1 + 80) = *(x_WORD *)(a1 + 4);
		v3 = *(x_DWORD *)(v1 + 12);
		*(x_WORD *)(v1 + 42) = 100;
		*(x_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
		*(x_BYTE *)(v1 + 14) |= 2u;
		sub_49A20(v1);
		sub_49EA0(v2, 128, 128);
	}
	return v2;
}

//----- (0004E840) --------------------------------------------------------
int sub_4E840(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // edx
	char v4; // ah

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 11;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 11;
		*(x_DWORD *)(v1 + 4) = 40;
		*(x_DWORD *)(v1 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v1 + 80) = *(x_WORD *)(a1 + 4);
		v3 = *(x_DWORD *)(v1 + 12);
		*(x_WORD *)(v1 + 42) = 200;
		*(x_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
		v4 = *(x_BYTE *)(v1 + 14) | 2;
		*(x_WORD *)(v2 + 38) = 11;
		*(x_BYTE *)(v2 + 14) = v4;
		sub_49A20(v2);
		sub_49EA0((x_WORD *)v2, 2304, 0x2000);
	}
	return v2;
}

//----- (0004E8C0) --------------------------------------------------------
int sub_4E8C0(int a1)
{
	int v1; // eax
	int v2; // ebx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 12;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 12;
		*(x_DWORD *)(v1 + 4) = 8;
		*(x_DWORD *)(v1 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v1 + 80) = *(x_WORD *)(a1 + 4);
		*(x_WORD *)(v1 + 42) = -1536;
		*(x_BYTE *)(v1 + 12) = *(x_BYTE *)(v1 + 12) & 0xF6 | 1;
		sub_57D70(v1, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 41);
		*(x_BYTE *)(v2 + 12) |= 1u;
		sub_49EA0((x_WORD *)v2, 512, 512);
	}
	return v2;
}

//----- (0004E950) --------------------------------------------------------
int sub_4E950(int a1)
{
	int v1; // eax
	int v2; // ebx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 77;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 70;
		*(x_DWORD *)(v1 + 4) = 8;
		*(x_DWORD *)(v1 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v1 + 80) = *(x_WORD *)(a1 + 4);
		*(x_WORD *)(v1 + 42) = -1536;
		*(x_BYTE *)(v1 + 12) = *(x_BYTE *)(v1 + 12) & 0xF6 | 1;
		sub_57D70(v1, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 41);
		*(x_BYTE *)(v2 + 12) |= 1u;
		sub_49EA0((x_WORD *)v2, 512, 512);
	}
	return v2;
}

//----- (0004E9E0) --------------------------------------------------------
int sub_4E9E0(int a1)
{
	int v1; // eax

	v1 = (int)x_D41A0_BYTEARRAY_0;
	*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8) = 9377 * *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8) + 9439;
	return sub_4EAA0(a1, 13, 13, 67, *(x_DWORD *)(v1 + 8) % 0x17u + 17);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004EA20) --------------------------------------------------------
int sub_4EA20(int a1)
{
	int v1; // eax

	v1 = (int)x_D41A0_BYTEARRAY_0;
	*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8) = 9377 * *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8) + 9439;
	return sub_4EAA0(a1, 14, 14, 9, *(x_DWORD *)(v1 + 8) % 0x21u + 28);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004EA60) --------------------------------------------------------
int sub_4EA60(int a1)
{
	int v1; // eax

	v1 = (int)x_D41A0_BYTEARRAY_0;
	*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8) = 9377 * *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8) + 9439;
	return sub_4EAA0(a1, 87, 94, 67, *(x_DWORD *)(v1 + 8) % 0x17u + 17);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004EAA0) --------------------------------------------------------
int sub_4EAA0(int a1, char a2, char a3, __int16 a4, int a5)
{
	int v5; // eax
	int v6; // ebx
	unsigned int v7; // edx
	unsigned __int64 v8; // rt2
	char v9; // ah

	v5 = sub_4A050();
	v6 = v5;
	if (v5)
	{
		v7 = *(x_DWORD *)(v5 + 12) & 0xFFFDFFF7;
		*(x_BYTE *)(v5 + 69) = a3;
		*(x_DWORD *)(v5 + 12) = v7;
		*(x_BYTE *)(v5 + 64) = a2;
		LOWORD(v7) = *(x_WORD *)(v5 + 20);
		*(x_DWORD *)(v5 + 4) = a5;
		*(x_WORD *)(v5 + 20) = 9377 * v7 + 9439;
		v8 = *(unsigned __int16 *)(v5 + 20);
		*(x_BYTE *)(v5 + 63) = 10;
		*(x_WORD *)(v5 + 134) = 30;
		*(x_BYTE *)(v5 + 65) = 10;
		*(x_BYTE *)(v5 + 66) = a2;
		v9 = *(x_BYTE *)(v5 + 14);
		*(x_WORD *)(v6 + 130) = v8 % 0x35 + 51;
		*(x_BYTE *)(v6 + 14) = v9 | 2;
		sub_57D70(v6, a1);
		sub_49DA0((x_WORD *)v6, a4);
		sub_49A20(v6);
	}
	return v6;
}

//----- (0004EB50) --------------------------------------------------------
int sub_4EB50(int a1)
{
	int v1; // eax
	int v2; // ebx
	__int16 v3; // dx
	__int16 v4; // cx
	char v5; // ah

	if (sub_4A810() < 32)
		return 0;
	v1 = sub_4A050();
	v2 = v1;
	if (!v1)
		return 0;
	*(x_BYTE *)(v1 + 69) = 64;
	*(x_BYTE *)(v1 + 63) = 10;
	v3 = *(x_WORD *)(v1 + 20);
	*(x_BYTE *)(v1 + 64) = 59;
	*(x_WORD *)(v1 + 20) = 9377 * v3 + 9439;
	v4 = *(x_WORD *)(v1 + 20);
	v5 = *(x_BYTE *)(v1 + 12) & 0xF6;
	*(x_DWORD *)(v2 + 4) = *(unsigned __int16 *)(v2 + 20) % 0x64u + 800;
	*(x_BYTE *)(v2 + 12) = v5 | 1;
	*(x_WORD *)(v2 + 20) = 9377 * v4 + 9439;
	*(x_WORD *)(v2 + 130) = *(x_WORD *)(v2 + 20) % 0x11u;
	*(x_DWORD *)(v2 + 76) = *(x_DWORD *)a1;
	*(x_WORD *)(v2 + 80) = *(x_WORD *)(a1 + 4);
	sub_49A20(v2);
	return v2;
}

//----- (0004EC10) --------------------------------------------------------
int sub_4EC10(int a1)
{
	int v1; // eax
	int v2; // ebx
	__int16 v3; // dx
	__int16 v4; // cx
	char v5; // ah

	if (sub_4A810() < 32)
		return 0;
	v1 = sub_4A050();
	v2 = v1;
	if (!v1)
		return 0;
	*(x_BYTE *)(v1 + 69) = 65;
	*(x_BYTE *)(v1 + 63) = 10;
	v3 = *(x_WORD *)(v1 + 20);
	*(x_BYTE *)(v1 + 64) = 60;
	*(x_WORD *)(v1 + 20) = 9377 * v3 + 9439;
	v4 = *(x_WORD *)(v1 + 20);
	v5 = *(x_BYTE *)(v1 + 12) & 0xF6;
	*(x_DWORD *)(v2 + 4) = *(unsigned __int16 *)(v2 + 20) % 0x64u + 800;
	*(x_BYTE *)(v2 + 12) = v5 | 1;
	*(x_WORD *)(v2 + 20) = 9377 * v4 + 9439;
	*(x_WORD *)(v2 + 130) = *(x_WORD *)(v2 + 20) % 0x11u;
	*(x_DWORD *)(v2 + 76) = *(x_DWORD *)a1;
	*(x_WORD *)(v2 + 80) = *(x_WORD *)(a1 + 4);
	sub_49A20(v2);
	return v2;
}

//----- (0004ECD0) --------------------------------------------------------
int sub_4ECD0(int a1)
{
	int v1; // eax
	int v2; // ebx
	__int16 v3; // dx
	__int16 v4; // ax

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 15;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 15;
		*(x_DWORD *)(v1 + 4) = 128;
		*(x_WORD *)(v1 + 130) = 256;
		v3 = *(x_WORD *)(v1 + 20);
		*(x_BYTE *)(v1 + 12) &= 0xF7u;
		*(x_WORD *)(v1 + 42) = 100;
		*(x_WORD *)(v1 + 20) = 9377 * v3 + 9439;
		v4 = *(x_WORD *)(v1 + 20);
		*(x_DWORD *)(v2 + 16) = 0;
		*(x_WORD *)(v2 + 28) = v4 & 0x7FF;
		*(x_DWORD *)(v2 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v2 + 80) = *(x_WORD *)(a1 + 4);
		sub_49A20(v2);
		sub_49EA0((x_WORD *)v2, 1024, 0x4000);
	}
	return v2;
}

//----- (0004ED70) --------------------------------------------------------
int sub_4ED70(int a1)
{
	int v1; // eax
	int v2; // ebx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 17;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 17;
		*(x_DWORD *)(v1 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v1 + 80) = *(x_WORD *)(a1 + 4);
		*(x_DWORD *)(v1 + 4) = 10;
		*(x_WORD *)(v1 + 42) = 3000;
		*(x_BYTE *)(v1 + 12) &= 0xF7u;
		sub_49A20(v1);
	}
	return v2;
}

//----- (0004EDC0) --------------------------------------------------------
int sub_4EDC0(__int16 *a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // edx
	__int16 v4; // ax
	__int16 v5; // ax

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 16;
		*(x_BYTE *)(v1 + 63) = 10;
		v3 = *(x_DWORD *)(v1 + 12);
		*(x_BYTE *)(v1 + 64) = 16;
		*(x_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
		LOWORD(v3) = *(x_WORD *)(v1 + 20);
		*(x_WORD *)(v1 + 42) = 200;
		*(x_WORD *)(v1 + 20) = 9377 * v3 + 9439;
		v4 = 9377 * *(x_WORD *)(v1 + 20);
		*(x_DWORD *)(v2 + 4) = *(unsigned __int16 *)(v2 + 20) % 0x64u + 100;
		*(x_WORD *)(v2 + 20) = v4 + 9439;
		LOWORD(v3) = *(x_WORD *)(v2 + 20) % 0x32u;
		*(x_WORD *)(v2 + 20) = 9377 * *(x_WORD *)(v2 + 20) + 9439;
		v5 = *(x_WORD *)(v2 + 20);
		*(x_WORD *)(v2 + 44) = 256;
		*(x_WORD *)(v2 + 28) = v5 & 0x7FF;
		HIBYTE(v5) = *(x_BYTE *)(v2 + 14);
		*(x_WORD *)(v2 + 130) = v3 + 52;
		*(x_BYTE *)(v2 + 14) = HIBYTE(v5) | 2;
		sub_57D70(v2, (int)a1);
		*(x_WORD *)(v2 + 80) = sub_10C40(a1) + 64;
		sub_57FA0((x_WORD *)(v2 + 154), *(x_WORD *)(v2 + 28), 0, *(x_WORD *)(v2 + 130));
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 210);
	}
	return v2;
}

//----- (0004EED0) --------------------------------------------------------
int sub_4EED0(int a1)
{
	int v1; // eax
	int v2; // ebx
	char v3; // ah

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 18;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 18;
		*(x_WORD *)(v1 + 42) = 200;
		v3 = *(x_BYTE *)(v1 + 12);
		*(x_DWORD *)(v2 + 16) = 0;
		*(x_DWORD *)(v2 + 4) = 10000;
		*(x_BYTE *)(v2 + 12) = v3 & 0xF7;
		*(x_DWORD *)(v2 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v2 + 80) = *(x_WORD *)(a1 + 4);
		sub_49A20(v2);
	}
	return v2;
}

//----- (0004EF30) --------------------------------------------------------
int sub_4EF30(int a1)
{
	int v1; // eax
	int v2; // ebx
	char v3; // ah

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 98;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 91;
		*(x_WORD *)(v1 + 42) = 200;
		v3 = *(x_BYTE *)(v1 + 12);
		*(x_DWORD *)(v2 + 16) = 0;
		v3 &= 0xF6u;
		*(x_DWORD *)(v2 + 4) = 10000;
		*(x_BYTE *)(v2 + 12) = v3;
		*(x_BYTE *)(v2 + 12) = v3 | 1;
		*(x_DWORD *)(v2 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v2 + 80) = *(x_WORD *)(a1 + 4);
		sub_49A20(v2);
	}
	return v2;
}

//----- (0004EF90) --------------------------------------------------------
int sub_4EF90(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // edx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 19;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 19;
		*(x_WORD *)(v1 + 42) = 200;
		v3 = *(x_DWORD *)(v1 + 12);
		*(x_DWORD *)(v1 + 4) = 240;
		*(x_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
		*(x_BYTE *)(v1 + 14) |= 2u;
		sub_57D70(v1, a1);
		*(x_BYTE *)(v2 + 12) |= 1u;
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 228);
		sub_49EA0((x_WORD *)v2, 512, 512);
	}
	return v2;
}

//----- (0004F040) --------------------------------------------------------
x_WORD *sub_4F040(int a1)
{
	int v1; // eax
	int v2; // ebx
	__int16 v3; // dx
	__int16 v4; // ax
	__int16 v5; // ax
	int v6; // eax
	int v7; // ecx
	int v9; // [esp+0h] [ebp-10h]
	int v10; // [esp+4h] [ebp-Ch]
	x_WORD *v11; // [esp+8h] [ebp-8h]
	signed int i; // [esp+Ch] [ebp-4h]

	if (sub_4A810() < 12)
		return 0;
	v1 = sub_4A050();
	v2 = v1;
	v11 = (x_WORD *)v1;
	if (!v1)
		return 0;
	*(x_BYTE *)(v1 + 69) = 22;
	*(x_BYTE *)(v1 + 63) = 10;
	*(x_BYTE *)(v1 + 64) = 22;
	*(x_WORD *)(v1 + 44) = 0;
	*(x_WORD *)(v1 + 46) = 1;
	*(x_BYTE *)(v1 + 60) = 0;
	*(x_WORD *)(v1 + 132) = 20;
	*(x_WORD *)(v1 + 134) = 10;
	*(x_WORD *)(v1 + 130) = 50;
	*(x_DWORD *)(v1 + 4) = 500;
	*(x_WORD *)(v1 + 42) = 1000;
	v3 = *(x_WORD *)(v1 + 20);
	*(x_BYTE *)(v1 + 12) &= 0xF7u;
	*(x_WORD *)(v1 + 20) = 9377 * v3 + 9439;
	v4 = *(x_WORD *)(v1 + 20);
	*(x_WORD *)(v2 + 34) = 0;
	*(x_BYTE *)(v2 + 56) = 1;
	v5 = (v4 & 0x7FF) - 1;
	*(x_WORD *)(v2 + 32) = v5;
	*(x_WORD *)(v2 + 28) = v5;
	v10 = v2;
	*(x_WORD *)(v2 + 30) = *(x_WORD *)(v2 + 32);
	sub_49A20(v2);
	for (i = 0; i < 11; i++)
	{
		v6 = sub_4A050();
		v9 = v6;
		if (v6)
		{
			qmemcpy((void *)v6, v11, 0xA8u);
			*(x_BYTE *)(v6 + 64) = 75;
			v7 = (int)x_D41A0_BYTEARRAY_0;
			*(x_BYTE *)(v6 + 69) = 82;
			v7 += 28302;
			*(x_WORD *)(v6 + 44) = i + 1;
			*(x_WORD *)(v6 + 50) = (v10 - v7) / 168;
			*(x_WORD *)(v10 + 52) = (v6 - v7) / 168;
			*(x_WORD *)(v6 + 52) = 0;
			*(x_BYTE *)(v6 + 62) = i;
			sub_57D70(v6, a1);
		}
		v10 = v9;
	}
	sub_57D70((int)v11, a1);
	sub_4F1C0(v11);
	return v11;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004F1C0) --------------------------------------------------------
unsigned __int16 sub_4F1C0(x_WORD *a1)
{
	x_WORD *v1; // ebx
	int v2; // esi
	unsigned __int16 result; // ax
	int v4; // ecx
	unsigned __int16 v5; // di
	int v6; // ST0C_4
	int v7; // edi
	unsigned __int16 i; // [esp+4h] [ebp-8h]

	v1 = a1;
	v2 = 0;
	result = sub_10C40(a1 + 38);
	for (i = result; (unsigned int)v1 > x_DWORD_EA3E4[0]; v1 = (x_WORD *)x_DWORD_EA3E4[result])
	{
		v4 = (signed __int16)v1[22] + 293;
		v5 = x_WORD_D9524[7 * v4];
		v6 = 550 * v5 / 1000;
		v7 = 450 * v5 / 1000;
		sub_49CD0(v1, v4);
		sub_49EA0(v1, v6, v7);
		v1[40] = v2 + i;
		result = v1[26];
		v1[27] = v2;
		v2 += 2 * v7;
	}
	return result;
}
// D9524: using guessed type __int16 x_WORD_D9524[];
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0004F2A0) --------------------------------------------------------
x_WORD *sub_4F2A0(int a1)
{
	int v1; // eax
	int v2; // ebx
	char v3; // ah
	int v4; // eax
	int v5; // ecx
	int v7; // [esp+0h] [ebp-10h]
	int v8; // [esp+4h] [ebp-Ch]
	signed int i; // [esp+8h] [ebp-8h]
	x_WORD *v10; // [esp+Ch] [ebp-4h]

	v10 = 0;
	if (sub_4A810() >= 26)
	{
		v1 = sub_4A050();
		v2 = v1;
		v10 = (x_WORD *)v1;
		if (v1)
		{
			*(x_BYTE *)(v1 + 69) = 83;
			*(x_BYTE *)(v1 + 63) = 10;
			*(x_BYTE *)(v1 + 64) = 76;
			*(x_DWORD *)(v1 + 4) = 80;
			*(x_WORD *)(v1 + 42) = 70;
			*(x_WORD *)(v1 + 130) = 40;
			*(x_WORD *)(v1 + 134) = 192;
			*(x_WORD *)(v1 + 132) = 480;
			*(x_WORD *)(v1 + 130) = 40;
			v3 = *(x_BYTE *)(v1 + 12);
			*(x_BYTE *)(v2 + 56) = 1;
			*(x_BYTE *)(v2 + 67) = 0;
			*(x_BYTE *)(v2 + 68) = 0;
			*(x_WORD *)(v2 + 44) = 0;
			*(x_BYTE *)(v2 + 61) = 0;
			v8 = v2;
			*(x_BYTE *)(v2 + 12) = v3 & 0xF6 | 1;
			sub_49A20(v2);
			for (i = 0; i < 25; i++)
			{
				v4 = sub_4A050();
				v7 = v4;
				if (v4)
				{
					qmemcpy((void *)v4, v10, 0xA8u);
					v5 = (int)x_D41A0_BYTEARRAY_0 + 28302;
					*(x_BYTE *)(v4 + 64) = 77;
					*(x_BYTE *)(v4 + 69) = 84;
					*(x_WORD *)(v4 + 50) = (v8 - v5) / 168;
					*(x_WORD *)(v8 + 52) = (v4 - v5) / 168;
					*(x_BYTE *)(v4 + 62) = i;
					*(x_BYTE *)(v4 + 67) = i / 5;
					*(x_WORD *)(v4 + 52) = 0;
					*(x_BYTE *)(v4 + 68) = i % 5;
					sub_57D70(v4, a1);
				}
				v8 = v7;
			}
			sub_57D70((int)v10, a1);
			sub_49EA0(v10, 640, 640);
			sub_4F440((int)v10);
		}
	}
	return v10;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0004F440) --------------------------------------------------------
__int16 sub_4F440(int a1)
{
	unsigned __int16 v1; // ax
	int v2; // eax
	char v3; // ah
	char v4; // dl
	char v5; // cl
	__int16 v6; // ax
	int v7; // edx
	int v8; // edx
	__int16 v9; // dx
	signed __int16 v10; // cx
	__int16 v11; // dx
	__int16 v12; // dx
	unsigned int v13; // ebx

	v1 = *(x_WORD *)(a1 + 134);
	*(x_BYTE *)(a1 + 61) = 18;
	*(x_WORD *)(a1 + 44) = v1;
	*(x_WORD *)(a1 + 28) = 0;
	v2 = v1;
	LOWORD(v2) = *(x_WORD *)(a1 + 52);
	*(x_WORD *)(a1 + 30) = 0;
	while (1)
	{
		v13 = x_DWORD_EA3E4[v2];
		if (v13 <= x_DWORD_EA3E4[0])
			return v2;
		v3 = *(x_BYTE *)(v13 + 12) & 0xFE;
		v4 = *(x_BYTE *)(v13 + 68);
		*(x_BYTE *)(v13 + 12) = v3;
		if (v4)
		{
			v5 = *(x_BYTE *)(v13 + 12) & 0xF7;
			*(x_BYTE *)(v13 + 14) |= 0x80u;
			*(x_BYTE *)(v13 + 12) = v5;
		}
		else
		{
			*(x_BYTE *)(v13 + 12) = v3 | 8;
		}
		*(x_WORD *)(v13 + 20) = 9377 * *(x_WORD *)(v13 + 20) + 9439;
		v6 = (*(x_WORD *)(v13 + 20) & 0x3F) + 84;
		v7 = *(unsigned __int8 *)(v13 + 67);
		switch ((x_BYTE)v7)
		{
		case 0:
			LOWORD(v7) = *(char *)(v13 + 68);
			*(x_WORD *)(v13 + 30) = 0;
			*(x_WORD *)(v13 + 34) = 0;
			v8 = 512 - 96 * v7;
			*(x_WORD *)(v13 + 32) = v6;
			BYTE1(v8) &= 7u;
			*(x_WORD *)(v13 + 28) = v8;
			break;
		case 1:
			v9 = 96 * *(char *)(v13 + 68);
			v10 = 512;
			*(x_WORD *)(v13 + 28) = 512;
			goto LABEL_11;
		case 2:
			v11 = *(char *)(v13 + 68);
			*(x_WORD *)(v13 + 28) = 0;
			*(x_WORD *)(v13 + 32) = 0;
			v12 = -96 * v11;
			goto LABEL_12;
		case 3:
			v9 = 96 * *(char *)(v13 + 68);
			v10 = 256;
			*(x_WORD *)(v13 + 28) = 256;
			goto LABEL_11;
		case 4:
			v9 = 96 * *(char *)(v13 + 68);
			v10 = 768;
			*(x_WORD *)(v13 + 28) = 768;
		LABEL_11:
			*(x_WORD *)(v13 + 32) = 0;
			v12 = v10 - v9;
		LABEL_12:
			*(x_WORD *)(v13 + 34) = v6;
			HIBYTE(v12) &= 7u;
			*(x_WORD *)(v13 + 30) = v12;
			break;
		default:
			break;
		}
		*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
		*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
		sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(v13 + 28), *(x_WORD *)(v13 + 30), *(x_WORD *)(a1 + 44));
		sub_57CF0(v13, (int)&x_WORD_EB398);
		sub_49CD0((x_WORD *)v13, 340);
		sub_847D0(v13, 128, 1, 0);
		v2 = *(unsigned __int16 *)(v13 + 52);
	}
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;

//----- (0004F5F0) --------------------------------------------------------
int sub_4F5F0(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // edx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_DWORD *)(v1 + 4) = 8;
		*(x_BYTE *)(v1 + 69) = 23;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 23;
		v3 = *(x_DWORD *)(v1 + 12);
		*(x_WORD *)(v1 + 42) = 25;
		*(x_DWORD *)(v1 + 12) = v3 & 0xFFFDFFF7;
		*(x_BYTE *)(v1 + 14) |= 2u;
		sub_57D70(v1, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 7);
		sub_49EA0((x_WORD *)v2, 200, 200);
		*(x_BYTE *)(v2 + 12) |= 1u;
		sub_847D0(v2, 128, 9, 0);
	}
	return v2;
}

//----- (0004F6A0) --------------------------------------------------------
x_WORD *sub_4F6A0(int a1)
{
	int v1; // eax
	x_WORD *v2; // ebx

	v1 = sub_4A050();
	v2 = (x_WORD *)v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 25;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 25;
		*(x_DWORD *)(v1 + 4) = 8;
		*(x_DWORD *)(v1 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v1 + 80) = *(x_WORD *)(a1 + 4);
		*(x_WORD *)(v1 + 42) = 2000;
		*(x_BYTE *)(v1 + 12) = *(x_BYTE *)(v1 + 12) & 0xF6 | 1;
		sub_57D70(v1, a1);
		sub_49A20((int)v2);
		sub_49EA0(v2, 512, 512);
	}
	return v2;
}

//----- (0004F720) --------------------------------------------------------
x_WORD *sub_4F720(int a1)
{
	int v1; // eax
	x_WORD *v2; // ebx

	v1 = sub_4A050();
	v2 = (x_WORD *)v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 26;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 26;
		*(x_DWORD *)(v1 + 4) = 8;
		*(x_DWORD *)(v1 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v1 + 80) = *(x_WORD *)(a1 + 4);
		*(x_WORD *)(v1 + 42) = 200;
		*(x_BYTE *)(v1 + 12) &= 0xF7u;
		sub_57D70(v1, a1);
		sub_49A20((int)v2);
		sub_49CD0(v2, 213);
		sub_49EA0(v2, 512, 512);
	}
	return v2;
}

//----- (0004F7A0) --------------------------------------------------------
int sub_4F7A0(int a1)
{
	int v1; // eax
	int v2; // ebx
	char v3; // ah

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_DWORD *)(v1 + 4) = 2;
		*(x_BYTE *)(v1 + 69) = 27;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 27;
		*(x_WORD *)(v1 + 42) = (*(x_WORD *)(a1 + 4) >> 5) + 48;
		v3 = *(x_BYTE *)(v1 + 12);
		*(x_DWORD *)(v2 + 16) = 10;
		*(x_BYTE *)(v2 + 12) = v3 & 0xF7;
		sub_57D70(v2, a1);
		sub_49A20(v2);
	}
	return v2;
}

//----- (0004F800) --------------------------------------------------------
int sub_4F800(int a1)
{
	int v1; // eax
	int v2; // ebx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_DWORD *)(v1 + 4) = 0;
		*(x_BYTE *)(v1 + 69) = 30;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 28;
		*(x_DWORD *)(v1 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v1 + 80) = *(x_WORD *)(a1 + 4);
		*(x_BYTE *)(v1 + 12) &= 0xF7u;
		sub_57D70(v1, a1);
		sub_49A20(v2);
	}
	return v2;
}

//----- (0004F860) --------------------------------------------------------
int sub_4F860(int a1)
{
	int v1; // eax
	int v2; // ebx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_DWORD *)(v1 + 4) = 52;
		*(x_BYTE *)(v1 + 69) = 66;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 61;
		*(x_BYTE *)(v1 + 12) = *(x_BYTE *)(v1 + 12) & 0xF6 | 1;
		sub_57D70(v1, a1);
		sub_49A20(v2);
	}
	return v2;
}

//----- (0004F8B0) --------------------------------------------------------
int sub_4F8B0(int a1)
{
	int v1; // eax
	int v2; // ebx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_DWORD *)(v1 + 4) = 52;
		*(x_BYTE *)(v1 + 69) = 67;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 62;
		*(x_BYTE *)(v1 + 12) = *(x_BYTE *)(v1 + 12) & 0xF6 | 1;
		sub_57D70(v1, a1);
		sub_49A20(v2);
	}
	return v2;
}

//----- (0004F900) --------------------------------------------------------
int sub_4F900(int a1)
{
	int v1; // eax
	int v2; // ebx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_DWORD *)(v1 + 4) = 1;
		*(x_BYTE *)(v1 + 69) = 68;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 63;
		*(x_BYTE *)(v1 + 12) = *(x_BYTE *)(v1 + 12) & 0xF6 | 1;
		sub_57D70(v1, a1);
		sub_49A20(v2);
	}
	return v2;
}

//----- (0004F950) --------------------------------------------------------
int sub_4F950(int a1)
{
	int v1; // eax
	int v2; // ebx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_DWORD *)(v1 + 4) = 1;
		*(x_BYTE *)(v1 + 69) = 69;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 64;
		*(x_BYTE *)(v1 + 12) = *(x_BYTE *)(v1 + 12) & 0xF6 | 1;
		sub_57D70(v1, a1);
		sub_49A20(v2);
	}
	return v2;
}

//----- (0004F9A0) --------------------------------------------------------
int sub_4F9A0(int a1)
{
	int v1; // eax
	int v2; // ebx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_DWORD *)(v1 + 4) = 0;
		*(x_BYTE *)(v1 + 69) = 32;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 30;
		*(x_DWORD *)(v1 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v1 + 80) = *(x_WORD *)(a1 + 4);
		*(x_BYTE *)(v1 + 12) &= 0xF7u;
		sub_57D70(v1, a1);
		sub_49A20(v2);
	}
	return v2;
}

//----- (0004FA00) --------------------------------------------------------
int sub_4FA00(int a1)
{
	int v1; // eax
	int v2; // ebx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_DWORD *)(v1 + 4) = 0;
		*(x_BYTE *)(v1 + 69) = 31;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 29;
		*(x_DWORD *)(v1 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v1 + 80) = *(x_WORD *)(a1 + 4);
		*(x_BYTE *)(v1 + 12) &= 0xF7u;
		sub_57D70(v1, a1);
		sub_49A20(v2);
	}
	return v2;
}

//----- (0004FA60) --------------------------------------------------------
int sub_4FA60(int a1)
{
	int v1; // eax
	int v2; // ebx
	char v3; // ah

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_DWORD *)(v1 + 4) = 0;
		*(x_BYTE *)(v1 + 69) = 34;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 32;
		*(x_DWORD *)(v1 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v1 + 80) = *(x_WORD *)(a1 + 4);
		v3 = *(x_BYTE *)(v1 + 12);
		*(x_WORD *)(v2 + 130) = 256;
		*(x_BYTE *)(v2 + 70) = 2;
		*(x_BYTE *)(v2 + 12) = v3 & 0xF7;
		sub_49A20(v2);
	}
	return v2;
}

//----- (0004FAC0) --------------------------------------------------------
int sub_4FAC0(int a1)
{
	int v1; // eax
	int v2; // ebx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_DWORD *)(v1 + 4) = 0;
		*(x_BYTE *)(v1 + 69) = 33;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 31;
		*(x_DWORD *)(v1 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v1 + 80) = *(x_WORD *)(a1 + 4);
		*(x_BYTE *)(v1 + 12) &= 0xF7u;
		sub_57D70(v1, a1);
		sub_49A20(v2);
	}
	return v2;
}

//----- (0004FB20) --------------------------------------------------------
int sub_4FB20(int a1)
{
	int v1; // eax
	int v2; // ebx
	char v3; // dl

	if (!x_BYTE_D41B6)
		return 0;
	v1 = sub_4A050();
	v2 = v1;
	if (!v1)
		return 0;
	*(x_DWORD *)(v1 + 4) = 0;
	*(x_BYTE *)(v1 + 69) = 88;
	*(x_BYTE *)(v1 + 63) = 10;
	*(x_BYTE *)(v1 + 64) = 81;
	*(x_DWORD *)(v1 + 76) = *(x_DWORD *)a1;
	*(x_WORD *)(v1 + 80) = *(x_WORD *)(a1 + 4);
	*(x_WORD *)(v1 + 130) = 256;
	v3 = *(x_BYTE *)(v1 + 12);
	*(x_BYTE *)(v1 + 70) = 2;
	*(x_BYTE *)(v1 + 12) = v3 & 0xF7;
	sub_49A20(v1);
	return v2;
}
// D41B6: using guessed type char x_BYTE_D41B6;

//----- (0004FB80) --------------------------------------------------------
int sub_4FB80(int a1)
{
	int v1; // eax
	int v2; // ebx

	if (!x_BYTE_D41B6)
		return 0;
	v1 = sub_4A050();
	v2 = v1;
	if (!v1)
		return 0;
	*(x_DWORD *)(v1 + 4) = 0;
	*(x_BYTE *)(v1 + 69) = 87;
	*(x_BYTE *)(v1 + 63) = 10;
	*(x_BYTE *)(v1 + 64) = 80;
	*(x_DWORD *)(v1 + 76) = *(x_DWORD *)a1;
	*(x_WORD *)(v1 + 80) = *(x_WORD *)(a1 + 4);
	*(x_BYTE *)(v1 + 12) &= 0xF7u;
	sub_57D70(v1, a1);
	sub_49A20(v2);
	return v2;
}
// D41B6: using guessed type char x_BYTE_D41B6;

//----- (0004FBE0) --------------------------------------------------------
int sub_4FBE0(int a1)
{
	int result; // eax

	if (!x_BYTE_D41B6)
		return 0;
	result = sub_4A050();
	if (!result)
		return 0;
	*(x_DWORD *)(result + 4) = 0;
	*(x_BYTE *)(result + 69) = 89;
	*(x_BYTE *)(result + 63) = 10;
	*(x_BYTE *)(result + 64) = 82;
	*(x_DWORD *)(result + 76) = *(x_DWORD *)a1;
	*(x_WORD *)(result + 80) = *(x_WORD *)(a1 + 4);
	*(x_BYTE *)(result + 70) = 2;
	*(x_BYTE *)(result + 67) = 3;
	*(x_BYTE *)(result + 68) = 3;
	return result;
}
// D41B6: using guessed type char x_BYTE_D41B6;

//----- (0004FC30) --------------------------------------------------------
int sub_4FC30(int a1)
{
	int result; // eax
	char v2; // dl

	if (!x_BYTE_D41B6)
		return 0;
	result = sub_4A050();
	if (!result)
		return 0;
	*(x_DWORD *)(result + 8) = 16;
	*(x_BYTE *)(result + 69) = 90;
	*(x_BYTE *)(result + 63) = 10;
	*(x_BYTE *)(result + 64) = 83;
	*(x_DWORD *)(result + 76) = *(x_DWORD *)a1;
	*(x_WORD *)(result + 80) = *(x_WORD *)(a1 + 4);
	*(x_BYTE *)(result + 70) = 0;
	*(x_WORD *)(result + 154) = 2;
	v2 = *(x_BYTE *)(result + 12);
	*(x_WORD *)(result + 158) = 0;
	v2 |= 1u;
	*(x_BYTE *)(result + 12) = v2;
	*(x_WORD *)(result + 80) = 0;
	*(x_BYTE *)(result + 12) = v2 & 0xF7;
	return result;
}
// D41B6: using guessed type char x_BYTE_D41B6;

//----- (0004FCA0) --------------------------------------------------------
int sub_4FCA0(int a1)
{
	int result; // eax

	result = sub_4FD00(a1);
	if (result)
	{
		*(x_BYTE *)(result + 69) = 91;
		*(x_BYTE *)(result + 64) = 84;
	}
	return result;
}

//----- (0004FCD0) --------------------------------------------------------
int sub_4FCD0(int a1)
{
	int result; // eax

	result = sub_4FD00(a1);
	if (result)
	{
		*(x_BYTE *)(result + 69) = 92;
		*(x_BYTE *)(result + 64) = 85;
	}
	return result;
}

//----- (0004FD00) --------------------------------------------------------
int sub_4FD00(int a1)
{
	int v1; // edx
	int v2; // eax
	char v3; // bl

	v1 = 0;
	if (x_BYTE_D41B6)
	{
		v2 = sub_4A050();
		v1 = v2;
		if (v2)
		{
			*(x_DWORD *)(v2 + 8) = 16;
			*(x_BYTE *)(v2 + 63) = 10;
			*(x_DWORD *)(v2 + 76) = *(x_DWORD *)a1;
			*(x_WORD *)(v2 + 80) = *(x_WORD *)(a1 + 4);
			*(x_BYTE *)(v2 + 70) = 0;
			*(x_WORD *)(v2 + 154) = 2;
			v3 = *(x_BYTE *)(v2 + 12);
			*(x_WORD *)(v2 + 158) = 0;
			v3 |= 1u;
			*(x_BYTE *)(v2 + 12) = v3;
			*(x_WORD *)(v2 + 80) = 0;
			*(x_BYTE *)(v2 + 12) = v3 & 0xF7;
		}
	}
	return v1;
}
// D41B6: using guessed type char x_BYTE_D41B6;

//----- (0004FD70) --------------------------------------------------------
int sub_4FD70(int a1)
{
	int v1; // eax
	int v2; // ebx
	char v3; // ah

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_DWORD *)(v1 + 4) = 0;
		*(x_BYTE *)(v1 + 69) = 55;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 51;
		*(x_DWORD *)(v1 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v1 + 80) = *(x_WORD *)(a1 + 4);
		v3 = *(x_BYTE *)(v1 + 12);
		*(x_DWORD *)(v2 + 16) = 256;
		*(x_WORD *)(v2 + 130) = 1024;
		*(x_BYTE *)(v2 + 12) = v3 & 0xF7;
		sub_49EA0((x_WORD *)v2, 768, 768);
		sub_49A20(v2);
	}
	return v2;
}

//----- (0004FDE0) --------------------------------------------------------
int sub_4FDE0(int a1)
{
	int v1; // eax
	int v2; // ebx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_DWORD *)(v1 + 4) = 0;
		*(x_BYTE *)(v1 + 69) = 54;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 50;
		*(x_DWORD *)(v1 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v1 + 80) = *(x_WORD *)(a1 + 4);
		*(x_BYTE *)(v1 + 12) &= 0xF7u;
		sub_57D70(v1, a1);
		sub_49A20(v2);
	}
	return v2;
}

//----- (0004FE40) --------------------------------------------------------
x_WORD *sub_4FE40(int a1)
{
	int v1; // eax
	x_WORD *v2; // ebx

	v1 = sub_4A050();
	v2 = (x_WORD *)v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 36;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 34;
		*(x_DWORD *)(v1 + 4) = 0;
		*(x_BYTE *)(v1 + 65) = 3;
		*(x_BYTE *)(v1 + 66) = -1;
		*(x_BYTE *)(v1 + 12) &= 0xF7u;
		*(x_DWORD *)(v1 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v1 + 80) = *(x_WORD *)(a1 + 4);
		sub_49CD0((x_WORD *)v1, 223);
		sub_49EA0(v2, 256, 256);
		sub_49A20((int)v2);
		sub_57D70((int)v2, a1);
		v2[40] = sub_10C40(v2 + 38) + 640;
		*(x_DWORD *)(v2 + 77) = *((x_DWORD *)v2 + 19);
		v2[79] = v2[40];
		v2[10] = 9377 * v2[10] + 9439;
		sub_57FA0(v2 + 77, v2[10] & 0x7FF, 0, -32768);
	}
	return v2;
}

//----- (0004FF20) --------------------------------------------------------
int sub_4FF20()
{
	return sub_4A050();
}

//----- (0004FF30) --------------------------------------------------------
x_WORD *sub_4FF30(int a1)
{
	int v1; // eax
	x_WORD *v2; // ebx

	v1 = sub_4A050();
	v2 = (x_WORD *)v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 38;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 36;
		*(x_DWORD *)(v1 + 4) = 8;
		*(x_DWORD *)(v1 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v1 + 80) = *(x_WORD *)(a1 + 4);
		*(x_WORD *)(v1 + 42) = -1536;
		*(x_BYTE *)(v1 + 12) &= 0xF7u;
		sub_57D70(v1, a1);
		sub_49A20((int)v2);
		sub_49CD0(v2, 41);
		sub_49EA0(v2, 512, 512);
	}
	return v2;
}

//----- (0004FFB0) --------------------------------------------------------
int sub_4FFB0(int a1)
{
	x_BYTE *v1; // eax
	int v2; // ebx
	char v3; // ah

	v1 = (x_BYTE *)sub_4A050();
	v2 = (int)v1;
	if (v1)
	{
		v1[69] = 40;
		v1[63] = 10;
		v1[64] = 38;
		v3 = v1[12] & 0xF7;
		*(x_DWORD *)(v2 + 4) = 32;
		*(x_BYTE *)(v2 + 12) = v3;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 272);
		sub_49EA0((x_WORD *)v2, 512, 512);
	}
	return v2;
}

//----- (00050020) --------------------------------------------------------
x_WORD *sub_50020(int a1)
{
	int v1; // eax
	x_WORD *v2; // ebx

	v1 = sub_4A050();
	v2 = (x_WORD *)v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 35;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 33;
		*(x_BYTE *)(v1 + 12) &= 0xF7u;
		*(x_DWORD *)(v1 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v1 + 80) = *(x_WORD *)(a1 + 4);
		sub_49A20(v1);
		sub_49EA0(v2, 512, 512);
	}
	return v2;
}

//----- (00050080) --------------------------------------------------------
int sub_50080(int a1)
{
	return sub_500C0(a1, 512);
}

//----- (000500A0) --------------------------------------------------------
int sub_500A0(int a1)
{
	return sub_500C0(a1, 2560);
}

//----- (000500C0) --------------------------------------------------------
int sub_500C0(int a1, __int16 a2)
{
	int result; // eax
	int v3; // ebx

	result = sub_4A050();
	v3 = result;
	if (result)
	{
		*(x_BYTE *)(result + 69) = 41;
		*(x_BYTE *)(result + 63) = 10;
		*(x_BYTE *)(result + 64) = 39;
		*(x_BYTE *)(result + 65) = 10;
		*(x_BYTE *)(result + 66) = 39;
		*(x_WORD *)(result + 44) = 128;
		*(x_WORD *)(result + 130) = 32;
		*(x_BYTE *)(result + 56) = 3;
		*(x_BYTE *)(result + 57) = -128;
		*(x_BYTE *)(result + 58) = 0;
		*(x_DWORD *)(result + 144) = a2;
		sub_57D70(result, a1);
		sub_49A20(v3);
		sub_36920(v3, v3);
		result = v3;
	}
	return result;
}

//----- (00050130) --------------------------------------------------------
int sub_50130(int a1)
{
	int v1; // eax
	int v2; // ebx
	__int16 v3; // dx
	unsigned __int64 v4; // rtt
	char v5; // ah

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 62;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 57;
		*(x_BYTE *)(v1 + 65) = 10;
		*(x_BYTE *)(v1 + 66) = 57;
		v3 = *(x_WORD *)(v1 + 20);
		*(x_WORD *)(v1 + 44) = 128;
		*(x_WORD *)(v1 + 20) = 9377 * v3 + 9439;
		v4 = *(unsigned __int16 *)(v1 + 20);
		*(x_WORD *)(v1 + 130) = 0;
		*(x_BYTE *)(v1 + 56) = 3;
		*(x_BYTE *)(v1 + 57) = -128;
		*(x_BYTE *)(v1 + 58) = 0;
		*(x_BYTE *)(v1 + 67) = 10;
		*(x_DWORD *)(v1 + 144) = v4 % 0x7D0;
		v5 = *(x_BYTE *)(v1 + 14);
		*(x_BYTE *)(v2 + 68) = 1;
		*(x_BYTE *)(v2 + 14) = v5 | 2;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_36920(v2, v2);
	}
	return v2;
}

//----- (000501D0) --------------------------------------------------------
x_WORD *sub_501D0(int a1)
{
	int v1; // eax
	x_WORD *v2; // ebx
	int v3; // edx

	v1 = sub_4A050();
	v2 = (x_WORD *)v1;
	if (v1)
	{
		v3 = (int)x_D41A0_BYTEARRAY_0;
		*(x_BYTE *)(v1 + 69) = 42;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 40;
		*(x_DWORD *)(v1 + 16) = (v1 - (v3 + 28302)) / 168 % 11;
		*(x_BYTE *)(v1 + 56) = 2;
		sub_57D70(v1, a1);
		sub_49A20((int)v2);
		sub_49DA0(v2, 65);
	}
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00050250) --------------------------------------------------------
x_WORD *sub_50250(int a1)
{
	int v1; // eax
	x_WORD *v2; // ebx

	v1 = sub_4A050();
	v2 = (x_WORD *)v1;
	if (v1)
	{
		*(x_DWORD *)(v1 + 4) = 30;
		*(x_BYTE *)(v1 + 69) = 51;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 45;
		*(x_WORD *)(v1 + 42) = 100;
		*(x_DWORD *)(v1 + 16) = 4;
		*(x_DWORD *)(v1 + 12) = 9;
		*(x_BYTE *)(v1 + 56) = 33;
		sub_57D70(v1, a1);
		sub_49CD0(v2, 177);
	}
	return v2;
}

//----- (000502B0) --------------------------------------------------------
x_WORD *sub_502B0(int a1)
{
	int v1; // eax
	x_WORD *v2; // ebx

	v1 = sub_4A050();
	v2 = (x_WORD *)v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 45;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 43;
		*(x_DWORD *)(v1 + 4) = 8;
		*(x_WORD *)(v1 + 42) = -1536;
		*(x_BYTE *)(v1 + 12) &= 0xF7u;
		sub_57D70(v1, a1);
		sub_49A20((int)v2);
		sub_49CD0(v2, 41);
		sub_49EA0(v2, 512, 512);
	}
	return v2;
}

//----- (00050320) --------------------------------------------------------
int sub_50320(int a1)
{
	int v1; // eax
	int v2; // ebx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 43;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 41;
		*(x_DWORD *)(v1 + 4) = 0;
		*(x_BYTE *)(v1 + 12) &= 0xF7u;
		*(x_DWORD *)(v1 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v1 + 80) = *(x_WORD *)(a1 + 4);
		sub_49A20(v1);
	}
	return v2;
}

//----- (00050370) --------------------------------------------------------
int sub_50370(int a1)
{
	int v1; // eax
	int v2; // ebx
	char v3; // ah

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 44;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 42;
		*(x_DWORD *)(v1 + 4) = 0;
		v3 = *(x_BYTE *)(v1 + 12) & 0xF6;
		*(x_BYTE *)(v2 + 12) = v3;
		*(x_BYTE *)(v2 + 12) = v3 | 1;
		*(x_DWORD *)(v2 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v2 + 80) = *(x_WORD *)(a1 + 4);
		*(x_BYTE *)(v2 + 59) = 1;
		sub_49A20(v2);
	}
	return v2;
}

//----- (000503D0) --------------------------------------------------------
x_WORD *sub_503D0(int a1)
{
	int v1; // eax
	x_WORD *v2; // ebx

	v1 = sub_4A050();
	v2 = (x_WORD *)v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 46;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 44;
		*(x_DWORD *)(v1 + 4) = 500;
		*(x_WORD *)(v1 + 42) = 500;
		*(x_BYTE *)(v1 + 12) &= 0xF7u;
		sub_57D70(v1, a1);
		sub_49A20((int)v2);
		sub_49CD0(v2, 8);
	}
	return v2;
}

//----- (00050430) --------------------------------------------------------
x_WORD *sub_50430(int a1)
{
	int v1; // eax
	x_WORD *v2; // ebx

	v1 = sub_4A050();
	v2 = (x_WORD *)v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 56;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 52;
		*(x_DWORD *)(v1 + 4) = 100000;
		*(x_WORD *)(v1 + 42) = 500;
		*(x_DWORD *)(v1 + 16) = 600;
		*(x_DWORD *)(v1 + 144) = 500;
		*(x_DWORD *)(v1 + 140) = 2000;
		*(x_BYTE *)(v1 + 12) &= 0xF7u;
		sub_57D70(v1, a1);
		sub_49A20((int)v2);
		sub_49CD0(v2, 205);
	}
	return v2;
}

//----- (000504B0) --------------------------------------------------------
int sub_504B0(int a1)
{
	int v1; // eax
	int v2; // ebx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 58;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 53;
		*(x_DWORD *)(v1 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v1 + 80) = *(x_WORD *)(a1 + 4);
		*(x_DWORD *)(v1 + 4) = 6;
		*(x_WORD *)(v1 + 42) = 3000;
		*(x_BYTE *)(v1 + 12) &= 0xF7u;
		sub_49A20(v1);
	}
	return v2;
}

//----- (00050500) --------------------------------------------------------
int sub_50500(int a1)
{
	int v1; // eax
	int v2; // ebx
	__int16 v3; // dx
	__int16 v4; // ax

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 59;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 54;
		*(x_DWORD *)(v1 + 4) = 128;
		*(x_WORD *)(v1 + 130) = 256;
		v3 = *(x_WORD *)(v1 + 20);
		*(x_BYTE *)(v1 + 12) &= 0xF7u;
		*(x_WORD *)(v1 + 42) = 100;
		*(x_WORD *)(v1 + 20) = 9377 * v3 + 9439;
		v4 = *(x_WORD *)(v1 + 20);
		*(x_DWORD *)(v2 + 16) = 12845056;
		*(x_WORD *)(v2 + 28) = v4 & 0x7FF;
		*(x_DWORD *)(v2 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v2 + 80) = *(x_WORD *)(a1 + 4);
		*(x_BYTE *)(v2 + 12) |= 1u;
		sub_49A20(v2);
		sub_49EA0((x_WORD *)v2, 1024, 0x4000);
	}
	return v2;
}

//----- (000505A0) --------------------------------------------------------
int sub_505A0(int a1)
{
	int result; // eax

	result = sub_505E0(a1);
	if (result)
	{
		*(x_BYTE *)(result + 64) = 68;
		*(x_BYTE *)(result + 69) = 75;
	}
	return result;
}

//----- (000505E0) --------------------------------------------------------
int sub_505E0(int a1)
{
	int v1; // eax
	int v2; // ebx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_WORD *)(v1 + 130) = 64;
		*(x_DWORD *)(v1 + 16) = 12845056;
		*(x_DWORD *)(v1 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v1 + 80) = *(x_WORD *)(a1 + 4);
		*(x_BYTE *)(v1 + 12) = *(x_BYTE *)(v1 + 12) & 0xF6 | 1;
		sub_49EA0((x_WORD *)v1, 256, 256);
	}
	return v2;
}

//----- (00050640) --------------------------------------------------------
int sub_50640(int a1)
{
	int v1; // eax
	int v2; // ebx
	__int16 v3; // dx
	__int16 v4; // ax

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 60;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 55;
		*(x_DWORD *)(v1 + 4) = 19;
		*(x_WORD *)(v1 + 130) = 256;
		v3 = *(x_WORD *)(v1 + 20);
		*(x_BYTE *)(v1 + 12) &= 0xF7u;
		*(x_WORD *)(v1 + 42) = 100;
		*(x_WORD *)(v1 + 20) = 9377 * v3 + 9439;
		v4 = *(x_WORD *)(v1 + 20);
		*(x_DWORD *)(v2 + 16) = 32;
		*(x_WORD *)(v2 + 28) = v4 & 0x7FF;
		*(x_DWORD *)(v2 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v2 + 80) = *(x_WORD *)(a1 + 4);
		*(x_BYTE *)(v2 + 12) |= 1u;
		sub_49A20(v2);
		sub_49EA0((x_WORD *)v2, 1024, 0x4000);
	}
	return v2;
}

//----- (000506E0) --------------------------------------------------------
int sub_506E0(int a1)
{
	int v1; // eax
	int v2; // ebx
	__int16 v3; // dx
	__int16 v4; // ax

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 61;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 56;
		*(x_DWORD *)(v1 + 4) = 128;
		*(x_WORD *)(v1 + 130) = 256;
		v3 = *(x_WORD *)(v1 + 20);
		*(x_BYTE *)(v1 + 12) &= 0xF7u;
		*(x_WORD *)(v1 + 42) = 100;
		*(x_WORD *)(v1 + 20) = 9377 * v3 + 9439;
		v4 = *(x_WORD *)(v1 + 20);
		*(x_DWORD *)(v2 + 16) = 0;
		*(x_WORD *)(v2 + 28) = v4 & 0x7FF;
		*(x_DWORD *)(v2 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v2 + 80) = *(x_WORD *)(a1 + 4);
		*(x_BYTE *)(v2 + 12) |= 1u;
		sub_49A20(v2);
		sub_49EA0((x_WORD *)v2, 1024, 0x4000);
	}
	return v2;
}

//----- (00050780) --------------------------------------------------------
int sub_50780(int a1)
{
	int result; // eax
	char v2; // dl

	result = sub_4A050();
	if (result)
	{
		*(x_BYTE *)(result + 69) = 70;
		v2 = *(x_BYTE *)(result + 12);
		*(x_BYTE *)(result + 63) = 10;
		v2 &= 0xF6u;
		*(x_BYTE *)(result + 12) = v2;
		*(x_BYTE *)(result + 64) = 65;
		*(x_BYTE *)(result + 12) = v2 | 1;
		*(x_DWORD *)(result + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(result + 80) = *(x_WORD *)(a1 + 4);
	}
	return result;
}

//----- (000507C0) --------------------------------------------------------
int sub_507C0(int a1)
{
	int result; // eax
	char v2; // dl

	result = sub_4A050();
	if (result)
	{
		*(x_BYTE *)(result + 69) = 71;
		v2 = *(x_BYTE *)(result + 12);
		*(x_BYTE *)(result + 63) = 10;
		v2 &= 0xF6u;
		*(x_BYTE *)(result + 12) = v2;
		*(x_BYTE *)(result + 64) = 66;
		*(x_BYTE *)(result + 12) = v2 | 1;
		*(x_DWORD *)(result + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(result + 80) = *(x_WORD *)(a1 + 4);
		*(x_WORD *)(result + 42) = 200;
	}
	return result;
}

//----- (00050800) --------------------------------------------------------
x_BYTE *sub_50800()
{
	x_BYTE *result; // eax
	char v1; // bl

	result = (x_BYTE *)sub_4A050();
	if (result)
	{
		result[69] = 81;
		v1 = result[12];
		result[63] = 10;
		v1 &= 0xF6u;
		result[12] = v1;
		result[64] = 74;
		result[12] = v1 | 1;
	}
	return result;
}

//----- (00050840) --------------------------------------------------------
x_WORD *sub_50840(int a1)
{
	int v1; // eax
	x_WORD *v2; // ebx
	int v3; // edx

	v1 = sub_4A050();
	v2 = (x_WORD *)v1;
	if (v1)
	{
		*(x_DWORD *)(v1 + 4) = 1000;
		*(x_BYTE *)(v1 + 69) = 85;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 78;
		*(x_DWORD *)(v1 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v1 + 80) = *(x_WORD *)(a1 + 4);
		v3 = (int)x_D41A0_BYTEARRAY_0 + 28302;
		*(x_BYTE *)(v1 + 12) |= 8u;
		*(x_WORD *)(v1 + 42) = 0;
		*(x_BYTE *)(v1 + 70) = 0;
		*(x_WORD *)(v1 + 54) = -1;
		*(x_BYTE *)(v1 + 61) = 1;
		*(x_BYTE *)(v1 + 67) = 1;
		*(x_BYTE *)(v1 + 68) = 0;
		*(x_WORD *)(v1 + 50) = (v1 - v3) / 168;
		sub_57D70(v1, a1);
		sub_49A20((int)v2);
		sub_49CD0(v2, 66);
	}
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (000508E0) --------------------------------------------------------
int sub_508E0(int a1)
{
	int v1; // eax
	int v2; // ebx
	char v3; // ah

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_DWORD *)(v1 + 4) = 100000;
		*(x_BYTE *)(v1 + 69) = 86;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 79;
		*(x_DWORD *)(v1 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v1 + 80) = *(x_WORD *)(a1 + 4);
		v3 = *(x_BYTE *)(v1 + 12);
		*(x_BYTE *)(v2 + 70) = 0;
		*(x_BYTE *)(v2 + 67) = 0;
		*(x_WORD *)(v2 + 44) = 0;
		*(x_BYTE *)(v2 + 61) = 1;
		*(x_WORD *)(v2 + 54) = 0;
		*(x_BYTE *)(v2 + 12) = v3 & 0xF7;
		sub_57D70(v2, a1);
		sub_49A20(v2);
		sub_49CD0((x_WORD *)v2, 66);
	}
	return v2;
}

//----- (00050960) --------------------------------------------------------
int sub_50960(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // eax
	int v4; // edx
	__int16 v5; // ax
	__int16 v6; // dx

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_DWORD *)(v1 + 4) = 9;
		v3 = *(x_DWORD *)(v1 + 4);
		*(x_BYTE *)(v2 + 69) = 93;
		v4 = *(x_DWORD *)(v2 + 12);
		*(x_BYTE *)(v2 + 63) = 10;
		*(x_DWORD *)(v2 + 8) = v3;
		*(x_DWORD *)(v2 + 12) = v4 & 0xFFFDFFF7;
		BYTE1(v3) = *(x_BYTE *)(v2 + 14);
		*(x_BYTE *)(v2 + 64) = 86;
		*(x_BYTE *)(v2 + 14) = BYTE1(v3) | 2;
		sub_57D70(v2, a1);
		v5 = sub_10C40((__int16 *)(v2 + 76));
		v6 = *(x_WORD *)(v2 + 20);
		*(x_WORD *)(v2 + 80) = v5;
		*(x_WORD *)(v2 + 20) = 9377 * v6 + 9439;
		sub_49CD0((x_WORD *)v2, *(x_WORD *)(v2 + 20) % 3u + 332);
		if (!(sub_104A0(v2 + 76) & 1))
		{
			sub_57F20(v2);
			v2 = 0;
		}
	}
	return v2;
}

//----- (00050A20) --------------------------------------------------------
int sub_50A20(int a1)
{
	int v1; // eax
	int v2; // ebx
	char v3; // dl

	if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308) != 2)
		return 0;
	v1 = sub_4A050();
	v2 = v1;
	if (!v1)
		return 0;
	v3 = *(x_BYTE *)(v1 + 12) & 0xF6;
	*(x_BYTE *)(v1 + 12) = v3;
	*(x_BYTE *)(v1 + 69) = 96;
	*(x_BYTE *)(v1 + 12) = v3 | 1;
	*(x_BYTE *)(v1 + 63) = 10;
	*(x_BYTE *)(v1 + 64) = 89;
	*(x_DWORD *)(v1 + 8) = 40;
	sub_57D70(v1, a1);
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00050A90) --------------------------------------------------------
int sub_50A90(int a1, char a2, char a3)
{
	int v3; // eax
	int v4; // ebx
	char v5; // dl

	v3 = sub_4A050();
	v4 = v3;
	if (v3)
	{
		*(x_BYTE *)(v3 + 63) = 11;
		*(x_BYTE *)(v3 + 64) = a2;
		*(x_BYTE *)(v3 + 69) = a3;
		*(x_BYTE *)(v3 + 12) &= 0xF6u;
		v5 = *(x_BYTE *)(v3 + 12);
		*(x_DWORD *)(v3 + 16) = 0;
		*(x_BYTE *)(v3 + 12) = v5 | 1;
		*(x_DWORD *)(v3 + 76) = *(x_DWORD *)a1;
		*(x_WORD *)(v3 + 80) = *(x_WORD *)(a1 + 4);
		sub_49A20(v3);
	}
	return v4;
}

//----- (00050AE0) --------------------------------------------------------
int sub_50AE0(int a1)
{
	return sub_50A90(a1, 0, 0);
}

//----- (00050B00) --------------------------------------------------------
int sub_50B00(int a1)
{
	return sub_50A90(a1, 1, 1);
}

//----- (00050B20) --------------------------------------------------------
int sub_50B20(int a1)
{
	return sub_50A90(a1, 2, 2);
}

//----- (00050B40) --------------------------------------------------------
int sub_50B40(int a1)
{
	return sub_50A90(a1, 3, 3);
}

//----- (00050B60) --------------------------------------------------------
int sub_50B60(int a1)
{
	return sub_50A90(a1, 4, 4);
}

//----- (00050B80) --------------------------------------------------------
int sub_50B80(int a1)
{
	return sub_50A90(a1, 32, 32);
}

//----- (00050C10) --------------------------------------------------------
int sub_50C10(int a1)
{
	return sub_50A90(a1, 12, 12);
}

//----- (00050C30) --------------------------------------------------------
int sub_50C30(int a1)
{
	return sub_50A90(a1, 13, 13);
}

//----- (00050C50) --------------------------------------------------------
int sub_50C50(int a1)
{
	return sub_50A90(a1, 14, 14);
}

//----- (00050C70) --------------------------------------------------------
int sub_50C70(int a1)
{
	return sub_50A90(a1, 15, 15);
}

//----- (00050C90) --------------------------------------------------------
int sub_50C90(int a1)
{
	return sub_50A90(a1, 16, 16);
}

//----- (00050CB0) --------------------------------------------------------
int sub_50CB0(int a1)
{
	return sub_50A90(a1, 17, 17);
}

//----- (00050CD0) --------------------------------------------------------
int sub_50CD0(int a1)
{
	return sub_50A90(a1, 18, 18);
}

//----- (00050CF0) --------------------------------------------------------
int sub_50CF0(int a1)
{
	return sub_50A90(a1, 19, 19);
}

//----- (00050D10) --------------------------------------------------------
int sub_50D10(int a1)
{
	return sub_50A90(a1, 20, 20);
}

//----- (00050D30) --------------------------------------------------------
int sub_50D30(int a1)
{
	return sub_50A90(a1, 21, 21);
}

//----- (00050D50) --------------------------------------------------------
int sub_50D50(int a1)
{
	return sub_50A90(a1, 22, 22);
}

//----- (00050D70) --------------------------------------------------------
int sub_50D70(int a1)
{
	return sub_50A90(a1, 23, 23);
}

//----- (00050D90) --------------------------------------------------------
int sub_50D90(int a1)
{
	return sub_50A90(a1, 24, 24);
}

//----- (00050DB0) --------------------------------------------------------
int sub_50DB0(int a1)
{
	return sub_50A90(a1, 25, 25);
}

//----- (00050DD0) --------------------------------------------------------
int sub_50DD0(int a1)
{
	return sub_50A90(a1, 26, 26);
}

//----- (00050DF0) --------------------------------------------------------
int sub_50DF0(int a1)
{
	return sub_50A90(a1, 27, 27);
}

//----- (00050E10) --------------------------------------------------------
int sub_50E10(int a1)
{
	return sub_50A90(a1, 28, 28);
}

//----- (00050E30) --------------------------------------------------------
int sub_50E30(int a1)
{
	return sub_50A90(a1, 29, 29);
}

//----- (00050E50) --------------------------------------------------------
int sub_50E50(int a1)
{
	return sub_50A90(a1, 33, 33);
}

//----- (00050E70) --------------------------------------------------------
int sub_50E70(int a1)
{
	return sub_50A90(a1, 34, 34);
}

//----- (00050E90) --------------------------------------------------------
int sub_50E90(int a1)
{
	return sub_50A90(a1, 35, 35);
}

//----- (00050EB0) --------------------------------------------------------
int sub_50EB0(int a1)
{
	return sub_50A90(a1, 36, 36);
}

//----- (00050ED0) --------------------------------------------------------
int sub_50ED0(int a1)
{
	return sub_50A90(a1, 37, 37);
}

//----- (00050EF0) --------------------------------------------------------
int sub_50EF0(int a1)
{
	return sub_50A90(a1, 38, 38);
}

//----- (00050F10) --------------------------------------------------------
int sub_50F10(int a1)
{
	return sub_50A90(a1, 39, 39);
}

//----- (00050F30) --------------------------------------------------------
int sub_50F30(int a1)
{
	return sub_50A90(a1, 40, 40);
}

//----- (00050F50) --------------------------------------------------------
int sub_50F50(int a1)
{
	return sub_50A90(a1, 41, 41);
}

//----- (00050F70) --------------------------------------------------------
int sub_50F70(int a1)
{
	return sub_50A90(a1, 42, 42);
}

//----- (00050F90) --------------------------------------------------------
int sub_50F90(int a1)
{
	return sub_50A90(a1, 43, 43);
}

//----- (00050FB0) --------------------------------------------------------
int sub_50FB0(int a1)
{
	return sub_50A90(a1, 44, 44);
}

//----- (00050FD0) --------------------------------------------------------
int sub_50FD0(int a1)
{
	return sub_50A90(a1, 30, 30);
}

//----- (00050FF0) --------------------------------------------------------
int sub_50FF0(int a1)
{
	int v1; // edx
	int v2; // eax
	char v3; // cl

	v1 = 0;
	if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10) && !(x_D41A0_BYTEARRAY_4[38545] & 8))
	{
		v1 = sub_50A90(a1, 31, 31);
		if (v1)
		{
			v2 = (int)x_D41A0_BYTEARRAY_0;
			v3 = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 224779);
			*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 224770) = 1;
			*(x_BYTE *)(v2 + 224779) = v3 | 1;
		}
	}
	return v1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (00051120) --------------------------------------------------------
int sub_51120(int a1, char a2, char a3)
{
	int v3; // eax
	int v4; // ebx
	int v5; // esi
	char v6; // ah

	v3 = sub_4A050();
	v4 = v3;
	v5 = v3;
	if (v3)
	{
		*(x_BYTE *)(v3 + 63) = 15;
		*(x_DWORD *)(v3 + 4) = 0;
		*(x_BYTE *)(v3 + 64) = a2;
		*(x_BYTE *)(v3 + 69) = a3;
		v6 = *(x_BYTE *)(v3 + 12);
		*(x_DWORD *)(v4 + 8) = 0;
		*(x_BYTE *)(v4 + 12) = v6 & 0xF7;
		sub_57D70(v4, a1);
		sub_49CD0((x_WORD *)v4, 77);
		sub_49EA0((x_WORD *)v4, 768, 1280);
		sub_49A20(v4);
		sub_6D5E0(v4, 0);
	}
	return v5;
}

//----- (000511A0) --------------------------------------------------------
int sub_511A0(int a1)
{
	return sub_51120(a1, 0, 0);
}

//----- (000511C0) --------------------------------------------------------
int sub_511C0(int a1)
{
	return sub_51120(a1, 1, 3);
}

//----- (000511E0) --------------------------------------------------------
int sub_511E0(int a1)
{
	return sub_51120(a1, 2, 6);
}

//----- (00051200) --------------------------------------------------------
int sub_51200(int a1)
{
	return sub_51120(a1, 3, 9);
}

//----- (00051220) --------------------------------------------------------
int sub_51220(int a1)
{
	return sub_51120(a1, 4, 12);
}

//----- (00051240) --------------------------------------------------------
int sub_51240(int a1)
{
	return sub_51120(a1, 5, 15);
}

//----- (00051260) --------------------------------------------------------
int sub_51260(int a1)
{
	return sub_51120(a1, 6, 18);
}

//----- (00051280) --------------------------------------------------------
int sub_51280(int a1)
{
	return sub_51120(a1, 7, 21);
}

//----- (000512A0) --------------------------------------------------------
int sub_512A0(int a1)
{
	return sub_51120(a1, 8, 24);
}

//----- (000512C0) --------------------------------------------------------
int sub_512C0(int a1)
{
	return sub_51120(a1, 9, 27);
}

//----- (000512E0) --------------------------------------------------------
int sub_512E0(int a1)
{
	return sub_51120(a1, 10, 30);
}

//----- (00051300) --------------------------------------------------------
int sub_51300(int a1)
{
	return sub_51120(a1, 11, 33);
}

//----- (00051320) --------------------------------------------------------
int sub_51320(int a1)
{
	return sub_51120(a1, 12, 36);
}

//----- (00051340) --------------------------------------------------------
int sub_51340(int a1)
{
	return sub_51120(a1, 13, 39);
}

//----- (00051360) --------------------------------------------------------
int sub_51360(int a1)
{
	return sub_51120(a1, 14, 42);
}

//----- (00051380) --------------------------------------------------------
int sub_51380(int a1)
{
	return sub_51120(a1, 15, 45);
}

//----- (000513A0) --------------------------------------------------------
int sub_513A0(int a1)
{
	return sub_51120(a1, 16, 48);
}

//----- (000513C0) --------------------------------------------------------
int sub_513C0(int a1)
{
	return sub_51120(a1, 17, 51);
}

//----- (000513E0) --------------------------------------------------------
int sub_513E0(int a1)
{
	return sub_51120(a1, 18, 54);
}

//----- (00051400) --------------------------------------------------------
int sub_51400(int a1)
{
	return sub_51120(a1, 19, 57);
}

//----- (00051420) --------------------------------------------------------
int sub_51420(int a1)
{
	return sub_51120(a1, 20, 60);
}

//----- (00051440) --------------------------------------------------------
int sub_51440(int a1)
{
	return sub_51120(a1, 21, 63);
}

//----- (00051460) --------------------------------------------------------
int sub_51460(int a1)
{
	return sub_51120(a1, 22, 66);
}

//----- (00051480) --------------------------------------------------------
int sub_51480(int a1)
{
	return sub_51120(a1, 23, 69);
}

//----- (000514A0) --------------------------------------------------------
int sub_514A0(int a1)
{
	return sub_51120(a1, 24, 72);
}

//----- (000514C0) --------------------------------------------------------
int sub_514C0(int a1)
{
	return sub_51120(a1, 25, 75);
}

//----- (000514E0) --------------------------------------------------------
int sub_514E0(int a1, char a2, char a3, __int16 a4)
{
	int v4; // ebx

	v4 = sub_4A050();
	if (v4)
	{
		*(x_BYTE *)(v4 + 63) = 14;
		*(x_BYTE *)(v4 + 70) = 0;
		*(x_BYTE *)(v4 + 69) = a3;
		*(x_BYTE *)(v4 + 64) = a2;
		sub_57D70(v4, a1);
		sub_49A20(v4);
		sub_49DA0((x_WORD *)v4, a4);
	}
	return v4;
}

//----- (00051530) --------------------------------------------------------
x_WORD *sub_51530(int a1)
{
	x_WORD *v1; // eax
	x_WORD *v2; // ebx

	v1 = (x_WORD *)sub_514E0(a1, 0, 0, 77);
	v2 = v1;
	if (v1)
		sub_49EA0(v1, 384, 384);
	return v2;
}

//----- (00051570) --------------------------------------------------------
int sub_51570(int a1)
{
	int result; // eax

	result = sub_514E0(a1, 3, 8, 338);
	if (result)
	{
		*(x_WORD *)(x_D41A0_BYTEARRAY_0 + 224766) = (result - (x_D41A0_BYTEARRAY_0[28302])) / 168;
		*(x_BYTE *)(result + 12) |= 1u;
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (000515C0) --------------------------------------------------------
int sub_515C0(int a1)
{
	int result; // eax

	result = sub_514E0(a1, 4, 9, 339);
	if (result)
	{
		*(x_WORD *)(0x36DFC + x_D41A0_BYTEARRAY_0) = (result - (x_D41A0_BYTEARRAY_0[28302])) / 168;
		*(x_BYTE *)(result + 12) |= 1u;
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00051610) --------------------------------------------------------
x_WORD *sub_51610(int a1)
{
	x_WORD *v1; // eax
	x_WORD *v2; // ebx
	x_WORD *v3; // esi

	v1 = (x_WORD *)sub_514E0(a1, 5, 10, 280);
	v2 = v1;
	v3 = v1;
	if (v1)
	{
		sub_49EA0(v1, 768, 1280);
		if (x_D41A0_BYTEARRAY_4[38545] & 4)
			*((x_BYTE *)v2 + 12) |= 1u;
	}
	return v3;
}
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (00051660) --------------------------------------------------------
int sub_51660(int a1)
{
	int v1; // eax
	int v2; // ebx
	char v3; // dl

	v1 = sub_4A050();
	v2 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 6;
		v3 = *(x_BYTE *)(v1 + 12);
		*(x_BYTE *)(v1 + 63) = 14;
		v3 &= 0xF6u;
		*(x_BYTE *)(v1 + 12) = v3;
		*(x_BYTE *)(v1 + 64) = 1;
		*(x_BYTE *)(v1 + 12) = v3 | 1;
		*(x_DWORD *)(v1 + 4) = 0;
		*(x_DWORD *)(v1 + 8) = 0;
		*(x_WORD *)(v1 + 42) = 0;
		sub_57D70(v1, a1);
	}
	return v2;
}

//----- (000516C0) --------------------------------------------------------
int sub_516C0(int a1)
{
	int v1; // ebx
	int v2; // eax
	char v3; // dl

	v1 = 0;
	if (x_BYTE_D41B6)
	{
		v2 = sub_4A050();
		v1 = v2;
		if (v2)
		{
			*(x_BYTE *)(v2 + 69) = 7;
			*(x_BYTE *)(v2 + 63) = 14;
			v3 = *(x_BYTE *)(v2 + 12);
			*(x_BYTE *)(v2 + 64) = 2;
			v3 &= 0xF6u;
			*(x_BYTE *)(v2 + 12) = v3;
			*(x_DWORD *)(v2 + 8) = 0;
			*(x_BYTE *)(v2 + 12) = v3 | 1;
			*(x_WORD *)(v2 + 42) = 0;
			*(x_WORD *)(v2 + 44) = 0;
			*(x_WORD *)(v2 + 150) = 0;
			sub_57D70(v2, a1);
		}
	}
	return v1;
}
// D41B6: using guessed type char x_BYTE_D41B6;

//----- (00051730) --------------------------------------------------------
int sub_51730(int a1)
{
	int v1; // eax
	x_WORD *v2; // ebx
	int v3; // esi

	v1 = sub_4A050();
	v2 = (x_WORD *)v1;
	v3 = v1;
	if (v1)
	{
		*(x_BYTE *)(v1 + 69) = 72;
		*(x_BYTE *)(v1 + 63) = 10;
		*(x_BYTE *)(v1 + 64) = 67;
		*(x_BYTE *)(v1 + 12) = *(x_BYTE *)(v1 + 12) & 0xF6 | 1;
		*(x_DWORD *)(v1 + 8) = 120;
		*(x_WORD *)(v1 + 42) = 20000;
		sub_57D70(v1, a1);
		sub_49EA0(v2, 4352, 4352);
	}
	return v3;
}

//----- (00051790) --------------------------------------------------------
x_BYTE *sub_51790(int a1)
{
	x_BYTE *v1; // eax
	int v2; // ebx
	x_BYTE *v3; // esi
	char v4; // ah

	v1 = (x_BYTE *)sub_4A050();
	v2 = (int)v1;
	v3 = v1;
	if (v1)
	{
		v1[69] = 78;
		v1[63] = 10;
		v1[64] = 71;
		v4 = v1[12];
		*(x_DWORD *)(v2 + 8) = 120;
		*(x_WORD *)(v2 + 42) = 20000;
		*(x_BYTE *)(v2 + 12) = v4 & 0xF6 | 1;
		*(x_BYTE *)(v2 + 70) = 0;
		*(x_DWORD *)(v2 + 4) = *(x_DWORD *)(v2 + 8);
		sub_57D70(v2, a1);
		sub_49EA0((x_WORD *)v2, 1280, 2048);
	}
	return v3;
}

//----- (00051800) --------------------------------------------------------
x_WORD *sub_51800(int a1)
{
	int v1; // ebx
	int v2; // eax
	char v3; // dl
	int v4; // eax
	x_WORD *v5; // ebx
	int v6; // edx
	int v7; // eax
	int v9; // [esp+0h] [ebp-10h]
	int v10; // [esp+4h] [ebp-Ch]
	x_WORD *v11; // [esp+8h] [ebp-8h]
	signed __int16 v12; // [esp+Ch] [ebp-4h]

	v11 = 0;
	v1 = x_D41A0_BYTEARRAY_4[0xE0];
	if (sub_4A810() >= v1)
	{
		v2 = sub_4A050();
		v11 = (x_WORD *)v2;
		if (v2)
		{
			*(x_BYTE *)(v2 + 69) = 79;
			*(x_BYTE *)(v2 + 63) = 10;
			*(x_BYTE *)(v2 + 64) = 72;
			v3 = *(x_BYTE *)(v2 + 12);
			*(x_DWORD *)(v2 + 4) = 16;
			*(x_BYTE *)(v2 + 12) = v3 & 0xF7;
			v10 = v2;
			*(x_DWORD *)(v2 + 8) = *(x_DWORD *)(v2 + 4);
			v12 = 1;
			*(x_BYTE *)(v2 + 62) = 0;
			while (x_D41A0_BYTEARRAY_4[0xE0] > v12)
			{
				v4 = sub_4A050();
				v5 = (x_WORD *)v4;
				v9 = v4;
				if (v4)
				{
					qmemcpy((void *)v4, v11, 0xA8u);
					v6 = v4 - (x_D41A0_BYTEARRAY_0[28302]);
					*(x_WORD *)(v4 + 50) = (v10 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
					*(x_WORD *)(v10 + 52) = v6 / 168;
					*(x_WORD *)(v4 + 52) = 0;
					*(x_BYTE *)(v4 + 62) = v12;
					v7 = (int)x_D41A0_BYTEARRAY_4;
					*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)a1;
					*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 4);
					sub_57FA0((x_WORD*)&x_WORD_EB398, v12 * (2048 / *(unsigned __int8 *)(v7 + 224)), 0, 512);
					x_WORD_EB39C = sub_10C40(&x_WORD_EB398);
					sub_57D70((int)v5, (int)&x_WORD_EB398);
					sub_49EA0(v5, 128, 256);
					sub_49CD0(v5, 220);
				}
				v10 = v9;
				++v12;
			}
			*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)a1;
			*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 4);
			sub_57FA0((x_WORD*)&x_WORD_EB398, 0, 0, 512);
			x_WORD_EB39C = sub_10C40(&x_WORD_EB398);
			sub_57D70((int)v11, (int)&x_WORD_EB398);
			sub_49EA0(v11, 128, 256);
			sub_49CD0(v11, 220);
		}
	}
	return v11;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (00051A00) --------------------------------------------------------
x_BYTE *sub_51A00(int a1)
{
	x_BYTE *v1; // eax
	int v2; // ebx
	char v3; // ah
	x_BYTE *v5; // [esp+0h] [ebp-4h]

	v1 = (x_BYTE *)sub_4A050();
	v2 = (int)v1;
	v5 = v1;
	if (v1)
	{
		v1[69] = 80;
		v1[63] = 10;
		v1[64] = 73;
		v3 = v1[12] & 0xF7;
		*(x_DWORD *)(v2 + 8) = 16;
		*(x_BYTE *)(v2 + 12) = v3;
		*(x_DWORD *)(v2 + 4) = *(x_DWORD *)(v2 + 8);
		*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)a1;
		*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 4);
		x_WORD_EB39C = sub_10C40(&x_WORD_EB398);
		sub_57D70(v2, (int)&x_WORD_EB398);
		sub_49EA0((x_WORD *)v2, 128, 256);
		sub_49CD0((x_WORD *)v2, 220);
	}
	return v5;
}
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (00051BB0) --------------------------------------------------------
int sub_51BB0(int a1)
{
	char v1; // al
	x_BYTE *v2; // ecx
	unsigned __int16 v3; // dx
	Bit8u* v4; // ebx
	char *v5; // esi
	char *v6; // edi
	char v7; // al
	char v8; // al
	int v9; // esi
	Bit8u* v10; // edx
	int v11; // eax
	int v12; // esi
	char v13; // dl
	char v14; // bl
	signed __int16 v15; // bx
	char v16; // cl
	int v17; // eax
	Bit8u* v18; // ebx
	int v19; // eax
	char *v20; // esi
	char *v21; // edi
	char v22; // al
	char v23; // al
	__int16 v24; // ST08_2
	__int16 v25; // ST08_2
	char *v26; // esi
	char *v27; // edi
	char v28; // al
	char v29; // al
	__int16 v30; // ax
	int v31; // eax
	int v32; // edx
	int v33; // eax
	int v34; // eax
	char v35; // al
	char v36; // dl
	const char *v37; // edi
	unsigned int v38; // kr04_4
	const char *v39; // edi
	unsigned int v40; // kr08_4
	char *v41; // esi
	char *v42; // edi
	char v43; // al
	char v44; // al
	char *v45; // edi
	char *v46; // esi
	char v47; // al
	char v48; // al
	int v49; // edx
	int v50; // ecx
	bool v51; // zf
	char *v52; // esi
	char *v53; // edi
	char v54; // al
	char v55; // al
	int v56; // eax
	__int16 i; // ax
	int v58; // edx
	unsigned __int16 v59; // si
	int j; // eax
	int v61; // eax
	int v62; // esi
	int v63; // eax
	__int64 v64; // rtt
	__int16 n; // ax
	int v66; // edx
	unsigned int ii; // eax
	int v68; // eax
	int v69; // edx
	unsigned int k; // eax
	char v71; // dl
	unsigned int l; // eax
	unsigned int m; // eax
	__int16 v74; // ax
	int v75; // edx
	char v76; // dl
	char v77; // ch
	__int16 v78; // cx
	int v79; // eax
	int v80; // edx
	int v81; // edx
	int v82; // esi
	char *v83; // edi
	char *v84; // esi
	char v85; // al
	char v86; // al
	int v87; // eax
	int v88; // eax
	int v89; // edx
	int v90; // eax
	unsigned __int8 v91; // cl
	int v92; // edx
	char v93; // al
	int v94; // eax
	char v95; // dl
	int v96; // eax
	int v97; // edx
	unsigned int v98; // eax
	int v99; // ecx
	__int64 v100; // rax
	int v101; // ecx
	__int64 v102; // rax
	int v103; // esi
	int v104; // esi
	int result; // eax
	const char *v106; // [esp-4h] [ebp-120h]
	//unsigned __int8 v107; // [esp+0h] [ebp-11Ch]
	unsigned __int8 v108; // [esp+1h] [ebp-11Bh]
	unsigned __int8 v109; // [esp+2h] [ebp-11Ah]
	unsigned __int8 v110; // [esp+3h] [ebp-119h]
	unsigned __int8 v111; // [esp+4h] [ebp-118h]
	int v112; // [esp+100h] [ebp-1Ch]
	int v113; // [esp+104h] [ebp-18h]
	Bit8u* v114; // [esp+108h] [ebp-14h]
	int v115; // [esp+10Ch] [ebp-10h]
	unsigned int v116; // [esp+110h] [ebp-Ch]
	char v117; // [esp+114h] [ebp-8h]
	char v118; // [esp+118h] [ebp-4h]

	// fix if begin
	v108 = 0;
	v109 = 0;
	v110 = 0;
	v111 = 0;
	// end

	if (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10)
	{
		sub_74374();
		sub_7438A((int)x_D41A0_BYTEARRAY_0 + 28222, 0xAu);
		v1 = 0;
		v2 = (x_BYTE *)(x_D41A0_BYTEARRAY_0 + 28222);
		v3 = 0;
		v4 = x_D41A0_BYTEARRAY_0 + 11230;
		while (1)
		{
			v9 = (int)x_D41A0_BYTEARRAY_0;
			if (v3 >= *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 14))
				break;
			if (*v2 == 1)
			{
				*(x_BYTE *)(v4 + 6) = 1;
				if (v3 == *(signed __int16 *)(v9 + 12) && x_D41A0_BYTEARRAY_4_struct.player_name_57)
				{
					v5 = x_D41A0_BYTEARRAY_4_struct.player_name_57;
					v6 = (char *)(v4 + 927);
					do
					{
						v7 = *v5;
						*v6 = *v5;
						if (!v7)
							break;
						v8 = v5[1];
						v5 += 2;
						v6[1] = v8;
						v6 += 2;
					} while (v8);
					a1 = (int)v4 + 927;
				}
				v1 = 1;
			}
			v2 += 10;
			v4 += 2124;
			++v3;
		}
		if (v1)
			sub_7438A((int)x_D41A0_BYTEARRAY_0 + 11230, 0x84Cu);
	}
	v10 = 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0;
	v11 = (int)x_D41A0_BYTEARRAY_4;
	++*(x_DWORD *)(v10 + 11248);
	v12 = *(x_DWORD *)(v11 + 30);
	++*(x_DWORD *)(v11 + 26);
	v13 = *(x_BYTE *)(v11 + 38400);
	*(x_DWORD *)(v11 + 30) = v12 + 1;
	if (v13)
		*(x_BYTE *)(v11 + 38400) = v13 - 1;
	v14 = x_D41A0_BYTEARRAY_4[38401];
	if (v14)
		x_D41A0_BYTEARRAY_4[38401] = v14 - 1;
	v15 = 1;
	while (v15 < 16)
	{
		v16 = *(x_DWORD *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11248) / (unsigned int)v15 & 1;
		v17 = v15++;
		x_D41A0_BYTEARRAY_4[v17 + 121] = v16;
	}
	v114 = x_D41A0_BYTEARRAY_0 + 28222;
	v18 = x_D41A0_BYTEARRAY_0 + 11230;
	v116 = 0;
	while (1)
	{
		result = (int)x_D41A0_BYTEARRAY_0;
		if ((unsigned __int16)v116 >= *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 14))
			return result;
		v113 = x_DWORD_EA3E4[*(unsigned __int16 *)(v18 + 10)];
		if (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x20)
		{
			a1 = (int)v114;
			sub_53A40((char *)v114);
		}
		switch (*(x_BYTE *)v114)
		{
		case 1:
			v19 = (int)x_D41A0_BYTEARRAY_4;
			*(x_BYTE *)(v18 + 6) = 1;
			if (!(*(x_BYTE *)(v19 + 22) & 0x10)
				&& (unsigned __int16)v116 == x_D41A0_BYTEARRAY_4_struct.dwordindex_12
				&& x_D41A0_BYTEARRAY_4_struct.player_name_57)
			{
				v20 = x_D41A0_BYTEARRAY_4_struct.player_name_57;
				v21 = (char *)(v18 + 927);
				do
				{
					v22 = *v20;
					*v21 = *v20;
					if (!v22)
						break;
					v23 = v20[1];
					v20 += 2;
					v21[1] = v23;
					v21 += 2;
				} while (v23);
				a1 = (int)v18 + 927;
			}
			goto LABEL_33;
		case 2:
			sub_53120();
			if (x_D41A0_BYTEARRAY_4_struct.dwordindex_12 == (unsigned __int16)v116)
				*(x_BYTE *)(v18 + 4) = 1;
			if (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10)
				sub_5E660(v113);
			sub_7373D(v116);
			*(x_BYTE *)(v18 + 6) = 0;
			goto LABEL_215;
		case 3:
			goto LABEL_33;
		case 4:
			*(x_BYTE *)(v18 + 5) ^= *(x_BYTE *)(v114 + 1);
			goto LABEL_215;
		case 6:
			if (*(x_BYTE *)(v114 + 5) & 0x40)
				*(x_BYTE *)(*(x_DWORD *)(v113 + 164) + 1112) = *(x_BYTE *)(v114 + 1);
			if (*(x_BYTE *)(v114 + 5) < 0 && !*(x_BYTE *)(v18 + 2118))
				*(x_BYTE *)(v18 + 2118) = 1;
			goto LABEL_215;
		case 7:
			if (*(unsigned __int16 *)(v18 + 14) + (signed int)*(char *)(v114 + 1) >= 0
				&& *(char *)(v114 + 1) + *(unsigned __int16 *)(v18 + 14) < *(unsigned __int16 *)(v18 + 16) - 1)
			{
				*(x_WORD *)(v18 + 14) += *(char *)(v114 + 1);
			}
			goto LABEL_215;
		case 8:
			*(x_WORD *)(v18 + 477) += *(char *)(v114 + 1);
			goto LABEL_215;
		case 0xC:
			x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 = (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 | 0x22) & 0xFB;
			goto LABEL_215;
		case 0xD:
			x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 = (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 | 0x24) & 0xFD;
			goto LABEL_215;
		case 0xF:
			if (*(x_WORD *)(*(x_DWORD *)(v113 + 164) + 58))
				goto LABEL_33;
			if (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10)
				goto LABEL_56;
			*(x_BYTE *)(v18 + 2) |= 0xCu;
		LABEL_33:
			sub_5C950((int)v18, v113);
			sub_6EDB0_set_mouse_position_by_res();
			sub_548F0((x_WORD *)v18);
			sub_52E90((int)v18, 0, 0);
			goto LABEL_215;
		case 0x10:
			if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 224746) && (unsigned __int16)v116 == x_D41A0_BYTEARRAY_4_struct.dwordindex_12)
			{
				v33 = (int)v114;
				*(x_BYTE *)(v114 + 3) = 0;
				*(x_BYTE *)(v33 + 4) = 0;
				sub_6EDB0_set_mouse_position_by_res();
			}
			sub_52E90((int)v18, 3, 1);
			v34 = (int)x_D41A0_BYTEARRAY_0;
			*(x_BYTE *)(v18 + 994) = 0;
			if ((unsigned __int16)v116 == *(signed __int16 *)(v34 + 12))
			{
				v35 = *(x_BYTE *)(v18 + 992);
				sub_54960();
			}
			goto LABEL_215;
		case 0x11:
			v36 = *(x_BYTE *)(v114 + 1);
			if (v36 == 8)
			{
				v37 = (const char *)(48 * *(unsigned __int8 *)(v18 + 992) + v18 + 81);
				v38 = strlen(v37) + 1;
				a1 = (int)&v37[v38];
				if (v38 != 1)
				{
					--*(x_BYTE *)(v18 + 994);
					*(x_BYTE *)(v38 - 1 + v18 + 48 * *(unsigned __int8 *)(v18 + 992) + 80) = 0;
				}
			}
			else if (v36)
			{
				v39 = (const char *)(48 * *(unsigned __int8 *)(v18 + 992) + v18 + 81);
				v40 = strlen(v39) + 1;
				a1 = (int)&v39[v40];
				if (v40 - 1 < 0x2B)
				{
					if (!*(x_BYTE *)(v18 + 994))
						*(x_BYTE *)(v18 + 48 * *(unsigned __int8 *)(v18 + 992) + 81) = 0;
					++*(x_BYTE *)(v18 + 994);
					sprintf_s(printbuffer, 512, "%c", *(char *)(v114 + 1));
					v41 = printbuffer;
					v106 = (const char *)(48 * *(unsigned __int8 *)(v18 + 992) + v18 + 81);
					v42 = (char *)&v106[strlen(v106)];
					do
					{
						v43 = *v41;
						*v42 = *v41;
						if (!v43)
							break;
						v44 = v41[1];
						v41 += 2;
						v42[1] = v44;
						v42 += 2;
					} while (v44);
					a1 = (int)v106;
				}
			}
			goto LABEL_215;
		case 0x12:
			sub_52E90((int)v18, 0, 1);
			goto LABEL_215;
		case 0x13:
			goto LABEL_82;
		case 0x14:
			if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 224746) && (unsigned __int16)v116 == x_D41A0_BYTEARRAY_4_struct.dwordindex_12)
			{
				switch (*(x_BYTE *)(v114 + 1))
				{
				case 3:
				case 5:
				case 8:
				case 9:
				case 0xA:
				case 0xB:
				case 0xC:
				case 0xD:
				case 0xE:
					v56 = (int)v114;
					*(x_BYTE *)(v114 + 3) = 0;
					*(x_BYTE *)(v56 + 4) = 0;
					sub_6EDB0_set_mouse_position_by_res();
					break;
				default:
					break;
				}
			}
			sub_52E90((int)v18, *(char *)(v114 + 1), 1);
			goto LABEL_215;
		case 0x17:
			if (*(char *)(v114 + 2) != -1)
			{
				for (i = 0; i < 26; i++)
				{
					v58 = i + *(x_DWORD *)(v113 + 164);
					if (*(x_BYTE *)(v58 + 923) == *(x_BYTE *)(v114 + 2))
						*(x_BYTE *)(v58 + 923) = -1;
				}
				*(x_BYTE *)(*(char *)(v114 + 1) + *(x_DWORD *)(v113 + 164) + 923) = *(x_BYTE *)(v114 + 2);
				sub_6E450(0, *(x_WORD *)(v18 + 7), 14);
			}
			goto LABEL_215;
		case 0x19:
		case 0x1A:
			v59 = 0;
			for (j = (int)x_D41A0_BYTEARRAY_0; v59 < *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 14); j = (int)x_D41A0_BYTEARRAY_0)
			{
				v61 = 2124 * v59 + j;
				if (*(x_BYTE *)(v61 + 11236))
				{
					*(x_BYTE *)(v61 + 11234) = 1;
					sub_7373D(v59);
				}
				++v59;
			}
			goto LABEL_215;
		case 0x1B:
			sub_53120();
			v24 = v116;
			*(x_WORD *)(v18 + 2) = 10;
			sub_7373D(v24);
			goto LABEL_215;
		case 0x1C:
			v25 = v116;
			*(x_WORD *)(v18 + 2) = 12;
			sub_7373D(v25);
			goto LABEL_215;
		case 0x1D:
		LABEL_56:
			v26 = (char *)x_DWORD_E9C4C_langindexbuffer[283];
			v27 = (char *)(v18 + 28);
			do
			{
				v28 = *v26;
				*v27 = *v26;
				if (!v28)
					break;
				v29 = v26[1];
				v26 += 2;
				v27[1] = v29;
				v27 += 2;
			} while (v29);
			HIWORD(a1) = (unsigned int)(v18 + 28) >> 16;
			*(x_WORD *)(v18 + 79) = 1;
			v30 = v116;
			*(x_WORD *)(v18 + 77) = 100;
			*(x_WORD *)(v18 + 2) = 8;
			sub_7373D(v30);
			v31 = (int)x_D41A0_BYTEARRAY_4;
			*(x_BYTE *)(v18 + 6) = 0;
			if (*(x_BYTE *)(v31 + 22) & 0x10)
				sub_5E660(v113);
			LOWORD(a1) = x_D41A0_BYTEARRAY_4_struct.levelnumber_43;
			x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 &= 0xD9u;
			if ((unsigned __int16)a1 > 0x18u)
				*(x_BYTE *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11232) |= 0x10u;
			goto LABEL_215;
		case 0x1E:
			sub_53120();
			switch (*(x_BYTE *)(v114 + 1))
			{
			case 1:
				v112 = 0;
				break;
			case 2:
				v68 = sub_4A190(v113 + 76, 10, 39);
				if (v68)
				{
					v69 = (int)x_D41A0_BYTEARRAY_0;
					*(x_DWORD *)(v68 + 144) = 100000;
					*(x_WORD *)(v68 + 148) = (v113 - (v69 + 28302)) / 168;
				}
				*(x_DWORD *)(v113 + 144) = *(x_DWORD *)(v113 + 140);
				sub_52D70(v116, (char*)".. CHEAT: more mana");
				goto LABEL_215;
			case 3:
				for (k = x_D41A0_BYTEARRAY_4[0x9677]; k > x_DWORD_EA3E4[0]; k = *(x_DWORD *)k)
				{
					if (*(x_WORD *)(k + 26) != *(x_WORD *)(v113 + 26))
					{
						v71 = *(x_BYTE *)(k + 64);
						if (!v71 || v71 == 1)
							*(x_DWORD *)(k + 8) = -1;
					}
				}
				sub_52D70(v116, (char*)".. CHEAT: destroy all players");
				goto LABEL_215;
			case 4:
				for (l = x_D41A0_BYTEARRAY_4[0x9677]; l > x_DWORD_EA3E4[0]; l = *(x_DWORD *)l)
				{
					if (*(x_WORD *)(l + 26) != *(x_WORD *)(v113 + 26) && *(x_BYTE *)(l + 64) == 2)
						*(x_DWORD *)(l + 8) = -1;
				}
				sub_52D70(v116, (char*)".. CHEAT: destroy all castles");
				goto LABEL_215;
			case 5:
				for (m = x_D41A0_BYTEARRAY_4[0x9677]; m > x_DWORD_EA3E4[0]; m = *(x_DWORD *)m)
				{
					if (*(x_WORD *)(m + 26) != *(x_WORD *)(v113 + 26) && *(x_BYTE *)(m + 64) == 3)
						*(x_DWORD *)(m + 8) = -1;
				}
				sub_52D70(v116, (char*)".. CHEAT: destroy all balloons");
				goto LABEL_215;
			case 6:
				*(x_DWORD *)(v113 + 8) = *(x_DWORD *)(v113 + 4);
				sub_52D70(v116, (char*)".. CHEAT: heal");
				goto LABEL_215;
			case 7:
				sub_1B5F0();
				sub_52D70(v116, (char*)".. CHEAT: Kill all creatures");
				goto LABEL_215;
			case 8:
				v74 = 0;
				while (v74 < 26)
				{
					v75 = (unsigned __int8)x_BYTE_D94FF[v74++];
					*(x_DWORD *)(*(x_DWORD *)(v113 + 164) + 4 * v75 + 715) += 100;
				}
				sub_6DB50(0, 0);
				sub_52D70(v116, (char*)".. CHEAT: More Spell Experience Points");
				goto LABEL_215;
			case 9:
				v76 = x_D41A0_BYTEARRAY_4_struct.setting_byte3_24;
				if (v76 & 0x20)
				{
					x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 = v76 & 0xDF;
					sub_52D70(v116, (char*)".. CHEAT: Free Spell Usage OFF");
				}
				else
				{
					x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 = v76 | 0x20;
					sub_52D70(v116, (char*)".. CHEAT: Free Spell Usage ON");
				}
				goto LABEL_215;
			case 0xA:
				v77 = x_D41A0_BYTEARRAY_4_struct.setting_byte4_25;
				if (v77 & 1)
					x_D41A0_BYTEARRAY_4_struct.setting_byte4_25 = v77 & 0xFE;
				else
					x_D41A0_BYTEARRAY_4_struct.setting_byte4_25 = v77 | 1;
				if (x_D41A0_BYTEARRAY_4_struct.setting_byte4_25 & 1)
					sub_52D70(v116, (char*)".. CHEAT: Invincability ON");
				else
					sub_52D70(v116, (char*)".. CHEAT: Invincability OFF");
				goto LABEL_215;
			default:
				goto LABEL_215;
			}
			break;
		case 0x1F:
		case 0x20:
			if (*(char *)(v114 + 1) != -1)
			{
				sub_6E450(0, *(x_WORD *)(v18 + 7), 14);
				sub_87C10();
				v78 = (unsigned __int8)x_BYTE_D94FF[*(char *)(v114 + 1)];
				v79 = *(x_DWORD *)(v113 + 164) + 611;
				*(x_BYTE *)(v79 + (unsigned __int8)x_BYTE_D94FF[*(char *)(v114 + 1)] + 468) = *(x_BYTE *)(v114 + 2);
				if (*(x_BYTE *)v114 >= 0x1Fu)
				{
					if (*(x_BYTE *)v114 <= 0x1Fu)
					{
						v80 = (int)v114;
						*(x_WORD *)(v79 + 494) = v78;
						*(x_BYTE *)(v79 + 498) = *(x_BYTE *)(v80 + 2);
						x_D41A0_BYTEARRAY_4[38400] = 8;
					}
					else if (*(x_BYTE *)v114 == 32)
					{
						v81 = (int)v114;
						*(x_WORD *)(v79 + 496) = v78;
						*(x_BYTE *)(v79 + 499) = *(x_BYTE *)(v81 + 2);
						x_D41A0_BYTEARRAY_4[38401] = 8;
					}
				}
				v82 = v78;
				a1 = x_DWORD_EA3E4[*(signed __int16 *)(v79 + 2 * v78 + 208)];
				sub_6D5E0(x_DWORD_EA3E4[*(signed __int16 *)(v79 + 2 * v78 + 208)], *(x_BYTE *)(v114 + 2));
				sub_6D830(a1, *(x_BYTE *)(v114 + 2));
				if ((unsigned __int16)v116 == x_D41A0_BYTEARRAY_4_struct.dwordindex_12)
				{
					v83 = (char *)(v18 + 28);
					v84 = (char *)x_DWORD_E9C4C_langindexbuffer[x_WORD_DA82E[40 * v82 + 13 * *(char *)(v114 + 2)]];
					do
					{
						v85 = *v84;
						*v83 = *v84;
						if (!v85)
							break;
						v86 = v84[1];
						v84 += 2;
						v83[1] = v86;
						v83 += 2;
					} while (v86);
					a1 = (int)v18 + 28;
					*(x_WORD *)(v18 + 77) = 20;
					*(x_WORD *)(v18 + 79) = 3;
				}
				if (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 4)
				{
					v87 = x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
					if ((unsigned __int16)v116 == v87)
					{
						sub_6D200((int)x_D41A0_BYTEARRAY_0 + 11230 + 2124 * v87);
						sub_473B0();
					}
				}
			}
			goto LABEL_215;
		case 0x23:
			v93 = *(x_BYTE *)(v114 + 1);
			*(x_BYTE *)(v18 + 994) = 0;
			*(x_BYTE *)(v18 + 992) = v93;
			goto LABEL_215;
		case 0x24:
			*(x_BYTE *)(v18 + 993) = *(x_BYTE *)(v114 + 1);
			goto LABEL_215;
		case 0x25:
			if (*(x_BYTE *)(v18 + 993) == 3)
				*(x_BYTE *)(v18 + 995) ^= 1 << *(x_BYTE *)(v114 + 1);
			goto LABEL_215;
		case 0x26:
			*(x_BYTE *)(*(char *)(v114 + 1) + *(x_DWORD *)(v113 + 164) + 949) = *(x_BYTE *)(v114 + 2);
			sub_6E450(0, *(x_WORD *)(v18 + 7), 14);
			goto LABEL_215;
		case 0x27:
			v94 = (int)v114;
			*(x_BYTE *)(v114 + 3) = 0;
			v95 = *(x_BYTE *)(v94 + 1);
			*(x_BYTE *)(v94 + 4) = 0;
			if (v95)
			{
				v96 = v113;
				*(x_WORD *)(v113 + 130) = 0;
				*(x_WORD *)(*(x_DWORD *)(v96 + 164) + 12) = 0;
				LOWORD(a1) = *(x_WORD *)(*(x_DWORD *)(v113 + 164) + 825);
				if ((x_WORD)a1)
					*(x_WORD *)(x_DWORD_EA3E4[(signed __int16)a1] + 46) = 0;
			}
			if (*(x_WORD *)(v18 + 7) == *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12))
				sub_6EDB0_set_mouse_position_by_res();
			goto LABEL_215;
		case 0x28:
			if (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 4)
			{
				v88 = *(x_DWORD *)(v113 + 164);
				*(x_BYTE *)(v88 + 1112) = *(x_BYTE *)(v114 + 1);
				*(x_BYTE *)(v88 + 1111) = *(x_BYTE *)(v114 + 2);
				v89 = x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
				if ((unsigned __int16)v116 == v89)
				{
					sub_6D200(2124 * v89 + (int)x_D41A0_BYTEARRAY_0 + 11230);
					sub_473B0();
				}
			}
			goto LABEL_215;
		case 0x29:
			if (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 4)
			{
				v90 = *(x_DWORD *)(v113 + 164);
				v91 = x_BYTE_D94FF[*(char *)(v90 + 1112)];
				v90 += 611;
				*(x_BYTE *)(v90 + 502) = *(x_BYTE *)(v114 + 1);
				*(x_BYTE *)(v90 + v91 + 468) = *(x_BYTE *)(v114 + 1);
				v92 = x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
				if ((unsigned __int16)v116 == v92)
				{
					sub_6D200((int)x_D41A0_BYTEARRAY_0 + 11230 + 2124 * v92);
					sub_473B0();
				}
			}
			goto LABEL_215;
		case 0x2A:
			v97 = *(x_DWORD *)(v113 + 164);
			a1 = x_DWORD_EA3E4[0];
			v98 = x_DWORD_EA3E4[*(unsigned __int16 *)(v97 + 58)];
			if (v98 > x_DWORD_EA3E4[0])
			{
				if (*(x_DWORD *)(v98 + 16) == 1)
					*(x_BYTE *)(v97 + 446) = 1;
				*(x_DWORD *)(v98 + 8) = -1;
			}
			goto LABEL_215;
		case 0x2B:
			*(x_BYTE *)(v18 + 992) = *(x_BYTE *)(v114 + 1);
		LABEL_82:
			v45 = printbuffer;
			v46 = (char *)(48 * *(unsigned __int8 *)(v18 + 992) + v18 + 81);
			do
			{
				v47 = *v46;
				*v45 = *v46;
				if (!v47)
					break;
				v48 = v46[1];
				v46 += 2;
				v45[1] = v48;
				v45 += 2;
			} while (v48);
			a1 = (int)printbuffer;
			v118 = 0;
			if (printbuffer[0])
			{
				v118 = 1;
				if (x_toupper(printbuffer[0]) == 87
					&& x_toupper(v108) == 73
					&& x_toupper(v109) == 78
					&& x_toupper(v110) == 68
					&& x_toupper(v111) == 89)
				{
					if ((unsigned __int16)v116 == x_D41A0_BYTEARRAY_4_struct.dwordindex_12)
						x_D41A0_BYTEARRAY_4[0x17] |= 0x80u;
				}
				else
				{
					v117 = 0;
					v49 = x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
					if ((unsigned __int16)v116 == v49)
					{
					LABEL_98:
						v117 = 1;
					}
					else
					{
						v50 = 2124 * v49 + (int)x_D41A0_BYTEARRAY_0;
						switch (*(x_BYTE *)(v18 + 993))
						{
						case 0:
							v51 = sub_61810(v113, x_DWORD_EA3E4[*(unsigned __int16 *)(v50 + 11240)]) == 0;
							goto LABEL_97;
						case 1:
							a1 = v113;
							v51 = sub_61620(v113, x_DWORD_EA3E4[*(unsigned __int16 *)(v50 + 11240)]) == 0;
						LABEL_97:
							if (!v51)
								goto LABEL_98;
							break;
						case 2:
							goto LABEL_98;
						case 3:
							if ((1 << *(x_WORD *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 12284)) & *(unsigned __int8 *)(v18 + 995))
								goto LABEL_98;
							break;
						default:
							break;
						}
					}
					if (printbuffer[0])
					{
						v52 = printbuffer;
						v53 = (char *)(v18 + 28);
						do
						{
							v54 = *v52;
							*v53 = *v52;
							if (!v54)
								break;
							v55 = v52[1];
							v52 += 2;
							v53[1] = v55;
							v53 += 2;
						} while (v55);
						a1 = (int)v18 + 28;
						*(x_WORD *)(v18 + 77) = 200;
						*(x_WORD *)(v18 + 79) = 2;
					}
				}
			}
			sub_52E90((int)v18, 0, v118);
			goto LABEL_215;
		case 0x2C:
			v32 = *(unsigned __int8 *)(v18 + 992);
			*(x_BYTE *)(v18 + 994) = 0;
			*(x_BYTE *)(v18 + 48 * v32 + 81) = 0;
			sub_6E450(0, *(x_WORD *)(v18 + 7), 14);
			goto LABEL_215;
		default:
			goto LABEL_215;
		}
		do
		{
			v62 = 2 * v112;
			if (!*(x_WORD *)(2 * v112 + *(x_DWORD *)(v113 + 164) + 819))
			{
				v63 = (*(int(**)(int))((char *)&off_D781E + 14 * v112))(v113 + 76);
				if (v63)
				{
					a1 = (int)x_D41A0_BYTEARRAY_0 + 28302;
					*(x_BYTE *)(v63 + 12) |= 1u;
					v115 = 168;
					v64 = v113 - a1;
					*(x_DWORD *)(v63 + 136) = 0;
					*(x_WORD *)(v63 + 40) = v64 / 168;
					*(x_WORD *)(v62 + *(x_DWORD *)(v113 + 164) + 819) = (v63 - a1) / 168;
					for (n = 0; n < 10; ++n)
					{
						v66 = *(x_DWORD *)(v113 + 164) + n;
						if (*(char *)(v66 + 923) == -1)
						{
							*(x_BYTE *)(v66 + 923) = v112;
							break;
						}
					}
				}
			}
			++v112;
		} while (v112 < 26);
		for (ii = x_DWORD_EA3E8; ii < x_DWORD_EB384; ii += 168)
		{
			if (*(x_BYTE *)(ii + 63) == 11)
				*(x_BYTE *)(ii + 12) &= 0xFEu;
		}
		sub_52D70(v116, (char*)".. CHEAT: access all spells");
	LABEL_215:
		v99 = *(x_DWORD *)(v113 + 164);
		v100 = 2 * *(char *)(v114 + 3) - *(signed __int16 *)(v99 + 341);
		*(x_WORD *)(v99 + 4) = (signed int)(v100 - (__CFSHL__(HIDWORD(v100), 2) + 4 * HIDWORD(v100))) >> 2;
		v101 = *(x_DWORD *)(v113 + 164);
		v102 = 2 * *(char *)(v114 + 4) - *(signed __int16 *)(v101 + 343);
		LODWORD(v102) = (signed int)(v102 - (__CFSHL__(HIDWORD(v102), 2) + 4 * HIDWORD(v102))) >> 2;
		HIDWORD(v102) = (int)v114;
		*(x_WORD *)(v101 + 6) = v102;
		**(x_DWORD **)(v113 + 164) = *(unsigned __int8 *)(HIDWORD(v102) + 5);
		*(x_WORD *)(*(x_DWORD *)(v113 + 164) + 24) = *(x_WORD *)(v114 + 6);
		*(x_WORD *)(*(x_DWORD *)(v113 + 164) + 26) = *(x_WORD *)(v114 + 8);
		v103 = x_DWORD_EA3E4[*(unsigned __int16 *)(v18 + 10)];
		sub_57B20((int)v18, v103);
		if (*(x_BYTE *)(v18 + 2118))
			sub_55C60(a1, v103, (int)v18);
		a1 = (int)v114;
		v18 += 2124;
		v104 = v116 + 1;
		memset((void*)v114, 0, 10);
		v116 = v104;
		v114 = (Bit8u*)a1 + 10;
	}
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// 98805: using guessed type x_DWORD x_toupper(x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// D781E: using guessed type int (*off_D781E)(int);
// DA82E: using guessed type __int16 x_WORD_DA82E[];
// EA0B8: using guessed type int x_DWORD_EA0B8;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EA3E8: using guessed type int x_DWORD_EA3E8;
// EB384: using guessed type int x_DWORD_EB384;

//----- (00052D70) --------------------------------------------------------
char sub_52D70(unsigned __int16 a1, char *a2)
{
	char *v2; // esi
	int v3; // edx
	char *v4; // edi
	char result; // al

	v2 = a2;
	v3 = (int)x_D41A0_BYTEARRAY_0 + 11230 + 2124 * a1;
	v4 = (char *)(v3 + 28);
	do
	{
		result = *v2;
		*v4 = *v2;
		if (!result)
			break;
		result = v2[1];
		v2 += 2;
		v4[1] = result;
		v4 += 2;
	} while (result);
	*(x_WORD *)(v3 + 77) = 100;
	*(x_WORD *)(v3 + 79) = 1;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00052E90) --------------------------------------------------------
char sub_52E90(int a1, signed int a2, char a3)
{
	int v3; // edx
	unsigned __int16 v4; // ax
	__int16 v5; // ax
	int v6; // edx
	unsigned __int16 v8; // [esp+0h] [ebp-4h]

	v3 = (int)x_D41A0_BYTEARRAY_0;
	v4 = *(unsigned __int8 *)(a1 + 991);
	*(x_BYTE *)(a1 + 991) = a2;
	v8 = v4;
	if (*(x_WORD *)(a1 + 7) != *(x_WORD *)(v3 + 12))
		return sub_53120();
	x_D41A0_BYTEARRAY_4[38544] = v4;
	sub_87C10();
	if ((x_WORD)a2)
	{
		sub_41AF0();
	}
	else if (v8)
	{
		sub_41B60();
	}
	if ((x_WORD)a2 && ((unsigned __int16)a2 < 6u || (unsigned __int16)a2 > 7u))
	{
		if (x_WORD_1805C2 == 7 || x_WORD_1805C2 == 1 || x_WORD_1805C2 == 2)
			sub_8CD27_set_cursor(*filearray_2aa18c[x_BYTE_D419E].posistruct); // fix it
	}
	else if (x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 1)
	{
		if (x_WORD_1805C2 != 7 && x_WORD_1805C2 != 1 && x_WORD_1805C2 != 2)
			sub_8CD27_set_cursor(*filearray_2aa18c[0].posistruct);
		else
			sub_8CD27_set_cursor(*filearray_2aa18c[x_BYTE_D419E].posistruct); // fix it
	}
	else
	{
		sub_8CD27_set_cursor(*filearray_2aa18c[0].posistruct);
	}
	switch ((x_WORD)a2)
	{
	case 3:
	case 7:
	case 9:
	case 0xA:
	case 0xB:
	case 0xC:
	case 0xD:
	case 0xE:
		*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 224772) = 0;
		break;
	default:
		break;
	}
	switch (v8)
	{
	case 0u:
	case 6u:
		if ((x_WORD)a2 == v8 && !(x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 1))
			sub_548B0((__int16 *)a1);
		break;
	case 3u:
	case 5u:
	case 8u:
	case 9u:
	case 0xAu:
	case 0xBu:
	case 0xCu:
	case 0xDu:
	case 0xEu:
		sub_548B0((__int16 *)a1);
		sub_473B0();
		break;
	default:
		break;
	}
	switch ((x_WORD)a2)
	{
	case 0:
	case 6:
		if ((x_WORD)a2 == v8 && x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 1)
		{
			sub_6EDB0_set_mouse_position_by_res();
			goto LABEL_31;
		}
		break;
	case 3:
	case 5:
	case 8:
	LABEL_31:
		sub_548F0((x_WORD *)a1);
		break;
	case 9:
	case 0xB:
		sub_1A280();
		v5 = sub_1A4A0();
		v6 = (int)x_D41A0_BYTEARRAY_4;
		x_D41A0_BYTEARRAY_4[0xE1] = 1;
		*(x_WORD *)(v6 + 186) = v5;
		sub_548F0((x_WORD *)a1);
		break;
	case 0xA:
	case 0xC:
		sub_548F0((x_WORD *)a1);
		sub_19D60(a2, a1);
		break;
	case 0xD:
	case 0xE:
		sub_548F0((x_WORD *)a1);
		sub_1A030();
		break;
	default:
		break;
	}
	if ((unsigned __int16)a2 >= 5u)
	{
		if ((unsigned __int16)a2 > 5u)
		{
			if ((x_WORD)a2 != 8)
				goto LABEL_40;
			a3 = 0;
		}
		*(x_BYTE *)(a1 + 2109) = 0;
		sub_6D200(a1);
		sub_473B0();
	}
LABEL_40:
	if (v8 >= 5u && (v8 <= 5u || v8 == 8))
		a3 = 0;
	switch ((x_WORD)a2)
	{
	case 6:
	case 7:
	case 8:
	case 0xB:
	case 0xC:
	case 0xE:
		sub_2CA60(384, 0, 256, 400);
		break;
	default:
		sub_2CA90(*(char *)(x_D41A0_BYTEARRAY_0 + 8589));
		break;
	}
	if (a3)
		sub_6E450(0, *(x_WORD *)(a1 + 7), 14);
	return sub_53120();
}
// D419E: using guessed type char x_BYTE_D419E;
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EB394: using guessed type int **filearray_2aa18c[0];
// 1805C2: using guessed type __int16 x_WORD_1805C2;

//----- (00053120) --------------------------------------------------------
char sub_53120()
{
	int v0; // eax

	LOBYTE(v0) = (uint8)x_D41A0_BYTEARRAY_4;
	if (!(x_D41A0_BYTEARRAY_4[26] & 7))
	{
		LOBYTE(v0) = x_D41A0_BYTEARRAY_4[52] & 3;
		if ((x_BYTE)v0 == 1)
		{
			LOWORD(v0) = sub_10010();
			if (!v0)
			{
				LOBYTE(v0) = (int)x_D41A0_BYTEARRAY_0;
				*(x_BYTE *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11234) = 2;
			}
		}
	}
	return v0;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (00053160) --------------------------------------------------------
int sub_53160()
{
	int v0; // ebx
	int v1; // esi
	int v2; // eax
	__int16 v3; // ax
	__int16 v4; // dx
	int v5; // eax
	char *v6; // edi
	char *v7; // esi
	char v8; // al
	char v9; // al
	int result; // eax
	x_BYTE *v11; // [esp+4h] [ebp-Ch]
	unsigned __int16 v12; // [esp+8h] [ebp-8h]
	char v13; // [esp+Ch] [ebp-4h]

	v13 = 1;
	v12 = 0;
	v11 = (x_BYTE *)(x_D41A0_BYTEARRAY_0 + 28222);
	v0 = (int)x_D41A0_BYTEARRAY_0 + 11230;
	do
	{
		memset(v11, 0, 10);
		qmemcpy((void *)(x_D41A0_BYTEARRAY_4[0x100]), (void *)v0, 0x84Cu);
		memset((void*)v0, 0, 2124);
		v1 = x_D41A0_BYTEARRAY_4[0x8CF];
		qmemcpy((void *)(v0 + 1999), (void *)(x_D41A0_BYTEARRAY_4[0x8CF]), 0x18u);
		qmemcpy((void *)(v0 + 2023), (void *)(v1 + 24), 2u);
		if (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10)
			v13 = 0;
		if (v13)
			sub_549A0(v0 + 1609, x_D41A0_BYTEARRAY_4[0x749]);
		v2 = (int)x_D41A0_BYTEARRAY_4;
		*(x_DWORD *)(v0 + 24) = x_D41A0_BYTEARRAY_4[280];
		*v11 = 1;
		*(x_WORD *)(v0 + 7) = v12;
		if (!(*(x_BYTE *)(v2 + 22) & 0x10) && v12 != x_D41A0_BYTEARRAY_4_struct.dwordindex_12)
			*(x_BYTE *)(v0 + 9) = 1;
		*(x_WORD *)(v0 + 16) = 32;
		*(x_WORD *)(v0 + 477) = 128;
		v3 = *(x_WORD *)(v0 + 16);
		*(x_BYTE *)(v0 + 993) = 2;
		v4 = 0;
		*(x_WORD *)(v0 + 14) = v3 - 1;
		while (v4 < (signed int)*(unsigned __int16 *)(v0 + 16))
		{
			v5 = 7 * v4++;
			*(x_DWORD *)(v0 + 2 * v5 + 479) = *(x_DWORD *)(v0 + 465);
			*(x_DWORD *)(v0 + 2 * v5 + 483) = *(x_DWORD *)(v0 + 469);
			*(x_DWORD *)(v0 + 2 * v5 + 487) = *(x_DWORD *)(v0 + 473);
			*(x_WORD *)(v0 + 2 * v5 + 491) = *(x_WORD *)(v0 + 477);
		}
		if (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10)
			*(x_BYTE *)(v0 + 1446) = x_BYTE_E131C[v12];
		v6 = (char *)(v0 + 927);
		v7 = (char*)(&off_D93A0_wizards_names2)[sub_61790(v12)];
		do
		{
			v8 = *v7;
			*v6 = *v7;
			if (!v8)
				break;
			v9 = v7[1];
			v7 += 2;
			v6[1] = v9;
			v6 += 2;
		} while (v9);
		result = sub_54A50(v12, v0);
		v0 += 2124;
		v11 += 10;
		++v12;
	} while (v12 < 8u);
	return result;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// D93A0: using guessed type const char *off_D93A0_wizards_names2;

//----- (000533B0) --------------------------------------------------------
char sub_533B0_decompress_levels(__int16 a1, void *a2)
{
	Bit8u* v2; // edi
	FILE* levelsdatfile; // ebx
	FILE* levelstabfile; // esi
	int *v6; // eax
	int v7; // edi
	//char v8; // [esp+0h] [ebp-44h]
	int v9; // [esp+40h] [ebp-4h]

	v2 = (Bit8u*)x_DWORD_E9C38_smalltit;
	if (a1 < 1000)
	{
		sprintf_s(printbuffer, 512, "%c:%s/%s/levels.dat", x_D41A0_BYTEARRAY_4_struct.harddiskchar_byte4_182, "/netherw", "clevels");
		levelsdatfile = sub_98817_open(printbuffer, 512);
		if (levelsdatfile == NULL)
		{
			levelsdatfile = sub_98817_open((char*)"levels/levels.dat", 512);
			if (levelsdatfile == NULL)
				return 0;
		}
		sprintf_s(printbuffer, 512, "%c:%s/%s/levels.tab", x_D41A0_BYTEARRAY_4_struct.harddiskchar_byte4_182, "/netherw", "clevels");
		levelstabfile = sub_98817_open(printbuffer, 512);
		if (levelstabfile == NULL)
		{
			levelstabfile = sub_98817_open((char*)"levels/levels.tab", 512);
			if (levelstabfile == NULL)
			{
				sub_98882_close(levelsdatfile);
				return 0;
			}
		}
		sub_988A7_read(levelstabfile, v2, 4000);
		v6 = (int *)(v2 + 4 * a1);
		v7 = *v6;
		v9 = v6[1] - *v6;
		sub_98882_close(levelstabfile);
		if (x_filelength(levelsdatfile))
		{
			sub_9891E_seek(levelsdatfile, v7, 0);
			sub_988A7_read(levelsdatfile, (Bit8u*)x_DWORD_E9C38_smalltit, v9);
			if (sub_9894C_decompress((Bit8u*)x_DWORD_E9C38_smalltit, (Bit8u*)x_DWORD_E9C38_smalltit) < 0)
			{
				myprintf("ERROR decompressing levels.dat\n");
				return 0;
			}
			qmemcpy(a2, (void*)(const void *)x_DWORD_E9C38_smalltit, 0x6604u);
			memset((void*)x_DWORD_E9C38_smalltit, 0, 26116);
		}
		sub_98882_close(levelsdatfile);
		sub_56C00_sound_proc2((int)a2);
		sub_53590((int)a2);
	}
	return 1;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// 988DA: using guessed type x_DWORD filelength(x_DWORD);
// D41A4: using guessed type int x_DWORD_D41A4;
// E9C38: using guessed type int x_DWORD_E9C38_smalltit;

//----- (00053590) --------------------------------------------------------
int sub_53590(int a1)
{
	int result; // eax

	result = *(unsigned __int16 *)(a1 + 2);
	*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 4) = result;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00053770) --------------------------------------------------------
char sub_53770_test_open_moviegam(Bit16u gamnumber)
{
	FILE* gamxfile; // eax
	sprintf_s(printbuffer, 512, "%s/gam%05d.dat", "movie", gamnumber);
	gamxfile = sub_98817_open(printbuffer, 512);
	if (gamxfile == NULL)
		return 0;
	sub_98882_close(gamxfile);
	return 1;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);

//----- (00053950) --------------------------------------------------------
char sub_53950_test_open_moviemap(Bit16u mapnumeber)
{
	FILE* mapxfile; // eax
	sprintf_s(printbuffer, 512, "%s/map%05d.dat", "movie", mapnumeber);
	mapxfile = sub_98817_open(printbuffer, 512);
	if (mapxfile == NULL)
		return 0;
	sub_98882_close(mapxfile);
	return 1;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);

//----- (000539A0) --------------------------------------------------------
void sub_539A0_load_bldgprm()
{
	FILE* bldgprmfile = sub_98817_open((char*)"data/bldgprm.dat", 512);
	if (bldgprmfile >= 0)
	{
		sub_988A7_read(bldgprmfile, x_WORD_D93C0_bldgprmbuffer, 304);
		sub_98882_close(bldgprmfile);
	}
}
// D93C0: using guessed type __int16 x_WORD_D93C0_bldgprmbuffer[];

//----- (00053A40) --------------------------------------------------------
void sub_53A40(char *a1)
{
	char v1; // ah
	//FILE* moviemvidatfile; // eax
	int v3; // edx
	int v4; // edx
	char v5; // al
	//FILE* v6; // ecx
	char v7; // dh
	//FILE* v8; // edi
	//FILE* moviemvidatfile2; // eax
	int v10; // edx
	int v11; // edx
	char v12; // ch
	//FILE* v13; // eax
	//char v14; // [esp+0h] [ebp-48h]
	char v15; // [esp+40h] [ebp-8h]
	char v16; // [esp+44h] [ebp-4h]

	v1 = x_D41A0_BYTEARRAY_4_struct.setting_byte1_22;
	if (v1 & 4)
	{
		v15 = 0;
		if (!x_D41A0_BYTEARRAY_4_struct.moviemvidatfile_byte4_33 && !((signed int)&a1[-(int)x_D41A0_BYTEARRAY_0 - 28222] / 10))
		{
			sprintf_s(printbuffer, 512, "%s/mvi%05d.dat", "movie", x_D41A0_BYTEARRAY_4_struct.moviemvinumber_byte4_39);
			//moviemvidatfile = sub_98817_open(printbuffer, 512);
			v3 = (int)x_D41A0_BYTEARRAY_4;
			x_D41A0_BYTEARRAY_4_struct.moviemvidatfile_byte4_33 = sub_98817_open(printbuffer, 512);
			if (x_D41A0_BYTEARRAY_4_struct.moviemvidatfile_byte4_33 == NULL || !sub_54D30(*(x_WORD *)(v3 + 39)))
				v15 = 1;
			if (v15)
			{
				v4 = (int)x_D41A0_BYTEARRAY_4;
				v5 = x_D41A0_BYTEARRAY_4_struct.setting_byte1_22;
				x_D41A0_BYTEARRAY_4_struct.moviemvidatfile_byte4_33 = 0;
				*(x_BYTE *)(v4 + 22) = v5 & 0xFB;
			}
			else
			{
				sub_53C70();
			}
		}
		if (v15)
			goto LABEL_21;
		//v6 = x_D41A0_BYTEARRAY_4_struct.moviemvidatfile_byte4_33;
		if (!x_D41A0_BYTEARRAY_4_struct.moviemvidatfile_byte4_33)
			goto LABEL_21;
		if (*a1 != 2 && sub_988A7_read(x_D41A0_BYTEARRAY_4_struct.moviemvidatfile_byte4_33, (Bit8u*)a1, 10) == 10)
		{
			v7 = *a1;
			if (*a1 == 13)
			{
				*a1 = 0;
				goto LABEL_21;
			}
			if (v7 != 2 && v7 != 29 && !sub_473E0())
				goto LABEL_21;
		}
		v15 = 1;
	LABEL_21:
		if (v15)
		{
			sub_53CC0();
			*(x_WORD *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11232) = 8;
			sub_53CA0();
			a1[0] = 0;
		}
		return;
	}
	if (v1 & 2)
	{
		//v8 = x_D41A0_BYTEARRAY_4_struct.moviemvidatfile_byte4_33;
		v16 = 0;
		if (!x_D41A0_BYTEARRAY_4_struct.moviemvidatfile_byte4_33 && !((signed int)&a1[-(int)x_D41A0_BYTEARRAY_0 - 28222] / 10))
		{
			sprintf_s(printbuffer, 512, "%s/mvi%05d.dat", "movie", x_D41A0_BYTEARRAY_4_struct.moviemvinumber_byte4_39);
			//moviemvidatfile2 = sub_98817_open(printbuffer, 546);
			v10 = (int)x_D41A0_BYTEARRAY_4;
			x_D41A0_BYTEARRAY_4_struct.moviemvidatfile_byte4_33 = sub_98817_open(printbuffer, 546);
			if (x_D41A0_BYTEARRAY_4_struct.moviemvidatfile_byte4_33 == NULL || !sub_54F00(*(x_WORD *)(v10 + 39)))
				v16 = 1;
			if (v16)
			{
				v11 = (int)x_D41A0_BYTEARRAY_4;
				v12 = x_D41A0_BYTEARRAY_4_struct.setting_byte1_22;
				x_D41A0_BYTEARRAY_4_struct.moviemvidatfile_byte4_33 = 0;
				*(x_BYTE *)(v11 + 22) = v12 & 0xFD;
			}
			else
			{
				sub_53C70();
			}
		}
		if (!v16)
		{
			//v13 = x_D41A0_BYTEARRAY_4_struct.moviemvidatfile_byte4_33;
			if (x_D41A0_BYTEARRAY_4_struct.moviemvidatfile_byte4_33)
			{
				if (sub_98CAA_write(x_D41A0_BYTEARRAY_4_struct.moviemvidatfile_byte4_33, (Bit8u*)a1, 10) != 10)
					sub_53CC0();
				if (a1[0] == 12)
					a1[0] = 0;
			}
		}
	}
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (00053C70) --------------------------------------------------------
int sub_53C70()
{
	int result; // eax
	int v1; // edx

	result = (int)x_D41A0_BYTEARRAY_4;
	x_D41A0_BYTEARRAY_4[26] = 0;
	v1 = *(x_DWORD *)(result + 22);
	*(x_DWORD *)(result + 30) = 0;
	*(x_DWORD *)(result + 22) = v1 | 0x1208000;
	return result;
}
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (00053CA0) --------------------------------------------------------
int sub_53CA0()
{
	int result; // eax

	result = (int)x_D41A0_BYTEARRAY_4;
	*(x_DWORD *)(result + 22) &= 0xFEDF7FFF;
	return result;
}
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (00053CC0) --------------------------------------------------------
int sub_53CC0()
{
	int result; // eax
	char v1; // dl

	result = (int)x_D41A0_BYTEARRAY_4;
	if (x_D41A0_BYTEARRAY_4_struct.moviemvidatfile_byte4_33)
	{
		sub_98882_close((FILE*)x_D41A0_BYTEARRAY_4_struct.moviemvidatfile_byte4_33);
		result = (int)x_D41A0_BYTEARRAY_4;
		v1 = x_D41A0_BYTEARRAY_4_struct.setting_byte1_22;
		x_D41A0_BYTEARRAY_4_struct.moviemvidatfile_byte4_33 = 0;
		*(x_BYTE *)(result + 22) = v1 & 0xD9;
	}
	return result;
}
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (00053CF0) --------------------------------------------------------
int sub_53CF0_access(char* a1)
{
	return myaccess(a1, 0);
}
// 98CF2: using guessed type x_DWORD access(x_DWORD, x_DWORD);

//----- (00053D10) --------------------------------------------------------
Bit8u sub_53D10_create_nether_subdir(Bit8u a1, Bit8u* a2, Bit8u* a3)
{
	__int16 v3; // cx
	char result; // al
	char *v4; // esi
	char *v5; // edi
	char v6; // al
	char v7; // al
	char *v8; // esi
	char *v9; // edi
	char v10; // al
	char v11; // al
	char *v12; // esi
	char *v13; // edi
	char v14; // al
	char v15; // al
	//printbuffer -char v16; // [esp+0h] [ebp-12h]
	//char_355198 -
	char v17[144]; // [esp+90h] [ebp+7Eh]
	char v18; // [esp+120h] [ebp+10Eh] //fix it - minimal space or space struct

	//
	v3 = 0;//fix it
	//
	// ebx=0 esi=3532c1(c:\netherw.exe) edi=2b9ee0(0000) ebp=355250(80 52 35) eax=355228(c6 d2 26) edi=3=a1
	if (dos_getdiskfree(v3, (__int16)a3, a1 - 64, (short*)&v18))//234D3A - 26D1E8
		return 1;
	sprintf_s(printbuffer, 512, "%c:%s", a1, a2);//234D5E - 26F3D5
	if ((signed __int16)sub_53CF0_access(printbuffer) <= -1 && mymkdir(printbuffer))//234D6A - 234CF0 | 279D30
		return 2;
	v4 = printbuffer;
	v5 = v17;//355198 385235
	do
	{
		v6 = v4[0];//43
		v5[0] = v4[0];//prvni znak 5 se rovna prvnimu znaku
		if (!v6)
			break;
		v7 = v4[1];
		v4 += 2;
		v5[1] = v7;
		v5 += 2;
	} while (v7);
	v8 = (char*)"/";
	v9 = &v17[strlen(v17)];
	do
	{
		v10 = v8[0];
		v9[0] = v8[0];
		if (!v10)
			break;
		v11 = v8[1];
		v8 += 2;
		v9[1] = v11;
		v9 += 2;
	} while (v11);
	v12 = (char*)a3;
	v13 = &v17[strlen(v17)];
	do
	{
		v14 = *v12;
		*v13 = *v12;
		if (!v14)
			break;
		v15 = v12[1];
		v12 += 2;
		v13[1] = v15;
		v13 += 2;
	} while (v15);
	if ((sub_53CF0_access(v17) & 0x8000u) != 0 && mymkdir(v17))
		result = 2;
	else
		result = 3;
	return result;
}
// 8C1E8: using guessed type x_DWORD dos_getdiskfree(x_DWORD, x_DWORD);
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// 98D30: using guessed type x_DWORD mkdir(x_DWORD);
// 53D10: using guessed type char var_98[144];

//----- (00053E60) --------------------------------------------------------
int sub_53E60_readfile_and_decompress(const char* path, Bit8u** a2)
{
	x_DWORD result; // eax
	FILE* v3; // ebx
	Bit32u v4; // esi
	v3 = sub_98817_open((char*)path, 0x200);//234E72 - 279817
	result = (x_DWORD)v3;
	if (result != NULL)
	{
		v4 = x_filelength(v3);//234E82 - 2798DA
		sub_988A7_read(v3, *a2, v4);//234E8F - 2798A7
		sub_98882_close(v3);//234E98 - 279882
		result = (x_DWORD)sub_9894C_decompress(*a2, *a2);//234ea2 - 27994c
		if (result >= 0)
		{
			if (!result)
				result = v4;
		}
		else
		{
			myprintf("ERROR decompressing %s\n");
			result = -2;
		}
	}
	return result;
}
// 988DA: using guessed type x_DWORD filelength(x_DWORD);

//----- (00053EF0) --------------------------------------------------------
bool sub_53EF0_fileexist(char* path, char* path2)//fix a2
{
	FILE* testfile1; // eax
	FILE* testfile2; // eax
	bool result = false; // [esp+0h] [ebp-4h]
	testfile1 = sub_98817_open(path, 512);
	testfile2 = sub_98817_open(path2, 512);
	if (testfile1 == NULL || testfile2 == NULL)
		result = true;
	if (testfile1 != NULL)
		sub_98882_close(testfile1);
	if (testfile2 != NULL)
		sub_98882_close(testfile2);
	return result;
}

//----- (00053F60) --------------------------------------------------------
bool sub_53F60(char* a1)
{
	return myaccess(a1, 0) != NULL;//234F69 - 279CF2
}
// 98CF2: using guessed type x_DWORD access(x_DWORD, x_DWORD);

//----- (00053F80) --------------------------------------------------------
char sub_53F80(char* a1, char* a2, char* a3)
{
	FILE* v3; // ebx
	FILE* v4; // esi
	int v5; // eax
	int v6; // edi
	FILE* v8; // ebx
	FILE* v9; // edi
	signed int v10; // ebx
	int v11; // eax
	int v12; // esi
	int v13; // esi
	int v14; // eax


	char printbuffer[512] = { '\0' };//char v15; // [esp+0h] [ebp-194h]
	char printbuffer2[512] = { '\0' };//char v16; // [esp+90h] [ebp-104h]
	// x_DWORD_180628b_screen_buffer - readbuffer
	//printbuffer - char v17; // [esp+120h] [ebp-74h]
	int v18; // [esp+184h] [ebp-10h]
	int v19; // [esp+188h] [ebp-Ch]
	int v20; // [esp+18Ch] [ebp-8h]
	FILE* v21; // [esp+190h] [ebp-4h]

	if (!sub_53F60(a1))//234F90 - 234F60
		return 2;
	if (!sub_53F60(a2))//234FA5 - 234F60
		return 1;
	sprintf_s(printbuffer, 512, "%s/%s.tab", a1, a3);//234FCA - 269F3D5
	sprintf_s(printbuffer2, 512, "%s/%s.tab", a2, a3);//234FE3 - 269F3D5
	v3 = sub_98817_open(printbuffer, 0x200);//234FF7 - 279817
	if (v3 == NULL)//tady asi bude nerovnost
		return 3;
	v4 = sub_98817_open(printbuffer2, 0x222);//235012 - 279817
	if (v4 == NULL)
		return 3;
	v5 = x_filelength(v3);
	v6 = sub_988A7_read(v3, readbuffer, v5);
	v19 = sub_98CAA_write(v4, readbuffer, v6);
	sub_98882_close(v3);
	sub_98882_close(v4);
	if (v6 != v19)
		return 3;
	sprintf_s(printbuffer, 512, "%s/%s.dat", a1, a3);
	sprintf_s(printbuffer2, 512, "%s/%s.dat", a2, a3);
	v8 = sub_98817_open(printbuffer, 512);
	v21 = v8;
	if (v8 == NULL)
		return 3;
	v9 = sub_98817_open(printbuffer2, 546);
	if (v9 == NULL)
		return 3;
	v10 = x_filelength(v8);
	v18 = v10;
	v20 = 0;
	while (v10)
	{
		if (v10 <= 64000)
			v11 = v10;
		else
			v11 = 64000;
		v12 = sub_988A7_read(v21, readbuffer, v11);
		v10 -= v12;
		if (sub_98CAA_write(v9, readbuffer, v12) != v12)
		{
			sub_98882_close(v21);
			sub_98882_close(v9);
			return 3;
		}
		v20 += v12;
		v13 = v20;
		settextposition(x_DWORD_F4720.x, x_DWORD_F4720.y);
		v14 = 100 * v13 / v18;
		if (v14 > 100)
			v14 = 100;
		sprintf_s(printbuffer, 512, "%d%c", v14, 37);
		outtext(printbuffer);
	}
	sub_98882_close(v21);
	sub_98882_close(v9);
	memset(readbuffer, 0, 64000);
	return 0;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// 988DA: using guessed type x_DWORD filelength(x_DWORD);
// BD985: using guessed type x_DWORD settextposition(x_DWORD, x_DWORD);
// BDBED: using guessed type x_DWORD outtext(x_DWORD);
// F4720: using guessed type int x_DWORD_F4720;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;

//----- (00054200) --------------------------------------------------------
char sub_54200_create_user_directiores()//235200
{
	Bit8s v0l; // bx
	Bit8s v0h; // bx
	int v1; // eax
	int v2; // edx
	int v3; // eax
	int v4; // edx
	int v5; // eax
	int v6; // edx
	int v7; // eax
	//int v8; // edx
	//char* buffer; // [esp+0h] [ebp-2h]
	//char v11; // [esp+40h] [ebp+3Eh]
	//int v12; // [esp+80h] [ebp+7Eh]

	// fix if begin
	v2 = 0;
	v4 = 0;
	v6 = 0;
	v0h = 0;
	//v8 = 0;

	readbuffer[0] = 0x0;
	// end

	printbuffer[0] = 0;
	outtext((char*)"Checking Setup Version ..");//23521B - 29EBED
	v0l = 1;
	sprintf_s(printbuffer, 512, "%c:%s/%s/%s", x_D41A0_BYTEARRAY_4_struct.harddisk_number, "/netherw", "cdata", "version.dat");//235250 - 26F3D5
	sub_53E60_readfile_and_decompress(printbuffer, &readbuffer);//235260 - 234E60
	if (readbuffer[0] != 60)
		v0h = 1;
	outtext((char*)"\n");//235277 - 29EBED
	sprintf_s(printbuffer, 512, "%c:%s/%s/%s.dat", x_D41A0_BYTEARRAY_4_struct.harddisk_number, "/netherw", "cdata", "tmaps0-0");//2352A8 - 26F3D5
	sprintf_s(printbuffer2, 512, "data/%s.dat", "tmaps0-0");//2352BE - 26F3D5
	if (v0h || sub_53EF0_fileexist(printbuffer, printbuffer2))
	{
		//fix it - whne file not exist
		v1 = outtext((char*)"Creating Setup Directories 1 ..");//2352E4 -29EBED
		x_DWORD_F4720 = gettextposition();//2352EC - 29E953
		sprintf_s(printbuffer, 512, "%c:%s/%s", x_D41A0_BYTEARRAY_4_struct.harddisk_number, "/netherw", "cdata");//23531A - 26F3D5
		if (sub_53F80((char*)"data", printbuffer, (char*)"tmaps0-0"))//tohle musi nco vytvoit //235330 -234F80 //vytvoreni tmaps00 tab/dat
			v0l = 0;
		outtext((char*)"\n");//235343 - 29EBED
	}
	if (v0l)
	{
		sprintf_s(printbuffer, 512, "%c:%s/%s/%s.dat", x_D41A0_BYTEARRAY_4_struct.harddisk_number, "/netherw", "cdata", "tmaps1-0");//23537C - 26F3D5
		sprintf_s(printbuffer2, 512, "data/%s.dat", "tmaps1-0");//235392 - 26F3D5
		if (v0h || sub_53EF0_fileexist(printbuffer, printbuffer2))
		{
			//fix it - whne file not exist
			v3 = outtext((char*)"Creating Setup Directories 2 ..");
			x_DWORD_F4720 = gettextposition(/*v3, v4, v0*/);
			sprintf_s(printbuffer, 512, "%c:%s/%s", x_D41A0_BYTEARRAY_4_struct.harddisk_number, "/netherw", "cdata");//2353EE - 26F3D5
			if (sub_53F80((char*)"data", printbuffer, (char*)"tmaps1-0"))//235404 - 234F80
				v0l = 0;
			outtext((char*)"\n");
		}
	}
	if (v0l)
	{
		sprintf_s(printbuffer, 512, "%c:%s/%s/%s.dat", x_D41A0_BYTEARRAY_4_struct.harddisk_number, "/netherw", "cdata", "tmaps2-0");
		sprintf_s(printbuffer2, 512, "data/%s.dat", "tmaps2-0");
		if (v0h || sub_53EF0_fileexist(printbuffer, printbuffer2))
		{
			//fix it - whne file not exist
			v5 = outtext((char*)"Creating Setup Directories 3 ..");
			x_DWORD_F4720 = gettextposition(/*v5, v6, v0*/);
			sprintf_s(printbuffer, 512, "%c:%s/%s", x_D41A0_BYTEARRAY_4_struct.harddisk_number, "/netherw", "cdata");
			if (sub_53F80((char*)"data", printbuffer, (char*)"tmaps2-0"))
				v0l = 0;
			outtext((char*)"\n");
		}
	}
	if (v0l && !((x_D41A0_BYTEARRAY_4_struct.setting_byte1_22) & 8))//test it
	{
		sprintf_s(printbuffer, 512, "%c:%s/%s/levels.dat", x_D41A0_BYTEARRAY_4_struct.harddisk_number, "/netherw", "clevels");
		v7 = outtext((char*)"Setting Up Levels ..");
		x_DWORD_F4720 = gettextposition(/*v7, v8, v0*/);
		sprintf_s(printbuffer, 512, "%c:%s/%s", x_D41A0_BYTEARRAY_4_struct.harddisk_number, "/netherw", "clevels");
		if (sub_53F80((char*)"levels", printbuffer, (char*)"levels"))
			v0l = 0;
		outtext((char*)"\n");
	}
	if (v0l && v0h)
	{
		sprintf_s(printbuffer, 512, "%c:%s/%s/%s", x_D41A0_BYTEARRAY_4_struct.harddisk_number, "/netherw", "cdata", "version.dat");
		readbuffer[0] = 60;
		sub_98C48_open_nwrite_close(printbuffer, readbuffer, 4);
	}

	return v0l;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// BD953: using guessed type int /*__fastcall*/ gettextposition(x_DWORD, x_DWORD, x_DWORD);
// BDBED: using guessed type x_DWORD outtext(x_DWORD);
// D41A4: using guessed type int x_DWORD_D41A4;
// F4720: using guessed type int x_DWORD_F4720;

//----- (00054600) --------------------------------------------------------
void sub_54600_mouse_reset()//mouse reset
{
	int result; // eax
	//char v1; // [esp+0h] [ebp-38h]
	__int16 v2; // [esp+1Ch] [ebp-1Ch]

	v2 = 0;
	//result = int386(0x33, (REGS*)&v2, (REGS*)&v1);//Mouse Reset/Get Mouse Installed Flag //fix
	//result=1;
	x_DWORD_E3768 = 0;
	//return result;
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// E3768: using guessed type int x_DWORD_E3768;

//----- (00054630) --------------------------------------------------------
void sub_54630_load_psxblock(__int16 a1)//235630
{
	//__int16 result; // ax

	//result = a1;
	if ((unsigned __int16)a1 >= 0x10u)
	{
		if ((unsigned __int16)a1 <= 0x10u)
		{
			sub_84250_load_file_array(psxadatablock16dat);
		}
		else if (a1 == 32)
		{
			sub_84250_load_file_array(psxadatablock32dat);//psxadatablock32dat=~2a9e74
		}
	}
}

//----- (00054660) --------------------------------------------------------
int sub_54660_read_and_decompress_sky_and_blocks(Bit8u a1, Bit8u a2)//235660
{
	int result; // eax

	result = a2;
	if (a1 < 1u)
	{
		if (!a1)
		{
			if (a2 >= 0x10u)
			{
				if (a2 <= 0x10u)
				{
					sub_53E60_readfile_and_decompress("data/block16.dat", &BLOCK32DAT_BEGIN_BUFFER);//2bac2c
					sub_53E60_readfile_and_decompress("data/skyd0-0.dat", &off_D41A8);//2a51a8
				}
				else if (a2 == 32)
				{
					sub_53E60_readfile_and_decompress("data/block32.dat", &BLOCK32DAT_BEGIN_BUFFER);//2bac2c
					sub_53E60_readfile_and_decompress("data/skyd0-0.dat", &off_D41A8);//2a51a8
				}
			}
			result = sub_53E60_readfile_and_decompress("data/tmaps0-0.tab", &TMAPS00TAB_BEGIN_BUFFER);//2c7ed0
		}
	}
	else if (a1 <= 1u)
	{
		if (a2 >= 0x10u)
		{
			if (a2 <= 0x10u)
			{
				if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196306) & 2)
					sub_53E60_readfile_and_decompress("data/bl16f0-0.dat", &BLOCK32DAT_BEGIN_BUFFER);//2bac2c
				else
					sub_53E60_readfile_and_decompress("data/bl16n0-0.dat", &BLOCK32DAT_BEGIN_BUFFER);//2bac2c
				sub_53E60_readfile_and_decompress("data/skyn0-0.dat", &off_D41A8);//2a51a8
			}
			else if (a2 == 32)
			{
				if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196306) & 2)
					sub_53E60_readfile_and_decompress("data/bl32f0-0.dat", &BLOCK32DAT_BEGIN_BUFFER);//2bac2c
				else
					sub_53E60_readfile_and_decompress("data/bl32n0-0.dat", &BLOCK32DAT_BEGIN_BUFFER);//2bac2c
				sub_53E60_readfile_and_decompress("data/skyn0-0.dat", &off_D41A8);//2a51a8
			}
		}
		result = sub_53E60_readfile_and_decompress("data/tmaps1-0.tab", &TMAPS00TAB_BEGIN_BUFFER);//2c7ed0
	}
	else if (a1 == 2)
	{
		if (a2 >= 0x10u)
		{
			if (a2 <= 0x10u)
			{
				sub_53E60_readfile_and_decompress("data/bl16c0-0.dat", &BLOCK32DAT_BEGIN_BUFFER);//2bac2c
			}
			else if (a2 == 32)
			{
				sub_53E60_readfile_and_decompress("data/bl32c0-0.dat", &BLOCK32DAT_BEGIN_BUFFER);//2bac2c
			}
		}
		result = sub_53E60_readfile_and_decompress("data/tmaps2-0.tab", &TMAPS00TAB_BEGIN_BUFFER);//2c7ed0
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A8: using guessed type char *off_D41A8;
// E9C2C: using guessed type int x_DWORD_E9C2C;
// F6ED0: using guessed type int TMAPS00TAB_BEGIN_BUFFER;

//----- (00054800) --------------------------------------------------------
void sub_54800_read_and_decompress_tables(Bit8u a1)//235800
{
	if (a1 == 0)
	{
		sub_53E60_readfile_and_decompress("data/tablesd.dat", &x_BYTE_F6EE0_tables);//2c7ee0
		x_WORD_D4B7E = 0;
		x_WORD_D4B7C = 254;
	}
	else if (a1 == 1)
	{
		sub_53E60_readfile_and_decompress("data/tablesn.dat", &x_BYTE_F6EE0_tables);
		x_WORD_D4B7E = 255;
		x_WORD_D4B7C = 0;
	}
	else if (a1 == 2)
	{
		sub_53E60_readfile_and_decompress("data/tablesc.dat", &x_BYTE_F6EE0_tables);
		x_WORD_D4B7C = 254;
		x_WORD_D4B7E = 255;
	}
}
// D4B7C: using guessed type __int16 x_WORD_D4B7C;
// D4B7E: using guessed type __int16 x_WORD_D4B7E;

//----- (000548B0) --------------------------------------------------------
__int16 sub_548B0(__int16 *a1)
{
	__int16 result; // ax

	result = *(__int16 *)((char *)a1 + 7);
	if (result == *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12))
		result = sub_5BDC0_set_mouse_position(a1[509], a1[510]);
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (000548F0) --------------------------------------------------------
x_WORD *sub_548F0(x_WORD *a1)
{
	x_WORD *result; // eax
	__int16 v2; // dx

	result = a1;
	if (*(x_WORD *)((char *)a1 + 7) == *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12))
	{
		if (x_WORD_1805C2 != 7 && x_WORD_1805C2 != 1 && x_WORD_1805C2 != 2)
		{
			a1[509] = x_DWORD_1805B0;
			v2 = x_DWORD_1805B4;
		}
		else
		{
			a1[509] = x_WORD_E3760_mousex;
			v2 = x_WORD_E3762_mousey;
		}
		a1[510] = v2;
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// E3760: using guessed type __int16 x_WORD_E3760;
// E3762: using guessed type __int16 x_WORD_E3762;
// 1805B0: using guessed type int x_DWORD_1805B0;
// 1805B4: using guessed type int x_DWORD_1805B4;
// 1805C2: using guessed type __int16 x_WORD_1805C2;

//----- (00054960) --------------------------------------------------------
int sub_54960()
{
	Bit16s v0; // ax

	if (x_WORD_180660_VGA_type_resolution & 1)
		v0 = 400;
	else
		v0 = 480;
	return sub_5BDC0_set_mouse_position(426, v0 - 72 + 17);
}
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (000549A0) --------------------------------------------------------
signed int sub_549A0(int a1, int a2)
{
	signed int result; // eax

	qmemcpy((void *)(a1 + 390), (void *)(a2 + 390), 0x18u);
	qmemcpy((void *)(a1 + 414), (void *)(a2 + 414), 2u);
	qmemcpy((void *)a1, (void *)a2, 0x68u);
	qmemcpy((void *)(a1 + 442), (void *)(a2 + 442), 0x18u);
	qmemcpy((void *)(a1 + 466), (void *)(a2 + 466), 2u);
	qmemcpy((void *)(a1 + 338), (void *)(a2 + 338), 0x18u);
	qmemcpy((void *)(a1 + 362), (void *)(a2 + 362), 2u);
	result = 26;
	qmemcpy((void *)(a1 + 468), (void *)(a2 + 468), 0x18u);
	qmemcpy((void *)(a1 + 492), (void *)(a2 + 492), 2u);
	return result;
}

//----- (00054A50) --------------------------------------------------------
int sub_54A50(unsigned __int16 a1, int a2)
{
	signed int i; // eax
	int v3; // eax
	unsigned __int16 v4; // cx
	signed int v5; // esi
	int result; // eax
	int v7; // ebx
	char v8; // bl
	int v9; // ST00_4
	bool v10; // zf
	int v11; // edi
	signed int v12; // [esp+1Ch] [ebp-14h]
	int v13; // [esp+20h] [ebp-10h]
	int v14; // [esp+24h] [ebp-Ch]
	int v15; // [esp+28h] [ebp-8h]
	signed int v16; // [esp+2Ch] [ebp-4h]

	for (i = 0; i < 26; *(x_BYTE *)(a2 + i + 2076) = 0)
	{
		*(x_WORD *)(a2 + 2 * i++ + 1815) = 0;
		*(x_BYTE *)(a2 + i + 2024) = 0;
	}
	*(x_WORD *)(a2 + 2103) = -1;
	v3 = (int)x_D41A0_BYTEARRAY_4;
	*(x_WORD *)(a2 + 2105) = -1;
	if (*(x_BYTE *)(v3 + 22) & 0x10)
		v4 = 0;
	else
		v4 = a1;
	v5 = 0;
	v15 = 0;
	do
	{
		result = (unsigned __int8)x_BYTE_D94FF[v5];
		v7 = result + 110 * v4 + (int)x_D41A0_BYTEARRAY_0;
		if (*(x_BYTE *)(v7 + 221435) > 2u)
			*(x_BYTE *)(v7 + 221435) = 2;
		if (*(x_BYTE *)(a2 + 9) == 1)
		{
			*(x_BYTE *)(a2 + result + 2051) = *(x_BYTE *)(110 * v4 + x_D41A0_BYTEARRAY_0 + result + 221435);
		}
		else if (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 8 || x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10)
		{
			v12 = *(unsigned __int8 *)(110 * v4 + x_D41A0_BYTEARRAY_0 + result + 221435);
			if (*(char *)(a2 + result + 2051) < v12)
			{
				v16 = *(unsigned __int8 *)(110 * v4 + x_D41A0_BYTEARRAY_0 + result + 221435);
				if (v12 < 0)
					v16 = 0;
				if (v16 > 2)
					v16 = 2;
				*(x_BYTE *)(a2 + result + 2051) = v16;
				*(x_DWORD *)(a2 + 4 * result + 1609) = *(x_DWORD *)&*xadataspellsdat.var28_begin_buffer[80 * result + 18 + 26 * v16] + 1;
			}
		}
		*(x_BYTE *)(a2 + v5 + 1921) = -1;
		v8 = 0;
		v13 = a2 + result;
		if (*(x_BYTE *)(a2 + 9) == 1)
		{
			v9 = (int)x_D41A0_BYTEARRAY_0;
			*(x_BYTE *)(v13 + 1973) = *(x_BYTE *)(result + 110 * v4 + x_D41A0_BYTEARRAY_0 + 221461);
			if (!*(x_BYTE *)(result + 110 * a1 + v9 + 221409))
				goto LABEL_37;
			v10 = *(x_BYTE *)(v13 + 1973) == 0;
			goto LABEL_35;
		}
		v14 = result + 110 * v4 + (int)x_D41A0_BYTEARRAY_0;
		if (*(x_BYTE *)(v14 + 221461))
			goto LABEL_37;
		if (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10)
		{
			if (!*(x_BYTE *)(v14 + 221409))
				goto LABEL_37;
			v10 = *(x_BYTE *)(v14 + 221461) == 0;
		LABEL_35:
			if (!v10)
				goto LABEL_37;
			goto LABEL_36;
		}
		if (x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 >= 0 && x_D41A0_BYTEARRAY_4_struct.levelnumber_43)
		{
			if (!*(x_BYTE *)(v13 + 1999))
				goto LABEL_37;
		LABEL_36:
			v8 = 1;
			goto LABEL_37;
		}
		if (*(x_BYTE *)(a2 + result + 1999))
			goto LABEL_36;
		v11 = result + 110 * v4 + (int)x_D41A0_BYTEARRAY_0;
		if (*(x_BYTE *)(v11 + 221409))
		{
			if (!*(x_BYTE *)(v11 + 221461))
				goto LABEL_36;
		}
	LABEL_37:
		if (v8)
		{
			*(x_WORD *)(a2 + 2 * result + 1817) = 1;
			*(x_BYTE *)(a2 + result + 1999) = 1;
			if (*(signed __int16 *)(a2 + 2103) == -1)
			{
				*(x_WORD *)(a2 + 2103) = result;
			}
			else if (*(signed __int16 *)(a2 + 2105) == -1)
			{
				*(x_WORD *)(a2 + 2105) = result;
			}
			result = v15 + 1;
			*(x_BYTE *)(a2 + v15 + 1 + 1920) = v15;
			++v15;
		}
		++v5;
	} while (v5 < 26);
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (00054D30) --------------------------------------------------------
char sub_54D30(__int16 a1)
{
	FILE* moviesmapfile; // eax
	//FILE* v2; // ebx
	int v3; // eax
	x_DWORD *v4; // edi
	x_DWORD *v5; // edi
	char result; // al
	//char v7; // [esp+0h] [ebp-36h]
	int v8; // [esp+80h] [ebp+4Ah]
	int v9; // [esp+84h] [ebp+4Eh]
	int v10; // [esp+88h] [ebp+52h]
	int v11; // [esp+8Ch] [ebp+56h]
	int v12; // [esp+90h] [ebp+5Ah]
	int v13; // [esp+94h] [ebp+5Eh]
	int v14; // [esp+98h] [ebp+62h]
	int v15; // [esp+9Ch] [ebp+66h]
	int v16; // [esp+A0h] [ebp+6Ah]
	int v17; // [esp+A4h] [ebp+6Eh]
	int v18; // [esp+A8h] [ebp+72h]
	int v19; // [esp+ACh] [ebp+76h]
	char v20; // [esp+B0h] [ebp+7Ah]

	v20 = 1;
	v16 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8586);
	v17 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8590);
	v18 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8594);
	v19 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8598);
	v12 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8602);
	v13 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8606);
	v14 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8610);
	v15 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8614);
	v8 = x_D41A0_BYTEARRAY_4[0x21AA];
	v9 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8622);
	v10 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8626);
	v11 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8630);
	sprintf_s(printbuffer, 512, "%s/%s%03d.dat", "movie", "SMAP", a1);
	moviesmapfile = sub_98817_open(printbuffer, 512);
	//v2 = moviesmapfile;
	if (moviesmapfile >= 0)
	{
		sub_988A7_read(moviesmapfile, (Bit8u*)x_BYTE_10B4E0, 0x10000);
		sub_988A7_read(moviesmapfile, (Bit8u*)x_BYTE_11B4E0, 0x10000);
		sub_988A7_read(moviesmapfile, (Bit8u*)x_BYTE_12B4E0, 0x10000);
		sub_988A7_read(moviesmapfile, (Bit8u*)x_BYTE_13B4E0, 0x10000);
		sub_988A7_read(moviesmapfile, (Bit8u*)x_BYTE_14B4E0, 0x10000);
		sub_988A7_read(moviesmapfile, (Bit8u*)x_WORD_15B4E0, 0x20000);
		sub_988A7_read(moviesmapfile, (Bit8u*)x_BYTE_F2CD0, 4802);
		sub_98882_close(moviesmapfile);
	}
	sprintf_s(printbuffer, 512, "%s/%s%03d.dat", "movie", "SLEV", a1);
	sub_53E60_readfile_and_decompress(printbuffer, &x_D41A0_BYTEARRAY_0);
	sub_55100(2);
	sub_57680();
	sub_49F90();
	*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 4582) = -1;
	sub_71990();
	sub_473B0();
	v3 = (int)x_D41A0_BYTEARRAY_0;
	v4 = (x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8586);
	*v4 = v16;
	++v4;
	*v4 = v17;
	++v4;
	*v4 = v18;
	v4[1] = v19;
	*(x_DWORD *)(v3 + 8602) = v12;
	*(x_DWORD *)(v3 + 8606) = v13;
	*(x_DWORD *)(v3 + 8610) = v14;
	*(x_DWORD *)(v3 + 8614) = v15;
	v5 = (x_DWORD *)(v3 + 8618);
	result = v20;
	*v5 = v8;
	++v5;
	*v5 = v9;
	++v5;
	*v5 = v10;
	v5[1] = v11;
	return result;
}
// 10000: using guessed type void /*__noreturn*/ sub_10000();
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00054F00) --------------------------------------------------------
char sub_54F00(__int16 a1)
{
	Bit8u* v1; // ST0C_4
	FILE* v2; // eax
	FILE* v3; // ebx
	//char v5; // [esp+0h] [ebp-6h]
	char v6; // [esp+80h] [ebp+7Ah]

	v6 = 1;
	sub_71930();
	sub_55100(1);
	sprintf_s(printbuffer, 512, "%s/%s%03d.dat", "movie", "SLEV", a1);
	v1 = (Bit8u*)x_D41A0_BYTEARRAY_0;
	*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 224758) = (x_DWORD)&unk_D83AC;
	sub_98C48_open_nwrite_close(printbuffer, v1, 224791);
	sprintf_s(printbuffer, 512, "%s/%s%03d.dat", "movie", "SMAP", a1);
	v2 = sub_98817_open(printbuffer, 546);
	v3 = v2;
	if (v2 >= 0)
	{
		sub_98CAA_write(v2, (Bit8u*)x_BYTE_10B4E0, 0x10000);
		sub_98CAA_write(v3, (Bit8u*)x_BYTE_11B4E0, 0x10000);
		sub_98CAA_write(v3, (Bit8u*)x_BYTE_12B4E0, 0x10000);
		sub_98CAA_write(v3, (Bit8u*)x_BYTE_13B4E0, 0x10000);
		sub_98CAA_write(v3, (Bit8u*)x_BYTE_14B4E0, 0x10000);
		sub_98CAA_write(v3, (Bit8u*)x_WORD_15B4E0, 0x20000);
		sub_98CAA_write(v3, (Bit8u*)x_BYTE_F2CD0, 4802);
		sub_98882_close(v3);
	}
	sub_55100(2);
	sub_49F90();
	*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 4582) = -1;
	return v6;
}
// 10000: using guessed type void /*__noreturn*/ sub_10000();
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00055080) --------------------------------------------------------
char sub_55080(unsigned __int8 a1, int a2)
{
	char v2; // bl

	v2 = 0;
	if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10))
	{
		sub_71930();
		sub_55100(1);
		v2 = sub_55250(a1);
		if (v2)
		{
			v2 = sub_55320(a1);
			if (v2)
				v2 = sub_55450(a1, a2);
		}
		sub_55100(2);
		sub_49F90();
		*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 4582) = -1;
	}
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (00055100) --------------------------------------------------------
int sub_55100(char a1)
{
	int v1; // edi
	signed int v2; // eax
	int v3; // edx
	signed int v4; // ebx
	int v5; // esi
	int v6; // eax
	unsigned __int8 v7; // cl
	signed int i; // ebx
	unsigned __int8 v9; // al
	int v10; // eax
	unsigned int v11; // ecx
	int result; // eax
	signed int j; // ebx

	v1 = (int)x_D41A0_BYTEARRAY_0;
	if (a1 == 1)
		v2 = -1;
	else
		v2 = 1;
	v3 = v2 * (x_D41A0_BYTEARRAY_0[28302]);
	v4 = 0;
	v5 = v2 * ((int)x_D41A0_BYTEARRAY_0 + 197393);
	while (v4 < *(unsigned __int8 *)(v1 + 224769))
	{
		v6 = v1 + 10 * v4;
		if (!*(x_DWORD *)(v6 + 222546))
			goto LABEL_15;
		v7 = *(x_BYTE *)(v6 + 222540);
		if (v7 < 3u)
		{
			if (v7 < 1u)
				goto LABEL_15;
		LABEL_11:
			v6 = v1 + 10 * v4;
			if (!(*(x_BYTE *)(v6 + 222541) & 1))
			{
				*(x_DWORD *)(v6 + 222546) += v5;
				goto LABEL_15;
			}
		LABEL_14:
			*(x_DWORD *)(v6 + 222546) += v3;
			goto LABEL_15;
		}
		if (v7 <= 3u)
		{
			if (!(*(x_BYTE *)(v6 + 222541) & 1))
				goto LABEL_15;
			goto LABEL_14;
		}
		if (v7 == 4)
			goto LABEL_11;
	LABEL_15:
		++v4;
	}
	for (i = 1; ; i++)
	{
		result = v1;
		if (i > *(unsigned __int8 *)(v1 + 224768))
			break;
		v9 = *(x_BYTE *)(v1 + 8 * i + 222708);
		if (v9 >= 3u && (v9 <= 5u || v9 >= 8u && v9 <= 9u))
		{
			v10 = v1 + 8 * i;
			if (!(*(x_BYTE *)(v10 + 222709) & 2))
			{
				v11 = *(x_DWORD *)((char *)sub_365F8 + v10);
				if (v11 >= x_DWORD_EA3E4[0] && v11 < x_DWORD_EB384)
					*(x_DWORD *)((char *)sub_365F8 + v10) = v3 + v11;
			}
		}
	}
	for (j = 1; j < 50; j++)
	{
		result = v1 + 39 * j;
		if (*(x_BYTE *)(result + 222796))
			*(x_DWORD *)(result + 222806) += v3;
	}
	x_D41A0_BYTEARRAY_0 = (Bit8u*)v1;
	return result;
}
// 365F8: using guessed type int sub_365F8();
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB384: using guessed type int x_DWORD_EB384;

//----- (00055250) --------------------------------------------------------
char sub_55250(unsigned __int8 a1)
{
	char v1; // bl
	int v2; // eax
	int v3; // esi
	int v4; // edi
	int v5; // edx
	long v6; // eax
	Bit8u* v7; // ST14_4
	//char v9; // [esp+0h] [ebp-40h]

	//fix it
	v5 = 0;
	//fix it

	v1 = 0;
	sprintf_s(printbuffer, 512, "%c:%s/%s/%s%d.dat", x_D41A0_BYTEARRAY_4_struct.harddiskchar_byte4_182, "/netherw", "save", "SLEV", a1 + 1);
	v2 = (int)x_D41A0_BYTEARRAY_0;
	v3 = (int)x_D41A0_BYTEARRAY_0 + 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
	*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 224758) = (x_DWORD)&unk_D83AC;
	v4 = *(x_DWORD *)(v3 + 12621);
	v6 = j___clock();
	v7 = (Bit8u*)x_D41A0_BYTEARRAY_0;
	*(x_DWORD *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 12621) = v6 - *(x_DWORD *)(v3 + 12621);
	if (sub_98C48_open_nwrite_close(printbuffer, v7, 224791) == 224791)
		v1 = 1;
	*(x_DWORD *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 12621) = v4;
	return v1;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// 98786: using guessed type int /*__fastcall*/ j___clock(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (00055320) --------------------------------------------------------
bool sub_55320(unsigned __int8 a1)
{
	FILE* savesmapfile; // eax
	//FILE* v2; // ebx
	//char v4; // [esp+0h] [ebp-48h]
	size_t writedsize; // [esp+40h] [ebp-8h]
	//bool v6; // [esp+44h] [ebp-4h]

	//v6 = 0;
	sprintf_s(printbuffer, 512, "%c:%s/%s/%s%d.dat", x_D41A0_BYTEARRAY_4_struct.harddiskchar_byte4_182, "/netherw", "save", "SMAP", a1 + 1);
	savesmapfile = sub_98817_open(printbuffer, 546);
	//v2 = v1;
	if (savesmapfile >= 0)
	{
		sub_98CAA_write(savesmapfile, (Bit8u*)x_BYTE_10B4E0, (int)sub_10000);
		sub_98CAA_write(savesmapfile, (Bit8u*)x_BYTE_11B4E0, (int)sub_10000);
		sub_98CAA_write(savesmapfile, (Bit8u*)x_BYTE_12B4E0, (int)sub_10000);
		sub_98CAA_write(savesmapfile, (Bit8u*)x_BYTE_13B4E0, (int)sub_10000);
		sub_98CAA_write(savesmapfile, (Bit8u*)x_BYTE_14B4E0, (int)sub_10000);
		sub_98CAA_write(savesmapfile, (Bit8u*)x_WORD_15B4E0, (int)&loc_20000);
		writedsize = sub_98CAA_write(savesmapfile, (Bit8u*)x_BYTE_F2CD0, 4802) != 4802;
		sub_98882_close(savesmapfile);
		//v6 = v5 == 0;
	}
	return (writedsize == 0);
}
// 10000: using guessed type void /*__noreturn*/ sub_10000();
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (00055450) --------------------------------------------------------
char sub_55450(unsigned __int8 a1, int a2)
{
	char v2; // bl
	//char v4; // [esp+0h] [ebp-48h]
	int v5; // [esp+40h] [ebp-8h]
	int v6; // [esp+44h] [ebp-4h]

	v6 = a2;
	v5 = 15;
	v2 = 0;
	sprintf_s(printbuffer, 512, "%c:%s/%s/%s%d.dat", x_D41A0_BYTEARRAY_4_struct.harddiskchar_byte4_182, "/netherw", "save", "SVER", a1 + 1);
	if (sub_98C48_open_nwrite_close(printbuffer, (Bit8u*)&v5, 8) == 8)
		v2 = 1;
	return v2;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (000555D0) --------------------------------------------------------
char sub_555D0(unsigned __int8 a1, int a2)
{
	char v2; // bl
	int v3; // eax
	int v4; // edx
	int v5; // ecx
	int v6; // eax
	x_DWORD *v7; // edi
	int v9; // [esp+0h] [ebp-34h]
	int v10; // [esp+4h] [ebp-30h]
	int v11; // [esp+8h] [ebp-2Ch]
	int v12; // [esp+Ch] [ebp-28h]
	int v13; // [esp+10h] [ebp-24h]
	int v14; // [esp+14h] [ebp-20h]
	int v15; // [esp+18h] [ebp-1Ch]
	int v16; // [esp+1Ch] [ebp-18h]
	int v17; // [esp+20h] [ebp-14h]
	int v18; // [esp+24h] [ebp-10h]
	int v19; // [esp+28h] [ebp-Ch]
	int v20; // [esp+2Ch] [ebp-8h]

	v2 = 0;
	if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10))
	{
		v13 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8586);
		v14 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8590);
		v15 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8594);
		v16 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8598);
		v9 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8602);
		v10 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8606);
		v11 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8610);
		v12 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8614);
		v17 = x_D41A0_BYTEARRAY_4[0x21AA];
		v18 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8622);
		v19 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8626);
		v20 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8630);
		v2 = sub_55750(a1, a2);
		if (v2)
		{
			v2 = sub_558E0(a1);
			if (v2)
			{
				qmemcpy(
					(void *)(x_D41A0_BYTEARRAY_4[0x100]),
					(void *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11230),
					0x84Cu);
				v2 = sub_55A10(a1);
				if (v2)
				{
					sub_55100(2);
					sub_57680();
					sub_549A0(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + (int)x_D41A0_BYTEARRAY_0 + 11230 + 1609, x_D41A0_BYTEARRAY_4[0x749]);
					sub_49F90();
					v3 = (int)x_D41A0_BYTEARRAY_0;
					v4 = 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
					v5 = (int)x_D41A0_BYTEARRAY_0 + 11230;
					*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 4582) = -1;
					sub_55AB0(*(unsigned __int16 *)(v3 + 12), v5 + v4);
					sub_71990();
					sub_473B0();
				}
			}
		}
		v6 = (int)x_D41A0_BYTEARRAY_0;
		v7 = (x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8586);
		*v7 = v13;
		++v7;
		*v7 = v14;
		++v7;
		*v7 = v15;
		v7[1] = v16;
		*(x_DWORD *)(v6 + 8602) = v9;
		*(x_DWORD *)(v6 + 8606) = v10;
		*(x_DWORD *)(v6 + 8610) = v11;
		*(x_DWORD *)(v6 + 8614) = v12;
		*(x_DWORD *)(v6 + 8618) = v17;
		*(x_DWORD *)(v6 + 8622) = v18;
		*(x_DWORD *)(v6 + 8626) = v19;
		*(x_DWORD *)(v6 + 8630) = v20;
	}
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (00055750) --------------------------------------------------------
Bit8u sub_55750(unsigned __int8 a1, int a2)
{
	FILE* saveslevfile; // eax
	//FILE* v3; // esi
	int v4; // eax
	bool v5; // bl
	//Bit32u filesize2; // edi
	FILE* savesmapfile; // eax
	//FILE* v8; // ebx
	//Bit32u filesize; // esi
	//char v11; // [esp+0h] [ebp-54h]
	Bit8u* v12; // [esp+40h] [ebp-14h]
	int v13; // [esp+44h] [ebp-10h]
	char v14; // [esp+48h] [ebp-Ch]
	int v15; // [esp+4Ch] [ebp-8h]
	Bit8u result; // [esp+50h] [ebp-4h]

	//fix it
	v13 = 0;
	v15 = 0;
	//fix it

	//!!!!v12 fix

	result = 0;
	sprintf_s(printbuffer, 512, "%c:%s/%s/%s%d.dat", x_D41A0_BYTEARRAY_4_struct.harddiskchar_byte4_182, "/netherw", "save", "SVER", a1 + 1);
	if (sub_53E60_readfile_and_decompress(printbuffer, &v12) == 8 && v13 == a2 && v12 == (Bit8u*)15)
	{
		sprintf_s(printbuffer, 512, "%c:%s/%s/%s%d.dat", x_D41A0_BYTEARRAY_4_struct.harddiskchar_byte4_182, "/netherw", "save", "SLEV", a1 + 1);
		saveslevfile = sub_98817_open(printbuffer, 512);
		//v3 = saveslevfile;
		if (saveslevfile >= 0)
		{
			v4 = sub_988A7_read(saveslevfile, (Bit8u*)&v14, 8);
			v5 = v4 != 8;
			if (v4 == 8 && v15 != *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 4))
				v5 = 1;
			//filesize2 = x_filelength(saveslevfile);
			sub_98882_close(saveslevfile);
			if (x_filelength(saveslevfile) == 224791 && !v5)
			{
				sprintf_s(printbuffer, 512, "%c:%s/%s/%s%d.dat", x_D41A0_BYTEARRAY_4_struct.harddiskchar_byte4_182, "/netherw", "save", "SMAP", a1 + 1);
				savesmapfile = sub_98817_open(printbuffer, 512);
				//v8 = v7;
				if (savesmapfile >= 0)
				{
					//	filesize = x_filelength(savesmapfile);
					sub_98882_close(savesmapfile);
					if (x_filelength(savesmapfile) == 0x712C2)
						result = 1;
				}
			}
		}
	}
	return result;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// 988DA: using guessed type x_DWORD filelength(x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (000558E0) --------------------------------------------------------
bool sub_558E0(unsigned __int8 a1)
{
	FILE* savesmapfile; // eax
	//FILE* v2; // ebx
	//char v4; // [esp+0h] [ebp-48h]
	size_t readsize; // [esp+40h] [ebp-8h]
	//bool v6; // [esp+44h] [ebp-4h]

	//v6 = 0;
	sprintf_s(printbuffer, 512, "%c:%s/%s/%s%d.dat", x_D41A0_BYTEARRAY_4_struct.harddiskchar_byte4_182, "/netherw", "save", "SMAP", a1 + 1);
	savesmapfile = sub_98817_open(printbuffer, 512);
	//v2 = v1;
	if (savesmapfile >= 0)
	{
		sub_988A7_read(savesmapfile, (Bit8u*)x_BYTE_10B4E0, 0x10000);
		sub_988A7_read(savesmapfile, (Bit8u*)x_BYTE_11B4E0, 0x10000);
		sub_988A7_read(savesmapfile, (Bit8u*)x_BYTE_12B4E0, 0x10000);
		sub_988A7_read(savesmapfile, (Bit8u*)x_BYTE_13B4E0, 0x10000);
		sub_988A7_read(savesmapfile, (Bit8u*)x_BYTE_14B4E0, 0x10000);
		sub_988A7_read(savesmapfile, (Bit8u*)x_WORD_15B4E0, 0x20000);
		readsize = sub_988A7_read(savesmapfile, (Bit8u*)x_BYTE_F2CD0, 4802) != 4802;
		sub_98882_close(savesmapfile);
		//v6 = v5 == 0;
	}
	return (readsize == 0);
}
// 10000: using guessed type void /*__noreturn*/ sub_10000();
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (00055A10) --------------------------------------------------------
char sub_55A10(unsigned __int8 a1)
{
	char v1; // bl
	int v2; // edx
	int v3; // ebx
	//char v5; // [esp+0h] [ebp-40h]

	//fix it
	v2 = 0;
	//fix it

	v1 = 0;
	sprintf_s(printbuffer, 512, "%c:%s/%s/%s%d.dat", x_D41A0_BYTEARRAY_4_struct.harddiskchar_byte4_182, "/netherw", "save", "SLEV", a1 + 1);
	if (sub_53E60_readfile_and_decompress(printbuffer, &x_D41A0_BYTEARRAY_0) == 224791)
	{
		v3 = (int)x_D41A0_BYTEARRAY_0 + 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
		*(x_DWORD *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 12621) = j___clock() - *(x_DWORD *)(v3 + 12621);
		v1 = 1;
	}
	return v1;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// 98786: using guessed type int /*__fastcall*/ j___clock(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (00055AB0) --------------------------------------------------------
int sub_55AB0(int a1, int a2)
{
	int result; // eax
	signed int v3; // esi
	int v4; // edi
	int v5; // edx
	int v6; // ST0C_4
	int v7; // edx
	int v8; // ST08_4
	int v9; // edx
	int v10; // edx
	int v11; // [esp+4h] [ebp-8h]

	result = *(unsigned __int16 *)(a2 + 10);
	v3 = 0;
	v4 = x_DWORD_EA3E4[(unsigned __int16)result];
	while (v3 < 26)
	{
		v5 = (unsigned __int8)x_BYTE_D94FF[v3];
		result = a2 + v5;
		if (*(x_BYTE *)(a2 + v5 + 1999) || *(x_BYTE *)(result + 2025))
		{
			result = 2 * v5;
			v11 = a2 + 2 * v5;
			if (!*(x_WORD *)(v11 + 1817))
			{
				result = sub_4A190(v4 + 76, 15, v5);
				if (result)
				{
					v6 = (int)x_D41A0_BYTEARRAY_0 + 28302;
					*(x_WORD *)(v11 + 1817) = (result - (x_D41A0_BYTEARRAY_0[28302])) / 168;
					*(x_WORD *)(result + 40) = (v4 - v6) / 168;
					*(x_BYTE *)(result + 12) |= 1u;
					LOBYTE(result) = sub_6D5E0(result, *(x_BYTE *)(a2 + *(char *)(result + 64) + 2077));
				}
			}
		}
		else
		{
			v7 = a2 + 2 * v5;
			LOWORD(result) = *(x_WORD *)(v7 + 1817);
			if ((x_WORD)result)
			{
				v8 = x_DWORD_EA3E4[(signed __int16)result];
				*(x_WORD *)(v7 + 1817) = 0;
				result = sub_57F20(v8);
			}
		}
		++v3;
	}
	v9 = *(signed __int16 *)(a2 + 2103);
	if (v9 != -1 && !*(x_WORD *)(a2 + 2 * v9 + 1817))
		*(x_WORD *)(a2 + 2103) = -1;
	v10 = *(signed __int16 *)(a2 + 2105);
	if (v10 != -1 && !*(x_WORD *)(a2 + 2 * v10 + 1817))
		*(x_WORD *)(a2 + 2105) = -1;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00055C00) --------------------------------------------------------
char sub_55C00(__int16 a1)
{
	return sub_55750(0, a1);
}

//----- (00055C60) --------------------------------------------------------
unsigned int sub_55C60(int a1, int a2, int a3)
{
	unsigned int result; // eax
	int v4; // eax
	__int16 v5; // ax
	int v6; // edx
	char v7; // cl
	__int16 v8; // ax
	__int16 v9; // ax
	unsigned __int8 v10; // ch
	char v11; // dl
	__int16 v12; // ax
	__int16 v13; // dx
	signed int v14; // [esp+0h] [ebp-4h]

	//fix it
	v14 = 0;
	//fix it

	result = (unsigned int)x_D41A0_BYTEARRAY_4;
	if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 1))
	{
		v4 = abs(*(signed __int16 *)(a3 + 1339));
		if ((unsigned __int8)(*(x_BYTE *)(a3 + 2118) - 1) <= 6u)
			JUMPOUT(__CS__, (int*) *(&off_55C38 + (unsigned __int8)(*(x_BYTE *)(a3 + 2118) - 1)));
		if (*(x_BYTE *)(a3 + 2118) == 1)
		{
			if (*(x_WORD *)(a3 + 1339) >= 0)
				*(x_BYTE *)(a3 + 2119) = 1;
			else
				*(x_BYTE *)(a3 + 2119) = -1;
			v5 = abs(*(x_WORD *)(a3 + 1339));
			*(x_WORD *)(a3 + 2122) = 91;
			v6 = (int)x_D41A0_BYTEARRAY_4;
			v7 = *(x_BYTE *)(a3 + 2118);
			*(x_WORD *)(a3 + 2120) = v5;
			v8 = x_WORD_E3760_mousex;
			*(x_BYTE *)(a3 + 2118) = v7 + 1;
			*(x_WORD *)(v6 + 220) = v8;
			sub_55EB0(*(x_WORD *)(a3 + 10));
		}
		*(x_WORD *)(a3 + 2120) += a2 * *(x_WORD *)(a3 + 2122);
		if (a1)
		{
			v9 = a1 + *(x_WORD *)(a3 + 2122);
			*(x_WORD *)(a3 + 2122) = v9;
			if (v9 < 11)
				*(x_WORD *)(a3 + 2122) = 11;
			if (*(x_WORD *)(a3 + 2122) > 68)
				*(x_WORD *)(a3 + 2122) = 68;
		}
		if (a2 > 0 && *(signed __int16 *)(a3 + 2120) >= v14 || a2 < 0 && *(signed __int16 *)(a3 + 2120) <= v14)
		{
			v10 = *(x_BYTE *)(a3 + 2118) + 1;
			*(x_BYTE *)(a3 + 2118) = v10;
			if (v10 > 3u)
				*(x_WORD *)(a3 + 2122) >>= 1;
		}
		if (*(x_BYTE *)(a3 + 2118) >= 4u)
		{
			if (abs(x_WORD_E3760_mousex - x_D41A0_BYTEARRAY_4[0xDC]) > 16)
				*(x_BYTE *)(a3 + 2118) = 8;
			x_D41A0_BYTEARRAY_4[0xDC] = x_WORD_E3760_mousex;
		}
		v11 = *(x_BYTE *)(a3 + 2118);
		*(x_WORD *)(a3 + 1002) = 0;
		if (v11 == 8)
		{
			result = sub_55EB0(*(x_WORD *)(a3 + 10));
			*(x_BYTE *)(a3 + 2118) = 0;
		}
		else
		{
			v12 = *(x_WORD *)(a3 + 2120) * *(char *)(a3 + 2119);
			HIBYTE(v12) &= 7u;
			v13 = v12;
			result = *(unsigned __int16 *)(a3 + 16) - 1;
			*(x_WORD *)(a3 + 14 * result + 489) = v13;
		}
	}
	return result;
}
// 55C38: using guessed type void *off_55C38;
// D41A4: using guessed type int x_DWORD_D41A4;
// E3760: using guessed type int x_DWORD_E3760;

//----- (00055EB0) --------------------------------------------------------
unsigned int sub_55EB0(__int16 a1)
{
	unsigned int result; // eax
	unsigned int i; // edx

	result = 0;
	do
	{
		if (result < 0xC)
		{
			if (result == 1)
				goto LABEL_13;
		}
		else if (result <= 0xF || result >= 0x16 && result <= 0x17)
		{
			goto LABEL_13;
		}
		for (i = x_D41A0_BYTEARRAY_4[result + 38403]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
		{
			if (*(unsigned __int16 *)(i + 150) == a1)
				*(x_WORD *)(i + 150) = 0;
		}
	LABEL_13:
		++result;
	} while ((signed int)result < 29);
	return result;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];


//----- (00055F70) --------------------------------------------------------
int sub_main(int argc, char **argv, char **envp)//236F70
{

	*xadataclrd0dat.var28_begin_buffer = (Bit8u*)malloc(10000);//fix it

	*xadataspellsdat.var28_begin_buffer = (Bit8u*)malloc(50000);



	signed int v3; // edi
	unsigned __int16 v4; // si
	//skip __int16 v6; // [esp+0h] [ebp-1Ch]
	//__int16 v7; // [esp+Ch] [ebp-10h]

	//fix it
	v3 = 0;
	v4 = 0;
	//fix it

	//skip memset(&v6, 0, 28);//236F7F - 26D250
	//v7 = 0;
	//skip v6 = 0x3301;
	//skip int386(0x21, (REGS*)&v6, (REGS*)&v6);//236F9D - 279D52 //INT 21,33 - Get/Set System Values (Ctl-Break/Boot Drive) AH = 33h AL = 01 to set Ctrl - Break checking flag



	//skip signal(7, 1);//236FA9 - 279DC0
	//skip signal(4, 1);//236FB5 - 279DC0
	//skip signal(6, 1);//236FC1 - 279DC0

	readini((char*)"c:\\prenos\\remc2\\Debug\\config.ini");//tom

	VGA_Init();

	sub_56210_process_command_line(argc, argv);//236FD4 - 237210
	//-init 0x2a51a4 je nekde tu

	sub_5B8D0_initialize();//236FDC - 23C8D0//rozdil 1E1000
	x_BYTE_D41AD_skip_screen = config_skip_screen;
	sub_46830_main_loop(0, v3, v4);//227830
	sub_5BC20();//23CC20 //remove devices?
	sub_56730_clean_memory();//237730
	return 0;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// 98DC0: using guessed type x_DWORD signal(x_DWORD, x_DWORD);

//----- (000560D0) --------------------------------------------------------
void sub_560D0_create_sound_dir()
{
	FILE* diginifile2; // eax
	FILE* diginifile; // ebx
	FILE* mdiini; // eax
	FILE* mdiini2; // ebx
	//printbuffer char v5; // [esp+0h] [ebp-2Ah]
	//printbuffer2 char v6; // [esp+80h] [ebp+56h]
	//char v7; // [esp+A8h] [ebp+7Eh]


	//v7 = 1;
	sprintf_s(printbuffer, 512, "DEVICE\t\tNone\r\nDRIVER\t\tNone\r\nIO_ADDR\t\t-1\r\nIRQ\t\t-1\r\nDMA_8_BIT\t\t-1\r\nDMA_16_BIT\t\t-1\r\n");
	sprintf_s(printbuffer2, 512, "%c:%s/%s/dig.ini", x_D41A0_BYTEARRAY_4_struct.harddisk_number, "/netherw", "sound");
	diginifile2 = sub_98817_open(printbuffer2, 512);
	if (diginifile2 == NULL)
	{
		diginifile = sub_98817_open(printbuffer2, 546);
		if (diginifile != NULL)
		{
			sub_98CAA_write(diginifile, (Bit8u*)printbuffer, strlen(printbuffer));
			sub_98882_close(diginifile);
		}
	}
	else
	{
		sub_98882_close(diginifile2);
	}
	sprintf_s(printbuffer2, 512, "%c:%s/%s/mdi.ini", x_D41A0_BYTEARRAY_4_struct.harddisk_number, "/netherw", "sound");
	mdiini = sub_98817_open(printbuffer2, 512);
	if (mdiini == NULL)
	{
		mdiini2 = sub_98817_open(printbuffer2, 546);
		if (mdiini2 != NULL)
		{
			sub_98CAA_write(mdiini2, (Bit8u*)printbuffer, strlen(printbuffer));
			sub_98882_close(mdiini2);
		}
	}
	else
	{
		sub_98882_close(mdiini);
	}
	//return v7;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (00056210) --------------------------------------------------------
void sub_56210_process_command_line(int argc, char** argv)//237210
{
	Bit32s x_DWORD_355208;//3551CE+3A DWORD
	x_BYTE x_BYTE_355234_hardisknumber;//harddrive//3551CE+66 BYTE
	x_BYTE x_BYTE_35520C;//3551CE+3e BYTE
	x_BYTE x_BYTE_355210;//3551CE+42 BYTE
	x_BYTE x_BYTE_355230;//3551CE+62 BYTE
	x_BYTE x_BYTE_355218;//3551CE+4a BYTE
	x_BYTE x_BYTE_355244_spellsedit;//aSpellsedit//3551CE+76 BYTE
	x_BYTE x_BYTE_355240_load_set_level;//3551CE+72 BYTE
	x_BYTE x_BYTE_35522C_nocd;//nocd//3551CE+5e BYTE
	x_BYTE x_BYTE_355224_showversion;//Showversion//3551CE+56 BYTE
	x_BYTE x_BYTE_355228_showversion2;//Showversion2//3551CE+5a BYTE
	x_BYTE x_BYTE_355214;//3551CE+46 BYTE
	x_BYTE x_BYTE_35521C_cc;//3551CE+4e BYTE
	x_BYTE x_BYTE_35523C_detectoff;//Detectoff//3551CE+6e BYTE
	x_BYTE x_BYTE_355220_langcheck;//Langcheck//3551CE+52 BYTE
	x_BYTE x_BYTE_355238_music2;//aMusic2//3551CE+6a BYTE

	Bit8u argnumber; // ebx
	char arg0; // dl
	Bit8u *v4; // edi
	char *v5; // esi
	//char v6; // al
	char v7; // al
	//unsigned __int8 v8; // al
	//int v9; // ebx
	//char* v10; // esi
	int result; // eax
	Bit8u actarg[512]; // [esp+0h] [ebp-46h]
	//int v13; // [esp+80h] [ebp+3Ah]
	//char v14; // [esp+84h] [ebp+3Eh]
	//unsigned __int8 v15; // [esp+88h] [ebp+42h]
	//char v16; // [esp+8Ch] [ebp+46h]
	//char v17; // [esp+90h] [ebp+4Ah]
	//char v18; // [esp+94h] [ebp+4Eh]
	//char v19; // [esp+98h] [ebp+52h]
	//char v20; // [esp+9Ch] [ebp+56h]
	//char v21; // [esp+A0h] [ebp+5Ah]
	//char v22; // [esp+A4h] [ebp+5Eh]
	//char v23; // [esp+A8h] [ebp+62h]
	//unsigned __int8 v24; // [esp+ACh] [ebp+66h]
	//char v25; // [esp+B0h] [ebp+6Ah]
	//char v26; // [esp+B4h] [ebp+6Eh]
	//char v27; // [esp+B8h] [ebp+72h]
	//char v28; // [esp+BCh] [ebp+76h]
	//fix it:
	argnumber = 1;
	x_DWORD_355208/* v13*/ = -1;//3551CE+3A DWORD //355208
	x_BYTE_355234_hardisknumber/*v24*/ = 'C';//harddrive//3551CE+66 BYTE
	x_BYTE_35520C/*v14*/ = 0;//3551CE+3e BYTE
	x_BYTE_355210/*v15*/ = 0;//3551CE+42 BYTE
	x_BYTE_355230/*v23*/ = 0;//3551CE+62 BYTE
	x_BYTE_355218/*v17*/ = 0;//3551CE+4a BYTE
	x_BYTE_355244_spellsedit/*v28*/ = 0;//aSpellsedit//3551CE+76 BYTE
	x_BYTE_355240_load_set_level/*v27*/ = 0;//3551CE+72 BYTE
	x_BYTE_35522C_nocd/*v22*/ = 0;//nocd//3551CE+5e BYTE
	x_BYTE_355224_showversion/*v20*/ = 0;//Showversion//3551CE+56 BYTE
	x_BYTE_355228_showversion2/*v21*/ = 0;//Showversion2//3551CE+5a BYTE
	x_BYTE_355214/*v16*/ = 0;//3551CE+46 BYTE
	x_BYTE_35521C_cc/*v18*/ = 0;//3551CE+4e BYTE
	x_BYTE_35523C_detectoff/*v26*/ = 0;//Detectoff//3551CE+6e BYTE
	x_BYTE_355220_langcheck/*v19*/ = 0;//Langcheck//3551CE+52 BYTE
	x_BYTE_355238_music2/*v25*/ = 0;//aMusic2//3551CE+6a BYTE
	sub_89B60_aplicate_setting(7u);
	while (argnumber < argc)
	{
		arg0 = argv[argnumber][0];// **(x_BYTE **)((int)argv + 4 * v2);
		if (arg0 == '-' || arg0 == '/')
		{
			v4 = actarg;
			v5 = argv[argnumber] + 1;//(char *)(*(x_DWORD *)((int)argv + 4 * v2) + 1);
			do
			{
				//v6 = v5[0];
				v4[0] = v5[0];
				if (!v4[0])
					break;
				v7 = v5[1];
				v5 += 2;
				v4[1] = v7;
				v4 += 2;
			} while (v7);
		}
		if (_stricmp("network", (char*)actarg))
		{
			if (!_stricmp("level", (char*)actarg))
			{
				x_BYTE_355210 = atoi(argv[++argnumber]/* *(char**)((int)argv + 4 * ++v2)*/);//2372C4 - 279F5D
				x_BYTE_D419C_level_num = x_BYTE_355210;
				x_BYTE_355240_load_set_level = 1;
			}
			else if (!_stricmp("harddrive", (char*)actarg))
			{
				x_BYTE_355234_hardisknumber = x_toupper(argv[++argnumber][0]);//**(x_BYTE **)((int)argv + 4 * ++v2);
				//x_BYTE_355234_hardisknumber = x_toupper(x_BYTE_355234_hardisknumber);
			  //x_BYTE_355234_hardisknumber = v8;
				if (x_BYTE_355234_hardisknumber < 'A' || x_BYTE_355234_hardisknumber > 'Z')
					x_BYTE_355234_hardisknumber = 'C';
			}
			else if (!_stricmp("skipscreens", (char*)actarg))
			{
				x_BYTE_D41AD_skip_screen = 1;
			}
			else if (!_stricmp("nocd", (char*)actarg))
			{
				x_BYTE_35522C_nocd = 1;
			}
			else if (!_stricmp("showversion", (char*)actarg))
			{
				x_BYTE_355224_showversion = 1;
			}
			else if (!_stricmp("showversion2", (char*)actarg))
			{
				x_BYTE_355228_showversion2 = 1;
			}
			else if (!_stricmp("detectoff", (char*)actarg))
			{
				x_BYTE_35523C_detectoff = 1;
			}
			else if (!_stricmp("langcheck", (char*)actarg))
			{
				x_BYTE_355220_langcheck = 1;
			}
			else if (!_stricmp("vio", (char*)actarg))
			{
				//v9 = argnumber + 1;
				//v10 = argv[argnumber + 1];//*(x_DWORD *)((int)argv + 4 * v9);

				x_WORD_1805C4_vio1 = atoi(argv[argnumber + 1]);
				argnumber += 2;
				x_WORD_1805C6_vio2 = atoi(argv[argnumber]/* *(char**)((int)argv + 4 * v2)*/);
				sub_89B60_aplicate_setting(1u);
			}
			else if (!_stricmp("extern", (char*)actarg))
			{
				x_DWORD_E36C4 = atoi(argv[++argnumber]/* *(char **)((int)argv + 4 * ++v2)*/);
				myprintf("External ctrl at %ul\n");
				sub_89B60_aplicate_setting(6u);
			}
			else if (!_stricmp("VFX1", (char*)actarg))
			{
				sub_89B60_aplicate_setting(2u);
			}
			else if (!_stricmp("cc", (char*)actarg))
			{
				x_BYTE_35521C_cc = atoi(argv[++argnumber]/* *(char**)((int)argv + 4 * ++v2)*/);
			}
			else if (!_stricmp("spellsedit", (char*)actarg))
			{
				x_BYTE_355244_spellsedit = 1;
			}
			else if (!_stricmp("music2", (char*)actarg))
			{
				x_BYTE_355238_music2 = 1;
			}
		}
		++argnumber;
	}
	if (!x_BYTE_35522C_nocd)//if cd
		sub_86A00_some_allocs();//fix it -not at now
	x_D41A0_BYTEARRAY_0 = (Bit8u*)sub_83CD0_malloc2(0x36e17);//2A51A0
	if (!x_D41A0_BYTEARRAY_0)
	{
		myprintf("ERROR: CANT ALLOC CARPET MEMORY.");
		exit(-1);
	}
	x_D41A0_BYTEARRAY_4 = (Bit8u*)sub_83CD0_malloc2(0x9693);
	if (!x_D41A0_BYTEARRAY_4)
	{
		sub_83E80_sound_proc_99(x_D41A0_BYTEARRAY_0);
		myprintf("ERROR: CANT ALLOC TAPE MEMORY.");
		exit(-1);
	}
	/*memset((void*)x_D41A0_BYTEARRAY_0[0], 0, 224791);
	memset((void*)x_DWORD_D41A4, 0, 38547);*/
	memset((void*)x_D41A0_BYTEARRAY_0, 0, 0x36e17);
	memset((void*)x_D41A0_BYTEARRAY_4, 0, 0x9693);

	if (x_BYTE_35520C)
		x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 |= 0x800008u;
	if (x_BYTE_355230)
		x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 |= 2u;
	if (x_BYTE_355218)
		x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 |= 8u;
	if (x_BYTE_355244_spellsedit)
		x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 |= 0x10u;
	if (!x_BYTE_35522C_nocd && x_BYTE_E2A28)
		x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 |= 0x40u;
	if (x_BYTE_355240_load_set_level)
		x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 |= 0x80u;
	if (x_BYTE_355214)
		x_D41A0_BYTEARRAY_4_struct.setting_byte2_23 |= 2u;
	if (x_BYTE_355224_showversion)
		x_D41A0_BYTEARRAY_4_struct.setting_byte4_25 |= 8u;
	if (x_BYTE_355220_langcheck)
		x_D41A0_BYTEARRAY_4_struct.setting_byte4_25 |= 0x10u;
	if (x_BYTE_355238_music2)
		x_D41A0_BYTEARRAY_4_struct.setting_byte4_25 |= 0x40u;
	if (x_BYTE_35523C_detectoff)
		x_BYTE_E379B = 1;
	//result = x_D41A0_BYTEARRAY_4;
	x_D41A0_BYTEARRAY_4_struct.levelnumber_43 = x_BYTE_355210;
	x_D41A0_BYTEARRAY_4_struct.setting_45 = x_DWORD_355208;
	x_D41A0_BYTEARRAY_4_struct.harddisk_number = x_BYTE_355234_hardisknumber;
	if (x_BYTE_35521C_cc)
		x_D41A0_BYTEARRAY_4_struct.setting_byte4_25 = (x_D41A0_BYTEARRAY_4_struct.setting_byte4_25 | 4) & 0xFD;
	if (x_BYTE_355228_showversion2)
	{
		sub_70890_print_header();
		sub_5BC20();
		exit(1);
	}
	//return (int)x_D41A0_BYTEARRAY_4;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 98805: using guessed type x_DWORD x_toupper(x_DWORD);
// 98F5D: using guessed type x_DWORD stricmp(x_DWORD, x_DWORD);
// 98F9E: using guessed type x_DWORD unknown_libname_1_atoi(x_DWORD);
// D419C: using guessed type char x_BYTE_D419C_level_num;
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// D41AD: using guessed type char x_BYTE_D41AD_skip_screen;
// E2A28: using guessed type char x_BYTE_E2A28;
// E36C4: using guessed type int x_DWORD_E36C4;
// 1805C4: using guessed type __int16 x_WORD_1805C4_vio1;
// 1805C6: using guessed type __int16 x_WORD_1805C6_vio2;

//----- (00056730) --------------------------------------------------------
int sub_56730_clean_memory()
{
	return sub_8B5A0();
}

//----- (000567C0) --------------------------------------------------------
int sub_567C0()//2377c0
{
	int result; // eax
	int v1; // ebx

	memset((void*)(&x_D41A0_BYTEARRAY_0[16]), 0, 29);
	memset((void*)(&x_D41A0_BYTEARRAY_0[45]), 0, 4);
	memset((void*)(&x_D41A0_BYTEARRAY_0[49]), 0, 2);
	memset((void*)(&x_D41A0_BYTEARRAY_0[51]), 0, 2);
	memset((void*)(&x_D41A0_BYTEARRAY_0[53]), 0, 4);
	memset((void*)(&x_D41A0_BYTEARRAY_0[569]), 0, 1);
	memset((void*)(&x_D41A0_BYTEARRAY_0[222418]), 0, 108);
	memset((void*)(&x_D41A0_BYTEARRAY_0[9058]), 0, 48);
	memset((void*)(&x_D41A0_BYTEARRAY_0[28302]), 0, 168000);
	memset((void*)(&x_D41A0_BYTEARRAY_4[0x33]), 0, 1);
	memset((void*)(&x_D41A0_BYTEARRAY_4[0x79]), 0, 16);
	memset((void*)(&x_D41A0_BYTEARRAY_4[0xB2]), 0, 1);
	memset((void*)(&x_D41A0_BYTEARRAY_4[0xB4]), 0, 1);
	memset((void*)(&x_D41A0_BYTEARRAY_4[0xF2]), 0, 14);
	memset((void*)(&x_D41A0_BYTEARRAY_4[0x9603]), 0, 116);
	memset((void*)(&x_D41A0_BYTEARRAY_4[0x9677]), 0, 4);
	memset((void*)(&x_D41A0_BYTEARRAY_4[0x967B]), 0, 4);
	memset((void*)(&x_D41A0_BYTEARRAY_4[0x967F]), 0, 4);
	memset((void*)(&x_D41A0_BYTEARRAY_4[0x9683]), 0, 4);
	memset((void*)(&x_D41A0_BYTEARRAY_4[0x9687]), 0, 4);
	memset((void*)x_WORD_15B4E0, 0, 0x20000);
	memset((void*)x_BYTE_10B4E0, 0, 0x10000);
	memset((void*)x_BYTE_11B4E0, 0, 0x10000);
	memset((void*)x_BYTE_12B4E0, 0, 0x10000);
	memset((void*)x_BYTE_13B4E0, 0, 0x10000);
	memset((void*)x_DWORD_E9C38_smalltit, 0, 64000);
	result = (int)x_D41A0_BYTEARRAY_4;
	x_D41A0_BYTEARRAY_4_struct.setting_30 = 0;
	v1 = *(x_DWORD *)(result + 22);
	*(x_DWORD *)(result + 26) = 0;
	*(x_DWORD *)(result + 22) = v1 & 0xFFFE3FFF;
	return result;
}
// 10000: using guessed type void /*__noreturn*/ sub_10000();
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// E9C38: using guessed type int x_DWORD_E9C38_smalltit;

//----- (00056A30) --------------------------------------------------------
void sub_56A30_init_game_level(unsigned int a1)//237a30
{
	char v1; // bl
	Bit8u* v2; // eax
	int v3; // ST08_4

	v1 = x_BYTE_E3799;
	x_BYTE_E3799 = 0;
	sub_567C0();
	if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 8))
	{
		sub_70910_print_string((char*)"Load Level\0");
		sub_533B0_decompress_levels(x_D41A0_BYTEARRAY_4_struct.levelnumber_43, (void *)(x_D41A0_BYTEARRAY_0 + 196302));
	}
	sub_54660_read_and_decompress_sky_and_blocks(x_D41A0_BYTEARRAY_0[196308], x_BYTE_D41B5);//235660
	sub_54800_read_and_decompress_tables(x_D41A0_BYTEARRAY_0[196308]);//235800
	if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10))
		*(x_WORD *)(x_D41A0_BYTEARRAY_0 + 14) = *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 196311);
	sub_70910_print_string((char*)"Generate map\0");
	if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 4))
		sub_43830_generate_level_map(a1, x_D41A0_BYTEARRAY_0 + 196302);
	sub_49F30();
	sub_70910_print_string((char*)"Generate features\0");
	if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 4))
		sub_49270_generate_level_features(&x_D41A0_BYTEARRAY_0[196302]);
	sub_70910_print_string((char*)"Initialise Models\0");
	memset(&x_WORD_EB398, 0, 6);
	sub_49F90();
	v2 = x_D41A0_BYTEARRAY_0;
	x_D41A0_BYTEARRAY_0[4582] = -1;
	sub_71A70(v2[196308]);
	if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 4))
	{
		sub_58940(&x_D41A0_BYTEARRAY_0[196302]);
		sub_11EE0(&x_D41A0_BYTEARRAY_0[196302]);
		sub_84790();
	}
	sub_4A1E0(0, 1);
	x_BYTE_E3799 = v1;
	sub_53160();
	v3 = x_DWORD_EA3E4[*(unsigned __int16 *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240)];
	sub_60F00();
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// D41B5: using guessed type char x_BYTE_D41B5;
// E3799: using guessed type char x_BYTE_E3799;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;

//----- (00056C00) --------------------------------------------------------
int sub_56C00_sound_proc2(int a1)
{
	unsigned __int8 v1; // al
	int v2; // eax
	char v3; // cl
	int result; // eax

	x_BYTE_D41B6 = 0;
	x_BYTE_DA972[0] = 19;
	x_WORD_DAE1E = 245;
	x_WORD_DA96E = 199;
	v1 = *(x_BYTE *)(a1 + 6);
	x_BYTE_DAE22 = 19;
	if (v1 < 1u)
	{
		if (!v1)
		{
			x_BYTE_DA972[0] = 2;
			x_WORD_DA96E = 198;
			x_BYTE_DAE22 = 2;
			x_WORD_DAE1E = 244;
			*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8600) = 0;
			sub_84300_load_sound(0);
			x_BYTE_D419E = 1;
		}
	}
	else if (v1 <= 1u)
	{
		*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8600) = 0;
		sub_84300_load_sound(1u);
		x_BYTE_D419E = 9;
	}
	else if (v1 == 2)
	{
		*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8600) = 1;
		x_BYTE_D41B6 = 1;
		x_BYTE_D41B7 = *(x_BYTE *)(a1 + 5);
		sub_84300_load_sound(2u);
		x_BYTE_D419E = 10;
	}
	sub_5C0A0();
	v2 = (int)x_D41A0_BYTEARRAY_0;
	*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 224770) = 1;
	*(x_WORD *)(v2 + 224766) = 0;
	*(x_WORD *)(0x36DFC + v2) = 0;
	*(x_BYTE *)(v2 + 8625) = 0;
	v3 = *(x_BYTE *)(v2 + 224779);
	*(x_BYTE *)(v2 + 8593) = 0;
	*(x_BYTE *)(v2 + 224779) = v3 & 0xFC;
	result = (int)x_D41A0_BYTEARRAY_4;
	x_D41A0_BYTEARRAY_4[0x9692] = 0;
	if (x_WORD_180660_VGA_type_resolution == 1)
		x_BYTE_D419D = 1;
	else
		x_BYTE_D419D = 3;
	return result;
}
// D419D: using guessed type char x_BYTE_D419D;
// D419E: using guessed type char x_BYTE_D419E;
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// D41B6: using guessed type char x_BYTE_D41B6;
// D41B7: using guessed type char x_BYTE_D41B7;
// DA96E: using guessed type __int16 x_WORD_DA96E;
// DAE1E: using guessed type __int16 x_WORD_DAE1E;
// DAE22: using guessed type char x_BYTE_DAE22;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00056D60) --------------------------------------------------------
void sub_56D60(unsigned int a1, char a2)
{
	char v2; // bl
	Bit8u* v3; // ST08_4
	Bit8u* v4; // eax
	int v5; // ST08_4

	v2 = x_BYTE_E3799;
	x_BYTE_E3799 = 0;
	sub_567C0();
	sub_533B0_decompress_levels(x_D41A0_BYTEARRAY_4_struct.levelnumber_43, (void *)(x_D41A0_BYTEARRAY_0 + 196302));
	if (a2)
	{
		sub_54660_read_and_decompress_sky_and_blocks(*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308), x_BYTE_D41B5);
		sub_54800_read_and_decompress_tables(*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308));
	}
	v3 = x_D41A0_BYTEARRAY_0 + 196302;
	*(x_WORD *)(v3 - 196288) = *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 196311);
	sub_43830_generate_level_map(a1, v3);
	sub_49F30();
	sub_49270_generate_level_features(&x_D41A0_BYTEARRAY_0[196302]);
	memset(&x_WORD_EB398, 0, 6);
	sub_49F90();
	v4 = x_D41A0_BYTEARRAY_0;
	*(x_DWORD *)((int)x_D41A0_BYTEARRAY_0 + 4582) = -1;
	if (a2)
		sub_71A70(*(x_BYTE *)(v4 + 196308));
	sub_58940(&x_D41A0_BYTEARRAY_0[196302]);
	sub_11EE0(&x_D41A0_BYTEARRAY_0[196302]);
	sub_84790();
	sub_4A1E0(0, 1);
	x_BYTE_E3799 = v2;
	sub_53160();
	v5 = x_DWORD_EA3E4[*(unsigned __int16 *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240)];
	sub_60F00();
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// D41B5: using guessed type char x_BYTE_D41B5;
// E3799: using guessed type char x_BYTE_E3799;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;

//----- (00056EE0) --------------------------------------------------------
bool sub_56EE0(unsigned __int16 a1)
{
	char v1; // al

	v1 = x_BYTE_13B4E0[a1] & 7;
	return v1 != 5 && v1 != 2 && v1 != 3;
}

//----- (00056F10) --------------------------------------------------------
char sub_56F10(__int16 a1, __int16 a2, __int16 a3, char a4)
{
	signed __int16 v4; // bx
	char v5; // dh
	int v6; // edx
	int v7; // eax
	char v8; // dl
	unsigned __int16 v9; // bx
	char v11; // [esp+0h] [ebp-8h]
	unsigned __int16 v12; // [esp+4h] [ebp-4h]

	LOBYTE(v12) = a1;
	HIBYTE(v12) = a2;
	v11 = 0;
	v4 = a3 + x_BYTE_11B4E0[v12];
	if (v4 > 200)
	{
		v4 = 200;
		if (!a1 && !a2)
			v11 = 1;
	}
	if (v4 < 0)
	{
		v4 = 0;
		if (!a1 && !a2)
			v11 = 1;
	}
	if (a4 && x_BYTE_13B4E0[v12] < 0)
		return 1;
	v5 = x_BYTE_D41B6;
	x_BYTE_11B4E0[v12] = v4;
	if (v5)
	{
		v6 = (unsigned __int8)x_BYTE_14B4E0[v12] - a3;
		if (v6 >= 255)
			x_BYTE_14B4E0[v12] = -1;
		else
			x_BYTE_14B4E0[v12] = v6;
	}
	if (v4)
	{
		v7 = v12;
		v8 = x_BYTE_13B4E0[v12] & 0xF8 | 1;
	}
	else
	{
		LOBYTE(v9) = a1 - 1;
		HIBYTE(v9) = a2 - 1;
		if (!sub_56EE0(v9))
			goto LABEL_28;
		LOBYTE(v9) = v9 + 1;
		if (!sub_56EE0(v9))
			goto LABEL_28;
		LOBYTE(v9) = v9 + 1;
		if (!sub_56EE0(v9))
			goto LABEL_28;
		HIBYTE(v9) = a2;
		if (!sub_56EE0(v9))
			goto LABEL_28;
		LOBYTE(v9) = v9 - 2;
		if (!sub_56EE0(v9))
			goto LABEL_28;
		HIBYTE(v9) = a2 + 1;
		if (!sub_56EE0(v9))
			goto LABEL_28;
		LOBYTE(v9) = v9 + 1;
		if (!sub_56EE0(v9))
			goto LABEL_28;
		LOBYTE(v9) = v9 + 1;
		if (!sub_56EE0(v9))
			goto LABEL_28;
		v7 = v12;
		v8 = x_BYTE_13B4E0[v12] & 0xF0;
	}
	x_BYTE_13B4E0[v7] = v8;
LABEL_28:
	if (a4)
		sub_462A0(v12, v12);
	else
		sub_46570(v12, v12);
	return v11;
}
// D41B6: using guessed type char x_BYTE_D41B6;

//----- (000570F0) --------------------------------------------------------
char sub_570F0(__int16 a1, __int16 a2, signed __int16 a3, char a4, char a5, char a6)
{
	unsigned __int16 v6; // bx
	char v8; // [esp+0h] [ebp-8h]
	unsigned __int16 v9; // [esp+4h] [ebp-4h]

	LOBYTE(v9) = a1;
	HIBYTE(v9) = a2;
	v8 = 0;
	if (a3 > 255)
	{
		a3 = 255;
		if (!a1 && !a2)
			v8 = 1;
	}
	if (a3 < 0)
	{
		a3 = 0;
		if (!a1 && !a2)
			v8 = 1;
	}
	if (a4 && x_BYTE_13B4E0[v9] < 0)
		return 1;
	x_BYTE_11B4E0[v9] = a3;
	if (a5 || sub_57450(x_BYTE_10B4E0[v9]))
		x_BYTE_13B4E0[v9] = x_BYTE_13B4E0[v9] & 0xF8 | 1;
	if (!a3)
	{
		if (!a6)
			goto LABEL_32;
		LOBYTE(v6) = a1 - 1;
		HIBYTE(v6) = a2 - 1;
		if (sub_56EE0(v6))
		{
			LOBYTE(v6) = v6 + 1;
			if (sub_56EE0(v6))
			{
				LOBYTE(v6) = v6 + 1;
				if (sub_56EE0(v6))
				{
					HIBYTE(v6) = a2;
					if (sub_56EE0(v6))
					{
						LOBYTE(v6) = v6 - 2;
						if (sub_56EE0(v6))
						{
							HIBYTE(v6) = a2 + 1;
							if (sub_56EE0(v6))
							{
								LOBYTE(v6) = v6 + 1;
								if (sub_56EE0(v6))
								{
									LOBYTE(v6) = v6 + 1;
									if (sub_56EE0(v6))
										LABEL_32:
									x_BYTE_13B4E0[v9] &= 0xF0u;
								}
							}
						}
					}
				}
			}
		}
	}
	if (a4)
		sub_462A0(v9, v9);
	else
		sub_46570(v9, v9);
	return v8;
}

//----- (000572C0) --------------------------------------------------------
char sub_572C0(signed __int16 *a1, __int16 a2, __int16 a3, __int16 a4, char a5)
{
	int v5; // ebx
	int v6; // esi
	int v7; // edi
	int v8; // ebx
	int v10; // [esp+0h] [ebp-8h]
	int v11; // [esp+4h] [ebp-4h]

	LOWORD(v5) = a3;
	v6 = (a1[38] + 128) >> 8;
	v7 = (a1[39] + 128) >> 8;
	if (a3 > (a1[42] - (__CFSHL__(a1[42] >> 31, 8) + (a1[42] >> 31 << 8))) >> 8)
		v5 = (a1[42] - (__CFSHL__(a1[42] >> 31, 8) + (a1[42] >> 31 << 8))) >> 8;
	v8 = sub_10080(a2, (signed __int16)v5);
	if (!v8)
		return 0;
	do
	{
		if (sub_10130(v8, &v11, &v10) != 1)
		{
			sub_10100(v8);
			return 0;
		}
	} while (!sub_56F10(v6 + v11, v7 + v10, a4, a5));
	sub_10100(v8);
	return 1;
}

//----- (00057390) --------------------------------------------------------
unsigned __int8 sub_57390(unsigned __int16 a1, unsigned __int16 a2)
{
	unsigned __int8 result; // al
	int i; // ebx
	char v4; // ah
	int v5; // ebx

	result = a1;
	for (i = x_WORD_15B4E0[a1]; ; i = *(unsigned __int16 *)(v5 + 22))
	{
		v5 = x_DWORD_EA3E4[i];
		if (v5 == x_DWORD_EA3E4[0])
			break;
		result = a2;
		if (*(signed __int16 *)(v5 + 26) != a2)
		{
			result = *(x_BYTE *)(v5 + 63);
			if (result >= 2u)
			{
				if (result <= 2u)
				{
					sub_57F10(v5);
					continue;
				}
				if (result == 5)
				{
					v4 = 1;
					result = *(x_BYTE *)(v5 + 64);
					if (result < 0x10u)
					{
						if (result < 8u)
						{
							if (result != 6)
								goto LABEL_25;
						}
						else if (result > 8u && result != 10)
						{
							goto LABEL_25;
						}
					}
					else if (result > 0x10u)
					{
						if (result < 0x19u)
						{
							if (result < 0x16u || result > 0x17u)
								goto LABEL_25;
						}
						else if (result <= 0x19u)
						{
							if (*(x_BYTE *)(v5 + 69) != -56)
								goto LABEL_25;
						}
						else if (result != 27)
						{
						LABEL_25:
							if (v4)
							{
								*(x_DWORD *)(v5 + 8) = -1;
								*(x_WORD *)(v5 + 36) = a2;
								*(x_WORD *)(v5 + 38) = a2;
							}
							continue;
						}
					}
					v4 = 0;
					goto LABEL_25;
				}
			}
		}
	}
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00057450) --------------------------------------------------------
char sub_57450(unsigned __int8 a1)
{
	if (a1 < 0x53u)
	{
		if (a1 < 0x25u)
		{
			if (a1)
				return 0;
		}
		else if (a1 > 0x26u)
		{
			if (a1 >= 0x2Cu)
			{
				if (a1 > 0x2Fu && a1 != 81)
					return 0;
				return 1;
			}
			return 0;
		}
		return 1;
	}
	if (a1 <= 0x53u)
		return 1;
	if (a1 < 0x6Du)
	{
		if (a1 >= 0x68u)
		{
			if (a1 > 0x69u)
				return 0;
			return 1;
		}
		return 0;
	}
	if (a1 <= 0x6Du)
		return 1;
	if (a1 >= 0x72u)
	{
		if (a1 > 0x72u && a1 != 116)
			return 0;
		return 1;
	}
	return 0;
}

//----- (000574A0) --------------------------------------------------------
x_WORD *sub_574A0()
{
	x_WORD *result; // eax
	int v1; // ebx
	int v2; // edx

	result = (x_WORD *)x_D41A0_BYTEARRAY_4;
	if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10))
	{
		memset((void*)(x_D41A0_BYTEARRAY_0 + 222422), 0, 104);
		result = (x_WORD *)(0x30325 + x_D41A0_BYTEARRAY_0);
		v1 = *(x_DWORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240)]
			+ 164)
			+ 611;
		while ((unsigned int)result < (int)x_D41A0_BYTEARRAY_0 + 221393)
		{
			if (*result == 15)
			{
				v2 = (unsigned __int16)result[1];
				if (!*(x_WORD *)(v1 + 2 * (unsigned __int16)v2 + 208) && !*(x_BYTE *)(v2 + v1 + 390))
					++*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 4 * v2 + 222422);
			}
			result += 10;
		}
	}
	return result;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00057570) --------------------------------------------------------
int sub_57570()
{
	int result; // eax
	int v1; // edx
	char v2; // ch

	result = (int)x_D41A0_BYTEARRAY_4;
	if (!(x_D41A0_BYTEARRAY_4[0x17] & 1))
	{
		result = (int)x_D41A0_BYTEARRAY_0;
		v1 = x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
		if (x_BYTE_3659C[11 * v1 + (int)x_D41A0_BYTEARRAY_0])
		{
			result = 2124 * v1 + (int)x_D41A0_BYTEARRAY_0;
			v2 = *(x_BYTE *)(result + 11232);
			if (!(v2 & 0x10))
				*(x_BYTE *)(result + 11232) = v2 | 2;
		}
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (000575C0) --------------------------------------------------------
char sub_575C0()
{
	int v0; // edx
	int v1; // eax
	char v2; // dl

	v0 = 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
	LOBYTE(v1) = v0 + (int)x_D41A0_BYTEARRAY_0;
	v2 = *(x_BYTE *)(v0 + x_D41A0_BYTEARRAY_0 + 11232);
	if (v2 & 8)
	{
		if (v2 & 4)
		{
			LOBYTE(v1) = (uint8)x_D41A0_BYTEARRAY_4;
			if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10) && x_D41A0_BYTEARRAY_4[38545] < 0)
			{
				LOBYTE(v1) = sub_555D0(1u, x_D41A0_BYTEARRAY_4_struct.levelnumber_43);
				if ((x_BYTE)v1)
				{
					v1 = (int)x_D41A0_BYTEARRAY_0;
					*(x_BYTE *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + v1 + 11232) &= 0xF7u;
					*(x_BYTE *)(2124 * *(signed __int16 *)(v1 + 12) + v1 + 11232) &= 0xFBu;
				}
			}
		}
	}
	return v1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (00057640) --------------------------------------------------------
char sub_57640()
{
	int v0; // eax

	LOBYTE(v0) = (uint8)x_D41A0_BYTEARRAY_4;
	if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10) && x_D41A0_BYTEARRAY_4[38545] >= 0)
	{
		LOBYTE(v0) = sub_55080(1u, x_D41A0_BYTEARRAY_4_struct.levelnumber_43);
		if ((x_BYTE)v0)
		{
			v0 = (int)x_D41A0_BYTEARRAY_4;
			*(x_BYTE *)(v0 + 38545) |= 0x80u;
		}
	}
	return v0;
}
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (00057680) --------------------------------------------------------
unsigned int sub_57680()
{
	signed int v0; // edx
	int v1; // ebx
	int v2; // ecx
	unsigned int result; // eax
	char *i; // edx

	v0 = 0;
	while (v0 < *(unsigned __int16 *)(x_D41A0_BYTEARRAY_0 + 14))
	{
		v1 = (int)x_D41A0_BYTEARRAY_0 + 11230 + 2124 * v0;
		v2 = x_DWORD_EA3E4[*(unsigned __int16 *)(2124 * v0++ + x_D41A0_BYTEARRAY_0 + 11240)];
		*(x_DWORD *)(v2 + 164) = v1 + 998;
	}
	result = x_DWORD_EA3E8;
	for (i = (char *)&unk_D83AC - *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 224758); result < x_DWORD_EB384; result += 168)
	{
		if (*(x_BYTE *)(result + 63))
			*(x_DWORD *)(result + 160) += (int)i;
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EA3E8: using guessed type int x_DWORD_EA3E8;
// EB384: using guessed type int x_DWORD_EB384;

//----- (00057730) --------------------------------------------------------
char sub_57730()
{
	unsigned int i; // ebx
	int v1; // eax
	x_DWORD *v2; // esi
	x_DWORD *v3; // ecx
	x_DWORD *v4; // edx
	int *j; // eax
	char v6; // bl
	unsigned __int8 v7; // bl
	bool v8; // zf
	int v9; // ebx
	int **v10; // edi
	unsigned __int8 v11; // bl
	int v12; // ebx
	unsigned __int8 v13; // bl
	char result; // al
	signed int k; // esi
	unsigned int l; // ebx
	int v17; // ST08_4
	x_BYTE *m; // ebx
	char v19; // cl
	int v20; // eax
	__int16 v21; // si
	int v22[29]; // [esp+0h] [ebp-7Ch]
	x_DWORD *v23; // [esp+74h] [ebp-8h]
	x_DWORD *v24; // [esp+78h] [ebp-4h]

	*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8) = 9377 * *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8) + 9439;
	for (i = x_DWORD_EA3E8; i < x_DWORD_EB384; i += 168)
	{
		if (*(x_BYTE *)(i + 63) && *(x_BYTE *)(i + 13) & 4)
			sub_57F20(i);
	}
	memset(v22, 0, 116);
	memset((void*)(x_D41A0_BYTEARRAY_4[0x9603]), 0, 116);
	v1 = (int)x_D41A0_BYTEARRAY_4;
	v2 = 0;
	x_D41A0_BYTEARRAY_4[0x967B] = 0;
	v24 = 0;
	*(x_DWORD *)(v1 + 38527) = 0;
	v23 = 0;
	*(x_DWORD *)(v1 + 38519) = 0;
	*(x_DWORD *)(v1 + 38531) = 0;
	v3 = 0;
	*(x_DWORD *)(v1 + 38535) = 0;
	v4 = 0;
	for (j = (int *)x_DWORD_EA3E8; (unsigned int)j < x_DWORD_EB384; j += 42)
	{
		v6 = *((x_BYTE *)j + 63);
		if (v6)
		{
			switch (v6)
			{
			case 3:
				if (j[2] >= 0)
				{
					if (v3)
						*v3 = (x_DWORD)j;
					else
						x_D41A0_BYTEARRAY_4[0x9677] = (x_DWORD)j;
					v12 = x_DWORD_EA3E4[0];
					v3 = j;
					goto LABEL_60;
				}
				continue;
			case 5:
				if (j[2] < 0)
					continue;
				v7 = *((x_BYTE *)j + 69);
				if (v7 < 0xE8u)
				{
					v8 = v7 == -76;
				}
				else
				{
					if (v7 <= 0xE8u)
						continue;
					v8 = v7 == -22;
				}
				if (!v8)
				{
					v9 = *((char *)j + 64);
					v10 = (int **)v22[v9];
					if (v10)
						*v10 = j;
					else
						x_D41A0_BYTEARRAY_4[v9 * 4] = (x_DWORD)j;
					*j = x_DWORD_EA3E4[0];
					v22[*((char *)j + 64)] = (int)j;
				}
				continue;
			case 9:
				if (v23)
					*v23 = (x_DWORD)j;
				else
					x_D41A0_BYTEARRAY_4[0x9683] = (x_DWORD)j;
				v12 = x_DWORD_EA3E4[0];
				v23 = j;
				goto LABEL_60;
			case 10:
				v11 = *((x_BYTE *)j + 64);
				if (v11 < 0x2Du)
				{
					if (v11 < 0x27u)
						continue;
					if (v11 <= 0x28u)
						goto LABEL_32;
					if (v11 != 42)
						continue;
				LABEL_40:
					if (v4)
						*v4 = (x_DWORD)j;
					else
						x_D41A0_BYTEARRAY_4[38535] = (x_DWORD)j;
					*j = x_DWORD_EA3E4[0];
					v4 = j;
					continue;
				}
				if (v11 <= 0x2Du)
				{
					if (v24)
						*v24 = (x_DWORD)j;
					else
						x_D41A0_BYTEARRAY_4[0x967F] = (x_DWORD)j;
					v12 = x_DWORD_EA3E4[0];
					v24 = j;
					goto LABEL_60;
				}
				if (v11 < 0x43u)
				{
					if (v11 != 57)
						continue;
				LABEL_32:
					if (v2)
						*v2 = (x_DWORD)j;
					else
						x_D41A0_BYTEARRAY_4[0x967B] = (x_DWORD)j;
					v12 = x_DWORD_EA3E4[0];
					v2 = j;
				LABEL_60:
					*j = v12;
					continue;
				}
				if (v11 <= 0x43u || v11 == 78)
					goto LABEL_40;
				break;
			case 11:
				v13 = *((x_BYTE *)j + 64);
				if (v13 >= 0xCu && (v13 <= 0xCu || v13 == 31))
				{
					if (v4)
						*v4 = (x_DWORD)j;
					else
						x_D41A0_BYTEARRAY_4[38535] = (x_DWORD)j;
					*j = x_DWORD_EA3E4[0];
					v4 = j;
				}
				continue;
			default:
				continue;
			}
		}
	}
	result = (char)x_D41A0_BYTEARRAY_4;
	if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 1))
	{
		sub_12780();
		for (k = 0; k < 29; k++)
		{
			for (l = x_D41A0_BYTEARRAY_4[k + 38403]; l > x_DWORD_EA3E4[0]; l = *(x_DWORD *)l)
			{
				if (*(x_BYTE *)(l + 72) || *(x_BYTE *)(l + 73))
					sub_12500(l);
			}
		}
		if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10))
			sub_68BF0();
		sub_159E0();
		if (x_BYTE_D41B6)
			sub_58630();
		v17 = x_DWORD_EA3E4[*(unsigned __int16 *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240)];
		sub_60F00();
		for (m = (x_BYTE *)x_DWORD_EA3E8; (unsigned int)m < x_DWORD_EB384; m += 168)
		{
			v19 = m[63];
			if (v19)
			{
				v20 = 14 * (unsigned __int8)m[69] + *(int *)((char *)&x_DWORD_D4C52 + 18 * v19);
				if ((unsigned __int8)m[69] == *(x_WORD *)(v20 + 4))
				{
					if (*(x_DWORD *)(v20 + 10))
					{
						(*(void(**)(x_BYTE *))(v20 + 6))(m);
						++m[62];
					}
				}
				else
				{
					sub_57F10((int)m);
				}
			}
		}
		sub_585D0();
		result = (int)x_D41A0_BYTEARRAY_0;
		v21 = *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 222538);
		if (v21)
			result = sub_21F60(x_DWORD_EA3E4[v21]);
	}
	return result;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// D41B6: using guessed type char x_BYTE_D41B6;
// D4C52: using guessed type int x_DWORD_D4C52;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EA3E8: using guessed type int x_DWORD_EA3E8;
// EB384: using guessed type int x_DWORD_EB384;
// 57730: using guessed type int var_7C[29];

//----- (00057B20) --------------------------------------------------------
char sub_57B20(int a1, int a2)
{
	__int16 v2; // t1
	int v3; // edi
	int v4; // ecx

	if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 1))
	{
		*(x_WORD *)(a1 + 14 * (*(unsigned __int16 *)(a1 + 16) - 1) + 479) = *(x_WORD *)(a2 + 76);
		*(x_WORD *)(a1 + 14 * (*(unsigned __int16 *)(a1 + 16) - 1) + 481) = *(x_WORD *)(a2 + 78);
		sub_10C40((__int16 *)(a2 + 76));
		v2 = *(x_WORD *)(a2 + 80);
		*(x_WORD *)(14 * (*(unsigned __int16 *)(a1 + 16) - 1) + a1 + 483) = *(x_WORD *)(a2 + 80);
		*(x_WORD *)(14 * (*(unsigned __int16 *)(a1 + 16) - 1) + a1 + 485) = *(x_WORD *)(a2 + 28);
		*(x_WORD *)(a1 + 14 * (*(unsigned __int16 *)(a1 + 16) - 1) + 491) = *(x_WORD *)(a1 + 477);
		*(x_WORD *)(14 * (*(unsigned __int16 *)(a1 + 16) - 1) + a1 + 489) = *(x_WORD *)(*(x_DWORD *)(a2 + 164) + 341);
		v3 = *(x_DWORD *)(a2 + 164);
		v4 = *(signed __int16 *)(v3 + 30);
		*(x_WORD *)(a1 + 14 * (*(unsigned __int16 *)(a1 + 16) - 1) + 487) = *(x_WORD *)(v3 + 343) / 2
			+ x_D41A0_BYTEARRAY_4[0x7A]
			* (unsigned __int16)((signed int)(v4 - (__CFSHL__((unsigned __int64)*(signed __int16 *)(v3 + 30) >> 32, 4) + 16 * ((unsigned __int64)*(signed __int16 *)(v3 + 30) >> 32))) >> 4)
			- ((v4 - (__CFSHL__(v4 >> 31, 3) + 8 * (v4 >> 31))) >> 3);
		*(x_WORD *)(a1 + 14 * (*(unsigned __int16 *)(a1 + 16) - 1) + 485) += *(x_WORD *)(*(x_DWORD *)(a2 + 164) + 24);
		*(x_WORD *)(a1 + 14 * (*(unsigned __int16 *)(a1 + 16) - 1) + 487) += *(x_WORD *)(*(x_DWORD *)(a2 + 164) + 26);
	}
	return 1;
}
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (00057CF0) --------------------------------------------------------
signed int sub_57CF0(int a1, int a2)
{
	signed int result; // eax

	if (*(x_BYTE *)(a1 + 77) == *(x_BYTE *)(a2 + 1) && *(x_BYTE *)(a1 + 79) == *(x_BYTE *)(a2 + 3))
	{
		result = 0;
		*(x_DWORD *)(a1 + 76) = *(x_DWORD *)a2;
		*(x_WORD *)(a1 + 80) = *(x_WORD *)(a2 + 4);
	}
	else
	{
		sub_57E50(a1);
		sub_57D70(a1, a2);
		result = 1;
	}
	return result;
}

//----- (00057D40) --------------------------------------------------------
signed int sub_57D40(int a1, int a2)
{
	sub_57E50(a1);
	sub_57D70(a1, a2);
	return 1;
}

//----- (00057D70) --------------------------------------------------------
int sub_57D70(int a1, int a2)
{
	unsigned __int16 v2; // di
	int result; // eax

	if (!(*(x_BYTE *)(a1 + 12) & 4))
	{
		*(x_WORD *)(a1 + 24) = 0;
		v2 = x_WORD_15B4E0[(*(unsigned __int8 *)(a2 + 3) << 8) + *(unsigned __int8 *)(a2 + 1)];
		*(x_WORD *)(a1 + 22) = v2;
		if (v2)
			*(x_WORD *)(x_D41A0_BYTEARRAY_0 + 168 * v2 + 28326) = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
		result = (*(unsigned __int8 *)(a2 + 3) << 8) + *(unsigned __int8 *)(a2 + 1);
		x_WORD_15B4E0[result] = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
		*(x_DWORD *)(a1 + 76) = *(x_DWORD *)a2;
		*(x_WORD *)(a1 + 80) = *(x_WORD *)(a2 + 4);
		*(x_BYTE *)(a1 + 12) |= 4u;
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00057E50) --------------------------------------------------------
__int16 sub_57E50(int a1)
{
	__int16 result; // ax
	unsigned __int16 v2; // cx

	if (*(x_BYTE *)(a1 + 12) & 4)
	{
		if (*(x_WORD *)(a1 + 24))
		{
			result = *(x_WORD *)(a1 + 22);
			*(x_WORD *)(168 * *(unsigned __int16 *)(a1 + 24) + x_D41A0_BYTEARRAY_0 + 28324) = result;
		}
		else
		{
			result = *(x_WORD *)(a1 + 22);
			x_WORD_15B4E0[*(unsigned __int8 *)(a1 + 77) + (*(unsigned __int8 *)(a1 + 79) << 8)] = result;
		}
		v2 = *(x_WORD *)(a1 + 22);
		if (v2)
		{
			result = *(x_WORD *)(a1 + 24);
			*(x_WORD *)(x_D41A0_BYTEARRAY_0 + 168 * v2 + 28326) = result;
		}
		*(x_BYTE *)(a1 + 12) &= 0xFBu;
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00057F10) --------------------------------------------------------
void sub_57F10(int a1)
{
	//int result; // eax

	//result = a1;
	*(x_BYTE *)(a1 + 13) |= 4u;
	//return result;
}

//----- (00057F20) --------------------------------------------------------
int sub_57F20(int a1)
{
	int v1; // edx
	signed int v2; // ecx
	x_DWORD *v3; // eax
	int v4; // edx
	int result; // eax
	int v6; // edx

	sub_57E50(a1);
	if (*(x_BYTE *)(a1 + 14) & 2)
	{
		v1 = 0;
		v2 = 0;
		v3 = (x_DWORD *)(x_D41A0_BYTEARRAY_0 + 4586);
		while (v1 <= *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 4582))
		{
			if (a1 == *v3)
			{
				v2 = 1;
				break;
			}
			++v3;
			++v1;
		}
		if (v2)
		{
			v4 = (int)x_D41A0_BYTEARRAY_0;
			*v3 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 4 * *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 4582) + 4586);
			--*(x_DWORD *)(v4 + 4582);
		}
	}
	result = (int)x_D41A0_BYTEARRAY_0;
	*(x_BYTE *)(a1 + 63) = 0;
	v6 = *(x_DWORD *)(result + 53) + 1;
	*(x_DWORD *)(result + 53) = v6;
	*(x_DWORD *)(result + 4 * v6 + 582) = a1;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00057FA0) --------------------------------------------------------
x_WORD *sub_57FA0(x_WORD *a1, unsigned __int16 a2, __int16 a3, __int16 a4)
{
	x_WORD *result; // eax
	unsigned __int16 v5; // bx
	int v6; // edx

	result = a1;
	LOBYTE(v5) = a3;
	LOWORD(v6) = a4;
	if (a4)
	{
		HIBYTE(v5) = HIBYTE(a3) & 7;
		HIBYTE(a2) &= 7u;
		if (v5)
		{
			a1[2] -= (unsigned int)(a4 * x_DWORD_DB750[v5]) >> 16;
			v6 = a4 * (signed int)off_DBF50[v5] >> 16;
		}
		*a1 += (unsigned int)((signed __int16)v6 * x_DWORD_DB750[a2]) >> 16;
		a1[1] -= (unsigned int)((x_DWORD)off_DBF50[a2] * (signed __int16)v6) >> 16;
	}
	return result;
}
// DBF50: using guessed type void (/*__noreturn*/ *off_DBF50[2])();

//----- (00058030) --------------------------------------------------------
x_WORD *sub_58030(int a1, x_WORD *a2)
{
	x_WORD *result; // eax
	unsigned __int16 v3; // dx
	unsigned __int8 v4; // bl
	unsigned __int8 v5; // bl
	unsigned __int8 v6; // bl

	result = a2;
	LOBYTE(v3) = *(x_BYTE *)(a1 + 1);
	HIBYTE(v3) = *(x_BYTE *)(a1 + 3);
	v4 = x_BYTE_11B4E0[v3];
	*a2 = v4;
	LOBYTE(v3) = v3 + 1;
	a2[1] = v4;
	*a2 -= x_BYTE_11B4E0[v3];
	v5 = x_BYTE_11B4E0[v3];
	++HIBYTE(v3);
	result[1] += v5;
	*a2 -= x_BYTE_11B4E0[v3];
	v6 = x_BYTE_11B4E0[v3];
	LOBYTE(v3) = v3 - 1;
	result[1] -= v6;
	*result += x_BYTE_11B4E0[v3];
	a2[1] -= x_BYTE_11B4E0[v3];
	return result;
}

//----- (000580E0) --------------------------------------------------------
signed int sub_580E0(int a1, signed int a2, int a3, int a4, __int16 a5)
{
	signed int result; // eax

	result = 0;
	if (*(signed __int16 *)(a1 + 4) > a2)
	{
		result = 1;
		*(x_WORD *)(a1 + 4) += a5;
	}
	if (*(signed __int16 *)(a1 + 4) <= a2 + a3)
	{
		result = 3;
		*(x_WORD *)(a1 + 4) = a3 + a2;
	}
	return result;
}

//----- (000581E0) --------------------------------------------------------
__int16 sub_581E0(Bit16u* a1, Bit16u* a2)//2391E0
{
	//354f10->35f418 +2->35012a .. 012a
	//354f14->354f20 +2->350168 .. 0168
	//0168-18a=3e
	//354f10->35f418->ec0141 .. 0141
	//354f14->354f20->012a018d .. 018d
	//18d-141=4c

	//ebx=a1 //141
	//edx=a2 //1d8
	//ax edx+2

	return sub_72633(a2[0] - a1[0], a2[1] - a1[1]);//253633
	//rozdil1- 4c rozdil2 - 3e
}

//----- (00058210) --------------------------------------------------------
__int16 sub_58210(x_WORD *a1, x_WORD *a2)
{
	__int16 v2; // ax

	v2 = sub_58490(a1, a2);//
	return sub_72633(a1[2] - a2[2], -v2);
}

//----- (000582B0) --------------------------------------------------------
int sub_582B0(__int16 a1, __int16 a2)
{
	int result; // eax

	result = abs((a1 & 0x7FF) - (a2 & 0x7FF));
	if ((unsigned __int16)result > 0x400u)
		result = 2048 - result;
	return result;
}

//----- (000582F0) --------------------------------------------------------
int sub_582F0(int a1, __int16 a2)
{
	int v2; // edx
	int v3; // ebx

	v2 = a1;
	BYTE1(v2) &= 7u;
	v3 = (a2 & 0x7FF) - (unsigned __int16)v2;
	if ((a2 & 0x7FF) == (unsigned __int16)v2)
		return v2 ^ (unsigned __int16)v2;
	if (abs(v3) > 1024)
	{
		if (v3 >= 0)
			v3 -= 2048;
		else
			v3 += 2048;
	}
	if (v3)
	{
		if (v3 > 0)
			return 1;
		v3 = -1;
	}
	return v3;
}

//----- (00058350) --------------------------------------------------------
int sub_58350(unsigned __int16 a1, __int16 a2, int a3, unsigned __int16 a4)
{
	int v4; // ebx
	int v5; // esi
	int v6; // eax

	if (a1 == a2)
		return 0;
	v4 = sub_582B0(a1, a2);
	v5 = sub_582F0(a1, a2);
	v6 = v4;
	if ((signed __int16)v4 > (signed int)a4)
		v6 = a4;
	return v5 * v6;
}

//----- (000583B0) --------------------------------------------------------
int sub_583B0(x_WORD *a1, x_WORD *a2)
{
	int v2; // ebx
	int v3; // eax

	v2 = abs((signed __int16)(*a2 - *a1));
	v3 = abs((signed __int16)(a2[1] - a1[1]));
	if (v2 < v3)
		v2 = v3;
	return v2;
}

//----- (000583F0) --------------------------------------------------------
unsigned int sub_583F0(x_WORD *a1, x_WORD *a2)
{
	__int16 v2; // cx

	v2 = a2[2] - a1[2];
	return sub_7277A(
		(signed __int16)(a2[1] - a1[1]) * (signed __int16)(a2[1] - a1[1])
		+ (signed __int16)(*a2 - *a1) * (signed __int16)(*a2 - *a1)
		+ v2 * v2);
}

//----- (00058440) --------------------------------------------------------
int sub_58440(x_WORD *a1, x_WORD *a2)
{
	return (signed __int16)(a2[1] - a1[1]) * (signed __int16)(a2[1] - a1[1])
		+ (signed __int16)(*a2 - *a1) * (signed __int16)(*a2 - *a1)
		+ (signed __int16)(a2[2] - a1[2]) * (signed __int16)(a2[2] - a1[2]);
}

//----- (00058490) --------------------------------------------------------
unsigned int sub_58490(x_WORD *a1, x_WORD *a2)
{
	return sub_7277A(
		(signed __int16)(*a2 - *a1) * (signed __int16)(*a2 - *a1)
		+ (signed __int16)(a2[1] - a1[1]) * (signed __int16)(a2[1] - a1[1]));
}

//----- (000584D0) --------------------------------------------------------
int sub_584D0(x_WORD *a1, x_WORD *a2)
{
	return (signed __int16)(*a2 - *a1) * (signed __int16)(*a2 - *a1)
		+ (signed __int16)(a2[1] - a1[1]) * (signed __int16)(a2[1] - a1[1]);
}

//----- (000585A0) --------------------------------------------------------
signed int sub_585A0(int a1)
{
	signed int result; // eax

	if (*(x_BYTE *)(a1 + 92) >= *(x_BYTE *)(a1 + 93))
		return 1;
	result = 0;
	++*(x_BYTE *)(a1 + 92);
	return result;
}

//----- (000585D0) --------------------------------------------------------
void sub_585D0()
{
	int v0; // esi
	unsigned int i; // ebx
	__int16 v2; // ax

	v0 = x_WORD_D84A6;
	for (i = x_D41A0_BYTEARRAY_4[0x9677]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
	{
		if (!*(x_BYTE *)(i + 64))
		{
			v2 = sub_10C40((__int16 *)(i + 76));
			if (*(signed __int16 *)(i + 80) < v2 + v0)
				*(x_WORD *)(i + 80) = v0 + v2;
		}
	}
}
// D41A4: using guessed type int x_DWORD_D41A4;
// D84A6: using guessed type __int16 x_WORD_D84A6;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00058630) --------------------------------------------------------
char sub_58630()
{
	char v0; // bl
	unsigned int v1; // edx
	int v2; // eax
	unsigned int v3; // eax
	int v4; // eax
	__int16 v5; // cx
	int v6; // ebx
	unsigned int v7; // eax
	unsigned int v8; // edx
	int v9; // eax
	signed int v10; // esi
	signed int v11; // edi
	char v12; // ah
	unsigned __int16 v13; // bx
	int v15; // [esp+0h] [ebp-10h]
	__int16 v16; // [esp+4h] [ebp-Ch]
	int v17; // [esp+8h] [ebp-8h]
	int v18; // [esp+Ch] [ebp-4h]

	v0 = 0;
	v1 = 0;
	if (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10)
	{
		v2 = (int)x_D41A0_BYTEARRAY_0;
		*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8) = 9377 * *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8) + 9439;
		v1 = *(x_DWORD *)(v2 + 8) % (unsigned int)*(unsigned __int16 *)(v2 + 14);
	}
	else if (*(x_BYTE *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11248) & 7)
	{
		goto LABEL_5;
	}
	v0 = 1;
LABEL_5:
	v3 = 2124 * v1 + (int)x_D41A0_BYTEARRAY_0 + 11230;
	if (!*(x_BYTE *)(v3 + 6))
		v0 = 0;
	if (v0)
	{
		v4 = x_DWORD_EA3E4[*(unsigned __int16 *)(v3 + 10)];
		v15 = *(x_DWORD *)(v4 + 76);
		v16 = *(x_WORD *)(v4 + 80);
		sub_57FA0((x_WORD*)&v15, *(x_WORD *)(v4 + 28), 0, 2560);
		LOBYTE(v5) = (unsigned __int16)(v15 + 128) >> 8;
		v6 = (int)x_D41A0_BYTEARRAY_0;
		HIBYTE(v5) = (unsigned __int16)(HIWORD(v15) + 128) >> 8;
		v7 = 9377 * *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8) + 9439;
		*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8) = v7;
		v8 = v7 % 0x14;
		v9 = 9377 * *(x_DWORD *)(v6 + 8);
		v17 = v8;
		v3 = v9 + 9439;
		*(x_DWORD *)(v6 + 8) = v3;
		LOBYTE(v5) = v5 - 10;
		HIBYTE(v5) -= 10;
		LOWORD(v18) = v5;
		v10 = v3 % 0x14;
		BYTE1(v18) = v3 % 0x14 + HIBYTE(v5);
		LOBYTE(v3) = 0;
		while (v10 < 20 && !(x_BYTE)v3)
		{
			v11 = v17;
			HIBYTE(v13) = BYTE1(v18);
			v12 = v17;
			v17 = 0;
			LOBYTE(v13) = v12 + v18;
			while (v11 < 20 && !(x_BYTE)v3)
			{
				if (!x_BYTE_10B4E0[v13] && !(x_BYTE_13B4E0[v13] & 8))
				{
					LOWORD(v15) = (unsigned __int8)v13 << 8;
					HIWORD(v15) = HIBYTE(v13) << 8;
					sub_4A190((int)&v15, 10, 86);
					LOBYTE(v3) = 1;
				}
				v11 += 11;
				LOBYTE(v13) = v13 + 11;
			}
			++v10;
			++BYTE1(v18);
		}
	}
	return v3;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00058940) --------------------------------------------------------
int sub_58940(Bit8u* a1)
{
	Bit8u* v1; // ST00_4
	Bit8u* v2; // esi
	Bit8u* v3; // ecx
	int result; // eax
	int v5; // edx
	int v6; // edi
	__int16 v7; // dx
	int v8; // edi
	int v9; // edi
	int v10; // ST0C_4
	int v11; // ebx
	int v12; // [esp+Ch] [ebp-8h]

	v1 = &x_D41A0_BYTEARRAY_0[0x3659C];
	*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 224769) = 0;
	memset(v1, 0, 88);
	memset((void*)(x_D41A0_BYTEARRAY_0 + 222540), 0, 80);
	v2 = x_D41A0_BYTEARRAY_0;
	v3 = x_D41A0_BYTEARRAY_4;
	*(x_WORD *)(0x2FED5 + x_D41A0_BYTEARRAY_0) = 0;
	if (*(x_BYTE *)(v3 + 22) & 0x10)
	{
		*(x_BYTE *)(v2 + 224769) = 1;
		*(x_BYTE *)(v2 + 222540) = 8;
		result = 0;
		while ((signed __int16)result < 8)
		{
			v11 = 11 * (signed __int16)result++;
			x_BYTE_3659F[(int)v2 + v11] = 1;
		}
		x_D41A0_BYTEARRAY_0 = v2;
	}
	else
	{
		result = 0;
		do
		{
			if (*(char *)(7 * (signed __int16)result + a1 + 25972) != -1)
			{
				switch (*(x_BYTE *)(v2 + 10 * *(unsigned __int8 *)(v2 + 224769) + 222540))
				{
				case 1:
				case 2:
				case 4:
				case 6:
				case 7:
				case 9:
					v5 = (int)a1 + 7 * (signed __int16)result;
					if (!*(x_WORD *)(v5 + 25973))
						*(x_BYTE *)(v5 + 25972) = -1;
					break;
				default:
					break;
				}
			}
			v6 = (int)a1 + 7 * (signed __int16)result;
			if (*(char *)(v6 + 25972) != -1)
			{
				*(x_BYTE *)(v2 + 10 * *(unsigned __int8 *)(v2 + 224769) + 222540) = *(x_BYTE *)(v6 + 25972);
				v7 = 0;
				while (v7 < 8)
				{
					v8 = (int)(11 * v7++ + v2);
					x_BYTE_3659F[v8 + *(unsigned __int8 *)(v2 + 224769)] = 1;
				}
				v9 = (int)v2 + 10 * *(unsigned __int8 *)(v2 + 224769);
				v12 = (int)v2 + 10 * *(unsigned __int8 *)(v2 + 224769);
				switch (*(x_BYTE *)(v9 + 222540))
				{
				case 0:
					goto LABEL_17;
				case 1:
				case 2:
				case 6:
					*(x_DWORD *)(v2 + 10 * *(unsigned __int8 *)(v2 + 224769) + 222546) = 20
						* *(unsigned __int16 *)(7 * (signed __int16)result + a1 + 25973)
						+ (int)a1
						+ 1091;
					break;
				case 4:
					v10 = (int)a1 + 7 * (signed __int16)result;
					*(x_DWORD *)(v12 + 222546) = 20 * *(unsigned __int16 *)((int)a1 + 7 * (signed __int16)result + 25973) + (int)a1 + 1091;
					*(x_WORD *)(0x3654E + 10 * *(unsigned __int8 *)(v2 + 224769) + v2) = *(x_WORD *)(v10 + 25975) << 8;
					*(x_WORD *)(0x36550 + 10 * *(unsigned __int8 *)(v2 + 224769) + v2) = *(x_WORD *)(v10 + 25977) << 8;
					break;
				case 5:
					*(x_WORD *)(0x3654E + v12) = *(x_WORD *)(a1 + 7 * (signed __int16)result + 25975) << 8;
					*(x_WORD *)(0x36550 + 10 * *(unsigned __int8 *)(v2 + 224769) + v2) = *(x_WORD *)(a1 + 7 * (signed __int16)result + 25977) << 8;
				LABEL_17:
					*(x_DWORD *)(v2 + 10 * *(unsigned __int8 *)(v2 + 224769) + 222546) = *(unsigned __int16 *)(7 * (signed __int16)result + a1 + 25973);
					break;
				case 7:
					*(x_DWORD *)(v9 + 222546) = *(unsigned __int16 *)(a1
						+ 20
						* *(unsigned __int16 *)(7 * (signed __int16)result
							+ a1
							+ 25973)
						+ 1093);
					break;
				case 8:
					break;
				case 9:
					*(x_DWORD *)(v9 + 222546) = *(unsigned __int16 *)(a1
						+ 20
						* *(unsigned __int16 *)(7 * (signed __int16)result
							+ a1
							+ 25973)
						+ 1105);
					break;
				default:
					*(x_DWORD *)(v2 + 10 * *(unsigned __int8 *)(v2 + 224769) + 222546) = *(unsigned __int16 *)(7 * (signed __int16)result + a1 + 25973)
						- 1;
					break;
				}
				++*(x_BYTE *)(v2 + 224769);
			}
			++result;
		} while ((signed __int16)result < 8);
		x_D41A0_BYTEARRAY_0 = v2;
	}
	return result;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (00058DA0) --------------------------------------------------------
int sub_58DA0(int a1, int a2)
{
	signed __int16 i; // bx
	int v3; // esi
	int v4; // eax
	char v5; // dl
	char v6; // al
	int v7; // eax
	char v8; // dl
	char v9; // dh
	int result; // eax

	for (i = 0; ; i++)
	{
		result = *(unsigned __int8 *)(x_D41A0_BYTEARRAY_0 + 224769);
		if (i >= (signed __int16)result)
			break;
		v3 = (int)x_D41A0_BYTEARRAY_0 + 10 * i;
		switch (*(x_BYTE *)(v3 + 222540))
		{
		case 1:
		case 2:
		case 4:
			v4 = (int)x_D41A0_BYTEARRAY_0 + 10 * i;
			if (a1 == *(x_DWORD *)(v4 + 222546))
			{
				v5 = *(x_BYTE *)(v4 + 222541);
				*(x_DWORD *)(v4 + 222546) = a2;
				*(x_BYTE *)(v4 + 222541) = v5 | 1;
			}
			break;
		case 3:
			if (*(x_BYTE *)(a2 + 63) == 3)
			{
				v6 = *(x_BYTE *)(a2 + 64);
				if (!v6 || v6 == 1)
				{
					v7 = 10 * i + (int)x_D41A0_BYTEARRAY_0;
					if (*(signed __int16 *)(*(x_DWORD *)(a2 + 164) + 56) == *(x_DWORD *)(v7 + 222546))
					{
						v8 = *(x_BYTE *)(v7 + 222541);
						*(x_DWORD *)(v7 + 222546) = a2;
						*(x_BYTE *)(v7 + 222541) = v8 | 1;
					}
				}
			}
			break;
		case 6:
			if (a1 == *(x_DWORD *)(v3 + 222546))
			{
				v9 = *(x_BYTE *)(v3 + 222541);
				*(x_DWORD *)(v3 + 222546) = (a2 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
				*(x_BYTE *)(v3 + 222541) = v9 | 1;
			}
			break;
		default:
			continue;
		}
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00058F00) --------------------------------------------------------
int sub_58F00()
{
	Bit8u* v0; // esi
	int result; // eax
	char v2; // dh
	signed __int16 v3; // bx
	signed __int16 v4; // cx
	int v5; // eax
	int v6; // eax
	int v7; // edi
	unsigned int v8; // edx
	__int16 j; // ax
	__int16 i; // ax
	__int64 v11; // rax
	__int64 v12; // rax
	__int16 v13; // dx
	signed __int16 v14; // ax
	signed __int16 k; // bx
	Bit8u* v16; // edx
	int v17; // [esp+4h] [ebp-44h]
	int v18; // [esp+1Ch] [ebp-2Ch]
	int v19; // [esp+24h] [ebp-24h]
	int v20; // [esp+28h] [ebp-20h]
	int v21; // [esp+30h] [ebp-18h]
	signed __int16 v22; // [esp+34h] [ebp-14h]
	signed __int16 v23; // [esp+38h] [ebp-10h]
	int v24; // [esp+3Ch] [ebp-Ch]
	char v25; // [esp+40h] [ebp-8h]
	unsigned __int8 v26; // [esp+44h] [ebp-4h]

	if (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10)
		v22 = *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 14);
	else
		v22 = 1;
	v24 = 0;
	v0 = &x_D41A0_BYTEARRAY_0[0x3659C];
	result = 0;
	if (v22 > 0)
	{
		do
		{
			v2 = v0[2];
			if (v2)
			{
				v0[2] = v2 - 1;
			}
			else if (!*v0)
			{
				v3 = 0;
				v4 = 0;
				v23 = 0;
				v17 = x_DWORD_EA3E4[*(unsigned __int16 *)(x_D41A0_BYTEARRAY_0 + 2124 * (signed __int16)v24 + 11240)];
				while (v3 < *(unsigned __int8 *)(x_D41A0_BYTEARRAY_0 + 224769))
				{
					v19 = 10 * v3;
					v5 = v19 + (int)x_D41A0_BYTEARRAY_0;
					v21 = (int)&v0[v3];
					if (*(x_BYTE *)(v19 + x_D41A0_BYTEARRAY_0 + 222541) & 2)
					{
						*(x_BYTE *)(v21 + 3) = 2;
						v4 = 1;
						*(x_BYTE *)(v5 + 222541) &= 0xFDu;
					}
					else if (*(x_BYTE *)(v21 + 3) == 1)
					{
						switch (*(x_BYTE *)(v5 + 222540))
						{
						case 0:
							v6 = *(x_DWORD *)(v17 + 164);
							if (*(x_WORD *)(v6 + 58))
							{
								v18 = x_D41A0_BYTEARRAY_4[0xF6];
								if (v18 > 0)
								{
									v7 = (int)x_D41A0_BYTEARRAY_0;
									if ((unsigned int)(100
										* (*(x_DWORD *)(v6 + 316)
											+ *(x_DWORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(v6 + 58)] + 144))
										/ v18) >= *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 10 * v3 + 222546))
									{
										v0[v3 + 3] = 2;
										v4 = 1;
										*(x_WORD *)(0x2FED5 + v7) = 0;
									}
								}
							}
							if (!*(x_WORD *)(0x2FED5 + x_D41A0_BYTEARRAY_0) && v3 == (unsigned __int8)v0[1] && !v4)
								*(x_WORD *)(0x2FED5 + x_D41A0_BYTEARRAY_0) = *(x_WORD *)(x_D41A0_BYTEARRAY_0
									+ 10 * (unsigned __int8)v0[1]
									+ 222546);
							break;
						case 1:
							if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 10 * v3 + 222541) & 1
								&& *(x_DWORD *)(*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 10 * v3 + 222546) + 8) <= -1)
							{
								v4 = 1;
								v0[v3 + 3] = 2;
							}
							break;
						case 2:
							if (*(x_BYTE *)(v5 + 222541) & 1
								&& *(x_DWORD *)(*(x_DWORD *)(v5 + 222546) + 8) <= -1
								&& !*(x_BYTE *)(*(x_DWORD *)(10 * v3 + x_D41A0_BYTEARRAY_0 + 222546) + 61))
							{
								v4 = 1;
								v0[v3 + 3] = 2;
							}
							break;
						case 3:
							if (!*(x_BYTE *)(x_D41A0_BYTEARRAY_0
								+ 2124 * *(signed __int16 *)(*(x_DWORD *)(*(x_DWORD *)(v5 + 222546) + 164) + 56)
								+ 11236))
							{
								v4 = 1;
								*(x_BYTE *)(v21 + 3) = 2;
							}
							break;
						case 4:
							if (*(x_BYTE *)(v5 + 222541) & 1)
							{
								v20 = *(x_DWORD *)(v5 + 222546);
								if (v17 == x_DWORD_EA3E4[*(unsigned __int16 *)(v20 + 40)])
								{
									v11 = *(signed __int16 *)(0x3654E + v5) - (signed int)*(signed __int16 *)(v20 + 76);
									if ((signed int)((HIDWORD(v11) ^ v11) - HIDWORD(v11)) <= 768
										&& abs(*(signed __int16 *)(0x36550 + v19 + x_D41A0_BYTEARRAY_0) - *(signed __int16 *)(v20 + 78)) <= 768)
									{
										v4 = 1;
										*(x_BYTE *)(v21 + 3) = 2;
									}
								}
							}
							break;
						case 5:
							if (v3 == (unsigned __int8)v0[1])
							{
								v12 = *(signed __int16 *)(0x3654E + v5) - (signed int)*(signed __int16 *)(v17 + 76);
								if ((signed int)((HIDWORD(v12) ^ v12) - HIDWORD(v12)) <= 768
									&& abs(*(signed __int16 *)(0x36550 + v19 + x_D41A0_BYTEARRAY_0) - *(signed __int16 *)(v17 + 78)) <= 768)
								{
									v4 = 1;
									*(x_BYTE *)(v21 + 3) = 2;
								}
							}
							break;
						case 6:
							if (v3 == (unsigned __int8)v0[1] && *(x_BYTE *)(v5 + 222541) & 1)
							{
								v13 = 0;
								while (*(signed __int16 *)(x_D41A0_BYTEARRAY_0 + 11230 + 2124 * (signed __int16)v24 + 1426 + 2 * v13 + 2) != *(x_DWORD *)(10 * v3 + x_D41A0_BYTEARRAY_0 + 222546))
								{
									if (++v13 >= 8)
										goto LABEL_72;
								}
								v4 = 1;
								v0[v3 + 3] = 2;
							}
							break;
						case 7:
							if (v3 == (unsigned __int8)v0[1] && !x_D41A0_BYTEARRAY_4[*(x_DWORD *)(v5 + 222546) + 38403])
							{
								v4 = 1;
								*(x_BYTE *)(v21 + 3) = 2;
							}
							break;
						case 8:
							if (v3 == (unsigned __int8)v0[1])
							{
								v4 = 1;
								for (i = 0; i < (signed int)*(unsigned __int16 *)(x_D41A0_BYTEARRAY_0 + 14); i++)
								{
									if (i != (x_WORD)v24 && *(x_BYTE *)(2124 * i + x_D41A0_BYTEARRAY_0 + 11236))
									{
										v4 = 0;
										break;
									}
								}
								if (v4)
									v0[v3 + 3] = 2;
							}
							break;
						case 9:
							if (v3 == (unsigned __int8)v0[1] && !(x_D41A0_BYTEARRAY_4[26] & 0xF))
							{
								v8 = x_D41A0_BYTEARRAY_4[0x967F];
								v25 = 0;
								while (v8 > x_DWORD_EA3E4[0] && !v25)
								{
									v26 = 0;
									for (j = *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 10 * v3 + 222546);
										j && !v25 && v26 < 8u;
										j = (unsigned __int8)x_BYTE_D93C3[4 * j])
									{
										if (j == *(char *)(v8 + 70))
											v25 = 1;
										++v26;
									}
									v8 = *(x_DWORD *)v8;
								}
								if (!v25)
								{
									v4 = 1;
									v0[v3 + 3] = 2;
								}
							}
							break;
						default:
							break;
						}
					}
				LABEL_72:
					if (v4 && v3 == (unsigned __int8)v0[1])
						v23 = 1;
					++v3;
				}
				if (v4)
				{
					sub_88B20();
					v14 = 1;
					for (k = 0; k < *(unsigned __int8 *)(x_D41A0_BYTEARRAY_0 + 224769); k++)
					{
						if (v0[k + 3] == 1)
						{
							v14 = 0;
							v0[1] = k;
							break;
						}
					}
					*v0 = v14;
					if (v23 || v14)
					{
						if (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10 && (x_WORD)v24 != *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12))
						{
							v16 = (Bit8u*)(2124 * (signed __int16)v24 + x_D41A0_BYTEARRAY_0 + 11230 + 28);
							*(x_WORD *)(v16 + 49) = 60;
							*(x_WORD *)(v16 + 51) = 4;
							if (v14)
								sprintf_s((char* const)v16, 512, (char *)x_DWORD_E9C4C_langindexbuffer[431]);
							else
								sprintf_s((char* const)v16, 512, (char *)x_DWORD_E9C4C_langindexbuffer[430]);
						}
						if ((x_WORD)v24 == *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12))
							*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 224770) = 1;
					}
				}
			}
			v0 += 11;
			result = ++v24;
		} while ((signed __int16)v24 < v22);
	}
	return result;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA304: using guessed type int x_DWORD_EA304;
// EA308: using guessed type int x_DWORD_EA308;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000595C0) --------------------------------------------------------
char sub_595C0(__int16 a1)
{
	char result; // al
	Bit8u* v2; // ebx

	result = -1;
	if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 224779) & 1)
		return -3;
	v2 = &x_D41A0_BYTEARRAY_0[0x3659C + 11 * a1];
	if (!*v2)
		result = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 10 * (unsigned __int8)v2[1] + 222540);
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00059610) --------------------------------------------------------
char sub_59610(int *a1, __int16 a2)
{
	int v2; // eax
	Bit8u* v3; // ecx
	Bit8u* v4; // ebx
	char v5; // dl
	unsigned __int8 v6; // dh
	int v7; // eax
	int v8; // ebx
	unsigned __int8 v9; // al
	int v10; // eax
	int v11; // eax

	v2 = 11 * a2;
	v3 = x_D41A0_BYTEARRAY_0;
	v4 = &x_D41A0_BYTEARRAY_0[0x3659C];
	*a1 = 0;
	v5 = 0;
	v6 = v4[v2 + 1];
	if (v4[v2])
		return v5;
	v7 = 10 * v6;
	v8 = (int)v3 + v7;
	v9 = *(x_BYTE *)(v3 + v7 + 222540);
	if (v9 < 4u)
	{
		if (v9 < 1u || v9 > 2u)
			return v5;
	}
	else if (v9 > 4u)
	{
		if (v9 == 6 && *(x_BYTE *)(v8 + 222541) & 1)
		{
			v11 = x_DWORD_EA3E4[*(x_DWORD *)(v8 + 222546)];
			goto LABEL_12;
		}
		return v5;
	}
	v10 = (int)x_D41A0_BYTEARRAY_0 + 10 * v6;
	if (*(x_BYTE *)(v10 + 222541) & 1)
	{
		v11 = *(x_DWORD *)(v10 + 222546);
	LABEL_12:
		v5 = 1;
		*a1 = v11;
	}
	return v5;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000596C0) --------------------------------------------------------
char sub_596C0(x_WORD *a1, __int16 a2)
{
	int v2; // ebx
	char *v3; // ecx
	char v4; // dl
	int v5; // eax
	int v6; // edi
	unsigned __int8 v7; // al

	v2 = (int)x_D41A0_BYTEARRAY_0;
	*a1 = -1;
	a1[1] = -1;
	v3 = &x_BYTE_3659C[11 * a2 + v2];
	a1[2] = -1;
	v4 = 0;
	if (!*v3)
	{
		v5 = 10 * (unsigned __int8)v3[1];
		v6 = v2 + v5;
		v7 = *(x_BYTE *)(v2 + v5 + 222540);
		if (v7 >= 4u && v7 <= 5u)
		{
			*a1 = *(x_WORD *)(0x3654E + v6);
			v4 = 1;
			a1[1] = *(x_WORD *)(0x36550 + 10 * (unsigned __int8)v3[1] + v2);
		}
	}
	return v4;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00059760) --------------------------------------------------------
int sub_59760(int a1, int a2)
{
	int result; // eax
	signed int v3; // esi
	signed int v4; // ecx
	Bit8u* i; // ebx
	int j; // edx
	int v7; // eax

	result = (int)x_D41A0_BYTEARRAY_4;
	if (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10)
		v3 = *(unsigned __int16 *)(x_D41A0_BYTEARRAY_0 + 14);
	else
		v3 = 1;
	v4 = 0;
	for (i = &x_D41A0_BYTEARRAY_0[0x3659C]; v4 < v3; i += 11)
	{
		if (!*i)
		{
			for (j = 0; ; j++)
			{
				result = *(unsigned __int8 *)(x_D41A0_BYTEARRAY_0 + 224769);
				if (j >= result)
					break;
				if (i[j + 3] == 1)
				{
					v7 = (int)x_D41A0_BYTEARRAY_0 + 10 * j;
					if (*(x_BYTE *)(v7 + 222540) == 2 && *(x_DWORD *)(v7 + 222546) == a1)
					{
						if (*(x_BYTE *)(v7 + 222541) & 1)
							*(x_DWORD *)(v7 + 222546) = a2;
					}
				}
			}
		}
		++v4;
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (00059820) --------------------------------------------------------
void sub_59820()
{
	char v0; // dl
	int v1; // ebx
	int v2; // eax
	unsigned __int8 v3; // ch
	char v4; // cl
	int v5; // ebx
	unsigned __int16 v6; // dx
	int v7; // eax
	__int16 v8; // bx
	unsigned __int8 v9; // al
	char v10; // cl
	int v11; // ebx

	v0 = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 224772);
	if (v0)
	{
		*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 224772) = v0 - 1;
		if (v0 == 1)
			sub_88BA0();
	}
	if (x_D41A0_BYTEARRAY_4[38545] & 0x40 && sub_86180(x_WORD_1803EC) == 256)
		sub_59AF0_sound_proc9();
	v1 = (int)x_D41A0_BYTEARRAY_4;
	if (x_D41A0_BYTEARRAY_4[0x33] >= 3u)
	{
		v2 = (int)x_D41A0_BYTEARRAY_0;
		v3 = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 224770);
		if (v3)
		{
			if (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10)
			{
			LABEL_38:
				*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 224770) = 0;
				return;
			}
			if (x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 0x40)
			{
				if (v3 < 7u)
				{
					if (v3 == 1)
					{
						++*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 224770);
						return;
					}
					goto LABEL_32;
				}
				if (v3 > 7u)
				{
					if (v3 > 8u)
					{
						if (v3 != -56)
						{
						LABEL_32:
							++*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 224770);
							return;
						}
						goto LABEL_38;
					}
					v4 = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 224779);
					*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 224770) = v3 + 1;
					if (v4 & 1)
					{
						*(x_BYTE *)(v1 + 180) = 8;
						sub_86F20(*(x_BYTE *)(2124 * *(signed __int16 *)(v2 + 12) + v2 + 12226));
						sub_59A50_sound_proc8();
						return;
					}
					v5 = *(signed __int16 *)(v2 + 12);
					if (x_BYTE_3659D[11 * v5 + v2])
						sub_6E450(v5, -1, 61);
					v6 = x_D41A0_BYTEARRAY_4_struct.levelnumber_43;
					if (v6 >= 0x1Eu && v6 <= 0x22u)
					{
						if (!x_D41A0_BYTEARRAY_0[11 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 0x3659C])
						{
							v9 = 4;
							LOBYTE(v8) = 0;
							goto LABEL_30;
						}
						LOBYTE(v8) = 10;
					}
					else
					{
						v7 = 11 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + (int)x_D41A0_BYTEARRAY_0;
						v8 = x_D41A0_BYTEARRAY_4_struct.levelnumber_43;
						if (!x_BYTE_3659C[v7])
						{
							v9 = x_BYTE_3659D[v7] + 1;
						LABEL_30:
							x_D41A0_BYTEARRAY_4[0xB4] = 8;
							sub_86EB0(v8, v9, 1);
							sub_59A50_sound_proc8();
							return;
						}
					}
					v9 = 9;
					goto LABEL_30;
				}
				*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 224770) = 8;
				*(x_BYTE *)(v1 + 180) = 8;
				goto LABEL_36;
			}
			*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 224770) = 0;
			v10 = *(x_BYTE *)(v2 + 224779);
			*(x_BYTE *)(v2 + 224772) = -56;
			if (v10 & 1)
			{
			LABEL_36:
				sub_6E450(*(x_WORD *)(v2 + 12), -1, 41);
				return;
			}
			v11 = *(signed __int16 *)(v2 + 12);
			if (x_BYTE_3659D[11 * v11 + v2])
				sub_6E450(v11, -1, 61);
		}
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// 1803EC: using guessed type __int16 x_WORD_1803EC;

//----- (00059A50) --------------------------------------------------------
int sub_59A50_sound_proc8()
{
	int result; // eax

	if (x_BYTE_D4B7A == 1)
	{
		sub_92DC0_AIL_release_timer_handle(x_DWORD_F4940);
		x_BYTE_D4B7A = 0;
	}
	sub_8E470_sound_proc17_volume(x_D41A0_BYTEARRAY_4_struct.dwordindex_6 / 3);
	x_BYTE_D4B78 = x_D41A0_BYTEARRAY_4_struct.dwordindex_6 / 3;
	sub_8E410_sound_proc16_xmidivolume((x_D41A0_BYTEARRAY_4_struct.dwordindex_8 / 3));
	result = x_D41A0_BYTEARRAY_4_struct.dwordindex_8 / 3;
	x_BYTE_D4B79 = x_D41A0_BYTEARRAY_4_struct.dwordindex_8 / 3;
	x_D41A0_BYTEARRAY_4[38545] |= 0x40u;
	return result;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// D4B78: using guessed type char x_BYTE_D4B78;
// D4B79: using guessed type char x_BYTE_D4B79;
// D4B7A: using guessed type char x_BYTE_D4B7A;
// F4940: using guessed type int x_DWORD_F4940;

//----- (00059AF0) --------------------------------------------------------
int sub_59AF0_sound_proc9()
{
	int result; // eax

	sub_86860(x_WORD_1803EC);
	x_DWORD_F4940 = sub_92600_AIL_register_timer(sub_59B50_sound_proc10);
	sub_92930_AIL_set_timer_frequency(x_DWORD_F4940, 0x78u);
	sub_92BA0_AIL_start_timer(x_DWORD_F4940);
	x_BYTE_D4B7A = 1;
	result = (int)x_D41A0_BYTEARRAY_4;
	*(x_BYTE *)(result + 38545) &= 0xBFu;
	return result;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// D4B7A: using guessed type char x_BYTE_D4B7A;
// F4940: using guessed type int x_DWORD_F4940;
// 1803EC: using guessed type __int16 x_WORD_1803EC;

//----- (00059B50) --------------------------------------------------------
void sub_59B50_sound_proc10(HMDIDRIVER user)
{
	__int16 v0; // bx
	__int16 v1; // dx

	v0 = x_D41A0_BYTEARRAY_4_struct.dwordindex_6;
	if ((unsigned __int8)x_BYTE_D4B78 != v0
		|| (HIBYTE(v1) = HIBYTE(v0), LOBYTE(v1) = x_BYTE_D4B79, v1 != x_D41A0_BYTEARRAY_4_struct.dwordindex_8))
	{
		if ((signed __int16)(unsigned __int8)x_BYTE_D4B78 < x_D41A0_BYTEARRAY_4_struct.dwordindex_6)
			sub_8E470_sound_proc17_volume((unsigned __int8)++x_BYTE_D4B78);
		if ((signed __int16)(unsigned __int8)x_BYTE_D4B79 < x_D41A0_BYTEARRAY_4_struct.dwordindex_8)
			sub_8E410_sound_proc16_xmidivolume(++x_BYTE_D4B79);
	}
	else
	{
		x_BYTE_D4B7A = 0;
		sub_92DC0_AIL_release_timer_handle(x_DWORD_F4940);
	}
}
// D41A4: using guessed type int x_DWORD_D41A4;
// D4B78: using guessed type char x_BYTE_D4B78;
// D4B79: using guessed type char x_BYTE_D4B79;
// D4B7A: using guessed type char x_BYTE_D4B7A;
// F4940: using guessed type int x_DWORD_F4940;

//----- (00059BF0) --------------------------------------------------------
void sub_59BF0_sound_proc11_volume()
{
	if (x_BYTE_D4B7A == 1)
	{
		sub_92DC0_AIL_release_timer_handle(x_DWORD_F4940);
		x_BYTE_D4B7A = 0;
	}
	sub_8E470_sound_proc17_volume(x_D41A0_BYTEARRAY_4_struct.dwordindex_6);
	sub_8E410_sound_proc16_xmidivolume(x_D41A0_BYTEARRAY_4_struct.dwordindex_8);
}
// D41A4: using guessed type int x_DWORD_D41A4;
// D4B7A: using guessed type char x_BYTE_D4B7A;
// F4940: using guessed type int x_DWORD_F4940;

//----- (00059C40) --------------------------------------------------------
int sub_59C40(int a1)
{
	int result; // eax

	result = sub_10C40((__int16 *)(a1 + 76));
	*(x_WORD *)(a1 + 80) = result;
	return result;
}

//----- (00059C60) --------------------------------------------------------
int sub_59C60(int a1)
{
	int result; // eax

	result = sub_10C40((__int16 *)(a1 + 76));
	*(x_WORD *)(a1 + 80) = result;
	return result;
}

//----- (00059C80) --------------------------------------------------------
int sub_59C80(int a1)
{
	//int result; // eax
	int v2; // ebx
	unsigned int i; // ebx
	int v4; // edi
	int v5; // eax

	if (x_D41A0_BYTEARRAY_4[38545] & 4)
	{
		*(x_BYTE *)(a1 + 12) |= 1u;
		sub_57F10(a1);
	}
	else
	{
		*(x_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
		v2 = (int)x_D41A0_BYTEARRAY_4;
		//*(x_WORD *)(a1 + 80) = result;
		for (i = *(x_DWORD *)(v2 + 38519); i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
		{
			if (!*(x_BYTE *)(i + 64) && *(x_DWORD *)(i + 8) >= 0)
			{
				//result = sub_106C0(i, a1);
				if (sub_106C0(i, a1))
				{
					v4 = *(signed __int16 *)(*(x_DWORD *)(i + 164) + 56);
					if (v4 == x_D41A0_BYTEARRAY_4_struct.dwordindex_12)
					{
						if (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10)
							v5 = 50;
						else
							v5 = 4;
						sub_6E090(*(x_DWORD *)(i + 164) + 611, v5);
						sub_6E450(v4, -1, 63);
						if (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10)
							sub_6DBD0();
						else
							sub_6DB50(0, 1);
					}
					sub_57F10(a1);
				}
			}
		}
	}
	//return result;
	return 1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00059DC0) --------------------------------------------------------
char sub_59DC0(x_WORD *a1)
{
	int v1; // eax
	__int16 v2; // dx
	__int16 v3; // si
	int v4; // eax
	__int16 v5; // ST0C_2
	__int16 v6; // ST08_2
	__int16 v7; // ax
	__int16 v8; // ax
	int v10; // [esp+0h] [ebp-Ch]
	__int16 v11; // [esp+4h] [ebp-8h]
	char v12; // [esp+8h] [ebp-4h]

	v12 = 0;
	v1 = x_DWORD_EA3E4[(unsigned __int16)a1[20]];
	if (*(x_DWORD *)(v1 + 8) < 0 || *(x_BYTE *)(v1 + 13) & 4)
		return 1;
	if (*((x_DWORD *)a1 + 4) <= 5)
	{
		*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(v1 + 76);
		*(&x_WORD_EB398 + 2) = *(x_WORD *)(v1 + 80);
		a1[14] = *(x_WORD *)(v1 + 28);
		v2 = a1[8];
		v3 = *(x_WORD *)(v1 + 30);
		a1[15] = v3;
		sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(v1 + 28), v3 - 16 * v2, 384);
		sub_57CF0((int)a1, (int)&x_WORD_EB398);
		goto LABEL_10;
	}
	v4 = x_DWORD_EA3E4[(unsigned __int16)a1[19]];
	if (*(x_DWORD *)(v4 + 8) < 0 || *(x_BYTE *)(v4 + 13) & 4)
	{
		v12 = 1;
		goto LABEL_10;
	}
	v10 = *(x_DWORD *)(v4 + 76);
	v11 = *(x_WORD *)(v4 + 80);
	sub_57FA0((x_WORD*)&v10, *(x_WORD *)(v4 + 28), 0, 384);
	*(x_DWORD *)&x_WORD_EB398 = *((x_DWORD *)a1 + 19);
	*(&x_WORD_EB398 + 2) = a1[40];
	v5 = 32 * (a1[8] - 5);
	v6 = sub_58210(a1 + 38, (x_WORD*)&v10);
	v7 = sub_581E0((Bit16u *)a1 + 38, (Bit16u *)&v10);
	sub_57FA0((x_WORD*)&x_WORD_EB398, v7, v6, v5);
	sub_57CF0((int)a1, (int)&x_WORD_EB398);
	v8 = sub_10C40(a1 + 38);
	if ((signed __int16)a1[40] >= v8 + 64)
	{
	LABEL_10:
		++*((x_DWORD *)a1 + 4);
		return v12;
	}
	a1[40] = v8;
	v12 = 1;
	++*((x_DWORD *)a1 + 4);
	return v12;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;

//----- (00059F60) --------------------------------------------------------
void sub_59F60(int a1)
{
	unsigned int v1; // eax
	int v2; // eax
	char v3; // al
	unsigned __int16 v4; // bx
	unsigned __int16 v5; // cx
	signed int v6; // eax
	unsigned __int16 v7; // bx
	unsigned __int16 v8; // cx
	signed int v9; // edx
	unsigned __int16 v10; // di
	int v11; // eax
	__int16 v12; // bx
	signed int v13; // edx
	unsigned __int16 v14; // cx
	unsigned __int16 v15; // di
	int v16; // edi
	__int16 v17; // bx
	unsigned __int16 v18; // cx
	unsigned __int8 v19; // dh
	signed int v20; // edx
	unsigned __int16 v21; // bx
	unsigned __int16 v22; // ax
	unsigned __int16 v23; // cx
	char v24; // al
	unsigned __int16 v25; // bx
	char v26; // cl
	unsigned __int16 v27; // ax
	int v28; // eax
	__int16 v29; // bx
	signed int v30; // edx
	unsigned __int16 v31; // cx
	unsigned __int16 v32; // di
	unsigned __int16 v33; // bx
	unsigned __int16 v34; // cx
	unsigned __int16 v35; // ax
	unsigned __int16 v36; // bx
	signed int v37; // eax
	signed int v38; // edx
	unsigned __int16 v39; // cx
	unsigned __int16 v40; // di
	__int16 v41; // bx
	signed int v42; // eax
	int v43; // edx
	unsigned __int16 v44; // cx
	unsigned __int16 v45; // di
	__int16 v46; // bx
	signed int v47; // edi
	unsigned __int16 v48; // cx
	unsigned __int8 v49; // dh
	signed int v50; // edx
	unsigned __int16 v51; // bx
	unsigned __int16 v52; // ax
	unsigned __int16 v53; // cx
	char v54; // al
	char v55; // cl
	unsigned __int16 v56; // ax
	signed int v57; // eax
	__int16 v58; // bx
	int v59; // edx
	unsigned __int16 v60; // cx
	unsigned __int16 v61; // di
	char v62; // al
	int v63; // eax
	unsigned __int16 v64; // bx
	unsigned __int16 v65; // cx
	signed int v66; // edx
	unsigned __int16 v67; // di
	int v68; // edx
	__int16 v69; // bx
	signed int v70; // eax
	unsigned __int16 v71; // cx
	unsigned __int16 v72; // di
	int v73; // edx
	__int16 j; // bx
	signed int v75; // eax
	unsigned __int16 v76; // cx
	unsigned __int16 v77; // di
	__int16 v78; // bx
	signed int v79; // edx
	int v80; // eax
	unsigned __int16 v81; // cx
	unsigned __int16 v82; // di
	signed int v83; // edx
	__int16 v84; // bx
	int v85; // eax
	unsigned __int16 v86; // cx
	unsigned __int16 v87; // di
	signed int v88; // edx
	__int16 v89; // bx
	int v90; // eax
	unsigned __int16 v91; // cx
	unsigned __int16 v92; // di
	char v93; // al
	int v94; // eax
	int v95; // ebx
	unsigned __int16 v96; // dx
	char v97; // cl
	unsigned __int16 v98; // dx
	int v99; // edx
	unsigned __int16 k; // bx
	unsigned __int8 v101; // ch
	unsigned __int8 v102; // ch
	int v103; // eax
	int v104; // ebx
	unsigned __int16 v105; // dx
	char v106; // cl
	int v107; // ebx
	unsigned __int16 v108; // dx
	int v109; // edx
	int v110; // ebx
	unsigned __int8 v111; // ch
	int v112; // ebx
	unsigned __int8 v113; // ch
	char v114; // al
	signed int v115; // edx
	unsigned __int16 l; // bx
	unsigned __int16 v117; // ax
	unsigned __int16 v118; // cx
	char v119; // al
	unsigned __int16 v120; // bx
	char v121; // cl
	unsigned __int16 v122; // ax
	unsigned __int16 v123; // bx
	signed int v124; // edx
	unsigned __int16 v125; // ax
	unsigned __int16 v126; // cx
	char v127; // al
	unsigned __int16 v128; // bx
	char v129; // cl
	unsigned __int16 v130; // ax
	int v131; // edx
	char v132; // al
	int v133; // edx
	unsigned __int16 m; // bx
	unsigned __int16 v135; // ax
	int v136; // ecx
	int v137; // edi
	int v138; // ecx
	int v139; // edx
	int v140; // ebx
	int v141; // ecx
	int v142; // edi
	int v143; // ebx
	int v144; // ecx
	__int16 v145; // di
	char v146; // al
	int v147; // edx
	unsigned __int16 v148; // bx
	unsigned __int16 v149; // ax
	unsigned __int16 v150; // di
	unsigned __int16 v151; // di
	unsigned __int16 v152; // di
	char v153; // ch
	char v154; // cl
	unsigned __int16 v155; // di
	char v156; // ah
	int v157; // edx
	unsigned __int16 v158; // bx
	unsigned __int8 v159; // ch
	unsigned __int8 v160; // ch
	unsigned __int8 v161; // ch
	unsigned __int8 v162; // ch
	int v163; // edx
	__int16 v164; // bx
	unsigned __int16 v165; // bx
	unsigned __int16 v166; // ax
	char v167; // dh
	unsigned __int16 v168; // ax
	char v169; // cl
	signed int v170; // eax
	unsigned __int16 v171; // cx
	unsigned __int16 v172; // di
	int v173; // edx
	int v174; // ebx
	unsigned __int16 v175; // ax
	int v176; // ebx
	unsigned __int16 v177; // di
	unsigned __int16 v178; // di
	unsigned __int16 v179; // di
	char v180; // ch
	char v181; // cl
	unsigned __int16 v182; // di
	char v183; // ah
	int v184; // edx
	int v185; // ebx
	int v186; // ebx
	unsigned __int8 v187; // ch
	int v188; // ebx
	unsigned __int8 v189; // ch
	int v190; // ebx
	unsigned __int8 v191; // ch
	int v192; // ebx
	unsigned __int8 v193; // ch
	signed int v194; // eax
	__int16 v195; // bx
	unsigned __int16 v196; // bx
	unsigned __int16 v197; // ax
	int v198; // edx
	unsigned __int16 v199; // cx
	unsigned __int16 v200; // di
	signed int v201; // [esp+4h] [ebp-1Ch]
	int v202; // [esp+8h] [ebp-18h]
	signed int v203; // [esp+Ch] [ebp-14h]
	int i; // [esp+10h] [ebp-10h]
	signed int v205; // [esp+14h] [ebp-Ch]
	int v206; // [esp+18h] [ebp-8h]
	int v207; // [esp+1Ch] [ebp-4h]
	unsigned __int16 v208; // [esp+1Ch] [ebp-4h]

	v1 = *(x_DWORD *)(a1 + 8);
	if (v1 < 1)
	{
		if (!v1)
		{
			LOBYTE(v208) = (unsigned __int16)(*(x_WORD *)(a1 + 76) + 128) >> 8;
			v2 = (*(signed __int16 *)(a1 + 78) + 128) >> 8;
			HIBYTE(v208) = (unsigned __int16)(*(x_WORD *)(a1 + 78) + 128) >> 8;
			BYTE1(v2) = *(x_BYTE *)(a1 + 70);
			++*(x_DWORD *)(a1 + 16);
			if (BYTE1(v2))
				HIBYTE(v208) = v2 - 1;
			else
				--v208;
			v3 = *(x_BYTE *)(a1 + 70);
			if (v3)
			{
				if (v3 == 1)
				{
					v33 = v208;
					v201 = 0;
					do
					{
						v34 = v33;
						for (i = 0; i < *(x_DWORD *)(a1 + 16); i++)
						{
							if (x_BYTE_10B4E0[v34] != 8
								|| (LOBYTE(v35) = v33,
									HIBYTE(v35) = HIBYTE(v34) + 1,
									abs(x_BYTE_11B4E0[v34] - x_BYTE_11B4E0[v35]) > 30))
							{
								x_BYTE_11B4E0[v34] += 48;
							}
							++HIBYTE(v34);
						}
						--v33;
						++v201;
					} while (v201 < 2);
					v36 = v208;
					v37 = 0;
					while (v37 < 3)
					{
						v38 = -1;
						v39 = v36 - 256;
						while (v38 < *(x_DWORD *)(a1 + 16))
						{
							v40 = v39;
							++v38;
							++HIBYTE(v39);
							x_BYTE_10B4E0[v40] = 8;
							x_BYTE_13B4E0[v40] = 1;
						}
						++v37;
						--v36;
					}
					if (x_BYTE_D41B6)
					{
						v46 = v208 + 1;
						v47 = 0;
						while (v47 < 4)
						{
							v202 = -1;
							v48 = v46 - 256;
							while (*(x_DWORD *)(a1 + 16) + 1 > v202)
							{
								v49 = x_BYTE_11B4E0[v48];
								if ((unsigned __int8)x_BYTE_14B4E0[v48] > v49)
								{
									x_BYTE_13B4E0[v48] &= 0xF7u;
								}
								else
								{
									x_BYTE_14B4E0[v48] = v49 - 1;
									x_BYTE_13B4E0[v48] |= 8u;
								}
								++HIBYTE(v48);
								++v202;
							}
							++v47;
							--v46;
						}
					}
					else
					{
						v41 = v208 + 1;
						v42 = 0;
						while (v42 < 4)
						{
							v43 = -1;
							v44 = v41 - 256;
							while (v43 < *(x_DWORD *)(a1 + 16) + 1)
							{
								v45 = v44;
								++v43;
								++HIBYTE(v44);
								x_BYTE_13B4E0[v45] &= 0xF7u;
							}
							++v42;
							--v41;
						}
					}
					v50 = -1;
					v51 = v208 - 256;
					while (v50 < *(x_DWORD *)(a1 + 16))
					{
						LOBYTE(v51) = v51 + 1;
						++HIBYTE(v51);
						v52 = v51;
						LOBYTE(v51) = v51 - 2;
						HIBYTE(v51) -= 2;
						v53 = v51;
						LOBYTE(v51) = v51 + 1;
						v54 = x_BYTE_11B4E0[v53] - x_BYTE_11B4E0[v52] + 32;
						++HIBYTE(v51);
						if (v54 >= 28)
						{
							if (v54 > 40)
								v54 = (v54 & 7) + 40;
						}
						else
						{
							v54 = (v54 & 3) + 28;
						}
						if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308))
							v55 = 32 - v54 + 32;
						else
							v55 = v54;
						v56 = v51;
						++v50;
						++HIBYTE(v51);
						x_BYTE_12B4E0[v56] = v55;
					}
					v57 = -3;
					v58 = v208 - 3;
					while (v57 < 6)
					{
						v59 = -3;
						v60 = v58 - 768;
						while (v59 < *(x_DWORD *)(a1 + 16) + 3)
						{
							v61 = v60;
							++v59;
							++HIBYTE(v60);
							x_BYTE_13B4E0[v61] |= 0x80u;
						}
						++v57;
						++v58;
					}
				}
				*(x_WORD *)(a1 + 42) = 48;
				*(x_DWORD *)(a1 + 8) = 3;
			}
			else
			{
				v206 = 0;
				v4 = v208;
				while (v206 < *(x_DWORD *)(a1 + 16))
				{
					v205 = 0;
					v5 = v4;
					while (v205 < 2)
					{
						if (x_BYTE_10B4E0[v5] != 8
							|| abs(x_BYTE_11B4E0[v5] - x_BYTE_11B4E0[(unsigned __int16)(v5 + 1)]) > 30)
						{
							x_BYTE_11B4E0[v5] += 48;
						}
						--HIBYTE(v5);
						++v205;
					}
					++v4;
					++v206;
				}
				v6 = -1;
				v7 = v208 - 1;
				while (v6 < *(x_DWORD *)(a1 + 16))
				{
					v8 = v7;
					v9 = 0;
					while (v9 < 3)
					{
						v10 = v8;
						++v9;
						--HIBYTE(v8);
						x_BYTE_10B4E0[v10] = 8;
						x_BYTE_13B4E0[v10] = 1;
					}
					++v6;
					++v7;
				}
				if (x_BYTE_D41B6)
				{
					v16 = -1;
					v17 = v208 - 1;
					while (v16 < *(x_DWORD *)(a1 + 16) + 1)
					{
						v203 = 0;
						v18 = v17 + 256;
						while (v203 < 4)
						{
							v19 = x_BYTE_11B4E0[v18];
							if ((unsigned __int8)x_BYTE_14B4E0[v18] > v19)
							{
								x_BYTE_13B4E0[v18] &= 0xF7u;
							}
							else
							{
								x_BYTE_14B4E0[v18] = v19 - 1;
								x_BYTE_13B4E0[v18] |= 8u;
							}
							--HIBYTE(v18);
							++v203;
						}
						++v16;
						++v17;
					}
				}
				else
				{
					v11 = -1;
					v12 = v208 - 1;
					while (v11 < *(x_DWORD *)(a1 + 16) + 1)
					{
						v13 = 0;
						v14 = v12 + 256;
						while (v13 < 4)
						{
							v15 = v14;
							++v13;
							--HIBYTE(v14);
							x_BYTE_13B4E0[v15] &= 0xF7u;
						}
						++v11;
						++v12;
					}
				}
				v20 = -1;
				v21 = v208 - 1;
				while (v20 < *(x_DWORD *)(a1 + 16))
				{
					LOBYTE(v21) = v21 + 1;
					++HIBYTE(v21);
					v22 = v21;
					LOBYTE(v21) = v21 - 2;
					HIBYTE(v21) -= 2;
					v23 = v21;
					LOBYTE(v21) = v21 + 1;
					v24 = x_BYTE_11B4E0[v23] - x_BYTE_11B4E0[v22] + 32;
					HIBYTE(v25) = HIBYTE(v21) + 1;
					if (v24 >= 28)
					{
						if (v24 > 40)
							v24 = (v24 & 7) + 40;
					}
					else
					{
						v24 = (v24 & 3) + 28;
					}
					if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308))
						v26 = 32 - v24 + 32;
					else
						v26 = v24;
					v27 = v25;
					++v20;
					v21 = v25 + 1;
					x_BYTE_12B4E0[v27] = v26;
				}
				v28 = -3;
				v29 = v208 - 3;
				while (v28 < *(x_DWORD *)(a1 + 16) + 3)
				{
					v30 = -3;
					v31 = v29 + 768;
					while (v30 < 6)
					{
						v32 = v31;
						++v30;
						--HIBYTE(v31);
						x_BYTE_13B4E0[v32] |= 0x80u;
					}
					++v28;
					++v29;
				}
				*(x_WORD *)(a1 + 42) = 48;
				*(x_DWORD *)(a1 + 8) = 3;
			}
		}
		return;
	}
	if (v1 <= 1)
	{
		if (*(x_WORD *)(a1 + 42) < 0x30u)
		{
			sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 47);
			LOBYTE(v207) = (unsigned __int16)(*(x_WORD *)(a1 + 76) + 128) >> 8;
			if (*(x_BYTE *)(a1 + 70))
			{
				BYTE1(v207) = ((unsigned __int16)(*(x_WORD *)(a1 + 78) + 128) >> 8) - 1;
			}
			else
			{
				BYTE1(v207) = (unsigned __int16)(*(x_WORD *)(a1 + 78) + 128) >> 8;
				LOWORD(v207) = v207 - 1;
			}
			if (!*(x_WORD *)(a1 + 42))
			{
				v62 = *(x_BYTE *)(a1 + 70);
				if (v62)
				{
					if (v62 == 1)
					{
						v78 = v207;
						v79 = 0;
						while (v79 < 3)
						{
							v80 = 2;
							v81 = v78 + 512;
							while (v80 < *(x_DWORD *)(a1 + 16) - 3)
							{
								v82 = v81;
								++v80;
								++HIBYTE(v81);
								x_BYTE_10B4E0[v82] = 8;
								x_BYTE_13B4E0[v82] = 1;
							}
							++v79;
							--v78;
						}
						if (!x_BYTE_D41B6)
						{
							v83 = 0;
							v84 = v207 + 1;
							while (v83 < 4)
							{
								v85 = 2;
								v86 = v84 + 512;
								while (v85 < *(x_DWORD *)(a1 + 16) - 2)
								{
									v87 = v86;
									++v85;
									++HIBYTE(v86);
									x_BYTE_13B4E0[v87] &= 0xF7u;
								}
								++v83;
								--v84;
							}
						}
						v88 = -3;
						v89 = v207 - 3;
						while (v88 < 6)
						{
							v90 = -3;
							v91 = v89 - 768;
							while (v90 < *(x_DWORD *)(a1 + 16) + 3)
							{
								v92 = v91;
								++v90;
								++HIBYTE(v91);
								x_BYTE_13B4E0[v92] |= 0x80u;
							}
							++v88;
							++v89;
						}
					}
				}
				else
				{
					v63 = 2;
					v64 = v207 + 2;
					while (v63 < *(x_DWORD *)(a1 + 16) - 3)
					{
						v65 = v64;
						v66 = 0;
						while (v66 < 3)
						{
							v67 = v65;
							++v66;
							--HIBYTE(v65);
							x_BYTE_10B4E0[v67] = 8;
							x_BYTE_13B4E0[v67] = 1;
						}
						++v63;
						++v64;
					}
					if (!x_BYTE_D41B6)
					{
						v68 = 2;
						v69 = v207 + 2;
						while (v68 < *(x_DWORD *)(a1 + 16) - 2)
						{
							v70 = 0;
							v71 = v69 + 256;
							while (v70 < 4)
							{
								v72 = v71;
								++v70;
								--HIBYTE(v71);
								x_BYTE_13B4E0[v72] &= 0xF7u;
							}
							++v68;
							++v69;
						}
					}
					v73 = -3;
					for (j = v207 - 3; v73 < *(x_DWORD *)(a1 + 16) + 3; j++)
					{
						v75 = -3;
						v76 = j + 768;
						while (v75 < 6)
						{
							v77 = v76;
							++v75;
							--HIBYTE(v76);
							x_BYTE_13B4E0[v77] |= 0x80u;
						}
						++v73;
					}
				}
			}
			++*(x_WORD *)(a1 + 42);
			v93 = *(x_BYTE *)(a1 + 70);
			if (v93)
			{
				if (v93 == 1)
				{
					v104 = v207;
					v103 = 3;
					BYTE1(v104) += 3;
					while (v103 < *(x_DWORD *)(a1 + 16) - 3)
					{
						v105 = v104;
						v106 = x_BYTE_11B4E0[(unsigned __int16)v104] + 1;
						v107 = v104 - 1;
						x_BYTE_11B4E0[v105] = v106;
						v108 = v107;
						++v103;
						v104 = v107 + 1;
						++BYTE1(v104);
						++x_BYTE_11B4E0[v108];
					}
					if (x_BYTE_D41B6)
					{
						v110 = v207;
						v109 = 3;
						BYTE1(v110) += 3;
						while (v109 < *(x_DWORD *)(a1 + 16) - 3)
						{
							v111 = x_BYTE_11B4E0[(unsigned __int16)v110];
							if ((unsigned __int8)x_BYTE_14B4E0[(unsigned __int16)v110] > v111)
							{
								x_BYTE_13B4E0[(unsigned __int16)v110] &= 0xF7u;
							}
							else
							{
								x_BYTE_14B4E0[(unsigned __int16)v110] = v111 - 1;
								x_BYTE_13B4E0[(unsigned __int16)v110] |= 8u;
							}
							v112 = v110 - 1;
							v113 = x_BYTE_11B4E0[(unsigned __int16)v112];
							if ((unsigned __int8)x_BYTE_14B4E0[(unsigned __int16)v112] > v113)
							{
								x_BYTE_13B4E0[(unsigned __int16)v112] &= 0xF7u;
							}
							else
							{
								x_BYTE_14B4E0[(unsigned __int16)v112] = v113 - 1;
								x_BYTE_13B4E0[(unsigned __int16)v112] |= 8u;
							}
							v110 = v112 + 1;
							++v109;
							++BYTE1(v110);
						}
					}
				}
			}
			else
			{
				v94 = 3;
				v95 = v207 + 3;
				while (v94 < *(x_DWORD *)(a1 + 16) - 3)
				{
					v96 = v95;
					v97 = x_BYTE_11B4E0[(unsigned __int16)v95] + 1;
					--BYTE1(v95);
					x_BYTE_11B4E0[v96] = v97;
					v98 = v95;
					++v94;
					++BYTE1(v95);
					++v95;
					++x_BYTE_11B4E0[v98];
				}
				if (x_BYTE_D41B6)
				{
					v99 = 3;
					for (k = v207 + 3; v99 < *(x_DWORD *)(a1 + 16) - 3; k++)
					{
						v101 = x_BYTE_11B4E0[k];
						if ((unsigned __int8)x_BYTE_14B4E0[k] > v101)
						{
							x_BYTE_13B4E0[k] &= 0xF7u;
						}
						else
						{
							x_BYTE_14B4E0[k] = v101 - 1;
							x_BYTE_13B4E0[k] |= 8u;
						}
						--HIBYTE(k);
						v102 = x_BYTE_11B4E0[k];
						if ((unsigned __int8)x_BYTE_14B4E0[k] > v102)
						{
							x_BYTE_13B4E0[k] &= 0xF7u;
						}
						else
						{
							x_BYTE_14B4E0[k] = v102 - 1;
							x_BYTE_13B4E0[k] |= 8u;
						}
						++HIBYTE(k);
						++v99;
					}
				}
			}
			if (*(x_WORD *)(a1 + 42) >= 0x30u)
			{
				v114 = *(x_BYTE *)(a1 + 70);
				if (v114)
				{
					if (v114 == 1)
					{
						v123 = v207;
						v124 = 0;
						do
						{
							LOBYTE(v123) = v123 + 1;
							++HIBYTE(v123);
							v125 = v123;
							LOBYTE(v123) = v123 - 2;
							HIBYTE(v123) -= 2;
							v126 = v123;
							LOBYTE(v123) = v123 + 1;
							v127 = x_BYTE_11B4E0[v126] - x_BYTE_11B4E0[v125] + 32;
							HIBYTE(v128) = HIBYTE(v123) + 1;
							if (v127 >= 28)
							{
								if (v127 > 40)
									v127 = (v127 & 7) + 40;
							}
							else
							{
								v127 = (v127 & 3) + 28;
							}
							if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308))
								v129 = 32 - v127 + 32;
							else
								v129 = v127;
							v130 = v128;
							++v124;
							v123 = v128 + 1;
							x_BYTE_12B4E0[v130] = v129;
						} while (v124 < 3);
					}
				}
				else
				{
					v115 = -1;
					for (l = v207 - 1; v115 < *(x_DWORD *)(a1 + 16); x_BYTE_12B4E0[v122] = v121)
					{
						LOBYTE(l) = l + 1;
						++HIBYTE(l);
						v117 = l;
						LOBYTE(l) = l - 2;
						HIBYTE(l) -= 2;
						v118 = l;
						LOBYTE(l) = l + 1;
						v119 = x_BYTE_11B4E0[v118] - x_BYTE_11B4E0[v117] + 32;
						HIBYTE(v120) = HIBYTE(l) + 1;
						if (v119 >= 28)
						{
							if (v119 > 40)
								v119 = (v119 & 7) + 40;
						}
						else
						{
							v119 = (v119 & 3) + 28;
						}
						if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308))
							v121 = 32 - v119 + 32;
						else
							v121 = v119;
						v122 = v120;
						++v115;
						l = v120 + 1;
					}
				}
			}
			return;
		}
		v131 = (int)x_D41A0_BYTEARRAY_0 + 28302;
		*(x_DWORD *)(a1 + 8) = 3;
	LABEL_292:
		sub_6EAB0((signed __int16)((a1 - v131) / 168), -1, 47);
		return;
	}
	if (v1 != 2)
		return;
	if (!*(x_WORD *)(a1 + 42))
	{
		v131 = (int)x_D41A0_BYTEARRAY_0 + 28302;
		*(x_DWORD *)(a1 + 8) = 4;
		goto LABEL_292;
	}
	sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 47);
	LOBYTE(v207) = (unsigned __int16)(*(x_WORD *)(a1 + 76) + 128) >> 8;
	if (*(x_BYTE *)(a1 + 70))
	{
		BYTE1(v207) = ((unsigned __int16)(*(x_WORD *)(a1 + 78) + 128) >> 8) - 1;
	}
	else
	{
		BYTE1(v207) = (unsigned __int16)(*(x_WORD *)(a1 + 78) + 128) >> 8;
		LOWORD(v207) = v207 - 1;
	}
	v132 = *(x_BYTE *)(a1 + 70);
	if (v132)
	{
		if (v132 == 1)
		{
			v140 = v207;
			v139 = 3;
			BYTE1(v140) += 3;
			while (v139 < *(x_DWORD *)(a1 + 16) - 3)
			{
				v141 = x_BYTE_11B4E0[(unsigned __int16)v140];
				v142 = (x_BYTE_11B4E0[(unsigned __int16)(v140 - 2)]
					+ x_BYTE_11B4E0[(unsigned __int16)(v140 + 1)]) >> 1;
				if (v142 < v141)
					x_BYTE_11B4E0[(unsigned __int16)v140] = v141 - 1;
				v143 = v140 - 1;
				v144 = x_BYTE_11B4E0[(unsigned __int16)v143];
				if (v142 < v144)
					x_BYTE_11B4E0[(unsigned __int16)v143] = v144 - 1;
				v140 = v143 + 1;
				++v139;
				++BYTE1(v140);
			}
		}
	}
	else
	{
		v133 = 3;
		for (m = v207 + 3; v133 < *(x_DWORD *)(a1 + 16) - 3; ++m)
		{
			v135 = m + 256;
			HIBYTE(v135) = HIBYTE(m) - 2;
			v136 = x_BYTE_11B4E0[m];
			v137 = (x_BYTE_11B4E0[v135] + x_BYTE_11B4E0[(unsigned __int16)(m + 256)]) >> 1;
			if (v137 < v136)
				x_BYTE_11B4E0[m] = v136 - 1;
			--HIBYTE(m);
			v138 = x_BYTE_11B4E0[m];
			if (v137 < v138)
				x_BYTE_11B4E0[m] = v138 - 1;
			++HIBYTE(m);
			++v133;
		}
	}
	v145 = *(x_WORD *)(a1 + 42) - 1;
	*(x_WORD *)(a1 + 42) = v145;
	if (!v145)
	{
		v146 = *(x_BYTE *)(a1 + 70);
		if (v146)
		{
			if (v146 != 1)
				return;
			v174 = v207;
			v173 = 3;
			BYTE1(v174) += 3;
			while (v173 < *(x_DWORD *)(a1 + 16) - 4)
			{
				v175 = v174 + 2;
				if (x_BYTE_10B4E0[(unsigned __int16)(v174 + 2)] == 8)
					HIBYTE(v175) += *(x_DWORD *)(a1 + 16) >> 1;
				v176 = v174 + 1;
				v177 = v176;
				x_BYTE_10B4E0[(unsigned __int16)v176] = x_BYTE_10B4E0[v175];
				x_BYTE_13B4E0[(unsigned __int16)v176] = x_BYTE_13B4E0[v175];
				x_BYTE_12B4E0[(unsigned __int16)v176--] = 32;
				x_BYTE_13B4E0[v177] |= 0x80u;
				v178 = v176;
				x_BYTE_10B4E0[(unsigned __int16)v176] = x_BYTE_10B4E0[v175];
				x_BYTE_13B4E0[(unsigned __int16)v176] = x_BYTE_13B4E0[v175];
				x_BYTE_12B4E0[(unsigned __int16)v176--] = 32;
				x_BYTE_13B4E0[v178] |= 0x80u;
				v179 = v176;
				x_BYTE_10B4E0[(unsigned __int16)v176] = x_BYTE_10B4E0[v175];
				x_BYTE_13B4E0[(unsigned __int16)v176] = x_BYTE_13B4E0[v175];
				x_BYTE_12B4E0[(unsigned __int16)v176] = 32;
				v180 = x_BYTE_13B4E0[(unsigned __int16)v176--] | 0x80;
				x_BYTE_13B4E0[v179] = v180;
				v181 = x_BYTE_10B4E0[v175];
				v182 = v176;
				++v173;
				x_BYTE_13B4E0[(unsigned __int16)v176] = x_BYTE_13B4E0[v175];
				v174 = v176 + 2;
				x_BYTE_12B4E0[v182] = 32;
				v183 = x_BYTE_13B4E0[v182];
				x_BYTE_10B4E0[v182] = v181;
				++BYTE1(v174);
				x_BYTE_13B4E0[v182] = v183 | 0x80;
			}
			if (x_BYTE_D41B6)
			{
				v185 = v207;
				v184 = 3;
				BYTE1(v185) += 3;
				if (*(x_DWORD *)(a1 + 16) - 4 > 3)
				{
					do
					{
						v186 = v185 + 1;
						v187 = x_BYTE_11B4E0[(unsigned __int16)v186];
						if ((unsigned __int8)x_BYTE_14B4E0[(unsigned __int16)v186] > v187)
						{
							x_BYTE_13B4E0[(unsigned __int16)v186] &= 0xF7u;
						}
						else
						{
							x_BYTE_14B4E0[(unsigned __int16)v186] = v187 - 1;
							x_BYTE_13B4E0[(unsigned __int16)v186] |= 8u;
						}
						v188 = v186 - 1;
						v189 = x_BYTE_11B4E0[(unsigned __int16)v188];
						if ((unsigned __int8)x_BYTE_14B4E0[(unsigned __int16)v188] > v189)
						{
							x_BYTE_13B4E0[(unsigned __int16)v188] &= 0xF7u;
						}
						else
						{
							x_BYTE_14B4E0[(unsigned __int16)v188] = v189 - 1;
							x_BYTE_13B4E0[(unsigned __int16)v188] |= 8u;
						}
						v190 = v188 - 1;
						v191 = x_BYTE_11B4E0[(unsigned __int16)v190];
						if ((unsigned __int8)x_BYTE_14B4E0[(unsigned __int16)v190] > v191)
						{
							x_BYTE_13B4E0[(unsigned __int16)v190] &= 0xF7u;
						}
						else
						{
							x_BYTE_14B4E0[(unsigned __int16)v190] = v191 - 1;
							x_BYTE_13B4E0[(unsigned __int16)v190] |= 8u;
						}
						v192 = v190 - 1;
						v193 = x_BYTE_11B4E0[(unsigned __int16)v192];
						if ((unsigned __int8)x_BYTE_14B4E0[(unsigned __int16)v192] > v193)
						{
							x_BYTE_13B4E0[(unsigned __int16)v192] &= 0xF7u;
						}
						else
						{
							x_BYTE_14B4E0[(unsigned __int16)v192] = v193 - 1;
							x_BYTE_13B4E0[(unsigned __int16)v192] |= 8u;
						}
						v185 = v192 + 2;
						++v184;
						++BYTE1(v185);
					} while (v184 < *(x_DWORD *)(a1 + 16) - 4);
					v194 = -3;
					v195 = v207 - 3;
					goto LABEL_286;
				}
			}
			else
			{
				v196 = v207 + 768;
				x_BYTE_13B4E0[(unsigned __int16)(v196 + 1)] &= 0xF7u;
				x_BYTE_13B4E0[v196] &= 0xF7u;
				v197 = v207 + 767;
				x_BYTE_13B4E0[v197] = x_BYTE_13B4E0[(unsigned __int16)(v207 + 767)] & 0xF7;
				x_BYTE_13B4E0[(unsigned __int16)(v197 - 1)] &= 0xF7u;
			}
			v194 = -3;
			v195 = v207 - 3;
			do
			{
			LABEL_286:
				v198 = -3;
				v199 = v195 - 768;
				while (v198 < *(x_DWORD *)(a1 + 16) + 3)
				{
					v200 = v199;
					++v198;
					++HIBYTE(v199);
					x_BYTE_13B4E0[v200] |= 0x80u;
				}
				++v194;
				++v195;
			} while (v194 < 6);
			return;
		}
		v147 = 3;
		v148 = v207 + 3;
		while (v147 < *(x_DWORD *)(a1 + 16) - 4)
		{
			v149 = v148 + 512;
			if (x_BYTE_10B4E0[(unsigned __int16)(v148 + 512)] == 8)
				v149 += *(x_DWORD *)(a1 + 16) >> 1;
			++HIBYTE(v148);
			v150 = v148;
			x_BYTE_10B4E0[v148] = x_BYTE_10B4E0[v149];
			x_BYTE_13B4E0[v148] = x_BYTE_13B4E0[v149];
			x_BYTE_12B4E0[v148] = 32;
			--HIBYTE(v148);
			x_BYTE_13B4E0[v150] |= 0x80u;
			v151 = v148;
			x_BYTE_10B4E0[v148] = x_BYTE_10B4E0[v149];
			x_BYTE_13B4E0[v148] = x_BYTE_13B4E0[v149];
			x_BYTE_12B4E0[v148] = 32;
			--HIBYTE(v148);
			x_BYTE_13B4E0[v151] |= 0x80u;
			v152 = v148;
			x_BYTE_10B4E0[v148] = x_BYTE_10B4E0[v149];
			x_BYTE_13B4E0[v148] = x_BYTE_13B4E0[v149];
			x_BYTE_12B4E0[v148] = 32;
			v153 = x_BYTE_13B4E0[v148] | 0x80;
			--HIBYTE(v148);
			x_BYTE_13B4E0[v152] = v153;
			v154 = x_BYTE_10B4E0[v149];
			v155 = v148;
			++v147;
			x_BYTE_13B4E0[v148] = x_BYTE_13B4E0[v149];
			HIBYTE(v148) += 2;
			x_BYTE_12B4E0[v155] = 32;
			v156 = x_BYTE_13B4E0[v155];
			x_BYTE_10B4E0[v155] = v154;
			++v148;
			x_BYTE_13B4E0[v155] = v156 | 0x80;
		}
		if (x_BYTE_D41B6)
		{
			v157 = 3;
			v158 = v207 + 3;
			if (*(x_DWORD *)(a1 + 16) - 4 > 3)
			{
				do
				{
					++HIBYTE(v158);
					v159 = x_BYTE_11B4E0[v158];
					if ((unsigned __int8)x_BYTE_14B4E0[v158] > v159)
					{
						x_BYTE_13B4E0[v158] &= 0xF7u;
					}
					else
					{
						x_BYTE_14B4E0[v158] = v159 - 1;
						x_BYTE_13B4E0[v158] |= 8u;
					}
					--HIBYTE(v158);
					v160 = x_BYTE_11B4E0[v158];
					if ((unsigned __int8)x_BYTE_14B4E0[v158] > v160)
					{
						x_BYTE_13B4E0[v158] &= 0xF7u;
					}
					else
					{
						x_BYTE_14B4E0[v158] = v160 - 1;
						x_BYTE_13B4E0[v158] |= 8u;
					}
					--HIBYTE(v158);
					v161 = x_BYTE_11B4E0[v158];
					if ((unsigned __int8)x_BYTE_14B4E0[v158] > v161)
					{
						x_BYTE_13B4E0[v158] &= 0xF7u;
					}
					else
					{
						x_BYTE_14B4E0[v158] = v161 - 1;
						x_BYTE_13B4E0[v158] |= 8u;
					}
					--HIBYTE(v158);
					v162 = x_BYTE_11B4E0[v158];
					if ((unsigned __int8)x_BYTE_14B4E0[v158] > v162)
					{
						x_BYTE_13B4E0[v158] &= 0xF7u;
					}
					else
					{
						x_BYTE_14B4E0[v158] = v162 - 1;
						x_BYTE_13B4E0[v158] |= 8u;
					}
					HIBYTE(v158) += 2;
					++v157;
					++v158;
				} while (v157 < *(x_DWORD *)(a1 + 16) - 4);
				v163 = -3;
				v164 = v207 - 3;
				goto LABEL_261;
			}
		}
		else
		{
			v165 = v207 + 259;
			HIBYTE(v165) = (unsigned __int16)(v207 + 3) >> 8;
			x_BYTE_13B4E0[(unsigned __int16)(v207 + 259)] &= 0xF7u;
			v166 = v165;
			v167 = x_BYTE_13B4E0[v165] & 0xF7;
			--HIBYTE(v165);
			x_BYTE_13B4E0[v166] = v167;
			v168 = v165;
			v169 = x_BYTE_13B4E0[v165] & 0xF7;
			--HIBYTE(v165);
			x_BYTE_13B4E0[v168] = v169;
			x_BYTE_13B4E0[v165] &= 0xF7u;
		}
		v163 = -3;
		v164 = v207 - 3;
	LABEL_261:
		while (v163 < *(x_DWORD *)(a1 + 16) + 3)
		{
			v170 = -3;
			v171 = v164 + 768;
			while (v170 < 6)
			{
				v172 = v171;
				++v170;
				--HIBYTE(v171);
				x_BYTE_13B4E0[v172] |= 0x80u;
			}
			++v163;
			++v164;
		}
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41B6: using guessed type char x_BYTE_D41B6;

//----- (0005B070) --------------------------------------------------------
unsigned int sub_5B070(int a1)
{
	int v1; // eax
	char v2; // dl
	char v3; // bl
	unsigned int result; // eax

	v1 = x_WORD_15B4E0[((unsigned __int8)((unsigned __int16)(*(x_WORD *)(a1 + 78) - 128) >> 8) << 8)
		+ ((unsigned __int16)(*(x_WORD *)(a1 + 76) - 128) >> 8)];
	v2 = 0;
	while (1)
	{
		result = x_DWORD_EA3E4[v1];
		if (result <= x_DWORD_EA3E4[0])
			break;
		if (*(x_BYTE *)(result + 63) == 14)
		{
			v3 = *(x_BYTE *)(result + 64);
			if (v3 == 1 || v3 == 2)
			{
				v2 = 1;
				break;
			}
		}
		v1 = *(unsigned __int16 *)(result + 22);
	}
	if (!v2)
		result = 0;
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0005B100) --------------------------------------------------------
void sub_5B100(int a1)
{
	int v1; // edi
	char v2; // ST60_1
	char v3; // ST61_1
	unsigned int v4; // eax
	int v69; // [esp+0h] [ebp-68h]
	int v78; // [esp+3Ch] [ebp-2Ch]

	if (*(x_DWORD *)(a1 + 8) <= 2u)
	{
		v1 = *(signed __int16 *)(a1 + 80);
		if (*(x_WORD *)(a1 + 44))
		{
			v69 = (2 * ((*(unsigned __int16 *)(a1 + 150) << 8) + 512) + 128) >> 8;
			v78 = 2;
		}
		else
		{
			v78 = (2 * ((*(unsigned __int16 *)(a1 + 150) << 8) + 512) + 128) >> 8;
			v69 = 2;
		}
		v2 = (*(x_WORD *)(a1 + 76) >> 8) - (v69 >> 1);
		v3 = (*(x_WORD *)(a1 + 78) >> 8) - (v78 >> 1);
	}
	v4 = *(x_DWORD *)(a1 + 8);
	if (v4 <= 4)
		JUMPOUT(__CS__, (int*) *(&off_5B0E4 + v4));
}
// 5B0E4: using guessed type void *off_5B0E4;
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0005B7A0) --------------------------------------------------------
void sub_5B7A0_prepare_pallette()//23C7A0
{
	int v0; // ebx
	unsigned int v1; // edx
	int *v2; // ecx
	signed int i; // eax
	//int v4; // edi
	//int v6; // [esp+0h] [ebp-Ch]
	//int v7; // [esp+4h] [ebp-8h]

	v0 = x_BYTE_D41B5;
	sub_3B4D0_fill_unk_D4350_256(x_BYTE_D41B5);//21C4D0
	v1 = 0x100u % (256 / v0);
	v2 = x_DWORD_DDF50;
	/*for ( i = 0; i < (signed int)(0x100u / (256 / v0)); i++ )
	{
	  v1 = 0;
	  while ( v1 < 256 / v0 )
	  {
		v6 = v1 * v0 + BLOCK32DAT_BEGIN_BUFFER;
		v7 = i * v0 << 8;
		++v2;
		v4 = v7 + v6;
		++v1;
		*(v2 - 1) = v4;
	  }
	}*/ //fix it
	//_wcpp_1_unwind_leave__93(i, v1, v0, (x_DWORD)v2, v6, v7);// fix//23C830
	sub_5B840_load_pallette_and_help_pallette();//23C840
}
// 5B830: using guessed type int /*__fastcall*/ _wcpp_1_unwind_leave__93(x_DWORD, x_DWORD, x_DWORD, x_DWORD, x_DWORD, x_DWORD);
// D41B5: using guessed type char x_BYTE_D41B5;
// DDF50: using guessed type int x_DWORD_DDF50[];
// E9C2C: using guessed type int x_DWORD_E9C2C;

//----- (0005B840) --------------------------------------------------------
void sub_5B840_load_pallette_and_help_pallette()//23C840
{
	sub_53E60_readfile_and_decompress("data/pald-0.dat", xadatapald0dat2.var28_begin_buffer);
	sub_53E60_readfile_and_decompress("data/clrd-0.dat", xadataclrd0dat.var28_begin_buffer);
}
// EA3D8: using guessed type int *xadatapald0dat2.var28_begin_buffer;

//----- (0005B870) --------------------------------------------------------
void sub_5B870(Bit8u *langbuffer, Bit8u** langindexbuffer, Bit32u count)//23c870
{
	//sub_5B870((x_BYTE *)x_DWORD_D41BC_langbuffer, 0xE9C4C, 471);
	//edx 87ab14 ecx 1d7
  //x_BYTE *v3; // edx
  //int v4; // ecx
  //int result; // eax
  //x_DWORD *v6; // ebx
  //x_BYTE *v7; // ebx

	Bit32u langindex = 0;
	Bit32u indexindex = 0;
	while (indexindex < count)//1d7
	{
		langindexbuffer[indexindex] = (langbuffer + langindex);
		while (langbuffer[langindex++]);
		indexindex++;
	}
}



//----- (0005B8D0) --------------------------------------------------------
void sub_5B8D0_initialize()//23c8d0
{
	//int v0; // eax

	int v2; // eax
	int v3; // edx

	//fix it
	v3 = 0;//jen pro zvuk
	//fix it

	sub_70890_print_header();//23C8D6 - 251890
	if ((x_D41A0_BYTEARRAY_4_struct.setting_byte4_25) & 8)
		sub_5C490_testers_info();//23C8E6 - 23D490
	if (sub_53D10_create_nether_subdir(x_D41A0_BYTEARRAY_4_struct.harddisk_number, (Bit8u*)"/netherw", (Bit8u*)"save") != 3//23C906 - 234D10
		|| sub_53D10_create_nether_subdir(x_D41A0_BYTEARRAY_4_struct.harddisk_number, (Bit8u*)"/netherw", (Bit8u*)"cdata") != 3//23C931 - 234D10
		|| sub_53D10_create_nether_subdir(x_D41A0_BYTEARRAY_4_struct.harddisk_number, (Bit8u*)"/netherw", (Bit8u*)"clevels") != 3//23C95C - 234D10
		|| sub_53D10_create_nether_subdir(x_D41A0_BYTEARRAY_4_struct.harddisk_number, (Bit8u*)"/netherw", (Bit8u*)"sound") != 3//23C987 - 234D10
		|| sub_53D10_create_nether_subdir(x_D41A0_BYTEARRAY_4_struct.harddisk_number, (Bit8u*)"/netherw", (Bit8u*)"language") != 3//23C9B2 - 234D10
		|| sub_53D10_create_nether_subdir(x_D41A0_BYTEARRAY_4_struct.harddisk_number, (Bit8u*)"/netherw", (Bit8u*)"shots") != 3)//23C9DD - 234D10
	{
		myprintf("Error creating setup directories.\n");
		exit(-1);
	}
	sub_560D0_create_sound_dir();//23C9ED - 2370D0
	sub_5BCC0_set_any_variables1();//23C9F2 - 23CCC0
	if (!sub_5BF50_load_psxdata())//23C9F7 - 23CF50 //neco se soubory asi jejich naceteni, nebo jen soubor palety
		exit(-1);
	sub_5C1B0_set_any_variables2();//23CA05 - 23D1B0
	if (!sub_54200_create_user_directiores())//23CA0A - 235200 //tady jedou i ty procenta
	{
		myprintf("ERROR COPYING DATA FILES TO LOCAL DRIVE \n");
		exit(-1);
	}
	sub_71410_process_tmaps();//252410

	//sub_6EB90((unsigned int **)*filearray_2aa18c);//24FB90
	//2AA18C
	sub_6EB90(&filearray_2aa18c[filearrayindex_POINTERSDATTAB]);//24fb90
	//sub_6EB90((unsigned int **)&*filearray_2aa18c[0x60]);//24FB90
	//2AA1EC
	sub_6EB90(&filearray_2aa18c[filearrayindex_BUILD00DATTAB]);//24fb90

	sub_101C0();//23CA36 - 1f11c0 //sem se to vubec nedostane
	//zkontrolovat inicializaci



	//*xadataspellsdat.var28_begin_buffer = (Bit8u*)malloc(10000);//fix it

	/*if ( !(x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 8) )
	//fix it //x_D41A0_BYTEARRAY_4_struct.setting_byte3_24=50CF38 =0
	*/
	//*xadataspellsdat.var28_begin_buffer = (Bit8u*)malloc(50000);
	sub_53E60_readfile_and_decompress("data/spells.dat", xadataspellsdat.var28_begin_buffer);//234e60 buffer - 2ab818

	//v0 = sub_5C0A0();//23d0a0
	if (x_BYTE_D4B80)
		exit(-1);
	x_BYTE_D4B80 = 1;
	x_WORD_180660_VGA_type_resolution = 1;//fix it
	if (x_WORD_180660_VGA_type_resolution & 1)
		sub_72883_clear_text_mode(/*sub_5C0A0(), */(void *)x_DWORD_180628b_screen_buffer, 0xC8u, 0);//253883
	else
		sub_728A9_clear_graphics_mode((void *)x_DWORD_180628b_screen_buffer, 0x1E0u, 0);//2538a9

	  //VGA_Write_basic_pallette(basic_pal_buffer);

	sub_90B27_VGA_pal_fadein_fadeout(0, 0x10u, 0);//271B27 tady se zapina vga
	//fixed
	sub_728A9_clear_graphics_mode((void *)x_DWORD_180628b_screen_buffer, 0x1E0u, 0);//fixed
	sub_75200_VGA_Blit640(480);//debug
	sub_75200_VGA_Blit640(480);//debug
	//fixed
  //*xadatapald0dat2.var28_begin_buffer = (Bit8u*)malloc(10000);//fix it
	memset((void*)*xadatapald0dat2.var28_begin_buffer, 0, 768);
	sub_41A90_VGA_pallette_install(*xadatapald0dat2.var28_begin_buffer);//222a90
	x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 = 0;//fix it
	if ((x_D41A0_BYTEARRAY_4_struct.setting_byte1_22) & 0x110)//2a51a4 // 38cf50+16 //00 druh grafiky/inicializace
	{
		if (x_WORD_180660_VGA_type_resolution & 1)
			sub_90D6E_VGA_set_video_mode_320x200_and_pallette(*xadatapald0dat2.var28_begin_buffer);
		else
			sub_90E07_VGA_set_video_mode_640x480_and_pallette(*xadatapald0dat2.var28_begin_buffer);
		memset((void*)*xadatapald0dat2.var28_begin_buffer, 0, 768);
		sub_41A90_VGA_pallette_install(*xadatapald0dat2.var28_begin_buffer);//222a90
	}
	else
	{
		sub_90B27_VGA_pal_fadein_fadeout(0, 0x10u, 0);
		x_WORD_180660_VGA_type_resolution = 1;//fix it
		if (x_WORD_180660_VGA_type_resolution & 1)
			sub_90D6E_VGA_set_video_mode_320x200_and_pallette((unsigned __int8 *)x_DWORD_180628b_screen_buffer);//3aa0a4
		else
			sub_90E07_VGA_set_video_mode_640x480_and_pallette((unsigned __int8 *)x_DWORD_180628b_screen_buffer);
		memset((void*)*xadatapald0dat2.var28_begin_buffer, 0, 768);
		sub_41A90_VGA_pallette_install(*xadatapald0dat2.var28_begin_buffer);//222a90
	}
	/*if ( x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 8 )
	  sub_8C2CD();
	else
	  sub_753D0();
	  ?keyboard init
	  */
	x_BYTE_E3799 = x_BYTE_E3798_sound_active2;
	x_BYTE_E37FD = x_BYTE_E37FC;
	sub_8CEDF_install_mouse();
	if (!x_DWORD_E3768)
	{
		sub_5BC20();
		myprintf("ERROR : MOUSE DRIVER NOT INSTALLED\n");
		exit(-1);
	}
	//mouse init

	//pointersdat_buffer = xadatapointersdat.var28_begin_buffer;//eb394 - 2bc394 -446f1{set in 23cf50}

	//nema to byt buffer obrazovky?! ---

	sub_8CD27_set_cursor(*filearray_2aa18c[filearrayindex_POINTERSDATTAB].posistruct);//anything with vga, maybe mouse cursor//26dd27 //xadatapointersdat asi 1a6f44
	//1a6f44->1a6578 00 00 pointer->0b0005a1a1a1a1a10005a1b413aaa1
	//nastavi se zde:sub_6EB90(&filearray_2aa18c[filearrayindex_POINTERSDATTAB]);//24fb90

	//pak je to v 809380

	//VGA_Set_Cursor(*filearray_2aa18c[filearrayindex_POINTERSDATTAB].posistruct,0);


	v2 = sub_5C430_multi_allocation(); //23d430  
	sub_46DD0_init_sound_and_music(/*v2, v3, (char*)filearray_2aa18c[filearrayindex_POINTERSDATTAB].begin_buffer*/);//init sound and music//227DD0
	//x_WORD_E2A14_sound_activel = 0;x_BYTE_E3798_sound_active2 = 0;//debug tittes

}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D41A4: using guessed type int x_DWORD_D41A4;
// D4B80: using guessed type char x_BYTE_D4B80;
// D918C: using guessed type int **filearray_2aa18c;
// D91EC: using guessed type int *off_D91EC;
// E3768: using guessed type int x_DWORD_E3768;
// E3798: using guessed type char x_BYTE_E3798_sound_active2;
// E3799: using guessed type char x_BYTE_E3799;
// E37FC: using guessed type char x_BYTE_E37FC;
// E37FD: using guessed type char x_BYTE_E37FD;
// EA3D8: using guessed type int *xadatapald0dat2.var28_begin_buffer;
// EB394: using guessed type int **filearray_2aa18c[0];
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0005BC20) --------------------------------------------------------
void sub_5BC20()
{
	if (x_BYTE_D4B80 == 1)
	{
		sub_5C450();
		if (x_DWORD_E3768)
			sub_54600_mouse_reset();//mouse reset
		if (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 8)
			sub_8C2DE();
		else
			sub_75420();
		sub_46F50_sound_proc7();
		sub_8C21F_any_graphics_command();
		sub_72D04();
		sub_6FE20();
		sub_5C060();
	}
	sub_83E80_sound_proc_99(x_DWORD_D4198);
	sub_83E80_sound_proc_99(x_D41A0_BYTEARRAY_0);
	sub_83E80_sound_proc_99(x_D41A0_BYTEARRAY_4);
	sub_86860(x_WORD_1803EC);
	sub_86BD0_freemem1();
}
// D4198: using guessed type int x_DWORD_D4198;
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// D4B80: using guessed type char x_BYTE_D4B80;
// E3768: using guessed type int x_DWORD_E3768;
// 1803EC: using guessed type __int16 x_WORD_1803EC;

//----- (0005BCC0) --------------------------------------------------------
void sub_5BCC0_set_any_variables1()
{
	//int result; // eax //push ebx=0 ebp=355250

	x_BYTE_EB39E_keys[0] = 0x48;//2bc39e
	x_BYTE_EB39E_keys[1] = 0x50;//2bc39f
	x_BYTE_EB39E_keys[3] = 0x4D;//2bc3a1
	x_BYTE_EB39E_keys[7] = 0x36;//2bc3a5
	x_BYTE_EB39E_keys[8] = 0x36;//2bc3a6
	//result = x_D41A0_BYTEARRAY_4;//2a51a4
	x_BYTE_EB39E_keys[5] = 0x1D;//2bc3A3
	x_D41A0_BYTEARRAY_4_struct.byteindex_4 = 0;//dword 38cf54
	x_D41A0_BYTEARRAY_4_struct.dwordindex_6 = 127;//dword 38cf56
	x_D41A0_BYTEARRAY_4_struct.dwordindex_8 = 127;//dword 38cf58
	x_BYTE_EB39E_keys[2] = 0x4B;//2BC3A0
	x_D41A0_BYTEARRAY_4_struct.byteindex_A = 1;//byte 38cf5a
	x_BYTE_EB39E_keys[4] = 0x1C;//2BC3A2
	x_D41A0_BYTEARRAY_4[11] = 0;//byte 38cf5b
	x_BYTE_EB39E_keys[6] = 0x38;//2BC3A4
	x_D41A0_BYTEARRAY_4[12] = 0;//byte 38cf5c
	x_BYTE_EB39E_keys[9] = 0x38;//2BC3A7
	x_D41A0_BYTEARRAY_4[13] = 0;//byte 38cf5d
	//return result;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EB39E: using guessed type char x_BYTE_EB39E_keys;
// EB39F: using guessed type char x_BYTE_EB39F;
// EB3A0: using guessed type char x_BYTE_EB3A0;
// EB3A1: using guessed type char x_BYTE_EB3A1;
// EB3A2: using guessed type char x_BYTE_EB3A2;
// EB3A3: using guessed type char x_BYTE_EB3A3;
// EB3A4: using guessed type char x_BYTE_EB3A4;
// EB3A5: using guessed type char x_BYTE_EB3A5;
// EB3A6: using guessed type char x_BYTE_EB3A6;
// EB3A7: using guessed type char x_BYTE_EB3A7;

//----- (0005BDC0) --------------------------------------------------------
int sub_5BDC0_set_mouse_position(__int16 a1, __int16 a2)
{
	__int16 v2; // bx
	__int16 v3; // si
	int v4; // ecx
	int v5; // edx
	int result; // eax
	int v7; // [esp+0h] [ebp-1Ch]
	int v8; // [esp+8h] [ebp-14h]
	int v9; // [esp+Ch] [ebp-10h]

	v2 = a1;
	v3 = a2;
	memset(&v7, 0, 28);
	if (a1 < 0)
		v2 = 0;
	if (a2 < 0)
		v3 = 0;
	_disable();
	v4 = x_DWORD_E36C4;
	x_WORD_E375C_mouse_position_x = v2;
	x_WORD_E3760_mousex = v2;
	x_WORD_E375E_mouse_position_y = v3;
	x_WORD_E3762_mousey = v3;
	x_DWORD_1805B8 = v2;
	x_DWORD_1805B0 = v2;
	v7 = 4;
	x_DWORD_1805BC = v3;
	x_DWORD_1805B4 = v3;
	if (x_DWORD_E36C4)
	{
		v5 = x_DWORD_1805B0;
		*(x_DWORD *)(x_DWORD_E36C4 + 40) = v3;
		*(x_DWORD *)(v4 + 36) = v5;
	}
	if (x_WORD_180660_VGA_type_resolution & 8)
	{
		v2 *= 8;
		v3 *= 8;
	}
	v8 = v2;
	v9 = v3;
	result = int386(0x33, (REGS*)&v7, (REGS*)&v7);//set mouse cursor position
	_enable();
	return result;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// E36C4: using guessed type int x_DWORD_E36C4;
// E375C: using guessed type __int16 x_WORD_E375C_mouse_position_x;
// E375E: using guessed type __int16 x_WORD_E375E_mouse_position_y;
// E3760: using guessed type __int16 x_WORD_E3760;
// E3762: using guessed type __int16 x_WORD_E3762;
// 1805B0: using guessed type int x_DWORD_1805B0;
// 1805B4: using guessed type int x_DWORD_1805B4;
// 1805B8: using guessed type int x_DWORD_1805B8;
// 1805BC: using guessed type int x_DWORD_1805BC;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0005BE80) --------------------------------------------------------
Bit8u sub_5BE80_test_pallette(Bit8u *pallette, Bit8u a2, Bit8u a3, Bit8u a4)//23ce80
{
	//Bit8u *v4; // eax
	Bit16u count_of_colors; // edx
	Bit16s v6; // ecx
	//Bit16u v7; // edx
	Bit16s v9; // esi
	Bit16s v10; // esi
	Bit16s v11; // edi
	//unsigned int v12; // [esp+0h] [ebp-8h]
	Bit8u result; // [esp+4h] [ebp-4h]

	//fix it
	result = 0;
	//fix it

	//v4 = pallette;//1a7358
	Bit16u pallette_index = 0;
	if (x_WORD_180660_VGA_type_resolution & 6)
		count_of_colors = 16;
	else
		count_of_colors = 256;
	v6 = 9999;
	//v12 = count_of_colors;
	//v7 = 0;
	//if (count_of_colors > 0)
	//{
	for (Bit16u i = 0;i < count_of_colors;i++)
	{
		v9 = a3 - pallette[pallette_index + 1];//eax[1]
		v10 = (a2 - pallette[pallette_index]) * (a2 - pallette[pallette_index]) + v9 * v9;
		v11 = a4 - pallette[pallette_index + 2];
		if (v10 + v11 * v11 < v6)
		{
			v6 = v10 + v11 * v11;
			result = i;
		}
		//v7++;
		pallette_index += 3;
	} //while (v7 < count_of_colors);
//}
	return result;
}
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

/*
char __cdecl sub_5BE80(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  unsigned __int8 *v4; // eax
  signed int v5; // edx
  signed int v6; // ecx
  unsigned int v7; // edx
  int v9; // esi
  int v10; // esi
  int v11; // edi
  unsigned int v12; // [esp+0h] [ebp-8h]
  char v13; // [esp+4h] [ebp-4h]

  v4 = a1;//eax=[ebp+14]
  if ( word_180660 & 6 )//[351660]&6
	v5 = 16;//edx
  else
	v5 = 256;//edx
  v6 = 9999;//ecx
  v12 = v5;[ebp-8]=edx
  v7 = 0;//edx
  if ( v12 <= 0 )[ebp-8]<0
	return v13;
  do
  {
	v9 = a3 - v4[1];//[ebp+1c]-a1[1]
	v10 = (a2 - *v4) * (a2 - *v4) + v9 * v9;
	v11 = a4 - v4[2];//[ebp+20]-[eax+2]
	if ( v10 + v11 * v11 < v6 )
	{
	  v6 = v10 + v11 * v11;
	  v13 = v7;
	}
	++v7;
	v4 += 3;
  }
  while ( v7 < v12 );
  return v13;
}
*/

//----- (0005BF10) --------------------------------------------------------
char sub_5BF10()
{
	char result; // al

	if (x_BYTE_E3799)
		sub_8D8F0_sound_proc3_endsample();
	if (x_BYTE_E37FD)
		sub_8E020_sound_proc14_stopsequence();
	result = 0;
	x_BYTE_E37FD = 0;
	x_BYTE_E3799 = 0;
	return result;
}
// E3799: using guessed type char x_BYTE_E3799;
// E37FD: using guessed type char x_BYTE_E37FD;





//----- (0005BF50) --------------------------------------------------------
signed int sub_5BF50_load_psxdata()//23cf50 //find 2bc394
{
	signed int result; // eax

	x_DWORD_181C40_vga_init_buffer = (Bit8u*)sub_83D70_malloc1(0x100); //fix it 264D70
	if (x_DWORD_181C40_vga_init_buffer)
	{
		if (sub_5C380_test_vga_driver_header(0x101))
			x_BYTE_D41B4_vesa_driver_finded = 1;
		else
			myprintf("NO VESA DRIVER DETECTED\n");
		if (sub_84250_load_file_array(psxasearchd))//psxasearchd~=2a9a54   set 2bc394(after 2A9A54) - set 2bab20
		{
			myprintf("NOT ENOUGH MEMORY\n");
			sub_90D3F_unload_file_array(psxasearchd);
			result = 0;
		}
		else
		{
			if (sub_84250_load_file_array(psxadatabuild00dat))
			{
				myprintf("NOT ENOUGH MEMORY\n");
				sub_90D3F_unload_file_array(psxasearchd);
				sub_90D3F_unload_file_array(psxadatabuild00dat);
				result = 0;
			}
			else
			{
				sub_539A0_load_bldgprm();
				if (sub_84250_load_file_array(psxawscreen))
				{
					sub_90D3F_unload_file_array(psxawscreen);
					myprintf("NOT ENOUGH MEMORY\n");
					result = 0;
				}
				else
				{
					x_WORD_180660_VGA_type_resolution = 1;
					sub_83B50();//264B50
					result = 1;
				}
			}
		}
	}
	else
	{
		myprintf("NO VESA DRIVER DETECTED\n");
		result = 0;
	}
	return result;
}
// D41B4: using guessed type char x_BYTE_D41B4_vesa_driver_finded;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;
// 181C40: using guessed type int x_DWORD_181C40_vga_init_buffer;

//----- (0005C060) --------------------------------------------------------
signed int sub_5C060()
{
	sub_90D3F_unload_file_array(psxasearchd);
	sub_90D3F_unload_file_array(psxadatabuild00dat);
	sub_90D3F_unload_file_array(psxawscreen);
	return 1;
}

//----- (0005C0A0) --------------------------------------------------------
int sub_5C0A0()
{
	char *v0; // ebx
	unsigned int v1; // ecx
	char v2; // dl
	char v3; // ah
	char v4; // dh
	int result; // eax

	v0 = (char*)*xadataspellsdat.var28_begin_buffer;
	v1 = 0;
	do
	{
		while (1)
		{
			v2 = v0[53];
			v0[1] = 0;
			v3 = v0[27];
			v0[53] = v2 & 0xFE;
			v4 = v0[79];
			v0[27] = v3 & 0xFE;
			v0[79] = v4 & 0xFE;
			if (v1 < 7)
			{
				if (v1 < 3)
				{
					if (!v1)
						v0[53] |= 1u;
				}
				else if (v1 <= 4 || v1 == 6)
				{
					goto LABEL_18;
				}
			}
			else
			{
				if (v1 <= 7)
				{
					v0[27] |= 1u;
					goto LABEL_22;
				}
				if (v1 < 0xB)
				{
					if (v1 != 8)
						goto LABEL_22;
				LABEL_18:
					v0[1] |= 4u;
					goto LABEL_22;
				}
				if (v1 <= 0xC)
					goto LABEL_18;
				if (v1 >= 0xE)
				{
					if (v1 <= 0xE)
						goto LABEL_18;
					if (v1 == 23)
					{
						*(x_DWORD *)(v0 + 10) = 50000;
						*((x_DWORD *)v0 + 9) = 70000;
						*(x_DWORD *)(v0 + 62) = 90000;
					}
				}
			}
		LABEL_22:
			result = 1000 / *(x_DWORD *)(v0 + 58);
			if (*(x_DWORD *)(v0 + 62) <= 0 && result > 0)
			{
				v0[1] |= 0x20u;
				goto LABEL_30;
			}
			if (*((x_DWORD *)v0 + 9) > 0 || 1000 / *((x_DWORD *)v0 + 8) <= 0)
				break;
			v0[1] |= 0x10u;
			++v1;
			v0 += 80;
			if ((signed int)v1 >= 26)
				return result;
		}
		v0[1] |= 8u;
	LABEL_30:
		++v1;
		v0 += 80;
	} while ((signed int)v1 < 26);
	return result;
}

//----- (0005C1B0) --------------------------------------------------------
signed int sub_5C1B0_set_any_variables2()//23CA05 - 23D1B0
{
	//x_BYTE *v0; // eax
	//int v1; // eax
	//int v2; // eax
	//int v3; // eax
	//int v4; // eax
	char v5; // dl
	unsigned __int16 v6; // dx
	unsigned __int16 v7; // bx

	sub_5C330();//23D330
	//v0 = (x_BYTE *)x_D41A0_BYTEARRAY_0;
	x_D41A0_BYTEARRAY_0[8618] = 1;
	x_D41A0_BYTEARRAY_0[8619] = 1;
	x_D41A0_BYTEARRAY_0[8620] = 1;
	x_D41A0_BYTEARRAY_0[8621] = 1;
	x_D41A0_BYTEARRAY_0[8622] = 1;
	x_D41A0_BYTEARRAY_0[8623] = 1;
	x_D41A0_BYTEARRAY_0[8624] = 1;
	x_D41A0_BYTEARRAY_0[8625] = 0;
	x_D41A0_BYTEARRAY_0[8626] = 1;
	x_D41A0_BYTEARRAY_0[8627] = 1;
	x_D41A0_BYTEARRAY_0[8628] = 1;
	x_D41A0_BYTEARRAY_0[8630] = 1;
	x_D41A0_BYTEARRAY_0[8631] = 1;
	x_D41A0_BYTEARRAY_0[8632] = 1;
	x_D41A0_BYTEARRAY_0[8633] = 1;
	sub_84050();//265050
	if (x_D41A0_BYTEARRAY_0[34])
	{
		x_D41A0_BYTEARRAY_0[8586] = 1;
		x_D41A0_BYTEARRAY_0[8588] = 1;
		x_D41A0_BYTEARRAY_0[8598] = 1;
	}
	else
	{
		x_D41A0_BYTEARRAY_0[8586] = 0;
		x_D41A0_BYTEARRAY_0[8588] = 0;
		x_D41A0_BYTEARRAY_0[8598] = 0;
	}
	x_D41A0_BYTEARRAY_0[8587] = 1;
	x_D41A0_BYTEARRAY_0[8591] = 1;
	x_D41A0_BYTEARRAY_0[8590] = 1;
	x_D41A0_BYTEARRAY_0[8589] = 40;
	x_D41A0_BYTEARRAY_0[8599] = 0;
	x_D41A0_BYTEARRAY_0[8600] = 0;
	x_D41A0_BYTEARRAY_0[8601] = 0;
	x_D41A0_BYTEARRAY_0[14] = 2;
	//v4 = x_D41A0_BYTEARRAY_4;
	strcpy_s((char *)(&x_D41A0_BYTEARRAY_4[4 + 145]), sizeof("NETHERW"), "NETHERW");
	x_D41A0_BYTEARRAY_4[4 + 184] = 256;
	v5 = '\0';
	x_D41A0_BYTEARRAY_4[4 + 218] = 25;
	x_D41A0_BYTEARRAY_4[4 + 57] = v5;
	v6 = x_D41A0_BYTEARRAY_4[4 + 43];
	v7 = x_D41A0_BYTEARRAY_4[4 + 218];
	x_D41A0_BYTEARRAY_4[4 + 30] = 0;
	if (v6 >= v7)
		x_D41A0_BYTEARRAY_4[4 + 43] = v7 - 1;
	sub_87090();
	if (x_BYTE_180552)
		x_D41A0_BYTEARRAY_4[4 + 10] = 1;
	sub_2CA90(x_D41A0_BYTEARRAY_0[8589]);//268090
	return 1;
}
// D0C18: using guessed type char x_BYTE_D0C18;
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// 180552: using guessed type char x_BYTE_180552;

Bit32u readdword(Bit8s* a, Bit32u b)
{
	return(*(Bit32u*)&a[b]);
}

//----- (0005C330) --------------------------------------------------------
void sub_5C330()//23D330
{
	//signed int i; // edx
	//int v1; // eax

	if (x_D41A0_BYTEARRAY_0)//386035
	{
		for (int i = 0; i < 0x3E9; i++)
		{
			//Bit32s x = *x_D41A0_BYTEARRAY_0 + 0x6e8e + 168 * i;//fix
			//var_2BB3E0_x_DWORD_EA3D4_14.pointer
		}
		//*filearray_2aa18c[7] = (Bit8u*)(Bit32u*)readdword((Bit8s*)x_D41A0_BYTEARRAY_0, 0) + 0x6e8e + 168 * i;//fix it - this is dword // fix it
	//356038([x_D41A0_BYTEARRAY_0=2a51a0]) +6e8e
	//[2bb3e0+edx*4]-<
	//edx++
	//356038([x_D41A0_BYTEARRAY_0]) +6e8e + a8 * i
	  //*filearray_2aa18c[7] = (Bit8u*)(Bit32u*)readdword((Bit8s*)x_D41A0_BYTEARRAY_0,0) + 0x6e8e + 168 * i;//fix it - this is dword // fix it
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E0: using guessed type int x_DWORD_EA3E0_copyto_x_DWORD_EA3E0[];

//----- (0005C380) --------------------------------------------------------
bool sub_5C380_test_vga_driver_header(Bit16u testlenght)//23D380
{
	/*
  //Bit16u i; // eax

  if ( !(unsigned __int16)sub_995B0_test_vga_driver() )
  {
	  //(352C40[0x10]&0xffff<<4)+352C40[0x10-2]
	  //Bit16u x=x_DWORD_181C40_vga_init_buffer[14] + (x_DWORD_181C40_vga_init_buffer[15] << 8) + (x_DWORD_181C40_vga_init_buffer[9] << 24);
	for (Bit32u i = x_DWORD_181C40_vga_init_buffer[14] + (x_DWORD_181C40_vga_init_buffer[15] << 8) + (x_DWORD_181C40_vga_init_buffer[9] << 12);i != -1;++i )
	{
	  if ( a1 == i )
		return 1;
	}
  }
  return 0;*/
	return true;
}
// 181C40: using guessed type int x_DWORD_181C40_vga_init_buffer;

//----- (0005C3D0) --------------------------------------------------------
signed int sub_5C3D0_file_decompress(Bit8u* input, Bit8u* output)
{
	//char v3; // [esp+0h] [ebp-8h]
	//char v4; // [esp+1h] [ebp-7h]
	//char v5; // [esp+2h] [ebp-6h]
	//char v6; // [esp+3h] [ebp-5h]
	//char v7; // [esp+4h] [ebp-4h]

	char RNSSING[5] = "RNC\x1";
	//v3 = 82;
	//v4 = 78;
	//v6 = 1;
	//v5 = 67;
	//v7 = 0;
	if (strncmp((const char*)input, RNSSING, 4))
		return 0;
	sub_9894C_decompress(input, output);
	return 1;
}
// 99682: using guessed type x_DWORD strncmp(x_DWORD, x_DWORD, x_DWORD);

//----- (0005C430) --------------------------------------------------------
int sub_5C430_multi_allocation()//23d430
{
	int result; // eax

	result = sub_74556();//255556 push ebp 355250
	x_D41A0_BYTEARRAY_4_struct.setting_216 = result;
	return result;
}
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (0005C450) --------------------------------------------------------
void sub_5C450()
{
	if (x_D41A0_BYTEARRAY_4_struct.setting_216)
		sub_72D04();
}
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (0005C490) --------------------------------------------------------
int sub_5C490_testers_info()
{
	int result; // eax
	int v1; // edx

	myprintf("\n");
	myprintf("***********************************************************\n");
	myprintf("*   TESTERS: WRITE DOWN THE ABOVE VERSION DATE AND TIME.  *\n");
	myprintf("*   Press RETURN to continue...                           *\n");
	myprintf("***********************************************************\n");
	do
	{
		if (x_DWORD_E3BB0 <= 0 || x_DWORD_E3BB8 & 4 || *(x_BYTE *)x_DWORD_E3BAC == 13 || *(x_BYTE *)x_DWORD_E3BAC == 26)
		{
			result = fgetc((FILE*)&x_DWORD_E3BAC);
			v1 = result;
		}
		else
		{
			result = x_DWORD_E3BAC + 1;
			x_DWORD_E3BAC = result;
			v1 = *(unsigned __int8 *)(result - 1);
			--x_DWORD_E3BB0;
		}
	} while (v1 != 10);
	return result;
}
// 996B7: using guessed type x_DWORD fgetc(x_DWORD);
// E3BAC: using guessed type int x_DWORD_E3BAC;
// E3BB0: using guessed type int x_DWORD_E3BB0;
// E3BB8: using guessed type int x_DWORD_E3BB8;

//----- (0005C530) --------------------------------------------------------
int sub_5C530()
{
	int v0; // edx
	int v1; // ecx
	int v2; // ebx
	signed int i; // eax
	int v4; // esi
	signed int j; // eax
	int v6; // eax
	int v7; // ecx
	int v8; // edx
	int v9; // edi
	int v10; // eax
	int v11; // ecx
	int v12; // edx
	int v13; // edi
	int v14; // eax
	int v15; // ecx
	int v16; // eax
	int v17; // esi
	int v18; // edx
	int v19; // esi
	int v20; // eax
	int v21; // eax
	int v22; // eax
	int v23; // eax
	int v24; // eax
	int v25; // eax
	int v26; // eax
	int v27; // eax

	v0 = 0;
	v1 = 0;
	v2 = x_DWORD_EA3E4[*(unsigned __int16 *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240)];
	for (i = 0; i < 26; i++)
	{
		v4 = *(x_DWORD *)(v2 + 164);
		if (*(x_WORD *)(v4 + 2 * i + 819) || *(x_BYTE *)(v4 + i + 1027))
			*(x_BYTE *)(*(x_DWORD *)(v2 + 164) + i + 1001) = 1;
	}
	if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 224779) & 1)
		++*(x_BYTE *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 12226);
	for (j = 0; j < 26; j++)
	{
		if (*(x_DWORD *)(4 * j + x_D41A0_BYTEARRAY_0 + 222422))
		{
			++v1;
			if (*(x_BYTE *)(*(x_DWORD *)(v2 + 164) + j + 1027))
				++v0;
		}
	}
	if (v1)
	{
		v6 = 100 * v0 / v1;
		v0 = *(x_DWORD *)(v2 + 164);
		*(x_DWORD *)(v0 + 377) = v6;
	}
	else
	{
		*(x_DWORD *)(*(x_DWORD *)(v2 + 164) + 377) = 100;
	}
	if (*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 222418))
	{
		v7 = *(x_DWORD *)(v2 + 164);
		v8 = 100 * *(x_DWORD *)(v7 + 373);
		v9 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 222418);
		v10 = v8 / v9;
		v0 = v8 % v9;
		*(x_DWORD *)(v7 + 373) = v10;
	}
	else
	{
		*(x_DWORD *)(*(x_DWORD *)(v2 + 164) + 373) = 100;
	}
	v11 = *(x_DWORD *)(v2 + 164);
	if (*(x_DWORD *)(v11 + 357))
	{
		v12 = 100 * *(x_DWORD *)(v11 + 361);
		v13 = *(x_DWORD *)(v11 + 357);
		v14 = v12 / v13;
		v0 = v12 % v13;
		*(x_DWORD *)(v11 + 381) = v14;
	}
	else
	{
		*(x_DWORD *)(v11 + 381) = 100;
	}
	v15 = *(x_DWORD *)(v2 + 164);
	v16 = x_DWORD_EA3E4[*(unsigned __int16 *)(v15 + 58)];
	if (v16)
	{
		v17 = x_D41A0_BYTEARRAY_4[0xF6] - 1;
		if (v17 <= 0)
		{
			*(x_DWORD *)(v15 + 385) = 100;
			goto LABEL_29;
		}
		v18 = 100 * (*(x_DWORD *)(v15 + 316) + *(x_DWORD *)(v16 + 144));
		v16 = v18 / v17;
		v0 = v18 % v17;
	}
	*(x_DWORD *)(v15 + 385) = v16;
LABEL_29:
	v19 = *(x_DWORD *)(v2 + 164);
	*(x_DWORD *)(*(x_DWORD *)(v2 + 164) + 393) = (j___clock() - *(x_DWORD *)(v19 + 393)) / 0x64u;
	v20 = *(x_DWORD *)(v2 + 164);
	if (*(x_DWORD *)(v20 + 377) < 0)
		*(x_DWORD *)(v20 + 377) = 0;
	v21 = *(x_DWORD *)(v2 + 164);
	if (*(x_DWORD *)(v21 + 377) > 100)
		*(x_DWORD *)(v21 + 377) = 100;
	v22 = *(x_DWORD *)(v2 + 164);
	if (*(x_DWORD *)(v22 + 373) < 0)
		*(x_DWORD *)(v22 + 373) = 0;
	v23 = *(x_DWORD *)(v2 + 164);
	if (*(x_DWORD *)(v23 + 373) > 100)
		*(x_DWORD *)(v23 + 373) = 100;
	v24 = *(x_DWORD *)(v2 + 164);
	if (*(x_DWORD *)(v24 + 381) < 0)
		*(x_DWORD *)(v24 + 381) = 0;
	v25 = *(x_DWORD *)(v2 + 164);
	if (*(x_DWORD *)(v25 + 381) > 100)
		*(x_DWORD *)(v25 + 381) = 100;
	v26 = *(x_DWORD *)(v2 + 164);
	if (*(x_DWORD *)(v26 + 385) < 0)
		*(x_DWORD *)(v26 + 385) = 0;
	v27 = *(x_DWORD *)(v2 + 164);
	if (*(x_DWORD *)(v27 + 385) > 100)
		*(x_DWORD *)(v27 + 385) = 100;
	return sub_82AB0(*(x_BYTE *)(x_D41A0_BYTEARRAY_4_struct.levelnumber_43));
}
// 98786: using guessed type int /*__fastcall*/ j___clock(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0005C800) --------------------------------------------------------
__int16 sub_5C800(int a1, char a2)
{
	__int16 result; // ax

	result = *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12);
	if (result == *(x_WORD *)(*(x_DWORD *)(a1 + 164) + 56))
	{
		result = (short)x_D41A0_BYTEARRAY_4;
		x_D41A0_BYTEARRAY_4[0xB4] = a2;
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (0005C830) --------------------------------------------------------
__int16 sub_5C830(int a1, char a2, __int16 a3)
{
	int v3; // eax

	LOWORD(v3) = *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12);
	if ((x_WORD)v3 == *(x_WORD *)(*(x_DWORD *)(a1 + 164) + 56))
	{
		v3 = (int)x_D41A0_BYTEARRAY_4;
		x_D41A0_BYTEARRAY_4[0xB4] = a2;
		*(x_WORD *)(v3 + 184) = a3;
	}
	return v3;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (0005C870) --------------------------------------------------------
signed int sub_5C870(int a1)
{
	int v1; // ebx
	int v2; // esi
	signed int result; // eax

	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240)];
	v2 = *(x_DWORD *)(v1 + 164);
	result = sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(v1 + 76));
	if (result <= *(x_DWORD *)(v2 + 410))
		*(x_DWORD *)(*(x_DWORD *)(v1 + 164) + 410) = result;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0005C8D0) --------------------------------------------------------
signed int sub_5C8D0(int a1)
{
	int v1; // ebx
	int v2; // esi
	signed int result; // eax

	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240)];
	v2 = *(x_DWORD *)(v1 + 164);
	result = sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(v1 + 76));
	if (result <= *(x_DWORD *)(v2 + 414))
		*(x_DWORD *)(*(x_DWORD *)(v1 + 164) + 414) = result;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0005C950) --------------------------------------------------------
int sub_5C950(int a1, int a2)
{
	int v2; // ebx
	__int16 v3; // ax
	int v4; // eax
	unsigned __int16 v5; // dx
	int v6; // esi
	int v7; // ecx
	char v8; // ST08_1
	int v9; // edi
	int v10; // edx
	signed int i; // eax
	int v12; // eax
	int v13; // edx
	__int16 v14; // cx
	int v15; // eax
	int v16; // eax
	int v17; // ecx
	int v18; // edi
	int v19; // esi
	int v20; // eax
	__int16 v21; // dx
	int v22; // edi
	int v23; // eax
	x_WORD *v24; // edx
	int v25; // eax
	int v26; // ST08_4
	int v27; // esi
	int v28; // eax
	int v29; // eax
	int v30; // edx
	unsigned int k; // eax
	char v32; // dl
	signed int l; // eax
	int result; // eax
	int v35; // [esp+0h] [ebp-14h]
	__int16 v36; // [esp+4h] [ebp-10h]
	int v37; // [esp+8h] [ebp-Ch]
	int j; // [esp+Ch] [ebp-8h]
	int v39; // [esp+10h] [ebp-4h]

	//fix it
	v10 = 0;
	//fix it

	v2 = a2;
	v37 = 0;
	sub_49F90();
	v35 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 6 * ((a1 - ((int)x_D41A0_BYTEARRAY_0 + 11230)) / 2124) + 9058);
	v36 = *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 6 * ((a1 - ((int)x_D41A0_BYTEARRAY_0 + 11230)) / 2124) + 9062);
	v3 = sub_10C40((__int16 *)&v35);
	++HIBYTE(v3);
	v36 = v3;
	if (a2 == x_DWORD_EA3E4[0])
	{
		v2 = sub_4A190((int)&v35, 3, *(x_BYTE *)(a1 + 9) == 1);
		v37 = 1;
	}
	else
	{
		*(x_BYTE *)(a2 + 69) = *(x_BYTE *)(a1 + 9) == 1;
		v4 = *(x_DWORD *)(a2 + 164);
		*(x_BYTE *)(a2 + 12) &= 0xDFu;
		v5 = *(x_WORD *)(v4 + 58);
		if (v5)
		{
			v6 = x_DWORD_EA3E4[v5] + 76;
			v35 = *(x_DWORD *)v6;
			v36 = *(x_WORD *)(v6 + 4);
		}
		sub_57CF0(a2, (int)&v35);
	}
	v7 = (int)x_D41A0_BYTEARRAY_0;
	*(x_WORD *)(a1 + 10) = (v2 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
	*(x_DWORD *)(v2 + 164) = a1 + 998;
	*(x_WORD *)(*(x_DWORD *)(v2 + 164) + 56) = (a1 - (v7 + 11230)) / 2124;
	*(x_WORD *)(*(x_DWORD *)(v2 + 164) + 345) = 100;
	*(x_WORD *)(*(x_DWORD *)(v2 + 164) + 588) = 0;
	*(x_DWORD *)(*(x_DWORD *)(v2 + 164) + 365) = 2000;
	*(x_WORD *)(*(x_DWORD *)(v2 + 164) + 12) = 0;
	*(x_WORD *)(*(x_DWORD *)(v2 + 164) + 32) = 0;
	*(x_WORD *)(*(x_DWORD *)(v2 + 164) + 34) = 0;
	*(x_WORD *)(*(x_DWORD *)(v2 + 164) + 30) = 0;
	*(x_WORD *)(*(x_DWORD *)(v2 + 164) + 16) = 0;
	memset((void*)(*(x_DWORD *)(v2 + 164) + 428), 0, 18);
	*(x_WORD *)(*(x_DWORD *)(v2 + 164) + 586) = 256;
	v8 = v37;
	*(x_DWORD *)(v2 + 140) = 1000;
	v9 = v37;
	*(x_DWORD *)(v2 + 4) = 10000;
	sub_5CF40(v2, v8);
	if (v9)
	{
		sub_58DA0(0, v2);
		for (i = 0; i < 26; *(x_DWORD *)(*(x_DWORD *)(v2 + 164) + 4 * i + 711) = 0)
			++i;
		*(x_DWORD *)(*(x_DWORD *)(v2 + 164) + 393) = j___clock();
		switch (sub_616D0(*(signed __int16 *)(*(x_DWORD *)(v2 + 164) + 56)))
		{
		case 0:
			sub_49CD0((x_WORD *)v2, 44);
			break;
		case 1:
			sub_49CD0((x_WORD *)v2, 273);
			break;
		case 2:
			sub_49CD0((x_WORD *)v2, 274);
			break;
		case 3:
			sub_49CD0((x_WORD *)v2, 275);
			break;
		case 4:
			sub_49CD0((x_WORD *)v2, 276);
			break;
		case 5:
			sub_49CD0((x_WORD *)v2, 277);
			break;
		case 6:
			sub_49CD0((x_WORD *)v2, 278);
			break;
		case 7:
			sub_49CD0((x_WORD *)v2, 279);
			break;
		default:
			break;
		}
		if (*(x_BYTE *)(a1 + 9) == 1)
		{
			v12 = (int)x_D41A0_BYTEARRAY_0;
			*(x_WORD *)(*(x_DWORD *)(v2 + 164) + 578) = *(x_WORD *)(110 * *(signed __int16 *)(*(x_DWORD *)(v2 + 164) + 56)
				+ x_D41A0_BYTEARRAY_0
				+ 221397);
			*(x_WORD *)(*(x_DWORD *)(v2 + 164) + 580) = *(x_WORD *)(110 * *(signed __int16 *)(*(x_DWORD *)(v2 + 164) + 56)
				+ v12
				+ 221405);
			*(x_WORD *)(*(x_DWORD *)(v2 + 164) + 582) = *(x_WORD *)(110 * *(signed __int16 *)(*(x_DWORD *)(v2 + 164) + 56)
				+ v12
				+ 221401);
			v13 = *(x_DWORD *)(v2 + 164);
			v14 = *(x_WORD *)(110 * *(signed __int16 *)(v13 + 56) + v12 + 221487);
			if (v14)
			{
				*(x_WORD *)(v13 + 586) = v14;
				*(x_DWORD *)(v2 + 4) = *(x_DWORD *)(v2 + 4) * (signed int)*(signed __int16 *)(*(x_DWORD *)(v2 + 164) + 586) >> 8;
			}
			v15 = *(x_DWORD *)(v2 + 164);
			if (*(x_WORD *)(v15 + 823))
			{
				if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + *(signed __int16 *)(v15 + 56) + 196313))
				{
					v16 = sub_4A190(v2 + 76, 3, 2);
					v39 = v16;
					if (v16)
					{
						v17 = (int)x_D41A0_BYTEARRAY_0 + 28302;
						*(x_WORD *)(v16 + 26) = *(x_WORD *)(v2 + 26);
						*(x_WORD *)(*(x_DWORD *)(v2 + 164) + 58) = (v16 - v17) / 168;
						sub_6E450((v2 - v17) / 168, -1, 30);
						for (j = 0; ; j = v22 + 1)
						{
							v23 = *(unsigned __int8 *)(x_D41A0_BYTEARRAY_0 + *(signed __int16 *)(*(x_DWORD *)(v2 + 164) + 56) + 196313);
							if (v23 <= j)
								break;
							v18 = x_DWORD_EA3E4[0] + 76;
							v19 = v39 + 154;
							*(x_DWORD *)v18 = *(x_DWORD *)(v39 + 154);
							*(x_WORD *)(v18 + 4) = *(x_WORD *)(v19 + 4);
							v20 = x_DWORD_EA3E4[0];
							v21 = *(x_WORD *)(v39 + 26);
							*(x_BYTE *)(x_DWORD_EA3E4[0] + 64) = 0;
							v22 = j;
							*(x_DWORD *)(v20 + 16) = 0;
							*(x_WORD *)(v20 + 26) = v21;
							*(x_BYTE *)(v20 + 70) = j;
							sub_36FC0(v20);
						}
						v24 = (x_WORD *)v39;
						*(x_DWORD *)(v39 + 16) = v23 - 1;
						sub_49EC0(v24, v24[8]);
						v25 = v39;
						v26 = v39;
						*(x_WORD *)(v39 + 82) = -8192;
						v27 = v25;
						*(x_WORD *)(v25 + 88) = 0x4000;
						sub_60810(v26);
						v28 = *(x_DWORD *)(v27 + 140);
						*(x_DWORD *)(v27 + 144) = v28;
						if (v28 < 0)
							*(x_DWORD *)(v27 + 144) = 0;
						if (*(x_DWORD *)(v39 + 144) > 320000)
							*(x_DWORD *)(v39 + 144) = 320000;
					}
				}
			}
		}
		*(x_DWORD *)(*(x_DWORD *)(v2 + 164) + 373) = 0;
	}
	if (*(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12) == *(x_WORD *)(*(x_DWORD *)(v2 + 164) + 56))
		*(x_BYTE *)(v2 + 12) |= 1u;
	*(x_DWORD *)(v2 + 8) = *(x_DWORD *)(v2 + 4);
	v29 = *(x_DWORD *)(v2 + 140);
	v30 = *(x_DWORD *)(v2 + 164);
	*(x_DWORD *)(v2 + 144) = v29;
	*(x_DWORD *)(v30 + 336) = v29;
	for (k = x_D41A0_BYTEARRAY_4[0x9677]; k > x_DWORD_EA3E4[0]; k = *(x_DWORD *)k)
	{
		if (*(x_WORD *)(k + 26) != *(x_WORD *)(v2 + 26))
		{
			v32 = *(x_BYTE *)(k + 64);
			if (!v32 || v32 == 1)
				*(x_WORD *)(*(x_DWORD *)(k + 164) + 8 * *(signed __int16 *)(*(x_DWORD *)(v2 + 164) + 56) + 516) = -24609;
		}
	}
	*(x_WORD *)(*(x_DWORD *)(v2 + 164) + 326) = 0;
	*(x_WORD *)(*(x_DWORD *)(v2 + 164) + 328) = 0;
	if (*(x_BYTE *)(v2 + 64) == 1)
	{
		memset((void*)(*(x_DWORD *)(v2 + 164) + 449), 0, 1);
		for (l = 0; l < 8; *(x_WORD *)(*(x_DWORD *)(v2 + 164) + 8 * l + 508) = 24607)
			++l;
		*(x_WORD *)(*(x_DWORD *)(v2 + 164) + 875) = 4 * *(x_WORD *)(*(x_DWORD *)(v2 + 164) + 56);
	}
	*(x_DWORD *)(*(x_DWORD *)(v2 + 164) + 410) = 2048;
	*(x_DWORD *)(*(x_DWORD *)(v2 + 164) + 414) = 2048;
	*(x_WORD *)(*(x_DWORD *)(v2 + 164) + 54) = 0;
	memset((void*)(*(x_DWORD *)(v2 + 164) + 347), 16, 8);
	result = (int)x_D41A0_BYTEARRAY_0;
	*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 4582) = -1;
	if (*(x_WORD *)(*(x_DWORD *)(v2 + 164) + 56) == *(x_WORD *)(result + 12))
	{
		result = (int)x_D41A0_BYTEARRAY_4;
		x_D41A0_BYTEARRAY_4[0xB2] = 0;
	}
	return result;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 98786: using guessed type int /*__fastcall*/ j___clock(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0005CF40) --------------------------------------------------------
x_WORD *sub_5CF40(int a1, char a2)
{
	int i; // esi
	int v3; // edi
	int v4; // eax
	int v5; // ST0C_4
	signed int j; // edx
	signed int v7; // esi
	int v8; // eax
	__int16 v9; // cx

	for (i = 0; i < 26; i++)
	{
		v3 = 2 * i;
		if (*(x_WORD *)(2 * i + *(x_DWORD *)(a1 + 164) + 819))
		{
			v4 = sub_4A190(a1 + 76, 15, i);
			if (v4)
			{
				v5 = (int)x_D41A0_BYTEARRAY_0 + 28302;
				*(x_WORD *)(*(x_DWORD *)(a1 + 164) + v3 + 819) = (v4 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
				*(x_WORD *)(v4 + 40) = (a1 - v5) / 168;
				*(x_BYTE *)(v4 + 12) |= 1u;
			}
			else
			{
				*(x_WORD *)(v3 + *(x_DWORD *)(a1 + 164) + 819) = 0;
			}
		}
	}
	if (a2)
	{
		for (j = 0; j < 26; *(x_BYTE *)(j + *(x_DWORD *)(a1 + 164) + 1078) = 0)
			++j;
	}
	v7 = 0;
	sub_6DB50(0, 0);
	while (v7 < 26)
	{
		v8 = *(x_DWORD *)(a1 + 164);
		v9 = *(x_WORD *)(v8 + 2 * v7 + 819);
		if (v9)
			sub_6D5E0(x_DWORD_EA3E4[v9], *(x_BYTE *)(v7 + v8 + 1079));
		++v7;
	}
	*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 1109) = *(x_BYTE *)(*(x_DWORD *)(a1 + 164)
		+ *(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 1105)
		+ 1079);
	*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 1110) = *(x_BYTE *)(*(x_DWORD *)(a1 + 164)
		+ *(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 1107)
		+ 1079);
	return sub_574A0();
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0005D0A0) --------------------------------------------------------
int sub_5D0A0(int a1)
{
	unsigned __int16 v1; // di
	int v2; // eax
	int v3; // eax
	unsigned __int16 v4; // si
	unsigned __int16 v5; // ax
	unsigned __int16 v6; // ax
	int v7; // esi
	int v8; // esi
	__int16 v9; // ax
	int v10; // eax
	int v11; // edx
	int v12; // edx
	__int16 v13; // si
	__int16 v14; // ax
	int v15; // edi
	__int16 v16; // ax
	int v17; // esi
	int v18; // eax
	int *v19; // esi
	char v20; // ch
	int v21; // edx
	int v22; // eax
	int v23; // eax
	__int16 v24; // ax
	__int16 v25; // dx
	int v27; // [esp+0h] [ebp-60h]
	__int16 v28; // [esp+4h] [ebp-5Ch]
	int v29; // [esp+8h] [ebp-58h]
	__int16 v30; // [esp+Ch] [ebp-54h]
	int v31; // [esp+10h] [ebp-50h]
	__int16 v32; // [esp+14h] [ebp-4Ch]
	int v33; // [esp+18h] [ebp-48h]
	__int16 v34; // [esp+1Ch] [ebp-44h]
	int v35; // [esp+20h] [ebp-40h]
	int v36; // [esp+24h] [ebp-3Ch]
	int v37; // [esp+28h] [ebp-38h]
	int v38; // [esp+2Ch] [ebp-34h]
	int v39; // [esp+30h] [ebp-30h]
	int i; // [esp+34h] [ebp-2Ch]
	int v41; // [esp+38h] [ebp-28h]
	unsigned int v42; // [esp+3Ch] [ebp-24h]
	int v43; // [esp+40h] [ebp-20h]
	int v44; // [esp+44h] [ebp-1Ch]
	int v45; // [esp+48h] [ebp-18h]
	int v46; // [esp+4Ch] [ebp-14h]
	unsigned __int16 v47; // [esp+50h] [ebp-10h]
	int v48; // [esp+54h] [ebp-Ch]
	int v49; // [esp+58h] [ebp-8h]
	char v50; // [esp+5Ch] [ebp-4h]

	v46 = 1;
	if (sub_104D0(&x_WORD_EB398) == (int(*)())256)
	{
		++*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 610);
		v1 = sub_581E0((Bit16u *)(a1 + 76), (Bit16u *)&x_WORD_EB398);
		LOWORD(v2) = sub_58210((x_WORD *)(a1 + 76), &x_WORD_EB398);
		v45 = v2;
		v42 = sub_583F0((x_WORD *)(a1 + 76), &x_WORD_EB398);
		v41 = v1;
		v3 = (v41 - (__CFSHL__(v41 >> 31, 9) + (v41 >> 31 << 9))) >> 9;
		*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
		*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
		v4 = (x_WORD)v3 << 9;
		v49 = (((x_WORD)v3 + 1) << 9) & 0x7FF;
		v5 = sub_582B0(v41, (x_WORD)v3 << 9);
		v36 = (unsigned __int16)v42;
		v35 = (unsigned __int16)v45;
		sub_57FA0(
			&x_WORD_EB398,
			v4,
			v45,
			((unsigned __int16)v42 * (512 - v5)
				- (__CFSHL__((unsigned __int16)v42 * (512 - v5) >> 31, 9)
					+ ((unsigned __int16)v42 * (512 - v5) >> 31 << 9))) >> 9);
		if (sub_104D0(&x_WORD_EB398) == (int(*)())256)
		{
			*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
			*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
			v6 = sub_582B0(v41, v49);
			sub_57FA0(
				&x_WORD_EB398,
				v49,
				v35,
				(v36 * (512 - v6) - (__CFSHL__(v36 * (512 - v6) >> 31, 9) + (v36 * (512 - v6) >> 31 << 9))) >> 9);
			if (sub_104D0(&x_WORD_EB398) == (int(*)())256)
				v46 = 0;
		}
	}
	if (!x_BYTE_D41B6)
		return v46;
	v31 = *(x_DWORD *)&x_WORD_EB398;
	v32 = *(&x_WORD_EB398 + 2);
	v7 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 12);
	v8 = v7 + (signed __int16)sub_10C40((__int16 *)&v31) + *(signed __int16 *)(a1 + 88);
	v9 = sub_10C60((__int16 *)&v31);
	LOBYTE(v47) = BYTE1(v31);
	HIBYTE(v47) = HIBYTE(v31);
	if (v8 < v9 - 576 && !(x_BYTE_13B4E0[v47] & 8))
		goto LABEL_30;
	v48 = 0;
	LOWORD(v10) = sub_581E0((Bit16u *)(a1 + 76), (Bit16u *)&v31);
	v11 = v10 - 512;
	v50 = 0;
	BYTE1(v11) &= 7u;
	BYTE1(v10) = (BYTE1(v10) + 2) & 7;
	v43 = v11;
	v44 = v10;
	v12 = 16;
	for (i = 0; ; i++)
	{
		v39 = v12;
		if (i >= 6 || v50)
			break;
		v33 = v31;
		v34 = v32;
		v27 = v31;
		v28 = v32;
		v13 = v39;
		v37 = (unsigned __int16)v48;
		sub_57FA0((x_WORD*)&v33, v43, v48, v39);
		v38 = (signed __int16)sub_10C60((__int16 *)&v33);
		v14 = sub_10C40((__int16 *)&v33);
		v15 = v38 - v14;
		sub_57FA0((x_WORD*)&v27, v44, v37, v13);
		v38 = (signed __int16)sub_10C60((__int16 *)&v27);
		v16 = sub_10C40((__int16 *)&v27);
		v17 = v38 - v16;
		LOBYTE(v47) = BYTE1(v33);
		HIBYTE(v47) = HIBYTE(v33);
		v18 = (signed __int16)v27 >> 8;
		BYTE1(v18) = HIBYTE(v27);
		if (!(x_BYTE_13B4E0[v47] & 8) || !(x_BYTE_13B4E0[(unsigned __int16)v18] & 8))
		{
			if (v15 > v17 && !(x_BYTE_13B4E0[v47] & 8))
			{
				if (sub_11E20(a1, (__int16 *)&v33))
					goto LABEL_20;
				v19 = &v33;
				v50 = 1;
				goto LABEL_19;
			}
			if (v17 > v15 && !(x_BYTE_13B4E0[(unsigned __int16)v18] & 8) && !sub_11E20(a1, (__int16 *)&v27))
			{
				v19 = &v27;
				v50 = 2;
			LABEL_19:
				v29 = *v19;
				v30 = *((x_WORD *)v19 + 2);
				goto LABEL_20;
			}
		}
	LABEL_20:
		v12 = 16 * (i + 1) + v39;
	}
	v20 = v50;
	if (v50)
	{
		v21 = i;
		v22 = 16 * i;
		*(x_DWORD *)&x_WORD_EB398 = v29;
		*(&x_WORD_EB398 + 2) = v30;
		v23 = (v22 + v21) / 6;
		if (v20 == 1)
			v23 = -v23;
		v24 = *(x_WORD *)(a1 + 28) + v23;
		HIBYTE(v24) &= 7u;
		*(x_WORD *)(a1 + 28) = v24;
	}
	else if (sub_11E20(a1, (__int16 *)&v31))
	{
		v46 = 0;
	}
	else
	{
		*(x_DWORD *)&x_WORD_EB398 = v31;
		*(&x_WORD_EB398 + 2) = v32;
	}
LABEL_30:
	if ((x_WORD)v46)
	{
		LOBYTE(v47) = HIBYTE(x_WORD_EB398);
		HIBYTE(v47) = HIBYTE(x_WORD_EB39A);
		if (x_BYTE_13B4E0[v47] & 8)
			v46 = 0;
	}
	if (!(x_WORD)v46)
	{
		++*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 610);
		*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
		*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
		*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 12) = 0;
		v25 = *(x_WORD *)(*(x_DWORD *)(a1 + 164) + 825);
		if (v25)
			*(x_WORD *)(x_DWORD_EA3E4[v25] + 46) = 0;
	}
	return v46;
}
// D41B6: using guessed type char x_BYTE_D41B6;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39A: using guessed type __int16 x_WORD_EB39A;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (0005D530) --------------------------------------------------------
void sub_5D530(int a1)
{
	char v1; // ah
	int v2; // ecx
	unsigned __int8 v3; // dh
	int v4; // edx
	int v5; // ecx
	int v6; // edx
	int v7; // edx
	int v8; // eax
	int v9; // edx
	__int16 v10; // ax
	int v11; // eax
	__int16 v12; // dx
	int v13; // eax
	unsigned __int8 v14; // cl
	int v15; // edx
	int v16; // eax
	int v17; // edx
	__int16 v18; // di
	int v19; // eax
	__int16 v20; // ST0C_2
	unsigned __int16 v21; // ax
	int v22; // eax
	__int16 v23; // dx
	int v24; // eax
	__int16 v25; // si
	x_WORD *v26; // edx
	signed __int16 v27; // ax
	x_WORD *v28; // edx
	__int16 v29; // si
	__int16 v30; // ax
	int v31; // edx
	char v32; // cl
	int v33; // edx
	char v34; // ah
	int v35; // eax
	char v36; // ch
	int v37; // edx
	char v38; // ch
	__int16 v39; // ax
	__int16 v40; // dx
	int v41; // ecx
	int v42; // eax
	__int16 v43; // ax
	unsigned int v44; // edx
	char v45; // al
	int v46; // ecx
	unsigned int v47; // eax
	__int16 v48; // si
	int v49; // edx
	__int16 v50; // ax

	v1 = *(x_BYTE *)(a1 + 13);
	if (v1 & 8)
	{
		*(x_BYTE *)(a1 + 13) = v1 & 0xF7;
		return;
	}
	*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
	*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
	v2 = *(x_DWORD *)(a1 + 164);
	v3 = *(x_BYTE *)(v2 + 332);
	if (v3)
	{
		v4 = *(signed __int16 *)(v2 + 4) * (4 - v3);
		*(x_WORD *)(v2 + 341) += (v4 - (__CFSHL__(v4 >> 31, 2) + 4 * (v4 >> 31))) >> 2;
		v5 = *(x_DWORD *)(a1 + 164);
		v6 = *(signed __int16 *)(v5 + 6) * (4 - *(unsigned __int8 *)(v5 + 332));
		*(x_WORD *)(v5 + 343) += (v6 - (__CFSHL__(v6 >> 31, 2) + 4 * (v6 >> 31))) >> 2;
	}
	else
	{
		*(x_WORD *)(v2 + 341) += *(x_WORD *)(v2 + 4);
		*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 343) += *(x_WORD *)(*(x_DWORD *)(a1 + 164) + 6);
	}
	v7 = *(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 341);
	*(x_WORD *)(a1 + 28) = (*(x_WORD *)(a1 + 28) + ((v7 - (__CFSHL__(v7 >> 31, 3) + 8 * (v7 >> 31))) >> 3)) & 0x7FF;
	v8 = *(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 12) - *(signed __int16 *)(a1 + 130);
	if (*(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 12) != *(signed __int16 *)(a1 + 130))
	{
		if (v8 <= 0)
			LOWORD(v8) = -1;
		else
			LOWORD(v8) = 1;
	}
	*(x_WORD *)(a1 + 130) += v8 * x_DWORD_D4B84;
	v9 = ((x_WORD_EB39C - (signed __int16)sub_10C40(&x_WORD_EB398) - *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 10)) << 10)
		/ *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 10);
	if (v9 < -256)
		v9 = -256;
	if (v9 > 256)
		v9 = 256;
	v10 = *(x_WORD *)(*(x_DWORD *)(a1 + 164) + 343);
	HIBYTE(v10) &= 7u;
	*(x_WORD *)(a1 + 30) = v10;
	if (v10 > 1024)
		v10 -= 2048;
	if (*(x_WORD *)(a1 + 130) >= 0 || v10 <= 0)
	{
		if (*(x_WORD *)(a1 + 130) < 0 && v10 < 0)
			goto LABEL_105;
		if (*(x_WORD *)(a1 + 130) > 0 && v10 < 0)
		{
			*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 36) = (v10 * -v9 - (__CFSHL__(v10 * -v9 >> 31, 8) + (v10 * -v9 >> 31 << 8))) >> 8;
			goto LABEL_27;
		}
		if (*(x_WORD *)(a1 + 130) > 0 && v10 > 0)
		{
		LABEL_105:
			*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 36) = *(x_WORD *)(*(x_DWORD *)(a1 + 164) + 343);
			goto LABEL_27;
		}
	}
	else
	{
		*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 36) = (v10 * -v9 - (__CFSHL__(v10 * -v9 >> 31, 8) + (v10 * -v9 >> 31 << 8))) >> 8;
	}
LABEL_27:
	v11 = *(x_DWORD *)(a1 + 164);
	v12 = *(x_WORD *)(v11 + 36);
	HIBYTE(v12) &= 7u;
	*(x_WORD *)(v11 + 36) = v12;
	v13 = *(x_DWORD *)(a1 + 164);
	v14 = *(x_BYTE *)(v13 + 332);
	if (v14)
	{
		v15 = *(signed __int16 *)(a1 + 130) * (4 - v14);
		v16 = (v15 - (__CFSHL__(v15 >> 31, 2) + 4 * (v15 >> 31))) >> 2;
	}
	else if (*(x_BYTE *)(v13 + 334))
	{
		LOWORD(v16) = 0;
	}
	else
	{
		LOWORD(v16) = *(x_WORD *)(a1 + 130);
	}
	sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), *(x_WORD *)(*(x_DWORD *)(a1 + 164) + 36), v16);
	v17 = *(x_DWORD *)(a1 + 164);
	v18 = *(x_WORD *)(v17 + 16);
	if (v18)
	{
		LOBYTE(v19) = *(x_BYTE *)(v17 + 332);
		if ((x_BYTE)v19)
		{
			v19 = ((4 - *(unsigned __int8 *)(v17 + 332)) * v18
				- (__CFSHL__((4 - *(unsigned __int8 *)(v17 + 332)) * v18 >> 31, 2)
					+ 4 * ((4 - *(unsigned __int8 *)(v17 + 332)) * v18 >> 31))) >> 2;
		}
		else if (*(x_BYTE *)(v17 + 334))
		{
			BYTE1(v19) = 0;
		}
		else
		{
			LOWORD(v19) = *(x_WORD *)(v17 + 16);
		}
		v20 = v19;
		v21 = *(x_WORD *)(a1 + 28);
		HIBYTE(v21) += 2;
		sub_57FA0((x_WORD*)&x_WORD_EB398, v21, 0, v20);
	}
	v22 = *(x_DWORD *)(a1 + 164);
	v23 = *(x_WORD *)(v22 + 30);
	if (v23)
	{
		if (v23 > 128)
			*(x_WORD *)(v22 + 30) = 128;
		sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(*(x_DWORD *)(a1 + 164) + 32), 0, *(x_WORD *)(*(x_DWORD *)(a1 + 164) + 30));
		v24 = *(x_DWORD *)(a1 + 164);
		v25 = *(x_WORD *)(v24 + 30);
		v26 = (x_WORD *)(v24 + 30);
		if (v25)
		{
			if (v25 <= 0)
				v27 = -1;
			else
				v27 = 1;
		}
		else
		{
			v27 = 0;
		}
		*v26 += v27 * x_DWORD_D4B90;
		if (abs(*(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 30)) < 4)
			*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 30) = 0;
	}
	v28 = *(x_WORD **)(a1 + 164);
	v29 = v28[212] + x_WORD_EB39A;
	v30 = v28[213];
	x_WORD_EB398 += v28[211];
	x_WORD_EB39A = v29;
	x_WORD_EB39C += v30;
	v28[211] = 0;
	*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 424) = 0;
	*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 426) = 0;
	v31 = *(x_DWORD *)(a1 + 164);
	v32 = *(x_BYTE *)(v31 + 610);
	if (v32)
		*(x_BYTE *)(v31 + 610) = v32 - 1;
	sub_5DE30(a1);
	v33 = *(x_DWORD *)(a1 + 164);
	if (*(x_BYTE *)(v33 + 332))
	{
		v34 = *(x_BYTE *)(v33 + 333) - 1;
		*(x_BYTE *)(v33 + 333) = v34;
		if (!v34)
		{
			v35 = *(x_DWORD *)(a1 + 164);
			v36 = *(x_BYTE *)(v35 + 332) - 1;
			*(x_BYTE *)(v35 + 332) = v36;
			if (v36)
			{
				*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 333) = 8;
				x_D41A0_BYTEARRAY_4[181] = 1;
			}
			else
			{
				sub_5C800(a1, 1);
			}
		}
	}
	v37 = *(x_DWORD *)(a1 + 164);
	if (*(x_BYTE *)(v37 + 334))
	{
		v38 = *(x_BYTE *)(v37 + 335) - 1;
		*(x_BYTE *)(v37 + 335) = v38;
		if (!v38)
			--*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 334);
	}
	if ((unsigned __int16)sub_5D0A0(a1))
	{
		v39 = sub_10C40(&x_WORD_EB398);
		v40 = v39;
		if (*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 334))
		{
			x_WORD_EB39C -= 51;
		}
		else
		{
			v41 = *(x_DWORD *)(a1 + 160);
			if (x_WORD_EB39C > *(signed __int16 *)(v41 + 12) + v39)
				x_WORD_EB39C += *(x_WORD *)(v41 + 14);
		}
		v42 = *(x_DWORD *)(a1 + 160);
		if (x_WORD_EB39C >= v40 + *(signed __int16 *)(v42 + 12))
		{
			if (x_BYTE_D41B6)
			{
				v43 = sub_10C60(&x_WORD_EB398);
				if (x_WORD_EB39C > v43 - 384)
					x_WORD_EB39C = v43 - 384;
			}
		}
		else
		{
			x_WORD_EB39C = *(x_WORD *)(v42 + 12) + v40;
		}
		sub_57CF0(a1, (int)&x_WORD_EB398);
	}
	else
	{
		sub_5DD50(a1);
	}
	if (!(*(x_BYTE *)(a1 + 62) & 0x3F))
	{
		v44 = x_DWORD_EA3E4[*(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 827)];
		if (v44 > x_DWORD_EA3E4[0])
		{
			if (*(x_WORD *)(v44 + 46))
			{
				v45 = x_BYTE_DA972[26 * *(char *)(v44 + 70)];
				if ((unsigned __int8)v45 < 0x10u)
				{
					if (v45 == 2)
						sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 12);
				}
				else if ((unsigned __int8)v45 <= 0x10u)
				{
					sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 39);
				}
				else if ((unsigned __int8)v45 >= 0x13u)
				{
					if ((unsigned __int8)v45 <= 0x13u)
					{
						sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 43);
					}
					else if (v45 == 25)
					{
						sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 37);
					}
				}
			}
		}
	}
	v46 = (int)x_D41A0_BYTEARRAY_0;
	if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308) == 2)
	{
		v47 = 9377 * *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8) + 9439;
		*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8) = v47;
		*(x_DWORD *)(v46 + 8) += x_D41A0_BYTEARRAY_4_struct.setting_30;
		if ((signed int)(v47 % 0x83) < 5)
		{
			v48 = *(x_WORD *)(v46 + 12);
			if (v48 == *(x_WORD *)(*(x_DWORD *)(a1 + 164) + 56))
				sub_6E450(0, v48, v47 % 0x83 + 65);
		}
	}
	else if (sub_104D0((signed __int16 *)(a1 + 76)) == (int(*)())1)
	{
		sub_6E450(0, *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12), 1);
		sub_6EAB0(0, *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12), 2);
	}
	else
	{
		sub_6E450(0, *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12), 2);
		sub_6EAB0(0, *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12), 1);
	}
	if (*(x_DWORD *)(*(x_DWORD *)(a1 + 164) + 410) >= 1536)
	{
		sub_6EAB0(0, *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12), 5);
	}
	else
	{
		sub_6E450(0, *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12), 5);
		*(x_DWORD *)(*(x_DWORD *)(a1 + 164) + 410) = 2048;
	}
	if (*(x_DWORD *)(*(x_DWORD *)(a1 + 164) + 414) >= 1536)
	{
		sub_6EAB0(0, *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12), 31);
	}
	else
	{
		sub_6E450(0, *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12), 31);
		*(x_DWORD *)(*(x_DWORD *)(a1 + 164) + 414) = 2048;
	}
	v49 = *(x_DWORD *)(a1 + 164);
	if (*(x_WORD *)(v49 + 56) == *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12))
	{
		v50 = *(x_WORD *)(v49 + 54);
		if (v50 <= 0)
		{
			sub_99970(1, 3u);
		}
		else
		{
			*(x_WORD *)(v49 + 54) = v50 - 1;
			sub_99970(2, 3u);
		}
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// D41B6: using guessed type char x_BYTE_D41B6;
// D4B84: using guessed type int x_DWORD_D4B84;
// D4B90: using guessed type int x_DWORD_D4B90;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39A: using guessed type __int16 x_WORD_EB39A;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (0005DD50) --------------------------------------------------------
signed int sub_5DD50(int a1)
{
	int v1; // eax
	signed int result; // eax
	char v3; // [esp+0h] [ebp-4h]

	v3 = 0;
	if (sub_104D0((signed __int16 *)(a1 + 76)) == (int(*)())256
		|| x_BYTE_D41B6
		&& (v1 = *(signed __int16 *)(a1 + 76) >> 8,
			BYTE1(v1) = *(x_WORD *)(a1 + 78) >> 8,
			x_BYTE_13B4E0[(unsigned __int16)v1] & 8))
	{
		v3 = 1;
	}
	if (!v3 && x_BYTE_D41B6 && *(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 609) && sub_11E20(a1, (__int16 *)(a1 + 76)))
		v3 = 1;
	if (v3)
	{
		*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 609) = 1;
		*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
		*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
		sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), 0, 128);
		result = sub_57CF0(a1, (int)&x_WORD_EB398);
	}
	else
	{
		result = *(x_DWORD *)(a1 + 164);
		*(x_BYTE *)(result + 609) = 0;
	}
	return result;
}
// D41B6: using guessed type char x_BYTE_D41B6;
// EB398: using guessed type __int16 x_WORD_EB398;

//----- (0005DE30) --------------------------------------------------------
void sub_5DE30(int a1)
{
	int v1; // edx
	unsigned int v2; // ebx
	int v3; // edi
	__int16 v4; // cx
	signed int v5; // ecx
	int v6; // edi
	__int16 v7; // ax
	unsigned __int16 v8; // ST10_2
	__int16 v9; // ax
	char v10; // al
	int v11; // esi
	int v12; // [esp+4h] [ebp-Ch]
	char *v13; // [esp+8h] [ebp-8h]

	v1 = *(x_DWORD *)(a1 + 164);
	v2 = x_DWORD_EA3E4[*(unsigned __int16 *)(v1 + 326)];
	v3 = 0;
	if (v2 > x_DWORD_EA3E4[0])
	{
		v13 = (char *)&unk_DAC7A + 26 * *(signed __int16 *)(v1 + 330);
		v4 = *(x_WORD *)(v1 + 847);
		if (v4)
			v3 = x_DWORD_EA3E4[v4];
		v5 = sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(v2 + 76));
		if (v3 && *(x_WORD *)(v3 + 46) && v5 < *(x_DWORD *)v13 && *(x_DWORD *)(v2 + 8) >= 0)
		{
			v12 = 3 * *(signed __int16 *)(a1 + 132) / 2;
			LOWORD(v6) = (v5 - *(x_DWORD *)(*(x_DWORD *)(a1 + 164) + 322)) / (1024 / (signed __int16)v12);
			if ((signed __int16)v6 < -(signed __int16)v12)
				v6 = 3 * *(signed __int16 *)(a1 + 132) / -2;
			if ((signed __int16)v6 > (signed __int16)v12)
				LOWORD(v6) = v12;
			v7 = sub_581E0((Bit16u *)(a1 + 76), (Bit16u *)(v2 + 76));
			v8 = v7;
			v9 = *(x_WORD *)(a1 + 28) + sub_58350(*(x_WORD *)(a1 + 28), v7, 5, 0x82u);
			HIBYTE(v9) &= 7u;
			*(x_WORD *)(a1 + 28) = v9;
			sub_57FA0((x_WORD*)&x_WORD_EB398, v8, *(x_WORD *)(a1 + 30), v6);
			v10 = v13[24];
			if ((unsigned __int8)v10 >= 1u)
			{
				if ((unsigned __int8)v10 > 1u)
				{
					if (v10 != 2)
						return;
					*(x_DWORD *)(v2 + 8) -= *(signed __int16 *)(*(x_DWORD *)(v2 + 164) + 355) + 2;
				}
				v11 = *(x_DWORD *)(v2 + 144) - (*(x_DWORD *)(v2 + 136) + 8);
				*(x_DWORD *)(v2 + 144) = v11;
				if (v11 < 0)
					*(x_DWORD *)(v2 + 144) = 0;
			}
		}
		else
		{
			*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 326) = 0;
		}
	}
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;

//----- (0005E010) --------------------------------------------------------
void sub_5E010(unsigned int a1)
{
	unsigned __int16 v1; // dx
	int v2; // edx
	int v3; // edx
	unsigned __int8 v4; // cl
	int v5; // edx
	int v6; // edx
	int v7; // eax
	int v8; // edx
	__int16 v9; // cx
	int v10; // edi
	int v11; // edx
	int v12; // edx
	int v13; // ecx
	int v14; // edx
	__int16 v15; // di
	char v16; // [esp+0h] [ebp-4h]

	v16 = 0;
	*(x_WORD *)(a1 + 132) = x_DWORD_D4B8C;
	if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 1))
	{
		v1 = *(x_WORD *)(*(x_DWORD *)(a1 + 164) + 58);
		if (v1)
		{
			if (sub_106C0(a1, x_DWORD_EA3E4[v1]))
				v16 = 1;
		}
	}
	sub_5F380(a1);
	if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 1) && v16)
	{
		if (*(x_WORD *)(a1 + 98))
		{
			v2 = x_DWORD_EA3E4[*(unsigned __int16 *)(*(x_DWORD *)(a1 + 164) + 58)];
			if (*(x_WORD *)(v2 + 98))
				*(x_DWORD *)(v2 + 94) += *(x_DWORD *)(a1 + 94);
			else
				*(x_DWORD *)(v2 + 94) = *(x_DWORD *)(a1 + 94);
			*(x_WORD *)(v2 + 98) = *(x_WORD *)(a1 + 98);
		}
		*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 345) = 2;
	}
	if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 1))
	{
		if (*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 345))
		{
			memset((void*)(a1 + 94), 0, 36);
			--*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 345);
		}
		else
		{
			sub_5EFA0(a1);
		}
		v3 = *(x_DWORD *)(a1 + 164);
		v4 = *(x_BYTE *)(v3 + 340);
		if (v4 < 0xC8u)
			*(x_BYTE *)(v3 + 340) = v4 + 1;
	}
	sub_5D530(a1);
	if (*(x_DWORD *)(a1 + 8) >= 0)
	{
		if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 1))
		{
			v6 = *(x_DWORD *)(a1 + 164);
			*(x_DWORD *)(a1 + 144) += *(x_DWORD *)(a1 + 136);
			v7 = *(x_DWORD *)(v6 + 397);
			if (v7)
				*(x_DWORD *)(v6 + 397) = v7 - 1;
			else
				*(x_DWORD *)(a1 + 8) += *(signed __int16 *)(v6 + 355);
			v8 = *(x_DWORD *)(a1 + 164);
			v9 = *(x_WORD *)(v8 + 588);
			if (v9)
				*(x_WORD *)(v8 + 588) = v9 - 1;
			if (*(x_DWORD *)(a1 + 144) < 0)
				*(x_DWORD *)(a1 + 144) = 0;
			v10 = *(x_DWORD *)(a1 + 140);
			if (*(x_DWORD *)(a1 + 144) > v10)
				*(x_DWORD *)(a1 + 144) = v10;
			if (*(x_DWORD *)(a1 + 8) < -1)
				*(x_DWORD *)(a1 + 8) = -1;
			v11 = *(x_DWORD *)(a1 + 4);
			if (*(x_DWORD *)(a1 + 8) > v11)
				*(x_DWORD *)(a1 + 8) = v11;
			v12 = *(x_DWORD *)(a1 + 164);
			v13 = *(x_DWORD *)(v12 + 365);
			if (v13)
				*(x_DWORD *)(v12 + 365) = v13 - 1;
			v14 = *(x_DWORD *)(a1 + 164);
			v15 = *(x_WORD *)(v14 + 584);
			if (v15)
				*(x_WORD *)(v14 + 584) = v15 - 1;
			if (v16 || *(x_BYTE *)(a1 + 13) & 0x10)
			{
				*(x_DWORD *)(a1 + 136) = *(x_DWORD *)(a1 + 140) / 200;
				*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 355) = *(x_DWORD *)(a1 + 4) / 250;
				if (*(x_DWORD *)(a1 + 136) < 1000)
					*(x_DWORD *)(a1 + 136) = 1000;
				*(x_BYTE *)(a1 + 13) &= 0xEFu;
			}
			else
			{
				*(x_DWORD *)(a1 + 136) = *(x_DWORD *)(a1 + 140) / 2000;
				*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 355) = *(x_DWORD *)(a1 + 4) / 2000;
				if (*(x_DWORD *)(a1 + 136) < 100)
					*(x_DWORD *)(a1 + 136) = 100;
			}
		}
	}
	else
	{
		v5 = (int)x_D41A0_BYTEARRAY_0;
		*(x_BYTE *)(a1 + 69) = 2;
		*(x_WORD *)(a1 + 44) = 0;
		sub_6E450((signed int)(a1 - (v5 + 28302)) / 168, -1, 16);
	}
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// D4B8C: using guessed type int x_DWORD_D4B8C;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0005E310) --------------------------------------------------------
int sub_5E310(int a1)
{
	int v1; // edx
	__int16 v2; // cx
	int v3; // esi
	__int16 v4; // ax
	__int16 v5; // di
	int v6; // eax
	int result; // eax
	unsigned __int16 v8; // di
	int v9; // eax
	char v10; // dl
	int v11; // edx
	int v12; // eax
	int v13; // edx
	char *v14; // esi
	char *v15; // edi
	char v16; // al
	char v17; // al
	int v18; // eax
	unsigned int v19; // edx
	__int16 v20; // di
	__int16 v21; // ax
	int v22; // ecx
	unsigned int j; // ecx
	int v24; // [esp+0h] [ebp-Ch]
	signed int i; // [esp+4h] [ebp-8h]
	unsigned int v26; // [esp+8h] [ebp-4h]

	sub_5D530(a1);
	if (x_D41A0_BYTEARRAY_4[0x7F])
		sub_5C800(a1, 7);
	v1 = 2124 * *(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 56);
	if (*(x_BYTE *)(v1 + x_D41A0_BYTEARRAY_0 + 11230 + 991))
		sub_52E90(v1 + (int)x_D41A0_BYTEARRAY_0 + 11230, 0, 0);
	v2 = *(x_WORD *)(a1 + 44) - 2;
	*(x_WORD *)(a1 + 80) += *(x_WORD *)(a1 + 44);
	*(x_WORD *)(a1 + 44) = v2;
	if (v2 < -256)
		*(x_WORD *)(a1 + 44) = -256;
	if (*(x_WORD *)(a1 + 44) > 0)
		*(x_WORD *)(a1 + 44) = 0;
	v3 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 12);
	v4 = sub_10C40((__int16 *)(a1 + 76));
	v5 = v4;
	if (*(signed __int16 *)(a1 + 80) < v3 + v4)
		*(x_WORD *)(a1 + 80) = *(x_WORD *)(*(x_DWORD *)(a1 + 160) + 12) + v4;
	v6 = sub_4A190((int)&x_WORD_EB398, 10, 1);
	if (v6)
	{
		*(x_BYTE *)(v6 + 12) |= 0x80u;
		*(x_WORD *)(v6 + 26) = *(x_WORD *)(a1 + 26);
	}
	result = v5 + *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 12);
	if (*(signed __int16 *)(a1 + 80) == result)
	{
		sub_49F90();
		v8 = *(x_WORD *)(a1 + 36);
		if (v8)
		{
			v9 = x_DWORD_EA3E4[v8];
			if (*(x_BYTE *)(v9 + 63) == 3)
			{
				v10 = *(x_BYTE *)(v9 + 64);
				if (!v10 || v10 == 1)
				{
					v11 = *(x_DWORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 36)] + 164);
					v12 = *(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 56);
					++*(x_WORD *)(v11 + 2 * v12 + 38);
				}
			}
		}
		memset((void*)(a1 + 94), 0, 36);
		v13 = 2124 * *(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 56) + (int)x_D41A0_BYTEARRAY_0 + 11230;
		v14 = (char *)x_DWORD_E9C4C_langindexbuffer[374];
		v15 = (char *)(v13 + 28);
		do
		{
			v16 = *v14;
			*v15 = *v14;
			if (!v16)
				break;
			v17 = v14[1];
			v14 += 2;
			v15[1] = v17;
			v15 += 2;
		} while (v17);
		*(x_WORD *)(v13 + 79) = 1;
		*(x_WORD *)(v13 + 77) = 100;
		for (i = 0; i < 26; i++)
		{
			v18 = *(x_DWORD *)(a1 + 164) + 2 * i;
			v19 = x_DWORD_EA3E4[*(signed __int16 *)(v18 + 819)];
			v26 = v19;
			if (v19 <= x_DWORD_EA3E4[0])
			{
				*(x_WORD *)(v18 + 819) = 0;
			}
			else
			{
				*(x_WORD *)(v18 + 819) = 1;
				*(x_BYTE *)(v19 + 12) &= 0xFEu;
				++*(x_BYTE *)(v19 + 69);
				*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
				*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
				*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
				v20 = *(x_WORD *)(a1 + 20);
				x_WORD_EB398 += (*(x_WORD *)(a1 + 20) & 0x1FF) - 256;
				v21 = 9377 * v20 + 9439;
				*(x_WORD *)(a1 + 20) = v21;
				x_WORD_EB39A += (v21 & 0x1FF) - 256;
				sub_57CF0(v19, (int)&x_WORD_EB398);
				*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
				*(x_DWORD *)(v26 + 8) = *(unsigned __int16 *)(a1 + 20) % 0x5Au + 200;
			}
		}
		v24 = sub_4A190(a1 + 76, 10, 40);
		if (v24)
		{
			*(x_BYTE *)(a1 + 69) = 3;
			v22 = (int)x_D41A0_BYTEARRAY_4;
			v22 = (int)x_D41A0_BYTEARRAY_4;
			*(x_DWORD *)(a1 + 16) = 1200;
			for (j = *(x_DWORD *)(v22 + 38523); j > x_DWORD_EA3E4[0]; j = *(x_DWORD *)j)
			{
				if (*(x_BYTE *)(j + 64) == 39 && *(unsigned __int16 *)(j + 148) == (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168)
					*(x_WORD *)(j + 148) = (v24 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
			}
		}
		*(x_BYTE *)(a1 + 12) |= 0x20u;
		result = (int)x_D41A0_BYTEARRAY_0;
		--*(x_DWORD *)(result + 4582);
	}
	return result;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA224: using guessed type int x_DWORD_EA224;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39A: using guessed type __int16 x_WORD_EB39A;

//----- (0005E660) --------------------------------------------------------
int sub_5E660(int a1)
{
	char v1; // ah
	signed int v2; // ebx

	v1 = *(x_BYTE *)(a1 + 12);
	*(x_DWORD *)(a1 + 8) = -1;
	v2 = 0;
	*(x_BYTE *)(a1 + 12) = v1 | 0x20;
	while (v2 < 26)
	{
		if ((unsigned int)x_DWORD_EA3E4[*(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 2 * v2 + 819)] > x_DWORD_EA3E4[0])
			sub_57F10(x_DWORD_EA3E4[*(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 2 * v2 + 819)]);
		++v2;
	}
	sub_57F10(a1);
	return 1;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0005E6C0) --------------------------------------------------------
__int16 sub_5E6C0(int a1)
{
	char v1; // al
	x_WORD *v2; // edi
	__int16 v3; // ax
	__int16 v4; // ST04_2
	unsigned __int16 v5; // ST00_2
	__int16 v6; // ax
	unsigned __int16 v7; // ST00_2
	__int16 v8; // ax
	__int16 result; // ax

	v1 = 0;
	if (!*(x_WORD *)(a1 + 36))
		v1 = 1;
	if (v1)
	{
		*(x_WORD *)(a1 + 28) += 5;
		*(x_BYTE *)(a1 + 29) &= 7u;
		v8 = sub_10C40((__int16 *)(a1 + 76));
		++HIBYTE(v8);
	}
	else
	{
		v2 = (x_WORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 36)] + 76);
		*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)v2);
		v3 = sub_58210((x_WORD *)(a1 + 76), v2);
		v4 = *(x_WORD *)(a1 + 32);
		v5 = *(x_WORD *)(a1 + 28);
		*(x_WORD *)(a1 + 34) = v3;
		v6 = sub_58350(v5, v4, 5, 0x16u);
		LOWORD(v2) = *(x_WORD *)(a1 + 34);
		*(x_WORD *)(a1 + 28) += v6;
		v7 = *(x_WORD *)(a1 + 30);
		*(x_BYTE *)(a1 + 29) &= 7u;
		*(x_WORD *)(a1 + 30) += sub_58350(v7, (__int16)v2, 5, 0x16u);
		*(x_BYTE *)(a1 + 31) &= 7u;
		v8 = sub_10C40((__int16 *)(a1 + 76));
	}
	*(x_WORD *)(a1 + 80) = v8;
	*(x_WORD *)(a1 + 30) = 0;
	result = *(x_WORD *)(a1 + 30);
	*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 343) = result;
	*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 341) = 0;
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0005E7C0) --------------------------------------------------------
char sub_5E7C0(int a1)
{
	int v1; // eax
	int v2; // ebx
	int v3; // edx
	int v4; // ebx
	x_BYTE *v5; // esi
	x_BYTE *v6; // edi

	*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 30) = 0;
	v1 = *(x_DWORD *)(a1 + 164);
	v2 = 2124 * *(signed __int16 *)(v1 + 56);
	if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + v2 + 11239) == 1)
	{
		v3 = v2 + (int)x_D41A0_BYTEARRAY_0 + 11230;
		if (*(x_WORD *)(v1 + 58))
		{
			v4 = *(x_DWORD *)(a1 + 16);
			if (v4)
				*(x_DWORD *)(a1 + 16) = v4 - 1;
			else
				LOBYTE(v1) = sub_5C950(v3, a1);
		}
		else
		{
			if (*(x_BYTE *)(v3 + 6))
			{
				v5 = (x_BYTE *)x_DWORD_E9C4C_langindexbuffer[283];
				v6 = (x_BYTE *)(v3 + 28);
				do
				{
					LOBYTE(v1) = *v5;
					*v6 = *v5;
					if (!(x_BYTE)v1)
						break;
					LOBYTE(v1) = v5[1];
					v5 += 2;
					v6[1] = v1;
					v6 += 2;
				} while ((x_BYTE)v1);
				*(x_WORD *)(v3 + 79) = 1;
				*(x_WORD *)(v3 + 77) = 200;
			}
			*(x_BYTE *)(v3 + 6) = 0;
		}
	}
	else
	{
		sub_5C800(a1, 7);
		LOBYTE(v1) = sub_5E6C0(a1);
	}
	return v1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA0B8: using guessed type int x_DWORD_EA0B8;

//----- (0005E8C0) --------------------------------------------------------
signed int sub_5E8C0(int a1)
{
	__int16 v1; // si
	int v2; // eax
	unsigned __int8 v3; // dl
	__int16 v4; // di
	__int16 v5; // dx
	unsigned int v6; // eax
	char v7; // dl
	int v8; // esi
	signed __int16 v9; // ax
	__int16 v10; // si
	int v11; // eax
	int v12; // ecx
	int v13; // edx
	int v14; // esi
	__int16 v15; // di
	int v16; // esi
	__int16 v17; // cx
	int v18; // eax
	int v19; // eax
	int v20; // eax
	int v21; // edx
	int v22; // eax
	__int16 v23; // ax
	int v24; // edx
	int v25; // esi
	int v26; // ecx
	signed int result; // eax
	char v28; // [esp+0h] [ebp-4h]

	v28 = 0;
	switch (*(x_BYTE *)(a1 + 70))
	{
	case 0:
		sub_52E90(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + (int)x_D41A0_BYTEARRAY_0 + 11230, 0, 0);
		if (*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 56) == *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12))
		{
			sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 41);
			sub_5C800(a1, 6);
		}
		*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 334) = 0;
		*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 332) = 0;
		*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 30) = 0;
		*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 16) = 0;
		v1 = *(x_WORD *)(*(x_DWORD *)(a1 + 164) + 825);
		if (v1)
			*(x_WORD *)(x_DWORD_EA3E4[v1] + 46) = 0;
		v2 = (int)x_D41A0_BYTEARRAY_0;
		*(x_BYTE *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + v2 + 11232) |= 0x20u;
		v3 = *(x_BYTE *)(a1 + 69);
		*(x_WORD *)(a1 + 150) = 0;
		if (v3 >= 0xBu)
		{
			if (v3 <= 0xBu)
			{
				v5 = *(x_WORD *)(0x36DFC + v2);
				if (v5)
					*(x_WORD *)(a1 + 150) = v5;
			}
			else if (v3 == 12)
			{
				v4 = *(x_WORD *)(v2 + 224766);
				if (v4)
					*(x_WORD *)(a1 + 150) = v4;
			}
		}
		v6 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
		if (v6 > x_DWORD_EA3E4[0])
		{
			if (*(x_BYTE *)(v6 + 63) != 14 || (v7 = *(x_BYTE *)(v6 + 64), v7 != 4) && v7 != 3)
				*(x_WORD *)(a1 + 150) = 0;
		}
		*(x_BYTE *)(a1 + 70) = 1;
		break;
	case 1:
		*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
		*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
		v8 = *(signed __int16 *)(a1 + 130);
		sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), 0, *(x_WORD *)(a1 + 130));
		if ((unsigned __int16)sub_5D0A0(a1))
			sub_57CF0(a1, (int)&x_WORD_EB398);
		else
			*(x_WORD *)(a1 + 130) = 0;
		if (abs(v8) <= 4)
		{
			*(x_WORD *)(a1 + 130) = 0;
		}
		else
		{
			if (v8 <= 0)
				v9 = 1;
			else
				v9 = -1;
			*(x_WORD *)(a1 + 130) += 4 * v9;
		}
		if (!*(x_WORD *)(a1 + 130))
			*(x_BYTE *)(a1 + 70) = (*(x_WORD *)(a1 + 150) == 0) + 3;
		break;
	case 3:
		v10 = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)] + 76));
		if ((unsigned __int16)sub_582B0(*(x_WORD *)(a1 + 28), v10) <= 0xBu)
		{
			*(x_BYTE *)(a1 + 70) = 4;
			*(x_WORD *)(a1 + 28) = v10;
		}
		else
		{
			*(x_WORD *)(a1 + 28) += sub_58350(*(x_WORD *)(a1 + 28), v10, 0, 0xBu);
			*(x_BYTE *)(a1 + 29) &= 7u;
		}
		break;
	case 4:
		*(x_DWORD *)(a1 + 16) = 12;
		v11 = (int)x_D41A0_BYTEARRAY_0;
		*(x_BYTE *)(a1 + 70) = 5;
		*(x_BYTE *)(v11 + 224779) |= 2u;
		goto LABEL_34;
	case 5:
	LABEL_34:
		v12 = *(x_DWORD *)(a1 + 16) - 1;
		*(x_DWORD *)(a1 + 16) = v12;
		if (v12)
		{
			if (v12 > 4)
				--*(x_WORD *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11707);
		}
		else
		{
			if (*(x_WORD *)(a1 + 150))
				*(x_BYTE *)(a1 + 70) = 6;
			else
				*(x_BYTE *)(a1 + 70) = 8;
			if (x_DWORD_E9C3C && !*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308))
			{
				sub_86860(x_WORD_1803EC);
				//sub_53E60_readfile_and_decompress("data/gtd2.dat", &x_BYTE_FAEE0); //fix it
			}
		}
		break;
	case 6:
		*(x_DWORD *)(a1 + 16) = 512;
		*(x_WORD *)(a1 + 130) = 100;
		*(x_BYTE *)(a1 + 70) = 7;
		v28 = 1;
		goto LABEL_44;
	case 7:
	LABEL_44:
		v13 = *(x_DWORD *)(a1 + 16) - 1;
		*(x_DWORD *)(a1 + 16) = v13;
		if (!v13)
			goto LABEL_51;
		*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
		*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
		v14 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
		*(x_WORD *)(a1 + 28) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v14 + 76));
		sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), 0, *(x_WORD *)(a1 + 130));
		v15 = *(x_WORD *)(a1 + 130) + 8;
		*(x_WORD *)(a1 + 130) = v15;
		if (v15 < 0)
			*(x_WORD *)(a1 + 130) = 0;
		if (*(x_WORD *)(a1 + 130) > 200)
			*(x_WORD *)(a1 + 130) = 200;
		if (!(unsigned __int16)sub_5D0A0(a1))
			goto LABEL_51;
		sub_57CF0(a1, (int)&x_WORD_EB398);
		if (sub_58490((x_WORD *)(a1 + 76), (x_WORD *)(v14 + 76)) < 0x180)
			goto LABEL_51;
		break;
	case 8:
		*(x_DWORD *)(a1 + 16) = 128;
		*(x_WORD *)(a1 + 130) = 100;
		*(x_BYTE *)(a1 + 70) = 9;
		v28 = 1;
		goto LABEL_53;
	case 9:
	LABEL_53:
		v16 = *(x_DWORD *)(a1 + 16) - 1;
		*(x_DWORD *)(a1 + 16) = v16;
		if (!v16)
			goto LABEL_51;
		*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
		*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
		sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), 0, *(x_WORD *)(a1 + 130));
		v17 = *(x_WORD *)(a1 + 130) + 8;
		*(x_WORD *)(a1 + 130) = v17;
		if (v17 < 0)
			*(x_WORD *)(a1 + 130) = 0;
		if (*(x_WORD *)(a1 + 130) > 200)
			*(x_WORD *)(a1 + 130) = 200;
		if ((unsigned __int16)sub_5D0A0(a1))
			sub_57CF0(a1, (int)&x_WORD_EB398);
		else
			LABEL_51:
		*(x_BYTE *)(a1 + 70) = 10;
		break;
	case 0xA:
		*(x_BYTE *)(a1 + 70) = 11;
		v18 = *(x_DWORD *)(a1 + 164);
		*(x_DWORD *)(a1 + 16) = 32;
		if (*(x_WORD *)(v18 + 56) == *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12))
			sub_5C800(a1, 5);
		goto LABEL_62;
	case 0xB:
	LABEL_62:
		v19 = *(x_DWORD *)(a1 + 16) - 1;
		*(x_DWORD *)(a1 + 16) = v19;
		if (v19 && x_D41A0_BYTEARRAY_4[0xB4])
		{
			*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
			*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
			sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), 0, 2);
			if ((unsigned __int16)sub_5D0A0(a1))
				sub_57CF0(a1, (int)&x_WORD_EB398);
		}
		else
		{
			*(x_BYTE *)(a1 + 70) = 12;
		}
		break;
	case 0xC:
		v20 = (int)x_D41A0_BYTEARRAY_0;
		v21 = 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
		*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8625) = 0;
		*(x_BYTE *)(v20 + 8593) = 0;
		*(x_WORD *)(v21 + v20 + 11232) = 10;
		if (*(x_BYTE *)(a1 + 69) == 11)
			x_D41A0_BYTEARRAY_4[38545] &= 0xFBu;
		if (*(x_BYTE *)(a1 + 69) == 11 || x_D41A0_BYTEARRAY_4[38545] & 0x10)
			*(x_BYTE *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11232) |= 0x10u;
		break;
	default:
		break;
	}
	if (v28)
	{
		if (*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 56) == *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12))
		{
			sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 19);
			if (x_DWORD_E9C3C)
			{
				v22 = (int)x_D41A0_BYTEARRAY_0;
				*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8625) = 1;
				*(x_BYTE *)(v22 + 8593) = 2;
			}
		}
	}
	v23 = sub_10C40((__int16 *)(a1 + 76));
	v24 = *(signed __int16 *)(a1 + 80);
	if (v24 <= v23 + 256)
	{
		if (v24 >= v23)
			*(x_WORD *)(a1 + 80) = v23 + 128;
		else
			*(x_WORD *)(a1 + 80) += 128;
	}
	else
	{
		*(x_WORD *)(a1 + 80) -= 128;
	}
	v25 = *(x_DWORD *)(a1 + 164);
	*(x_WORD *)(v25 + 341) -= (signed int)(*(signed __int16 *)(v25 + 341)
		- (__CFSHL__((unsigned __int64)*(signed __int16 *)(v25 + 341) >> 32, 3)
			+ 8 * ((unsigned __int64)*(signed __int16 *)(v25 + 341) >> 32))) >> 3;
	v26 = *(x_DWORD *)(a1 + 164);
	result = (signed int)(*(signed __int16 *)(v26 + 343)
		- (__CFSHL__((unsigned __int64)*(signed __int16 *)(v26 + 343) >> 32, 2)
			+ 4 * ((unsigned __int64)*(signed __int16 *)(v26 + 343) >> 32))) >> 2;
	*(x_WORD *)(v26 + 343) -= result;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// E9C3C: using guessed type int x_DWORD_E9C3C;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// 1803EC: using guessed type __int16 x_WORD_1803EC;

//----- (0005EF70) --------------------------------------------------------
unsigned int sub_5EF70(unsigned int a1)
{
	unsigned int result; // eax

	result = a1;
	if (a1 > x_DWORD_EA3E4[0] && *(x_BYTE *)(a1 + 63) == 3 && !*(x_BYTE *)(a1 + 64))
	{
		result = *(x_DWORD *)(a1 + 164);
		*(x_WORD *)(result + 54) = 100;
	}
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0005EFA0) --------------------------------------------------------
signed int sub_5EFA0(unsigned int a1)
{
	signed int v1; // esi
	unsigned int v2; // eax
	int v3; // edi
	int v4; // eax
	int v5; // eax
	int v6; // eax
	int v7; // eax
	__int16 v8; // ax
	char v9; // ch
	int v10; // eax
	char v11; // dl
	int v12; // edi
	char v13; // dh
	unsigned __int16 v14; // di
	int v15; // edi
	int v16; // eax
	int v17; // eax

	*(x_WORD *)(a1 + 38) = 0;
	v1 = 0;
	if (*(x_WORD *)(a1 + 150))
	{
		v2 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
		if (v2 > x_DWORD_EA3E4[0] && (*(x_DWORD *)(v2 + 8) <= 0 || *(x_BYTE *)(v2 + 13) & 4))
			*(x_WORD *)(a1 + 150) = 0;
	}
	if (*(x_DWORD *)(a1 + 8) >= 0)
	{
		if (*(x_WORD *)(a1 + 122))
		{
			v3 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 122)];
			if (v3)
			{
				*(x_WORD *)(*(x_DWORD *)(v3 + 164) + 326) = (signed int)(a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
				*(x_DWORD *)(*(x_DWORD *)(v3 + 164) + 322) = sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(v3 + 76));
				*(x_WORD *)(*(x_DWORD *)(v3 + 164) + 330) = *(x_WORD *)(a1 + 118);
				v4 = *(x_DWORD *)(v3 + 164);
				if (*(x_DWORD *)(v4 + 322) < 1024)
					*(x_DWORD *)(v4 + 322) = 1024;
				v5 = *(x_DWORD *)(v3 + 164);
				if (*(x_DWORD *)(v5 + 322) > 3072)
					*(x_DWORD *)(v5 + 322) = 3072;
				sub_6D8B0(*(x_WORD *)(a1 + 122), 0xEu, 1);
			}
			v6 = *(x_DWORD *)(a1 + 164);
			*(x_WORD *)(a1 + 122) = 0;
			*(x_BYTE *)(v6 + 406) = 4;
			*(x_DWORD *)(*(x_DWORD *)(a1 + 164) + 397) = 16;
			*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 588) = 64;
			sub_5EF70(a1);
		}
		if (*(x_WORD *)(a1 + 116))
			sub_61050(a1);
		v7 = *(x_DWORD *)(a1 + 164);
		if (*(x_BYTE *)(v7 + 332) && x_D41A0_BYTEARRAY_4[181])
			sub_5C830(a1, 3, 171 * *(unsigned __int8 *)(v7 + 332) / 3 + 85);
		v8 = *(x_WORD *)(a1 + 98);
		if (v8)
		{
			v9 = *(x_BYTE *)(a1 + 13);
			*(x_WORD *)(a1 + 38) = v8;
			if (v9 & 0x40 || *(x_BYTE *)(a1 + 14) & 0x40)
			{
				sub_6D8B0((signed int)(a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, 6u, 1);
				if (*(x_BYTE *)(a1 + 13) & 0x40)
				{
					v10 = (*(x_DWORD *)(a1 + 94) - (__CFSHL__(*(x_DWORD *)(a1 + 94) >> 31, 2) + 4 * (*(x_DWORD *)(a1 + 94) >> 31))) >> 2;
					v11 = *(x_BYTE *)(a1 + 13);
					v12 = *(x_DWORD *)(a1 + 144) - v10;
					*(x_DWORD *)(a1 + 94) = v10;
					*(x_DWORD *)(a1 + 144) = v12;
					*(x_BYTE *)(a1 + 13) = v11 & 0xBF;
				}
				else
				{
					*(x_DWORD *)(a1 + 12) &= 0xFFBFBFFF;
					v13 = *(x_BYTE *)(a1 + 13);
					*(x_DWORD *)(a1 + 94) = 0;
					*(x_BYTE *)(a1 + 13) = v13 | 0x40;
				}
			}
			v14 = *(x_WORD *)(a1 + 98);
			*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
			v15 = x_DWORD_EA3E4[v14];
			*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 32) = sub_581E0((Bit16u*)(v15 + 76), (Bit16u*)(a1 + 76));
			*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 34) = sub_58210((x_WORD *)(v15 + 76), (x_WORD *)(a1 + 76));
			*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 30) = *(x_DWORD *)(a1 + 94) / 10;
			v16 = *(x_DWORD *)(a1 + 164);
			if (*(x_WORD *)(v16 + 30) < 0)
				*(x_WORD *)(v16 + 30) = 0;
			v17 = *(x_DWORD *)(a1 + 164);
			if (*(x_WORD *)(v17 + 30) > 80)
				*(x_WORD *)(v17 + 30) = 80;
			sub_5C800(a1, 2);
			*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 406) = 4;
			*(x_DWORD *)(*(x_DWORD *)(a1 + 164) + 397) = 16;
			*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 588) = 64;
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			sub_6E450((signed int)(a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, (*(x_WORD *)(a1 + 20) & 3) + 54);
			if (*(x_DWORD *)(a1 + 8) < 0)
			{
				*(x_WORD *)(a1 + 36) = *(x_WORD *)(a1 + 98);
				if (*(x_BYTE *)(v15 + 63) == 10 && *(x_BYTE *)(v15 + 64) == 67)
					*(x_WORD *)(a1 + 36) = 0;
				v1 = 2;
			}
			if (v1 != 2)
			{
				v1 = 1;
				sub_5EF70(a1);
				*(x_WORD *)(a1 + 98) = 0;
			}
		}
	}
	else
	{
		v1 = 2;
	}
	if (x_D41A0_BYTEARRAY_4_struct.setting_byte4_25 & 1 && !*(x_BYTE *)(a1 + 64))
	{
		*(x_WORD *)(a1 + 38) = 0;
		*(x_WORD *)(a1 + 36) = 0;
		*(x_WORD *)(a1 + 98) = 0;
		*(x_DWORD *)(a1 + 8) = 10000;
		v1 = 0;
	}
	return v1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0005F380) --------------------------------------------------------
char sub_5F380(int a1)
{
	signed __int16 v1; // ax
	int v2; // edx
	int v3; // edx
	int v4; // eax
	int v5; // eax
	signed __int16 v6; // ax
	__int16 v7; // di
	signed __int16 v8; // ax
	signed __int16 v9; // dx
	__int16 v10; // di
	signed int v11; // eax
	int v12; // eax
	int v13; // eax
	int v14; // edx
	bool v15; // zf
	bool v16; // sf
	unsigned __int8 v17; // of
	int v18; // eax
	int v19; // edx
	int v20; // eax
	int v21; // eax
	x_BYTE *v22; // eax

	v1 = 0;
	*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 14) = 0;
	v2 = *(x_DWORD *)(a1 + 164);
	if (*(x_BYTE *)v2 & 1 && *(signed __int16 *)(v2 + 12) < x_DWORD_D4B8C)
		v1 = 1;
	v3 = *(x_DWORD *)(a1 + 164);
	if (*(x_BYTE *)v3 & 2 && *(signed __int16 *)(v3 + 12) > x_DWORD_D4B88)
		v1 = -1;
	if (v1)
	{
		*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 12) += x_DWORD_D4B84 * v1;
		v4 = *(x_DWORD *)(a1 + 164);
		if (*(signed __int16 *)(v4 + 12) < x_DWORD_D4B88)
			*(x_WORD *)(v4 + 12) = x_DWORD_D4B88;
		v5 = *(x_DWORD *)(a1 + 164);
		if (*(signed __int16 *)(v5 + 12) > x_DWORD_D4B8C)
			*(x_WORD *)(v5 + 12) = x_DWORD_D4B8C;
		*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 14) = 1;
	}
	v6 = 0;
	if (**(x_BYTE **)(a1 + 164) & 4)
		v6 = -1;
	if (**(x_BYTE **)(a1 + 164) & 8)
		v6 = 1;
	if (v6)
	{
		*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 16) += x_WORD_D4BA4 * v6;
		v18 = *(x_DWORD *)(a1 + 164);
		if (*(signed __int16 *)(v18 + 16) < x_DWORD_D4BA8)
			*(x_WORD *)(v18 + 16) = x_DWORD_D4BA8;
		v13 = *(x_DWORD *)(a1 + 164);
		v19 = *(signed __int16 *)(v13 + 16);
		v17 = __OFSUB__(v19, x_DWORD_D4BAC);
		v15 = v19 == x_DWORD_D4BAC;
		v16 = v19 - x_DWORD_D4BAC < 0;
	}
	else
	{
		v7 = *(x_WORD *)(*(x_DWORD *)(a1 + 164) + 16);
		if (v7)
		{
			if (v7 <= 0)
				v8 = -1;
			else
				v8 = 1;
		}
		else
		{
			v8 = 0;
		}
		v9 = v8;
		*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 16) += v8 * x_WORD_D4BB0;
		v10 = *(x_WORD *)(*(x_DWORD *)(a1 + 164) + 16);
		if (v10)
		{
			if (v10 <= 0)
				v11 = -1;
			else
				v11 = 1;
		}
		else
		{
			v11 = 0;
		}
		if (v9 != v11)
			*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 16) = 0;
		v12 = *(x_DWORD *)(a1 + 164);
		if (*(signed __int16 *)(v12 + 16) < x_DWORD_D4BA8)
			*(x_WORD *)(v12 + 16) = x_DWORD_D4BA8;
		v13 = *(x_DWORD *)(a1 + 164);
		v14 = *(signed __int16 *)(v13 + 16);
		v17 = __OFSUB__(v14, x_DWORD_D4BAC);
		v15 = v14 == x_DWORD_D4BAC;
		v16 = v14 - x_DWORD_D4BAC < 0;
	}
	if (!((unsigned __int8)(v16 ^ v17) | (unsigned __int8)v15))
		*(x_WORD *)(v13 + 16) = x_DWORD_D4BAC;
	v20 = *(x_DWORD *)(a1 + 164);
	if (*(x_BYTE *)v20 & 0x10)
		sub_5F660(a1, x_DWORD_EA3E4[*(signed __int16 *)(v20 + 2 * *(signed __int16 *)(v20 + 1105) + 819)], 256);
	v21 = *(x_DWORD *)(a1 + 164);
	if (*(x_BYTE *)v21 & 0x20)
		sub_5F660(a1, x_DWORD_EA3E4[*(signed __int16 *)(v21 + 2 * *(signed __int16 *)(v21 + 1107) + 819)], 512);
	v22 = *(x_BYTE **)(a1 + 164);
	if (*v22 & 0x40)
		LOBYTE(v22) = sub_5F660(
			a1,
			x_DWORD_EA3E4[*(signed __int16 *)&v22[2 * (unsigned __int8)x_BYTE_D94FF[(char)v22[1112]] + 819]],
			256);
	return (char)v22;
}
// D4B84: using guessed type int x_DWORD_D4B84;
// D4B88: using guessed type int x_DWORD_D4B88;
// D4B8C: using guessed type int x_DWORD_D4B8C;
// D4BA4: using guessed type __int16 x_WORD_D4BA4;
// D4BA8: using guessed type int x_DWORD_D4BA8;
// D4BAC: using guessed type int x_DWORD_D4BAC;
// D4BB0: using guessed type __int16 x_WORD_D4BB0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0005F660) --------------------------------------------------------
char sub_5F660(int a1, unsigned int a2, int a3)
{
	int v3; // ecx
	char v5; // [esp+0h] [ebp-Ch]
	char v6; // [esp+4h] [ebp-8h]
	char v7; // [esp+8h] [ebp-4h]

	v3 = a3;
	v5 = 0;
	v7 = 0;
	v6 = 0;
	if (a2 > x_DWORD_EA3E4[0])
	{
		if (*(x_BYTE *)(a1 + 64) == 1)
		{
			v5 = 1;
			v3 = 0;
		}
		switch (*(x_BYTE *)(a2 + 64))
		{
		case 0:
			if (*(x_BYTE *)(a2 + 70) < 2)
				break;
			goto LABEL_16;
		case 1:
			if (*(x_WORD *)(a2 + 46) <= 0)
				break;
			*(x_BYTE *)(a2 + 60) = 1;
			*(x_BYTE *)(a1 + 13) &= 0xFCu;
			*(x_DWORD *)(a1 + 12) |= v3;
			sub_5F7E0(a2, a1);
			v7 = 1;
			goto LABEL_23;
		case 2:
			if (*(x_WORD *)(a2 + 46) <= 0)
				break;
			if (!v5)
				sub_6E450(0, *(x_WORD *)(*(x_DWORD *)(a1 + 164) + 56), 29);
			goto LABEL_23;
		case 4:
		case 6:
		case 8:
		case 0xB:
		case 0xC:
		case 0xE:
			if (*(x_BYTE *)(a1 + 64))
				goto LABEL_16;
			if (*(x_WORD *)(a2 + 46) <= 0)
				break;
			if (*(x_BYTE *)(a2 + 64) == 4)
				*(x_WORD *)(a2 + 46) = 7;
			else
				*(x_WORD *)(a2 + 46) = 1;
			goto LABEL_23;
		case 7:
			if (*(x_BYTE *)(a2 + 70) < 1 || !*(x_WORD *)(a2 + 46))
				break;
			goto LABEL_23;
		case 9:
		case 0xA:
		case 0xD:
		case 0xF:
		case 0x10:
		case 0x11:
		case 0x12:
		case 0x13:
		case 0x14:
		case 0x15:
		case 0x16:
		case 0x17:
		case 0x18:
		LABEL_16:
			if (*(x_WORD *)(a2 + 46))
				goto LABEL_23;
			break;
		default:
			break;
		}
		if (*(x_DWORD *)(a1 + 144) < *(x_DWORD *)(a2 + 140))
		{
			v6 = 1;
		}
		else
		{
			sub_5F7B0(a2, a1, v3);
			v7 = 1;
		}
	}
LABEL_23:
	if (v6 && !v5)
	{
		sub_88B60();
		sub_6E450(0, *(x_WORD *)(*(x_DWORD *)(a1 + 164) + 56), 29);
	}
	return v7;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0005F7B0) --------------------------------------------------------
unsigned __int8 sub_5F7B0(int a1, int a2, int a3)
{
	*(x_WORD *)(a1 + 46) = *(x_WORD *)(a1 + 48);
	*(x_BYTE *)(a2 + 13) &= 0xFCu;
	*(x_DWORD *)(a2 + 12) |= a3;
	return sub_5F7E0(a1, a2);
}

//----- (0005F7E0) --------------------------------------------------------
unsigned __int8 sub_5F7E0(int a1, int a2)
{
	unsigned __int8 result; // al

	result = *(x_BYTE *)(*(x_DWORD *)(a2 + 164) + 447);
	if (result < 2u || result <= 2u && (result = *(x_BYTE *)(a1 + 64), result != 1))
		*(x_BYTE *)(a2 + 12) &= 0xDFu;
	return result;
}

//----- (0005F810) --------------------------------------------------------
unsigned int sub_5F810(int a1, int a2, int a3)
{
	unsigned int v3; // edi
	unsigned int v4; // esi
	unsigned int v5; // ebx
	unsigned int v7; // eax

	v3 = -1;
	v4 = 0;
	v5 = x_D41A0_BYTEARRAY_4[0x967B];
	if (v5 <= x_DWORD_EA3E4[0])
		return 0;
	do
	{
		if (*(x_BYTE *)(v5 + 64) == 39
			&& !(*(x_BYTE *)(v5 + 13) & 0x20)
			&& *(unsigned __int16 *)(v5 + 148) == *(signed __int16 *)(a1 + 26)
			&& v5 != a2
			&& v5 != a3)
		{
			v7 = sub_58440((x_WORD *)(a1 + 76), (x_WORD *)(v5 + 76));
			if (v7 < v3)
			{
				v4 = v5;
				v3 = v7;
			}
		}
		v5 = *(x_DWORD *)v5;
	} while (v5 > x_DWORD_EA3E4[0]);
	return v4;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0005F890) --------------------------------------------------------
char sub_5F890(int a1, __int16 a2)
{
	x_WORD *v2; // eax
	__int16 v3; // bx

	v2 = *(x_WORD **)(x_DWORD_EA3E4[*(signed __int16 *)(a1 + 26)] + 164);
	v3 = *(x_WORD *)((char *)v2 + 823);
	if (v3)
	{
		if (a2)
		{
			v2 = (x_WORD *)x_DWORD_EA3E4[v3];
			v2[23] = v2[24] - 1;
		}
		else
		{
			*(x_WORD *)(x_DWORD_EA3E4[v3] + 46) = 0;
			LOBYTE(v2) = sub_6D880(a1);
		}
	}
	return (char)v2;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0005F8F0) --------------------------------------------------------
void sub_5F8F0(int a1)
{
	__int16 v1; // si
	char v2; // dl
	unsigned int v3; // esi

	v1 = *(x_WORD *)(a1 + 48);
	if (v1)
	{
		if (v1 == 1)
		{
			if (!(*(x_BYTE *)(a1 + 14) & 0x10))
			{
				*(x_BYTE *)(a1 + 69) = 5;
				*(x_WORD *)(a1 + 46) = 3;
				*(x_WORD *)(a1 + 48) = 0;
			}
		}
		else
		{
			--*(x_WORD *)(a1 + 48);
			sub_5F890(a1, 1);
			*(x_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
		}
	}
	else
	{
		if (sub_609E0(a1) == 2)
		{
			*(x_BYTE *)(a1 + 69) = 6;
		}
		else if (*(x_BYTE *)(a1 + 12) & 0x40)
		{
			*(x_WORD *)(a1 + 46) = 0;
			*(x_BYTE *)(a1 + 69) = 5;
		}
		*(x_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
		v2 = *(x_BYTE *)(a1 + 62);
		*(x_WORD *)(a1 + 148) = *(x_WORD *)(a1 + 26);
		if (!(v2 & 1))
		{
			sub_5FD00(a1);
			sub_49EC0((x_WORD *)a1, *(x_WORD *)(a1 + 16));
			*(x_WORD *)(a1 + 82) = -8192;
			*(x_WORD *)(a1 + 88) = 0x4000;
			sub_5FF50(a1);
			if (*(x_DWORD *)(a1 + 144) < *(x_DWORD *)(a1 + 140))
			{
				v3 = x_D41A0_BYTEARRAY_4[0x967B];
				if (v3 > x_DWORD_EA3E4[0])
				{
					while (*(x_BYTE *)(v3 + 64) != 39
						|| *(unsigned __int16 *)(v3 + 148) != *(signed __int16 *)(a1 + 26)
						|| !sub_10750(a1, v3))
					{
						v3 = *(x_DWORD *)v3;
						if (v3 <= x_DWORD_EA3E4[0])
							return;
					}
					*(x_DWORD *)(a1 + 144) += *(x_DWORD *)(v3 + 144);
					sub_57F10(v3);
				}
			}
		}
	}
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0005FA70) --------------------------------------------------------
void sub_5FA70(int a1)
{
	JUMPOUT((x_WORD)*(x_WORD *)(a1 + 46), 6, (int*)&loc_5FBBE);
	JUMPOUT(__CS__, (int*)off_5FA4C[*(unsigned __int16 *)(a1 + 46)]);
}
// 5FA4C: using guessed type int (*off_5FA4C[7])();

//----- (0005FA96) --------------------------------------------------------
//#error "5FAC8: positive sp value has been found (funcsize=17)"

//----- (0005FB09) --------------------------------------------------------
//#error "5FB1F: positive sp value has been found (funcsize=7)"

//----- (0005FB22) --------------------------------------------------------
//#error "5FB37: positive sp value has been found (funcsize=8)"

//----- (0005FB3A) --------------------------------------------------------
//#error "5FB89: positive sp value has been found (funcsize=25)"

//----- (0005FB8C) --------------------------------------------------------
//#error "5FBAE: positive sp value has been found (funcsize=12)"

//----- (0005FBB1) --------------------------------------------------------
//#error "5FBBF: positive sp value has been found (funcsize=5)"

//----- (0005FBD0) --------------------------------------------------------
unsigned int sub_5FBD0(__int16 *a1)
{
	unsigned int result; // eax
	__int16 v2; // ST08_2

	result = sub_4A190((int)(a1 + 77), 10, 42);
	if (result)
	{
		*(x_BYTE *)(result + 70) = *((x_BYTE *)a1 + 16);
		*(x_WORD *)(result + 26) = a1[13];
		*(x_WORD *)(result + 40) = (signed int)((char *)a1 - (int)x_D41A0_BYTEARRAY_0 - 28302) / 168;
		v2 = a1[8];
		a1[23] = 4;
		result = sub_49EC0((x_WORD *)result, v2);
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0005FC40) --------------------------------------------------------
int sub_5FC40(int a1)
{
	int result; // eax
	int v2; // ebx

	result = sub_4A190(a1 + 154, 10, 41);
	v2 = result;
	if (result)
	{
		*(x_BYTE *)(result + 70) = *(x_BYTE *)(a1 + 16);
		*(x_WORD *)(result + 26) = *(x_WORD *)(a1 + 26);
		result = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
		*(x_WORD *)(v2 + 40) = result;
		*(x_WORD *)(a1 + 46) = 6;
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0005FCA0) --------------------------------------------------------
int sub_5FCA0(int a1)
{
	int result; // eax

	result = sub_4A810();
	if (result)
	{
		sub_605E0(a1);
		*(x_BYTE *)(a1 + 69) = 4;
		sub_5FD00(a1);
		result = sub_5FF50(a1);
		*(x_WORD *)(a1 + 46) = 0;
		*(x_WORD *)(a1 + 48) = 5;
	}
	else
	{
		*(x_BYTE *)(a1 + 69) = 4;
	}
	return result;
}

//----- (0005FD00) --------------------------------------------------------
int sub_5FD00(int a1)
{
	int result; // eax
	int v2; // esi
	int v3; // esi
	int v4; // eax
	int v5; // esi
	__int16 v6; // di
	unsigned __int16 v7; // ax
	int v8; // edi
	__int16 v9; // ax
	__int16 v10; // ST0C_2
	int v11; // eax
	int v12; // edi
	signed int v13; // [esp+0h] [ebp-10h]
	int v14; // [esp+4h] [ebp-Ch]
	int v15; // [esp+8h] [ebp-8h]
	__int16 v16; // [esp+Ch] [ebp-4h]

	result = *(x_DWORD *)(x_DWORD_EA3E4[*(signed __int16 *)(a1 + 26)] + 164);
	v14 = 0;
	v2 = *(x_DWORD *)(a1 + 140);
	if (*(x_DWORD *)(result + 316) + *(x_DWORD *)(a1 + 144) > v2)
		v14 = *(x_DWORD *)(a1 + 144) - v2;
	if (!*(x_DWORD *)(a1 + 16))
	{
		result = *(x_DWORD *)(a1 + 144);
		v14 = *(x_DWORD *)(a1 + 144);
	}
	if (v14 > 0)
	{
		if (v14)
		{
			v3 = v14 / 1000;
			v16 = sub_4A810();
			if (v16
				|| (sub_49F90(), result = sub_4A810(), v3 = 8, v16 = result, *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 4582) = -1, (x_WORD)result))
			{
				if (v3 < 1)
					v3 = 1;
				if (v3 > 32)
					v3 = 32;
				if (v16 < 0)
					v16 = 0;
				if (v16 > v3)
					v16 = v3;
				v13 = 0;
				v15 = v14 / v16;
				for (result = v16; v16 > v13; result = v16)
				{
					*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
					*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
					v4 = sub_4A190((int)&x_WORD_EB398, 10, 39);
					v5 = v4;
					if (v4)
					{
						*(x_DWORD *)(v4 + 144) = v15;
						v6 = *(x_WORD *)(v4 + 20);
						*(x_WORD *)(v4 + 148) = *(x_WORD *)(a1 + 26);
						*(x_WORD *)(v4 + 20) = 9377 * v6 + 9439;
						v7 = *(x_WORD *)(v4 + 20);
						*(x_WORD *)(v5 + 154) = 0;
						*(x_WORD *)(v5 + 156) = 0;
						*(x_WORD *)(v5 + 130) = v7 % 0x30u + 16;
						v8 = *(signed __int16 *)(a1 + 80);
						v9 = sub_10C40((__int16 *)(a1 + 76));
						*(x_WORD *)(v5 + 44) = (1024
							- (v8
								- v9)
							- (__CFSHL__((1024 - (v8 - v9)) >> 31, 3)
								+ 8 * ((1024 - (v8 - v9)) >> 31))) >> 3;
						*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
						v10 = *(x_WORD *)(a1 + 20) % 0x1400u + 3840;
						*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
						sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 20) & 0x7FF, 0, v10);
						sub_57CF0(v5, (int)&x_WORD_EB398);
						v11 = *(x_DWORD *)(v5 + 144);
						v12 = v14 - v11;
						v14 = v12;
						*(x_DWORD *)(a1 + 144) -= v11;
						if (v12 < v15)
							v15 = v12;
					}
					++v13;
				}
			}
		}
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;

//----- (0005FF50) --------------------------------------------------------
int sub_5FF50(int a1)
{
	int v1; // edi
	int v2; // eax
	unsigned int v3; // esi
	unsigned int v4; // eax
	int v5; // eax
	int v6; // edx
	__int64 v7; // rtt
	int v8; // eax
	int v9; // esi
	unsigned int v10; // esi
	__int16 v11; // si
	int result; // eax
	int v13; // edi
	x_BYTE *v14; // esi
	__int16 v15; // ax
	int v16; // [esp+4h] [ebp-1Ch]
	int v17; // [esp+8h] [ebp-18h]
	int v18; // [esp+Ch] [ebp-14h]
	__int16 v19; // [esp+14h] [ebp-Ch]
	int v20; // [esp+18h] [ebp-8h]
	__int16 v21; // [esp+1Ch] [ebp-4h]

	v18 = x_DWORD_EA3E4[*(signed __int16 *)(a1 + 26)];
	v1 = 0;
	sub_60400(*(x_WORD *)(a1 + 16), &v21, &v19);
	if (v21 > 0)
	{
		do
		{
			while (1)
			{
				*(x_DWORD *)(*(x_DWORD *)(v18 + 164) + 302) = 0;
				v2 = *(x_DWORD *)(v18 + 164);
				v16 = 2 * (signed __int16)v1;
				v3 = x_DWORD_EA3E4[*(unsigned __int16 *)(v16 + v2 + 60)];
				if (v3 <= x_DWORD_EA3E4[0])
				{
					v8 = sub_4A190(a1 + 76, 3, 3);
					v9 = v8;
					if (v8)
					{
						*(x_WORD *)(v8 + 26) = *(x_WORD *)(a1 + 26);
						*(x_WORD *)(v8 + 90) += sub_616D0(*(signed __int16 *)(*(x_DWORD *)(v18 + 164) + 56));
						*(x_WORD *)(v9 + 148) = *(x_WORD *)(a1 + 26);
						*(x_WORD *)(v16 + *(x_DWORD *)(v18 + 164) + 60) = (v9 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
						*(x_BYTE *)(v9 + 69) = 9;
					}
					goto LABEL_17;
				}
				if (*(x_DWORD *)(v3 + 8) >= 0)
					break;
				sub_36BA0(v3, 0);
				sub_57F10(v3);
				*(x_WORD *)(v16 + *(x_DWORD *)(v18 + 164) + 60) = 0;
			LABEL_17:
				if ((signed __int16)++v1 >= v21)
					goto LABEL_22;
			}
			if (*(x_DWORD *)(v2 + 316) + *(x_DWORD *)(a1 + 144) >= *(x_DWORD *)(a1 + 140))
			{
				v6 = a1 - (x_D41A0_BYTEARRAY_0[28302]);
				v5 = a1 - (x_D41A0_BYTEARRAY_0[28302]);
			}
			else
			{
				if (*(unsigned __int8 *)(a1 + 62) % v21)
					goto LABEL_13;
				if (*(x_BYTE *)(v3 + 69) != 9)
					goto LABEL_13;
				*(x_WORD *)(v3 + 150) = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
				if (*(x_DWORD *)(v3 + 140) <= *(x_DWORD *)(v3 + 144))
					goto LABEL_13;
				*(x_WORD *)(x_DWORD_EA3E4[0] + 150) = 0;
				v4 = sub_5F810(
					v3,
					x_DWORD_EA3E4[*(unsigned __int16 *)(x_DWORD_EA3E4[*(unsigned __int16 *)(*(x_DWORD *)(v18 + 164)
						+ 2 * (((signed __int16)v1 + 1) % 3)
						+ 60)]
						+ 150)],
					x_DWORD_EA3E4[*(unsigned __int16 *)(x_DWORD_EA3E4[*(unsigned __int16 *)(2 * (((signed __int16)v1 + 2) % 3)
						+ *(x_DWORD *)(v18 + 164)
						+ 60)]
						+ 150)]);
				if (!v4)
					goto LABEL_13;
				v5 = v4 - (x_D41A0_BYTEARRAY_0[28302]);
				v6 = v5;
			}
			LODWORD(v7) = v5;
			HIDWORD(v7) = v6 >> 31;
			*(x_WORD *)(v3 + 150) = v7 / 168;
		LABEL_13:
			*(x_DWORD *)(*(x_DWORD *)(v18 + 164) + 302) += *(x_DWORD *)(v3 + 144);
			*(x_DWORD *)(*(x_DWORD *)(v18 + 164) + 298) += *(x_DWORD *)(v3 + 140);
			++v1;
		} while ((signed __int16)v1 < v21);
	}
LABEL_22:
	while ((signed __int16)v1 < 3)
	{
		v10 = x_DWORD_EA3E4[*(unsigned __int16 *)(2 * (signed __int16)v1 + *(x_DWORD *)(v18 + 164) + 60)];
		if (v10 > x_DWORD_EA3E4[0])
		{
			sub_36BA0(v10, 0);
			sub_57F10(v10);
			*(x_WORD *)(2 * (signed __int16)v1 + *(x_DWORD *)(v18 + 164) + 60) = 0;
		}
		LOWORD(v1) = v1 + 1;
	}
	v11 = *(x_WORD *)(a1 + 44);
	if (v11 > 0)
		*(x_WORD *)(a1 + 44) = v11 - 1;
	v20 = 0;
	result = 0;
	if (v19 > 0)
	{
		do
		{
			v13 = 2 * (signed __int16)v20;
			v14 = (x_BYTE *)x_DWORD_EA3E4[*(unsigned __int16 *)(v13 + *(x_DWORD *)(v18 + 164) + 92)];
			if ((unsigned int)v14 <= x_DWORD_EA3E4[0])
			{
				if (!*(x_WORD *)(a1 + 44))
				{
					v17 = sub_4A190(a1 + 76, 5, 15);
					if (v17)
					{
						*(x_WORD *)(a1 + 44) = 16;
						v15 = *(x_WORD *)(a1 + 26);
						*(x_WORD *)(v17 + 26) = v15;
						*(x_WORD *)(v17 + 148) = v15;
						*(x_WORD *)(*(x_DWORD *)(v18 + 164) + v13 + 92) = (v17 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
						*(x_WORD *)(v17 + 28) = 512;
						*(x_WORD *)(v17 + 32) = *(x_WORD *)(v17 + 28);
						*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(v17 + 76);
						*(&x_WORD_EB398 + 2) = *(x_WORD *)(v17 + 80);
						x_WORD_EB398 += 128;
						x_WORD_EB39A += 640;
						x_WORD_EB39C = sub_10C40(&x_WORD_EB398);
						sub_57CF0(v17, (int)&x_WORD_EB398);
					}
				}
			}
			else if (v14[63] != 5 || v14[64] != 15 || v14[69] == 125)
			{
				*(x_WORD *)(*(x_DWORD *)(v18 + 164) + 2 * (signed __int16)v20 + 92) = 0;
				*(x_WORD *)(a1 + 44) = 16;
			}
			result = ++v20;
		} while ((signed __int16)v20 < v19);
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39A: using guessed type __int16 x_WORD_EB39A;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (00060400) --------------------------------------------------------
x_WORD *sub_60400(__int16 a1, x_WORD *a2, x_WORD *a3)
{
	x_WORD *result; // eax

	result = a3;
	switch (a1)
	{
	case 1:
	case 2:
		*a2 = 1;
		*a3 = 0;
		break;
	case 3:
		*a2 = 1;
		*a3 = 4;
		break;
	case 4:
		*a2 = 2;
		*a3 = 6;
		break;
	case 5:
		*a2 = 2;
		*a3 = 14;
		break;
	case 6:
		*a2 = 3;
		*a3 = 18;
		break;
	case 7:
		*a2 = 3;
		*a3 = 34;
		break;
	default:
		*a2 = 0;
		*a3 = 0;
		break;
	}
	return result;
}

//----- (00060480) --------------------------------------------------------
char sub_60480(int a1)
{
	int v1; // eax
	int v2; // esi
	int v3; // edx
	__int16 v4; // ST08_2
	__int16 v5; // ST08_2
	int v6; // edi
	char v7; // dl

	v1 = sub_50370(a1 + 154);
	v2 = v1;
	if (v1)
	{
		sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 10);
		v3 = *(x_DWORD *)(a1 + 16) + 1;
		*(x_BYTE *)(a1 + 12) &= 0xBFu;
		*(x_DWORD *)(a1 + 16) = v3;
		v4 = *(x_WORD *)(a1 + 16);
		*(x_BYTE *)(a1 + 69) = 5;
		*(x_WORD *)(a1 + 46) = 4;
		sub_49EC0((x_WORD *)a1, v4);
		v5 = *(x_WORD *)(a1 + 16);
		*(x_WORD *)(a1 + 82) = -8192;
		*(x_WORD *)(a1 + 88) = 0x4000;
		sub_49EC0((x_WORD *)v2, v5);
		v6 = x_DWORD_EA3E4[*(signed __int16 *)(a1 + 26)];
		*(x_WORD *)(*(x_DWORD *)(v6 + 164) + 58) = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
		*(x_WORD *)(*(x_DWORD *)(v6 + 164) + 450) = *(x_WORD *)(a1 + 16);
		*(x_BYTE *)(*(x_DWORD *)(v6 + 164) + 446) = 0;
		sub_60810(a1);
		sub_613D0(a1);
		sub_6D8B0((v6 - (x_D41A0_BYTEARRAY_0[28302])) / 168, 2u, 1);
		*(x_WORD *)(v2 + 40) = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
		*(x_WORD *)(v2 + 26) = *(x_WORD *)(a1 + 26);
		v7 = *(x_BYTE *)(v2 + 14);
		LOBYTE(v1) = *(x_BYTE *)(a1 + 16);
		*(x_BYTE *)(v2 + 59) = 0;
		*(x_BYTE *)(v2 + 70) = v1;
		*(x_BYTE *)(v2 + 14) = v7 | 1;
	}
	return v1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000605E0) --------------------------------------------------------
void sub_605E0(int a1)
{
	int v1; // esi
	__int16 v2; // ST00_2
	int v3; // edi
	int v4; // edx
	int v5; // eax
	int v6; // edx
	//char result; // al
	int v8; // esi
	__int16 v9; // dx

	if (*(x_DWORD *)(a1 + 16) > 0)
	{
		v1 = 10 * *(x_DWORD *)(a1 + 140) / 100;
		*(x_DWORD *)(a1 + 140) -= v1;
		sub_5FD00(a1);
		v2 = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
		*(x_DWORD *)(a1 + 140) += v1;
		sub_6E450(v2, -1, 30);
		v3 = x_DWORD_EA3E4[0] + 76;
		*(x_DWORD *)v3 = *(x_DWORD *)(a1 + 154);
		*(x_WORD *)(v3 + 4) = *(x_WORD *)(a1 + 158);
		v4 = x_DWORD_EA3E4[0];
		*(x_BYTE *)(x_DWORD_EA3E4[0] + 70) = *(x_BYTE *)(a1 + 16);
		*(x_WORD *)(v4 + 26) = *(x_WORD *)(a1 + 26);
		v5 = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
		v6 = x_DWORD_EA3E4[0];
		*(x_BYTE *)(x_DWORD_EA3E4[0] + 64) = 0;
		*(x_DWORD *)(v6 + 16) = 0;
		*(x_WORD *)(v6 + 40) = v5;
		sub_385C0(v6);
		--*(x_DWORD *)(a1 + 16);
		sub_49EC0((x_WORD *)a1, *(x_WORD *)(a1 + 16));
		*(x_WORD *)(a1 + 82) = -8192;
		*(x_WORD *)(a1 + 88) = 0x4000;
		sub_60810(a1);
		sub_613D0(a1);
		sub_5F890(a1, 1);
	}
	if (!*(x_DWORD *)(a1 + 16))
	{
		v8 = x_DWORD_EA3E4[*(signed __int16 *)(a1 + 26)];
		if (*(x_BYTE *)(v8 + 64) == 1)
		{
			if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196306) & 4)
			{
				v9 = *(x_WORD *)(*(x_DWORD *)(v8 + 164) + 823);
				if (v9)
				{
					sub_57F10(x_DWORD_EA3E4[v9]);
					*(x_WORD *)(*(x_DWORD *)(v8 + 164) + 823) = 0;
				}
			}
		}
		else
		{
			sub_5F890(a1, *(x_DWORD *)(a1 + 16));
		}
		*(x_WORD *)(*(x_DWORD *)(v8 + 164) + 58) = 0;
		sub_57F10(a1);
	}
	//return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E0: using guessed type int x_DWORD_EA3E0_copyto_x_DWORD_EA3E0[];
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00060780) --------------------------------------------------------
int sub_60780(x_DWORD *a1, int a2, int a3, int a4)
{
	int v4; // edx
	int v5; // ecx
	char v6; // ST04_1
	__int16 v7; // di
	int result; // eax

	if (a3)
	{
		v4 = a1[2];
		v5 = 0;
		a1[1] = a3;
		if (v4 < 0)
		{
			v5 = -v4;
			if (-v4 > a3 / 2)
				v5 = a3 / 2;
		}
		a1[2] = a1[1] - v5;
	}
	if (a2)
	{
		v6 = *(x_BYTE *)(a2 + 70);
		v7 = *(x_WORD *)(a2 + 46);
		*(x_WORD *)(a2 + 46) = 0;
		sub_6D5E0(a2, v6);
		*(x_WORD *)(a2 + 46) = v7;
	}
	result = a4;
	a1[35] = a4;
	return result;
}

//----- (00060810) --------------------------------------------------------
unsigned int sub_60810(int a1)
{
	int v1; // eax
	char v2; // dl
	__int16 v3; // cx
	int v4; // edx
	int v5; // ecx
	unsigned int result; // eax

	v1 = x_DWORD_EA3E4[*(signed __int16 *)(a1 + 26)];
	v2 = *(x_BYTE *)(v1 + 69);
	if (!v2 || v2 == 1)
	{
		v3 = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 823);
		if (v3)
			v4 = x_DWORD_EA3E4[v3];
	}
	v5 = *(signed __int16 *)(*(x_DWORD *)(v1 + 164) + 586)
		* ((*(char *)(*(x_DWORD *)(a1 + 16) + *(x_DWORD *)(v1 + 164) + 590) << 8) + 256);
	result = *(x_DWORD *)(a1 + 16);
	if (result <= 7)
		JUMPOUT(__CS__, (int*) *(&off_607E8 + result));
	return result;
}
// 607E8: using guessed type void *off_607E8;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000609E0) --------------------------------------------------------
signed int sub_609E0(int a1)
{
	signed int v1; // esi
	int v3; // ecx
	__int16 v4; // ax
	int v5; // eax

	v1 = 0;
	if (*(x_DWORD *)(a1 + 8) < 0)
		return 2;
	if (*(x_WORD *)(a1 + 98))
	{
		v3 = *(x_DWORD *)(a1 + 8) - *(x_DWORD *)(a1 + 94);
		*(x_DWORD *)(a1 + 8) = v3;
		if (v3 < 0)
		{
			v4 = *(x_WORD *)(a1 + 98);
			*(x_WORD *)(a1 + 98) = 0;
			*(x_WORD *)(a1 + 36) = v4;
			return 2;
		}
		_wcpp_1_unwind_leave__100(a1, *(x_DWORD *)(a1 + 94));
		*(x_WORD *)(a1 + 98) = 0;
		v5 = *(signed __int16 *)(a1 + 26);
		*(x_DWORD *)(a1 + 94) = 0;
		v1 = 1;
		*(x_BYTE *)(*(x_DWORD *)(x_DWORD_EA3E4[v5] + 164) + 405) = 4;
	}
	if (*(unsigned __int16 *)(a1 + 128) == *(signed __int16 *)(a1 + 26))
	{
		if (*(x_DWORD *)(a1 + 16) < 7)
			*(x_BYTE *)(a1 + 12) |= 0x40u;
		*(x_WORD *)(a1 + 128) = 0;
	}
	return v1;
}
// 5FCF0: using guessed type int _wcpp_1_unwind_leave__100(x_DWORD, x_DWORD);
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00060AB0) --------------------------------------------------------
signed int sub_60AB0(int a1)
{
	unsigned int v1; // eax
	x_WORD *v2; // esi
	char v3; // dl
	signed int v4; // esi
	signed int v5; // edi
	signed int v6; // eax
	unsigned int v7; // edi
	int v8; // esi
	int v9; // ecx
	signed __int16 *v10; // eax
	__int16 v11; // ST10_2
	int v12; // ST0C_4
	int v13; // ST08_4
	__int16 v14; // ax
	int v16; // [esp+0h] [ebp-4h]

	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
	v16 = v1;
	if (v1 > x_DWORD_EA3E4[0])
	{
		*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
		*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
		v2 = (x_WORD *)(v1 + 76);
		*(x_WORD *)(a1 + 28) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(v1 + 76));
		v3 = *(x_BYTE *)(v16 + 63);
		if (v3 == 10)
		{
			if (*(unsigned __int16 *)(v16 + 148) != *(signed __int16 *)(a1 + 26))
				goto LABEL_20;
			if (x_BYTE_D41B6)
				v4 = 2048;
			else
				v4 = 1024;
			v5 = sub_58490(&x_WORD_EB398, (x_WORD *)(v16 + 76));
			if (v5 > v4)
			{
				*(x_BYTE *)(v16 + 12) &= 0xBFu;
			}
			else
			{
				*(x_BYTE *)(v16 + 12) |= 0x40u;
				*(x_WORD *)(v16 + 150) = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
				if (sub_106C0(v16, a1))
				{
					*(x_DWORD *)(a1 + 144) += *(x_DWORD *)(v16 + 144);
					*(x_WORD *)(a1 + 148) = *(x_WORD *)(v16 + 148);
					*(x_DWORD *)(a1 + 8) = *(x_DWORD *)(a1 + 4);
					*(x_WORD *)(a1 + 150) = 0;
					sub_57F10(v16);
				}
			}
			v6 = *(signed __int16 *)(a1 + 130);
			if (v5 <= v6)
			{
				x_WORD_EB398 = *(x_WORD *)(v16 + 76);
				x_WORD_EB39A = *(x_WORD *)(v16 + 78);
				goto LABEL_20;
			}
		}
		else
		{
			if (v3 == 3)
			{
				v7 = *(signed __int16 *)(a1 + 130) * *(x_DWORD *)(v16 + 16);
				if (sub_58490(&x_WORD_EB398, v2) <= v7)
				{
					v8 = *(signed __int16 *)(*(x_DWORD *)(a1 + 160) + 12);
					if (x_WORD_EB39C <= v8 + (signed __int16)sub_10C40(&x_WORD_EB398) && *(x_DWORD *)(v16 + 16) > 0)
					{
						x_WORD_EB398 = *(x_WORD *)(v16 + 76);
						v9 = *(x_DWORD *)(v16 + 144);
						x_WORD_EB39A = *(x_WORD *)(v16 + 78);
						*(x_DWORD *)(v16 + 144) = *(x_DWORD *)(a1 + 144) + v9;
						*(x_DWORD *)(a1 + 144) = 0;
						*(x_WORD *)(a1 + 148) = *(x_WORD *)(a1 + 26);
						*(x_DWORD *)(a1 + 8) = *(x_DWORD *)(a1 + 4);
					}
					goto LABEL_20;
				}
			}
			LOWORD(v6) = *(x_WORD *)(a1 + 130);
		}
		sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), *(x_WORD *)(a1 + 30), v6);
	LABEL_20:
		if (x_BYTE_D41B6)
		{
			sub_60D50(&x_WORD_EB398, a1);
		}
		else
		{
			v10 = *(signed __int16 **)(a1 + 160);
			v11 = v10[7];
			v12 = v10[5];
			v13 = v10[6];
			v14 = sub_10C40(&x_WORD_EB398);
			sub_580E0((int)&x_WORD_EB398, v14, v13, v12, v11);
			sub_57CF0(a1, (int)&x_WORD_EB398);
		}
	}
	return sub_60EA0(a1);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41B6: using guessed type char x_BYTE_D41B6;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39A: using guessed type __int16 x_WORD_EB39A;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (00060D50) --------------------------------------------------------
signed int sub_60D50(__int16 *a1, int a2)
{
	int v2; // edx
	char v3; // ch
	signed __int16 *v4; // edx
	__int16 v5; // ST10_2
	int v6; // ST0C_4
	int v7; // ST08_4
	__int16 v8; // ax
	int v9; // edi
	int v10; // edx
	char v12; // [esp+0h] [ebp-4h]

	v12 = 0;
	v2 = *a1 >> 8;
	BYTE1(v2) = (unsigned __int16)a1[1] >> 8;
	if (*(x_BYTE *)(a2 + 12) & 1)
	{
		if (!(x_BYTE_13B4E0[(unsigned __int16)v2] & 8) && !sub_11E70(a2, a1))
		{
			*(x_BYTE *)(a2 + 12) &= 0xFEu;
			v12 = 1;
		}
		*(x_WORD *)(a2 + 130) = 96;
	}
	else
	{
		if (x_BYTE_13B4E0[(unsigned __int16)v2] & 8 || sub_11E70(a2, a1))
		{
			v12 = 1;
			*(x_BYTE *)(a2 + 12) |= 1u;
		}
		*(x_WORD *)(a2 + 130) = 48;
	}
	v3 = *(x_BYTE *)(a2 + 70);
	if (v3)
		*(x_BYTE *)(a2 + 70) = v3 - 1;
	if (v12 && !*(x_BYTE *)(a2 + 70))
	{
		sub_6E450((a2 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 22);
		*(x_BYTE *)(a2 + 70) = 32;
	}
	v4 = *(signed __int16 **)(a2 + 160);
	v5 = v4[7];
	v6 = v4[5];
	v7 = v4[6];
	v8 = sub_10C40(a1);
	sub_580E0((int)a1, v8, v7, v6, v5);
	if (!(*(x_BYTE *)(a2 + 12) & 1))
	{
		v9 = *(signed __int16 *)(a2 + 88);
		v10 = (signed __int16)sub_10C60(a1) - v9;
		if (a1[2] > v10)
			a1[2] = v10;
	}
	return sub_57CF0(a2, (int)a1);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00060EA0) --------------------------------------------------------
signed int sub_60EA0(int a1)
{
	signed int v1; // edx
	int v3; // edx

	v1 = 0;
	if (*(x_DWORD *)(a1 + 8) < 0)
		return 2;
	if (*(x_WORD *)(a1 + 98))
	{
		v3 = *(x_DWORD *)(a1 + 164);
		*(x_DWORD *)(a1 + 8) -= *(x_DWORD *)(a1 + 94);
		*(x_BYTE *)(v3 + 407) = 4;
		if (*(x_DWORD *)(a1 + 8) < 0)
		{
			*(x_WORD *)(a1 + 36) = *(x_WORD *)(a1 + 98);
			return 2;
		}
		v1 = 1;
		*(x_WORD *)(a1 + 98) = 0;
	}
	return v1;
}

//----- (00060F00) --------------------------------------------------------
void sub_60F00()
{
	unsigned __int16 v0; // bx
	int v1; // eax
	int v2; // edx
	x_DWORD *v3; // eax
	unsigned int v4; // ebx

	v0 = 0;
	v1 = (int)x_D41A0_BYTEARRAY_0 + 11230;
	while (v0 < *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 14))
	{
		v2 = x_DWORD_EA3E4[*(unsigned __int16 *)(v1 + 10)];
		*(x_DWORD *)(v2 + 140) = *(x_DWORD *)(*(x_DWORD *)(v2 + 164) + 336);
		v1 += 2124;
		++v0;
		*(x_DWORD *)(*(x_DWORD *)(v2 + 164) + 316) = 0;
	}
	v3 = (x_DWORD *)x_D41A0_BYTEARRAY_4;
	v4 = x_DWORD_EA3E8;
	x_D41A0_BYTEARRAY_4[0xF6] = 1;
	*(x_DWORD *)((char *)v3 + 250) = 0;
	if (v4 < x_DWORD_EB384)
	{
		while (1)
		{
			LOBYTE(v3) = *(x_BYTE *)(v4 + 63);
			if ((unsigned __int8)v3 < 5u)
				break;
			if ((unsigned __int8)v3 <= 5u)
				goto LABEL_23;
			if ((x_BYTE)v3 != 10)
				goto LABEL_24;
			LOBYTE(v3) = *(x_BYTE *)(v4 + 64);
			if ((unsigned __int8)v3 < 0x2Du)
			{
				if ((x_BYTE)v3 == 39)
					goto LABEL_23;
			}
			else
			{
				if ((unsigned __int8)v3 <= 0x2Du)
				{
					LOWORD(v3) = sub_61000(v4);
					if (v3 && v3[41])
					{
						v3 = (x_DWORD *)v3[41];
						v3[79] += *(x_DWORD *)(v4 + 144);
					}
					goto LABEL_24;
				}
				if ((x_BYTE)v3 == 58)
					goto LABEL_23;
			}
		LABEL_24:
			v4 += 168;
			if (v4 >= x_DWORD_EB384)
				return/* (char)v3*/;
		}
		if ((x_BYTE)v3 != 3)
			goto LABEL_24;
		LOBYTE(v3) = *(x_BYTE *)(v4 + 64);
		if ((unsigned __int8)v3 < 2u || (unsigned __int8)v3 > 2u && (x_BYTE)v3 != 3)
			goto LABEL_24;
	LABEL_23:
		LOBYTE(v3) = sub_61000(v4);
		goto LABEL_24;
	}
	//return (char)v3;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EA3E8: using guessed type int x_DWORD_EA3E8;
// EB384: using guessed type int x_DWORD_EB384;

//----- (00061000) --------------------------------------------------------
__int16 sub_61000(int a1)
{
	int v1; // eax

	v1 = 0;
	if (*(x_WORD *)(a1 + 148))
	{
		LOWORD(v1) = *(x_WORD *)(a1 + 148);
		v1 = x_DWORD_EA3E4[v1];
		*(x_DWORD *)(v1 + 140) += *(x_DWORD *)(a1 + 144);
	}
	x_D41A0_BYTEARRAY_4[0xF6] += *(x_DWORD *)(a1 + 144);
	return v1;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00061050) --------------------------------------------------------
unsigned int sub_61050(unsigned int a1)
{
	unsigned __int16 v1; // ax
	unsigned int v2; // edx
	int v3; // eax
	unsigned __int8 v4; // dl
	int v5; // eax
	unsigned int v6; // ebx
	unsigned int v7; // eax
	int v8; // ecx
	__int64 v9; // rtt
	int v10; // edx
	int v11; // edx
	int v12; // ecx
	__int16 v13; // ax
	__int16 v14; // si
	__int16 v15; // ax
	int v16; // eax
	int v17; // ebx
	__int16 v18; // ax
	__int16 v19; // si
	__int16 v20; // ST0C_2
	unsigned __int16 v21; // ax
	int v22; // esi
	int v23; // esi
	int v24; // ebx
	unsigned int result; // eax
	int v26; // [esp+0h] [ebp-28h]
	__int16 v27; // [esp+4h] [ebp-24h]
	int *v28; // [esp+8h] [ebp-20h]
	unsigned int v29; // [esp+Ch] [ebp-1Ch]
	int v30; // [esp+10h] [ebp-18h]
	int v31; // [esp+14h] [ebp-14h]
	x_BYTE *v32; // [esp+18h] [ebp-10h]
	int v33; // [esp+1Ch] [ebp-Ch]
	x_DWORD *v34; // [esp+20h] [ebp-8h]
	char v35; // [esp+24h] [ebp-4h]

	v33 = 0;
	v35 = 0;
	v1 = *(x_WORD *)(a1 + 116);
	v2 = x_DWORD_EA3E4[v1];
	v34 = (x_DWORD *)v2;
	if (v2 < x_DWORD_EA3E4[0])
		goto LABEL_35;
	if (*(x_BYTE *)(v2 + 63) == 3)
	{
		sub_6D8B0(v1, 0xDu, 1);
		v3 = 26 * *(x_DWORD *)(a1 + 112);
		v28 = (int *)&unk_DAC44;
		v32 = &x_BYTE_DAC2A[v3];
		v4 = x_BYTE_DAC2A[v3 + 24];
		if (v4)
		{
			if (v4 > 2u)
				goto LABEL_23;
			v6 = x_DWORD_EA3E4[*(unsigned __int16 *)(*(x_DWORD *)(a1 + 164) + 58)];
			v7 = x_DWORD_EA3E4[*(unsigned __int16 *)(v34[41] + 58)];
			v31 = x_DWORD_EA3E4[*(unsigned __int16 *)(v34[41] + 58)];
			if (v6 <= x_DWORD_EA3E4[0] || v7 <= x_DWORD_EA3E4[0] || (v8 = *(x_DWORD *)(v6 + 144), v8 <= 0))
			{
				v35 = 1;
			}
			else
			{
				v9 = v8 * *(x_DWORD *)v32;
				v10 = v31;
				*(x_DWORD *)(v6 + 144) = v8 - v8 * *(x_DWORD *)v32 / 100;
				v11 = *(signed __int16 *)(v10 + 84) * *(signed __int16 *)(v10 + 84);
				v33 = v9 / 100;
				v29 = sub_7277A(v11 + *(signed __int16 *)(v31 + 86) * *(signed __int16 *)(v31 + 86));
				while (v33 > 0)
				{
					if (v33 <= 500)
						v30 = v33;
					else
						v30 = 500;
					v12 = v33 - v30;
					v26 = *(x_DWORD *)(v31 + 76);
					v27 = *(x_WORD *)(v31 + 80);
					v13 = 9377 * *(x_WORD *)(a1 + 20) + 9439;
					*(x_WORD *)(a1 + 20) = v13;
					v14 = v13 & 0x7FF;
					v33 = v12;
					sub_57FA0((x_WORD*)&v26, v13 & 0x7FF, 0, v29);
					v15 = sub_10C40((__int16 *)&v26);
					HIBYTE(v15) += 4;
					v27 = v15;
					v16 = sub_4A190((int)&v26, 10, 39);
					v17 = v16;
					if (v16)
					{
						*(x_WORD *)(v16 + 20) = 9377 * *(x_WORD *)(v16 + 20) + 9439;
						v18 = (v14 + *(x_WORD *)(v16 + 20) % 0x71u - 56) & 0x7FF;
						v19 = *(x_WORD *)(v17 + 20);
						*(x_WORD *)(v17 + 28) = v18;
						*(x_WORD *)(v17 + 20) = 9377 * v19 + 9439;
						*(x_WORD *)(v17 + 130) = *(x_WORD *)(v17 + 20) % 0x30u + 16;
						v20 = *(x_WORD *)(v17 + 130);
						v21 = *(x_WORD *)(v17 + 28);
						*(x_WORD *)(v17 + 154) = 0;
						*(x_WORD *)(v17 + 156) = 0;
						*(x_WORD *)(v17 + 44) = 128;
						sub_57FA0((x_WORD *)(v17 + 154), v21, 0, v20);
						*(x_DWORD *)(v17 + 144) = v30;
						if (v32[24] == 2)
							*(x_WORD *)(v17 + 148) = (signed int)((char *)v34 - (int)x_D41A0_BYTEARRAY_0 - 28302) / 168;
						else
							*(x_WORD *)(v17 + 148) = 0;
					}
				}
			}
			if (!v35)
				goto LABEL_23;
			v5 = *v28;
		}
		else
		{
			v5 = *(x_DWORD *)v32;
			v35 = 1;
		}
		v33 = v5;
	}
LABEL_23:
	if (v35)
	{
		v22 = v33;
		if (v33)
		{
			v34[36] += v33;
			*(x_DWORD *)(a1 + 144) -= v22;
		}
	}
	if (v34[36] < 0)
		v34[36] = 0;
	v23 = v34[35];
	if (v34[36] > v23)
		v34[36] = v23;
	if (*(x_DWORD *)(a1 + 144) < 0)
		*(x_DWORD *)(a1 + 144) = 0;
	v24 = *(x_DWORD *)(a1 + 140);
	if (*(x_DWORD *)(a1 + 144) > v24)
		*(x_DWORD *)(a1 + 144) = v24;
	*(x_BYTE *)(*(x_DWORD *)(a1 + 164) + 406) = 4;
	*(x_DWORD *)(*(x_DWORD *)(a1 + 164) + 397) = 16;
	*(x_WORD *)(*(x_DWORD *)(a1 + 164) + 588) = 64;
LABEL_35:
	sub_5EF70(a1);
	result = a1;
	*(x_WORD *)(a1 + 116) = 0;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000613D0) --------------------------------------------------------
__int16 sub_613D0(int a1)
{
	int i; // eax
	int v2; // ebx
	__int16 v3; // dx
	signed int v4; // esi
	int v5; // edx
	int v6; // ebx
	//int v7; // ebx
	signed int v8; // edx
	int v9; // ebx
	int v10; // ST14_4
	__int16 v11; // ax
	char *v13; // [esp+0h] [ebp-24h]
	int v14; // [esp+4h] [ebp-20h]
	int v15; // [esp+Ch] [ebp-18h]
	char v16; // [esp+10h] [ebp-14h]
	int v17; // [esp+14h] [ebp-10h]
	int v18; // [esp+18h] [ebp-Ch]
	unsigned __int8 v19; // [esp+1Ch] [ebp-8h]
	unsigned __int8 v20; // [esp+20h] [ebp-4h]

	for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v2 + 52))
	{
		v2 = x_DWORD_EA3E4[i];
		if (v2 == x_DWORD_EA3E4[0])
			break;
		sub_57F20(x_DWORD_EA3E4[i]);
	}
	v3 = *(x_WORD *)(a1 + 26);
	*(x_WORD *)(a1 + 52) = 0;
	if (v3 && *(x_DWORD *)(a1 + 16))
	{
		LOWORD(i) = v3;
		v4 = *(x_DWORD *)(a1 + 16);
		v5 = x_DWORD_EA3E4[v3];
		while (v4 > 0)
		{
			LOWORD(i) = *(char *)(v4 + *(x_DWORD *)(v5 + 164) + 599);
			v16 = *(x_BYTE *)(v4 + *(x_DWORD *)(v5 + 164) + 599);
			if (*(x_BYTE *)(v4 + *(x_DWORD *)(v5 + 164) + 599))
				break;
			--v4;
		}
		if (v4)
		{
			v6 = 6 * v4;
			/*i = x_WORD_180660_VGA_type_resolution == 1 ? (signed int)*(unsigned __int8 *)(v6 + **filearray_2aa18c[24] + 4) >> 1 : *(unsigned __int8 *)(v6 + **filearray_2aa18c[24] + 4);
			v7 = 6 * v4;
			v8 = x_WORD_180660_VGA_type_resolution == 1 ? (signed int)*(unsigned __int8 *)(v7 + **filearray_2aa18c[24] + 5) >> 1 : *(unsigned __int8 *)(v7 + **filearray_2aa18c[24] + 5);*/ // fix it
			v8 = 0;  //fix it
			v20 = ((unsigned __int16)(*(x_WORD *)(a1 + 76) + 128) >> 8) - (i >> 1);
			v19 = ((unsigned __int16)(*(x_WORD *)(a1 + 78) + 128) >> 8) - (v8 >> 1);
			v15 = 0;
			v14 = (unsigned __int8)x_BYTE_DB038[2 * v4];
			v18 = a1;
			v13 = (char *)&unk_DB04A + 2 * (unsigned __int8)x_BYTE_DB039[2 * v4];
			LOWORD(i) = 0;
			if (v14 > 0)
			{
				do
				{
					x_WORD_EB398 = (v20 + *v13) << 8;
					x_WORD_EB39A = (v19 + v13[1]) << 8;
					i = sub_4A190((int)&x_WORD_EB398, 10, 79);
					v9 = i;
					v17 = i;
					if (!i)
						break;
					v10 = (int)x_D41A0_BYTEARRAY_0 + 28302;
					*(x_WORD *)(i + 50) = (v18 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
					*(x_WORD *)(v18 + 52) = (i - v10) / 168;
					*(x_WORD *)(i + 52) = 0;
					*(x_WORD *)(i + 26) = *(x_WORD *)(a1 + 26);
					*(x_BYTE *)(i + 67) = v16;
					*(x_WORD *)(i + 74) = v4;
					v11 = sub_10C40((__int16 *)(i + 76));
					*(x_WORD *)(v9 + 80) = v11;
					*(x_WORD *)(v9 + 80) = v4 <= 1 ? v11 + 384 : v11 + 224;
					v18 = v17;
					++v15;
					v13 += 2;
					LOWORD(i) = v15;
				} while (v15 < v14);
			}
		}
	}
	return i;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3BC: using guessed type int **filearray_2aa18c[24];
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39A: using guessed type __int16 x_WORD_EB39A;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00061620) --------------------------------------------------------
char sub_61620(int a1, int a2)
{
	void(/*__noreturn*/ *v2)(); // edi
	unsigned int v3; // esi
	unsigned int i; // ebx
	signed int v5; // eax
	char v7; // [esp+0h] [ebp-4h]

	v2 = (void(*)())sub_10000;
	v3 = 0;
	v7 = 0;
	for (i = x_D41A0_BYTEARRAY_4[0x9677]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
	{
		if (!*(x_BYTE *)(i + 64) && i != a1)
		{
			v5 = sub_61810(a1, i);
			if (v5)
			{
				if (v5 < (signed int)v2)
				{
					v2 = (void(/*__noreturn*/ *)())v5;
					v3 = i;
				}
			}
		}
	}
	if (v3 == a2)
		v7 = 1;
	return v7;
}
// 10000: using guessed type void /*__noreturn*/ sub_10000();
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000616D0) --------------------------------------------------------
signed int sub_616D0(signed int a1)
{
	signed int result; // eax

	result = 0;
	if (a1 >= 0 && a1 <= 7)
	{
		if (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10)
		{
			switch (*(x_BYTE *)(2124 * a1 + x_D41A0_BYTEARRAY_0 + 12676))
			{
			case 0:
			LABEL_5:
				result = 0;
				break;
			case 1:
			LABEL_7:
				result = 4;
				break;
			case 2:
			LABEL_6:
				result = 1;
				break;
			case 3:
			LABEL_9:
				result = 2;
				break;
			case 4:
			LABEL_10:
				result = 5;
				break;
			case 5:
			case 7:
			LABEL_13:
				result = 7;
				break;
			case 6:
			LABEL_8:
				result = 3;
				break;
			default:
				return result;
			}
		}
		else
		{
			switch (a1)
			{
			case 0:
				goto LABEL_5;
			case 1:
				goto LABEL_6;
			case 2:
				goto LABEL_7;
			case 3:
				goto LABEL_8;
			case 4:
				goto LABEL_9;
			case 5:
				goto LABEL_10;
			case 6:
				goto LABEL_13;
			case 7:
				result = 6;
				break;
			default:
				return result;
			}
		}
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (00061790) --------------------------------------------------------
signed int sub_61790(signed int a1)
{
	signed int result; // eax

	result = a1;
	if (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10)
	{
		switch (*(x_BYTE *)(2124 * a1 + x_D41A0_BYTEARRAY_0 + 12676))
		{
		case 0:
			result = 0;
			break;
		case 1:
			result = 2;
			break;
		case 2:
			result = 1;
			break;
		case 3:
			result = 4;
			break;
		case 4:
			result = 5;
			break;
		case 5:
			result = 6;
			break;
		case 6:
			result = 3;
			break;
		case 7:
			result = 7;
			break;
		default:
			return result;
		}
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (00061810) --------------------------------------------------------
signed int sub_61810(int a1, int a2)
{
	signed int v2; // ebx
	signed int v3; // esi
	__int16 v4; // ax

	v2 = 0;
	v3 = sub_583F0((x_WORD *)(a1 + 76), (x_WORD *)(a2 + 76));
	if (v3 < 5376)
	{
		v4 = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(a2 + 76));
		if ((unsigned __int16)sub_582B0(*(x_WORD *)(a1 + 28), v4) < 0x100u)
			v2 = v3;
	}
	return v2;
}

//----- (00061880) --------------------------------------------------------
char *sub_61880(int a1, int a2, __int16 a3, __int16 a4, int a5, int a6, __int16 a7, int a8)
{
	char *result; // eax

	if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8592) == 1)
		result = sub_627F0(a1, a2, a3, a4, a5, a6, a7, a8);
	else
		result = sub_61A00(a1, a2, a3, a4, a5, a6, a7, a8);
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00061A00) --------------------------------------------------------
char *sub_61A00(int a1, int a2, __int16 a3, __int16 a4, int a5, int a6, __int16 a7, int a8)
{
	int v8; // edx
	int v9; // esi
	int v10; // ebx
	unsigned __int8 v11; // al
	__int64 v12; // rtt
	int v13; // ebx
	int v14; // edx
	int v15; // ebx
	__int16 v16; // dx
	int v17; // ebx
	int v18; // eax
	int v19; // edx
	int v20; // esi
	int v21; // edi
	int v22; // edx
	int v23; // eax
	int v24; // edx
	int v25; // ebx
	int v26; // ST48_4
	int v27; // edx
	int i; // eax
	int v29; // ebx
	unsigned int j; // ebx
	unsigned __int8 v31; // al
	unsigned __int8 v32; // ah
	unsigned __int8 v33; // ah
	unsigned __int8 v34; // ah
	unsigned __int16 v35; // si
	int v36; // eax
	char v37; // al
	char v38; // al
	int v39; // eax
	unsigned __int16 v40; // si
	int v41; // eax
	unsigned __int8 v42; // ah
	char v43; // al
	unsigned __int8 v44; // ah
	int v45; // eax
	unsigned __int8 v46; // al
	char v47; // al
	char v48; // dl
	char v49; // al
	unsigned __int8 v50; // ah
	__int16 v51; // ax
	int v52; // edx
	int v53; // ecx
	int v54; // esi
	int v55; // edi
	char *v56; // edx
	int v57; // ecx
	char *v58; // edx
	int v59; // eax
	int v60; // ebx
	int v61; // edx
	int v62; // eax
	int v63; // esi
	int v64; // edi
	unsigned __int8 *v65; // ST14_4
	unsigned __int8 v66; // al
	int v67; // esi
	x_BYTE *v68; // ebx
	char *result; // eax
	x_BYTE *v70; // edx
	int v71; // ecx
	int v72; // [esp+0h] [ebp-60h]
	int v73; // [esp+8h] [ebp-58h]
	int v74; // [esp+Ch] [ebp-54h]
	signed int v75; // [esp+10h] [ebp-50h]
	int v76; // [esp+14h] [ebp-4Ch]
	x_BYTE *v77; // [esp+18h] [ebp-48h]
	signed int v78; // [esp+1Ch] [ebp-44h]
	int v79; // [esp+20h] [ebp-40h]
	int v80; // [esp+24h] [ebp-3Ch]
	x_BYTE *v81; // [esp+28h] [ebp-38h]
	int v82; // [esp+2Ch] [ebp-34h]
	int v83; // [esp+30h] [ebp-30h]
	int v84; // [esp+34h] [ebp-2Ch]
	int v85; // [esp+38h] [ebp-28h]
	int v86; // [esp+3Ch] [ebp-24h]
	unsigned __int16 v87; // [esp+40h] [ebp-20h]
	unsigned __int16 v88; // [esp+44h] [ebp-1Ch]
	char v89; // [esp+48h] [ebp-18h]
	char v90; // [esp+4Ch] [ebp-14h]
	char v91; // [esp+50h] [ebp-10h]
	char v92; // [esp+54h] [ebp-Ch]
	unsigned __int8 v93; // [esp+58h] [ebp-8h]
	char v94; // [esp+5Ch] [ebp-4h]

	v8 = a1;
	v9 = a2;
	v10 = a8;
	v11 = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308);
	v83 = 0;
	if (v11 < 1u)
	{
		if (!v11)
		{
			v92 = (unsigned __int8)*xadataclrd0dat.var28_begin_buffer;
			v93 = (unsigned __int8)*xadataclrd0dat.var28_begin_buffer;
			v91 = -24;
			v90 = 28;
		}
	}
	else if (v11 <= 1u)
	{
		v92 = x_BYTE_E98FF;
		v93 = x_BYTE_E98FF;
		v91 = -24;
		v90 = -124;
	}
	else if (v11 == 2)
	{
		v92 = x_BYTE_E98FF;
		v93 = x_BYTE_E98FF;
		v91 = 28;
		v90 = x_BYTE_E89F0;
	}
	if (x_WORD_180660_VGA_type_resolution & 1)
	{
		v8 = a1 >> 1;
		v9 = a2 >> 1;
		v10 = 2 * a8;
		a5 >>= 1;
		a6 >>= 1;
	}
	v84 = v9 * x_DWORD_18062C_resolution_x + (int)x_DWORD_180628b_screen_buffer + v8;
	LODWORD(v12) = (uint32)sub_10000;
	HIDWORD(v12) = (signed int)sub_10000 >> 31;
	v13 = v12 / v10;
	v82 = a5 / 2;
	v14 = v13 * x_DWORD_DB750[a7 & 0x7FF];
	v76 = a6 / 2;
	v15 = (x_DWORD)off_DBF50[a7 & 0x7FF] * v13;
	v86 = -v14 >> 16;
	sub_6FC50(x_BYTE_D419D);
	v73 = v15 >> 16;
	v80 = x_DWORD_EA3E4[*(unsigned __int16 *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240)];
	v16 = *(x_WORD *)(*(x_DWORD *)(v80 + 164) + 843);
	if (v16)
		v83 = *(signed __int16 *)(x_DWORD_EA3E4[v16] + 46);
	v17 = *(x_DWORD *)(v80 + 164);
	if (*(x_WORD *)(v17 + 58))
	{
		v18 = (signed __int16)(*(x_WORD *)(v80 + 76) - a3);
		v19 = (signed __int16)(*(x_WORD *)(v80 + 78) - a4);
		v20 = v82 + ((v18 * v73 - v19 * v86) >> 16);
		v21 = ((v73 * v19 + v86 * v18) >> 16) + v76;
		v22 = x_DWORD_EA3E4[*(unsigned __int16 *)(v17 + 58)];
		v23 = (signed __int16)(*(x_WORD *)(v22 + 76) - a3);
		v24 = (signed __int16)(*(x_WORD *)(v22 + 78) - a4);
		v25 = v82 + ((v23 * v73 - v24 * v86) >> 16);
		v26 = ((v73 * v24 + v86 * v23) >> 16) + v76;
		v27 = v82 + ((v23 * v73 - v24 * v86) >> 16) - v20;
		v75 = sub_7277A(v27 * v27 + (v26 - v21) * (v26 - v21));
		v72 = (unsigned __int16)sub_72633(v25 - v20, v26 - v21);
		for (i = *(x_DWORD *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11248) & 3;
			;
			*(x_BYTE *)(v84 + v20 + (i * x_DWORD_DB750[v72] >> 16) + x_DWORD_18062C_resolution_x * v85) = x_BYTE_FAEE0[256
			* *(unsigned __int8 *)(v84 + v20 + (i * x_DWORD_DB750[v72] >> 16) + x_DWORD_18062C_resolution_x * v85)
			+ (unsigned __int8)x_BYTE_E98FF])
		{
			i += 4;
			if (i > v75)
				break;
			v29 = v20 + (i * x_DWORD_DB750[v72] >> 16);
			v85 = v21 + (-i * (signed int)off_DBF50[v72] >> 16);
			if (v29 < 0 || v29 >= a5 || v85 < 0 || v85 >= a6 || v29 < x_WORD_F4962[2 * v85] || v29 >= x_WORD_F4960[2 * v85])
				break;
		}
	}
	for (j = (int)x_D41A0_BYTEARRAY_0 + 28470; j < (int)x_D41A0_BYTEARRAY_0 + 196302; j += 168)
	{
		v31 = 0;
		v89 = 0;
		v78 = 1;
		v32 = *(x_BYTE *)(j + 63) - 2;
		v88 = 0;
		if (v32 <= 0xDu)
		{
			switch (v32)
			{
			case 0u:
				v42 = *(x_BYTE *)(j + 64);
				if (v42 > 3u)
				{
				LABEL_78:
					v38 = v90;
					goto LABEL_121;
				}
				switch (v42)
				{
				case 0u:
					if (*(x_BYTE *)(j + 69) != 2)
						goto LABEL_78;
					v94 = v90;
					v31 = 0;
					break;
				case 1u:
					v31 = 1;
					if (x_D41A0_BYTEARRAY_4[0x7C])
						v94 = x_BYTE_E8988;
					else
						v89 = 1;
					v88 = 27;
					break;
				case 2u:
					if (x_D41A0_BYTEARRAY_4[0x7B])
						v43 = x_BYTE_E9188;
					else
						v43 = v90;
					v94 = v43;
					v31 = 1;
					v88 = 22;
					break;
				case 3u:
					goto LABEL_123;
				}
				break;
			case 1u:
				v50 = *(x_BYTE *)(j + 64);
				if (v50 >= 2u)
				{
					if (v50 <= 2u)
					{
						LOBYTE(v51) = *(x_WORD *)(j + 26) != *(x_WORD *)(v80 + 26);
						HIBYTE(v51) = 0;
						v88 = v51 + 24;
						v31 = sub_616D0(*(signed __int16 *)(*(x_DWORD *)(x_DWORD_EA3E4[*(signed __int16 *)(j + 26)] + 164) + 56))
							+ 58;
					}
					else if (v50 == 3)
					{
						if (*(x_WORD *)(j + 26) == *(x_WORD *)(v80 + 26) || v83)
							v31 = sub_616D0(*(signed __int16 *)(*(x_DWORD *)(x_DWORD_EA3E4[*(signed __int16 *)(j + 26)] + 164) + 56))
							+ 66;
						if (*(x_WORD *)(j + 26) == *(x_WORD *)(v80 + 26))
						{
							v88 = 23;
						}
						else if (v83)
						{
							v88 = 26;
						}
					}
				}
				break;
			case 2u:
			case 4u:
			case 5u:
			case 6u:
			case 0xBu:
				break;
			case 3u:
				v44 = *(x_BYTE *)(j + 69);
				if (v44 >= 0xB4u && (v44 <= 0xB4u || v44 >= 0xE8u && v44 <= 0xEAu) || *(x_BYTE *)(j + 12) & 1)
					break;
				v45 = *(signed __int16 *)(j + 26);
				if (v45 != (signed int)(j - (x_D41A0_BYTEARRAY_0[28302])) / 168)
				{
					v47 = x_BYTE_E88E1[3 * sub_61790(*(signed __int16 *)(*(x_DWORD *)(x_DWORD_EA3E4[v45] + 164) + 56))];
					goto LABEL_102;
				}
				v46 = *(x_BYTE *)(j + 64);
				if (v46 >= 0xCu)
				{
					if (v46 <= 0xEu)
					{
						v47 = x_BYTE_E890F;
					LABEL_102:
						v94 = v47;
						goto LABEL_122;
					}
					if (v46 == 22)
					{
						if (*(unsigned __int16 *)(j + 148) != *(signed __int16 *)(v80 + 26))
							v88 = 18;
						v47 = v92;
						goto LABEL_102;
					}
				}
				v48 = *(x_BYTE *)(j + 73);
				v94 = v92;
				v49 = 1;
				if ((v48 == 14 || v48 == 13) && *(unsigned __int16 *)(j + 40) == *(signed __int16 *)(v80 + 26))
					v49 = 0;
				if (v49)
					v88 = 19;
				goto LABEL_122;
			case 7u:
				goto LABEL_56;
			case 8u:
				v34 = *(x_BYTE *)(j + 64);
				if (v34 < 0x27u)
				{
					if (v34 >= 0x12u)
					{
						if (v34 <= 0x12u)
							break;
						if (v34 == 34)
							v78 = 2;
					}
					goto LABEL_56;
				}
				if (v34 <= 0x27u)
					goto LABEL_173;
				if (v34 < 0x39u)
				{
					if (v34 != 45)
						goto LABEL_56;
					v40 = *(x_WORD *)(j + 148);
					if (v40)
					{
						v41 = x_DWORD_EA3E4[v40];
						if (*(x_BYTE *)(v41 + 63) == 3)
						{
							if (x_D41A0_BYTEARRAY_4[0x7C])
								v38 = x_BYTE_E88E0[3 * sub_61790(*(signed __int16 *)(*(x_DWORD *)(v41 + 164) + 56))];
							else
								v38 = x_BYTE_E88E1[3 * sub_61790(*(signed __int16 *)(*(x_DWORD *)(v41 + 164) + 56))];
							goto LABEL_121;
						}
					}
					if (!(x_BYTE_D93C2[4 * *(char *)(j + 70)] & 8))
						v88 = 21;
				LABEL_56:
					v39 = x_DWORD_EA3E4[*(signed __int16 *)(j + 26)];
					if (*(x_BYTE *)(v39 + 63) == 3)
						v38 = x_BYTE_E88E0[3 * sub_61790(*(signed __int16 *)(*(x_DWORD *)(v39 + 164) + 56))];
					else
						v38 = x_BYTE_E980F;
				LABEL_121:
					v94 = v38;
					goto LABEL_122;
				}
				if (v34 <= 0x39u)
				{
				LABEL_173:
					v35 = *(x_WORD *)(j + 148);
					if (v35 && (v36 = x_DWORD_EA3E4[v35], *(x_BYTE *)(v36 + 63) == 3))
					{
						if (x_D41A0_BYTEARRAY_4[0x7C])
							v37 = x_BYTE_E88E0[3 * sub_61790(*(signed __int16 *)(*(x_DWORD *)(v36 + 164) + 56))];
						else
							v37 = x_BYTE_E88E1[3 * sub_61790(*(signed __int16 *)(*(x_DWORD *)(v36 + 164) + 56))];
						v94 = v37;
					}
					else
					{
						v94 = v91;
						v88 = 18;
					}
				LABEL_122:
					v31 = 1;
				}
				else
				{
					if (v34 < 0x4Eu)
						goto LABEL_56;
					if (v34 <= 0x4Eu)
					{
						if (*(x_WORD *)(j + 50) != *(x_WORD *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240))
							break;
						v38 = x_BYTE_E88E0[3 * sub_61790(*(signed __int16 *)(*(x_DWORD *)(v80 + 164) + 56))
							+ x_D41A0_BYTEARRAY_4[0x7C]];
						goto LABEL_121;
					}
					if (v34 < 0x56u || v34 > 0x57u)
						goto LABEL_56;
				}
				break;
			case 9u:
				v33 = *(x_BYTE *)(j + 64);
				if (v33 <= 0x2Cu)
				{
					switch (v33)
					{
					case 0u:
					case 1u:
					case 2u:
					case 3u:
					case 4u:
					case 5u:
					case 6u:
					case 7u:
					case 8u:
					case 9u:
					case 0xAu:
					case 0xBu:
					case 0xDu:
					case 0xEu:
					case 0xFu:
					case 0x10u:
					case 0x11u:
					case 0x12u:
					case 0x13u:
					case 0x14u:
					case 0x15u:
					case 0x16u:
					case 0x17u:
					case 0x18u:
					case 0x19u:
					case 0x1Au:
					case 0x1Bu:
					case 0x1Cu:
					case 0x1Du:
					case 0x1Eu:
					case 0x20u:
					case 0x21u:
					case 0x22u:
					case 0x23u:
					case 0x24u:
					case 0x25u:
					case 0x26u:
					case 0x27u:
					case 0x28u:
					case 0x29u:
					case 0x2Au:
					case 0x2Bu:
					case 0x2Cu:
						goto LABEL_123;
					case 0xCu:
						v31 = 83;
						v88 = 83;
						break;
					case 0x1Fu:
						v31 = 84;
						v88 = 83;
						break;
					}
				}
				break;
			case 0xAu:
			case 0xDu:
				if (*(x_BYTE *)(j + 12) & 1)
					break;
				v38 = x_BYTE_E9800;
				v88 = 20;
				goto LABEL_121;
			case 0xCu:
				if (*(x_BYTE *)(j + 64) != 5)
					break;
				if (x_D41A0_BYTEARRAY_4[0x7C])
					v38 = x_BYTE_E9800;
				else
					v38 = x_BYTE_E98FF;
				goto LABEL_121;
			}
		}
	LABEL_123:
		if (v31)
		{
			v52 = (signed __int16)(*(x_WORD *)(j + 76) - a3);
			v53 = (signed __int16)(*(x_WORD *)(j + 78) - a4);
			v54 = v82 + ((v52 * v73 - v53 * v86) >> 16);
			if (v54 >= 0 && v54 < a5)
			{
				v55 = ((v73 * v53 + v86 * v52) >> 16) + v76;
				if (v55 >= 0 && v55 < a6 && v54 >= x_WORD_F4962[2 * v55] && v54 < x_WORD_F4960[2 * v55])
				{
					v56 = (char *)(v54 + v84 + v55 * x_DWORD_18062C_resolution_x);
					if (!v89)
					{
						if (v31 <= 1u)
						{
							*v56 = v94;
							if (v78 > 1)
							{
								v57 = x_DWORD_18062C_resolution_x;
								v56[1] = v94;
								v58 = &v56[v57];
								*v58 = v94;
								v58[1] = v94;
							}
						}
						else if (x_WORD_180660_VGA_type_resolution == 1)
						{
							if (v31 < 0x42u || v31 >= 0x4Au)
							{
								if (v31 < 0x3Au || v31 >= 0x42u)
								{
									/*if ( v31 == 83 || v31 == 84 )
									  sub_2BB40_draw_bitmap(
										2 * v54 - *(unsigned __int8 *)(6 * v31 + **filearray_2aa18c[6] + 4) / 2,
										2 * v55 - *(unsigned __int8 *)(6 * v31 + **filearray_2aa18c[6] + 5) / 2,
										  (Bit8u**)(6 * v31 + **filearray_2aa18c[6]));*/ // fix it
								}
								else
								{
									//fix it sub_2BB40_draw_bitmap(2 * v54, 2 * v55 - *(unsigned __int8 *)(6 * v31 + **filearray_2aa18c[6] + 5), (Bit8u**)(6 * v31 + **filearray_2aa18c[6]));
								}
							}
							else
							{
								/*sub_2BB40_draw_bitmap(
								  2 * v54 - *(unsigned __int8 *)(6 * v31 + **filearray_2aa18c[6] + 4) / 2,
								  2 * v55 - *(unsigned __int8 *)(6 * v31 + **filearray_2aa18c[6] + 5),
									(Bit8u**)(6 * v31 + **filearray_2aa18c[6]));*/ // fix it
							}
						}
						else if (v31 >= 0x3Cu)
						{
							/*sub_2BB40_draw_bitmap(
							  v54 - *(unsigned __int8 *)(6 * v31 + **filearray_2aa18c[6] + 4) / 2,
							  v55 - *(unsigned __int8 *)(6 * v31 + **filearray_2aa18c[6] + 5),
								(Bit8u**)(6 * v31 + **filearray_2aa18c[6]));*/ // fix it
						}
						else
						{
							//fix it //sub_2BB40_draw_bitmap(v54, v55 - *(unsigned __int8 *)(6 * v31 + **filearray_2aa18c[6] + 5), (Bit8u**)(6 * v31 + **filearray_2aa18c[6]));
						}
					}
					if (v88)
						sub_885E0(j, (signed __int16)v54, (signed __int16)v55, v88);
				}
			}
		}
	}
	if (v83)
	{
		v87 = 0;
		v74 = x_DWORD_EA3E4[*(unsigned __int16 *)(x_D41A0_BYTEARRAY_0 + 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 11240)];
		while (v87 < *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 14))
		{
			if (v87 != x_D41A0_BYTEARRAY_4_struct.dwordindex_12)
			{
				v79 = 2124 * v87;
				v59 = *(unsigned __int16 *)(2124 * v87 + x_D41A0_BYTEARRAY_0 + 11240);
				v60 = x_DWORD_EA3E4[v59];
				if (*(x_DWORD *)(v60 + 8) >= 0)
				{
					if (sub_63570(v74, x_DWORD_EA3E4[v59]))
					{
						v61 = (signed __int16)(*(x_WORD *)(v60 + 76) - a3);
						v62 = (signed __int16)(*(x_WORD *)(v60 + 78) - a4);
						v63 = v82 + ((v61 * v73 - v62 * v86) >> 16);
						if (v63 >= 0 && v63 < a5)
						{
							v64 = v76 + ((v86 * v61 + v73 * v62) >> 16);
							if (v64 >= 0 && v64 < a6 && v63 >= x_WORD_F4962[2 * v64] && v63 < x_WORD_F4960[2 * v64])
							{
								v65 = (unsigned __int8 *)(v64 * x_DWORD_18062C_resolution_x + v63 + v84);
								v66 = x_BYTE_E88E0[3 * sub_61790(*(signed __int16 *)(*(x_DWORD *)(v60 + 164) + 56))];
								*v65 = v66;
								if (x_WORD_180660_VGA_type_resolution == 1)
									sub_2BC10_draw_text((Bit8u*)(v79 + x_D41A0_BYTEARRAY_0 + 11230 + 927), 2 * v63 + 4, 2 * v64, v66);
								else
									sub_2BC10_draw_text((Bit8u*)(v79 + x_D41A0_BYTEARRAY_0 + 11230 + 927), v63 + 4, v64, v66);
							}
						}
					}
				}
			}
			++v87;
		}
	}
	v67 = a5 / 12;
	v68 = (x_BYTE *)(x_DWORD_18062C_resolution_x * (a6 / 2) + a5 / 2 + v84 - 1);
	result = &x_BYTE_FAEE0[256 * v93];
	v70 = (x_BYTE *)(x_DWORD_18062C_resolution_x * (a6 / 2) + a5 / 2 + v84 - 1);
	v77 = (x_BYTE *)(x_DWORD_18062C_resolution_x * (a6 / 2) + a5 / 2 + v84 - 1);
	v81 = (x_BYTE *)(x_DWORD_18062C_resolution_x * (a6 / 2) + a5 / 2 + v84 - 1);
	for (*v68 = result[(unsigned __int8)*v68]; v67; *v68 = x_BYTE_FAEE0[256 * v93 + v71])
	{
		v81 -= x_DWORD_18062C_resolution_x;
		v70 += x_DWORD_18062C_resolution_x;
		++v77;
		*v81 = x_BYTE_FAEE0[256 * v93 + (unsigned __int8)*v81];
		*v77 = x_BYTE_FAEE0[256 * v93 + (unsigned __int8)*v77];
		*v70 = x_BYTE_FAEE0[256 * v93 + (unsigned __int8)*v70];
		v71 = (unsigned __int8)*(v68-- - 1);
		--v67;
	}
	return result;
}
// 10000: using guessed type void /*__noreturn*/ sub_10000();
// D419D: using guessed type char x_BYTE_D419D;
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// DBF50: using guessed type void (/*__noreturn*/ *off_DBF50[2])();
// E890F: using guessed type char x_BYTE_E890F;
// E8988: using guessed type char x_BYTE_E8988;
// E89F0: using guessed type char x_BYTE_E89F0;
// E9188: using guessed type char x_BYTE_E9188;
// E9800: using guessed type char x_BYTE_E9800;
// E980F: using guessed type char x_BYTE_E980F;
// E98FF: using guessed type char x_BYTE_E98FF;
// EA3DC: using guessed type int **filearray_2aa18c[6];
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// F4960: using guessed type __int16 x_WORD_F4960[];
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 18062C: using guessed type int x_DWORD_18062C_resolution_x;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (000627F0) --------------------------------------------------------
char *sub_627F0(int a1, int a2, __int16 a3, __int16 a4, int a5, int a6, __int16 a7, int a8)
{
	int v8; // edx
	int v9; // esi
	int v10; // ebx
	unsigned __int8 v11; // al
	char v12; // al
	__int64 v13; // rtt
	int v14; // ebx
	int v15; // edx
	int v16; // ebx
	__int16 v17; // dx
	int v18; // ebx
	int v19; // edx
	int v20; // eax
	int v21; // esi
	int v22; // edx
	int v23; // eax
	int v24; // edi
	int v25; // edx
	int v26; // eax
	int v27; // ebx
	int v28; // ST48_4
	int v29; // edx
	int v30; // eax
	int v31; // ebx
	char *v32; // edx
	char *v33; // ST44_4
	char v34; // bl
	unsigned int i; // ebx
	unsigned __int8 v36; // al
	unsigned __int8 v37; // ah
	unsigned __int8 v38; // ah
	unsigned __int8 v39; // ah
	unsigned __int16 v40; // si
	int v41; // eax
	char v42; // al
	char v43; // al
	int v44; // eax
	unsigned __int16 v45; // si
	int v46; // eax
	bool v47; // zf
	unsigned __int8 v48; // ah
	unsigned __int8 v49; // ah
	int v50; // eax
	unsigned __int8 v51; // al
	char v52; // al
	char v53; // al
	char v54; // ah
	unsigned __int8 v55; // ah
	__int16 v56; // ax
	int v57; // edx
	int v58; // ecx
	int v59; // esi
	int v60; // edi
	char *v61; // ecx
	char *v62; // edx
	char *v63; // edx
	char *v64; // ecx
	int v65; // eax
	int v66; // ebx
	int v67; // edx
	int v68; // eax
	int v69; // esi
	int v70; // edi
	unsigned __int8 *v71; // ST2C_4
	unsigned __int8 *v72; // ST28_4
	unsigned __int8 v73; // al
	int v74; // eax
	char *v75; // esi
	char *v76; // ebx
	char *result; // eax
	char *v78; // edx
	char v79; // cl
	char v80; // cl
	char v81; // cl
	char v82; // cl
	char *v83; // [esp+0h] [ebp-1Eh]
	char *v84; // [esp+4h] [ebp-1Ah]
	int v85; // [esp+8h] [ebp-16h]
	int v86; // [esp+Ch] [ebp-12h]
	int v87; // [esp+10h] [ebp-Eh]
	char *v88; // [esp+14h] [ebp-Ah]
	int v89; // [esp+20h] [ebp+2h]
	int v90; // [esp+24h] [ebp+6h]
	signed int v91; // [esp+28h] [ebp+Ah]
	signed int v92; // [esp+2Ch] [ebp+Eh]
	int v93; // [esp+30h] [ebp+12h]
	int v94; // [esp+38h] [ebp+1Ah]
	char *v95; // [esp+3Ch] [ebp+1Eh]
	int v96; // [esp+40h] [ebp+22h]
	int v97; // [esp+44h] [ebp+26h]
	int v98; // [esp+48h] [ebp+2Ah]
	int v99; // [esp+4Ch] [ebp+2Eh]
	int v100; // [esp+50h] [ebp+32h]
	char *v101; // [esp+54h] [ebp+36h]
	int v102; // [esp+58h] [ebp+3Ah]
	unsigned __int16 j; // [esp+5Ch] [ebp+3Eh]
	unsigned __int16 v104; // [esp+60h] [ebp+42h]
	char v105; // [esp+68h] [ebp+4Ah]
	unsigned __int8 v106; // [esp+6Ch] [ebp+4Eh]
	char v107; // [esp+70h] [ebp+52h]
	char v108; // [esp+74h] [ebp+56h]
	char v109; // [esp+78h] [ebp+5Ah]
	char v110; // [esp+7Ch] [ebp+5Eh]

	v8 = a1;
	v9 = a2;
	v10 = a8;
	v11 = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308);
	v93 = 0;
	if (v11 < 1u)
	{
		if (!v11)
		{
			v109 = (unsigned __int8)*xadataclrd0dat.var28_begin_buffer;
			v106 = (unsigned __int8)*xadataclrd0dat.var28_begin_buffer;
			v108 = 28;
			v107 = -24;
		}
		goto LABEL_10;
	}
	if (v11 <= 1u)
	{
		v109 = x_BYTE_E98FF;
		v106 = x_BYTE_E98FF;
		v12 = -124;
		v107 = -24;
	}
	else
	{
		if (v11 != 2)
			goto LABEL_10;
		v109 = x_BYTE_E98FF;
		v106 = x_BYTE_E98FF;
		v107 = 28;
		v12 = x_BYTE_E89F0;
	}
	v108 = v12;
LABEL_10:
	if (x_WORD_180660_VGA_type_resolution & 1)
	{
		v8 = a1 >> 1;
		v9 = a2 >> 1;
		v10 = 2 * a8;
		a5 >>= 1;
		a6 >>= 1;
	}
	v99 = v9 * x_DWORD_18062C_resolution_x + (int)x_DWORD_180628b_screen_buffer + v8;
	v100 = (int)(v9 * x_DWORD_18062C_resolution_x + x_DWORD_E9C3C + v8);
	LODWORD(v13) = (uint32)sub_10000;
	HIDWORD(v13) = (signed int)sub_10000 >> 31;
	v14 = v13 / v10;
	v98 = a5 / 2;
	v15 = v14 * x_DWORD_DB750[a7 & 0x7FF];
	v16 = (x_DWORD)off_DBF50[a7 & 0x7FF] * v14;
	v85 = a6 / 2;
	v86 = -v15 >> 16;
	sub_6FC50(x_BYTE_D419D);
	v87 = v16 >> 16;
	v102 = x_DWORD_EA3E4[*(unsigned __int16 *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240)];
	v17 = *(x_WORD *)(*(x_DWORD *)(v102 + 164) + 843);
	if (v17)
		v93 = *(signed __int16 *)(x_DWORD_EA3E4[v17] + 46);
	v18 = *(x_DWORD *)(v102 + 164);
	if (*(x_WORD *)(v18 + 58))
	{
		v19 = (signed __int16)(*(x_WORD *)(v102 + 76) - a3);
		v20 = (signed __int16)(*(x_WORD *)(v102 + 78) - a4);
		v21 = v98 + ((v19 * v87 - v20 * v86) >> 16);
		v22 = v87 * v20 + v86 * v19;
		v23 = x_DWORD_EA3E4[*(unsigned __int16 *)(v18 + 58)];
		v24 = (v22 >> 16) + v85;
		v25 = (signed __int16)(*(x_WORD *)(v23 + 76) - a3);
		v26 = (signed __int16)(*(x_WORD *)(v23 + 78) - a4);
		v27 = v98 + ((v25 * v87 - v26 * v86) >> 16);
		v28 = ((v86 * v25 + v87 * v26) >> 16) + v85;
		v29 = v98 + ((v25 * v87 - v26 * v86) >> 16) - v21;
		v91 = sub_7277A(v29 * v29 + (v28 - v24) * (v28 - v24));
		v89 = (unsigned __int16)sub_72633(v27 - v21, v28 - v24);
		v30 = *(x_DWORD *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11248) & 3;
		while (1)
		{
			v30 += 4;
			if (v30 > v91)
				break;
			v31 = v21 + (v30 * x_DWORD_DB750[v89] >> 16);
			v94 = v24 + (-v30 * (signed int)off_DBF50[v89] >> 16);
			if (v31 < 0 || v31 >= a5 || v94 < 0 || v94 >= a6 || v31 < x_WORD_F4962[2 * v94] || v31 >= x_WORD_F4960[2 * v94])
				break;
			v32 = (char *)(x_DWORD_18062C_resolution_x * v94 + v31 + v99);
			v33 = (char *)(v100 + v31 + x_DWORD_18062C_resolution_x * v94);
			v34 = x_BYTE_FAEE0[256 * (unsigned __int8)*v32 + (unsigned __int8)x_BYTE_E98FF];
			*v33 = v34;
			*v32 = v34;
		}
	}
	for (i = (int)x_D41A0_BYTEARRAY_0 + 28470; i < (int)x_D41A0_BYTEARRAY_0 + 196302; i += 168)
	{
		v36 = 0;
		v105 = 0;
		v92 = 1;
		v37 = *(x_BYTE *)(i + 63) - 2;
		v104 = 0;
		if (v37 <= 0xDu)
		{
			switch (v37)
			{
			case 0u:
				v48 = *(x_BYTE *)(i + 64);
				if (v48 > 3u)
				{
				LABEL_74:
					v110 = v108;
					goto LABEL_118;
				}
				switch (v48)
				{
				case 0u:
					if (*(x_BYTE *)(i + 69) != 2)
						goto LABEL_74;
					v110 = v108;
					v36 = 0;
					break;
				case 1u:
					v36 = 1;
					if (x_D41A0_BYTEARRAY_4[0x7B])
						v110 = x_BYTE_E8988;
					else
						v105 = 1;
					v104 = 27;
					break;
				case 2u:
					v110 = v108;
					v104 = 22;
					goto LABEL_118;
				case 3u:
					goto LABEL_119;
				}
				break;
			case 1u:
				v55 = *(x_BYTE *)(i + 64);
				if (v55 >= 2u)
				{
					if (v55 <= 2u)
					{
						LOBYTE(v56) = *(x_WORD *)(i + 26) != *(x_WORD *)(v102 + 26);
						HIBYTE(v56) = 0;
						v104 = v56 + 24;
						v36 = *(x_BYTE *)(*(x_DWORD *)(x_DWORD_EA3E4[*(signed __int16 *)(i + 26)] + 164) + 56) + 58;
					}
					else if (v55 == 3)
					{
						if (*(x_WORD *)(i + 26) == *(x_WORD *)(v102 + 26) || v93)
							v36 = *(x_BYTE *)(*(x_DWORD *)(x_DWORD_EA3E4[*(signed __int16 *)(i + 26)] + 164) + 56) + 66;
						if (*(x_WORD *)(i + 26) == *(x_WORD *)(v102 + 26))
						{
							v104 = 23;
						}
						else if (v93)
						{
							v104 = 26;
						}
					}
				}
				break;
			case 2u:
			case 4u:
			case 5u:
			case 6u:
			case 0xBu:
				break;
			case 3u:
				v49 = *(x_BYTE *)(i + 69);
				if (v49 >= 0xB4u && (v49 <= 0xB4u || v49 >= 0xE8u && v49 <= 0xEAu) || *(x_BYTE *)(i + 12) & 1)
					break;
				v50 = *(signed __int16 *)(i + 26);
				if (v50 != (signed int)(i - (x_D41A0_BYTEARRAY_0[28302])) / 168)
				{
					v52 = x_BYTE_E88E1[3 * sub_61790(*(signed __int16 *)(*(x_DWORD *)(x_DWORD_EA3E4[v50] + 164) + 56))];
					goto LABEL_98;
				}
				v51 = *(x_BYTE *)(i + 64);
				if (v51 >= 0xCu)
				{
					if (v51 <= 0xEu)
					{
						v52 = x_BYTE_E890F;
					LABEL_98:
						v110 = v52;
						goto LABEL_118;
					}
					if (v51 == 22)
					{
						if (*(unsigned __int16 *)(i + 148) != *(signed __int16 *)(v102 + 26))
							v104 = 18;
						v52 = v109;
						goto LABEL_98;
					}
				}
				v110 = v109;
				v53 = 1;
				v54 = *(x_BYTE *)(i + 73);
				if ((v54 == 14 || v54 == 13) && *(unsigned __int16 *)(i + 40) == *(signed __int16 *)(v102 + 26))
					v53 = 0;
				if (v53)
					v104 = 19;
				goto LABEL_118;
			case 7u:
				goto LABEL_57;
			case 8u:
				v39 = *(x_BYTE *)(i + 64);
				if (v39 < 0x27u)
				{
					if (v39 >= 0x12u)
					{
						if (v39 <= 0x12u)
							break;
						if (v39 == 34)
							v92 = 2;
					}
					goto LABEL_57;
				}
				if (v39 <= 0x27u)
					goto LABEL_169;
				if (v39 < 0x39u)
				{
					if (v39 == 45)
					{
						v45 = *(x_WORD *)(i + 148);
						if (v45 && (v46 = x_DWORD_EA3E4[v45], *(x_BYTE *)(v46 + 63) == 3))
						{
							v47 = x_D41A0_BYTEARRAY_4[0x7C] == 0;
							sub_61790(*(signed __int16 *)(*(x_DWORD *)(v46 + 164) + 56));
						}
						else
						{
							if (!(x_BYTE_D93C2[4 * *(char *)(i + 70)] & 8))
								v104 = 21;
							v105 = 1;
						}
					}
				LABEL_57:
					v44 = x_DWORD_EA3E4[*(signed __int16 *)(i + 26)];
					if (*(x_BYTE *)(v44 + 63) == 3)
						v43 = x_BYTE_E88E0[3 * sub_61790(*(signed __int16 *)(*(x_DWORD *)(v44 + 164) + 56))];
					else
						v43 = x_BYTE_E980F;
				LABEL_117:
					v110 = v43;
					goto LABEL_118;
				}
				if (v39 <= 0x39u)
				{
				LABEL_169:
					v40 = *(x_WORD *)(i + 148);
					if (v40 && (v41 = x_DWORD_EA3E4[v40], *(x_BYTE *)(v41 + 63) == 3))
					{
						if (x_D41A0_BYTEARRAY_4[0x7C])
							v42 = x_BYTE_E88E0[3 * sub_61790(*(signed __int16 *)(*(x_DWORD *)(v41 + 164) + 56))];
						else
							v42 = x_BYTE_E88E1[3 * sub_61790(*(signed __int16 *)(*(x_DWORD *)(v41 + 164) + 56))];
						v110 = v42;
					}
					else
					{
						v110 = v107;
						v104 = 18;
					}
				LABEL_118:
					v36 = 1;
				}
				else
				{
					if (v39 < 0x4Eu)
						goto LABEL_57;
					if (v39 <= 0x4Eu)
					{
						if (*(x_WORD *)(i + 50) != *(x_WORD *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240))
							break;
						v43 = x_BYTE_E88E0[3 * sub_61790(*(signed __int16 *)(*(x_DWORD *)(v102 + 164) + 56))
							+ x_D41A0_BYTEARRAY_4[0x7C]];
						goto LABEL_117;
					}
					if (v39 < 0x56u || v39 > 0x57u)
						goto LABEL_57;
				}
				break;
			case 9u:
				v38 = *(x_BYTE *)(i + 64);
				if (v38 <= 0x2Cu)
				{
					switch (v38)
					{
					case 0u:
					case 1u:
					case 2u:
					case 3u:
					case 4u:
					case 5u:
					case 6u:
					case 7u:
					case 8u:
					case 9u:
					case 0xAu:
					case 0xBu:
					case 0xDu:
					case 0xEu:
					case 0xFu:
					case 0x10u:
					case 0x11u:
					case 0x12u:
					case 0x13u:
					case 0x14u:
					case 0x15u:
					case 0x16u:
					case 0x17u:
					case 0x18u:
					case 0x19u:
					case 0x1Au:
					case 0x1Bu:
					case 0x1Cu:
					case 0x1Du:
					case 0x1Eu:
					case 0x20u:
					case 0x21u:
					case 0x22u:
					case 0x23u:
					case 0x24u:
					case 0x25u:
					case 0x26u:
					case 0x27u:
					case 0x28u:
					case 0x29u:
					case 0x2Au:
					case 0x2Bu:
					case 0x2Cu:
						goto LABEL_119;
					case 0xCu:
						v36 = 83;
						v104 = 83;
						break;
					case 0x1Fu:
						v36 = 84;
						v104 = 83;
						break;
					}
				}
				break;
			case 0xAu:
			case 0xDu:
				if (*(x_BYTE *)(i + 12) & 1)
					break;
				v43 = x_BYTE_E9800;
				v104 = 20;
				goto LABEL_117;
			case 0xCu:
				if (*(x_BYTE *)(i + 64) != 5)
					break;
				if (x_D41A0_BYTEARRAY_4[0x7C])
					v43 = x_BYTE_E9800;
				else
					v43 = x_BYTE_E98FF;
				goto LABEL_117;
			}
		}
	LABEL_119:
		if (v36)
		{
			v57 = (signed __int16)(*(x_WORD *)(i + 76) - a3);
			v58 = (signed __int16)(*(x_WORD *)(i + 78) - a4);
			v59 = v98 + ((v57 * v87 - v58 * v86) >> 16);
			if (v59 >= 0 && v59 < a5)
			{
				v60 = ((v87 * v58 + v86 * v57) >> 16) + v85;
				if (v60 >= 0 && v60 < a6 && v59 >= x_WORD_F4962[2 * v60] && v59 < x_WORD_F4960[2 * v60])
				{
					v61 = (char *)(v60 * x_DWORD_18062C_resolution_x + v59 + v99);
					v62 = (char *)(v60 * x_DWORD_18062C_resolution_x + v59 + v100);
					if (!v105)
					{
						if (v36 <= 1u)
						{
							*v62 = v110;
							*v61 = v110;
							if (v92 > 1)
							{
								v62[1] = v110;
								v61[1] = v110;
								v63 = &v62[x_DWORD_18062C_resolution_x];
								*v63 = v110;
								v64 = &v61[x_DWORD_18062C_resolution_x];
								*v64 = v110;
								v63[1] = v110;
								v64[1] = v110;
							}
						}
						else if (x_WORD_180660_VGA_type_resolution == 1)
						{
							if (v36 < 0x42u || v36 >= 0x4Au)
							{
								if (v36 < 0x3Au || v36 >= 0x42u)
								{
									/*if ( v36 == 83 || v36 == 84 )
									  sub_2BB40_draw_bitmap(
										2 * v59 - *(unsigned __int8 *)(6 * v36 + **filearray_2aa18c[6] + 4) / 2,
										2 * v60 - *(unsigned __int8 *)(6 * v36 + **filearray_2aa18c[6] + 5) / 2,
										  (Bit8u**)(6 * v36 + **filearray_2aa18c[6]));*/ // fix it
								}
								else
								{
									//fix it sub_2BB40_draw_bitmap(2 * v59, 2 * v60 - *(unsigned __int8 *)(**filearray_2aa18c[6] + 6 * v36 + 5), (Bit8u**)(**filearray_2aa18c[6] + 6 * v36));
								}
							}
							else
							{
								/*sub_2BB40_draw_bitmap(
								  2 * v59 - *(unsigned __int8 *)(6 * v36 + **filearray_2aa18c[6] + 4) / 2,
								  2 * v60 - *(unsigned __int8 *)(6 * v36 + **filearray_2aa18c[6] + 5),
									(Bit8u**)(6 * v36 + **filearray_2aa18c[6]));*/ //fix it
							}
						}
						else if (v36 >= 0x3Cu)
						{
							/*sub_2BB40_draw_bitmap(
							  v59 - *(unsigned __int8 *)(6 * v36 + **filearray_2aa18c[6] + 4) / 2,
							  v60 - *(unsigned __int8 *)(6 * v36 + **filearray_2aa18c[6] + 5),
								(Bit8u**)(6 * v36 + **filearray_2aa18c[6]));*/ //fix it
						}
						else
						{
							//fix it //sub_2BB40_draw_bitmap(v59, v60 - *(unsigned __int8 *)(6 * v36 + **filearray_2aa18c[6] + 5), (Bit8u**)(6 * v36 + **filearray_2aa18c[6]));
						}
					}
					if (v104)
						sub_885E0(i, (signed __int16)v59, (signed __int16)v60, v104);
				}
			}
		}
	}
	if (v93)
	{
		v90 = x_DWORD_EA3E4[*(unsigned __int16 *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240)];
		for (j = 0; j < *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 14); j++)
		{
			if (j != x_D41A0_BYTEARRAY_4_struct.dwordindex_12)
			{
				v96 = 2124 * j;
				v65 = *(unsigned __int16 *)(2124 * j + x_D41A0_BYTEARRAY_0 + 11240);
				v66 = x_DWORD_EA3E4[v65];
				if (*(x_DWORD *)(v66 + 8) >= 0)
				{
					if (sub_63570(v90, x_DWORD_EA3E4[v65]))
					{
						v67 = (signed __int16)(*(x_WORD *)(v66 + 76) - a3);
						v68 = (signed __int16)(*(x_WORD *)(v66 + 78) - a4);
						v69 = v98 + ((v67 * v87 - v68 * v86) >> 16);
						if (v69 >= 0 && v69 < a5)
						{
							v70 = ((v86 * v67 + v87 * v68) >> 16) + v85;
							if (v70 >= 0 && v70 < a6 && v69 >= x_WORD_F4962[2 * v70] && v69 < x_WORD_F4960[2 * v70])
							{
								v71 = (unsigned __int8 *)(v70 * x_DWORD_18062C_resolution_x + v69 + v99);
								v72 = (unsigned __int8 *)(v70 * x_DWORD_18062C_resolution_x + v69 + v100);
								v73 = x_BYTE_E88E1[3 * sub_61790(*(signed __int16 *)(*(x_DWORD *)(v66 + 164) + 56))];
								*v72 = v73;
								*v71 = v73;
								if (x_WORD_180660_VGA_type_resolution == 1)
									sub_2BC10_draw_text((Bit8u*)(v96 + x_D41A0_BYTEARRAY_0 + 11230 + 927), 2 * v69 + 4, 2 * v70, v73);
								else
									sub_2BC10_draw_text((Bit8u*)(v96 + x_D41A0_BYTEARRAY_0 + 11230 + 927), v69 + 4, v70, v73);
							}
						}
					}
				}
			}
		}
	}
	v97 = a5 / 12;
	v74 = x_DWORD_18062C_resolution_x * (a6 / 2);
	v75 = (char *)(v100 + a5 / 2 + v74 - 1);
	v76 = (char *)(v74 + a5 / 2 + v99 - 1);
	result = &x_BYTE_FAEE0[256 * v106];
	v88 = v76;
	v101 = v76;
	*v76 = result[(unsigned __int8)*v76];
	v78 = v76;
	v83 = v75;
	v84 = v75;
	v95 = v75;
	for (*v75 = result[(unsigned __int8)*v76]; v97; --v97)
	{
		++v101;
		v88 += x_DWORD_18062C_resolution_x;
		v78 -= x_DWORD_18062C_resolution_x;
		v95 -= x_DWORD_18062C_resolution_x;
		++v84;
		v83 += x_DWORD_18062C_resolution_x;
		v79 = x_BYTE_FAEE0[256 * v106 + (unsigned __int8)*v78];
		*v78 = v79;
		*v95 = v79;
		v80 = x_BYTE_FAEE0[256 * v106 + (unsigned __int8)*v101];
		*v101 = v80;
		*v84 = v80;
		v81 = x_BYTE_FAEE0[256 * v106 + (unsigned __int8)*v88];
		*v88 = v81;
		*v83 = v81;
		v82 = x_BYTE_FAEE0[256 * v106 + (unsigned __int8)*(v76 - 1)];
		*(v76 - 1) = v82;
		*(v75 - 1) = v82;
		--v76;
		--v75;
	}
	return result;
}
// 10000: using guessed type void /*__noreturn*/ sub_10000();
// D419D: using guessed type char x_BYTE_D419D;
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// DBF50: using guessed type void (/*__noreturn*/ *off_DBF50[2])();
// E890F: using guessed type char x_BYTE_E890F;
// E8988: using guessed type char x_BYTE_E8988;
// E89F0: using guessed type char x_BYTE_E89F0;
// E9800: using guessed type char x_BYTE_E9800;
// E980F: using guessed type char x_BYTE_E980F;
// E98FF: using guessed type char x_BYTE_E98FF;
// E9C3C: using guessed type int x_DWORD_E9C3C;
// EA3DC: using guessed type int **filearray_2aa18c[6];
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// F4960: using guessed type __int16 x_WORD_F4960[];
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 18062C: using guessed type int x_DWORD_18062C_resolution_x;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00063570) --------------------------------------------------------
char sub_63570(int a1, int a2)
{
	unsigned int v2; // ecx
	char v3; // ah
	unsigned int v4; // ebx
	char v5; // dl
	unsigned __int8 v6; // al

	v2 = x_DWORD_EA3E4[*(signed __int16 *)(*(x_DWORD *)(a1 + 164) + 843)];
	v3 = 1;
	v4 = x_DWORD_EA3E4[*(signed __int16 *)(*(x_DWORD *)(a2 + 164) + 827)];
	v5 = 0;
	if (v4 > x_DWORD_EA3E4[0] && *(x_WORD *)(v4 + 46))
		v5 = 1;
	if (v2 > x_DWORD_EA3E4[0])
	{
		v6 = *(x_BYTE *)(v2 + 70);
		if (v6 < 1u)
		{
			if (v6)
				return v3;
			if (*(x_BYTE *)(*(x_DWORD *)(a2 + 164) + 447))
				return 0;
		}
		else if (v6 > 1u)
		{
			return v3;
		}
		if (v5)
			return 0;
	}
	return v3;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00063600) --------------------------------------------------------
int sub_63600(int a1, int a2, int a3, int a4, int a5, int a6, __int16 a7, int a8, int a9, int a10)
{
	int result; // eax

	if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8592) == 1)
		result = sub_63670(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
	else
		result = sub_63C90(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00063670) --------------------------------------------------------
int sub_63670(int a1, int a2, int a3, int a4, int a5, int a6, __int16 a7, int a8, int a9, int a10)
{
	int v10; // eax
	int v11; // esi
	int v12; // edi
	int v13; // ecx
	bool v14; // dl
	__int16 *v15; // ebx
	int v16; // edx
	__int16 *v17; // esi
	int v18; // ebx
	__int16 v19; // ax
	__int16 *v20; // edx
	__int16 v21; // ax
	int v22; // edx
	int v23; // ebx
	int v24; // esi
	int v25; // eax
	int v26; // eax
	int result; // eax
	int v28; // ebx
	int v29; // ecx
	char *v30; // edi
	int v31; // esi
	int v32; // eax
	int v33; // edx
	char v34; // al
	int v35; // ecx
	int v36; // ebx
	x_BYTE *v37; // edi
	int v38; // ecx
	int v39; // esi
	int v40; // eax
	int v41; // edx
	int v42; // ebx
	char *v43; // edi
	int v44; // ecx
	int v45; // esi
	int v46; // eax
	int v47; // edx
	char v48; // al
	int v49; // ecx
	int v50; // ebx
	x_BYTE *v51; // edi
	int v52; // ecx
	int v53; // esi
	int v54; // eax
	int v55; // edx
	int v56; // ebx
	char *v57; // edi
	int v58; // ecx
	int v59; // esi
	int v60; // eax
	int v61; // edx
	char v62; // al
	char *v63; // edi
	int v64; // [esp+0h] [ebp-60h]
	int v65; // [esp+4h] [ebp-5Ch]
	int v66; // [esp+8h] [ebp-58h]
	int v67; // [esp+Ch] [ebp-54h]
	int v68; // [esp+10h] [ebp-50h]
	int v69; // [esp+14h] [ebp-4Ch]
	int v70; // [esp+18h] [ebp-48h]
	int v71; // [esp+1Ch] [ebp-44h]
	int l; // [esp+20h] [ebp-40h]
	int v73; // [esp+24h] [ebp-3Ch]
	int i; // [esp+28h] [ebp-38h]
	int k; // [esp+2Ch] [ebp-34h]
	int m; // [esp+30h] [ebp-30h]
	int j; // [esp+34h] [ebp-2Ch]
	int v78; // [esp+38h] [ebp-28h]
	__int16 *v79; // [esp+3Ch] [ebp-24h]
	int v80; // [esp+40h] [ebp-20h]
	int v81; // [esp+44h] [ebp-1Ch]
	int v82; // [esp+48h] [ebp-18h]
	int v83; // [esp+4Ch] [ebp-14h]
	int v84; // [esp+50h] [ebp-10h]
	int v85; // [esp+54h] [ebp-Ch]
	__int16 *v86; // [esp+58h] [ebp-8h]
	bool v87; // [esp+5Ch] [ebp-4h]

	v10 = a1;
	v11 = a2;
	v12 = a5;
	v13 = a6;
	v14 = !*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8600) && *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308) != 2;
	v87 = v14;
	if (x_WORD_180660_VGA_type_resolution & 1)
	{
		v10 = a1 >> 1;
		v11 = a2 >> 1;
		v12 = a5 >> 1;
		v13 = a6 >> 1;
		a8 *= 2;
	}
	v70 = v11 * x_DWORD_18062C_resolution_x + (int)x_DWORD_180628b_screen_buffer + v10;
	v71 = (int)(v11 * x_DWORD_18062C_resolution_x + x_DWORD_E9C3C + v10);
	if (a10)
	{
		v15 = x_WORD_F4960;
		v16 = v13;
		while (v16)
		{
			v15 += 2;
			*(v15 - 1) = 0;
			--v16;
			*(v15 - 2) = v12;
		}
	}
	else
	{
		v78 = v13 / 2;
		v17 = &x_WORD_F4960[2 * (v13 / 2)];
		v79 = v17 - 2;
		v73 = 0;
		v68 = v13 >> 1;
		v18 = v12 >> 1;
		v69 = 0x1000000 / (v13 >> 1);
		while (v78)
		{
			v65 = v18 * (unsigned __int8)x_BYTE_10B1E0[v73 >> 16] >> 8;
			v19 = v18 + v65;
			v20 = v79;
			*v17 = v18 + v65;
			*v20 = v19;
			v21 = v18 - v65;
			v22 = (int)v79;
			v17[1] = v18 - v65;
			*(x_WORD *)(v22 + 2) = v21;
			v79 = (__int16 *)(v22 - 4);
			v17 += 2;
			v73 += v69;
			--v78;
		}
	}
	v23 = a7 & 0x7FF;
	v24 = v13 * (a8 * x_DWORD_DB750[v23] >> 16);
	v25 = a8 * (signed int)off_DBF50[v23] >> 16;
	v80 = a8 * x_DWORD_DB750[v23] >> 16;
	v81 = v25;
	v67 = v24 / v12;
	v26 = v13 * v25;
	v66 = v26 / v12;
	v85 = a3 - (v12 * (v26 / v12) - v24) / 2;
	v86 = x_WORD_F4960;
	v83 = a4 - (v26 + v12 * (v24 / v12)) / 2;
	v84 = v70;
	result = v71;
	v82 = v71;
	if (x_BYTE_D41B6)
	{
		if (a10)
		{
			for (i = v13; i; i--)
			{
				v33 = v86[1];
				v28 = v85 + v33 * v66;
				v29 = v83 + v33 * v67;
				v30 = (char *)(v33 + v84);
				v64 = v33 + v82;
				v31 = *v86 - v86[1];
				v32 = 0;
				HIWORD(v33) = 0;
				do
				{
					LOBYTE(v33) = BYTE1(v28);
					BYTE1(v33) = BYTE1(v29);
					v34 = 0;
					if (!(x_BYTE_13B4E0[v33] & 8))
					{
						LOBYTE(v32) = x_BYTE_10B4E0[v33];
						BYTE1(v33) = x_BYTE_12B4E0[v33];
						LOBYTE(v33) = x_BYTE_10AEE0[v32];
						v34 = x_BYTE_F6EE0_tables[v33];
					}
					*v30++ = v34;
					LOWORD(v28) = v66 + v28;
					LOWORD(v29) = v67 + v29;
					--v31;
				} while (v31);
				v84 += x_DWORD_18062C_resolution_x;
				v82 += x_DWORD_18062C_resolution_x;
				v86 += 2;
				v85 -= v80;
				result = i - 1;
				v83 += v81;
			}
		}
		else if (v87)
		{
			for (j = v13; j; j--)
			{
				v35 = v86[1];
				v36 = v85 + v35 * v66;
				v37 = (x_BYTE *)(v35 + v84);
				v64 = v35 + v82;
				v38 = v83 + v35 * v67;
				v39 = *v86 - v86[1];
				v40 = 0;
				HIWORD(v41) = 0;
				do
				{
					LOBYTE(v41) = BYTE1(v36);
					BYTE1(v41) = BYTE1(v38);
					if (!(x_BYTE_13B4E0[v41] & 8))
					{
						LOBYTE(v40) = x_BYTE_10B4E0[v41];
						BYTE1(v41) = x_BYTE_12B4E0[v41];
						LOBYTE(v41) = x_BYTE_10AEE0[v40];
						LOBYTE(v41) = x_BYTE_F6EE0_tables[v41];
						BYTE1(v41) = *v37;
						*v37 = x_BYTE_FAEE0[v41];
					}
					++v37;
					LOWORD(v36) = v66 + v36;
					LOWORD(v38) = v67 + v38;
					--v39;
				} while (v39);
				v84 += x_DWORD_18062C_resolution_x;
				v82 += x_DWORD_18062C_resolution_x;
				v86 += 2;
				v85 -= v80;
				result = j - 1;
				v83 += v81;
			}
		}
		else
		{
			for (k = v13; k; v83 += v81)
			{
				v47 = v86[1];
				v42 = v85 + v47 * v66;
				v43 = (char *)(v47 + v84);
				v44 = v83 + v47 * v67;
				v64 = v47 + v82;
				v45 = *v86 - v86[1];
				v46 = 0;
				HIWORD(v47) = 0;
				do
				{
					LOBYTE(v47) = BYTE1(v42);
					BYTE1(v47) = BYTE1(v44);
					if (x_BYTE_13B4E0[v47] & 8)
					{
						v48 = 0;
					}
					else
					{
						LOBYTE(v46) = x_BYTE_10B4E0[v47];
						BYTE1(v47) = x_BYTE_12B4E0[v47];
						LOBYTE(v47) = x_BYTE_10AEE0[v46];
						v48 = x_BYTE_F6EE0_tables[v47];
					}
					*v43++ = v48;
					LOWORD(v42) = v66 + v42;
					LOWORD(v44) = v67 + v44;
					--v45;
				} while (v45);
				v84 += x_DWORD_18062C_resolution_x;
				v82 += x_DWORD_18062C_resolution_x;
				v86 += 2;
				result = v81;
				v85 -= v80;
				--k;
			}
		}
	}
	else if (a10)
	{
		for (l = v13; l; l--)
		{
			v49 = v86[1];
			v50 = v85 + v49 * v66;
			v51 = (x_BYTE *)(v49 + v84);
			v64 = v49 + v82;
			v52 = v83 + v49 * v67;
			v53 = *v86 - v86[1];
			v54 = 0;
			HIWORD(v55) = 0;
			do
			{
				LOBYTE(v55) = BYTE1(v50);
				BYTE1(v55) = BYTE1(v52);
				LOBYTE(v54) = x_BYTE_10B4E0[v55];
				BYTE1(v55) = x_BYTE_12B4E0[v55];
				LOBYTE(v55) = x_BYTE_10AEE0[v54];
				*v51++ = x_BYTE_F6EE0_tables[v55];
				v50 += v66;
				v52 += v67;
				--v53;
			} while (v53);
			v84 += x_DWORD_18062C_resolution_x;
			v82 += x_DWORD_18062C_resolution_x;
			v86 += 2;
			v85 -= v80;
			result = l - 1;
			v83 += v81;
		}
	}
	else
	{
		for (m = v13; m; v83 += v81)
		{
			v61 = v86[1];
			v56 = v85 + v61 * v66;
			v57 = (char *)(v61 + v84);
			v58 = v83 + v61 * v67;
			v64 = v61 + v82;
			v59 = *v86 - v86[1];
			v60 = 0;
			HIWORD(v61) = 0;
			do
			{
				LOBYTE(v61) = BYTE1(v56);
				BYTE1(v61) = BYTE1(v58);
				LOBYTE(v60) = x_BYTE_10B4E0[v61];
				BYTE1(v61) = x_BYTE_12B4E0[v61];
				LOBYTE(v61) = x_BYTE_10AEE0[v60];
				LOBYTE(v61) = x_BYTE_F6EE0_tables[v61];
				BYTE1(v61) = *v57;
				v62 = x_BYTE_FAEE0[v61];
				*v57 = v62;
				v63 = (char *)x_InterlockedExchange((long*)&v64, (signed __int32)(v57 + 1));
				*v63 = v62;
				v57 = (char *)x_InterlockedExchange((long*)&v64, (signed __int32)(v63 + 1));
				v56 += v66;
				v58 += v67;
				--v59;
			} while (v59);
			v84 += x_DWORD_18062C_resolution_x;
			v82 += x_DWORD_18062C_resolution_x;
			v86 += 2;
			result = v81;
			v85 -= v80;
			--m;
		}
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41B6: using guessed type char x_BYTE_D41B6;
// DBF50: using guessed type void (/*__noreturn*/ *off_DBF50[2])();
// E9C3C: using guessed type int x_DWORD_E9C3C;
// F4960: using guessed type __int16 x_WORD_F4960[];
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 18062C: using guessed type int x_DWORD_18062C_resolution_x;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00063C90) --------------------------------------------------------
int sub_63C90(int a1, int a2, int a3, int a4, int a5, int a6, __int16 a7, int a8, int a9, int a10)
{
	int v10; // ebx
	int v11; // edx
	int v12; // edi
	int v13; // ecx
	bool v14; // al
	__int16 *v15; // ebx
	int v16; // edx
	__int16 *v17; // esi
	int v18; // ebx
	int v19; // ST00_4
	int v20; // ebx
	int v21; // esi
	int v22; // eax
	int v23; // eax
	int v24; // edx
	int result; // eax
	int v26; // ebx
	int v27; // ecx
	char *v28; // edi
	int v29; // esi
	int v30; // eax
	int v31; // edx
	char v32; // al
	int v33; // ebx
	int v34; // ecx
	x_BYTE *v35; // edi
	int v36; // esi
	int v37; // eax
	int v38; // edx
	int v39; // ebx
	int v40; // ecx
	char *v41; // edi
	int v42; // esi
	int v43; // eax
	int v44; // edx
	char v45; // al
	int v46; // ebx
	int v47; // ecx
	x_BYTE *v48; // edi
	int v49; // esi
	int v50; // eax
	int v51; // edx
	int v52; // ebx
	int v53; // ecx
	x_BYTE *v54; // edi
	int v55; // esi
	int v56; // eax
	int v57; // edx
	int v58; // [esp+4h] [ebp-50h]
	int v59; // [esp+8h] [ebp-4Ch]
	int v60; // [esp+14h] [ebp-40h]
	int m; // [esp+18h] [ebp-3Ch]
	int l; // [esp+1Ch] [ebp-38h]
	int k; // [esp+20h] [ebp-34h]
	int v64; // [esp+24h] [ebp-30h]
	int i; // [esp+28h] [ebp-2Ch]
	int j; // [esp+2Ch] [ebp-28h]
	int v67; // [esp+30h] [ebp-24h]
	__int16 *v68; // [esp+34h] [ebp-20h]
	int v69; // [esp+38h] [ebp-1Ch]
	int v70; // [esp+3Ch] [ebp-18h]
	int v71; // [esp+40h] [ebp-14h]
	int v72; // [esp+44h] [ebp-10h]
	int v73; // [esp+48h] [ebp-Ch]
	__int16 *v74; // [esp+4Ch] [ebp-8h]
	bool v75; // [esp+50h] [ebp-4h]

	v10 = a1;
	v11 = a2;
	v12 = a5;
	v13 = a6;
	v14 = !*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8600) && *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308) != 2;
	v75 = v14;
	if (x_WORD_180660_VGA_type_resolution & 1)
	{
		v10 = a1 >> 1;
		v11 = a2 >> 1;
		v12 = a5 >> 1;
		v13 = a6 >> 1;
		a8 *= 2;
	}
	v60 = x_DWORD_18062C_resolution_x * v11 + v10 + (int)x_DWORD_180628b_screen_buffer;
	if (a10)
	{
		v15 = x_WORD_F4960;
		v16 = v13;
		while (v16)
		{
			v15 += 2;
			*(v15 - 1) = 0;
			--v16;
			*(v15 - 2) = v12;
		}
	}
	else
	{
		v67 = v13 / 2;
		v17 = &x_WORD_F4960[2 * (v13 / 2)];
		v68 = v17 - 2;
		v64 = 0;
		v18 = v12 >> 1;
		while (v67)
		{
			v19 = v18 * (unsigned __int8)x_BYTE_10B1E0[v64 >> 16] >> 8;
			*v17 = v18 + v19;
			*v68 = v18 + v19;
			v17[1] = v18 - v19;
			v68[1] = v18 - v19;
			v68 -= 2;
			v17 += 2;
			v64 += 0x1000000 / (v13 >> 1);
			--v67;
		}
	}
	v20 = a7 & 0x7FF;
	v21 = v13 * (a8 * x_DWORD_DB750[v20] >> 16);
	v22 = a8 * (signed int)off_DBF50[v20] >> 16;
	v70 = a8 * x_DWORD_DB750[v20] >> 16;
	v69 = v22;
	v59 = v21 / v12;
	v23 = v13 * v22;
	v58 = v23 / v12;
	v72 = a3 - (v12 * (v23 / v12) - v21) / 2;
	v74 = x_WORD_F4960;
	v24 = a4 - (v23 + v12 * (v21 / v12)) / 2;
	result = v60;
	v73 = v24;
	v71 = v60;
	if (x_BYTE_D41B6)
	{
		if (a10)
		{
			for (i = v13; i; v73 += v69)
			{
				v31 = v74[1];
				v26 = v72 + v31 * v58;
				v27 = v73 + v31 * v59;
				v28 = (char *)(v31 + v71);
				v29 = *v74 - v31;
				v30 = 0;
				HIWORD(v31) = 0;
				do
				{
					LOBYTE(v31) = BYTE1(v26);
					BYTE1(v31) = BYTE1(v27);
					v32 = 0;
					if (!(x_BYTE_13B4E0[v31] & 8))
					{
						LOBYTE(v30) = x_BYTE_10B4E0[v31];
						BYTE1(v31) = x_BYTE_12B4E0[v31];
						LOBYTE(v31) = x_BYTE_10AEE0[v30];
						v32 = x_BYTE_F6EE0_tables[v31];
					}
					*v28++ = v32;
					LOWORD(v26) = v58 + v26;
					LOWORD(v27) = v59 + v27;
					--v29;
				} while (v29);
				v71 += x_DWORD_18062C_resolution_x;
				v74 += 2;
				result = v69;
				--i;
				v72 -= v70;
			}
		}
		else if (v75)
		{
			for (j = v13; j; v73 += v69)
			{
				v38 = v74[1];
				v33 = v72 + v38 * v58;
				v34 = v73 + v38 * v59;
				v35 = (x_BYTE *)(v38 + v71);
				v36 = *v74 - v38;
				v37 = 0;
				HIWORD(v38) = 0;
				do
				{
					LOBYTE(v38) = BYTE1(v33);
					BYTE1(v38) = BYTE1(v34);
					if (!(x_BYTE_13B4E0[v38] & 8))
					{
						LOBYTE(v37) = x_BYTE_10B4E0[v38];
						BYTE1(v38) = x_BYTE_12B4E0[v38];
						LOBYTE(v38) = x_BYTE_10AEE0[v37];
						LOBYTE(v38) = x_BYTE_F6EE0_tables[v38];
						BYTE1(v38) = *v35;
						*v35 = x_BYTE_FAEE0[v38];
					}
					++v35;
					LOWORD(v33) = v58 + v33;
					LOWORD(v34) = v59 + v34;
					--v36;
				} while (v36);
				v71 += x_DWORD_18062C_resolution_x;
				v74 += 2;
				result = v69;
				--j;
				v72 -= v70;
			}
		}
		else
		{
			for (k = v13; k; v73 += v69)
			{
				v44 = v74[1];
				v39 = v72 + v44 * v58;
				v40 = v73 + v44 * v59;
				v41 = (char *)(v44 + v71);
				v42 = *v74 - v44;
				v43 = 0;
				HIWORD(v44) = 0;
				do
				{
					LOBYTE(v44) = BYTE1(v39);
					BYTE1(v44) = BYTE1(v40);
					if (x_BYTE_13B4E0[v44] & 8)
					{
						v45 = 0;
					}
					else
					{
						LOBYTE(v43) = x_BYTE_10B4E0[v44];
						BYTE1(v44) = x_BYTE_12B4E0[v44];
						LOBYTE(v44) = x_BYTE_10AEE0[v43];
						v45 = x_BYTE_F6EE0_tables[v44];
					}
					*v41++ = v45;
					LOWORD(v39) = v58 + v39;
					LOWORD(v40) = v59 + v40;
					--v42;
				} while (v42);
				v71 += x_DWORD_18062C_resolution_x;
				v74 += 2;
				result = v69;
				--k;
				v72 -= v70;
			}
		}
	}
	else if (a10)
	{
		for (l = v13; l; v73 += v69)
		{
			v51 = v74[1];
			v46 = v72 + v51 * v58;
			v47 = v73 + v51 * v59;
			v48 = (x_BYTE *)(v51 + v71);
			v49 = *v74 - v51;
			v50 = 0;
			HIWORD(v51) = 0;
			do
			{
				LOBYTE(v51) = BYTE1(v46);
				BYTE1(v51) = BYTE1(v47);
				LOBYTE(v50) = x_BYTE_10B4E0[v51];
				BYTE1(v51) = x_BYTE_12B4E0[v51];
				LOBYTE(v51) = x_BYTE_10AEE0[v50];
				*v48++ = x_BYTE_F6EE0_tables[v51];
				v46 += v58;
				v47 += v59;
				--v49;
			} while (v49);
			v71 += x_DWORD_18062C_resolution_x;
			v74 += 2;
			result = v69;
			--l;
			v72 -= v70;
		}
	}
	else
	{
		for (m = v13; m; v73 += v69)
		{
			v57 = v74[1];
			v52 = v72 + v57 * v58;
			v53 = v73 + v57 * v59;
			v54 = (x_BYTE *)(v57 + v71);
			v55 = *v74 - v57;
			v56 = 0;
			HIWORD(v57) = 0;
			do
			{
				LOBYTE(v57) = BYTE1(v52);
				BYTE1(v57) = BYTE1(v53);
				LOBYTE(v56) = x_BYTE_10B4E0[v57];
				BYTE1(v57) = x_BYTE_12B4E0[v57];
				LOBYTE(v57) = x_BYTE_10AEE0[v56];
				LOBYTE(v57) = x_BYTE_F6EE0_tables[v57];
				BYTE1(v57) = *v54;
				*v54++ = x_BYTE_FAEE0[v57];
				v52 += v58;
				v53 += v59;
				--v55;
			} while (v55);
			v71 += x_DWORD_18062C_resolution_x;
			v74 += 2;
			result = v69;
			--m;
			v72 -= v70;
		}
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41B6: using guessed type char x_BYTE_D41B6;
// DBF50: using guessed type void (/*__noreturn*/ *off_DBF50[2])();
// F4960: using guessed type __int16 x_WORD_F4960[];
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 18062C: using guessed type int x_DWORD_18062C_resolution_x;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (000644F0) --------------------------------------------------------
char sub_644F0(int a1, int a2, __int16 a3, __int16 a4, int a5, int a6, __int16 a7, int a8)
{
	signed int v8; // ebx
	__int64 v9; // rtt
	int v10; // edi
	int v11; // edx
	int v12; // eax
	__int16 v13; // ST10_2
	char v14; // dl
	unsigned int i; // eax
	x_WORD *v16; // eax
	char *v17; // esi
	int v18; // edx
	signed int v19; // eax
	signed int v20; // eax
	int v21; // ebx
	int v22; // ecx
	int v23; // ebx
	int v24; // ecx
	int v25; // esi
	signed int v26; // edx
	int v27; // ecx
	void(/*__noreturn*/ *v28)(); // ebx
	int v29; // eax
	unsigned __int8 v30; // cl
	signed int v31; // ebx
	int v32; // eax
	int v33; // edi
	unsigned __int8 v34; // bl
	int *v36; // [esp-4h] [ebp-BEh]
	int v37; // [esp+0h] [ebp-BAh]
	int v38[5]; // [esp+4h] [ebp-B6h]
	int v39; // [esp+18h] [ebp-A2h]
	int v40; // [esp+1Ch] [ebp-9Eh]
	int v41; // [esp+30h] [ebp-8Ah]
	int v42; // [esp+34h] [ebp-86h]
	int v43; // [esp+48h] [ebp-72h]
	int v44; // [esp+4Ch] [ebp-6Eh]
	int v45; // [esp+60h] [ebp-5Ah]
	int v46; // [esp+64h] [ebp-56h]
	int v47; // [esp+78h] [ebp-42h]
	int v48; // [esp+7Ch] [ebp-3Eh]
	int v49; // [esp+90h] [ebp-2Ah]
	int v50; // [esp+94h] [ebp-26h]
	int v51; // [esp+A8h] [ebp-12h]
	__int16 v52; // [esp+ACh] [ebp-Eh]
	int v53; // [esp+AEh] [ebp-Ch]
	int v54; // [esp+B2h] [ebp-8h]
	int v55; // [esp+B6h] [ebp-4h]
	int v56; // [esp+BAh] [ebp+0h]
	int v57; // [esp+BEh] [ebp+4h]
	int v58; // [esp+C2h] [ebp+8h]
	int v59; // [esp+C6h] [ebp+Ch]
	int v60; // [esp+CAh] [ebp+10h]
	int v61; // [esp+CEh] [ebp+14h]
	__int16 v62; // [esp+D2h] [ebp+18h]
	__int16 v63; // [esp+D4h] [ebp+1Ah]
	char v64; // [esp+D6h] [ebp+1Ch]
	int v65; // [esp+D8h] [ebp+1Eh]
	__int16 v66; // [esp+DCh] [ebp+22h]
	int v67; // [esp+E0h] [ebp+26h]
	__int16 v68; // [esp+E4h] [ebp+2Ah]
	int v69; // [esp+E8h] [ebp+2Eh]
	int v70; // [esp+ECh] [ebp+32h]
	int v71; // [esp+F0h] [ebp+36h]
	int v72; // [esp+F4h] [ebp+3Ah]
	int v73; // [esp+F8h] [ebp+3Eh]
	int v74; // [esp+FCh] [ebp+42h]
	int v75; // [esp+100h] [ebp+46h]
	int v76; // [esp+104h] [ebp+4Ah]
	int v77; // [esp+108h] [ebp+4Eh]
	int v78; // [esp+10Ch] [ebp+52h]
	int v79; // [esp+110h] [ebp+56h]
	unsigned __int8 j; // [esp+114h] [ebp+5Ah]
	char v81; // [esp+118h] [ebp+5Eh]
	int v82; // [esp+148h] [ebp+8Eh]
	int v83; // [esp+14Ch] [ebp+92h]

	//fix it
	v62 = 0;
	v63 = 0;
	v66 = 0;
	//fix it

	v8 = 0x1000000;
	v81 = 0;
	if (x_WORD_180660_VGA_type_resolution & 1)
	{
		a1 >>= 1;
		a2 >>= 1;
		a5 >>= 1;
		a6 >>= 1;
		a8 *= 2;
	}
	v53 = x_DWORD_18062C_resolution_x * a2 + (int)x_DWORD_180628b_screen_buffer + a1;
	LODWORD(v9) = (uint32)sub_10000;
	HIDWORD(v9) = (signed int)sub_10000 >> 31;
	v83 = v9 / a8;
	v56 = a3;
	v57 = a4;
	v58 = a5;
	v59 = a6;
	v60 = a5 / 2;
	v10 = a7 & 0x7FF;
	v11 = v83 * x_DWORD_DB750[v10];
	v61 = a6 / 2;
	v12 = v83 * (signed int)off_DBF50[v10] >> 16;
	v55 = -v11 >> 16;
	v54 = v12;
	v82 = a7 & 0x7FF;
	v13 = *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12);
	v75 = x_DWORD_EA3E4[*(unsigned __int16 *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240)];
	LOBYTE(i) = sub_595C0(v13);
	v14 = i;
	LOBYTE(i) = i + 3;
	switch ((x_BYTE)i)
	{
	case 0:
	case 1:
	case 2:
		if (v14 == -3)
		{
			for (i = x_D41A0_BYTEARRAY_4[38535]; ; i = *(x_DWORD *)v72)
			{
				v72 = i;
				if (i <= x_DWORD_EA3E4[0])
					break;
				LOBYTE(i) = v72;
				if (*(x_BYTE *)(v72 + 64) == 31)
				{
					v81 = 1;
					break;
				}
			}
		}
		else
		{
			for (i = x_D41A0_BYTEARRAY_4[38535]; ; i = *(x_DWORD *)v72)
			{
				v72 = i;
				if (i <= x_DWORD_EA3E4[0])
					break;
				LOBYTE(i) = v72;
				if (*(x_BYTE *)(v72 + 64) == 12)
				{
					v81 = 1;
					break;
				}
			}
		}
		if (v81)
		{
			v36 = &v67;
			v16 = (x_WORD *)(v75 + 76);
			v17 = (char *)(v72 + 76);
			goto LABEL_47;
		}
		break;
	case 4:
	case 5:
		LOBYTE(i) = sub_59610(&v72, *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12));
		if ((x_BYTE)i)
		{
			v64 = x_BYTE_E9800;
			v51 = *(x_DWORD *)(v72 + 76);
			v52 = *(x_WORD *)(v72 + 80);
			if (sub_64CE0((int)&v51))
				sub_885E0(v72, v62, v63, 0x52u);
			v36 = (int *)(v72 + 76);
			v17 = (char *)(v72 + 76);
			v16 = (x_WORD *)(v75 + 76);
			v81 = 1;
			goto LABEL_47;
		}
		break;
	case 8:
		LOBYTE(i) = sub_596C0((x_WORD*)&v65, *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12));
		if ((x_BYTE)i)
		{
			v64 = x_BYTE_E98F0;
			v51 = v65;
			v52 = v66;
			if (sub_64CE0((int)&v51))
				sub_885E0(0, v62, v63, 0x51u);
			v36 = &v65;
			v17 = (char *)&v65;
			v16 = (x_WORD *)(v75 + 76);
			v81 = 1;
		LABEL_47:
			v67 = *(x_DWORD *)v17;
			v68 = *((x_WORD *)v17 + 2);
			i = sub_58490(v16, (x_WORD*)v36);
			v8 = i;
		}
		break;
	case 0xA:
		v18 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0
			+ 10 * (unsigned __int8)x_BYTE_3659D[11 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + (int)x_D41A0_BYTEARRAY_0]
			+ 222546);
		v64 = x_BYTE_E9800;
		for (i = x_D41A0_BYTEARRAY_4[v18 + 38403]; ; i = *(x_DWORD *)v72)
		{
			v72 = i;
			if (i <= x_DWORD_EA3E4[0])
				break;
			v51 = *(x_DWORD *)(v72 + 76);
			v52 = *(x_WORD *)(v72 + 80);
			if (sub_64CE0((int)&v51))
				sub_885E0(v72, v62, v63, 0x52u);
			v19 = sub_58490((x_WORD *)(v75 + 76), (x_WORD *)(v72 + 76));
			if (v19 < v8)
			{
				v81 = 1;
				v8 = v19;
				v67 = *(x_DWORD *)(v72 + 76);
				v68 = *(x_WORD *)(v72 + 80);
			}
		}
		break;
	case 0xC:
		v64 = x_BYTE_E9800;
		v76 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0
			+ 10 * (unsigned __int8)x_BYTE_3659D[11 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + (int)x_D41A0_BYTEARRAY_0]
			+ 222546);
		for (i = x_D41A0_BYTEARRAY_4[0x967F]; ; i = *(x_DWORD *)v72)
		{
			v72 = i;
			if (i <= x_DWORD_EA3E4[0])
				break;
			v79 = v76;
			for (j = 0; v79 && j < 8u; j++)
			{
				if (*(char *)(v72 + 70) == v79)
				{
					v51 = *(x_DWORD *)(v72 + 76);
					v52 = *(x_WORD *)(v72 + 80);
					if (sub_64CE0((int)&v51))
						sub_885E0(v72, v62, v63, 0x52u);
					v20 = sub_58490((x_WORD *)(v75 + 76), (x_WORD *)(v72 + 76));
					if (v20 < v8)
					{
						v8 = v20;
						v81 = 1;
						v67 = *(x_DWORD *)(v72 + 76);
						v68 = *(x_WORD *)(v72 + 80);
					}
				}
				v79 = (unsigned __int8)x_BYTE_D93C3[4 * v79];
			}
		}
		break;
	default:
		break;
	}
	if (v81)
	{
		LOBYTE(i) = (uint8)x_D41A0_BYTEARRAY_4;
		if (x_D41A0_BYTEARRAY_4[26] & 0x40)
		{
			if (x_D41A0_BYTEARRAY_4[0x7F])
			{
				v21 = v8 - 512;
				LOWORD(v78) = sub_581E0((Bit16u*)(v75 + 76), (Bit16u*)&v67);
				v78 = (unsigned __int16)v78;
				if (v21 > 15872)
					LOWORD(v21) = 15872;
				v67 = *(x_DWORD *)(v75 + 76);
				v68 = *(x_WORD *)(v75 + 80);
				sub_57FA0((x_WORD*)&v67, v78, 0, v21);
				v22 = v83 * x_DWORD_DB750[v82];
				v23 = v83 * (x_DWORD)off_DBF50[v82];
				v71 = (signed __int16)(v67 - a3);
				v23 >>= 16;
				v24 = -v22 >> 16;
				v25 = a5 / 2 + ((v23 * v71 - v24 * (signed __int16)(HIWORD(v67) - a4)) >> 16);
				v40 = 13;
				v42 = 13;
				v44 = 13;
				v50 = 13;
				v39 = 9;
				v77 = a6 / 2 + ((v71 * v24 + (signed __int16)(HIWORD(v67) - a4) * v23) >> 16);
				v37 = 0;
				v38[0] = 0;
				v41 = -9;
				v47 = -4;
				v49 = -4;
				v46 = 23;
				v48 = 23;
				v43 = 4;
				v45 = 4;
				v26 = 1;
				v78 = ((x_WORD)v78 - (x_WORD)v82) & 0x7FF;
				v27 = x_DWORD_DB750[v78];
				v28 = off_DBF50[v78];
				while (v26 < 7)
				{
					v29 = 3 * v26;
					v70 = 16 * *(&v37 + 6 * v26);
					v69 = 16 * v38[6 * v26];
					*(&v37 + 2 * v29) = ((signed int)v28 * v70 - v27 * v69) >> 20;
					v73 = v27 * v70;
					v74 = (x_DWORD)v28 * v69;
					++v26;
					v38[2 * v29] = ((signed int)v28 * v69 + v27 * v70) >> 20;
				}
				if (x_WORD_180660_VGA_type_resolution & 1)
				{
					v25 *= 2;
					v77 *= 2;
				}
				v30 = x_BYTE_E9800;
				v31 = 0;
				while (v31 < 7)
				{
					v32 = 3 * v31;
					*(&v37 + 2 * v32) = v25 + a1 + *(&v37 + 6 * v31);
					v33 = v38[6 * v31++];
					v38[2 * v32] = v77 + a2 + v33;
				}
				v34 = v30;
				sub_2BD10(v37, v38[0], v39, v40, v30);
				sub_2BD10(v39, v40, v43, v44, v34);
				sub_2BD10(v43, v44, v45, v46, v34);
				sub_2BD10(v45, v46, v47, v48, v34);
				sub_2BD10(v47, v48, v49, v50, v34);
				sub_2BD10(v49, v50, v41, v42, v34);
				/*LOBYTE(i) = */sub_2BD10(v41, v42, v37, v38[0], v34);
			}
		}
	}
	return i;
}
// 10000: using guessed type void /*__noreturn*/ sub_10000();
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// DBF50: using guessed type void (/*__noreturn*/ *off_DBF50[2])();
// E9800: using guessed type char x_BYTE_E9800;
// E98F0: using guessed type char x_BYTE_E98F0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 18062C: using guessed type int x_DWORD_18062C_resolution_x;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;
// 644F0: using guessed type int var_118[5];

//----- (00064CE0) --------------------------------------------------------
char sub_64CE0(int a1)
{
	int v1; // ecx
	int v2; // esi
	char v3; // ah
	int v4; // ebx
	char v5; // al
	int v6; // ecx
	int v7; // esi
	int v8; // ecx
	int v9; // ebx
	x_BYTE *v10; // edx
	x_BYTE *v11; // edx
	x_BYTE *v12; // edx
	x_BYTE *v13; // edx
	x_BYTE *v14; // edx
	x_BYTE *v15; // edx

	v1 = (signed __int16)(*(x_WORD *)a1 - *(x_WORD *)(a1 + 18));
	v2 = (signed __int16)(*(x_WORD *)(a1 + 2) - *(x_WORD *)(a1 + 22));
	v3 = 0;
	v4 = *(x_DWORD *)(a1 + 34) + ((v1 * *(x_DWORD *)(a1 + 10) - v2 * *(x_DWORD *)(a1 + 14)) >> 16);
	v5 = *(x_BYTE *)(a1 + 46);
	if (v4 >= 0 && v4 < *(x_DWORD *)(a1 + 26))
	{
		v6 = *(x_DWORD *)(a1 + 38) + ((*(x_DWORD *)(a1 + 10) * v2 + *(x_DWORD *)(a1 + 14) * v1) >> 16);
		if (v6 >= 3 && v6 < *(x_DWORD *)(a1 + 30) - 3 && v4 >= x_WORD_F4962[2 * v6] + 3 && v4 < x_WORD_F4960[2 * v6] - 3)
		{
			*(x_WORD *)(a1 + 42) = v4;
			*(x_WORD *)(a1 + 44) = v6;
			v3 = 1;
			if (!(x_D41A0_BYTEARRAY_4[26] & 3))
			{
				v7 = x_DWORD_18062C_resolution_x;
				v8 = x_DWORD_18062C_resolution_x * (v6 - 1);
				v9 = v4 - 1;
				v10 = (x_BYTE *)(v8 + v9 + x_DWORD_180628b_screen_buffer);
				*v10 = v5;
				v10[1] = v5;
				v10[2] = v5;
				v11 = &v10[v7];
				*v11 = v5;
				v11[2] = v5;
				v12 = &v11[v7];
				*v12 = v5;
				v12[1] = v5;
				v12[2] = v5;
				if (1 == *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8592))
				{
					v13 = (x_BYTE *)(v8 + v9 + x_DWORD_E9C3C);
					*v13 = v5;
					v13[1] = v5;
					v13[2] = v5;
					v14 = &v13[v7];
					*v14 = v5;
					v14[2] = v5;
					v15 = &v14[v7];
					*v15 = v5;
					v15[1] = v5;
					v15[2] = v5;
				}
			}
		}
	}
	return v3;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// E9C3C: using guessed type int x_DWORD_E9C3C;
// F4960: using guessed type __int16 x_WORD_F4960[];
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 18062C: using guessed type int x_DWORD_18062C_resolution_x;

//----- (00064E20) --------------------------------------------------------
int(*sub_64E20(int a1))()
{
	__int16 v1; // dx
	int v2; // edx
	int v3; // eax
	int v4; // ecx
	int v5; // esi
	__int64 v6; // rax
	__int16 v7; // di
	unsigned int v8; // edx
	int v9; // esi
	int(*result)(); // eax
	int v11; // eax

	v1 = *(x_WORD *)(a1 + 98);
	*(x_BYTE *)(a1 + 14) |= 2u;
	if (v1)
	{
		v2 = *(x_DWORD *)(a1 + 8) - *(x_DWORD *)(a1 + 94);
		*(x_DWORD *)(a1 + 8) = v2;
		if (v2 < 0)
		{
			v3 = sub_4A190(a1 + 76, 10, 6);
			v4 = v3;
			v5 = v3;
			if (v3)
			{
				*(x_WORD *)(v3 + 26) = *(x_WORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 98)] + 26);
				v6 = 3 * *(signed __int16 *)(a1 + 88);
				v7 = *(x_WORD *)(v4 + 80);
				*(x_WORD *)(v4 + 44) = (signed int)(v6 - (__CFSHL__(HIDWORD(v6), 2) + 4 * HIDWORD(v6))) >> 2;
				if (v7 <= 128)
					*(x_WORD *)(v4 + 80) = 0;
				else
					*(x_WORD *)(v4 + 80) = v7 - 128;
				*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
				v8 = *(unsigned __int16 *)(a1 + 20) % 0x3Cu + 130;
				*(x_DWORD *)(v5 + 8) = v8;
				v9 = *(x_DWORD *)(a1 + 12);
				*(x_DWORD *)(a1 + 8) = v8;
				*(x_DWORD *)(a1 + 12) = v9 & 0xFFFDFFF7;
				LOBYTE(v8) = *(x_BYTE *)(a1 + 14);
				*(x_BYTE *)(a1 + 69) = 1;
				*(x_BYTE *)(a1 + 14) = v8 | 2;
				sub_57D40(a1, a1 + 76);
			}
		}
		*(x_WORD *)(a1 + 98) = 0;
	}
	*(x_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
	result = sub_104D0((signed __int16 *)(a1 + 76));
	if (result == (int(*)())1)
	{
		v11 = sub_4A190(a1 + 76, 10, 5);
		if (v11)
			*(x_WORD *)(v11 + 26) = *(x_WORD *)(a1 + 26);
		sub_57F10(a1);
	}
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00064F60) --------------------------------------------------------
int(*sub_64F60(int a1))()
{
	int v1; // edx
	unsigned __int16 v2; // si
	int(*result)(); // eax
	int v4; // eax

	v1 = *(x_DWORD *)(a1 + 8) - 1;
	*(x_DWORD *)(a1 + 8) = v1;
	if (v1 < 60)
	{
		v2 = *(x_WORD *)(a1 + 90);
		*(x_BYTE *)(a1 + 69) = 2;
		if (v2 >= 0x53u)
		{
			if (v2 <= 0x53u)
			{
				sub_49DA0((x_WORD *)a1, 226);
			}
			else if (v2 == 84)
			{
				sub_49DA0((x_WORD *)a1, 227);
			}
		}
	}
	*(x_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
	result = sub_104D0((signed __int16 *)(a1 + 76));
	if (result == (int(*)())1)
	{
		v4 = sub_4A190(a1 + 76, 10, 5);
		if (v4)
			*(x_WORD *)(v4 + 26) = *(x_WORD *)(a1 + 26);
		sub_57F10(a1);
	}
	return result;
}

//----- (00064FF0) --------------------------------------------------------
int(*sub_64FF0(x_WORD *a1))()
{
	int(*result)(); // eax
	int v2; // eax

	a1[40] = sub_10C40(a1 + 38);
	result = sub_104D0(a1 + 38);
	if (result == (int(*)())1)
	{
		v2 = sub_4A190((int)(a1 + 38), 10, 5);
		if (v2)
			*(x_WORD *)(v2 + 26) = a1[13];
		sub_57F10((int)a1);
	}
	return result;
}

//----- (00065040) --------------------------------------------------------
int sub_65040(int a1)
{
	int result; // eax

	*(x_BYTE *)(a1 + 14) |= 2u;
	result = sub_10C40((__int16 *)(a1 + 76));
	*(x_WORD *)(a1 + 80) = result;
	return result;
}

//----- (00065080) --------------------------------------------------------
int sub_65080(int a1)
{
	unsigned __int16 v1; // di
	int v2; // esi
	int v3; // ebx
	int result; // eax

	v1 = 0;
	v2 = (int)x_D41A0_BYTEARRAY_0 + 11230;
	while (v1 < *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 14))
	{
		v3 = x_DWORD_EA3E4[*(unsigned __int16 *)(v2 + 10)];
		if (*(x_DWORD *)(v3 + 8) >= 0 && sub_106C0(v3, a1))
			*(x_BYTE *)(v3 + 13) |= 0x10u;
		v2 += 2124;
		++v1;
	}
	result = sub_10C40((__int16 *)(a1 + 76));
	*(x_WORD *)(a1 + 80) = result;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00065110) --------------------------------------------------------
int sub_65110(int a1)
{
	int result; // eax

	*(x_BYTE *)(a1 + 14) |= 2u;
	result = sub_10C40((__int16 *)(a1 + 76));
	*(x_WORD *)(a1 + 80) = result;
	return result;
}

//----- (000651B0) --------------------------------------------------------
int(*sub_651B0(int a1))()
{
	__int16 v1; // dx
	int v2; // edx
	__int16 v3; // ax
	char v4; // dl
	int(*result)(); // eax

	v1 = *(x_WORD *)(a1 + 98);
	*(x_BYTE *)(a1 + 14) |= 2u;
	if (v1)
	{
		v2 = *(x_DWORD *)(a1 + 8) - *(x_DWORD *)(a1 + 94);
		*(x_DWORD *)(a1 + 8) = v2;
		if (v2 < 0)
		{
			v3 = *(x_WORD *)(a1 + 90);
			*(x_WORD *)(a1 + 98) = 0;
			v4 = *(x_BYTE *)(a1 + 12);
			*(x_BYTE *)(a1 + 69) = 19;
			*(x_BYTE *)(a1 + 12) = v4 & 0xF7;
			sub_49DA0((x_WORD *)a1, v3 + 4);
			sub_4A190(a1 + 76, 10, 13);
		}
		*(x_WORD *)(a1 + 98) = 0;
	}
	*(x_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
	result = sub_104D0((signed __int16 *)(a1 + 76));
	if (result == (int(*)())1)
		sub_57F10(a1);
	return result;
}

//----- (00065240) --------------------------------------------------------
int(*sub_65240(int a1))()
{
	int(*result)(); // eax

	*(x_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
	result = sub_104D0((signed __int16 *)(a1 + 76));
	if (result == (int(*)())1)
		sub_57F10(a1);
	return result;
}

//----- (00065280) --------------------------------------------------------
void sub_65280(int a1)
{
	sub_652C0(a1);
}

//----- (000652A0) --------------------------------------------------------
void sub_652A0(int a1)
{
	sub_652C0(a1);
}

//----- (000652C0) --------------------------------------------------------
void sub_652C0(int a1)
{
	char v1; // ah
	__int16 v2; // dx
	__int16 v3; // cx
	__int16 v4; // di
	__int16 v5; // ax
	signed int v6; // esi
	signed int v7; // ecx
	signed int v8; // ecx
	__int16 v9; // ax
	unsigned int v10; // edx
	__int16 v11; // di
	__int16 v12; // ax
	int v13; // eax
	int v14; // edx

	v1 = *(x_BYTE *)(a1 + 13);
	if (v1 & 8)
	{
		*(x_BYTE *)(a1 + 13) = v1 & 0xF7;
	}
	else
	{
		*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
		*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
		if (*(signed __int16 *)(a1 + 80) > (signed __int16)sub_10C40((__int16 *)(a1 + 76)))
		{
			v2 = *(x_WORD *)(a1 + 130);
			if (v2)
				sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), 0, v2);
		}
		else
		{
			*(x_WORD *)(a1 + 130) = 0;
			sub_654B0(&x_WORD_EB398, a1);
		}
		sub_57CF0(a1, (int)&x_WORD_EB398);
		v3 = *(x_WORD *)(a1 + 130);
		if (v3)
			*(x_WORD *)(a1 + 130) = v3 - 1;
		v4 = *(x_WORD *)(a1 + 44) + *(x_WORD *)(a1 + 80);
		v5 = *(x_WORD *)(a1 + 44) - 24;
		*(x_WORD *)(a1 + 44) = v5;
		*(x_WORD *)(a1 + 80) = v4;
		if (v5 < -192)
			*(x_WORD *)(a1 + 44) = -192;
		if (*(x_WORD *)(a1 + 44) > 192)
			*(x_WORD *)(a1 + 44) = 192;
		v6 = (signed __int16)sub_10C40((__int16 *)(a1 + 76));
		if (*(signed __int16 *)(a1 + 80) <= v6)
			*(x_WORD *)(a1 + 80) = v6;
		if (*(x_WORD *)(a1 + 98))
		{
			if (*(signed __int16 *)(a1 + 80) <= v6)
			{
				v7 = *(x_DWORD *)(a1 + 94) >> 2;
				if (v7 < 2)
					v7 = 2;
				if (v7 > 192)
					v7 = 192;
				*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
				v8 = *(unsigned __int16 *)(a1 + 20) % (unsigned int)v7 + v7;
				v9 = 9377 * *(x_WORD *)(a1 + 20);
				*(x_WORD *)(a1 + 44) = v8;
				*(x_WORD *)(a1 + 20) = v9 + 9439;
				v10 = *(unsigned __int16 *)(a1 + 20) % (unsigned int)(v8 >> 1);
				*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
				v11 = *(x_WORD *)(a1 + 80);
				*(x_WORD *)(a1 + 28) = *(x_WORD *)(a1 + 20) & 0x7FF;
				v12 = *(x_WORD *)(a1 + 44);
				*(x_WORD *)(a1 + 130) = v10 + 1;
				*(x_WORD *)(a1 + 80) = v12 + v11;
			}
			v13 = *(x_DWORD *)(a1 + 94);
			v14 = *(x_DWORD *)(a1 + 8);
			*(x_WORD *)(a1 + 98) = 0;
			*(x_DWORD *)(a1 + 8) = v14 - v13;
		}
		if (*(x_DWORD *)(a1 + 8) < 0)
		{
			sub_4A190(a1 + 76, 10, 13);
			goto LABEL_27;
		}
		if (*(signed __int16 *)(a1 + 80) <= v6 && sub_104D0((signed __int16 *)(a1 + 76)) == (int(*)())1)
		{
			sub_4A190(a1 + 76, 10, 5);
		LABEL_27:
			sub_57F10(a1);
			return;
		}
	}
}
// EB398: using guessed type __int16 x_WORD_EB398;

//----- (000654B0) --------------------------------------------------------
int sub_654B0(signed __int16 *a1, int a2)
{
	int result; // eax
	void(/*__noreturn*/ *v3)(); // esi
	void(/*__noreturn*/ *v4)(); // eax
	int v5; // [esp+0h] [ebp-1Ch]
	__int16 v6; // [esp+4h] [ebp-18h]
	int v7; // [esp+8h] [ebp-14h]
	__int16 v8; // [esp+Ch] [ebp-10h]
	int v9; // [esp+10h] [ebp-Ch]
	void(/*__noreturn*/ *v10)(); // [esp+14h] [ebp-8h]
	int v11; // [esp+18h] [ebp-4h]

	result = sub_1B7A0(a1);
	if (result > 20)
	{
		v9 = 0;
		v5 = *(x_DWORD *)a1;
		v6 = a1[2];
		result = *(unsigned __int16 *)(a2 + 28);
		v10 = (void(*)())sub_10000;
		while (1)
		{
			v11 = result;
			if (v9 >= 8)
				break;
			v7 = *(x_DWORD *)a1;
			v8 = a1[2];
			sub_57FA0((x_WORD*)&v7, v11, 0, 64);
			v3 = v10;
			v4 = (void(/*__noreturn*/ *)())(signed __int16)sub_10C40((__int16 *)&v7);
			if ((signed __int16)v4 < (signed int)v3)
			{
				v10 = v4;
				v5 = v7;
				v6 = v8;
			}
			result = ((x_WORD)v11 + 256) & 0x7FF;
			++v9;
		}
		*(x_DWORD *)a1 = v5;
		a1[2] = v6;
	}
	return result;
}
// 10000: using guessed type void /*__noreturn*/ sub_10000();

//----- (00065580) --------------------------------------------------------
int sub_65580(int a1)
{
	int result; // eax

	result = a1;
	if (*(x_BYTE *)(a1 + 64) != 2)
		*(x_WORD *)(a1 + 80) += *(x_WORD *)(a1 + 82);
	return result;
}

//----- (000655A0) --------------------------------------------------------
int sub_655A0(int a1)
{
	int result; // eax

	result = a1;
	if (*(x_BYTE *)(a1 + 64) != 2)
		*(x_WORD *)(a1 + 80) -= *(x_WORD *)(a1 + 82);
	return result;
}

//----- (000655C0) --------------------------------------------------------
int sub_655C0(x_WORD *a1, int a2)
{
	sub_65580(a2);
	a1[16] = sub_581E0((Bit16u*)a1 + 38, (Bit16u*)(a2 + 76));
	a1[17] = sub_58210(a1 + 38, (x_WORD *)(a2 + 76));
	return sub_655A0(a2);
}

//----- (00065610) --------------------------------------------------------
int sub_65610(int a1, int a2)
{
	int v2; // ebx
	__int16 v3; // ax
	int v4; // esi
	__int16 v5; // ax
	int v6; // esi
	__int16 v7; // ax

	v2 = a1;
	sub_65580(a2);
	*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(a2 + 76));
	v3 = sub_58210((x_WORD *)(a1 + 76), (x_WORD *)(a2 + 76));
	v4 = *(x_DWORD *)(a1 + 160);
	*(x_WORD *)(a1 + 34) = v3;
	v5 = *(x_WORD *)(v2 + 28)
		+ sub_58350(*(x_WORD *)(v2 + 28), *(x_WORD *)(v2 + 32), *(unsigned __int16 *)(v4 + 4), *(x_WORD *)(v4 + 2));
	HIBYTE(v5) &= 7u;
	v6 = *(x_DWORD *)(a1 + 160);
	*(x_WORD *)(a1 + 28) = v5;
	v7 = *(x_WORD *)(v2 + 30)
		+ sub_58350(*(x_WORD *)(v2 + 30), *(x_WORD *)(v2 + 34), *(unsigned __int16 *)(v6 + 8), *(x_WORD *)(v6 + 6));
	HIBYTE(v7) &= 7u;
	*(x_WORD *)(a1 + 30) = v7;
	return sub_655A0(a2);
}

//----- (000656D0) --------------------------------------------------------
__int16 sub_656D0(int a1, int a2)
{
	int v2; // ebx
	__int16 v3; // ax
	int v4; // esi
	__int16 v5; // ax
	int v6; // esi
	__int16 result; // ax

	v2 = a1;
	*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(a2 + 76));
	v3 = sub_58210((x_WORD *)(a1 + 76), (x_WORD *)(a2 + 76));
	v4 = *(x_DWORD *)(a1 + 160);
	*(x_WORD *)(a1 + 34) = v3;
	v5 = *(x_WORD *)(v2 + 28)
		+ sub_58350(*(x_WORD *)(v2 + 28), *(x_WORD *)(v2 + 32), *(unsigned __int16 *)(v4 + 4), *(x_WORD *)(v4 + 2));
	HIBYTE(v5) &= 7u;
	v6 = *(x_DWORD *)(a1 + 160);
	*(x_WORD *)(a1 + 28) = v5;
	result = *(x_WORD *)(v2 + 30)
		+ sub_58350(*(x_WORD *)(v2 + 30), *(x_WORD *)(v2 + 34), *(unsigned __int16 *)(v6 + 8), *(x_WORD *)(v6 + 6));
	HIBYTE(result) &= 7u;
	*(x_WORD *)(a1 + 30) = result;
	return result;
}

//----- (00065780) --------------------------------------------------------
char sub_65780(int a1, unsigned int a2, unsigned int a3)
{
	int v3; // eax
	int v4; // ebx

	LOBYTE(v3) = *(x_BYTE *)(a1 + 64);
	if ((unsigned __int8)v3 < 0xCu)
	{
		if ((unsigned __int8)v3 < 3u)
		{
			if ((unsigned __int8)v3 > 1u)
				return v3;
		}
		else if ((unsigned __int8)v3 > 3u && ((unsigned __int8)v3 < 7u || (unsigned __int8)v3 > 9u))
		{
			return v3;
		}
	}
	else if ((unsigned __int8)v3 > 0xCu)
	{
		if ((unsigned __int8)v3 < 0x19u)
		{
			if ((x_BYTE)v3 != 17)
				return v3;
		}
		else if ((unsigned __int8)v3 > 0x19u && (x_BYTE)v3 != 28)
		{
			return v3;
		}
	}
	v3 = x_DWORD_EA3E4[*(signed __int16 *)(a1 + 26)];
	if (*(x_BYTE *)(v3 + 63) == 3 && !*(x_BYTE *)(v3 + 64))
	{
		++*(x_DWORD *)(*(x_DWORD *)(v3 + 164) + 357);
		if (a2 > x_DWORD_EA3E4[0] && a3 > x_DWORD_EA3E4[0] && *(x_WORD *)(a2 + 26) == *(x_WORD *)(a3 + 26))
		{
			v4 = *(x_DWORD *)(v3 + 164);
			if (v4)
				++*(x_DWORD *)(v4 + 361);
		}
	}
	return v3;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00065820) --------------------------------------------------------
int sub_65820(int a1)
{
	unsigned int v1; // eax
	char v2; // dl
	signed __int16 v3; // ax
	int v4; // eax
	unsigned int v5; // esi
	__int16 v6; // ax
	__int16 v7; // cx
	char v8; // al
	int v9; // eax
	int v10; // edi
	int v11; // edi
	unsigned int v13; // [esp+0h] [ebp-8h]
	char v14; // [esp+4h] [ebp-4h]

	v14 = 0;
	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
	v13 = v1;
	if (v1 <= x_DWORD_EA3E4[0])
	{
		v2 = *(x_BYTE *)(a1 + 12);
		if (!(v2 & 2))
		{
			*(x_BYTE *)(a1 + 12) = v2 | 2;
			if (sub_68940(a1) || sub_67CB0(a1))
			{
				*(x_WORD *)(a1 + 28) = *(x_WORD *)(a1 + 32);
				*(x_WORD *)(a1 + 30) = *(x_WORD *)(a1 + 34);
			}
			else
			{
				*(x_WORD *)(a1 + 32) = *(x_WORD *)(a1 + 28);
				*(x_WORD *)(a1 + 34) = *(x_WORD *)(a1 + 30);
			}
		}
	}
	else
	{
		sub_65610(a1, v1);
	}
	v3 = *(x_WORD *)(a1 + 132) - *(x_WORD *)(a1 + 130);
	if (*(signed __int16 *)(a1 + 132) != *(signed __int16 *)(a1 + 130))
	{
		if (*(signed __int16 *)(a1 + 132) - *(signed __int16 *)(a1 + 130) <= 0)
			v3 = -1;
		else
			v3 = 1;
	}
	*(x_WORD *)(a1 + 130) += 2 * v3;
	*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
	*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
	sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), *(x_WORD *)(a1 + 30), *(x_WORD *)(a1 + 130));
	sub_57CF0(a1, (int)&x_WORD_EB398);
	v4 = sub_10780(a1);
	v5 = v4;
	if (v4)
	{
		if (*(x_WORD *)(v4 + 12) & 0x8010 && sub_68740(a1, v4, 0x2Du, 22))
			return 0;
		sub_65580(v5);
		sub_57CF0(a1, v5 + 76);
		sub_655A0(v5);
		v14 = 1;
		goto LABEL_29;
	}
	v6 = sub_10C40((__int16 *)(a1 + 76));
	v7 = *(x_WORD *)(a1 + 80);
	x_WORD_EB39C = v6;
	if (v6 > v7
		|| x_BYTE_D41B6
		&& (x_WORD_EB39C = sub_10C60((__int16 *)(a1 + 76)) - *(x_WORD *)(a1 + 88), *(x_WORD *)(a1 + 80) > x_WORD_EB39C))
	{
		*(x_WORD *)(a1 + 80) = x_WORD_EB39C;
		v8 = *(x_BYTE *)(a1 + 64);
		if (v8 != 4 && v8 != 22 && v8 != 24 && v8 != 26 && sub_104D0((signed __int16 *)(a1 + 76)) == (int(*)())1)
		{
			v9 = sub_4A190(a1 + 76, 10, 5);
			if (v9)
				*(x_WORD *)(v9 + 26) = *(x_WORD *)(a1 + 26);
			sub_57F10(a1);
			goto LABEL_29;
		}
		goto LABEL_28;
	}
	v10 = *(x_DWORD *)(a1 + 8) - 1;
	*(x_DWORD *)(a1 + 8) = v10;
	if (v10 < 0)
		LABEL_28:
	v14 = 1;
LABEL_29:
	if (!v14)
		return 0;
	if (sub_68AC0(a1, v5))
	{
		sub_57F10(a1);
		return 0;
	}
	v11 = sub_4A190(a1 + 76, *(char *)(a1 + 67), *(char *)(a1 + 68));
	if (!v11)
		return 0;
	sub_65780(a1, v5, v13);
	sub_686D0(a1, v5);
	if (v5 > x_DWORD_EA3E4[0] && *(x_WORD *)(a1 + 38))
		sub_6D8B0(*(x_WORD *)(a1 + 26), *(char *)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 38)] + 64), 1);
	if (*(x_BYTE *)(a1 + 68) == 34)
		*(x_DWORD *)(v11 + 8) = *(unsigned __int16 *)(a1 + 42);
	*(x_WORD *)(v11 + 26) = *(x_WORD *)(a1 + 26);
	*(x_WORD *)(v11 + 28) = *(x_WORD *)(a1 + 28);
	*(x_WORD *)(v11 + 30) = *(x_WORD *)(a1 + 30);
	if (v5)
		*(x_WORD *)(v11 + 150) = (signed int)(v5 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
	*(x_WORD *)(v11 + 42) = *(x_WORD *)(a1 + 42);
	*(x_BYTE *)(v11 + 70) = *(x_BYTE *)(a1 + 70);
	sub_57F10(a1);
	return v11;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41B6: using guessed type char x_BYTE_D41B6;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (00065B30) --------------------------------------------------------
void sub_65B30(int a1)
{
	//int result; // eax

	if (sub_65C20(a1))
		sub_57F10(a1);
	//return result;
}

//----- (00065B50) --------------------------------------------------------
void sub_65B50(int a1)
{
	//int result; // eax
	int v2; // esi
	__int16 v3; // bx
	__int16 v4; // dx
	int v5; // eax
	unsigned int i; // ebx
	char v7; // [esp+0h] [ebp-4h]

	v7 = 0;
	v2 = sub_65C20(a1);
	//v2 = result;
	if (v2)
	{
		v3 = *(x_WORD *)(a1 + 150);
		*(x_DWORD *)(v2 + 4) = 30;
		*(x_WORD *)(v2 + 150) = v3;
		v4 = *(x_WORD *)(v2 + 26);
		*(x_DWORD *)(v2 + 8) = *(x_DWORD *)(v2 + 4);
		if (v4)
		{
			v5 = x_DWORD_EA3E4[v4];
			if (*(x_BYTE *)(v5 + 63) == 3
				&& !*(x_BYTE *)(v5 + 64)
				&& *(x_WORD *)(*(x_DWORD *)(v5 + 164) + 56) == *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12))
			{
				v7 = 1;
			}
		}
		for (i = x_DWORD_EA3E4[*(unsigned __int16 *)(v2 + 52)];
			i > x_DWORD_EA3E4[0];
			i = x_DWORD_EA3E4[*(unsigned __int16 *)(i + 52)])
		{
			*(x_WORD *)(i + 26) = *(x_WORD *)(v2 + 26);
			if (v7)
				sub_49C90(i, 42);
		}
		sub_57F10(a1);
	}
	//return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00065C20) --------------------------------------------------------
int sub_65C20(int a1)
{
	unsigned int v1; // eax
	char v2; // dl
	signed __int16 v3; // si
	__int16 v4; // dx
	__int16 v5; // ax
	signed __int16 v6; // si
	__int16 v7; // cx
	int v8; // eax
	unsigned int v9; // esi
	__int16 v11; // ax
	__int16 v12; // dx
	int v13; // eax
	int v14; // edi
	x_WORD *v15; // edi
	int v16; // [esp+0h] [ebp-14h]
	__int16 v17; // [esp+4h] [ebp-10h]
	x_WORD *v18; // [esp+8h] [ebp-Ch]
	unsigned int v19; // [esp+Ch] [ebp-8h]
	char v20; // [esp+10h] [ebp-4h]

	v20 = 0;
	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
	v18 = 0;
	v19 = v1;
	if (v1 > x_DWORD_EA3E4[0])
	{
		sub_65610(a1, v1);
		goto LABEL_18;
	}
	v2 = *(x_BYTE *)(a1 + 12);
	if (!(v2 & 2))
	{
		*(x_BYTE *)(a1 + 12) = v2 | 2;
		if (sub_68940(a1))
		{
			v6 = sub_582B0(*(x_WORD *)(a1 + 28), *(x_WORD *)(a1 + 32));
			if (v6 < 0)
				v6 = 0;
			if (v6 > 34)
				v6 = 34;
			v7 = v6 * sub_582F0(*(unsigned __int16 *)(a1 + 28), *(x_WORD *)(a1 + 32)) + *(x_WORD *)(a1 + 28);
			v5 = *(x_WORD *)(a1 + 34);
			*(x_WORD *)(a1 + 28) = v7;
		}
		else
		{
			if (!sub_67CB0(a1))
			{
				*(x_WORD *)(a1 + 32) = *(x_WORD *)(a1 + 28);
				*(x_WORD *)(a1 + 34) = *(x_WORD *)(a1 + 30);
				goto LABEL_18;
			}
			v3 = sub_582B0(*(x_WORD *)(a1 + 28), *(x_WORD *)(a1 + 32));
			if (v3 < 0)
				v3 = 0;
			if (v3 > 34)
				v3 = 34;
			v4 = v3 * sub_582F0(*(unsigned __int16 *)(a1 + 28), *(x_WORD *)(a1 + 32)) + *(x_WORD *)(a1 + 28);
			v5 = *(x_WORD *)(a1 + 34);
			*(x_WORD *)(a1 + 28) = v4;
		}
		*(x_WORD *)(a1 + 30) = v5;
	}
LABEL_18:
	v16 = *(x_DWORD *)(a1 + 76);
	v17 = *(x_WORD *)(a1 + 80);
	*(x_DWORD *)&x_WORD_EB398 = v16;
	*(&x_WORD_EB398 + 2) = v17;
	sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), *(x_WORD *)(a1 + 30), *(x_WORD *)(a1 + 130));
	sub_57CF0(a1, (int)&x_WORD_EB398);
	v8 = sub_10780(a1);
	v9 = v8;
	if (!v8)
	{
		v11 = sub_10C40((__int16 *)(a1 + 76));
		v12 = *(x_WORD *)(a1 + 80);
		x_WORD_EB39C = v11;
		if (v11 > v12
			|| x_BYTE_D41B6
			&& (x_WORD_EB39C = sub_10C60((__int16 *)(a1 + 76)) - *(x_WORD *)(a1 + 88), *(x_WORD *)(a1 + 80) > x_WORD_EB39C))
		{
			v17 = x_WORD_EB39C;
			sub_57CF0(a1, (int)&v16);
			if (*(x_BYTE *)(a1 + 64) != 4 && sub_104D0((signed __int16 *)(a1 + 76)) == (int(*)())1)
			{
				v13 = sub_4A190(a1 + 76, 10, 5);
				if (v13)
					*(x_WORD *)(v13 + 26) = *(x_WORD *)(a1 + 26);
				sub_57F10(a1);
				goto LABEL_35;
			}
		}
		else
		{
			v14 = *(x_DWORD *)(a1 + 8) - 1;
			*(x_DWORD *)(a1 + 8) = v14;
			if (v14 >= 0)
				goto LABEL_35;
		}
		v20 = 1;
		goto LABEL_35;
	}
	if (*(x_WORD *)(v8 + 12) & 0x8010)
	{
		if (sub_68740(a1, v8, 0x5Bu, 45))
			return 0;
	}
	else
	{
		if (*(x_BYTE *)(*(x_DWORD *)(v8 + 160) + 32) & 0x10)
			*(x_WORD *)(a1 + 42) = 1;
		sub_65580(v8);
		sub_57CF0(a1, v9 + 76);
		sub_655A0(v9);
		v20 = 1;
	}
LABEL_35:
	if (v20)
	{
		if (sub_68AC0(a1, v9))
		{
			sub_57F10(a1);
		}
		else
		{
			v18 = (x_WORD *)sub_4A190(a1 + 76, *(char *)(a1 + 67), *(char *)(a1 + 68));
			if (v18)
			{
				sub_65780(a1, v9, v19);
				sub_686D0(a1, v9);
				if (v9 > x_DWORD_EA3E4[0])
					sub_6D8B0(*(x_WORD *)(a1 + 26), 0, 1);
				v15 = v18;
				v18[21] = *(x_WORD *)(a1 + 42);
				v15[13] = *(x_WORD *)(a1 + 26);
				v15[14] = *(x_WORD *)(a1 + 28);
				v15[15] = *(x_WORD *)(a1 + 30);
				if (!v9)
					*(x_WORD *)(a1 + 150) = 0;
			}
		}
	}
	return (int)v18;
}
// D41B6: using guessed type char x_BYTE_D41B6;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (00065F60) --------------------------------------------------------
void sub_65F60(int a1)
{
	unsigned int v1; // eax
	char v2; // dl
	__int16 v3; // ax
	__int16 v4; // ax
	int v5; // eax
	int v6; // esi
	unsigned int v7; // edi
	int v8; // eax
	signed __int16 v9; // dx
	signed __int16 v10; // cx
	int v11; // esi
	x_WORD *v12; // esi
	unsigned int v14; // [esp+0h] [ebp-8h]
	char v15; // [esp+4h] [ebp-4h]

	v15 = 0;
	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
	v14 = v1;
	if (v1 <= x_DWORD_EA3E4[0])
	{
		v2 = *(x_BYTE *)(a1 + 12);
		if (!(v2 & 2))
		{
			*(x_BYTE *)(a1 + 12) = v2 | 2;
			if (sub_67CB0(a1))
			{
				*(x_WORD *)(a1 + 28) = *(x_WORD *)(a1 + 32);
				*(x_WORD *)(a1 + 30) = *(x_WORD *)(a1 + 34);
			}
		}
	}
	else
	{
		sub_65610(a1, v1);
	}
	*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
	*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
	sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), *(x_WORD *)(a1 + 30), *(x_WORD *)(a1 + 130));
	v3 = sub_10C40(&x_WORD_EB398);
	if (v3 > x_WORD_EB39C)
		x_WORD_EB39C = v3;
	if (x_BYTE_D41B6)
	{
		v4 = sub_10C60(&x_WORD_EB398) - *(x_WORD *)(a1 + 88);
		if (v4 < x_WORD_EB39C)
			x_WORD_EB39C = v4;
	}
	sub_57CF0(a1, (int)&x_WORD_EB398);
	v5 = sub_108B0(a1);
	v6 = v5;
	v7 = v5;
	if (!v5)
	{
		LOWORD(v8) = sub_10C40((__int16 *)(a1 + 76));
		v9 = *(x_WORD *)(a1 + 80);
		x_WORD_EB39C = v8;
		if ((signed __int16)v8 > v9
			|| x_BYTE_D41B6
			&& (LOWORD(v8) = sub_10C60((__int16 *)(a1 + 76)) - *(x_WORD *)(a1 + 88),
				x_WORD_EB39C = v8,
				v10 = v8,
				LOWORD(v8) = *(x_WORD *)(a1 + 80),
				(signed __int16)v8 > v10))
		{
			LOWORD(v8) = x_WORD_EB39C;
			*(x_WORD *)(a1 + 80) = x_WORD_EB39C;
		}
		else
		{
			v11 = *(x_DWORD *)(a1 + 8) - 1;
			*(x_DWORD *)(a1 + 8) = v11;
			if (v11 >= 0)
				goto LABEL_19;
		}
		v15 = 1;
		goto LABEL_19;
	}
	sub_65580(v5);
	sub_57CF0(a1, v6 + 76);
	LOWORD(v8) = sub_655A0(v6);
	v15 = 1;
LABEL_19:
	if (v15)
	{
		v8 = sub_4A190(a1 + 76, *(char *)(a1 + 67), *(char *)(a1 + 68));
		v12 = (x_WORD *)v8;
		if (v8)
		{
			sub_65780(a1, v7, v14);
			if (v7 > x_DWORD_EA3E4[0])
				sub_6D8B0(*(x_WORD *)(a1 + 26), 1u, 1);
			v12[13] = *(x_WORD *)(a1 + 26);
			v12[14] = *(x_WORD *)(a1 + 28);
			v12[15] = *(x_WORD *)(a1 + 30);
			sub_57F10(a1);
		}
	}
	return;
}
// D41B6: using guessed type char x_BYTE_D41B6;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (00066160) --------------------------------------------------------
int sub_66160(int a1)
{
	int result; // eax

	result = sub_65820(a1);
	if (result)
		*(x_DWORD *)(result + 8) = *(char *)(a1 + 70);
	return result;
}

//----- (00066180) --------------------------------------------------------
int sub_66180(int a1)
{
	int v1; // esi
	int result; // eax
	__int16 v3; // dx
	__int16 v4; // [esp+0h] [ebp-8h]
	__int16 v5; // [esp+2h] [ebp-6h]
	__int16 v6; // [esp+4h] [ebp-4h]

	result = sub_65820(a1);
	v1 = result;
	BYTE1(result) = *(x_BYTE *)(a1 + 63);
	if (BYTE1(result))
	{
		*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
		v4 = *(x_WORD *)(a1 + 20) % 0x81u + *(x_WORD *)(a1 + 76) - 96 - 64;
		*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
		v5 = *(x_WORD *)(a1 + 20) % 0x81u + *(x_WORD *)(a1 + 78) - 96 - 64;
		v6 = *(x_WORD *)(a1 + 80);
		result = sub_4A190((int)&v4, 10, 0);
		if (result)
		{
			*(x_DWORD *)(result + 12) |= (unsigned int)sub_10080;
			*(x_WORD *)(result + 26) = *(x_WORD *)(a1 + 26);
			v3 = *(x_WORD *)(a1 + 28);
			*(x_DWORD *)(result + 8) = 4;
			*(x_BYTE *)(result + 92) = 3;
			*(x_WORD *)(result + 28) = v3;
		}
		if (v1)
		{
			result = *(char *)(a1 + 70);
			*(x_DWORD *)(v1 + 4) = result;
			*(x_DWORD *)(v1 + 8) = result;
		}
	}
	return result;
}

//----- (00066250) --------------------------------------------------------
int sub_66250(int a1)
{
	int result; // eax
	int v2; // edx

	result = sub_65820(a1);
	if (result)
	{
		v2 = *(char *)(a1 + 70);
		*(x_BYTE *)(result + 70) = 0;
		*(x_DWORD *)(result + 4) = v2;
	}
	return result;
}

//----- (00066280) --------------------------------------------------------
int sub_66280(int a1)
{
	int result; // eax

	result = sub_65820(a1);
	if (result)
		*(x_DWORD *)(result + 8) = *(char *)(a1 + 70);
	return result;
}

//----- (000662A0) --------------------------------------------------------
int sub_662A0(int a1)
{
	return sub_65820(a1);
}

//----- (000662C0) --------------------------------------------------------
char sub_662C0(int a1)
{
	return sub_662E0(a1);
}

//----- (000662E0) --------------------------------------------------------
char sub_662E0(int a1)
{
	unsigned int v1; // eax
	char v2; // dl
	signed __int16 v3; // ax
	int v4; // eax
	unsigned int v5; // esi
	int(*v6)(); // eax
	signed __int16 v7; // cx
	signed __int16 v8; // di
	int v9; // eax
	int v10; // edi
	char v11; // al
	int(*v12)(); // edi
	unsigned int v14; // [esp+0h] [ebp-8h]
	char v15; // [esp+4h] [ebp-4h]

	v15 = 0;
	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
	v14 = v1;
	if (v1 <= x_DWORD_EA3E4[0])
	{
		v2 = *(x_BYTE *)(a1 + 12);
		if (!(v2 & 2))
		{
			*(x_BYTE *)(a1 + 12) = v2 | 2;
			if (sub_68940(a1) || sub_67CB0(a1))
			{
				*(x_WORD *)(a1 + 28) = *(x_WORD *)(a1 + 32);
				*(x_WORD *)(a1 + 30) = *(x_WORD *)(a1 + 34);
			}
			else
			{
				*(x_WORD *)(a1 + 32) = *(x_WORD *)(a1 + 28);
				*(x_WORD *)(a1 + 34) = *(x_WORD *)(a1 + 30);
			}
		}
	}
	else
	{
		sub_65610(a1, v1);
	}
	v3 = *(x_WORD *)(a1 + 132) - *(x_WORD *)(a1 + 130);
	if (*(signed __int16 *)(a1 + 132) != *(signed __int16 *)(a1 + 130))
	{
		if (*(signed __int16 *)(a1 + 132) - *(signed __int16 *)(a1 + 130) <= 0)
			v3 = -1;
		else
			v3 = 1;
	}
	*(x_WORD *)(a1 + 130) += 2 * v3;
	*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
	*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
	sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), *(x_WORD *)(a1 + 30), *(x_WORD *)(a1 + 130));
	sub_57CF0(a1, (int)&x_WORD_EB398);
	v4 = sub_10780(a1);
	v5 = v4;
	if (v4)
	{
		if (*(x_WORD *)(v4 + 12) & 0x8010)
		{
			LOBYTE(v6) = sub_68740(a1, v4, 0x2Du, 22);
			if ((x_BYTE)v6)
				return (char)v6;
		}
		sub_65580(v5);
		sub_57CF0(a1, v5 + 76);
		LOBYTE(v6) = sub_655A0(v5);
		v15 = 1;
	}
	else
	{
		LOWORD(v6) = sub_10C40((__int16 *)(a1 + 76));
		v7 = *(x_WORD *)(a1 + 80);
		x_WORD_EB39C = (signed __int16)v6;
		if ((signed __int16)v6 > v7
			|| x_BYTE_D41B6
			&& (LOWORD(v6) = sub_10C60((__int16 *)(a1 + 76)) - *(x_WORD *)(a1 + 88),
				x_WORD_EB39C = (signed __int16)v6,
				v8 = (signed __int16)v6,
				LOWORD(v6) = *(x_WORD *)(a1 + 80),
				(signed __int16)v6 > v8))
		{
			LOBYTE(v6) = x_WORD_EB39C;
			*(x_WORD *)(a1 + 80) = x_WORD_EB39C;
			if (*(x_BYTE *)(a1 + 64) != 4)
			{
				v6 = sub_104D0((signed __int16 *)(a1 + 76));
				if (v6 == (int(*)())1)
				{
					v9 = sub_4A190(a1 + 76, 10, 5);
					if (v9)
						*(x_WORD *)(v9 + 26) = *(x_WORD *)(a1 + 26);
					sub_57F10(a1);
					goto LABEL_26;
				}
			}
		}
		else
		{
			v10 = *(x_DWORD *)(a1 + 8) - 1;
			*(x_DWORD *)(a1 + 8) = v10;
			if (v10 >= 0)
				goto LABEL_26;
		}
		v15 = 1;
	}
LABEL_26:
	if (v15)
	{
		if (sub_68AC0(a1, v5))
		{
			sub_57F10(a1);
		}
		else if (!v5 || *(x_BYTE *)(v5 + 63) != 3 || (v11 = *(x_BYTE *)(v5 + 64)) != 0 && v11 != 1)
		{
			sub_65780(a1, 0, v14);
			sub_57F10(a1);
		}
		else
		{
			v6 = (int(*)())sub_4A190(a1 + 76, *(char *)(a1 + 67), *(char *)(a1 + 68));
			v12 = v6;
			if (v6)
			{
				sub_65780(a1, v5, v14);
				sub_686D0(a1, v5);
				if (v5 > x_DWORD_EA3E4[0] && *(x_WORD *)(a1 + 38))
					sub_6D8B0(*(x_WORD *)(a1 + 26), *(char *)(x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 38)] + 64), 1);
				if (*(x_BYTE *)(a1 + 68) == 34)
					*((x_DWORD *)v12 + 2) = *(unsigned __int16 *)(a1 + 42);
				*((x_WORD *)v12 + 13) = *(x_WORD *)(a1 + 26);
				*((x_WORD *)v12 + 14) = *(x_WORD *)(a1 + 28);
				*((x_WORD *)v12 + 15) = *(x_WORD *)(a1 + 30);
				*((x_WORD *)v12 + 75) = (signed int)(v5 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
				*((x_WORD *)v12 + 21) = *(x_WORD *)(a1 + 42);
				*((x_BYTE *)v12 + 70) = *(x_BYTE *)(a1 + 70);
				sub_57F10(a1);
			}
		}
	}
	return (char)v6;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41B6: using guessed type char x_BYTE_D41B6;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (00066610) --------------------------------------------------------
void sub_66610(int a1)
{
	char v1; // dl
	int v2; // eax
	signed __int16 v3; // dx
	signed __int16 v4; // cx
	int v5; // ecx
	char v7; // [esp+0h] [ebp-4h]

	v7 = 0;
	if (x_DWORD_EA3E4[0] >= (unsigned int)x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)])
	{
		v1 = *(x_BYTE *)(a1 + 12);
		if (!(v1 & 2))
		{
			*(x_BYTE *)(a1 + 12) = v1 | 2;
			if (sub_68940(a1) || sub_67CB0(a1))
			{
				*(x_WORD *)(a1 + 28) = *(x_WORD *)(a1 + 32);
				*(x_WORD *)(a1 + 30) = *(x_WORD *)(a1 + 34);
			}
			else
			{
				*(x_WORD *)(a1 + 32) = *(x_WORD *)(a1 + 28);
				*(x_WORD *)(a1 + 34) = *(x_WORD *)(a1 + 30);
			}
		}
	}
	*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
	*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
	sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), *(x_WORD *)(a1 + 30), *(x_WORD *)(a1 + 130));
	*(x_DWORD *)(a1 + 76) = *(x_DWORD *)&x_WORD_EB398;
	*(x_WORD *)(a1 + 80) = *(&x_WORD_EB398 + 2);
	v2 = sub_10780(a1);
	if (v2)
	{
		v7 = 1;
		*(x_DWORD *)(a1 + 76) = *(x_DWORD *)(v2 + 76);
		*(x_WORD *)(a1 + 80) = *(x_WORD *)(v2 + 80);
	}
	else
	{
		LOWORD(v2) = sub_10C40((__int16 *)(a1 + 76));
		v3 = *(x_WORD *)(a1 + 80);
		x_WORD_EB39C = v2;
		if ((signed __int16)v2 > v3
			|| x_BYTE_D41B6
			&& (LOWORD(v2) = sub_10C60((__int16 *)(a1 + 76)) - *(x_WORD *)(a1 + 88),
				x_WORD_EB39C = v2,
				v4 = v2,
				LOWORD(v2) = *(x_WORD *)(a1 + 80),
				(signed __int16)v2 > v4)
			|| (v5 = *(x_DWORD *)(a1 + 8) - 1, *(x_DWORD *)(a1 + 8) = v5, v5 < 0))
		{
			v7 = 1;
		}
	}
	if (v7)
		sub_57F10(a1);
	//return v2;
}
// D41B6: using guessed type char x_BYTE_D41B6;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (00066750) --------------------------------------------------------
__int16 sub_66750(unsigned int a1)
{
	__int16 v1; // di
	__int16 v2; // si
	int v3; // edx
	__int16 v4; // ST08_2
	unsigned __int16 v5; // ST04_2
	unsigned int v6; // eax
	int v7; // esi
	signed __int16 v8; // cx
	int v9; // esi
	int v10; // esi
	int v11; // esi
	unsigned __int16 v12; // ax
	unsigned int v13; // esi
	int v14; // eax
	x_WORD *v15; // edi
	char v16; // cl
	int v18; // [esp+0h] [ebp-2Ch]
	__int16 v19; // [esp+4h] [ebp-28h]
	int v20; // [esp+8h] [ebp-24h]
	__int16 v21; // [esp+Ch] [ebp-20h]
	int v22; // [esp+10h] [ebp-1Ch]
	int v23; // [esp+14h] [ebp-18h]
	unsigned int v24; // [esp+18h] [ebp-14h]
	int v25; // [esp+1Ch] [ebp-10h]
	int v26; // [esp+20h] [ebp-Ch]
	int v27; // [esp+24h] [ebp-8h]
	int v28; // [esp+28h] [ebp-4h]

	*(x_WORD *)(a1 + 130) = *(x_WORD *)(a1 + 132);
	v18 = *(x_DWORD *)(a1 + 76);
	v19 = *(x_WORD *)(a1 + 80);
	sub_57E50(a1);
	sub_66610(a1);
	v1 = *(x_WORD *)(a1 + 28);
	v2 = *(x_WORD *)(a1 + 30);
	v27 = 1;
	while (!(*(x_BYTE *)(a1 + 13) & 4))
	{
		sub_66610(a1);
		++v27;
	}
	*(x_WORD *)(a1 + 28) = v1;
	*(x_WORD *)(a1 + 30) = v2;
	v22 = 0;
	LOWORD(v23) = 0;
	v3 = *(signed __int16 *)(a1 + 130);
	v27 *= 8;
	v26 = (v3 - (__CFSHL__(v3 >> 31, 3) + 8 * (v3 >> 31))) >> 3;
	v4 = *(x_WORD *)(a1 + 30);
	v5 = *(x_WORD *)(a1 + 28);
	v25 = 0;
	v28 = 0;
	sub_57FA0((x_WORD*)&v22, v5, v4, v26);
	*(x_DWORD *)&x_WORD_EB398 = v18;
	*(&x_WORD_EB398 + 2) = v19;
	v20 = v18;
	v21 = v19;
	while ((v27 & 0x8000u) == 0)
	{
		v6 = sub_4A050();
		v7 = v6;
		if (v6)
		{
			*(x_BYTE *)(v6 + 69) = 14;
			*(x_BYTE *)(v6 + 63) = 9;
			*(x_BYTE *)(v6 + 64) = 9;
			*(x_WORD *)(v6 + 26) = *(x_WORD *)(a1 + 26);
			*(x_DWORD *)(v6 + 4) = (v6 >= a1) - 1;
			sub_49CD0((x_WORD *)v6, 216);
			sub_57D70(v7, (int)&v20);
			sub_49A20(v7);
		}
		v8 = (signed __int16)v27 / 2;
		if ((signed __int16)v27 / 2 < 0)
			v8 = 0;
		if (v8 > 8)
			v8 = 8;
		if (v8 >= (signed __int16)v28)
		{
			v10 = (signed __int16)v28;
			if ((signed __int16)v28 < -v8)
			{
				++v28;
				goto LABEL_17;
			}
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			v9 = 2 * ((signed int)(*(unsigned __int16 *)(a1 + 20) % 0x9Du) / 79) - 1 + v10;
		}
		else
		{
			v9 = v28 - 1;
		}
		v28 = v9;
	LABEL_17:
		if (v8 >= (signed __int16)v25)
		{
			v11 = (signed __int16)v25;
			if ((signed __int16)v25 >= -v8)
			{
				*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
				v25 = 2 * ((signed int)(*(unsigned __int16 *)(a1 + 20) % 0x9Du) / 79) - 1 + v11;
			}
			else
			{
				++v25;
			}
		}
		else
		{
			--v25;
		}
		x_WORD_EB398 += v22;
		x_WORD_EB39A += HIWORD(v22);
		x_WORD_EB39C += v23;
		v20 = *(x_DWORD *)&x_WORD_EB398;
		v21 = *(&x_WORD_EB398 + 2);
		v21 = v28
			* (((signed __int16)v26 - (__CFSHL__((signed __int16)v26 >> 31, 2) + 4 * ((signed __int16)v26 >> 31))) >> 2)
			+ x_WORD_EB39C;
		v12 = *(x_WORD *)(a1 + 28);
		HIBYTE(v12) = (HIBYTE(v12) + 2) & 7;
		sub_57FA0(
			(x_WORD*)&v20,
			v12,
			0,
			v28 * (((signed __int16)v26 - (__CFSHL__((signed __int16)v26 >> 31, 2) + 4 * ((signed __int16)v26 >> 31))) >> 2));
		--v27;
	}
	v13 = sub_10780(a1);
	v24 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
	v14 = sub_4A190((int)&v20, *(char *)(a1 + 67), *(char *)(a1 + 68));
	v15 = (x_WORD *)v14;
	if (!v14)
		return v14;
	sub_65780(a1, v13, v24);
	sub_686D0(a1, v13);
	sub_68AC0(a1, v13);
	if (v13 > x_DWORD_EA3E4[0])
		sub_6D8B0(*(x_WORD *)(a1 + 26), 7u, 1);
	v15[13] = *(x_WORD *)(a1 + 26);
	v15[14] = *(x_WORD *)(a1 + 28);
	v15[15] = *(x_WORD *)(a1 + 30);
	v16 = 0;
	v14 = (signed int)(v13 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
	v15[75] = v14;
	if (!v13 || *(x_BYTE *)(v13 + 63) != 3 || !(*(x_WORD *)(v13 + 12) & 0x8010))
	{
	LABEL_35:
		v16 = 1;
		goto LABEL_36;
	}
	if (*(x_BYTE *)(v13 + 13) >= 0)
	{
		v14 = (*(x_DWORD *)(a1 + 144) - (__CFSHL__(*(x_DWORD *)(a1 + 144) >> 31, 3) + 8 * (*(x_DWORD *)(a1 + 144) >> 31))) >> 3;
		if (v14 <= *(x_DWORD *)(v13 + 144))
		{
			v14 = *(unsigned __int16 *)(a1 + 42) / 2;
			v15[21] = v14;
			goto LABEL_36;
		}
		goto LABEL_35;
	}
	v14 = (*(x_DWORD *)(a1 + 144) - (__CFSHL__(*(x_DWORD *)(a1 + 144) >> 31, 2) + 4 * (*(x_DWORD *)(a1 + 144) >> 31))) >> 2;
	if (v14 > *(x_DWORD *)(v13 + 144))
		goto LABEL_35;
	v14 = (signed int)*(unsigned __int16 *)(a1 + 42) >> 2;
	v15[21] = v14;
LABEL_36:
	if (v16)
	{
		LOWORD(v14) = *(x_WORD *)(a1 + 42);
		v15[21] = v14;
	}
	return v14;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39A: using guessed type __int16 x_WORD_EB39A;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (00066B30) --------------------------------------------------------
char sub_66B30(int a1)
{
	unsigned int v1; // eax
	__int16 v2; // ax
	int v3; // eax
	__int16 v4; // dx
	__int16 v5; // ax
	__int16 v6; // cx
	int v7; // edi
	int v8; // eax
	int v10; // [esp+0h] [ebp-8h]
	char v11; // [esp+4h] [ebp-4h]

	v11 = 0;
	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
	v10 = v1;
	if (v1 > x_DWORD_EA3E4[0])
	{
		sub_656D0(a1, v1);
		v3 = *(signed __int16 *)(a1 + 132) - *(signed __int16 *)(a1 + 130);
		if (*(signed __int16 *)(a1 + 132) != *(signed __int16 *)(a1 + 130))
		{
			if (v3 <= 0)
				LOWORD(v3) = -1;
			else
				LOWORD(v3) = 1;
		}
		*(x_WORD *)(a1 + 130) += 2 * v3;
		*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
		*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
		sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), *(x_WORD *)(a1 + 30), *(x_WORD *)(a1 + 130));
		sub_57CF0(a1, (int)&x_WORD_EB398);
		if (sub_106C0(a1, v10))
		{
			LOBYTE(v2) = sub_57CF0(a1, v10 + 76);
			v11 = 1;
		}
		else
		{
			v2 = sub_10C40((__int16 *)(a1 + 76));
			v4 = *(x_WORD *)(a1 + 80);
			x_WORD_EB39C = v2;
			if (v2 > v4
				|| x_BYTE_D41B6
				&& (v5 = sub_10C60((__int16 *)(a1 + 76)) - *(x_WORD *)(a1 + 88),
					x_WORD_EB39C = v5,
					v6 = v5,
					v2 = *(x_WORD *)(a1 + 80),
					v2 > v6))
			{
				LOBYTE(v2) = x_WORD_EB39C;
				v11 = 1;
				*(x_WORD *)(a1 + 80) = x_WORD_EB39C;
			}
			else
			{
				v7 = *(x_DWORD *)(a1 + 8) - 1;
				*(x_DWORD *)(a1 + 8) = v7;
				if (v7 < 0)
					v11 = 1;
			}
		}
		if (v11)
		{
			if (*(x_BYTE *)(a1 + 67) == 3 && *(x_WORD *)(*(x_DWORD *)(x_DWORD_EA3E4[*(signed __int16 *)(a1 + 26)] + 164) + 58))
			{
				sub_57F10(a1);
			}
			else
			{
				v8 = sub_4A190(a1 + 76, *(char *)(a1 + 67), *(char *)(a1 + 68));
				if (v8)
				{
					*(x_WORD *)(v8 + 26) = *(x_WORD *)(a1 + 26);
					sub_57F10(a1);
				}
				else
				{
					LOBYTE(v2) = sub_5F890(x_DWORD_EA3E4[*(signed __int16 *)(a1 + 26)], 0);
				}
			}
		}
	}
	else
	{
		LOBYTE(v2) = sub_66D00(a1);
	}
	return v2;
}
// D41B6: using guessed type char x_BYTE_D41B6;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (00066D00) --------------------------------------------------------
char sub_66D00(int a1)
{
	char v1; // dh
	int v2; // eax
	__int16 v3; // ax
	__int16 v4; // ax
	signed __int16 v5; // ax
	unsigned __int16 v6; // ax
	unsigned int v7; // esi
	signed __int16 v8; // di
	signed __int16 v9; // dx
	int v10; // ecx
	unsigned __int16 v11; // ax
	char v13; // [esp+0h] [ebp-8h]
	char v14; // [esp+4h] [ebp-4h]

	v1 = *(x_BYTE *)(a1 + 12);
	v13 = 0;
	v14 = 0;
	if (!(v1 & 2))
	{
		*(x_BYTE *)(a1 + 12) = v1 | 2;
		LOBYTE(v2) = sub_11CB0((__int16 *)(a1 + 76));
		if (!(x_BYTE)v2)
		{
			sub_5F890(a1, 0);
			sub_57F10(a1);
			LOBYTE(v2) = sub_88D00();
		}
		return v2;
	}
	*(x_WORD *)(a1 + 32) = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(a1 + 154));
	*(x_WORD *)(a1 + 34) = sub_58210((x_WORD *)(a1 + 76), (x_WORD *)(a1 + 154));
	v3 = *(x_WORD *)(a1 + 28)
		+ sub_58350(
			*(x_WORD *)(a1 + 28),
			*(x_WORD *)(a1 + 32),
			*(unsigned __int16 *)(*(x_DWORD *)(a1 + 160) + 4),
			*(x_WORD *)(*(x_DWORD *)(a1 + 160) + 2));
	HIBYTE(v3) &= 7u;
	*(x_WORD *)(a1 + 28) = v3;
	v4 = *(x_WORD *)(a1 + 30)
		+ sub_58350(
			*(x_WORD *)(a1 + 30),
			*(x_WORD *)(a1 + 34),
			*(unsigned __int16 *)(*(x_DWORD *)(a1 + 160) + 8),
			*(x_WORD *)(*(x_DWORD *)(a1 + 160) + 6));
	HIBYTE(v4) &= 7u;
	*(x_WORD *)(a1 + 30) = v4;
	v5 = *(x_WORD *)(a1 + 132) - *(x_WORD *)(a1 + 130);
	if (*(signed __int16 *)(a1 + 132) != *(signed __int16 *)(a1 + 130))
	{
		if (*(signed __int16 *)(a1 + 132) - *(signed __int16 *)(a1 + 130) <= 0)
			v5 = -1;
		else
			v5 = 1;
	}
	*(x_WORD *)(a1 + 130) += 2 * v5;
	*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
	*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
	sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), *(x_WORD *)(a1 + 30), *(x_WORD *)(a1 + 130));
	sub_57CF0(a1, (int)&x_WORD_EB398);
	v6 = *(x_WORD *)(a1 + 150);
	v7 = x_DWORD_EA3E4[v6];
	if (v7 > x_DWORD_EA3E4[0] && sub_106C0(a1, x_DWORD_EA3E4[v6]))
	{
		sub_65580(v7);
		LOBYTE(v2) = sub_57CF0(a1, v7 + 76);
		v13 = 1;
		goto LABEL_18;
	}
	LOWORD(v2) = sub_10C40((__int16 *)(a1 + 76));
	v8 = *(x_WORD *)(a1 + 80);
	x_WORD_EB39C = v2;
	if ((signed __int16)v2 > v8
		|| x_BYTE_D41B6
		&& (LOWORD(v2) = sub_10C60((__int16 *)(a1 + 76)) - *(x_WORD *)(a1 + 88),
			x_WORD_EB39C = v2,
			v9 = v2,
			LOWORD(v2) = *(x_WORD *)(a1 + 80),
			(signed __int16)v2 > v9))
	{
		LOBYTE(v2) = x_WORD_EB39C;
		*(x_WORD *)(a1 + 80) = x_WORD_EB39C;
	LABEL_17:
		v13 = 1;
		goto LABEL_18;
	}
	v10 = *(x_DWORD *)(a1 + 8) - 1;
	*(x_DWORD *)(a1 + 8) = v10;
	if (v10 < 0)
		goto LABEL_17;
	LOBYTE(v2) = sub_11CB0((__int16 *)(a1 + 76)) == 0;
	v14 = v2;
	if ((x_BYTE)v2)
		goto LABEL_17;
LABEL_18:
	if (v13)
	{
		if (v14)
		{
			*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
			*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
			v11 = *(x_WORD *)(a1 + 28);
			HIBYTE(v11) = (HIBYTE(v11) + 4) & 7;
			sub_57FA0((x_WORD*)&x_WORD_EB398, v11, *(x_WORD *)(a1 + 30), *(x_WORD *)(a1 + 130));
			sub_57CF0(a1, (int)&x_WORD_EB398);
		}
		v2 = sub_4A190(a1 + 76, *(char *)(a1 + 67), *(char *)(a1 + 68));
		if (v2)
		{
			*(x_WORD *)(v2 + 26) = *(x_WORD *)(a1 + 26);
			sub_57F10(a1);
		}
	}
	return v2;
}
// D41B6: using guessed type char x_BYTE_D41B6;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (00066FB0) --------------------------------------------------------
int sub_66FB0(int a1)
{
	return sub_65820(a1);
}

//----- (00066FD0) --------------------------------------------------------
char sub_66FD0(int a1)
{
	unsigned int v1; // eax
	char v2; // dl
	int v3; // esi
	unsigned __int16 v4; // dx
	signed __int16 v5; // ax
	int v6; // eax
	unsigned int v7; // edi
	int(*v8)(); // eax
	__int16 v9; // ax
	__int16 v10; // dx
	int v11; // eax
	int(*v12)(); // esi
	unsigned int v14; // [esp+0h] [ebp-8h]
	char v15; // [esp+4h] [ebp-4h]

	v15 = 0;
	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
	v14 = v1;
	if (v1 <= x_DWORD_EA3E4[0])
	{
		v2 = *(x_BYTE *)(a1 + 12);
		if (!(v2 & 2))
		{
			*(x_BYTE *)(a1 + 12) = v2 | 2;
			if (sub_68940(a1))
			{
				v3 = *(x_DWORD *)(a1 + 8) + 32;
				*(x_WORD *)(a1 + 28) = *(x_WORD *)(a1 + 32);
				*(x_DWORD *)(a1 + 8) = v3;
				*(x_DWORD *)(a1 + 4) = v3;
				v4 = *(x_WORD *)(a1 + 52);
				*(x_WORD *)(a1 + 30) = *(x_WORD *)(a1 + 34);
				if (v4)
				{
					sub_57F20(x_DWORD_EA3E4[v4]);
					*(x_WORD *)(a1 + 52) = 0;
				}
			}
			else if (sub_67CB0(a1))
			{
				*(x_WORD *)(a1 + 28) = *(x_WORD *)(a1 + 32);
				*(x_WORD *)(a1 + 30) = *(x_WORD *)(a1 + 34);
			}
			else
			{
				*(x_WORD *)(a1 + 32) = *(x_WORD *)(a1 + 28);
				*(x_WORD *)(a1 + 34) = *(x_WORD *)(a1 + 30);
			}
		}
	}
	else
	{
		sub_65610(a1, v1);
	}
	v5 = *(x_WORD *)(a1 + 132) - *(x_WORD *)(a1 + 130);
	if (*(signed __int16 *)(a1 + 132) != *(signed __int16 *)(a1 + 130))
	{
		if (*(signed __int16 *)(a1 + 132) - *(signed __int16 *)(a1 + 130) <= 0)
			v5 = -1;
		else
			v5 = 1;
	}
	*(x_WORD *)(a1 + 130) += 2 * v5;
	*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
	*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
	sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), *(x_WORD *)(a1 + 30), *(x_WORD *)(a1 + 130));
	sub_57CF0(a1, (int)&x_WORD_EB398);
	v6 = sub_10780(a1);
	v7 = v6;
	if (v6)
	{
		if (*(x_WORD *)(v6 + 12) & 0x8010)
		{
			LOBYTE(v8) = sub_68740(a1, v6, 0x2Du, 22);
			if ((x_BYTE)v8)
				return (char)v8;
		}
		sub_65580(v7);
		sub_57CF0(a1, v7 + 76);
		LOBYTE(v8) = sub_655A0(v7);
		v15 = 1;
	}
	else
	{
		v9 = sub_10C40((__int16 *)(a1 + 76));
		v10 = *(x_WORD *)(a1 + 80);
		x_WORD_EB39C = v9;
		if (v9 > v10
			|| x_BYTE_D41B6
			&& (x_WORD_EB39C = sub_10C60((__int16 *)(a1 + 76)) - *(x_WORD *)(a1 + 88), *(x_WORD *)(a1 + 80) > x_WORD_EB39C))
		{
			LOBYTE(v8) = x_WORD_EB39C;
			*(x_WORD *)(a1 + 80) = x_WORD_EB39C;
			if (*(x_BYTE *)(a1 + 64) != 4)
			{
				v8 = sub_104D0((signed __int16 *)(a1 + 76));
				if (v8 == (int(*)())1)
				{
					v11 = sub_4A190(a1 + 76, 10, 5);
					if (v11)
						*(x_WORD *)(v11 + 26) = *(x_WORD *)(a1 + 26);
					sub_57F10(a1);
					goto LABEL_28;
				}
			}
		}
		else
		{
			v8 = (int(*)())(*(x_DWORD *)(a1 + 8) - 1);
			*(x_DWORD *)(a1 + 8) = (x_DWORD)v8;
			if ((signed int)v8 >= 0)
				goto LABEL_28;
		}
		v15 = 1;
	}
LABEL_28:
	if (v15)
	{
		if (sub_68AC0(a1, v7))
		{
			sub_57F10(a1);
		}
		else
		{
			v8 = (int(*)())sub_4A190(a1 + 76, 10, 38);
			v12 = v8;
			if (v8)
			{
				sub_65780(a1, v7, v14);
				if (v7 > x_DWORD_EA3E4[0])
					sub_6D8B0(*(x_WORD *)(a1 + 26), 7u, 1);
				*((x_WORD *)v12 + 13) = *(x_WORD *)(a1 + 26);
				*((x_WORD *)v12 + 14) = *(x_WORD *)(a1 + 28);
				*((x_WORD *)v12 + 15) = *(x_WORD *)(a1 + 30);
				*((x_WORD *)v12 + 75) = (signed int)(v7 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
				*((x_WORD *)v12 + 21) = *(x_WORD *)(a1 + 42);
				*((x_BYTE *)v12 + 67) = *(x_BYTE *)(a1 + 67);
				*((x_BYTE *)v12 + 68) = *(x_BYTE *)(a1 + 68);
				sub_57F10(a1);
			}
		}
	}
	return (char)v8;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41B6: using guessed type char x_BYTE_D41B6;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (000672E0) --------------------------------------------------------
char sub_672E0(int a1)
{
	int v1; // esi
	int v2; // eax
	int v3; // edi
	int v4; // eax
	char result; // al

	if (!(*(x_BYTE *)(a1 + 12) & 2))
	{
		v1 = (int)x_D41A0_BYTEARRAY_0;
		v2 = 9377 * *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8) + 9439;
		*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8) = v2;
		sub_6E450((a1 - (v1 + 28302)) / 168, -1, (v2 & 1) + 33);
		*(x_BYTE *)(a1 + 12) |= 2u;
	}
	*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
	*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
	sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), *(x_WORD *)(a1 + 30), *(x_WORD *)(a1 + 130));
	v3 = sub_10780(a1);
	if ((signed __int16)sub_10C40(&x_WORD_EB398) <= x_WORD_EB39C)
	{
		v4 = *(x_DWORD *)(a1 + 8);
		*(x_DWORD *)(a1 + 8) = v4 - 1;
		if (v4)
		{
			if (!v3)
				return sub_57CF0(a1, (int)&x_WORD_EB398);
		}
	}
	if (!v3)
	{
	LABEL_10:
		sub_10C80(a1, 0, *(x_WORD *)(a1 + 42));
		sub_57F10(a1);
	}
	if (!(*(x_WORD *)(v3 + 12) & 0x8010) || (result = sub_68740(a1, v3, 0x2Du, 22)) == 0)
	{
		sub_65580(v3);
		sub_57CF0(a1, v3 + 76);
		sub_655A0(v3);
		goto LABEL_10;
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (00067410) --------------------------------------------------------
void sub_67410(int a1)
{
	int result; // eax

	result = *(x_DWORD *)(a1 + 8);
	*(x_DWORD *)(a1 + 8) = result - 1;
	if (result < 0)
		sub_57F10(a1);
	//return result;
}

//----- (00067430) --------------------------------------------------------
int sub_67430(int a1)
{
	return sub_65820(a1);
}

//----- (00067450) --------------------------------------------------------
int sub_67450(int a1)
{
	return sub_65820(a1);
}

//----- (00067470) --------------------------------------------------------
int sub_67470(int a1)
{
	int result; // eax
	char v2; // dh

	result = sub_65820(a1);
	BYTE1(result) = *(x_BYTE *)(a1 + 63);
	if (BYTE1(result))
	{
		result = sub_4A190(a1 + 76, 10, 0);
		if (result)
		{
			*(x_BYTE *)(result + 12) |= 0x80u;
			v2 = *(x_BYTE *)(result + 14) | 1;
			*(x_WORD *)(result + 26) = *(x_WORD *)(a1 + 26);
			*(x_BYTE *)(result + 14) = v2;
		}
	}
	return result;
}

//----- (000674C0) --------------------------------------------------------
void sub_674C0(int a1)
{
	unsigned int v1; // eax
	char v2; // dl
	__int16 v3; // ax
	int v4; // eax
	int v5; // esi
	unsigned int v6; // edi
	__int16 result; // ax
	__int16 v8; // cx
	__int16 v9; // ax
	__int16 v10; // si
	int v11; // esi
	int v12; // eax
	x_WORD *v13; // esi
	int v14; // esi
	unsigned int v15; // [esp+0h] [ebp-8h]
	char v16; // [esp+4h] [ebp-4h]

	v16 = 0;
	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
	v15 = v1;
	if (v1 <= x_DWORD_EA3E4[0])
	{
		v2 = *(x_BYTE *)(a1 + 12);
		if (!(v2 & 2))
		{
			*(x_BYTE *)(a1 + 12) = v2 | 2;
			if (sub_67CB0(a1))
			{
				*(x_WORD *)(a1 + 28) = *(x_WORD *)(a1 + 32);
				*(x_WORD *)(a1 + 30) = *(x_WORD *)(a1 + 34);
			}
		}
	}
	else
	{
		sub_65610(a1, v1);
	}
	*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a1 + 76);
	*(&x_WORD_EB398 + 2) = *(x_WORD *)(a1 + 80);
	sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a1 + 28), *(x_WORD *)(a1 + 30), *(x_WORD *)(a1 + 130));
	v3 = sub_10C40(&x_WORD_EB398);
	if (v3 > x_WORD_EB39C)
		x_WORD_EB39C = v3;
	sub_57CF0(a1, (int)&x_WORD_EB398);
	v4 = sub_108B0(a1);
	v5 = v4;
	v6 = v4;
	if (v4)
	{
		sub_65580(v4);
		sub_57CF0(a1, v5 + 76);
		result = sub_655A0(v5);
		v16 = 1;
		goto LABEL_16;
	}
	result = sub_10C40((__int16 *)(a1 + 76));
	v8 = *(x_WORD *)(a1 + 80);
	x_WORD_EB39C = result;
	if (result > v8
		|| x_BYTE_D41B6
		&& (v9 = sub_10C60((__int16 *)(a1 + 76)) - *(x_WORD *)(a1 + 88),
			x_WORD_EB39C = v9,
			v10 = v9,
			result = *(x_WORD *)(a1 + 80),
			result > v10))
	{
		result = x_WORD_EB39C;
		*(x_WORD *)(a1 + 80) = x_WORD_EB39C;
	}
	else
	{
		v11 = *(x_DWORD *)(a1 + 8) - 1;
		*(x_DWORD *)(a1 + 8) = v11;
		if (v11 >= 0)
			goto LABEL_16;
	}
	v16 = 1;
LABEL_16:
	if (v16)
	{
		if (v6)
		{
			if (*(x_BYTE *)(a1 + 67) != 10 || *(x_BYTE *)(a1 + 68) != 69)
				v12 = sub_4A190(a1 + 76, 10, 12);
			else
				v12 = sub_4A190(a1 + 76, 10, 70);
			v13 = (x_WORD *)v12;
			if (v12)
			{
				sub_65780(a1, v6, v15);
				v13[13] = *(x_WORD *)(a1 + 26);
				v13[14] = *(x_WORD *)(a1 + 28);
				v13[15] = *(x_WORD *)(a1 + 30);
			}
			v14 = sub_4A190(a1 + 76, *(char *)(a1 + 67), *(char *)(a1 + 68));
			if (v14)
			{
				sub_65780(a1, v6, v15);
				sub_6D8B0(*(x_WORD *)(a1 + 26), 1u, 1);
				*(x_WORD *)(v14 + 26) = *(x_WORD *)(a1 + 26);
				*(x_WORD *)(v14 + 28) = *(x_WORD *)(a1 + 28);
				*(x_WORD *)(v14 + 30) = *(x_WORD *)(a1 + 30);
				*(x_DWORD *)(v14 + 16) = *(x_DWORD *)(a1 + 16);
			}
		}
		sub_57F10(a1);
	}
	//return result;
}
// D41B6: using guessed type char x_BYTE_D41B6;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (000676F0) --------------------------------------------------------
x_WORD *sub_676F0(int a1)
{
	x_WORD *result; // eax

	result = (x_WORD *)sub_4A190(a1 + 76, *(char *)(a1 + 67), *(char *)(a1 + 68));
	if (result)
	{
		result[13] = *(x_WORD *)(a1 + 26);
		result[14] = *(x_WORD *)(a1 + 28);
		result[15] = *(x_WORD *)(a1 + 30);
		result[21] = *(x_WORD *)(a1 + 42);
		sub_57F10(a1);
	}
	return result;
}

//----- (00067740) --------------------------------------------------------
int sub_67740(int a1)
{
	return sub_65820(a1);
}

//----- (00067760) --------------------------------------------------------
int sub_67760(int a1)
{
	return sub_65820(a1);
}

//----- (00067780) --------------------------------------------------------
int sub_67780(int a1)
{
	return sub_65820(a1);
}

//----- (000677A0) --------------------------------------------------------
int sub_677A0(int a1)
{
	int result; // eax
	int v2; // edx

	result = sub_65820(a1);
	if (result)
	{
		v2 = *(char *)(a1 + 70);
		*(x_BYTE *)(result + 70) = 0;
		*(x_DWORD *)(result + 8) = v2;
	}
	return result;
}

//----- (000677D0) --------------------------------------------------------
int sub_677D0(int a1)
{
	int result; // eax
	int v2; // edx

	result = sub_65820(a1);
	if (result)
	{
		v2 = *(char *)(a1 + 70);
		LOBYTE(v2) = v2 & 0xF0;
		*(x_BYTE *)(result + 70) = 0;
		*(x_DWORD *)(result + 4) = v2;
		*(x_DWORD *)(result + 8) = v2;
	}
	return result;
}

//----- (00067800) --------------------------------------------------------
int sub_67800(int a1)
{
	unsigned __int8 v1; // al
	int result; // eax

	v1 = *(x_BYTE *)(a1 + 70);
	if (v1 < 0x10u)
	{
		if (v1 != 2)
			goto LABEL_10;
	LABEL_8:
		x_D41A0_BYTEARRAY_4[0xE0] = 8;
		goto LABEL_11;
	}
	if (v1 <= 0x10u || v1 < 0x13u)
		goto LABEL_10;
	if (v1 <= 0x13u)
		goto LABEL_8;
	if (v1 == 25)
	{
		x_D41A0_BYTEARRAY_4[0xE0] = 4;
		goto LABEL_11;
	}
LABEL_10:
	x_D41A0_BYTEARRAY_4[0xE0] = 2;
LABEL_11:
	result = sub_65820(a1);
	if (result)
	{
		while (result != x_DWORD_EA3E4[0])
		{
			*(x_BYTE *)(result + 70) = *(x_BYTE *)(a1 + 70);
			*(x_WORD *)(result + 40) = *(x_WORD *)(a1 + 40);
			*(x_WORD *)(result + 26) = *(x_WORD *)(a1 + 26);
			result = x_DWORD_EA3E4[*(unsigned __int16 *)(result + 52)];
		}
	}
	return result;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00067890) --------------------------------------------------------
unsigned int sub_67890(int a1)
{
	unsigned int result; // eax
	char v2; // dh

	result = sub_65820(a1);
	if (result)
	{
		result = x_DWORD_EA3E4[*(signed __int16 *)(a1 + 26)];
		if (result > x_DWORD_EA3E4[0] && *(x_BYTE *)(result + 63) == 3)
		{
			v2 = *(x_BYTE *)(result + 64);
			if (!v2 || v2 == 1)
				*(x_WORD *)(result + 150) = 0;
		}
	}
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (000678E0) --------------------------------------------------------
int sub_678E0(int a1)
{
	int result; // eax
	int v2; // edx

	result = sub_65820(a1);
	if (result)
	{
		v2 = 8 * *(char *)(a1 + 70);
		*(x_DWORD *)(result + 4) = v2;
		*(x_DWORD *)(result + 8) = v2;
	}
	return result;
}

//----- (00067910) --------------------------------------------------------
int sub_67910(int a1)
{
	int result; // eax
	int v2; // edx

	result = sub_65820(a1);
	if (result)
	{
		v2 = *(char *)(a1 + 70);
		*(x_BYTE *)(result + 70) = 0;
		*(x_DWORD *)(result + 4) = v2;
	}
	return result;
}

//----- (00067940) --------------------------------------------------------
int sub_67940(int a1)
{
	return sub_65820(a1);
}

//----- (00067960) --------------------------------------------------------
void sub_67960(unsigned int a1, int a2)
{
	int v2; // eax
	unsigned int v3; // eax
	unsigned int i; // edi
	signed int v5; // ST10_4
	signed int v6; // eax
	int v7; // eax
	unsigned __int16 v8; // ax
	__int16 v9; // ax
	__int16 v10; // dx
	int result; // eax
	__int16 v12; // dx
	__int16 *v13; // [esp+4h] [ebp-18h]
	void(/*__noreturn*/ *v14)(); // [esp+8h] [ebp-14h]
	int v15; // [esp+Ch] [ebp-10h]
	unsigned int v16; // [esp+10h] [ebp-Ch]
	char v17; // [esp+14h] [ebp-8h]
	char v18; // [esp+18h] [ebp-4h]

	v15 = 0;
	v17 = 0;
	v18 = 0;
	v14 = (void(*)())sub_10000;
	if (*(x_DWORD *)(a2 + 8) == *(x_DWORD *)(a2 + 4) && *(x_WORD *)(a2 + 42) >= 2u)
	{
		v2 = *(signed __int16 *)(a2 + 26);
		*(x_WORD *)(a2 + 150) = 0;
		v3 = x_DWORD_EA3E4[v2];
		v16 = v3;
		if (v3 > x_DWORD_EA3E4[0] && *(x_BYTE *)(v3 + 63) == 3)
		{
			for (i = x_D41A0_BYTEARRAY_4[38535]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
			{
				if (*(x_BYTE *)(i + 64) == 78
					&& *(unsigned __int16 *)(i + 50) != *(signed __int16 *)(a2 + 26)
					&& *(x_WORD *)(i + 42) < 2u)
				{
					v5 = *(signed __int16 *)(*(x_DWORD *)(v16 + 160) + 28);
					v6 = sub_583F0((x_WORD *)(i + 76), (x_WORD *)(a2 + 76));
					if (v6 < v5 && v6 < (signed int)v14)
					{
						v15 = i;
						v14 = (void(/*__noreturn*/ *)())v6;
					}
				}
			}
			if (v15)
			{
				*(x_DWORD *)(a2 + 4) = 32;
				*(x_DWORD *)(a2 + 8) = *(x_DWORD *)(a2 + 4) - 1;
				*(x_WORD *)(a2 + 150) = (v15 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
				sub_655C0((x_WORD *)a2, v15);
			}
		}
	}
	v7 = *(signed __int16 *)(a2 + 132) - *(signed __int16 *)(a2 + 130);
	if (*(signed __int16 *)(a2 + 132) != *(signed __int16 *)(a2 + 130))
	{
		if (v7 <= 0)
			LOWORD(v7) = -1;
		else
			LOWORD(v7) = 1;
	}
	*(x_WORD *)(a2 + 130) += 2 * v7;
	if (*(x_WORD *)(a2 + 150))
	{
		v8 = *(x_WORD *)(a2 + 150);
		a1 = x_DWORD_EA3E4[v8];
		if (a1 <= x_DWORD_EA3E4[0] || *(x_DWORD *)(a1 + 8) < 0 || *(x_BYTE *)(a1 + 13) & 4)
		{
			*(x_WORD *)(a2 + 150) = 0;
		}
		else
		{
			sub_65610(a2, x_DWORD_EA3E4[v8]);
			if (sub_106C0(a2, a1))
				v17 = 1;
		}
	}
	v13 = (__int16 *)(a2 + 76);
	if (v17)
	{
		sub_65580(a1);
		sub_57CF0(a2, a1 + 76);
		sub_655A0(a1);
		*(x_BYTE *)(a1 + 70) = 8;
		sub_4A190((int)v13, 10, 0);
		sub_57F10(a2);
	}
	else
	{
		*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a2 + 76);
		*(&x_WORD_EB398 + 2) = *(x_WORD *)(a2 + 80);
		sub_57FA0((x_WORD*)&x_WORD_EB398, *(x_WORD *)(a2 + 28), *(x_WORD *)(a2 + 30), *(x_WORD *)(a2 + 130));
		sub_57CF0(a2, (int)&x_WORD_EB398);
		v9 = sub_10C40(v13);
		v10 = *(x_WORD *)(a2 + 80);
		x_WORD_EB39C = v9;
		if (v9 > v10 || x_BYTE_D41B6 && (x_WORD_EB39C = sub_10C60(v13) - *(x_WORD *)(a2 + 88), *(x_WORD *)(a2 + 80) > x_WORD_EB39C))
		{
			v18 = 1;
			*(x_WORD *)(a2 + 80) = x_WORD_EB39C;
		}
		result = *(x_DWORD *)(a2 + 8) - 1;
		*(x_DWORD *)(a2 + 8) = result;
		if (result < 0)
			v18 = 1;
		if (v18)
		{
			result = sub_4A190(a2 + 76, *(char *)(a2 + 67), *(char *)(a2 + 68));
			if (result)
			{
				*(x_WORD *)(result + 50) = *(x_WORD *)(a2 + 26);
				v12 = *(x_WORD *)(a2 + 42);
				*(x_BYTE *)(result + 70) = 0;
				*(x_WORD *)(result + 42) = v12;
				sub_57F10(a2);
			}
		}
	}
}
// 10000: using guessed type void /*__noreturn*/ sub_10000();
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// D41B6: using guessed type char x_BYTE_D41B6;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (00067CB0) --------------------------------------------------------
signed int sub_67CB0(int a1)
{
	unsigned int v1; // edi
	unsigned int ii; // esi
	unsigned int v3; // ST10_4
	unsigned int v4; // eax
	unsigned int kk; // esi
	unsigned int v6; // eax
	x_BYTE *v8; // esi
	unsigned int i; // edi
	unsigned int v10; // ST10_4
	unsigned int v11; // eax
	unsigned int k; // edi
	__int16 v13; // cx
	unsigned int v14; // eax
	unsigned int l; // edi
	int m; // eax
	unsigned int v17; // eax
	unsigned int v18; // edi
	unsigned int ll; // esi
	unsigned int v20; // ST10_4
	unsigned int v21; // eax
	unsigned int nn; // esi
	__int16 v23; // cx
	unsigned int v24; // eax
	unsigned int v25; // edi
	unsigned int v26; // esi
	unsigned __int8 v27; // al
	int v28; // eax
	int v29; // edx
	unsigned int v30; // eax
	unsigned int i3; // esi
	unsigned int v32; // eax
	unsigned int i4; // esi
	int i5; // eax
	unsigned int v35; // eax
	unsigned int v36; // edi
	unsigned int n; // esi
	unsigned int v38; // ST10_4
	unsigned int v39; // eax
	int v40; // edi
	unsigned int i2; // esi
	unsigned int v42; // eax
	int v43; // [esp+4h] [ebp-40h]
	int v44; // [esp+8h] [ebp-3Ch]
	int v45; // [esp+Ch] [ebp-38h]
	signed int j; // [esp+10h] [ebp-34h]
	unsigned int v47; // [esp+14h] [ebp-30h]
	unsigned int v48; // [esp+18h] [ebp-2Ch]
	signed int jj; // [esp+1Ch] [ebp-28h]
	signed int mm; // [esp+20h] [ebp-24h]
	signed int i1; // [esp+24h] [ebp-20h]
	int v52; // [esp+28h] [ebp-1Ch]
	int v53; // [esp+2Ch] [ebp-18h]
	int v54; // [esp+30h] [ebp-14h]
	unsigned int v55; // [esp+34h] [ebp-10h]
	int v56; // [esp+38h] [ebp-Ch]
	unsigned int v57; // [esp+40h] [ebp-4h]

	switch (*(x_BYTE *)(a1 + 64))
	{
	case 0:
	case 3:
	case 4:
	case 0x12:
	case 0x13:
	case 0x16:
	case 0x1A:
	case 0x1C:
	case 0x1E:
		v57 = -1;
		v43 = x_DWORD_EA3E4[*(signed __int16 *)(a1 + 26)];
		v8 = 0;
		for (i = x_D41A0_BYTEARRAY_4[0x9677]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
		{
			if (*(x_WORD *)(i + 26) != *(x_WORD *)(a1 + 26) && !(*(x_BYTE *)(i + 12) & 0x20))
			{
				v10 = *(signed __int16 *)(*(x_DWORD *)(v43 + 160) + 28);
				if (sub_583F0((x_WORD *)(i + 76), (x_WORD *)(a1 + 76)) <= v10)
				{
					v11 = *(x_BYTE *)(i + 64) == 2 ? sub_685D0((__int16 *)a1, i, 0x71u, 0x71u) : sub_68490(
						(__int16 *)a1,
						i,
						0x71u,
						0x71u);
					if (v11 < v57)
					{
						v8 = (x_BYTE *)i;
						v57 = v11;
					}
				}
			}
		}
		for (j = 0; j < 29; j++)
		{
			if (j != 22)
			{
				for (k = x_D41A0_BYTEARRAY_4[j + 38403]; k > x_DWORD_EA3E4[0]; k = *(x_DWORD *)k)
				{
					v13 = *(x_WORD *)(a1 + 26);
					if (*(x_WORD *)(k + 26) != v13
						&& *(x_BYTE *)(k + 57)
						&& (*(x_BYTE *)(k + 73) != 14 || *(unsigned __int16 *)(k + 40) != v13))
					{
						v14 = sub_68490((__int16 *)a1, k, 0x71u, 0x71u);
						if (v14 < v57)
						{
							v8 = (x_BYTE *)k;
							v57 = v14;
						}
					}
				}
			}
		}
		if (!v8)
		{
			for (l = x_D41A0_BYTEARRAY_4[0x965B]; l > x_DWORD_EA3E4[0]; l = *(x_DWORD *)l)
			{
				if (*(x_BYTE *)(l + 57))
				{
					for (m = *(unsigned __int16 *)(l + 52); ; m = *(unsigned __int16 *)(v53 + 52))
					{
						v53 = x_DWORD_EA3E4[m];
						if (v53 == x_DWORD_EA3E4[0])
							break;
						v17 = sub_68490((__int16 *)a1, v53, 0x71u, 0x71u);
						if (v17 < v57)
						{
							v8 = (x_BYTE *)v53;
							v57 = v17;
						}
					}
				}
			}
		}
		if (!v8)
			return 0;
		*(x_WORD *)(a1 + 150) = (signed int)&v8[-(int)x_D41A0_BYTEARRAY_0 - 28302] / 168;
		sub_68BD0(a1, v8);
		sub_655C0((x_WORD *)a1, (int)v8);
		if (v8[63] == 3 && !v8[64])
			sub_5EF70((unsigned int)v8);
		return 1;
	case 1:
	case 0x11:
		v25 = -1;
		v56 = 0;
		v26 = x_D41A0_BYTEARRAY_4[0x967B];
		break;
	case 7:
	case 8:
	case 0xB:
	case 0xC:
		v48 = -1;
		v36 = 0;
		v44 = x_DWORD_EA3E4[*(signed __int16 *)(a1 + 26)];
		for (n = x_D41A0_BYTEARRAY_4[0x9677]; n > x_DWORD_EA3E4[0]; n = *(x_DWORD *)n)
		{
			if (*(x_WORD *)(n + 26) != *(x_WORD *)(a1 + 26) && !(*(x_BYTE *)(n + 12) & 0x20))
			{
				v38 = *(signed __int16 *)(*(x_DWORD *)(v44 + 160) + 28);
				if (sub_583F0((x_WORD *)(n + 76), (x_WORD *)(a1 + 76)) <= v38)
				{
					v39 = sub_68490((__int16 *)a1, n, 0x71u, 0x71u);
					if (v39 < v48)
					{
						v36 = n;
						v48 = v39;
					}
				}
			}
		}
		if (!v36)
			return 0;
		*(x_WORD *)(a1 + 150) = (signed int)(v36 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
		sub_655C0((x_WORD *)a1, v36);
		if (*(x_BYTE *)(v36 + 63) == 3 && !*(x_BYTE *)(v36 + 64))
			sub_5EF70(v36);
		return 1;
	case 9:
		v1 = -1;
		v54 = 0;
		for (ii = x_D41A0_BYTEARRAY_4[0x9677]; ii > x_DWORD_EA3E4[0]; ii = *(x_DWORD *)ii)
		{
			if (*(x_WORD *)(ii + 26) != *(x_WORD *)(a1 + 26) && !(*(x_BYTE *)(ii + 12) & 0x20))
			{
				v3 = *(signed __int16 *)(a1 + 132) * *(x_DWORD *)(a1 + 4);
				if (sub_583F0((x_WORD *)(ii + 76), (x_WORD *)(a1 + 76)) <= v3)
				{
					v4 = *(x_BYTE *)(ii + 64) == 2 ? sub_685D0((__int16 *)a1, ii, 0x71u, 0x71u) : sub_68490(
						(__int16 *)a1,
						ii,
						0x71u,
						0x71u);
					if (v4 < v1)
					{
						v54 = ii;
						v1 = v4;
					}
				}
			}
		}
		for (jj = 0; jj < 29; ++jj)
		{
			for (kk = x_D41A0_BYTEARRAY_4[jj + 38403]; kk > x_DWORD_EA3E4[0]; kk = *(x_DWORD *)kk)
			{
				if (*(x_WORD *)(kk + 26) != *(x_WORD *)(a1 + 26)
					&& *(x_BYTE *)(kk + 57)
					&& (*(x_BYTE *)(kk + 73) != 14 || *(unsigned __int16 *)(kk + 40) != *(signed __int16 *)(a1 + 26)))
				{
					v6 = sub_68490((__int16 *)a1, kk, 0x71u, 0x200u);
					if (v6 < v1)
					{
						v54 = kk;
						v1 = v6;
					}
				}
			}
		}
		if (!v54)
			return 0;
		*(x_WORD *)(a1 + 150) = (v54 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
		sub_655C0((x_WORD *)a1, v54);
		return 1;
	case 0x10:
		v55 = -1;
		v45 = x_DWORD_EA3E4[*(signed __int16 *)(a1 + 26)];
		v18 = 0;
		for (ll = x_D41A0_BYTEARRAY_4[0x9677]; ll > x_DWORD_EA3E4[0]; ll = *(x_DWORD *)ll)
		{
			if (*(x_WORD *)(ll + 26) != *(x_WORD *)(a1 + 26) && !(*(x_BYTE *)(ll + 12) & 0x20))
			{
				v20 = *(signed __int16 *)(*(x_DWORD *)(v45 + 160) + 28);
				if (sub_583F0((x_WORD *)(ll + 76), (x_WORD *)(a1 + 76)) <= v20)
				{
					v21 = *(x_BYTE *)(ll + 64) == 2 ? sub_685D0((__int16 *)a1, ll, 0x100u, 0x71u) : sub_68490(
						(__int16 *)a1,
						ll,
						0x100u,
						0x71u);
					if (v21 < v55)
					{
						v18 = ll;
						v55 = v21;
					}
				}
			}
		}
		for (mm = 0; mm < 29; ++mm)
		{
			for (nn = x_D41A0_BYTEARRAY_4[mm + 38403]; nn > x_DWORD_EA3E4[0]; nn = *(x_DWORD *)nn)
			{
				v23 = *(x_WORD *)(a1 + 26);
				if (*(x_WORD *)(nn + 26) != v23
					&& *(x_BYTE *)(nn + 57)
					&& (*(x_BYTE *)(nn + 73) != 14 || *(unsigned __int16 *)(nn + 40) != v23))
				{
					v24 = sub_68490((__int16 *)a1, nn, 0x100u, 0x71u);
					if (v24 < v55)
					{
						v18 = nn;
						v55 = v24;
					}
				}
			}
		}
		if (!v18)
			return 0;
		*(x_WORD *)(a1 + 150) = (signed int)(v18 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
		sub_655C0((x_WORD *)a1, v18);
		if (*(x_BYTE *)(v18 + 63) == 3 && !*(x_BYTE *)(v18 + 64))
			sub_5EF70(v18);
		return 1;
	case 0x19:
		v40 = 0;
		v47 = -1;
		for (i1 = 0; i1 < 29; ++i1)
		{
			for (i2 = x_D41A0_BYTEARRAY_4[i1 + 38403]; i2 > x_DWORD_EA3E4[0]; i2 = *(x_DWORD *)i2)
			{
				if (*(x_WORD *)(i2 + 26) != *(x_WORD *)(a1 + 26))
				{
					if (*(x_BYTE *)(i2 + 57))
					{
						if (sub_3A7F0((x_BYTE *)i2))
						{
							v42 = sub_68490((__int16 *)a1, i2, 0x71u, 0x71u);
							if (v42 < v47)
							{
								v40 = i2;
								v47 = v42;
							}
						}
					}
				}
			}
		}
		if (!v40)
			return 0;
		*(x_WORD *)(a1 + 150) = (v40 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
		sub_655C0((x_WORD *)a1, v40);
		return 1;
	default:
		return 0;
	}
	while (v26 > x_DWORD_EA3E4[0])
	{
		v27 = *(x_BYTE *)(v26 + 64);
		if (v27 < 0x27u)
			goto LABEL_105;
		if (v27 <= 0x27u)
		{
			v28 = *(signed __int16 *)(a1 + 26);
			v29 = *(unsigned __int16 *)(v26 + 148);
		}
		else
		{
			if (v27 != 57)
				goto LABEL_105;
			v28 = *(signed __int16 *)(a1 + 26);
			v29 = *(unsigned __int16 *)(v26 + 40);
		}
		if (v29 != v28)
		{
			if (*(x_BYTE *)(v26 + 57))
			{
				v30 = sub_68490((__int16 *)a1, v26, 0x71u, 0x71u);
				if (v30 < v25)
				{
					v56 = v26;
					v25 = v30;
				}
			}
		}
	LABEL_105:
		v26 = *(x_DWORD *)v26;
	}
	for (i3 = x_D41A0_BYTEARRAY_4[0x967F]; i3 > x_DWORD_EA3E4[0]; i3 = *(x_DWORD *)i3)
	{
		if (*(unsigned __int16 *)(i3 + 148) != *(signed __int16 *)(a1 + 26))
		{
			if (*(x_BYTE *)(i3 + 57))
			{
				if (!(x_BYTE_D93C2[4 * *(char *)(i3 + 70)] & 8))
				{
					v32 = sub_68490((__int16 *)a1, i3, 0x71u, 0x71u);
					if (v32 < v25)
					{
						v56 = i3;
						v25 = v32;
					}
				}
			}
		}
	}
	for (i4 = x_D41A0_BYTEARRAY_4[0x965B]; i4 > x_DWORD_EA3E4[0]; i4 = *(x_DWORD *)i4)
	{
		if (*(x_BYTE *)(i4 + 57))
		{
			for (i5 = *(unsigned __int16 *)(i4 + 52); ; i5 = *(unsigned __int16 *)(v52 + 52))
			{
				v52 = x_DWORD_EA3E4[i5];
				if (v52 == x_DWORD_EA3E4[0])
					break;
				v35 = sub_68490((__int16 *)a1, v52, 0x71u, 0x71u);
				if (v35 < v25)
				{
					v25 = v35;
					v56 = v52;
				}
			}
		}
	}
	if (!v56)
		return 0;
	*(x_WORD *)(a1 + 150) = (v56 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
	sub_655C0((x_WORD *)a1, v56);
	return 1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00068490) --------------------------------------------------------
int sub_68490(__int16 *a1, int a2, unsigned __int16 a3, unsigned __int16 a4)
{
	x_WORD *v4; // edi
	__int16 v5; // ax
	int result; // eax
	__int16 v7; // ax
	signed int v8; // ebx
	int v9; // esi
	int v10; // edi
	int v11; // eax
	int v12; // edx
	unsigned __int16 v13; // [esp+0h] [ebp-8h]
	unsigned __int16 v14; // [esp+4h] [ebp-4h]

	sub_65580(a2);
	v4 = a1 + 38;
	v5 = sub_581E0((Bit16u*)a1 + 38, (Bit16u*)(a2 + 76));
	v13 = sub_582B0(a1[14], v5);
	if (v13 <= a3)
	{
		v7 = sub_58210(v4, (x_WORD *)(a2 + 76));
		v14 = sub_582B0(a1[15], v7);
		if (v14 <= a4)
		{
			v8 = sub_58490(v4, (x_WORD *)(a2 + 76));
			if (v8 <= 5120)
			{
				sub_655A0(a2);
				v9 = v8 * (x_DWORD)off_DBF50[v13];
				v10 = v8 * x_DWORD_DB750[v13];
				v11 = v8 * (x_DWORD)off_DBF50[v14];
				v12 = 4 * x_DWORD_DB750[v14] * v8 >> 16;
				result = (v11 >> 16) * (v11 >> 16) + (v9 >> 16) * (v9 >> 16) + (4 * v10 >> 16) * (4 * v10 >> 16) + v12 * v12;
			}
			else
			{
				sub_655A0(a2);
				result = -1;
			}
		}
		else
		{
			sub_655A0(a2);
			result = -1;
		}
	}
	else
	{
		sub_655A0(a2);
		result = -1;
	}
	return result;
}
// DBF50: using guessed type void (/*__noreturn*/ *off_DBF50[2])();

//----- (000685D0) --------------------------------------------------------
int sub_685D0(__int16 *a1, int a2, unsigned __int16 a3, unsigned __int16 a4)
{
	x_WORD *v4; // ebx
	x_WORD *v5; // esi
	__int16 v6; // ax
	__int16 v8; // ax
	unsigned __int16 v9; // di
	signed int v10; // eax
	int v11; // ebx
	int v12; // ecx
	int v13; // esi
	int v14; // eax
	unsigned __int16 v15; // [esp+0h] [ebp-4h]

	v4 = (x_WORD *)(a2 + 76);
	v5 = a1 + 38;
	v6 = sub_581E0((Bit16u*)a1 + 38, (Bit16u*)(a2 + 76));
	v15 = sub_582B0(a1[14], v6);
	if (v15 > a3)
		return -1;
	v8 = sub_58210(v5, v4);
	v9 = sub_582B0(a1[15], v8);
	if (v9 > a4)
		return -1;
	v10 = sub_58490(v5, v4);
	if (v10 > 5120)
		return -1;
	v11 = v10 * (x_DWORD)off_DBF50[v15];
	v12 = v10 * x_DWORD_DB750[v15];
	v13 = v10 * (x_DWORD)off_DBF50[v9];
	v14 = 4 * x_DWORD_DB750[v9] * v10 >> 16;
	return (4 * v12 >> 16) * (4 * v12 >> 16) + (v11 >> 16) * (v11 >> 16) + (v13 >> 16) * (v13 >> 16) + v14 * v14;
}
// DBF50: using guessed type void (/*__noreturn*/ *off_DBF50[2])();

//----- (000686D0) --------------------------------------------------------
int sub_686D0(int a1, unsigned int a2)
{
	int result; // eax
	unsigned int v3; // ebx
	char v4; // dh

	result = a2;
	v3 = x_DWORD_EA3E4[*(signed __int16 *)(a1 + 26)];
	if (v3 > x_DWORD_EA3E4[0] && *(x_BYTE *)(v3 + 63) == 3)
	{
		v4 = *(x_BYTE *)(v3 + 64);
		if (!v4 || v4 == 1)
		{
			if (a2)
			{
				if (a2 > x_DWORD_EA3E4[0])
				{
					result = (signed int)(a2 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
					*(x_WORD *)(v3 + 150) = result;
				}
			}
		}
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00068740) --------------------------------------------------------
char sub_68740(int a1, int a2, unsigned __int16 a3, __int16 a4)
{
	char v4; // cl
	char v5; // ch
	unsigned __int8 v6; // al
	__int16 v7; // ax
	int v8; // esi
	int v9; // eax
	__int16 v10; // dx
	int v11; // eax

	v4 = 0;
	v5 = 0;
	if ((*(x_DWORD *)(a1 + 144) - (__CFSHL__(*(x_DWORD *)(a1 + 144) >> 31, 2) + 4 * (*(x_DWORD *)(a1 + 144) >> 31))) >> 2 > *(x_DWORD *)(a2 + 144))
		return v4;
	if (*(x_BYTE *)(a1 + 67) != 10)
	{
		if (*(x_BYTE *)(a1 + 64) != 13)
			goto LABEL_23;
		goto LABEL_22;
	}
	v6 = *(x_BYTE *)(a1 + 68);
	if (v6 >= 0x11u)
	{
		if (v6 > 0x11u)
		{
			if (v6 < 0x43u)
			{
				if (v6 != 22)
					goto LABEL_23;
			}
			else if (v6 > 0x43u && (v6 < 0x47u || v6 > 0x47u && v6 != 89))
			{
				goto LABEL_23;
			}
		}
	LABEL_22:
		v5 = 1;
		goto LABEL_23;
	}
	if (v6 < 9u)
	{
		if (v6 > 1u)
			goto LABEL_23;
		goto LABEL_22;
	}
	if (v6 <= 9u || v6 >= 0xBu && (v6 <= 0xBu || v6 == 15))
		goto LABEL_22;
LABEL_23:
	if (v5)
	{
		sub_6E450((a2 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 28);
		sub_6D8B0((a2 - (x_D41A0_BYTEARRAY_0[28302])) / 168, 8u, 1);
		*(x_DWORD *)(a2 + 144) -= (*(x_DWORD *)(a1 + 144)
			- (__CFSHL__(*(x_DWORD *)(a1 + 144) >> 31, 2)
				+ 4 * (*(x_DWORD *)(a1 + 144) >> 31))) >> 2;
		v7 = *(x_WORD *)(a1 + 28);
		HIBYTE(v7) = (HIBYTE(v7) + 4) & 7;
		*(x_WORD *)(a1 + 32) = v7;
		v8 = sub_582F0(0, *(x_WORD *)(a1 + 30));
		v9 = -(v8 * sub_582B0(0, *(x_WORD *)(a1 + 30)));
		BYTE1(v9) &= 7u;
		*(x_WORD *)(a1 + 34) = v9;
		*(x_WORD *)(a1 + 30) = v9;
		if (*(x_BYTE *)(a2 + 12) & 0x10)
		{
			v10 = *(x_WORD *)(a1 + 42);
			*(x_WORD *)(a1 + 28) = *(x_WORD *)(a1 + 32);
			*(x_WORD *)(a1 + 42) = 2 * v10;
		}
		else
		{
			*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
			*(x_WORD *)(a1 + 28) = *(x_WORD *)(a1 + 32) + *(x_WORD *)(a1 + 20) % a3 - a4;
		}
		*(x_WORD *)(a1 + 150) = *(x_WORD *)(a1 + 26);
		*(x_WORD *)(a1 + 26) = *(x_WORD *)(a2 + 26);
		*(x_DWORD *)(a1 + 8) = *(x_DWORD *)(a1 + 4);
		v11 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 150)];
		*(x_BYTE *)(a1 + 65) = *(x_BYTE *)(v11 + 63);
		*(x_BYTE *)(a1 + 66) = *(x_BYTE *)(v11 + 64);
		*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(a2 + 76);
		*(&x_WORD_EB398 + 2) = *(x_WORD *)(a2 + 80);
		x_WORD_EB39C += *(x_WORD *)(a2 + 88);
		sub_57CF0(a1, (int)&x_WORD_EB398);
		v4 = 1;
	}
	return v4;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;
// EB39C: using guessed type __int16 x_WORD_EB39C;

//----- (00068940) --------------------------------------------------------
char sub_68940(int a1)
{
	unsigned __int8 v1; // al
	__int16 v2; // dx
	unsigned int i; // ebx
	signed int v4; // ST08_4
	signed int v5; // edi
	__int16 v6; // ax
	void(/*__noreturn*/ *v8)(); // [esp+8h] [ebp-10h]
	int v9; // [esp+Ch] [ebp-Ch]
	int v10; // [esp+10h] [ebp-8h]
	char v11; // [esp+14h] [ebp-4h]

	v11 = 0;
	v10 = 0;
	v1 = *(x_BYTE *)(a1 + 64);
	v8 = (void(*)())sub_10000;
	if (v1 < 0xCu)
	{
		if (v1 < 2u)
		{
			if (v1)
				return v11;
		}
		else if (v1 > 5u && (v1 < 8u || v1 > 9u))
		{
			return v11;
		}
	}
	else if (v1 > 0xCu)
	{
		if (v1 < 0x1Au)
		{
			if (v1 < 0x16u || v1 > 0x17u)
				return v11;
		}
		else if (v1 > 0x1Au && (v1 < 0x1Cu || v1 > 0x1Cu && v1 != 30))
		{
			return v11;
		}
	}
	v2 = *(x_WORD *)(a1 + 26);
	if (v2)
	{
		v9 = x_DWORD_EA3E4[v2];
		if (*(x_BYTE *)(v9 + 63) == 3)
		{
			for (i = x_D41A0_BYTEARRAY_4[38535]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
			{
				if (*(x_BYTE *)(i + 64) == 78
					&& *(unsigned __int16 *)(i + 50) == *(signed __int16 *)(a1 + 26)
					&& *(x_WORD *)(i + 54) == -1)
				{
					v4 = *(signed __int16 *)(*(x_DWORD *)(v9 + 160) + 28);
					v5 = sub_583F0((x_WORD *)(i + 76), (x_WORD *)(v9 + 76));
					if (v5 < v4 && v5 < (signed int)v8)
					{
						v6 = sub_581E0((Bit16u*)(a1 + 76), (Bit16u*)(i + 76));
						if ((unsigned __int16)sub_582B0(*(x_WORD *)(a1 + 28), v6) < 0xAAu)
						{
							v10 = i;
							v8 = (void(/*__noreturn*/ *)())v5;
						}
					}
				}
			}
			if (v10)
			{
				*(x_WORD *)(a1 + 150) = (v10 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
				v11 = 1;
				sub_655C0((x_WORD *)a1, v10);
			}
		}
	}
	return v11;
}
// 10000: using guessed type void /*__noreturn*/ sub_10000();
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00068AC0) --------------------------------------------------------
char sub_68AC0(int a1, int a2)
{
	unsigned __int8 v2; // al
	char v3; // dl
	unsigned __int16 v4; // di
	int v5; // edx

	v2 = *(x_BYTE *)(a1 + 64);
	v3 = 0;
	if (v2 < 0xCu)
	{
		if (v2 < 2u)
		{
			if (v2)
				return v3;
		}
		else if (v2 > 5u && (v2 < 8u || v2 > 9u))
		{
			return v3;
		}
	}
	else if (v2 > 0xCu)
	{
		if (v2 < 0x1Au)
		{
			if (v2 < 0x16u || v2 > 0x17u)
				return v3;
		}
		else if (v2 > 0x1Au && (v2 < 0x1Cu || v2 > 0x1Cu && v2 != 30))
		{
			return v3;
		}
	}
	if (a2
		&& *(x_BYTE *)(a2 + 63) == 10
		&& *(x_BYTE *)(a2 + 64) == 78
		&& *(unsigned __int16 *)(a2 + 50) == *(signed __int16 *)(a1 + 26)
		&& *(x_WORD *)(a2 + 54) == -1)
	{
		sub_4A190(a1 + 76, 10, 0);
		sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 26);
		v4 = *(x_WORD *)(a1 + 38);
		if (v4)
		{
			v5 = x_DWORD_EA3E4[v4];
			*(x_WORD *)(a2 + 54) = *(char *)(v5 + 64);
			*(x_WORD *)(a2 + 52) = *(char *)(v5 + 70);
			*(x_WORD *)(v5 + 46) = 1;
		}
		v3 = 1;
	}
	return v3;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00068BD0) --------------------------------------------------------
char sub_68BD0(int a1, x_BYTE *a2)
{
	char result; // al

	result = a2[63];
	if (result == 5)
	{
		result = a2[64];
		if (!result)
			a2[61] = 32;
	}
	return result;
}

//----- (00068BF0) --------------------------------------------------------
int sub_68BF0()
{
	__int16 i; // si
	int result; // eax
	unsigned int j; // ebx
	x_DWORD *k; // ebx

	for (i = 0; i < 29; i++)
	{
		result = (int)x_D41A0_BYTEARRAY_4;
		for (j = x_D41A0_BYTEARRAY_4[i + 38403]; j > x_DWORD_EA3E4[0]; j = *(x_DWORD *)j)
		{
			if (*(x_DWORD *)(j + 8) >= 0)
			{
				result = sub_68C70(j);
			}
			else
			{
				*(x_BYTE *)(j + 57) = -6;
				*(x_BYTE *)(j + 58) = 0;
			}
		}
	}
	for (k = *(x_DWORD **)(x_D41A0_BYTEARRAY_4[0x967B]); (unsigned int)k > x_DWORD_EA3E4[0]; k = (x_DWORD *)*k)
		result = sub_68C70((int)k);
	return result;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00068C70) --------------------------------------------------------
int sub_68C70(int a1)
{
	char v1; // dh
	int v2; // eax
	unsigned int v3; // eax
	int result; // eax
	int i; // eax
	unsigned int v6; // eax

	if (*(x_BYTE *)(a1 + 57))
	{
		for (i = *(unsigned __int16 *)(a1 + 52); ; i = *(unsigned __int16 *)(v6 + 52))
		{
			v6 = x_DWORD_EA3E4[i];
			if (v6 <= x_DWORD_EA3E4[0])
				break;
			*(x_BYTE *)(v6 + 57) = *(x_BYTE *)(a1 + 57);
		}
		--*(x_BYTE *)(a1 + 57);
		return 0;
	}
	if (*(x_BYTE *)(a1 + 12) & 1)
		return 0;
	v1 = *(x_BYTE *)(a1 + 58);
	if (v1)
	{
		*(x_BYTE *)(a1 + 58) = v1 - 1;
		result = 0;
	}
	else
	{
		if ((unsigned int)sub_584D0(
			(x_WORD *)(a1 + 76),
			(x_WORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12
				+ x_D41A0_BYTEARRAY_0
				+ 11240)]
				+ 76)) < 0x2400000)
		{
			v2 = *(unsigned __int16 *)(a1 + 52);
			*(x_BYTE *)(a1 + 57) = 16;
			while (1)
			{
				v3 = x_DWORD_EA3E4[v2];
				if (v3 <= x_DWORD_EA3E4[0])
					break;
				*(x_BYTE *)(v3 + 57) = *(x_BYTE *)(a1 + 57) + 2;
				v2 = *(unsigned __int16 *)(v3 + 52);
			}
		}
		*(x_BYTE *)(a1 + 58) = 0;
		result = 0;
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00068D50) --------------------------------------------------------
signed int sub_68D50(int a1, x_DWORD *a2)
{
	int v2; // esi
	unsigned __int16 v3; // cx
	signed int result; // eax

	if (a2[36] < 0)
		goto LABEL_14;
	if (a2[2] < 0)
		goto LABEL_14;
	v2 = *(x_DWORD *)(a1 + 136);
	if (v2)
	{
		v3 = *(x_WORD *)(a2[41] + 58);
		if (!v3 || v2 > *(x_DWORD *)(x_DWORD_EA3E4[v3] + 144))
			goto LABEL_14;
	}
	if (a2[36] >= *(x_DWORD *)(a1 + 140) && *(x_WORD *)(a1 + 46) == *(x_WORD *)(a1 + 48))
		return 1;
	if (*(x_WORD *)(a1 + 46) == *(x_WORD *)(a1 + 48))
		LABEL_14:
	result = 0;
	else
		result = 1;
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00068DE0) --------------------------------------------------------
signed int sub_68DE0(int a1, int a2)
{
	__int16 v2; // bx
	int v3; // ebx
	signed int result; // eax

	v2 = *(x_WORD *)(a1 + 46);
	if (v2 == *(x_WORD *)(a1 + 48))
	{
		v3 = *(x_DWORD *)(a2 + 136);
		if (v3 >= 0)
			*(x_DWORD *)(a2 + 136) = -*(x_DWORD *)(a1 + 140);
		else
			*(x_DWORD *)(a2 + 136) = v3 - *(x_DWORD *)(a1 + 140);
		result = 1;
	}
	else
	{
		if (v2 && *(x_DWORD *)(a2 + 136) > 0)
			*(x_DWORD *)(a2 + 136) = 0;
		result = 0;
	}
	return result;
}

//----- (00068E50) --------------------------------------------------------
signed int sub_68E50(int a1, int a2, int a3)
{
	char v3; // cl
	unsigned __int16 v4; // cx
	unsigned __int16 v5; // ax
	signed __int16 v6; // ax
	int i; // eax
	int v8; // esi
	signed int result; // eax
	unsigned __int16 v10; // cx
	unsigned __int16 v11; // ax
	signed __int16 v12; // ax
	int j; // esi
	int v14; // [esp+0h] [ebp-8h]
	int v15; // [esp+4h] [ebp-4h]

	v14 = *(x_DWORD *)(a2 + 76);
	LOWORD(v15) = *(x_WORD *)(a2 + 80);
	v3 = *(x_BYTE *)(a1 + 13);
	if (v3 & 1)
	{
		if (*(x_BYTE *)(a3 + 64) == 4 && (v4 = *(x_WORD *)(a3 + 150)) != 0)
		{
			LOWORD(v15) = *(x_WORD *)(x_DWORD_EA3E4[v4] + 82) + *(x_WORD *)(x_DWORD_EA3E4[v4] + 80);
		}
		else
		{
			v5 = *(x_WORD *)(a1 + 28) - 512;
			HIBYTE(v5) &= 7u;
			sub_57FA0((x_WORD*)&v14, v5, 0, 256);
		}
		v6 = sub_10C40((__int16 *)&v14);
		if (v6 > (signed __int16)v15)
		{
			v14 = *(x_DWORD *)(a2 + 76);
			LOWORD(v15) = *(x_WORD *)(a2 + 80);
		}
		for (i = *(unsigned __int16 *)(a2 + 52); ; i = *(unsigned __int16 *)(v8 + 52))
		{
			v8 = x_DWORD_EA3E4[i];
			if (v8 == x_DWORD_EA3E4[0])
				break;
			sub_57CF0(v8, (int)&v14);
		}
		result = sub_57CF0(a2, (int)&v14);
	}
	else
	{
		if (v3 & 2)
		{
			if (*(x_BYTE *)(a3 + 64) == 4 && (v10 = *(x_WORD *)(a3 + 150)) != 0)
			{
				LOWORD(v15) = *(x_WORD *)(x_DWORD_EA3E4[v10] + 82) + *(x_WORD *)(x_DWORD_EA3E4[v10] + 80);
			}
			else
			{
				v11 = *(x_WORD *)(a1 + 28);
				HIBYTE(v11) = (HIBYTE(v11) + 2) & 7;
				sub_57FA0((x_WORD*)&v14, v11, 0, 256);
			}
			v12 = sub_10C40((__int16 *)&v14);
			if (v12 > (signed __int16)v15)
			{
				v14 = *(x_DWORD *)(a2 + 76);
				LOWORD(v15) = *(x_WORD *)(a2 + 80);
			}
			for (j = x_DWORD_EA3E4[*(unsigned __int16 *)(a2 + 52)];
				j != x_DWORD_EA3E4[0];
				j = x_DWORD_EA3E4[*(unsigned __int16 *)(j + 52)])
			{
				sub_57CF0(j, (int)&v14);
			}
		}
		result = sub_57CF0(a2, (int)&v14);
	}
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00068FF0) --------------------------------------------------------
signed int sub_68FF0(int a1, char a2, char a3)
{
	int v3; // edx
	__int16 v4; // ax
	unsigned int i; // esi
	int v6; // eax
	char v7; // al
	int v8; // ecx
	__int16 v9; // ax
	int v10; // eax
	char v12; // [esp+0h] [ebp-4h]

	v3 = *(x_DWORD *)(a1 + 8);
	v12 = 0;
	if (v3 && (*(x_DWORD *)(a1 + 8) = v3 - 1, v3 == 1))
	{
		sub_57F10(a1);
	}
	else
	{
		v4 = sub_10C40((__int16 *)(a1 + 76));
		sub_580E0(a1 + 76, v4, 0, 0x2000, -128);
		if (!(*(x_BYTE *)(a1 + 62) & 3))
		{
			for (i = x_D41A0_BYTEARRAY_4[0x9677]; i > x_DWORD_EA3E4[0]; i = *(x_DWORD *)i)
			{
				if (!*(x_BYTE *)(i + 64) && *(x_DWORD *)(i + 8) >= 0)
				{
					v6 = *(x_DWORD *)(i + 164);
					if (*(x_WORD *)(v6 + 56) == *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12)
						&& !(*(x_BYTE *)(a1 + 12) & 1)
						&& *(x_WORD *)(v6 + 2 * *(char *)(a1 + 64) + 819))
					{
						*(x_BYTE *)(a1 + 12) |= 1u;
					}
					if (sub_106C0(i, a1))
					{
						v7 = 0;
						if (*(x_WORD *)(*(x_DWORD *)(i + 164) + 2 * a2 + 819))
							v7 = 1;
						if (!v7)
						{
							sub_6E450((signed int)(i - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 18);
							v8 = (int)x_D41A0_BYTEARRAY_0;
							*(x_BYTE *)(a1 + 12) |= 1u;
							v8 += 28302;
							*(x_BYTE *)(a1 + 15) &= 0xFDu;
							*(x_WORD *)(a1 + 40) = (signed int)(i - v8) / 168;
							*(x_BYTE *)(a1 + 69) = a3;
							*(x_WORD *)(a1 + 54) = 64;
							*(x_WORD *)(2 * a2 + *(x_DWORD *)(i + 164) + 819) = (a1 - v8) / 168;
							*(x_BYTE *)(*(x_DWORD *)(i + 164) + a2 + 1027) = 1;
							v9 = *(x_WORD *)(a1 + 74);
							if (v9)
							{
								if (v9 == 2)
									v12 = 1;
								*(x_WORD *)(a1 + 74) = 0;
							}
							else
							{
								v10 = *(x_DWORD *)(i + 164);
								if (*(signed __int16 *)(v10 + 1105) == -1 || *(signed __int16 *)(v10 + 1107) != -1)
									v12 = 1;
							}
							if (v12)
							{
								*(x_WORD *)(*(x_DWORD *)(i + 164) + 1105) = *(char *)(a1 + 64);
								*(x_BYTE *)(*(x_DWORD *)(i + 164) + 1109) = *(x_BYTE *)(*(char *)(a1 + 64) + *(x_DWORD *)(i + 164) + 1079);
							}
							else
							{
								*(x_WORD *)(*(x_DWORD *)(i + 164) + 1107) = *(char *)(a1 + 64);
								*(x_BYTE *)(*(x_DWORD *)(i + 164) + 1110) = *(x_BYTE *)(*(char *)(a1 + 64) + *(x_DWORD *)(i + 164) + 1079);
							}
							sub_6D5E0(a1, *(x_BYTE *)(*(char *)(a1 + 64) + *(x_DWORD *)(i + 164) + 1079));
							return 1;
						}
					}
				}
			}
		}
	}
	return 0;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00069250) --------------------------------------------------------
signed int sub_69250(int a1)
{
	signed int result; // eax

	result = sub_68FF0(a1, *(x_BYTE *)(a1 + 64), *(x_BYTE *)(a1 + 69) - 2);
	if (result)
	{
		result = (*(int(**)(int))((char *)&off_D781E + 14 * *(char *)(a1 + 64)))(a1 + 76);
		if (result)
			*(x_BYTE *)(result + 69) += 2;
	}
	return result;
}
// D781E: using guessed type int (*off_D781E)(int);

//----- (000692A0) --------------------------------------------------------
signed int sub_692A0(int a1)
{
	return sub_68FF0(a1, *(x_BYTE *)(a1 + 64), *(x_BYTE *)(a1 + 69) - 1);
}

//----- (000692C0) --------------------------------------------------------
char sub_692C0(int a1)
{
	char result; // al
	char v2; // ah

	result = sub_59DC0((x_WORD *)a1);
	if (result)
	{
		result = 3 * *(x_BYTE *)(a1 + 64) + 1;
		*(x_BYTE *)(a1 + 69) = result;
		v2 = *(x_BYTE *)(a1 + 15);
		*(x_WORD *)(a1 + 38) = 0;
		*(x_BYTE *)(a1 + 15) = v2 | 2;
	}
	return result;
}

//----- (00069300) --------------------------------------------------------
void sub_69300(int a1, int a2)
{
	char v2; // ah
	int v3; // eax
	int v4; // edx
	int v5; // edx
	int v6; // [esp+0h] [ebp-4h]

	if (!*(x_WORD *)(a1 + 54))
	{
		*(x_WORD *)(a1 + 38) = (a2 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
		v2 = *(x_BYTE *)(a1 + 12);
		*(x_BYTE *)(a1 + 69) = 78;
		*(x_BYTE *)(a1 + 12) = v2 & 0xFE;
		v3 = *(unsigned __int16 *)(a1 + 40);
		*(x_DWORD *)(a1 + 16) = 0;
		v6 = x_DWORD_EA3E4[v3];
		*(x_DWORD *)&x_WORD_EB398 = *(x_DWORD *)(v6 + 76);
		*(&x_WORD_EB398 + 2) = *(x_WORD *)(v6 + 80);
		sub_57CF0(a1, (int)&x_WORD_EB398);
		*(x_WORD *)(*(x_DWORD *)(v6 + 164) + 2 * *(char *)(a1 + 64) + 819) = 0;
		*(x_WORD *)(a1 + 74) = 0;
		v4 = *(x_DWORD *)(v6 + 164);
		if (*(char *)(a1 + 64) == *(x_WORD *)(v4 + 1107))
		{
			*(x_WORD *)(v4 + 1107) = -1;
			*(x_WORD *)(a1 + 74) = 1;
		}
		v5 = *(x_DWORD *)(v6 + 164);
		if (*(char *)(a1 + 64) == *(x_WORD *)(v5 + 1105))
		{
			*(x_WORD *)(v5 + 1105) = -1;
			*(x_WORD *)(a1 + 74) = 2;
		}
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// EB398: using guessed type __int16 x_WORD_EB398;

//----- (000693F0) --------------------------------------------------------
int sub_693F0(int a1)
{
	unsigned int v1; // ebx
	int v2; // eax
	__int16 v3; // si
	int result; // eax
	__int16 v5; // dx
	int v6; // [esp+0h] [ebp-4h]

	if (*(x_WORD *)(a1 + 46) > 0)
	{
		v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
		if (v1 > x_DWORD_EA3E4[0])
		{
			if (sub_68D50(a1, (x_DWORD *)v1))
			{
				if (*(x_WORD *)(a1 + 46) == *(x_WORD *)(a1 + 48))
				{
					v2 = sub_6DCA0(
						v1,
						v1 + 76,
						0,
						(__int16 *)&*xadataspellsdat.var28_begin_buffer[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)],
						*(x_WORD *)(v1 + 130),
						1);
					v6 = v2;
					if (v2)
					{
						sub_68E50(v1, v2, a1);
						*(x_WORD *)(v6 + 38) = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
						*(x_WORD *)(v6 + 26) = *(x_WORD *)(v1 + 26);
						*(x_WORD *)(v6 + 42) = *(x_WORD *)(a1 + 42);
						*(x_DWORD *)(v6 + 144) = *(x_DWORD *)(a1 + 144);
						*(x_WORD *)(v6 + 80) += *(x_WORD *)(v1 + 88);
						*(x_WORD *)(v6 + 28) = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 24) + *(x_WORD *)(v1 + 28);
						*(x_WORD *)(v6 + 30) = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 26) + *(x_WORD *)(v1 + 30);
						*(x_DWORD *)(v6 + 16) = *(unsigned __int8 *)(*(x_DWORD *)(v1 + 164) + 340);
						*(x_BYTE *)(*(x_DWORD *)(v1 + 164) + 340) = 0;
						*(x_DWORD *)(v6 + 154) = *(x_DWORD *)(v1 + 76);
						*(x_WORD *)(v6 + 158) = *(x_WORD *)(v1 + 80);
						sub_57FA0(
							(x_WORD *)(v6 + 154),
							*(x_WORD *)(*(x_DWORD *)(v1 + 164) + 24) + *(x_WORD *)(v1 + 28),
							*(x_WORD *)(*(x_DWORD *)(v1 + 164) + 26) + *(x_WORD *)(v1 + 30),
							0x4000);
						if (*(x_WORD *)(*(x_DWORD *)(v1 + 164) + 56) == *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12))
							sub_49C90(v6, 42);
					}
				}
				sub_68DE0(a1, v1);
			}
			else
			{
				*(x_WORD *)(a1 + 46) = 1;
			}
		}
		v3 = *(x_WORD *)(a1 + 46) - 1;
		*(x_WORD *)(a1 + 46) = v3;
		if (!v3)
			sub_6D880(a1);
	}
	result = a1;
	v5 = *(x_WORD *)(a1 + 54);
	if (v5)
		*(x_WORD *)(a1 + 54) = v5 - 1;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00069600) --------------------------------------------------------
signed int sub_69600(int a1)
{
	return sub_692A0(a1);
}

//----- (00069620) --------------------------------------------------------
signed int sub_69620(int a1)
{
	return sub_69250(a1);
}

//----- (00069640) --------------------------------------------------------
void sub_69640(int a1)
{
	x_DWORD *v1; // eax
	char *v2; // edi
	char v3; // dl
	int v4; // esi
	char v5; // dl
	char v6; // ah
	char v7; // cl
	__int16 v8; // di
	__int16 v9; // dx
	int v10; // [esp+4h] [ebp-4h]

	if (*(x_WORD *)(a1 + 46) <= 0)
		goto LABEL_28;
	v1 = (x_DWORD *)x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
	v10 = (int)v1;
	if ((unsigned int)v1 > x_DWORD_EA3E4[0])
	{
		if (sub_68D50(a1, v1))
		{
			if (*(x_WORD *)(a1 + 46) == *(x_WORD *)(a1 + 48))
			{
				v2 = (char*)*xadataspellsdat.var28_begin_buffer[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
				v3 = v2[24];
				if (v3)
				{
					if ((unsigned __int8)v3 <= 3u)
					{
						v4 = sub_4A190(v10 + 76, 9, 17);
						if (v4)
						{
							*(x_WORD *)(v4 + 130) += *(x_WORD *)(v10 + 130);
							sub_68E50(v10, v4, a1);
							*(x_WORD *)(v4 + 38) = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
							v5 = v2[24];
							if ((unsigned __int8)v5 >= 1u)
							{
								if ((unsigned __int8)v5 <= 1u)
								{
									*(x_BYTE *)(v4 + 68) = 54;
								}
								else if (v5 == 2)
								{
									*(x_BYTE *)(v4 + 68) = 69;
								}
							}
							*(x_BYTE *)(v4 + 67) = 10;
							*(x_WORD *)(v4 + 26) = *(x_WORD *)(v10 + 26);
							*(x_DWORD *)(v4 + 144) = *(x_DWORD *)(a1 + 144);
							*(x_WORD *)(v4 + 80) += *(x_WORD *)(v10 + 88);
							*(x_WORD *)(v4 + 28) = *(x_WORD *)(*(x_DWORD *)(v10 + 164) + 24) + *(x_WORD *)(v10 + 28);
							*(x_WORD *)(v4 + 30) = *(x_WORD *)(*(x_DWORD *)(v10 + 164) + 26) + *(x_WORD *)(v10 + 30);
							*(x_DWORD *)(v4 + 16) = (*(unsigned __int16 *)(a1 + 42) << 8) * (*(unsigned __int16 *)(a1 + 42) << 8);
							*(x_BYTE *)(*(x_DWORD *)(v10 + 164) + 340) = 0;
							*(x_DWORD *)(v4 + 154) = *(x_DWORD *)(v10 + 76);
							*(x_WORD *)(v4 + 158) = *(x_WORD *)(v10 + 80);
							sub_57FA0(
								(x_WORD *)(v4 + 154),
								*(x_WORD *)(*(x_DWORD *)(v10 + 164) + 24) + *(x_WORD *)(v10 + 28),
								*(x_WORD *)(*(x_DWORD *)(v10 + 164) + 26) + *(x_WORD *)(v10 + 30),
								0x4000);
							sub_6E450((v4 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 40);
							sub_68DE0(a1, v10);
							goto LABEL_26;
						}
					}
				}
				else
				{
					sub_69900(a1, v10);
				}
			}
			else
			{
				v6 = *(x_BYTE *)(a1 + 60);
				if (v6)
				{
					if (*(x_BYTE *)(a1 + 70))
					{
						if (v6 == 1)
							sub_69900(a1, v10);
						v7 = *(x_BYTE *)(a1 + 60) + 1;
						*(x_BYTE *)(a1 + 60) = v7;
						if (v7 > 3)
						{
							*(x_BYTE *)(a1 + 60) = 0;
							sub_68DE0(a1, v10);
							goto LABEL_26;
						}
					}
					else
					{
						*(x_BYTE *)(a1 + 60) = 0;
					}
				}
			}
			sub_68DE0(a1, v10);
		}
		else
		{
			*(x_WORD *)(a1 + 46) = 1;
		}
	}
LABEL_26:
	v8 = *(x_WORD *)(a1 + 46) - 1;
	*(x_WORD *)(a1 + 46) = v8;
	if (!v8)
		sub_6D880(a1);
LABEL_28:
	v9 = *(x_WORD *)(a1 + 54);
	if (v9)
		*(x_WORD *)(a1 + 54) = v9 - 1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00069900) --------------------------------------------------------
void sub_69900(int a1, int a2)
{
	int v2; // ebx
	int v3; // edx
	int v4; // eax

	v2 = sub_4A190(a2 + 76, 9, 1);
	if (v2)
	{
		*(x_WORD *)(v2 + 130) += *(x_WORD *)(a2 + 130);
		sub_68E50(a2, v2, a1);
		v3 = a1 - (x_D41A0_BYTEARRAY_0[28302]);
		*(x_BYTE *)(v2 + 67) = 10;
		*(x_WORD *)(v2 + 38) = v3 / 168;
		*(x_BYTE *)(v2 + 68) = 12;
		*(x_WORD *)(v2 + 26) = *(x_WORD *)(a2 + 26);
		*(x_WORD *)(v2 + 80) += *(x_WORD *)(a2 + 88);
		*(x_DWORD *)(v2 + 144) = *(x_DWORD *)(a1 + 144);
		*(x_DWORD *)(v2 + 16) = 200;
		*(x_BYTE *)(*(x_DWORD *)(a2 + 164) + 340) = 0;
		*(x_DWORD *)(v2 + 154) = *(x_DWORD *)(a2 + 76);
		*(x_WORD *)(v2 + 158) = *(x_WORD *)(a2 + 80);
		sub_57FA0(
			(x_WORD *)(v2 + 154),
			*(x_WORD *)(*(x_DWORD *)(a2 + 164) + 24) + *(x_WORD *)(a2 + 28),
			*(x_WORD *)(*(x_DWORD *)(a2 + 164) + 26) + *(x_WORD *)(a2 + 30),
			10240);
		*(x_WORD *)(v2 + 28) = *(x_WORD *)(*(x_DWORD *)(a2 + 164) + 24) + *(x_WORD *)(a2 + 28);
		v4 = (int)x_D41A0_BYTEARRAY_0 + 28302;
		*(x_WORD *)(v2 + 30) = *(x_WORD *)(*(x_DWORD *)(a2 + 164) + 26) + *(x_WORD *)(a2 + 30);
		sub_6E450((v2 - v4) / 168, -1, 40);
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00069A70) --------------------------------------------------------
signed int sub_69A70(int a1)
{
	return sub_692A0(a1);
}

//----- (00069A90) --------------------------------------------------------
signed int sub_69A90(int a1)
{
	return sub_69250(a1);
}

//----- (00069AB0) --------------------------------------------------------
int sub_69AB0(int a1)
{
	unsigned int v1; // ebx
	unsigned __int16 v2; // si
	char *v3; // edx
	int v4; // eax
	int v5; // eax
	int v6; // ecx
	unsigned int v7; // edx
	__int16 v8; // ax
	int result; // eax
	__int16 v10; // di
	int v11; // [esp+0h] [ebp-8h]
	int v12; // [esp+4h] [ebp-4h]

	if (*(x_WORD *)(a1 + 46) <= 0)
	{
		sub_6D880(a1);
	}
	else
	{
		v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
		if (v1 > x_DWORD_EA3E4[0])
		{
			if (sub_68D50(a1, (x_DWORD *)v1))
			{
				if (*(x_WORD *)(a1 + 46) == *(x_WORD *)(a1 + 48))
				{
					v2 = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 58);
					v3 = (char*)*xadataspellsdat.var28_begin_buffer[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
					v4 = 1;
					if (v2)
						v4 = *(x_DWORD *)(x_DWORD_EA3E4[v2] + 16) + 1;
					*(x_BYTE *)(*(x_DWORD *)(v1 + 164) + v4 + 590) = *v3;
					*(x_BYTE *)(*(x_DWORD *)(v1 + 164) + v4 + 599) = v3[24];
					sub_68DE0(a1, v1);
					v5 = sub_4A190(v1 + 76, 9, 10);
					v12 = v5;
					v11 = v5;
					if (v5)
					{
						*(x_WORD *)(a1 + 46) = *(x_WORD *)(a1 + 48) - 1;
						*(x_WORD *)(v5 + 130) += *(x_WORD *)(v1 + 130);
						sub_68E50(v1, v5, a1);
						v6 = (int)x_D41A0_BYTEARRAY_0 + 28302;
						*(x_WORD *)(v12 + 38) = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
						*(x_WORD *)(v12 + 42) = *(x_WORD *)(a1 + 42);
						*(x_WORD *)(v12 + 26) = *(x_WORD *)(v1 + 26);
						*(x_WORD *)(v12 + 80) += *(x_WORD *)(v1 + 88);
						*(x_DWORD *)(v12 + 144) = *(x_DWORD *)(a1 + 144);
						v7 = x_DWORD_EA3E4[*(unsigned __int16 *)(*(x_DWORD *)(v1 + 164) + 58)];
						if (v7 <= x_DWORD_EA3E4[0])
						{
							*(x_DWORD *)(v12 + 154) = *(x_DWORD *)(v1 + 76);
							*(x_WORD *)(v12 + 158) = *(x_WORD *)(v1 + 80);
							sub_57FA0((x_WORD *)(v12 + 154), *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 24) + *(x_WORD *)(v1 + 28), 0, 4096);
							v8 = sub_10C40((__int16 *)(v12 + 154));
							*(x_BYTE *)(v12 + 67) = 3;
							*(x_BYTE *)(v12 + 68) = 2;
							*(x_WORD *)(v12 + 158) = v8;
						}
						else
						{
							*(x_BYTE *)(v12 + 67) = 10;
							*(x_BYTE *)(v12 + 68) = 43;
							*(x_WORD *)(v12 + 150) = (signed int)(v7 - v6) / 168;
						}
						*(x_DWORD *)(v11 + 16) = *(unsigned __int8 *)(*(x_DWORD *)(v1 + 164) + 340);
						*(x_BYTE *)(*(x_DWORD *)(v1 + 164) + 340) = 0;
						*(x_WORD *)(v11 + 28) = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 24) + *(x_WORD *)(v1 + 28);
						*(x_WORD *)(v11 + 30) = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 26) + *(x_WORD *)(v1 + 30);
						sub_6E450((v11 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 15);
					}
				}
			}
			else
			{
				*(x_WORD *)(a1 + 46) = 0;
			}
		}
	}
	result = a1;
	v10 = *(x_WORD *)(a1 + 54);
	if (v10)
		*(x_WORD *)(a1 + 54) = v10 - 1;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00069D70) --------------------------------------------------------
signed int sub_69D70(int a1)
{
	return sub_692A0(a1);
}

//----- (00069D90) --------------------------------------------------------
signed int sub_69D90(int a1)
{
	return sub_69250(a1);
}

//----- (00069DB0) --------------------------------------------------------
void sub_69DB0(int a1)
{
	unsigned int v1; // esi
	signed __int16 v2; // di
	char v3; // dl
	int v4; // eax
	char v5; // cl
	int v6; // eax
	int v7; // ecx
	__int16 v8; // cx
	__int16 v9; // cx
	signed int v10; // [esp+0h] [ebp-8h]
	char *v11; // [esp+4h] [ebp-4h]

	if (*(x_WORD *)(a1 + 46) > 0)
	{
		v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
		if (v1 > x_DWORD_EA3E4[0])
		{
			if (*(x_BYTE *)(v1 + 64) == 1)
				v10 = 64;
			else
				v10 = 2;
			if (*(x_WORD *)(*(x_DWORD *)(v1 + 164) + 12) >= 0)
				v2 = 1;
			else
				v2 = -1;
			if (!sub_68D50(a1, (x_DWORD *)v1) || *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 14))
			{
				if (*(x_WORD *)(*(x_DWORD *)(v1 + 164) + 14))
					*(x_WORD *)(a1 + 46) = 1;
			}
			else
			{
				if (*(x_WORD *)(a1 + 46) == *(x_WORD *)(a1 + 48))
				{
					v3 = *(x_BYTE *)(a1 + 12);
					if (v3 >= 0)
					{
						v4 = (int)x_D41A0_BYTEARRAY_0 + 28302;
						*(x_BYTE *)(a1 + 12) = v3 | 0x80;
						sub_6E450((signed int)(v1 - v4) / 168, -1, 19);
					}
				}
				if (*(signed __int16 *)(a1 + 46) == *(signed __int16 *)(a1 + 48) - v10)
				{
					v5 = *(x_BYTE *)(a1 + 12);
					if (v5 < 0)
						*(x_BYTE *)(a1 + 12) = v5 & 0x7F;
				}
				v11 = (char*)*xadataspellsdat.var28_begin_buffer[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
				_wcpp_1_unwind_leave__98(v1);
				if (*(x_WORD *)(a1 + 46) == *(x_WORD *)(a1 + 48))
				{
					sub_6D8B0(*(x_WORD *)(a1 + 40), 3u, 1);
					*(x_WORD *)(*(x_DWORD *)(v1 + 164) + 12) = v2 * *(x_WORD *)(v1 + 132) * (*(x_WORD *)v11 + 1);
				}
				else
				{
					*(x_WORD *)(*(x_DWORD *)(v1 + 164) + 12) = v2 * *(x_WORD *)v11 * *(x_WORD *)(v1 + 132);
				}
				*(x_WORD *)(v1 + 130) = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 12);
				if (!(*(x_BYTE *)(a1 + 62) & 3))
				{
					v6 = sub_4A190(v1 + 76, 10, 2);
					if (v6)
					{
						v7 = 4 * *(x_DWORD *)(v6 + 8);
						*(x_WORD *)(v6 + 26) = *(x_WORD *)(v1 + 26);
						*(x_DWORD *)(v6 + 8) = v7;
					}
				}
				sub_68DE0(a1, v1);
			}
			v8 = *(x_WORD *)(a1 + 46) - 1;
			*(x_WORD *)(a1 + 46) = v8;
			if (!v8)
			{
				*(x_WORD *)(*(x_DWORD *)(v1 + 164) + 12) = *(x_WORD *)(v1 + 132) * v2;
				*(x_WORD *)(v1 + 130) = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 12);
				*(x_BYTE *)(a1 + 12) &= 0x7Fu;
				sub_6D880(a1);
			}
		}
	}
	v9 = *(x_WORD *)(a1 + 54);
	if (v9)
		*(x_WORD *)(a1 + 54) = v9 - 1;
}
// 5D520: using guessed type int _wcpp_1_unwind_leave__98(x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00069FF0) --------------------------------------------------------
signed int sub_69FF0(int a1)
{
	return sub_692A0(a1);
}

//----- (0006A010) --------------------------------------------------------
signed int sub_6A010(int a1)
{
	return sub_69250(a1);
}

//----- (0006A030) --------------------------------------------------------
char sub_6A030(int a1)
{
	unsigned __int16 v1; // ax
	unsigned int v2; // esi
	int v3; // edi
	int v4; // eax
	int v5; // ecx
	char v6; // al
	int v7; // ST0C_4
	int v8; // eax
	unsigned int v9; // ecx
	int v10; // edx
	__int16 v11; // dx
	unsigned __int16 v12; // di
	int v13; // eax
	__int16 v14; // si
	int v16; // [esp+4h] [ebp-8h]

	v1 = *(x_WORD *)(a1 + 40);
	v2 = x_DWORD_EA3E4[v1];
	v3 = -1;
	if (v2 > x_DWORD_EA3E4[0] && *(x_WORD *)(a1 + 46) > 0)
	{
		if (sub_68D50(a1, (x_DWORD *)v2))
		{
			if (*(x_WORD *)(a1 + 46) == *(x_WORD *)(a1 + 48))
			{
				sub_6D8B0(*(x_WORD *)(a1 + 40), 4u, 1);
				v4 = sub_4A190(v2 + 76, 5, (unsigned __int8)*xadataspellsdat.var28_begin_buffer[80 * *(char *)(a1 + 64) + 26 + 26 * *(char *)(a1 + 70)]);
				v5 = v4;
				if (v4)
				{
					v6 = 8 * *(x_BYTE *)(v4 + 64);
					*(x_BYTE *)(v5 + 73) = 12;
					*(x_BYTE *)(v5 + 69) = v6 + 7;
					*(x_WORD *)(v5 + 40) = *(x_WORD *)(a1 + 40);
					*(x_WORD *)(v5 + 26) = *(x_WORD *)(v2 + 26);
					v7 = (int)x_D41A0_BYTEARRAY_0;
					*(x_WORD *)(a1 + 150) = (v5 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
					*(x_BYTE *)(v5 + 12) |= 1u;
					v8 = *(x_DWORD *)(v2 + 164);
					*(x_BYTE *)(v2 + 12) |= 0x21u;
					if (*(x_WORD *)(v8 + 56) != *(x_WORD *)(v7 + 12))
					{
						*(x_BYTE *)(v5 + 12) &= 0xFEu;
						*(x_BYTE *)(v2 + 12) |= 1u;
					}
					sub_6E450((signed int)(v2 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 60);
				}
			}
			sub_68DE0(a1, v2);
		}
		else
		{
			*(x_WORD *)(a1 + 46) = 1;
		}
		v1 = *(x_WORD *)(*(x_DWORD *)(v2 + 164) + 56);
		if (v1 != *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12))
		{
			v1 = *(x_WORD *)(a1 + 150);
			v9 = x_DWORD_EA3E4[v1];
			if (v9 > x_DWORD_EA3E4[0])
			{
				v10 = *(signed __int16 *)(a1 + 48);
				v16 = *(signed __int16 *)(a1 + 46);
				LOBYTE(v1) = *(x_WORD *)(a1 + 46);
				if (v16 <= v10 - 7)
				{
					v1 = *(x_WORD *)(a1 + 46);
					if ((signed __int16)v1 < 7)
					{
						LOBYTE(v1) = v1 & 1;
						v3 = (unsigned __int8)v1;
					}
				}
				else
				{
					v3 = ((x_BYTE)v10 - (x_BYTE)v16) & 1;
				}
				if (v3 != -1)
				{
					if (v3)
					{
						if (v3 == 1)
						{
							*(x_BYTE *)(v9 + 12) |= 1u;
							*(x_BYTE *)(v2 + 12) &= 0xFEu;
						}
					}
					else
					{
						*(x_BYTE *)(v9 + 12) &= 0xFEu;
						*(x_BYTE *)(v2 + 12) |= 1u;
					}
				}
			}
		}
		v11 = *(x_WORD *)(a1 + 46) - 1;
		*(x_WORD *)(a1 + 46) = v11;
		if (!v11)
		{
			v12 = *(x_WORD *)(a1 + 150);
			if (v12)
			{
				sub_57F10(x_DWORD_EA3E4[v12]);
				*(x_WORD *)(a1 + 150) = 0;
			}
			v13 = *(x_DWORD *)(v2 + 164);
			*(x_BYTE *)(v2 + 12) &= 0xDFu;
			if (*(x_WORD *)(v13 + 56) == *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12))
				sub_6E450((signed int)(v2 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 60);
			else
				*(x_BYTE *)(v2 + 12) &= 0xFEu;
			LOBYTE(v1) = sub_6D880(a1);
		}
	}
	v14 = *(x_WORD *)(a1 + 54);
	if (v14)
		*(x_WORD *)(a1 + 54) = v14 - 1;
	return v1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006A2C0) --------------------------------------------------------
signed int sub_6A2C0(int a1)
{
	return sub_692A0(a1);
}

//----- (0006A2E0) --------------------------------------------------------
signed int sub_6A2E0(int a1)
{
	return sub_69250(a1);
}

//----- (0006A300) --------------------------------------------------------
void sub_6A300(int a1)
{
	x_DWORD *v1; // esi
	int v2; // edx
	int v3; // ecx
	int v4; // edi
	__int16 v5; // ax
	__int16 v6; // cx

	if (*(x_WORD *)(a1 + 46) > 0)
	{
		v1 = (x_DWORD *)x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
		if ((unsigned int)v1 > x_DWORD_EA3E4[0])
		{
			if (sub_68D50(a1, v1) && v1[36] >= *(x_DWORD *)(a1 + 140))
			{
				if (*(x_WORD *)(a1 + 46) == *(x_WORD *)(a1 + 48))
					sub_6E450((signed int)((char *)v1 - (int)x_D41A0_BYTEARRAY_0 - 28302) / 168, -1, 25);
				if (v1[2] < v1[1])
				{
					if (*(x_WORD *)(a1 + 46) == *(x_WORD *)(a1 + 48))
						sub_6D8B0(*(x_WORD *)(a1 + 40), 5u, 1);
					v2 = v1[1] * *(unsigned __int16 *)(a1 + 42) / 100 + v1[2];
					v3 = v1[1];
					v1[2] = v2;
					if (v2 > v3)
						v1[2] = v3;
					v4 = v1[34];
					if (v4 >= 0)
						v1[34] = -*(x_DWORD *)(a1 + 140);
					else
						v1[34] = v4 - *(x_DWORD *)(a1 + 140);
				}
			}
			else
			{
				*(x_WORD *)(a1 + 46) = 1;
			}
		}
		v5 = *(x_WORD *)(a1 + 46) - 1;
		*(x_WORD *)(a1 + 46) = v5;
		if (!v5)
			sub_6D880(a1);
	}
	v6 = *(x_WORD *)(a1 + 54);
	if (v6)
		*(x_WORD *)(a1 + 54) = v6 - 1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006A440) --------------------------------------------------------
signed int sub_6A440(int a1)
{
	return sub_692A0(a1);
}

//----- (0006A460) --------------------------------------------------------
signed int sub_6A460(int a1)
{
	return sub_69250(a1);
}

//----- (0006A480) --------------------------------------------------------
char sub_6A480(int a1)
{
	signed int v1; // eax
	unsigned int v2; // esi
	__int16 v3; // cx

	LOWORD(v1) = *(x_WORD *)(a1 + 40);
	v2 = x_DWORD_EA3E4[(unsigned __int16)v1];
	if (v2 <= x_DWORD_EA3E4[0] || *(x_WORD *)(a1 + 46) <= 0)
		goto LABEL_15;
	LOBYTE(v1) = *xadataspellsdat.var28_begin_buffer[80 * *(char *)(a1 + 64) + 26 + 26 * *(char *)(a1 + 70)];
	if (!(x_BYTE)v1)
	{
		v1 = sub_68D50(a1, (x_DWORD *)v2);
		if (v1)
		{
			*(x_BYTE *)(v2 + 13) |= 0x40u;
			LOBYTE(v1) = sub_68DE0(a1, v2);
			--*(x_WORD *)(a1 + 46);
			goto LABEL_13;
		}
		goto LABEL_12;
	}
	if ((x_BYTE)v1 == 1)
	{
		v1 = sub_68D50(a1, (x_DWORD *)v2);
		if (v1)
		{
			if (*(x_WORD *)(a1 + 46) == *(x_WORD *)(a1 + 48))
				*(x_BYTE *)(v2 + 14) |= 0x40u;
			--*(x_WORD *)(a1 + 46);
			LOBYTE(v1) = sub_68DE0(a1, v2);
			goto LABEL_13;
		}
	LABEL_12:
		*(x_WORD *)(a1 + 46) = 0;
	}
LABEL_13:
	if (!*(x_WORD *)(a1 + 46))
	{
		*(x_DWORD *)(v2 + 12) &= 0xFFBFBFFF;
		LOBYTE(v1) = sub_6D880(a1);
	}
LABEL_15:
	v3 = *(x_WORD *)(a1 + 54);
	if (v3)
		*(x_WORD *)(a1 + 54) = v3 - 1;
	return v1;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006A580) --------------------------------------------------------
signed int sub_6A580(int a1)
{
	return sub_692A0(a1);
}

//----- (0006A5A0) --------------------------------------------------------
signed int sub_6A5A0(int a1)
{
	return sub_69250(a1);
}

//----- (0006A5C0) --------------------------------------------------------
int sub_6A5C0(int a1)
{
	unsigned int v1; // ebx
	char *v2; // edx
	char v3; // al
	int v4; // eax
	__int16 v5; // ax
	int v6; // edx
	__int16 v7; // ax
	int v8; // ecx
	__int16 v9; // bx
	int result; // eax
	__int16 v11; // si
	int v12; // [esp+0h] [ebp-20h]
	int v13; // [esp+4h] [ebp-1Ch]
	char *v14; // [esp+Ch] [ebp-14h]
	int v15; // [esp+10h] [ebp-10h]
	int v16; // [esp+14h] [ebp-Ch]
	__int16 v17; // [esp+18h] [ebp-8h]
	__int16 v18; // [esp+1Ch] [ebp-4h]

	v12 = 0;
	v13 = 0;
	if (*(x_WORD *)(a1 + 46) <= 0)
		goto LABEL_29;
	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
	if (v1 > x_DWORD_EA3E4[0])
	{
		if (sub_68D50(a1, (x_DWORD *)v1))
		{
			if (*(x_WORD *)(a1 + 46) == *(x_WORD *)(a1 + 48))
			{
				v2 = (char*)*xadataspellsdat.var28_begin_buffer[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
				v3 = v2[24];
				v14 = (char*)*xadataspellsdat.var28_begin_buffer[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
				if (v3)
				{
					if ((unsigned __int8)v3 <= 2u)
					{
						v18 = 0;
						v17 = (v3 != 1) + 1;
						while (v18 < v17)
						{
							v16 = sub_6DCA0(v1, v1 + 76, 7u, (__int16 *)v14, *(x_WORD *)(v1 + 130), 1);
							if (v16)
							{
								sub_68E50(v1, v16, a1);
								*(x_WORD *)(v16 + 38) = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
								*(x_WORD *)(v16 + 42) = *(x_WORD *)(a1 + 42);
								*(x_WORD *)(v16 + 26) = *(x_WORD *)(v1 + 26);
								*(x_WORD *)(v16 + 80) += *(x_WORD *)(v1 + 88);
								*(x_DWORD *)(v16 + 144) = *(x_DWORD *)(a1 + 144);
								*(x_WORD *)(v16 + 42) = *(x_WORD *)v14;
								*(x_DWORD *)(v16 + 16) = *(unsigned __int8 *)(*(x_DWORD *)(v1 + 164) + 340);
								*(x_BYTE *)(*(x_DWORD *)(v1 + 164) + 340) = 0;
								*(x_DWORD *)(v16 + 154) = *(x_DWORD *)(v1 + 76);
								*(x_WORD *)(v16 + 158) = *(x_WORD *)(v1 + 80);
								sub_57FA0(
									(x_WORD *)(v16 + 154),
									*(x_WORD *)(*(x_DWORD *)(v1 + 164) + 24) + *(x_WORD *)(v1 + 28),
									*(x_WORD *)(*(x_DWORD *)(v1 + 164) + 26) + *(x_WORD *)(v1 + 30),
									0x4000);
								if (v14[24] == 2)
								{
									if (v18)
										v5 = *(x_WORD *)(v1 + 28) - 113;
									else
										v5 = *(x_WORD *)(v1 + 28) + 113;
									v6 = v16;
									v7 = (*(x_WORD *)(*(x_DWORD *)(v1 + 164) + 24) + v5) & 0x7FF;
								}
								else
								{
									v6 = v16;
									v7 = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 24) + *(x_WORD *)(v1 + 28);
								}
								*(x_WORD *)(v6 + 28) = v7;
								*(x_WORD *)(v16 + 30) = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 26) + *(x_WORD *)(v1 + 30);
								if (v18)
									v13 = v16;
								else
									v12 = v16;
							}
							++v18;
						}
						if (v13)
						{
							v8 = (int)x_D41A0_BYTEARRAY_0 + 28302;
							*(x_WORD *)(v12 + 52) = (v13 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
							*(x_WORD *)(v13 + 52) = (v12 - v8) / 168;
						}
					}
				}
				else
				{
					v4 = sub_6DCA0(v1, v1 + 76, 7u, (__int16 *)v2, *(x_WORD *)(v1 + 130), 1);
					v15 = v4;
					if (v4)
					{
						sub_68E50(v1, v4, a1);
						*(x_WORD *)(v15 + 38) = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
						*(x_WORD *)(v15 + 26) = *(x_WORD *)(v1 + 26);
						*(x_DWORD *)(v15 + 144) = *(x_DWORD *)(a1 + 144);
						*(x_WORD *)(v15 + 80) += *(x_WORD *)(v1 + 88);
						*(x_WORD *)(v15 + 28) = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 24) + *(x_WORD *)(v1 + 28);
						*(x_WORD *)(v15 + 30) = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 26) + *(x_WORD *)(v1 + 30);
						*(x_WORD *)(v15 + 42) = *(x_WORD *)v14;
						*(x_DWORD *)(v15 + 16) = *(unsigned __int8 *)(*(x_DWORD *)(v1 + 164) + 340);
						*(x_BYTE *)(*(x_DWORD *)(v1 + 164) + 340) = 0;
						*(x_DWORD *)(v15 + 154) = *(x_DWORD *)(v1 + 76);
						*(x_WORD *)(v15 + 158) = *(x_WORD *)(v1 + 80);
						sub_57FA0(
							(x_WORD *)(v15 + 154),
							*(x_WORD *)(*(x_DWORD *)(v1 + 164) + 24) + *(x_WORD *)(v1 + 28),
							*(x_WORD *)(*(x_DWORD *)(v1 + 164) + 26) + *(x_WORD *)(v1 + 30),
							0x4000);
						sub_68DE0(a1, v1);
						goto LABEL_27;
					}
				}
			}
			sub_68DE0(a1, v1);
		}
		else
		{
			*(x_WORD *)(a1 + 46) = 1;
		}
	}
LABEL_27:
	v9 = *(x_WORD *)(a1 + 46) - 1;
	*(x_WORD *)(a1 + 46) = v9;
	if (!v9)
		sub_6D880(a1);
LABEL_29:
	result = a1;
	v11 = *(x_WORD *)(a1 + 54);
	if (v11)
		*(x_WORD *)(a1 + 54) = v11 - 1;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006A9C0) --------------------------------------------------------
signed int sub_6A9C0(int a1)
{
	return sub_692A0(a1);
}

//----- (0006A9E0) --------------------------------------------------------
signed int sub_6A9E0(int a1)
{
	return sub_69250(a1);
}

//----- (0006AA00) --------------------------------------------------------
__int16 sub_6AA00(int a1)
{
	unsigned int v1; // esi
	char *v2; // edi
	char v3; // al
	__int16 v4; // cx
	__int16 result; // ax

	v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
	if (v1 > x_DWORD_EA3E4[0])
	{
		if (*(x_WORD *)(a1 + 46) <= 0)
		{
			*(x_WORD *)(v1 + 12) &= 0x7FEFu;
		}
		else
		{
			v2 = (char*)*xadataspellsdat.var28_begin_buffer[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
			if (sub_68D50(a1, (x_DWORD *)v1))
			{
				v3 = v2[24];
				if (v3)
				{
					if (v3 == 1)
						*(x_BYTE *)(v1 + 12) |= 0x10u;
				}
				else
				{
					*(x_BYTE *)(v1 + 13) |= 0x80u;
				}
				sub_68DE0(a1, v1);
			}
			else
			{
				*(x_WORD *)(a1 + 46) = 1;
			}
			v4 = *(x_WORD *)(a1 + 46) - 1;
			*(x_WORD *)(a1 + 46) = v4;
			if (!v4)
				sub_6D880(a1);
		}
	}
	result = *(x_WORD *)(a1 + 54);
	if (result)
		*(x_WORD *)(a1 + 54) = result - 1;
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006AAC0) --------------------------------------------------------
signed int sub_6AAC0(int a1)
{
	return sub_692A0(a1);
}

//----- (0006AAE0) --------------------------------------------------------
signed int sub_6AAE0(int a1)
{
	return sub_69250(a1);
}

//----- (0006AB00) --------------------------------------------------------
int sub_6AB00(int a1)
{
	unsigned int v1; // ebx
	char *v2; // esi
	__int16 v3; // si
	int result; // eax
	__int16 v5; // dx
	int v6; // [esp+0h] [ebp-4h]

	if (*(x_WORD *)(a1 + 46) > 0)
	{
		v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
		if (v1 > x_DWORD_EA3E4[0])
		{
			if (sub_68D50(a1, (x_DWORD *)v1))
			{
				if (*(x_WORD *)(a1 + 46) == *(x_WORD *)(a1 + 48))
				{
					v2 = (char*)*xadataspellsdat.var28_begin_buffer[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
					v6 = sub_6DCA0(v1, v1 + 76, 9u, (__int16 *)v2, *(x_WORD *)(v1 + 130), 1);
					if (v6)
					{
						sub_68E50(v1, v6, a1);
						*(x_WORD *)(v6 + 38) = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
						*(x_WORD *)(v6 + 26) = *(x_WORD *)(v1 + 26);
						*(x_WORD *)(v6 + 80) += *(x_WORD *)(v1 + 88);
						*(x_DWORD *)(v6 + 144) = *(x_DWORD *)(a1 + 144);
						*(x_WORD *)(v6 + 42) = *(x_WORD *)v2;
						*(x_BYTE *)(v6 + 70) = v2[24];
						*(x_DWORD *)(v6 + 16) = *(unsigned __int8 *)(*(x_DWORD *)(v1 + 164) + 340);
						*(x_BYTE *)(*(x_DWORD *)(v1 + 164) + 340) = 0;
						*(x_DWORD *)(v6 + 154) = *(x_DWORD *)(v1 + 76);
						*(x_WORD *)(v6 + 158) = *(x_WORD *)(v1 + 80);
						sub_57FA0(
							(x_WORD *)(v6 + 154),
							*(x_WORD *)(*(x_DWORD *)(v1 + 164) + 24) + *(x_WORD *)(v1 + 28),
							*(x_WORD *)(*(x_DWORD *)(v1 + 164) + 26) + *(x_WORD *)(v1 + 30),
							10240);
						*(x_WORD *)(v6 + 28) = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 24) + *(x_WORD *)(v1 + 28);
						*(x_WORD *)(v6 + 30) = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 26) + *(x_WORD *)(v1 + 30);
					}
				}
				sub_68DE0(a1, v1);
			}
			else
			{
				*(x_WORD *)(a1 + 46) = 1;
			}
		}
		v3 = *(x_WORD *)(a1 + 46) - 1;
		*(x_WORD *)(a1 + 46) = v3;
		if (!v3)
			sub_6D880(a1);
	}
	result = a1;
	v5 = *(x_WORD *)(a1 + 54);
	if (v5)
		*(x_WORD *)(a1 + 54) = v5 - 1;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006AD00) --------------------------------------------------------
signed int sub_6AD00(int a1)
{
	return sub_692A0(a1);
}

//----- (0006AD20) --------------------------------------------------------
signed int sub_6AD20(int a1)
{
	return sub_69250(a1);
}

//----- (0006AD60) --------------------------------------------------------
void sub_6AD60(int a1)
{
	x_DWORD *v1; // eax
	char *v2; // esi
	char v3; // al
	int v4; // eax
	unsigned int v5; // esi
	int v6; // esi
	unsigned __int16 v7; // ax
	unsigned int v8; // edx
	__int16 v9; // ax
	int v10; // esi
	unsigned __int16 v11; // ax
	unsigned int v12; // esi
	bool v13; // cf
	bool v14; // zf
	int v15; // eax
	unsigned int v16; // eax
	int v17; // esi
	unsigned __int16 v18; // ax
	unsigned __int16 v19; // si
	__int16 v20; // ax
	int v21; // esi
	int v22; // ecx
	__int16 v23; // cx
	__int16 v24; // di
	int v25; // [esp+0h] [ebp-14h]
	__int16 v26; // [esp+4h] [ebp-10h]
	int v27; // [esp+8h] [ebp-Ch]
	int v28; // [esp+Ch] [ebp-8h]
	x_DWORD *v29; // [esp+10h] [ebp-4h]

	v28 = 1;
	if (*(x_WORD *)(a1 + 46) > 0)
	{
		v1 = (x_DWORD *)x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
		v29 = v1;
		if ((unsigned int)v1 > x_DWORD_EA3E4[0])
		{
			if (sub_68D50(a1, v1))
			{
				if (*(x_WORD *)(a1 + 46) == *(x_WORD *)(a1 + 48))
				{
					v2 = (char*)*xadataspellsdat.var28_begin_buffer[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
					sub_6D8B0(*(x_WORD *)(a1 + 40), 0xAu, 1);
					v3 = v2[24];
					if ((unsigned __int8)v3 < 1u)
					{
						if (!v3)
						{
							v4 = (int)v29;
							*(x_WORD *)(a1 + 150) = 0;
							v5 = x_DWORD_EA3E4[*(unsigned __int16 *)(*(x_DWORD *)(v4 + 164) + 58)];
							if (v5 <= x_DWORD_EA3E4[0])
							{
								v28 = 0;
							}
							else
							{
								v6 = v5 + 76;
								v25 = *(x_DWORD *)v6;
								v26 = *(x_WORD *)(v6 + 4);
								v7 = *((x_WORD *)v29 + 14) - 204;
								HIBYTE(v7) &= 7u;
								sub_57FA0((x_WORD*)&v25, v7, 0, -448);
								sub_57CF0((int)v29, (int)&v25);
							}
						}
					}
					else if ((unsigned __int8)v3 <= 1u)
					{
						v8 = x_DWORD_EA3E4[*(unsigned __int16 *)(v29[41] + 58)];
						if (v8 <= x_DWORD_EA3E4[0])
						{
							v28 = 0;
						}
						else
						{
							v9 = *(x_WORD *)(a1 + 150);
							if (v9 && v9 == 1)
							{
								sub_57CF0((int)v29, a1 + 154);
								*(x_WORD *)(a1 + 150) = 0;
							}
							else
							{
								v10 = (int)(v29 + 19);
								*(x_DWORD *)(a1 + 154) = v29[19];
								*(x_WORD *)(a1 + 158) = *(x_WORD *)(v10 + 4);
								v25 = *(x_DWORD *)(v8 + 76);
								v26 = *(x_WORD *)(v8 + 80);
								v11 = *((x_WORD *)v29 + 14) - 204;
								HIBYTE(v11) &= 7u;
								sub_57FA0((x_WORD*)&v25, v11, 0, -448);
								sub_57CF0((int)v29, (int)&v25);
								*(x_WORD *)(a1 + 150) = 1;
							}
						}
					}
					else if (v3 == 2)
					{
						v27 = 0;
						v28 = 0;
						while (v27 < 9 && !v28)
						{
							switch (*(x_WORD *)(a1 + 150))
							{
							case 1:
								break;
							case 2:
							case 3:
							case 4:
							case 5:
							case 6:
							case 7:
							case 8:
							case 9:
								v15 = *(unsigned __int16 *)(a1 + 150) - 2;
								if (v15 != *(signed __int16 *)(v29[41] + 56) && v15 < *(unsigned __int16 *)(x_D41A0_BYTEARRAY_0 + 14))
								{
									v16 = x_DWORD_EA3E4[*(unsigned __int16 *)(x_D41A0_BYTEARRAY_0 + 2124 * v15 + 11240)];
									if (v16 > x_DWORD_EA3E4[0])
									{
										v12 = x_DWORD_EA3E4[*(unsigned __int16 *)(*(x_DWORD *)(v16 + 164) + 58)];
										v13 = v12 < x_DWORD_EA3E4[0];
										v14 = v12 == x_DWORD_EA3E4[0];
										goto LABEL_26;
									}
								}
								break;
							default:
								v12 = x_DWORD_EA3E4[*(unsigned __int16 *)(v29[41] + 58)];
								v13 = v12 < x_DWORD_EA3E4[0];
								v14 = v12 == x_DWORD_EA3E4[0];
							LABEL_26:
								if (!((unsigned __int8)v13 | (unsigned __int8)v14))
								{
									v17 = v12 + 76;
									v25 = *(x_DWORD *)v17;
									v26 = *(x_WORD *)(v17 + 4);
									v18 = *((x_WORD *)v29 + 14) - 204;
									HIBYTE(v18) &= 7u;
									sub_57FA0((x_WORD*)&v25, v18, 0, -448);
									sub_57CF0((int)v29, (int)&v25);
									v28 = 1;
								}
								break;
							}
							v19 = *(x_WORD *)(a1 + 150) + 1;
							*(x_WORD *)(a1 + 150) = v19;
							if (v19 >= 9u)
								*(x_WORD *)(a1 + 150) = 0;
							++v27;
						}
					}
					v20 = v28;
					if (!v28)
					{
						v21 = (int)(v29 + 19);
						*(x_DWORD *)(a1 + 154) = v29[19];
						*(x_WORD *)(a1 + 158) = *(x_WORD *)(v21 + 4);
						*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
						sub_57FA0((x_WORD *)(a1 + 154), *(x_WORD *)(a1 + 20) & 0x7FF, v20, 0x4000);
						sub_57CF0((int)v29, a1 + 154);
						*(x_WORD *)(a1 + 150) = 0;
					}
					v22 = v28;
					*(x_WORD *)(v29[41] + 12) = 0;
					if (v22)
						sub_6E450((signed int)((char *)v29 - (int)x_D41A0_BYTEARRAY_0 - 28302) / 168, -1, 22);
				}
				sub_68DE0(a1, (int)v29);
			}
			else
			{
				*(x_WORD *)(a1 + 46) = 1;
			}
			v23 = *(x_WORD *)(a1 + 46) - 1;
			*(x_WORD *)(a1 + 46) = v23;
			if (!v23)
			{
				*(x_WORD *)(v29[41] + 12) = 0;
				sub_6D880(a1);
			}
		}
	}
	v24 = *(x_WORD *)(a1 + 54);
	if (v24)
		*(x_WORD *)(a1 + 54) = v24 - 1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006B180) --------------------------------------------------------
signed int sub_6B180(int a1)
{
	return sub_692A0(a1);
}

//----- (0006B1A0) --------------------------------------------------------
signed int sub_6B1A0(int a1)
{
	return sub_69250(a1);
}

//----- (0006B1C0) --------------------------------------------------------
void sub_6B1C0(int a1)
{
	unsigned int v1; // esi
	char *v2; // edx
	__int16 v3; // di
	int v4; // eax
	__int16 v5; // dx

	if (*(x_WORD *)(a1 + 46) > 0)
	{
		v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
		if (v1 > x_DWORD_EA3E4[0])
		{
			if (sub_68D50(a1, (x_DWORD *)v1))
			{
				if (*(x_WORD *)(a1 + 46) == *(x_WORD *)(a1 + 48))
				{
					sub_6D8B0(*(x_WORD *)(a1 + 40), 0xBu, 1);
					v2 = (char*)*xadataspellsdat.var28_begin_buffer[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
					*(x_WORD *)(*(x_DWORD *)(v1 + 164) + 345) = 0;
					*(x_BYTE *)(*(x_DWORD *)(v1 + 164) + 447) = v2[24];
					*(x_BYTE *)(v1 + 12) |= 0x20u;
				}
				else if (!(*(x_BYTE *)(v1 + 12) & 0x20))
				{
					*(x_WORD *)(a1 + 46) = 1;
				}
				sub_68DE0(a1, v1);
			}
			else
			{
				*(x_WORD *)(a1 + 46) = 1;
			}
		}
		v3 = *(x_WORD *)(a1 + 46) - 1;
		*(x_WORD *)(a1 + 46) = v3;
		if (!v3)
		{
			v4 = *(x_DWORD *)(v1 + 164);
			*(x_BYTE *)(v1 + 12) &= 0xDFu;
			*(x_BYTE *)(v4 + 447) = 0;
			sub_6D880(a1);
		}
	}
	v5 = *(x_WORD *)(a1 + 54);
	if (v5)
		*(x_WORD *)(a1 + 54) = v5 - 1;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006B2D0) --------------------------------------------------------
signed int sub_6B2D0(int a1)
{
	return sub_692A0(a1);
}

//----- (0006B2F0) --------------------------------------------------------
signed int sub_6B2F0(int a1)
{
	return sub_69250(a1);
}

//----- (0006B310) --------------------------------------------------------
__int16 sub_6B310(x_WORD *a1)
{
	unsigned __int16 v1; // ax
	x_DWORD *v2; // esi
	__int16 v3; // si
	__int16 result; // ax

	if (a1[23] > 0)
	{
		v1 = a1[20];
		v2 = (x_DWORD *)x_DWORD_EA3E4[v1];
		if ((unsigned int)v2 > x_DWORD_EA3E4[0])
		{
			if (a1[23] == a1[24])
				sub_6D8B0(v1, 0xCu, 1);
			if (sub_68D50((int)a1, v2))
				sub_68DE0((int)a1, (int)v2);
			else
				a1[23] = 1;
		}
		v3 = a1[23] - 1;
		a1[23] = v3;
		if (!v3)
			sub_6D880((int)a1);
	}
	result = a1[27];
	if (result)
		a1[27] = result - 1;
	return result;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006B3A0) --------------------------------------------------------
signed int sub_6B3A0(int a1)
{
	return sub_692A0(a1);
}

//----- (0006B3C0) --------------------------------------------------------
signed int sub_6B3C0(int a1)
{
	return sub_69250(a1);
}

//----- (0006B3E0) --------------------------------------------------------
int sub_6B3E0(int a1)
{
	unsigned int v1; // ebx
	int v2; // eax
	__int16 v3; // dx
	int result; // eax
	__int16 v5; // cx
	int v6; // [esp+0h] [ebp-4h]

	if (*(x_WORD *)(a1 + 46) > 0)
	{
		v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
		if (v1 > x_DWORD_EA3E4[0])
		{
			if (sub_68D50(a1, (x_DWORD *)v1))
			{
				if (*(x_WORD *)(a1 + 46) == *(x_WORD *)(a1 + 48))
				{
					v2 = sub_6DCA0(
						v1,
						v1 + 76,
						0xDu,
						(__int16 *)&*xadataspellsdat.var28_begin_buffer[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)],
						*(x_WORD *)(v1 + 130),
						1);
					v6 = v2;
					if (v2)
					{
						sub_68E50(v1, v2, a1);
						*(x_WORD *)(v6 + 38) = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
						*(x_WORD *)(v6 + 26) = *(x_WORD *)(v1 + 26);
						*(x_WORD *)(v6 + 80) += *(x_WORD *)(v1 + 88);
						*(x_DWORD *)(v6 + 144) = *(x_DWORD *)(a1 + 144);
						*(x_DWORD *)(v6 + 16) = *(unsigned __int8 *)(*(x_DWORD *)(v1 + 164) + 340);
						*(x_BYTE *)(*(x_DWORD *)(v1 + 164) + 340) = 0;
						*(x_BYTE *)(v6 + 70) = *(x_BYTE *)(a1 + 70);
						*(x_DWORD *)(v6 + 154) = *(x_DWORD *)(v1 + 76);
						*(x_WORD *)(v6 + 158) = *(x_WORD *)(v1 + 80);
						sub_57FA0(
							(x_WORD *)(v6 + 154),
							*(x_WORD *)(*(x_DWORD *)(v1 + 164) + 24) + *(x_WORD *)(v1 + 28),
							*(x_WORD *)(*(x_DWORD *)(v1 + 164) + 26) + *(x_WORD *)(v1 + 30),
							0x4000);
						*(x_WORD *)(v6 + 28) = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 24) + *(x_WORD *)(v1 + 28);
						*(x_WORD *)(v6 + 30) = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 26) + *(x_WORD *)(v1 + 30);
					}
				}
				sub_68DE0(a1, v1);
			}
			else
			{
				*(x_WORD *)(a1 + 46) = 1;
			}
		}
		v3 = *(x_WORD *)(a1 + 46) - 1;
		*(x_WORD *)(a1 + 46) = v3;
		if (!v3)
			sub_6D880(a1);
	}
	result = a1;
	v5 = *(x_WORD *)(a1 + 54);
	if (v5)
		*(x_WORD *)(a1 + 54) = v5 - 1;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006B5D0) --------------------------------------------------------
signed int sub_6B5D0(int a1)
{
	return sub_692A0(a1);
}

//----- (0006B5F0) --------------------------------------------------------
signed int sub_6B5F0(int a1)
{
	return sub_69250(a1);
}

//----- (0006B610) --------------------------------------------------------
__int16 sub_6B610(int a1)
{
	x_DWORD *v1; // eax
	int v2; // eax
	int v3; // edi
	__int16 v4; // ax
	__int16 v5; // si
	__int16 result; // ax
	x_WORD *v7; // [esp+0h] [ebp-Ch]
	int v8; // [esp+4h] [ebp-8h]
	char v9; // [esp+8h] [ebp-4h]

	v9 = 0;
	if (*(x_WORD *)(a1 + 46) > 0)
	{
		v1 = (x_DWORD *)x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
		v8 = (int)v1;
		if ((unsigned int)v1 > x_DWORD_EA3E4[0])
		{
			if (!sub_68D50(a1, v1))
				goto LABEL_19;
			if (*(signed __int16 *)(a1 + 46) <= *(signed __int16 *)(a1 + 48) - 28 && !*(x_WORD *)(*(x_DWORD *)(v8 + 164) + 326))
				v9 = 1;
			if (v9)
			{
			LABEL_19:
				*(x_WORD *)(a1 + 46) = 1;
			}
			else
			{
				if (*(x_WORD *)(a1 + 46) == *(x_WORD *)(a1 + 48))
				{
					v2 = sub_4A190(v8 + 76, 9, 7);
					v7 = (x_WORD *)v2;
					if (v2)
					{
						v3 = v2;
						sub_68E50(v8, v2, a1);
						*(x_WORD *)(v3 + 38) = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
						v4 = *(x_WORD *)(a1 + 42);
						*(x_BYTE *)(v3 + 67) = 10;
						*(x_WORD *)(v3 + 42) = v4;
						*(x_BYTE *)(v3 + 68) = 26;
						*(x_WORD *)(v3 + 26) = *(x_WORD *)(v8 + 26);
						*(x_WORD *)(v3 + 80) += *(x_WORD *)(v8 + 88);
						*(x_DWORD *)(v3 + 144) = *(x_DWORD *)(a1 + 144);
						*(x_BYTE *)(v3 + 70) = *(x_BYTE *)(a1 + 70);
						v3 += 154;
						*(x_DWORD *)v3 = *(x_DWORD *)(v8 + 76);
						*(x_WORD *)(v3 + 4) = *(x_WORD *)(v8 + 80);
						sub_57FA0(
							v7 + 77,
							*(x_WORD *)(*(x_DWORD *)(v8 + 164) + 24) + *(x_WORD *)(v8 + 28),
							*(x_WORD *)(*(x_DWORD *)(v8 + 164) + 26) + *(x_WORD *)(v8 + 30),
							10240);
						v7[14] = *(x_WORD *)(*(x_DWORD *)(v8 + 164) + 24) + *(x_WORD *)(v8 + 28);
						v7[15] = *(x_WORD *)(*(x_DWORD *)(v8 + 164) + 26) + *(x_WORD *)(v8 + 30);
						sub_6E450((signed int)((char *)v7 - (int)x_D41A0_BYTEARRAY_0 - 28302) / 168, -1, 9);
					}
				}
				sub_68DE0(a1, v8);
			}
		}
		v5 = *(x_WORD *)(a1 + 46) - 1;
		*(x_WORD *)(a1 + 46) = v5;
		if (!v5)
			sub_6D880(a1);
	}
	result = *(x_WORD *)(a1 + 54);
	if (result)
		*(x_WORD *)(a1 + 54) = result - 1;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006B830) --------------------------------------------------------
signed int sub_6B830(int a1)
{
	return sub_692A0(a1);
}

//----- (0006B850) --------------------------------------------------------
signed int sub_6B850(int a1)
{
	return sub_69250(a1);
}

//----- (0006B870) --------------------------------------------------------
int sub_6B870(int a1)
{
	unsigned int v1; // ebx
	char *v2; // esi
	__int16 v3; // si
	int result; // eax
	__int16 v5; // dx
	int v6; // [esp+0h] [ebp-4h]

	if (*(x_WORD *)(a1 + 46) > 0)
	{
		v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
		if (v1 > x_DWORD_EA3E4[0])
		{
			if (sub_68D50(a1, (x_DWORD *)v1))
			{
				if (*(x_WORD *)(a1 + 46) == *(x_WORD *)(a1 + 48))
				{
					v2 = (char*)*xadataspellsdat.var28_begin_buffer[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
					v6 = sub_6DCA0(v1, v1 + 76, 0xFu, (__int16 *)v2, *(x_WORD *)(v1 + 130), 1);
					if (v6)
					{
						sub_68E50(v1, v6, a1);
						*(x_WORD *)(v6 + 38) = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
						*(x_WORD *)(v6 + 26) = *(x_WORD *)(v1 + 26);
						*(x_WORD *)(v6 + 80) += *(x_WORD *)(v1 + 88);
						*(x_WORD *)(v6 + 28) = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 24) + *(x_WORD *)(v1 + 28);
						*(x_WORD *)(v6 + 30) = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 26) + *(x_WORD *)(v1 + 30);
						*(x_DWORD *)(v6 + 144) = *(x_DWORD *)(a1 + 144);
						*(x_WORD *)(v6 + 42) = *(x_WORD *)v2;
						*(x_BYTE *)(v6 + 70) = v2[24];
						*(x_DWORD *)(v6 + 16) = *(unsigned __int8 *)(*(x_DWORD *)(v1 + 164) + 340);
						*(x_BYTE *)(*(x_DWORD *)(v1 + 164) + 340) = 0;
						*(x_DWORD *)(v6 + 154) = *(x_DWORD *)(v1 + 76);
						*(x_WORD *)(v6 + 158) = *(x_WORD *)(v1 + 80);
						sub_57FA0((x_WORD *)(v6 + 154), *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 24) + *(x_WORD *)(v1 + 28), 0, 4096);
						*(x_WORD *)(v6 + 158) = sub_10C40((__int16 *)(v6 + 154));
					}
				}
				sub_68DE0(a1, v1);
			}
			else
			{
				*(x_WORD *)(a1 + 46) = 1;
			}
		}
		v3 = *(x_WORD *)(a1 + 46) - 1;
		*(x_WORD *)(a1 + 46) = v3;
		if (!v3)
			sub_6D880(a1);
	}
	result = a1;
	v5 = *(x_WORD *)(a1 + 54);
	if (v5)
		*(x_WORD *)(a1 + 54) = v5 - 1;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006BA70) --------------------------------------------------------
signed int sub_6BA70(int a1)
{
	return sub_692A0(a1);
}

//----- (0006BA90) --------------------------------------------------------
signed int sub_6BA90(int a1)
{
	return sub_69250(a1);
}

//----- (0006BAB0) --------------------------------------------------------
int sub_6BAB0(int a1)
{
	unsigned int v1; // ebx
	char *v2; // esi
	__int16 v3; // si
	int result; // eax
	__int16 v5; // dx
	int v6; // [esp+0h] [ebp-4h]

	if (*(x_WORD *)(a1 + 46) > 0)
	{
		v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
		if (v1 > x_DWORD_EA3E4[0])
		{
			if (sub_68D50(a1, (x_DWORD *)v1))
			{
				if (*(x_WORD *)(a1 + 46) == *(x_WORD *)(a1 + 48))
				{
					v2 = (char*)*xadataspellsdat.var28_begin_buffer[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
					v6 = sub_6DCA0(v1, v1 + 76, 0x10u, (__int16 *)v2, *(x_WORD *)(v1 + 130), 1);
					if (v6)
					{
						sub_68E50(v1, v6, a1);
						*(x_WORD *)(v6 + 38) = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
						*(x_WORD *)(v6 + 26) = *(x_WORD *)(v1 + 26);
						*(x_WORD *)(v6 + 80) += *(x_WORD *)(v1 + 88);
						*(x_WORD *)(v6 + 28) = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 24) + *(x_WORD *)(v1 + 28);
						*(x_WORD *)(v6 + 30) = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 26) + *(x_WORD *)(v1 + 30);
						*(x_DWORD *)(v6 + 144) = *(x_DWORD *)(a1 + 144);
						*(x_WORD *)(v6 + 42) = *(x_WORD *)v2;
						*(x_BYTE *)(v6 + 70) = v2[24];
						*(x_DWORD *)(v6 + 16) = *(unsigned __int8 *)(*(x_DWORD *)(v1 + 164) + 340);
						*(x_BYTE *)(*(x_DWORD *)(v1 + 164) + 340) = 0;
						*(x_DWORD *)(v6 + 154) = *(x_DWORD *)(v1 + 76);
						*(x_WORD *)(v6 + 158) = *(x_WORD *)(v1 + 80);
						sub_57FA0((x_WORD *)(v6 + 154), *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 24) + *(x_WORD *)(v1 + 28), 0, 4096);
						*(x_WORD *)(v6 + 158) = sub_10C40((__int16 *)(v6 + 154));
					}
				}
				sub_68DE0(a1, v1);
			}
			else
			{
				*(x_WORD *)(a1 + 46) = 1;
			}
		}
		v3 = *(x_WORD *)(a1 + 46) - 1;
		*(x_WORD *)(a1 + 46) = v3;
		if (!v3)
			sub_6D880(a1);
	}
	result = a1;
	v5 = *(x_WORD *)(a1 + 54);
	if (v5)
		*(x_WORD *)(a1 + 54) = v5 - 1;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006BCB0) --------------------------------------------------------
signed int sub_6BCB0(int a1)
{
	return sub_692A0(a1);
}

//----- (0006BCD0) --------------------------------------------------------
signed int sub_6BCD0(int a1)
{
	return sub_69250(a1);
}

//----- (0006BCF0) --------------------------------------------------------
int sub_6BCF0(int a1)
{
	unsigned int v1; // ebx
	char *v2; // esi
	__int16 v3; // si
	int result; // eax
	__int16 v5; // dx
	int v6; // [esp+0h] [ebp-4h]

	if (*(x_WORD *)(a1 + 46) > 0)
	{
		v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
		if (v1 > x_DWORD_EA3E4[0])
		{
			if (sub_68D50(a1, (x_DWORD *)v1))
			{
				if (*(x_WORD *)(a1 + 46) == *(x_WORD *)(a1 + 48))
				{
					v2 = (char*)*xadataspellsdat.var28_begin_buffer[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
					v6 = sub_6DCA0(v1, v1 + 76, 0x11u, (__int16 *)v2, *(x_WORD *)(v1 + 130), 1);
					if (v6)
					{
						sub_68E50(v1, v6, a1);
						*(x_WORD *)(v6 + 38) = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
						*(x_WORD *)(v6 + 26) = *(x_WORD *)(v1 + 26);
						*(x_WORD *)(v6 + 80) += *(x_WORD *)(v1 + 88);
						*(x_WORD *)(v6 + 28) = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 24) + *(x_WORD *)(v1 + 28);
						*(x_WORD *)(v6 + 30) = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 26) + *(x_WORD *)(v1 + 30);
						*(x_DWORD *)(v6 + 144) = *(x_DWORD *)(a1 + 144);
						*(x_WORD *)(v6 + 42) = *(x_WORD *)v2;
						*(x_BYTE *)(v6 + 70) = v2[24];
						*(x_DWORD *)(v6 + 16) = *(unsigned __int8 *)(*(x_DWORD *)(v1 + 164) + 340);
						*(x_BYTE *)(*(x_DWORD *)(v1 + 164) + 340) = 0;
						*(x_DWORD *)(v6 + 154) = *(x_DWORD *)(v1 + 76);
						*(x_WORD *)(v6 + 158) = *(x_WORD *)(v1 + 80);
						sub_57FA0((x_WORD *)(v6 + 154), *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 24) + *(x_WORD *)(v1 + 28), 0, 4096);
						*(x_WORD *)(v6 + 158) = sub_10C40((__int16 *)(v6 + 154));
					}
					sub_68DE0(a1, v1);
				}
			}
			else
			{
				*(x_WORD *)(a1 + 46) = 1;
			}
		}
		v3 = *(x_WORD *)(a1 + 46) - 1;
		*(x_WORD *)(a1 + 46) = v3;
		if (!v3)
			sub_6D880(a1);
	}
	result = a1;
	v5 = *(x_WORD *)(a1 + 54);
	if (v5)
		*(x_WORD *)(a1 + 54) = v5 - 1;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006BEF0) --------------------------------------------------------
signed int sub_6BEF0(int a1)
{
	return sub_692A0(a1);
}

//----- (0006BF10) --------------------------------------------------------
signed int sub_6BF10(int a1)
{
	return sub_69250(a1);
}

//----- (0006BF30) --------------------------------------------------------
int sub_6BF30(int a1)
{
	unsigned int v1; // ebx
	char *v2; // esi
	__int16 v3; // dx
	int result; // eax
	__int16 v5; // cx
	int v6; // [esp+0h] [ebp-4h]

	if (*(x_WORD *)(a1 + 46) > 0)
	{
		v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
		if (v1 > x_DWORD_EA3E4[0])
		{
			if (sub_68D50(a1, (x_DWORD *)v1))
			{
				if (*(x_WORD *)(a1 + 46) == *(x_WORD *)(a1 + 48))
				{
					v2 = (char*)*xadataspellsdat.var28_begin_buffer[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
					v6 = sub_6DCA0(v1, v1 + 76, 0x12u, (__int16 *)v2, *(x_WORD *)(v1 + 130), 1);
					if (v6)
					{
						sub_68E50(v1, v6, a1);
						*(x_WORD *)(v6 + 38) = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
						*(x_WORD *)(v6 + 26) = *(x_WORD *)(v1 + 26);
						*(x_WORD *)(v6 + 80) += *(x_WORD *)(v1 + 88);
						*(x_DWORD *)(v6 + 144) = *(x_DWORD *)(a1 + 144);
						*(x_WORD *)(v6 + 42) = *(x_WORD *)v2;
						*(x_BYTE *)(v6 + 70) = v2[24];
						*(x_DWORD *)(v6 + 16) = *(unsigned __int8 *)(*(x_DWORD *)(v1 + 164) + 340);
						*(x_BYTE *)(*(x_DWORD *)(v1 + 164) + 340) = 0;
						*(x_DWORD *)(v6 + 154) = *(x_DWORD *)(v1 + 76);
						*(x_WORD *)(v6 + 158) = *(x_WORD *)(v1 + 80);
						sub_57FA0((x_WORD *)(v6 + 154), *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 24) + *(x_WORD *)(v1 + 28), 0, 4096);
						*(x_WORD *)(v6 + 158) = sub_10C40((__int16 *)(v6 + 154));
						*(x_WORD *)(v6 + 28) = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 24) + *(x_WORD *)(v1 + 28);
						*(x_WORD *)(v6 + 30) = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 26) + *(x_WORD *)(v1 + 30);
					}
					sub_68DE0(a1, v1);
				}
			}
			else
			{
				*(x_WORD *)(a1 + 46) = 1;
			}
		}
		v3 = *(x_WORD *)(a1 + 46) - 1;
		*(x_WORD *)(a1 + 46) = v3;
		if (!v3)
			sub_6D880(a1);
	}
	result = a1;
	v5 = *(x_WORD *)(a1 + 54);
	if (v5)
		*(x_WORD *)(a1 + 54) = v5 - 1;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006C130) --------------------------------------------------------
signed int sub_6C130(int a1)
{
	return sub_692A0(a1);
}

//----- (0006C150) --------------------------------------------------------
signed int sub_6C150(int a1)
{
	return sub_69250(a1);
}

//----- (0006C170) --------------------------------------------------------
__int16 sub_6C170(int a1)
{
	x_DWORD *v1; // eax
	char *v2; // esi
	__int16 v3; // ax
	__int16 v4; // si
	__int16 result; // ax
	int v6; // [esp+0h] [ebp-8h]
	int v7; // [esp+4h] [ebp-4h]

	if (*(x_WORD *)(a1 + 46) > 0)
	{
		v1 = (x_DWORD *)x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
		v7 = (int)v1;
		if ((unsigned int)v1 > x_DWORD_EA3E4[0])
		{
			if (sub_68D50(a1, v1))
			{
				if (*(x_WORD *)(a1 + 46) == *(x_WORD *)(a1 + 48))
				{
					v2 = (char*)*xadataspellsdat.var28_begin_buffer[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
					v6 = sub_4A190(v7 + 76, 9, 24);
					if (v6)
					{
						*(x_WORD *)(v6 + 130) += *(x_WORD *)(v7 + 130);
						sub_68E50(v7, v6, a1);
						v3 = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
						*(x_BYTE *)(v6 + 67) = 10;
						*(x_WORD *)(v6 + 38) = v3;
						*(x_BYTE *)(v6 + 68) = 72;
						*(x_WORD *)(v6 + 26) = *(x_WORD *)(v7 + 26);
						*(x_WORD *)(v6 + 40) = *(x_WORD *)(a1 + 40);
						*(x_BYTE *)(v6 + 70) = v2[24];
						*(x_DWORD *)(v6 + 16) = *(unsigned __int8 *)(*(x_DWORD *)(v7 + 164) + 340);
						*(x_BYTE *)(*(x_DWORD *)(v7 + 164) + 340) = 0;
						*(x_DWORD *)(v6 + 154) = *(x_DWORD *)(v7 + 76);
						*(x_WORD *)(v6 + 158) = *(x_WORD *)(v7 + 80);
						sub_57FA0(
							(x_WORD *)(v6 + 154),
							*(x_WORD *)(*(x_DWORD *)(v7 + 164) + 24) + *(x_WORD *)(v7 + 28),
							*(x_WORD *)(*(x_DWORD *)(v7 + 164) + 26) + *(x_WORD *)(v7 + 30),
							0x4000);
						*(x_WORD *)(v6 + 28) = *(x_WORD *)(*(x_DWORD *)(v7 + 164) + 24) + *(x_WORD *)(v7 + 28);
						*(x_WORD *)(v6 + 30) = *(x_WORD *)(*(x_DWORD *)(v7 + 164) + 26) + *(x_WORD *)(v7 + 30);
						sub_6E450((v6 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 9);
					}
				}
				sub_68DE0(a1, v7);
			}
			else
			{
				*(x_WORD *)(a1 + 46) = 1;
			}
		}
		v4 = *(x_WORD *)(a1 + 46) - 1;
		*(x_WORD *)(a1 + 46) = v4;
		if (!v4)
			sub_6D880(a1);
	}
	result = *(x_WORD *)(a1 + 54);
	if (result)
		*(x_WORD *)(a1 + 54) = result - 1;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006C3A0) --------------------------------------------------------
signed int sub_6C3A0(int a1)
{
	return sub_692A0(a1);
}

//----- (0006C3C0) --------------------------------------------------------
signed int sub_6C3C0(int a1)
{
	return sub_69250(a1);
}

//----- (0006C3E0) --------------------------------------------------------
int sub_6C3E0(int a1)
{
	unsigned int v1; // ebx
	char *v2; // esi
	__int16 v3; // si
	int result; // eax
	__int16 v5; // dx
	int v6; // [esp+0h] [ebp-4h]

	if (*(x_WORD *)(a1 + 46) > 0)
	{
		v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
		if (v1 > x_DWORD_EA3E4[0])
		{
			if (sub_68D50(a1, (x_DWORD *)v1))
			{
				if (*(x_WORD *)(a1 + 46) == *(x_WORD *)(a1 + 48))
				{
					v2 = (char*)*xadataspellsdat.var28_begin_buffer[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
					v6 = sub_6DCA0(v1, v1 + 76, 0x14u, (__int16 *)v2, *(x_WORD *)(v1 + 130), 1);
					if (v6)
					{
						sub_68E50(v1, v6, a1);
						*(x_WORD *)(v6 + 38) = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
						*(x_WORD *)(v6 + 26) = *(x_WORD *)(v1 + 26);
						*(x_WORD *)(v6 + 80) += *(x_WORD *)(v1 + 88);
						*(x_WORD *)(v6 + 28) = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 24) + *(x_WORD *)(v1 + 28);
						*(x_WORD *)(v6 + 30) = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 26) + *(x_WORD *)(v1 + 30);
						*(x_DWORD *)(v6 + 144) = *(x_DWORD *)(a1 + 144);
						*(x_WORD *)(v6 + 42) = *(x_WORD *)v2;
						*(x_BYTE *)(v6 + 70) = v2[24];
						*(x_DWORD *)(v6 + 16) = *(unsigned __int8 *)(*(x_DWORD *)(v1 + 164) + 340);
						*(x_BYTE *)(*(x_DWORD *)(v1 + 164) + 340) = 0;
						*(x_DWORD *)(v6 + 154) = *(x_DWORD *)(v1 + 76);
						*(x_WORD *)(v6 + 158) = *(x_WORD *)(v1 + 80);
						sub_57FA0((x_WORD *)(v6 + 154), *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 24) + *(x_WORD *)(v1 + 28), 0, 4096);
						*(x_WORD *)(v6 + 158) = sub_10C40((__int16 *)(v6 + 154));
					}
				}
				sub_68DE0(a1, v1);
			}
			else
			{
				*(x_WORD *)(a1 + 46) = 1;
			}
		}
		v3 = *(x_WORD *)(a1 + 46) - 1;
		*(x_WORD *)(a1 + 46) = v3;
		if (!v3)
			sub_6D880(a1);
	}
	result = a1;
	v5 = *(x_WORD *)(a1 + 54);
	if (v5)
		*(x_WORD *)(a1 + 54) = v5 - 1;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006C5E0) --------------------------------------------------------
signed int sub_6C5E0(int a1)
{
	return sub_692A0(a1);
}

//----- (0006C600) --------------------------------------------------------
signed int sub_6C600(int a1)
{
	return sub_69250(a1);
}

//----- (0006C620) --------------------------------------------------------
int sub_6C620(int a1)
{
	unsigned int v1; // ebx
	char *v2; // edi
	int v3; // esi
	unsigned __int8 v4; // ah
	int v5; // eax
	__int16 v6; // dx
	int result; // eax
	__int16 v8; // cx

	if (*(x_WORD *)(a1 + 46) > 0)
	{
		v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
		if (v1 > x_DWORD_EA3E4[0])
		{
			if (sub_68D50(a1, (x_DWORD *)v1))
			{
				if (*(x_WORD *)(a1 + 46) == *(x_WORD *)(a1 + 48))
				{
					v2 = (char*)*xadataspellsdat.var28_begin_buffer[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
					v3 = sub_6DCA0(v1, v1 + 76, 0x15u, (__int16 *)v2, *(x_WORD *)(v1 + 130), 1);
					if (v3)
					{
						sub_68E50(v1, v3, a1);
						*(x_WORD *)(v3 + 38) = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
						*(x_WORD *)(v3 + 26) = *(x_WORD *)(v1 + 26);
						*(x_WORD *)(v3 + 80) += *(x_WORD *)(v1 + 88);
						*(x_DWORD *)(v3 + 144) = *(x_DWORD *)(a1 + 144);
						v4 = v2[24];
						if (v4)
							v5 = *(x_DWORD *)v2 / (signed int)v4;
						else
							LOWORD(v5) = *(x_WORD *)v2;
						*(x_WORD *)(v3 + 42) = v5;
						*(x_BYTE *)(v3 + 70) = v2[24];
						*(x_DWORD *)(v3 + 16) = *(unsigned __int8 *)(*(x_DWORD *)(v1 + 164) + 340);
						*(x_BYTE *)(*(x_DWORD *)(v1 + 164) + 340) = 0;
						*(x_DWORD *)(v3 + 154) = *(x_DWORD *)(v1 + 76);
						*(x_WORD *)(v3 + 158) = *(x_WORD *)(v1 + 80);
						sub_57FA0((x_WORD *)(v3 + 154), *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 24) + *(x_WORD *)(v1 + 28), 0, 4096);
						*(x_WORD *)(v3 + 158) = sub_10C40((__int16 *)(v3 + 154));
						*(x_WORD *)(v3 + 28) = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 24) + *(x_WORD *)(v1 + 28);
						*(x_WORD *)(v3 + 30) = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 26) + *(x_WORD *)(v1 + 30);
					}
					sub_68DE0(a1, v1);
				}
			}
			else
			{
				*(x_WORD *)(a1 + 46) = 1;
			}
		}
		v6 = *(x_WORD *)(a1 + 46) - 1;
		*(x_WORD *)(a1 + 46) = v6;
		if (!v6)
			sub_6D880(a1);
	}
	result = a1;
	v8 = *(x_WORD *)(a1 + 54);
	if (v8)
		*(x_WORD *)(a1 + 54) = v8 - 1;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006C830) --------------------------------------------------------
signed int sub_6C830(int a1)
{
	return sub_692A0(a1);
}

//----- (0006C850) --------------------------------------------------------
signed int sub_6C850(int a1)
{
	return sub_69250(a1);
}

//----- (0006C870) --------------------------------------------------------
__int16 sub_6C870(int a1)
{
	int v1; // esi
	unsigned int v2; // edi
	int v3; // eax
	__int16 v4; // si
	__int16 result; // ax
	signed int v6; // [esp+0h] [ebp-8h]
	char *v7; // [esp+4h] [ebp-4h]

	v1 = 0;
	if (*(x_WORD *)(a1 + 46) > 0)
	{
		v2 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
		if (v2 > x_DWORD_EA3E4[0])
		{
			if (sub_68D50(a1, (x_DWORD *)v2))
			{
				if (*(x_WORD *)(a1 + 46) == *(x_WORD *)(a1 + 48))
				{
					if (sub_4A810() > 6)
					{
						v6 = 0;
						v7 = (char*)*xadataspellsdat.var28_begin_buffer[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
						while (v6 < 6)
						{
							v1 = sub_4A190(v2 + 76, 10, 57);
							if (v1)
							{
								v3 = 4 * *(signed __int16 *)(v2 + 130);
								if (v3 < 140)
									v3 = 140;
								if (v3 > 280)
									LOWORD(v3) = 280;
								*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
								*(x_WORD *)(v1 + 130) = (*(x_WORD *)(a1 + 20) & 0x7F) + v3;
								sub_68E50(v2, v1, a1);
								*(x_WORD *)(v1 + 40) = *(x_WORD *)(v2 + 26);
								*(x_WORD *)(v1 + 42) = *(x_WORD *)v7;
								*(x_BYTE *)(v1 + 70) = v7[24];
								*(x_WORD *)(v1 + 148) = 0;
								if ((unsigned __int8)v7[24] >= 3u)
								{
									*(x_WORD *)(v1 + 148) = *(x_WORD *)(v2 + 26);
									sub_36920(a1, v1);
								}
								*(x_WORD *)(a1 + 20) = 9377 * *(x_WORD *)(a1 + 20) + 9439;
								*(x_WORD *)(v1 + 28) = (*(x_WORD *)(v2 + 28)
									- 85
									+ *(x_WORD *)(a1 + 20) % 0xAAu
									+ *(x_WORD *)(*(x_DWORD *)(v2 + 164) + 24)) & 0x7FF;
								*(x_WORD *)(v1 + 30) = *(x_WORD *)(*(x_DWORD *)(v2 + 164) + 26) + *(x_WORD *)(v2 + 30);
							}
							++v6;
						}
						if (v1)
							sub_6E450((v1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 11);
					}
					sub_68DE0(a1, v2);
				}
			}
			else
			{
				*(x_WORD *)(a1 + 46) = 1;
			}
		}
		v4 = *(x_WORD *)(a1 + 46) - 1;
		*(x_WORD *)(a1 + 46) = v4;
		if (!v4)
			sub_6D880(a1);
	}
	result = *(x_WORD *)(a1 + 54);
	if (result)
		*(x_WORD *)(a1 + 54) = result - 1;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006CA80) --------------------------------------------------------
signed int sub_6CA80(int a1)
{
	return sub_692A0(a1);
}

//----- (0006CAA0) --------------------------------------------------------
signed int sub_6CAA0(int a1)
{
	return sub_69250(a1);
}

//----- (0006CAC0) --------------------------------------------------------
int sub_6CAC0(int a1)
{
	x_DWORD *v1; // eax
	int v2; // ebx
	int v3; // edx
	int v4; // eax
	__int16 v5; // di
	int result; // eax
	__int16 v7; // bx
	int v8; // [esp+0h] [ebp-4h]

	if (*(x_WORD *)(a1 + 46) > 0)
	{
		v1 = (x_DWORD *)x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
		v8 = (int)v1;
		if ((unsigned int)v1 > x_DWORD_EA3E4[0])
		{
			if (sub_68D50(a1, v1))
			{
				if (*(x_WORD *)(a1 + 46) == *(x_WORD *)(a1 + 48))
				{
					v2 = sub_4A190(v8 + 76, 9, 29);
					if (v2)
					{
						*(x_WORD *)(v2 + 130) += *(x_WORD *)(v8 + 130);
						sub_68E50(v8, v2, a1);
						v3 = a1 - (x_D41A0_BYTEARRAY_0[28302]);
						*(x_BYTE *)(v2 + 67) = 10;
						*(x_BYTE *)(v2 + 68) = 78;
						*(x_WORD *)(v2 + 38) = v3 / 168;
						*(x_WORD *)(v2 + 26) = *(x_WORD *)(v8 + 26);
						*(x_WORD *)(v2 + 80) += *(x_WORD *)(v8 + 88);
						*(x_DWORD *)(v2 + 144) = *(x_DWORD *)(a1 + 144);
						*(x_WORD *)(v2 + 42) = *(char *)(a1 + 70);
						*(x_DWORD *)(v2 + 16) = *(unsigned __int8 *)(*(x_DWORD *)(v8 + 164) + 340);
						*(x_BYTE *)(*(x_DWORD *)(v8 + 164) + 340) = 0;
						*(x_DWORD *)(v2 + 154) = *(x_DWORD *)(v8 + 76);
						*(x_WORD *)(v2 + 158) = *(x_WORD *)(v8 + 80);
						sub_57FA0((x_WORD *)(v2 + 154), *(x_WORD *)(*(x_DWORD *)(v8 + 164) + 24) + *(x_WORD *)(v8 + 28), 0, 4096);
						*(x_WORD *)(v2 + 158) = sub_10C40((__int16 *)(v2 + 154));
						*(x_WORD *)(v2 + 28) = *(x_WORD *)(*(x_DWORD *)(v8 + 164) + 24) + *(x_WORD *)(v8 + 28);
						v4 = (int)x_D41A0_BYTEARRAY_0 + 28302;
						*(x_WORD *)(v2 + 30) = *(x_WORD *)(*(x_DWORD *)(v8 + 164) + 26) + *(x_WORD *)(v8 + 30);
						sub_6E450((v2 - v4) / 168, -1, 15);
					}
					sub_68DE0(a1, v8);
				}
			}
			else
			{
				*(x_WORD *)(a1 + 46) = 1;
			}
		}
		v5 = *(x_WORD *)(a1 + 46) - 1;
		*(x_WORD *)(a1 + 46) = v5;
		if (!v5)
			sub_6D880(a1);
	}
	result = a1;
	v7 = *(x_WORD *)(a1 + 54);
	if (v7)
		*(x_WORD *)(a1 + 54) = v7 - 1;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006CCE0) --------------------------------------------------------
signed int sub_6CCE0(int a1)
{
	return sub_692A0(a1);
}

//----- (0006CD00) --------------------------------------------------------
signed int sub_6CD00(int a1)
{
	return sub_69250(a1);
}

//----- (0006CD20) --------------------------------------------------------
int sub_6CD20(int a1)
{
	x_DWORD *v1; // eax
	char *v2; // esi
	int v3; // ebx
	__int16 v4; // ax
	int v5; // eax
	__int16 v6; // di
	int result; // eax
	__int16 v8; // bx
	int v9; // [esp+0h] [ebp-4h]

	if (*(x_WORD *)(a1 + 46) > 0)
	{
		v1 = (x_DWORD *)x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
		v9 = (int)v1;
		if ((unsigned int)v1 > x_DWORD_EA3E4[0])
		{
			if (sub_68D50(a1, v1))
			{
				if (*(x_WORD *)(a1 + 46) == *(x_WORD *)(a1 + 48))
				{
					v2 = (char*)*xadataspellsdat.var28_begin_buffer[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
					v3 = sub_4A190(v9 + 76, 9, 25);
					if (v3)
					{
						*(x_WORD *)(v3 + 130) += *(x_WORD *)(v9 + 130);
						sub_68E50(v9, v3, a1);
						v4 = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
						*(x_BYTE *)(v3 + 67) = 10;
						*(x_WORD *)(v3 + 38) = v4;
						*(x_BYTE *)(v3 + 68) = 74;
						*(x_WORD *)(v3 + 26) = *(x_WORD *)(v9 + 26);
						*(x_WORD *)(v3 + 40) = *(x_WORD *)(a1 + 40);
						*(x_WORD *)(v3 + 42) = *(x_WORD *)v2;
						*(x_BYTE *)(v3 + 70) = v2[24];
						*(x_DWORD *)(v3 + 16) = *(unsigned __int8 *)(*(x_DWORD *)(v9 + 164) + 340);
						*(x_BYTE *)(*(x_DWORD *)(v9 + 164) + 340) = 0;
						*(x_DWORD *)(v3 + 154) = *(x_DWORD *)(v9 + 76);
						*(x_WORD *)(v3 + 158) = *(x_WORD *)(v9 + 80);
						sub_57FA0(
							(x_WORD *)(v3 + 154),
							*(x_WORD *)(*(x_DWORD *)(v9 + 164) + 24) + *(x_WORD *)(v9 + 28),
							*(x_WORD *)(*(x_DWORD *)(v9 + 164) + 26) + *(x_WORD *)(v9 + 30),
							0x4000);
						*(x_WORD *)(v3 + 28) = *(x_WORD *)(*(x_DWORD *)(v9 + 164) + 24) + *(x_WORD *)(v9 + 28);
						v5 = (int)x_D41A0_BYTEARRAY_0 + 28302;
						*(x_WORD *)(v3 + 30) = *(x_WORD *)(*(x_DWORD *)(v9 + 164) + 26) + *(x_WORD *)(v9 + 30);
						sub_6E450((v3 - v5) / 168, -1, 9);
					}
				}
				sub_68DE0(a1, v9);
			}
			else
			{
				*(x_WORD *)(a1 + 46) = 1;
			}
		}
		v6 = *(x_WORD *)(a1 + 46) - 1;
		*(x_WORD *)(a1 + 46) = v6;
		if (!v6)
			sub_6D880(a1);
	}
	result = a1;
	v8 = *(x_WORD *)(a1 + 54);
	if (v8)
		*(x_WORD *)(a1 + 54) = v8 - 1;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006CF60) --------------------------------------------------------
signed int sub_6CF60(int a1)
{
	return sub_692A0(a1);
}

//----- (0006CF80) --------------------------------------------------------
signed int sub_6CF80(int a1)
{
	return sub_69250(a1);
}

//----- (0006CFA0) --------------------------------------------------------
int sub_6CFA0(int a1)
{
	unsigned int v1; // ebx
	char *v2; // edi
	int v3; // esi
	unsigned __int8 v4; // dl
	int v5; // eax
	__int16 v6; // dx
	int result; // eax
	__int16 v8; // cx

	if (x_BYTE_D41B6 && *(x_WORD *)(a1 + 46) > 0)
	{
		v1 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
		if (v1 > x_DWORD_EA3E4[0])
		{
			if (sub_68D50(a1, (x_DWORD *)v1))
			{
				if (*(x_WORD *)(a1 + 46) == *(x_WORD *)(a1 + 48))
				{
					v2 = (char*)*xadataspellsdat.var28_begin_buffer[80 * *(char *)(a1 + 64) + 2 + 26 * *(char *)(a1 + 70)];
					v3 = sub_6DCA0(v1, v1 + 76, 0x19u, (__int16 *)v2, *(x_WORD *)(v1 + 130), 1);
					if (v3)
					{
						sub_68E50(v1, v3, a1);
						*(x_WORD *)(v3 + 38) = (a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168;
						*(x_WORD *)(v3 + 26) = *(x_WORD *)(v1 + 26);
						*(x_WORD *)(v3 + 80) += *(x_WORD *)(v1 + 88);
						*(x_DWORD *)(v3 + 144) = *(x_DWORD *)(a1 + 144);
						v4 = v2[24];
						if (v4)
							v5 = *(x_DWORD *)v2 / (signed int)v4;
						else
							LOWORD(v5) = *(x_WORD *)v2;
						*(x_WORD *)(v3 + 42) = v5;
						*(x_BYTE *)(v3 + 70) = v2[24];
						*(x_DWORD *)(v3 + 16) = *(unsigned __int8 *)(*(x_DWORD *)(v1 + 164) + 340);
						*(x_BYTE *)(*(x_DWORD *)(v1 + 164) + 340) = 0;
						*(x_DWORD *)(v3 + 154) = *(x_DWORD *)(v1 + 76);
						*(x_WORD *)(v3 + 158) = *(x_WORD *)(v1 + 80);
						sub_57FA0((x_WORD *)(v3 + 154), *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 24) + *(x_WORD *)(v1 + 28), 0, 4096);
						*(x_WORD *)(v3 + 158) = sub_10C40((__int16 *)(v3 + 154));
						*(x_WORD *)(v3 + 28) = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 24) + *(x_WORD *)(v1 + 28);
						*(x_WORD *)(v3 + 30) = *(x_WORD *)(*(x_DWORD *)(v1 + 164) + 26) + *(x_WORD *)(v1 + 30);
					}
					sub_68DE0(a1, v1);
				}
			}
			else
			{
				*(x_WORD *)(a1 + 46) = 1;
			}
		}
		v6 = *(x_WORD *)(a1 + 46) - 1;
		*(x_WORD *)(a1 + 46) = v6;
		if (!v6)
			sub_6D880(a1);
	}
	result = a1;
	v8 = *(x_WORD *)(a1 + 54);
	if (v8)
		*(x_WORD *)(a1 + 54) = v8 - 1;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41B6: using guessed type char x_BYTE_D41B6;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006D1C0) --------------------------------------------------------
signed int sub_6D1C0(int a1)
{
	return sub_692A0(a1);
}

//----- (0006D1E0) --------------------------------------------------------
signed int sub_6D1E0(int a1)
{
	return sub_69250(a1);
}

//----- (0006D200) --------------------------------------------------------
__int16 sub_6D200(int a1)
{
	int v1; // eax
	signed int v2; // ecx
	char v3; // bl
	__int16 v4; // ax
	unsigned __int8 v5; // bl
	int v6; // ebx
	int v7; // edx
	//__int16 v8; // bx
	__int16 v9; // di
	int v10; // ebx
	int v11; // eax
	__int16 v12; // bx
	__int16 v13; // ax
	//int v15; // [esp+8h] [ebp-14h]
	__int16 v16; // [esp+Ch] [ebp-10h]
	__int16 v17; // [esp+14h] [ebp-8h]

	LOWORD(v1) = *(x_WORD *)(a1 + 7);
	if ((x_WORD)v1 == *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12))
	{
		BYTE1(v1) = *(x_BYTE *)(a1 + 991);
		if (BYTE1(v1) == 5 || BYTE1(v1) == 8)
		{
			if (x_WORD_180660_VGA_type_resolution & 1)
				v2 = 400;
			else
				v2 = 480;
			v3 = *(x_BYTE *)(a1 + 2110);
			if (v3 < 13)
				v4 = v3;
			else
				v4 = v3 - 13;
			v17 = v4;
			/*v1 = **filearray_2aa18c[6];
			v15 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 539);
			v5 = *(x_BYTE *)(a1 + 2109);*/ // fix it
			v5 = 0;  //fix it
			if (v5)
			{
				if (v5 <= 2u)
				{
					/*v8 = (unsigned __int8)x_BYTE_D94FF[*(char *)(a1 + 2110)];
					LOBYTE(v8) = *(x_BYTE *)(**filearray_2aa18c[6] + 982);
					v9 = 3 * v8;
					v16 = v8;
					LOWORD(v1) = *(unsigned __int8 *)(**filearray_2aa18c[6] + 983);
					v10 = v2 - 2 * v15 - v1;
					v11 = ((signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 538) >> 1)
						+ *(unsigned __int8 *)(**filearray_2aa18c[6] + 538) * v17
						+ *(unsigned __int8 *)(**filearray_2aa18c[6] + 532)
						- (v9 >> 1);*/ //fix it
					v10 = 0; v9 = 0;v16 = 0; v11 = 0;//fix it
					v12 = v10 + 18;
					if (640 - v9 >= (signed __int16)v11)
					{
						if ((v11 & 0x8000u) != 0)
							LOWORD(v11) = 0;
					}
					else
					{
						LOWORD(v11) = 640 - v9;
					}
					v13 = v16 * *(char *)((unsigned __int8)x_BYTE_D94FF[*(char *)(a1 + 2110)] + a1 + 1609 + 468)
						+ (v16 >> 1)
						+ 8
						+ v11;
					if (x_WORD_1805C2 != 7 && x_WORD_1805C2 != 1 && x_WORD_1805C2 != 2)
					{
						x_DWORD_1805B0 = v13;
						LOWORD(v1) = v12;
						x_DWORD_1805B4 = v12;
					}
					else
					{
						LOWORD(v1) = sub_5BDC0_set_mouse_position(v13, v12);
					}
				}
			}
			else
			{
				/*v6 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 538) * v17
				   + *(unsigned __int8 *)(**filearray_2aa18c[6] + 532)
				   + ((signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 538) >> 1);
				v7 = ((signed __int16)v15 >> 1)
				   + (signed __int16)v2
				   - 2 * (signed __int16)v15
				   + (signed __int16)v15 * (*(x_BYTE *)(a1 + 2110) >= 13);*/ // fix it
				v6 = 0;v7 = 0;  //fix it
				if (x_WORD_1805C2 != 7 && x_WORD_1805C2 != 1 && x_WORD_1805C2 != 2)
				{
					x_DWORD_1805B0 = (signed __int16)v6;
					LOWORD(v1) = v7;
					x_DWORD_1805B4 = (signed __int16)v7;
				}
				else
				{
					LOWORD(v1) = sub_5BDC0_set_mouse_position(v6, v7);
				}
			}
		}
	}
	return v1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3DC: using guessed type int **filearray_2aa18c[6];
// 1805B0: using guessed type int x_DWORD_1805B0;
// 1805B4: using guessed type int x_DWORD_1805B4;
// 1805C2: using guessed type __int16 x_WORD_1805C2;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0006D420) --------------------------------------------------------
int sub_6D420(__int16 a1, __int16 a2)
{
	signed __int16 v2; // ax
	int v3; // ebx
	int v4; // eax

	if (x_WORD_180660_VGA_type_resolution & 1)
		v2 = 400;
	else
		v2 = 480;
	/*v3 = (a2 - (signed __int16)(v2 - 2 * *(unsigned __int8 *)(**filearray_2aa18c[6] + 539)))
	   / *(unsigned __int8 *)(**filearray_2aa18c[6] + 539);
	v4 = (a1 - *(unsigned __int8 *)(**filearray_2aa18c[6] + 532)) / *(unsigned __int8 *)(**filearray_2aa18c[6] + 538);*/ // fix it
	v3 = 0; v4 = 0; //fix it
	if ((v3 & 0x8000u) == 0)
	{
		if ((signed __int16)v3 > 1)
			v3 = 1;
	}
	else
	{
		v3 = 0;
	}
	if ((v4 & 0x8000u) == 0)
	{
		if ((signed __int16)v4 > 12)
			v4 = 12;
	}
	else
	{
		v4 = 0;
	}
	return 13 * v3 + v4;
}
// EA3DC: using guessed type int **filearray_2aa18c[6];
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0006D4C0) --------------------------------------------------------
char sub_6D4C0(int a1)
{
	char result; // al

	result = *(x_BYTE *)(a1 + (unsigned __int8)x_BYTE_D94FF[*(char *)(a1 + 501)] + 468);
	*(x_BYTE *)(a1 + 502) = result;
	return result;
}

//----- (0006D4F0) --------------------------------------------------------
int sub_6D4F0(int a1, __int16 a2)
{
	__int16 v2; // cx
	int v3; // esi
	int v4; // eax
	int result; // eax
	int v6; // edx

	/*v2 = 3 * *(unsigned __int8 *)(**filearray_2aa18c[6] + 982);
	v3 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 538) / 2
	   + *(unsigned __int8 *)(**filearray_2aa18c[6] + 532)
	   + *(unsigned __int8 *)(**filearray_2aa18c[6] + 538) * (*(char *)(a1 + 501) % 13)
	   - v2 / 2;
	v4 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 538) / 2
	   + *(unsigned __int8 *)(**filearray_2aa18c[6] + 532)
	   + *(unsigned __int8 *)(**filearray_2aa18c[6] + 538) * (*(char *)(a1 + 501) % 13)
	   - v2 / 2;*/ //fix it
	v3 = 0;v2 = 0;  //fix it
	if ((signed __int16)v3 <= 640 - v2)
	{
		if ((v3 & 0x8000u) != 0)
			LOWORD(v4) = v3 ^ v4;
	}
	else
	{
		LOWORD(v4) = 640 - v2;
	}
	// fix it result = (a2 - (signed __int16)v4) / *(unsigned __int8 *)(**filearray_2aa18c[6] + 982);
	result = 0;  //fix it
	v6 = a1 + (unsigned __int8)x_BYTE_D94FF[*(char *)(a1 + 501)];
	LOWORD(v6) = *(char *)(v6 + 442);
	if ((signed __int16)result > (signed __int16)v6)
		return v6;
	if ((result & 0x8000u) != 0)
		result = 0;
	return result;
}
// EA3DC: using guessed type int **filearray_2aa18c[6];

//----- (0006D5E0) --------------------------------------------------------
char sub_6D5E0(int a1, char a2)
{
	int v2; // eax
	int v3; // edx
	char *v4; // esi
	unsigned __int8 v5; // dl
	unsigned __int8 v6; // ST04_1
	unsigned __int16 v7; // dx
	__int16 v8; // cx
	int v9; // edi

	LOBYTE(v2) = a2;
	v3 = 80 * *(char *)(a1 + 64);
	if (a2 > (unsigned __int8)*xadataspellsdat.var28_begin_buffer[v3] - 1)
		LOBYTE(v2) = *xadataspellsdat.var28_begin_buffer[v3] - 1;
	if (*(x_WORD *)(a1 + 46))
	{
		*(x_WORD *)(a1 + 44) = (char)v2 + 1;
	}
	else
	{
		v4 = (char*)*xadataspellsdat.var28_begin_buffer[80 * *(char *)(a1 + 64) + 2 + 26 * (char)v2];
		*(x_BYTE *)(a1 + 70) = v2;
		*(x_WORD *)(a1 + 42) = *(x_WORD *)v4;
		*(x_WORD *)(a1 + 48) = *((x_WORD *)v4 + 11);
		*(x_BYTE *)(a1 + 59) = (v4[25] & 1) == 0;
		v5 = *(x_BYTE *)(a1 + 64);
		*(x_BYTE *)(a1 + 60) = 0;
		v6 = v5;
		v7 = *(x_WORD *)(a1 + 40);
		*(x_BYTE *)(a1 + 61) = 0;
		v2 = sub_6D710(x_DWORD_EA3E4[v7], v6, v2);
		v8 = *(x_WORD *)(a1 + 48);
		v9 = v2;
		if (v8)
			v2 /= v8;
		*(x_DWORD *)(a1 + 144) = v2;
		*(x_DWORD *)(a1 + 140) = v9;
		*(x_DWORD *)(a1 + 136) = *((x_DWORD *)v4 + 2);
		if (x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 0x20)
		{
			*(x_DWORD *)(a1 + 136) = 0;
			*(x_DWORD *)(a1 + 144) = 1;
		}
	}
	return v2;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006D710) --------------------------------------------------------
int sub_6D710(unsigned int a1, unsigned __int8 a2, unsigned __int8 a3)
{
	signed int v3; // ecx
	int result; // eax
	int v5; // edx
	unsigned int v6; // ebx
	int v7; // edx
	int v8; // eax

	v3 = 0;
	result = *(x_DWORD *)&*xadataspellsdat.var28_begin_buffer[80 * a2 + 6 + 26 * a3];
	if (a2 == 2 && a1 > x_DWORD_EA3E4[0])
	{
		v5 = *(x_DWORD *)(a1 + 164);
		v6 = x_DWORD_EA3E4[*(unsigned __int16 *)(v5 + 58)];
		if (v6 <= x_DWORD_EA3E4[0])
			goto LABEL_23;
		switch (*(x_DWORD *)(v6 + 16))
		{
		case 0:
			result = 1000;
			break;
		case 1:
			result = 10000;
			break;
		case 2:
			result = 20000;
			break;
		case 3:
			result = 40000;
			break;
		case 4:
			result = (int)nullsub_1;
			break;
		case 5:
			result = 160000;
			break;
		case 6:
			result = 320000;
			break;
		default:
			result = 300000000;
			break;
		}
		if (*(x_DWORD *)(v6 + 16) >= 7)
			goto LABEL_25;
		if (a3 >= 1u)
		{
			if (a3 <= 1u)
			{
				v7 = 320 * result;
				v8 = 320 * result;
			}
			else
			{
				if (a3 != 2)
					goto LABEL_21;
				v8 = 384 * result;
				v7 = v8;
			}
			result = (v8 - (__CFSHL__(v7 >> 31, 8) + (v7 >> 31 << 8))) >> 8;
		}
	LABEL_21:
		if (*(x_DWORD *)(v6 + 16))
		{
		LABEL_25:
			if (v3)
				result += 3000;
			return result;
		}
		v5 = *(x_DWORD *)(a1 + 164);
	LABEL_23:
		if (*(x_BYTE *)(v5 + 446))
			v3 = 1;
		goto LABEL_25;
	}
	return result;
}
// 13880: using guessed type int /*__fastcall*/ nullsub_1(x_DWORD);
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006D830) --------------------------------------------------------
char sub_6D830(int a1, char a2)
{
	char *v2; // eax
	unsigned int v3; // esi
	int v4; // esi

	LOBYTE(v2) = *(x_BYTE *)(a1 + 64);
	if ((x_BYTE)v2 == 10)
	{
		v2 = (char *)&unk_DAB3A + 26 * a2;
		v3 = x_DWORD_EA3E4[*(unsigned __int16 *)(a1 + 40)];
		if (v3 > x_DWORD_EA3E4[0] && v2[24] == 1)
		{
			v4 = v3 + 76;
			*(x_DWORD *)(a1 + 154) = *(x_DWORD *)v4;
			*(x_WORD *)(a1 + 158) = *(x_WORD *)(v4 + 4);
		}
	}
	return (char)v2;
}
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006D880) --------------------------------------------------------
char sub_6D880(int a1)
{
	char result; // al

	if (*(x_WORD *)(a1 + 44))
	{
		result = sub_6D5E0(a1, *(x_BYTE *)(a1 + 44) - 1);
		*(x_WORD *)(a1 + 44) = 0;
	}
	return result;
}

//----- (0006D8B0) --------------------------------------------------------
void sub_6D8B0(unsigned __int16 a1, unsigned __int16 a2, __int16 a3)
{
	int v3; // eax
	int v4; // ebx
	int v5; // ecx
	int v6; // ebx

	if (!(x_D41A0_BYTEARRAY_4[38545] & 4))
	{
		if (a1)
		{
			v3 = x_DWORD_EA3E4[a1];
			if (*(x_BYTE *)(v3 + 63) == 3 && !*(x_BYTE *)(v3 + 64))
			{
				v4 = *(x_DWORD *)(v3 + 164);
				v5 = *(x_DWORD *)(v4 + 4 * a2 + 715);
				v6 = v4 + 611;
				*(x_DWORD *)(v6 + 4 * a2 + 104) = a3 + v5;
				if (a2 == 2)
					sub_6D5E0(x_DWORD_EA3E4[*(signed __int16 *)(v6 + 212)], *(x_BYTE *)(v6 + 470));
				if (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10)
				{
					if (a1 == *(x_WORD *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240))
						sub_6DAD0(v6, (unsigned __int8 *)&*xadataspellsdat.var28_begin_buffer[80 * a2], a2);
				}
				else
				{
					sub_6D9C0(v6, (unsigned __int8 *)&*xadataspellsdat.var28_begin_buffer[80 * a2], a2, 0, 1);
				}
			}
		}
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006D9C0) --------------------------------------------------------
int sub_6D9C0(int a1, unsigned __int8 *a2, __int16 a3, char a4, char a5)
{
	signed int v5; // esi
	int v6; // eax
	int v7; // edi
	int v8; // edx
	int result; // eax
	char v10; // dh

	v5 = 0;
	if ((*(x_BYTE *)(a1 + a3 + 390) || *(x_WORD *)(a1 + 2 * a3 + 208)) && (x_BYTE_D41B6 || a3 != 25))
		v5 = 1;
	if (x_D41A0_BYTEARRAY_4[0x17] >= 0 && *(x_DWORD *)(a1 + 112) > 7)
		*(x_DWORD *)(a1 + 112) = 7;
	v6 = *a2;
	v7 = *(x_DWORD *)(a1 + 4 * a3 + 104) + *(x_DWORD *)(a1 + 4 * a3);
	do
		--v6;
	while (v6 >= 0 && v7 < *(x_DWORD *)&a2[26 * v6 + 14]);
	if (v6 < 0)
		v6 = 0;
	v8 = a1 + a3;
	if (v6 != *(char *)(v8 + 442))
	{
		*(x_BYTE *)(v8 + 442) = v6;
		if (v5)
		{
			if (a5)
				sub_6DC40(a3);
		}
	}
	result = a1 + a3;
	v10 = *(x_BYTE *)(result + 442);
	if (*(x_BYTE *)(result + 468) > v10)
		*(x_BYTE *)(result + 468) = v10;
	if (v5 && a4)
	{
		if (v7 >= *(x_DWORD *)(a2 + 66))
		{
			result = *(x_DWORD *)(a2 + 66);
			*(x_DWORD *)(4 * a3 + a1) = result;
		}
		else
		{
			result = a3;
			*(x_DWORD *)(a1 + 4 * a3) = v7;
		}
	}
	return result;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// D41B6: using guessed type char x_BYTE_D41B6;

//----- (0006DAD0) --------------------------------------------------------
void sub_6DAD0(int a1, unsigned __int8 *a2, __int16 a3)
{
	int v3; // eax
	int v4; // edx

	if (*(x_WORD *)(a1 + 2 * a3 + 208) && *(char *)(a1 + a3 + 442) < *a2 - 1)
	{
		v3 = *(x_DWORD *)(a1 + 4 * a3 + 104) + *(x_DWORD *)(a1 + 4 * a3);
		if (v3 < 0)
			v3 = 0;
		if (v3 > *(x_DWORD *)(a2 + 70) + 2)
			v3 = *(x_DWORD *)(a2 + 70) + 2;
		v4 = a1 + a3;
		if (v3 >= *(x_DWORD *)&a2[26 * (*(char *)(v4 + 442) + 1) + 18])
		{
			++*(x_BYTE *)(v4 + 442);
			sub_6DC40(a3);
		}
	}
}

//----- (0006DB50) --------------------------------------------------------
int sub_6DB50(char a1, char a2)
{
	int result; // eax
	unsigned __int8 *v3; // esi
	signed int v4; // ebx
	int v5; // edi
	__int16 v6; // ST08_2

	result = (int)x_D41A0_BYTEARRAY_4;
	if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10))
	{
		v3 = (unsigned __int8 *)*xadataspellsdat.var28_begin_buffer;
		result = *(x_DWORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(x_D41A0_BYTEARRAY_0
			+ 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12
			+ 11240)]
			+ 164);
		v4 = 0;
		v5 = result + 611;
		while (v4 < 26)
		{
			v6 = v4++;
			result = sub_6D9C0(v5, v3, v6, a1, a2);
			v3 += 80;
		}
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006DBD0) --------------------------------------------------------
void sub_6DBD0()
{
	unsigned __int8 *v0; // esi
	signed int v1; // ebx
	int v2; // edi
	__int16 v3; // ST08_2

	if (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10)
	{
		v0 = (unsigned __int8 *)*xadataspellsdat.var28_begin_buffer;
		v1 = 0;
		v2 = *(x_DWORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240)]
			+ 164)
			+ 611;
		while (v1 < 26)
		{
			v3 = v1++;
			sub_6DAD0(v2, v0, v3);
			v0 += 80;
		}
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006DC40) --------------------------------------------------------
void sub_6DC40(unsigned __int8 a1)
{
	//char v1; // [esp+0h] [ebp-2h]

	sprintf_s(printbuffer, 512, (const char *)x_DWORD_E9C4C_langindexbuffer[159], x_DWORD_E9C4C_langindexbuffer[160 + a1]);
	sub_19760(printbuffer, 5u, 200);
	sub_6E450(*(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12), -1, 61);
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// E9EC8: using guessed type int x_DWORD_E9EC8;

//----- (0006DCA0) --------------------------------------------------------
int sub_6DCA0(int a1, int a2, unsigned __int16 a3, __int16 *a4, __int16 a5, char a6)
{
	__int16 v6; // di
	int v7; // ebx
	int v8; // eax
	unsigned __int8 v9; // dl
	int v10; // eax
	__int16 v11; // ax
	int v12; // eax
	int v13; // eax
	int v14; // eax
	int v15; // eax
	int v16; // eax
	int v17; // eax
	int v18; // eax
	int v19; // eax
	int v20; // eax
	int v21; // ecx
	int v22; // eax
	int v23; // eax
	__int16 v24; // dx

	v6 = 15;
	v7 = 0;
	if (a3 < 0x10u)
	{
		if (a3 < 9u)
		{
			if (a3)
			{
				if (a3 != 7)
					goto LABEL_60;
				v9 = *((x_BYTE *)a4 + 24);
				if (v9)
				{
					if (v9 > 2u)
						goto LABEL_60;
					v12 = sub_4A190(a2, 9, 12);
					v7 = v12;
					if (!v12)
						goto LABEL_60;
					*(x_BYTE *)(v12 + 67) = 9;
					*(x_BYTE *)(v12 + 68) = 9;
					v11 = *a4;
					v6 = 9;
				}
				else
				{
					v10 = sub_4A190(a2, 9, 9);
					v7 = v10;
					if (!v10)
						goto LABEL_60;
					*(x_BYTE *)(v10 + 67) = 10;
					*(x_BYTE *)(v10 + 68) = 23;
					v11 = *a4;
					v6 = 23;
				}
				*(x_WORD *)(v7 + 42) = v11;
				goto LABEL_60;
			}
			if (*((x_BYTE *)a4 + 24) >= 2u)
				v8 = sub_4A190(a2, 9, 28);
			else
				v8 = sub_4A190(a2, 9, 0);
			v7 = v8;
			if (v8)
			{
				*(x_BYTE *)(v8 + 67) = 10;
				if (*((x_BYTE *)a4 + 24) >= 2u)
					*(x_BYTE *)(v8 + 68) = 76;
				else
					*(x_BYTE *)(v8 + 68) = 0;
				v6 = 9;
			}
		}
		else
		{
			if (a3 <= 9u)
			{
				v13 = sub_4A190(a2, 9, 3);
				v7 = v13;
				if (!v13)
					goto LABEL_60;
				*(x_BYTE *)(v13 + 67) = 10;
				*(x_BYTE *)(v13 + 68) = 17;
				*(x_WORD *)(v13 + 42) = *a4;
				goto LABEL_59;
			}
			if (a3 < 0xDu)
				goto LABEL_60;
			if (a3 <= 0xDu)
			{
				v14 = sub_4A190(a2, 9, 8);
				v7 = v14;
				if (v14)
				{
					*(x_BYTE *)(v14 + 67) = 10;
					*(x_BYTE *)(v14 + 68) = 25;
				}
			}
			else if (a3 == 15)
			{
				v15 = sub_4A190(a2, 9, 23);
				v7 = v15;
				if (v15)
				{
					*(x_BYTE *)(v15 + 67) = 10;
					*(x_BYTE *)(v15 + 68) = 71;
					*(x_WORD *)(v15 + 42) = *a4;
				LABEL_59:
					*(x_BYTE *)(v7 + 70) = *((x_BYTE *)a4 + 24);
					goto LABEL_60;
				}
			}
		}
	}
	else if (a3 <= 0x10u)
	{
		v16 = sub_4A190(a2, 9, 5);
		v7 = v16;
		if (v16)
		{
			*(x_BYTE *)(v16 + 67) = 10;
			*(x_BYTE *)(v16 + 68) = 11;
			*(x_WORD *)(v16 + 42) = *a4;
			*(x_BYTE *)(v16 + 70) = *((x_BYTE *)a4 + 24);
		}
	}
	else if (a3 < 0x14u)
	{
		if (a3 <= 0x11u)
		{
			v17 = sub_4A190(a2, 9, 2);
			v7 = v17;
			if (v17)
			{
				*(x_BYTE *)(v17 + 67) = 10;
				*(x_BYTE *)(v17 + 68) = 15;
				*(x_WORD *)(v17 + 42) = *a4;
				*(x_BYTE *)(v17 + 70) = *((x_BYTE *)a4 + 24);
			}
		}
		else if (a3 == 18)
		{
			v18 = sub_4A190(a2, 9, 4);
			v7 = v18;
			if (v18)
			{
				*(x_BYTE *)(v18 + 67) = 10;
				*(x_BYTE *)(v18 + 68) = 9;
				*(x_WORD *)(v18 + 42) = *a4;
				*(x_BYTE *)(v18 + 70) = *((x_BYTE *)a4 + 24);
			}
		}
	}
	else if (a3 <= 0x14u)
	{
		v19 = sub_4A190(a2, 9, 22);
		v7 = v19;
		if (v19)
		{
			*(x_BYTE *)(v19 + 67) = 10;
			*(x_BYTE *)(v19 + 68) = 67;
			*(x_WORD *)(v19 + 42) = *a4;
			*(x_BYTE *)(v19 + 70) = *((x_BYTE *)a4 + 24);
		}
	}
	else
	{
		if (a3 <= 0x15u)
		{
			v20 = sub_4A190(a2, 9, 26);
			v21 = v20;
			v7 = v20;
			if (!v20)
				goto LABEL_60;
			*(x_BYTE *)(v20 + 67) = 10;
			*(x_BYTE *)(v20 + 68) = 22;
			if (*((x_BYTE *)a4 + 24))
				v22 = *(x_DWORD *)a4 / (signed int)*((unsigned __int8 *)a4 + 24);
			else
				LOWORD(v22) = *a4;
			goto LABEL_58;
		}
		if (a3 == 25)
		{
			v23 = sub_4A190(a2, 9, 30);
			v21 = v23;
			v7 = v23;
			if (v23)
			{
				*(x_BYTE *)(v23 + 67) = 10;
				*(x_BYTE *)(v23 + 68) = 89;
				if (*((x_BYTE *)a4 + 24))
					v22 = *(x_DWORD *)a4 / (signed int)*((unsigned __int8 *)a4 + 24);
				else
					LOWORD(v22) = *a4;
			LABEL_58:
				*(x_WORD *)(v21 + 42) = v22;
				goto LABEL_59;
			}
		}
	}
LABEL_60:
	if (v7)
	{
		v24 = a5 + *(x_WORD *)(v7 + 130);
		*(x_WORD *)(v7 + 130) = v24;
		if (v24 < 384)
			*(x_WORD *)(v7 + 130) = 384;
		if (*(x_WORD *)(v7 + 130) > 0x2000)
			*(x_WORD *)(v7 + 130) = 0x2000;
		if (a6)
			sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, v6);
	}
	return v7;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (0006E020) --------------------------------------------------------
signed int sub_6E020(unsigned __int16 a1)
{
	signed int result; // eax

	result = 0;
	if (a1 < 0x11u)
	{
		if (a1 < 0xBu)
		{
			if (a1 == 9)
				result = 18;
		}
		else if (a1 <= 0xBu)
		{
			result = 16;
		}
		else if (a1 == 15)
		{
			result = 17;
		}
	}
	else if (a1 <= 0x11u)
	{
		result = 9;
	}
	else if (a1 < 0x43u)
	{
		if (a1 == 22)
			result = 21;
	}
	else if (a1 <= 0x43u)
	{
		result = 20;
	}
	else if (a1 == 71)
	{
		result = 15;
	}
	return result;
}

//----- (0006E090) --------------------------------------------------------
int sub_6E090(int a1, int a2)
{
	signed int i; // eax
	int result; // eax

	for (i = 0; i < 26; i++)
	{
		if (*(x_WORD *)(a1 + 2 * i + 208))
			*(x_DWORD *)(a1 + 4 * i + 104) += a2;
	}
	result = (int)x_D41A0_BYTEARRAY_4;
	if (x_D41A0_BYTEARRAY_4[0x17] >= 0 && *(x_DWORD *)(a1 + 112) > 7)
		*(x_DWORD *)(a1 + 112) = 7;
	return result;
}
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (0006E0D0) --------------------------------------------------------
int sub_6E0D0()
{
	signed int v0; // edx
	int v1; // ecx
	int v2; // ebx

	v0 = 0;
	v1 = *(x_DWORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240)]
		+ 164)
		+ 611;
	while (v0 < 26)
	{
		*(x_BYTE *)(v1 + v0 + 390) = 1;
		v2 = x_DWORD_DA85A[20 * v0++];
		*(x_DWORD *)(v1 + 4 * v0 - 4) = v2 + 1;
	}
	return sub_6DB50(1, 0);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006E150) --------------------------------------------------------
void sub_6E150()
{
	__int16 v0; // si
	int v1; // ebx
	unsigned __int16 v2; // di
	int v3; // ebx
	int v4; // ebx

	if (x_BYTE_E3799 && x_BYTE_E3798_sound_active2 && (!(x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 1) || x_D41A0_BYTEARRAY_4[0x96BF]))
	{
		v0 = 0;
		do
		{
			v1 = 6 * v0;
			switch (x_WORD_F4FE0[v1])
			{
			case 1:
				sub_75110(x_WORD_F4FE6[6 * v0], v0, x_WORD_F4FE4[6 * v0], x_WORD_F4FE2[6 * v0], x_WORD_F4FEA[6 * v0]);
				x_WORD_F4FE0[6 * v0] = 0;
				x_WORD_F4FE8[6 * v0] = 2;
				break;
			case 2:
				sub_751B0(x_WORD_F4FE6[v1], v0, x_WORD_F4FE4[v1], x_WORD_F4FE2[v1], x_WORD_F4FEA[v1]);
				x_WORD_F4FE0[v1] = 0;
				x_WORD_F4FE8[v1] = 2;
				break;
			case 3:
				sub_75160(x_WORD_F4FE6[v1], v0, x_WORD_F4FE4[v1], x_WORD_F4FE2[v1], x_WORD_F4FEA[v1]);
				x_WORD_F4FE0[v1] = 0;
				x_WORD_F4FE8[v1] = 2;
				break;
			case 4:
				v2 = x_WORD_F4FE4[v1];
				if (v2 == 512)
					sub_8F420_sound_proc20(0, v0);
				else
					sub_8F100_sound_proc19(0, v0, (signed int)v2 >> 8, 64, 0x64u, -1, 2u);
				v3 = 3 * v0;
				x_WORD_F4FE8[2 * v3] = 2;
				x_WORD_F4FE0[2 * v3] = 0;
				break;
			default:
				break;
			}
			v4 = 3 * v0++;
			x_WORD_F4FE4[2 * v4] = 0;
		} while (v0 < 70);
	}
}
// D41A4: using guessed type int x_DWORD_D41A4;
// E3798: using guessed type char x_BYTE_E3798_sound_active2;
// E3799: using guessed type char x_BYTE_E3799;
// F4FE0: using guessed type __int16 x_WORD_F4FE0[];
// F4FE2: using guessed type __int16 x_WORD_F4FE2[];
// F4FE4: using guessed type __int16 x_WORD_F4FE4[];
// F4FE6: using guessed type __int16 x_WORD_F4FE6[];
// F4FE8: using guessed type __int16 x_WORD_F4FE8[];

//----- (0006E450) --------------------------------------------------------
void sub_6E450(__int16 a1, __int16 a2, __int16 a3)
{
	unsigned int v3; // edx
	x_WORD *v4; // esi
	unsigned int v5; // eax
	__int16 v6; // ax
	unsigned __int16 v7; // ax
	int v8; // edx
	int v9; // eax
	int v10; // esi
	int v11; // edx
	int v12; // edi
	unsigned int v13; // eax
	unsigned int v14; // edx
	int v15; // ebx
	int v16; // ebx
	int v17; // ebx
	int v18; // ebx
	int v19; // ebx
	int v20; // ebx
	__int16 v21; // [esp+0h] [ebp-24h]
	unsigned int v22; // [esp+4h] [ebp-20h]
	signed int v23; // [esp+8h] [ebp-1Ch]
	int v24; // [esp+Ch] [ebp-18h]
	unsigned int v25; // [esp+10h] [ebp-14h]
	int v26; // [esp+14h] [ebp-10h]
	unsigned __int16 v27; // [esp+18h] [ebp-Ch]
	__int16 v28; // [esp+1Ch] [ebp-8h]
	__int16 v29; // [esp+20h] [ebp-4h]

	v29 = 0;
	v21 = 0;
	v24 = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 8);
	if (!x_BYTE_E3799 || !x_BYTE_E3798_sound_active2)
		return;
	v3 = x_DWORD_EA3E4[a1];
	v22 = v3;
	if (v3 <= x_DWORD_EA3E4[0])
	{
		v10 = 0x7FFF;
		LOWORD(v12) = 0x7FFF;
	}
	else
	{
		if (*(x_BYTE *)(v3 + 12) < 0)
			return;
		v4 = (x_WORD *)(v3 + 76);
		if ((unsigned int)sub_584D0(
			(x_WORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12
				+ x_D41A0_BYTEARRAY_0
				+ 11240)]
				+ 76),
				(x_WORD *)(v3 + 76)) > 0x9000000)
			return;
		v26 = x_DWORD_EA3E4[*(unsigned __int16 *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240)];
		v29 = *(x_WORD *)(v22 + 26);
		v5 = sub_58490((x_WORD *)(v26 + 76), v4);
		v25 = v5;
		v23 = v5;
		v6 = sub_581E0((Bit16u*)(v26 + 76), (Bit16u*)v4);
		v28 = v6;
		v7 = sub_582B0(*(x_WORD *)(v26 + 28), v6);
		v27 = v7;
		v8 = 12288 * (512 - v7 / 2 + 512);
		v9 = (v8 - (__CFSHL__(v8 >> 31, 10) + (v8 >> 31 << 10))) >> 10;
		v10 = v9 ? (signed int)(0x7FFF * (v9 - v25)) / v9 : 0x7FFF;
		v11 = (signed __int16)sub_582F0(*(unsigned __int16 *)(v26 + 28), v28);
		if (v10 < 512)
			return;
		if (v10 > 0x7FFF)
			v10 = 0x7FFF;
		if (v23 > 320)
		{
			if (v27 > 0x200u)
				v27 = 1024 - v27;
			v12 = (((v27 << 15) * v11 - (__CFSHL__((v27 << 15) * v11 >> 31, 9) + ((v27 << 15) * v11 >> 31 << 9))) >> 9)
				+ 0x7FFF;
			if (v12 < 0)
				v12 = 0;
			if (v12 > 0xFFFF)
				LOWORD(v12) = -1;
		}
		else
		{
			LOWORD(v12) = 0x7FFF;
		}
		if ((unsigned __int16)a3 >= 0x2Au)
		{
			v13 = 9377 * v24 + 9439;
			if ((unsigned __int16)a3 <= 0x2Cu)
			{
				v14 = v13 % 0x1E - 15;
			}
			else
			{
				if (a3 != 46)
					goto LABEL_29;
				v14 = v13 % 0x14;
				if (*(x_BYTE *)(v22 + 69) == 14)
					LOWORD(v14) = v14 + 10;
				else
					LOWORD(v14) = v14 - 10;
			}
			v21 = v14;
		}
	}
LABEL_29:
	if ((unsigned __int16)a3 < 0x2Au)
	{
		if ((unsigned __int16)a3 < 0x20u)
		{
			if (a3 != 7)
				exit(-1);
			goto LABEL_45;
		}
		if ((unsigned __int16)a3 <= 0x20u || a3 == 38)
		{
		LABEL_45:
			v29 = 0;
			exit(-1);
		}
	}
	else
	{
		if ((unsigned __int16)a3 <= 0x2Cu)
			goto LABEL_45;
		if ((unsigned __int16)a3 >= 0x31u)
		{
			if ((unsigned __int16)a3 > 0x35u && ((unsigned __int16)a3 < 0x3Au || (unsigned __int16)a3 > 0x3Bu && a3 != 62))
				exit(-1);
			goto LABEL_45;
		}
		if ((unsigned __int16)a3 >= 0x2Eu && (unsigned __int16)a3 <= 0x2Fu)
			goto LABEL_45;
	}
LABEL_46:
	switch (a3)
	{
	case 1:
	case 2:
		if (a2 == *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12))
		{
			sub_8F100_sound_proc19(0, a3, 0, 64, 0x64u, -1, 2u);
			sub_8F710_sound_proc21(0, a3, 70, 2u, 0);
		}
		break;
	case 3:
	case 4:
	case 6:
	case 9:
	case 10:
	case 11:
	case 15:
	case 18:
	case 19:
	case 20:
	case 21:
	case 22:
	case 23:
	case 24:
	case 25:
	case 26:
	case 27:
	case 28:
	case 30:
	case 38:
	case 40:
	case 41:
	case 48:
	case 50:
	case 51:
	case 52:
	case 53:
	case 60:
	case 61:
	case 63:
	case 64:
		v17 = 6 * a3;
		if (sub_6EA90(v10, (unsigned __int16)x_WORD_F4FE4[v17]))
		{
			x_WORD_F4FE4[v17] = v10;
			x_WORD_F4FE2[v17] = v12;
			x_WORD_F4FEA[v17] = v21;
			x_WORD_F4FE0[v17] = 1;
			x_WORD_F4FE6[v17] = v29;
		}
		break;
	case 5:
		if (a2 == *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12))
		{
			sub_8F100_sound_proc19(0, a3, 0, 64, 0x64u, -1, 2u);
			sub_8F710_sound_proc21(0, a3, 120, 2u, 0);
		}
		break;
	case 7:
	case 8:
	case 12:
	case 13:
	case 16:
	case 17:
	case 32:
	case 33:
	case 34:
	case 37:
	case 39:
	case 42:
	case 43:
	case 44:
	case 46:
	case 58:
	case 59:
	case 62:
		v20 = 6 * a3;
		if (sub_6EA90(v10, (unsigned __int16)x_WORD_F4FE4[v20]))
		{
			x_WORD_F4FE4[v20] = v10;
			x_WORD_F4FE2[v20] = v12;
			x_WORD_F4FEA[v20] = v21;
			x_WORD_F4FE0[v20] = 3;
			x_WORD_F4FE6[v20] = v29;
		}
		break;
	case 14:
	case 29:
		v18 = 6 * a3;
		if (sub_6EA90(v10, (unsigned __int16)x_WORD_F4FE4[v18]))
		{
			if (a2 == *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12))
			{
				x_WORD_F4FE4[v18] = v10;
				x_WORD_F4FE2[v18] = v12;
				x_WORD_F4FEA[v18] = v21;
				x_WORD_F4FE6[v18] = 0;
				x_WORD_F4FE0[v18] = 1;
			}
			else if (a2 == -1)
			{
				x_WORD_F4FE4[v18] = v10;
				x_WORD_F4FE2[v18] = v12;
				x_WORD_F4FEA[v18] = v21;
				x_WORD_F4FE6[v18] = v29;
				x_WORD_F4FE0[v18] = 1;
			}
		}
		break;
	case 31:
		if (a2 == *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12))
		{
			sub_8F100_sound_proc19(0, a3, 0, 64, 0x64u, -1, 2u);
			sub_8F710_sound_proc21(0, a3, 85, 2u, 0);
		}
		break;
	case 47:
	case 49:
		v15 = 6 * a3;
		if (sub_6EA90(v10, (unsigned __int16)x_WORD_F4FE4[v15]))
		{
			x_WORD_F4FE4[v15] = v10;
			x_WORD_F4FE2[v15] = v12;
			x_WORD_F4FEA[v15] = v21;
			x_WORD_F4FE6[v15] = v29;
			x_WORD_F4FE0[v15] = 4;
		}
		break;
	case 54:
	case 55:
	case 56:
	case 57:
		v19 = 6 * a3;
		if (sub_6EA90(v10, (unsigned __int16)x_WORD_F4FE4[v19]))
		{
			if (a2 == *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12))
			{
				x_WORD_F4FE4[v19] = v10;
				x_WORD_F4FE2[v19] = v12;
				x_WORD_F4FEA[v19] = v21;
				x_WORD_F4FE6[v19] = 0;
				x_WORD_F4FE0[v19] = 3;
			}
			else if (a2 == -1)
			{
				x_WORD_F4FE4[v19] = v10;
				x_WORD_F4FE2[v19] = v12;
				x_WORD_F4FEA[v19] = v21;
				x_WORD_F4FE6[v19] = v29;
				x_WORD_F4FE0[v19] = 3;
			}
		}
		break;
	case 65:
	case 66:
	case 67:
	case 68:
	case 69:
		v16 = 3 * a3;
		x_WORD_F4FE4[2 * v16] = v10;
		x_WORD_F4FE2[2 * v16] = v12;
		x_WORD_F4FE0[2 * v16] = 3;
		x_WORD_F4FEA[2 * v16] = v21;
		x_WORD_F4FE6[2 * v16] = v29;
		break;
	default:
		return;
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// E3798: using guessed type char x_BYTE_E3798_sound_active2;
// E3799: using guessed type char x_BYTE_E3799;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// F4FE0: using guessed type __int16 x_WORD_F4FE0[];
// F4FE2: using guessed type __int16 x_WORD_F4FE2[];
// F4FE4: using guessed type __int16 x_WORD_F4FE4[];
// F4FE6: using guessed type __int16 x_WORD_F4FE6[];

//----- (0006EA90) --------------------------------------------------------
bool sub_6EA90(int a1, int a2)
{
	return a1 - a2 >= -8;
}

//----- (0006EAB0) --------------------------------------------------------
void sub_6EAB0(int a1, __int16 a2, __int16 a3)
{
	if (!x_BYTE_E3799 || !x_BYTE_E3798_sound_active2)
		return;
	if ((unsigned __int16)a3 < 0x1Fu)
	{
		if ((unsigned __int16)a3 < 1u || (unsigned __int16)a3 > 2u && a3 != 5)
			return;
	}
	else if ((unsigned __int16)a3 > 0x1Fu)
	{
		if ((unsigned __int16)a3 >= 0x2Fu && ((unsigned __int16)a3 <= 0x2Fu || a3 == 49))
			sub_8F710_sound_proc21(0, a3, 0, 4u, 1);
		return;
	}
	if (a2 == *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12))
		sub_8F710_sound_proc21(0, a3, 0, 2u, 1);
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// E3798: using guessed type char x_BYTE_E3798_sound_active2;
// E3799: using guessed type char x_BYTE_E3799;

//----- (0006EB90) --------------------------------------------------------
void sub_6EB90(filearray_struct *a1)
{
	for (Bit32u i = 0;(a1[i].begin_buffer) != &ZERO_BUFFER;i++)
	{
		if (x_WORD_180660_VGA_type_resolution & 1)
			sub_98709_create_index_dattab_power(*a1[i].begin_buffer, *a1[i].end_buffer, *a1[i].dat_buffer, a1[i].posistruct);//279709 //1a6f44,1a6f86,1a6578
		  //result = sub_98709_create_index_dattab_power(**i, *i[1], *i[2]);
		  //1a6f44 000000000000020000000c0d92000000
		  //1a6f86 00000000000000000000000000000000
		  //1a6578 0b0005a1a1a1a1a10005a1b413aaa100
		else
			sub_9874D_create_index_dattab(*a1[i].begin_buffer, *a1[i].end_buffer, *a1[i].dat_buffer, a1[i].posistruct);
	}
}
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0006EBF0) --------------------------------------------------------
void sub_6EBF0(filearray_struct *a1)//24FBF0
{
	for (Bit32u i = 0;(a1[i].begin_buffer) != &ZERO_BUFFER;i++)
	{
		if (x_WORD_180660_VGA_type_resolution & 1)
			sub_99A77_create_index_dattab_div(*a1[i].begin_buffer, *a1[i].end_buffer, *a1[i].dat_buffer, a1[i].posistruct);
		else
			sub_99AEB_create_index_dattab_minus(*a1[i].begin_buffer, *a1[i].end_buffer, *a1[i].dat_buffer, a1[i].posistruct);
	}
	/*
  //unsigned int* *i; // ebx
  unsigned int result; // eax

  //i = (unsigned int**)malloc(30);//fix it

  for ( ; a1[0]; a1 += 3 )
  {
	if ( x_WORD_180660_VGA_type_resolution & 1 )
	  result = sub_99A77_create_index_dattab_div((Bit8u*)*a1[0], *a1[1], *a1[2]);
	else
	  result = (unsigned int)sub_99AEB_create_index_dattab_minus((unsigned int *)*a1[0], *a1[1], *a1[2]);
  }
  return result;*/
}
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0006EDB0) --------------------------------------------------------
int sub_6EDB0_set_mouse_position_by_res()//24FDB0
{
	int result; // eax

	if (x_WORD_180660_VGA_type_resolution == 1)
		result = sub_6EDE0_set_mouse_position2(320, 200);
	else
		result = sub_6EDE0_set_mouse_position2(320, 240);
	return result;
}
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0006EDE0) --------------------------------------------------------
int sub_6EDE0_set_mouse_position2(signed __int16 a1, signed __int16 a2)
{
	signed __int16 v2; // si
	signed __int16 v3; // bx
	char* result; // eax
	__int16 v5; // ax
	char v6[28]; // [esp+0h] [ebp-38h]
	__int16 v7; // [esp+8h] [ebp-30h]
	__int16 v8; // [esp+Ch] [ebp-2Ch]
	char v9[28]; // [esp+1Ch] [ebp-1Ch]

	v2 = a1;
	v3 = a2;
	memset(v6, 0, 28);
	result = v9;//fixed 3551f0 - najit
	memset(v9, 0, 28);//35520c najit
	if (x_DWORD_E3768 > 0)
	{
		if (a1 != -1 || (result = (char*)a2, a2 != -1))
		{
			result = (char*)a1;
			if (a1 != -1)
			{
				v6[0] = 4;
				if (a1 <= 0)
				{
					if (!(x_WORD_180660_VGA_type_resolution & 1))
						v2 = 8 * a1;
				}
				else
				{
					if (a1 > 638)
						v2 = 638;
					x_WORD_E3760_mousex = v2;
					if (!(x_WORD_180660_VGA_type_resolution & 1))
						v2 *= 8;
				}
				v7 = v2;
				if (a2 <= 0)
				{
					if (x_WORD_180660_VGA_type_resolution & 1)
						v5 = x_WORD_E3762_mousey;
					else
						v5 = 8 * x_WORD_E3762_mousey;
					v8 = v5;
				}
				else
				{
					if (x_WORD_180660_VGA_type_resolution & 1)
					{
						if (a2 > 398)
							v3 = 398;
						x_WORD_E3762_mousey = v3;
						if (!(x_WORD_180660_VGA_type_resolution & 1))
							v3 *= 8;
					}
					else
					{
						if (a2 > 478)
							v3 = 478;
						x_WORD_E3762_mousey = v3;
						if (!(x_WORD_180660_VGA_type_resolution & 1))
							v3 *= 8;
					}
					v8 = v3;
				}
				//result = int386(0x33, (REGS*)v6, (REGS*)v9);//set mouse position
				//set mouse pos //fix //it
			}
		}
	}
	return (int)result;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// E3760: using guessed type __int16 x_WORD_E3760;
// E3762: using guessed type __int16 x_WORD_E3762;
// E3768: using guessed type int x_DWORD_E3768;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0006EF10) --------------------------------------------------------
__int16 sub_6EF10_set_mouse_minmax(__int16 a1, signed __int16 a2, __int16 a3, signed __int16 a4)
{
	signed __int16 v4; // si
	signed __int16 v5; // bx
	__int16 result; // ax
	char v7; // [esp+0h] [ebp-38h]
	__int16 v8; // [esp+1Ch] [ebp-1Ch]
	__int16 v9; // [esp+24h] [ebp-14h]
	__int16 v10; // [esp+28h] [ebp-10h]

	v4 = a2;
	v5 = a4;
	memset(&v8, 0, 28);
	memset(&v7, 0, 28);
	if (a2 > 638)
		v4 = 638;
	result = x_WORD_180660_VGA_type_resolution;
	if ((unsigned __int16)x_WORD_180660_VGA_type_resolution >= 1u)
	{
		if ((unsigned __int16)x_WORD_180660_VGA_type_resolution <= 1u)
		{
			v9 = a1;
			v10 = v4;
			v8 = 7;
			int386(0x33, (REGS*)&v8, (REGS*)&v7);//set mouse min,max
			v8 = 8;
			v9 = a3;
			if (a4 > 398)
				v5 = 398;
		}
		else
		{
			if (x_WORD_180660_VGA_type_resolution != 8)
				return result;
			v8 = 7;
			v9 = 8 * a1;
			v10 = 8 * v4;
			int386(0x33, (REGS*)&v8, (REGS*)&v7);//set mouse min,max
			v8 = 8;
			if (a4 > 478)
				v5 = 478;
			v9 = 8 * a3;
			v5 *= 8;
		}
		v10 = v5;
		result = int386(0x33, (REGS*)&v8, (REGS*)&v7);//set mouse min,max
	}
	return result;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0006F030) --------------------------------------------------------
unsigned int sub_6F030(int a1)
{
	unsigned int result; // eax

	result = sub_6F850(a1, 1);
	if (result)
	{
		sub_4A1E0(*(signed __int16 *)(a1 + 26), 1);
		sub_57F10(a1);
	}
	return result;
}

//----- (0006F070) --------------------------------------------------------
unsigned int sub_6F070(int a1)
{
	unsigned int result; // eax

	result = sub_6F850(a1, 0);
	if (result)
	{
		sub_4A1E0(*(signed __int16 *)(a1 + 26), 1);
		sub_57F10(a1);
	}
	return result;
}

//----- (0006F0B0) --------------------------------------------------------
unsigned int sub_6F0B0(int a1)
{
	unsigned int result; // eax

	if (*(x_DWORD *)(a1 + 16))
	{
		result = sub_6F8E0(a1, 1);
		if (!result)
			--*(x_DWORD *)(a1 + 16);
	}
	else
	{
		result = sub_6F850(a1, 1);
		if (result)
		{
			result = sub_4A1E0(*(signed __int16 *)(a1 + 26), 0);
			*(x_DWORD *)(a1 + 16) = 10;
		}
	}
	return result;
}

//----- (0006F100) --------------------------------------------------------
unsigned int sub_6F100(int a1)
{
	unsigned int result; // eax

	if (*(x_DWORD *)(a1 + 16))
	{
		result = sub_6F8E0(a1, 0);
		if (!result)
			--*(x_DWORD *)(a1 + 16);
	}
	else
	{
		result = sub_6F850(a1, 0);
		if (result)
		{
			result = sub_4A1E0(*(signed __int16 *)(a1 + 26), 0);
			*(x_DWORD *)(a1 + 16) = 10;
		}
	}
	return result;
}

//----- (0006F150) --------------------------------------------------------
unsigned int sub_6F150(int a1)
{
	unsigned int result; // eax

	result = x_D41A0_BYTEARRAY_4[0x9677];
	if (result > x_DWORD_EA3E4[0])
	{
		while (*(x_BYTE *)(result + 64)
			|| !x_BYTE_3659C[11 * *(signed __int16 *)(*(x_DWORD *)(result + 164) + 56) + (int)x_D41A0_BYTEARRAY_0])
		{
			result = *(x_DWORD *)result;
			if (result <= x_DWORD_EA3E4[0])
				return result;
		}
		sub_4A1E0(*(signed __int16 *)(a1 + 26), 1);
		sub_57F10(a1);
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006F1C0) --------------------------------------------------------
int sub_6F1C0(int a1)
{
	int result; // eax
	signed __int16 v2; // bx
	signed __int16 v3; // dx

	result = *(unsigned __int8 *)(x_D41A0_BYTEARRAY_0 + 224769);
	if (*(char *)(a1 + 70) < result)
	{
		if (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10)
			v2 = *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 14);
		else
			v2 = 1;
		v3 = 0;
		result = (int)&x_D41A0_BYTEARRAY_0[0x3659C];
		while (v3 < v2)
		{
			if (*(x_BYTE *)(*(char *)(a1 + 70) + result + 3) == 2)
			{
				*(x_BYTE *)(result + 2) = 1;
				sub_4A1E0(*(signed __int16 *)(a1 + 26), 1);
				sub_57F10(a1);
				return 1;
			}
			++v3;
			result += 11;
		}
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (0006F2B0) --------------------------------------------------------
x_BYTE *sub_6F2B0(int a1)
{
	x_BYTE *result; // eax
	unsigned __int16 v2; // dx

	result = (x_BYTE *)sub_6F850(a1, 1);
	if (result)
	{
		result[69] = 12;
		result[70] = 0;
		sub_57F10(a1);
		result = (x_BYTE *)x_D41A0_BYTEARRAY_0;
		v2 = *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 224766);
		if (v2)
		{
			result = (x_BYTE *)x_DWORD_EA3E4[v2];
			result[12] &= 0xFEu;
		}
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006F300) --------------------------------------------------------
unsigned int sub_6F300(int a1, unsigned int a2)
{
	unsigned int result; // eax
	int v3; // esi

	result = a2;
	if (a2 == -1)
	{
		for (result = 0; (signed int)result <= 16; ++result)
		{
			if ((result <= 0xB || result >= 0x10 && result <= 0x1C) && x_D41A0_BYTEARRAY_4[result + 38403])
				return result;
		}
		v3 = *(x_DWORD *)(a1 + 16);
		if (!v3)
		{
			*(x_DWORD *)(a1 + 16) = 16;
			return result;
		}
		if (v3 == 1)
		{
			sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 41);
			sub_4A1E0(*(signed __int16 *)(a1 + 26), 1);
			sub_57F10(a1);
			return 1;
		}
	}
	else
	{
		if (x_D41A0_BYTEARRAY_4[a2 + 38403])
			return result;
		v3 = *(x_DWORD *)(a1 + 16);
		if (!v3)
		{
			*(x_DWORD *)(a1 + 16) = 16;
			return result;
		}
		if (v3 == 1)
		{
			sub_6E450((a1 - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 41);
			sub_4A1E0(*(signed __int16 *)(a1 + 26), 1);
			sub_57F10(a1);
			return 1;
		}
	}
	result = v3 - 1;
	*(x_DWORD *)(a1 + 16) = v3 - 1;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (0006F420) --------------------------------------------------------
unsigned int sub_6F420(int a1)
{
	return sub_6F300(a1, 0);
}

//----- (0006F440) --------------------------------------------------------
unsigned int sub_6F440(int a1)
{
	return sub_6F300(a1, 1u);
}

//----- (0006F460) --------------------------------------------------------
unsigned int sub_6F460(int a1)
{
	return sub_6F300(a1, 2u);
}

//----- (0006F480) --------------------------------------------------------
unsigned int sub_6F480(int a1)
{
	return sub_6F300(a1, 3u);
}

//----- (0006F4A0) --------------------------------------------------------
unsigned int sub_6F4A0(int a1)
{
	return sub_6F300(a1, 4u);
}

//----- (0006F4C0) --------------------------------------------------------
unsigned int sub_6F4C0(int a1)
{
	return sub_6F300(a1, 5u);
}

//----- (0006F4E0) --------------------------------------------------------
unsigned int sub_6F4E0(int a1)
{
	return sub_6F300(a1, 6u);
}

//----- (0006F500) --------------------------------------------------------
unsigned int sub_6F500(int a1)
{
	return sub_6F300(a1, 7u);
}

//----- (0006F520) --------------------------------------------------------
unsigned int sub_6F520(int a1)
{
	return sub_6F300(a1, 8u);
}

//----- (0006F540) --------------------------------------------------------
unsigned int sub_6F540(int a1)
{
	return sub_6F300(a1, 9u);
}

//----- (0006F560) --------------------------------------------------------
unsigned int sub_6F560(int a1)
{
	return sub_6F300(a1, 0xAu);
}

//----- (0006F580) --------------------------------------------------------
unsigned int sub_6F580(int a1)
{
	return sub_6F300(a1, 0xBu);
}

//----- (0006F5A0) --------------------------------------------------------
unsigned int sub_6F5A0(int a1)
{
	return sub_6F300(a1, 0xCu);
}

//----- (0006F5C0) --------------------------------------------------------
unsigned int sub_6F5C0(int a1)
{
	return sub_6F300(a1, 0xDu);
}

//----- (0006F5E0) --------------------------------------------------------
unsigned int sub_6F5E0(int a1)
{
	return sub_6F300(a1, 0xEu);
}

//----- (0006F600) --------------------------------------------------------
unsigned int sub_6F600(int a1)
{
	return sub_6F300(a1, 0xFu);
}

//----- (0006F620) --------------------------------------------------------
unsigned int sub_6F620(int a1)
{
	return sub_6F300(a1, 0x10u);
}

//----- (0006F640) --------------------------------------------------------
unsigned int sub_6F640(int a1)
{
	return sub_6F300(a1, 0x11u);
}

//----- (0006F660) --------------------------------------------------------
unsigned int sub_6F660(int a1)
{
	return sub_6F300(a1, 0x12u);
}

//----- (0006F680) --------------------------------------------------------
unsigned int sub_6F680(int a1)
{
	return sub_6F300(a1, 0x13u);
}

//----- (0006F6A0) --------------------------------------------------------
unsigned int sub_6F6A0(int a1)
{
	return sub_6F300(a1, 0x14u);
}

//----- (0006F6C0) --------------------------------------------------------
unsigned int sub_6F6C0(int a1)
{
	return sub_6F300(a1, 0x15u);
}

//----- (0006F6E0) --------------------------------------------------------
unsigned int sub_6F6E0(int a1)
{
	return sub_6F300(a1, 0x16u);
}

//----- (0006F700) --------------------------------------------------------
unsigned int sub_6F700(int a1)
{
	return sub_6F300(a1, 0x17u);
}

//----- (0006F720) --------------------------------------------------------
unsigned int sub_6F720(int a1)
{
	return sub_6F300(a1, 0x18u);
}

//----- (0006F740) --------------------------------------------------------
unsigned int sub_6F740(int a1)
{
	return sub_6F300(a1, 0x19u);
}

//----- (0006F760) --------------------------------------------------------
unsigned int sub_6F760(int a1)
{
	return sub_6F300(a1, 0x1Au);
}

//----- (0006F780) --------------------------------------------------------
unsigned int sub_6F780(int a1)
{
	return sub_6F300(a1, 0x1Bu);
}

//----- (0006F7A0) --------------------------------------------------------
unsigned int sub_6F7A0(int a1)
{
	return sub_6F300(a1, 0x1Cu);
}

//----- (0006F7C0) --------------------------------------------------------
unsigned int sub_6F7C0(int a1)
{
	return sub_6F300(a1, 0xFFFFFFFF);
}

//----- (0006F7E0) --------------------------------------------------------
x_BYTE *sub_6F7E0(int a1)
{
	x_BYTE *result; // eax
	unsigned __int16 v2; // dx

	if (x_D41A0_BYTEARRAY_4[38545] & 8)
		sub_57F10(a1);
	result = (x_BYTE *)sub_6F850(a1, 1);
	if (result)
	{
		result[69] = 11;
		result[70] = 0;
		sub_57F10(a1);
		result = (x_BYTE *)x_D41A0_BYTEARRAY_0;
		v2 = *(x_WORD *)(0x36DFC + x_D41A0_BYTEARRAY_0);
		if (v2)
		{
			result = (x_BYTE *)x_DWORD_EA3E4[v2];
			result[12] &= 0xFEu;
		}
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006F850) --------------------------------------------------------
unsigned int sub_6F850(int a1, int a2)
{
	unsigned int i; // ebx

	if (*(x_BYTE *)(a1 + 62) & 7)
		return 0;
	for (i = x_D41A0_BYTEARRAY_4[0x9677]; ; i = *(x_DWORD *)i)
	{
		if (i <= x_DWORD_EA3E4[0])
		{
			*(x_WORD *)(a1 + 80) = sub_10C40((__int16 *)(a1 + 76));
			return 0;
		}
		if (!*(x_BYTE *)(i + 64) && sub_10750(a1, i) == a2)
			break;
	}
	if (*(x_BYTE *)(a1 + 64) > 3u)
		sub_6E450((signed int)(i - (x_D41A0_BYTEARRAY_0[28302])) / 168, -1, 41);
	return i;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006F8E0) --------------------------------------------------------
int sub_6F8E0(int a1, int a2)
{
	unsigned __int16 v2; // bx
	int v3; // esi
	int v4; // edi

	v2 = 0;
	v3 = (int)x_D41A0_BYTEARRAY_0 + 11230;
	while (v2 < *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 14))
	{
		v4 = x_DWORD_EA3E4[*(unsigned __int16 *)(v3 + 10)];
		if (sub_10750(a1, v4) == a2)
			return v4;
		v3 += 2124;
		++v2;
	}
	return 0;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (0006F940) --------------------------------------------------------
void sub_6F940_sub_draw_text(Bit8u* textbuffer, int posx, int posy, Bit8u color)//250940
{
	Bit8u* v4; // esi
	int v5; // ebx
	unsigned __int16 v6; // ax
	int v7; // eax
	int v8; // edi
	int v9; // eax
	int result; // eax

	v4 = textbuffer;
	v5 = posx;
	x_WORD_E36D4 = 64;
	while (*v4 && v5 < 640)
	{
		v6 = (unsigned __int8)*v4;
		if (v6 < 0xAu)
		{
			if (!*v4)
				goto LABEL_16;
			if (v6 == 9)
				goto LABEL_14;
		}
		else
		{
			if (v6 <= 0xAu)
			{
				LOWORD(v7) = sub_6FC30_get34_sizey();
				v5 = posx;
				posy += v7;
				goto LABEL_16;
			}
			if (v6 >= 0xDu)
			{
				if (v6 <= 0xDu)
					goto LABEL_16;
				if (v6 == 32)
				{
				LABEL_14:
					LOWORD(v9) = sub_6FC10_letter_width();
					goto LABEL_15;
				}
			}
		}
		if (!*v4)
			goto LABEL_14;
		v8 = 6 * ((unsigned __int8)*v4 + 1);
		//similar as:sub_7C120_draw_bitmap_640(tempposx, tempposy, xy_DWORD_17DEC0_spritestr[temptextbuffer[0]]);
		//posistruct tempposistruct;//fixed
		//tempposistruct.pointer = new Bit8u[1];//fixed
		/*
		19f990->59361a00 0407 70361a00 04 07 85361a00
		*/
		/*tempposistruct.pointer= &x_DWORD_EA3D4[v8];//fixed
		tempposistruct.sizex = 0;
		tempposistruct.sizey = 0;*/
		sub_72C40_draw_bitmap_640_setcolor(v5, posy, x_DWORD_EA3D4[v8 / 6], color);//fixed 2509d1
		//sub_72C40_draw_bitmap_640_setcolor(v5, a3, *(new posistruct)/*(Bit8u*)(v8 + x_DWORD_EA3D4)*/, a4);
		v9 = x_DWORD_EA3D4[v8 / 6].sizex;
	LABEL_15:
		v5 += v9;
	LABEL_16:
		v4++;
	}
	result = v5;
	x_WORD_E36D4 = 0;
}
// E36D4: using guessed type __int16 x_WORD_E36D4;
// EA3D4: using guessed type int x_DWORD_EA3D4;

//----- (0006FC10) --------------------------------------------------------
Bit8u sub_6FC10_letter_width()//250c10
{
	return x_DWORD_EA3D4[33].sizex;
}
// EA3D4: using guessed type int x_DWORD_EA3D4;

//----- (0006FC30) --------------------------------------------------------
Bit8u sub_6FC30_get34_sizey()//250c30
{
	return x_DWORD_EA3D4[34].sizey;
}
// EA3D4: using guessed type int x_DWORD_EA3D4;

//----- (0006FC50) --------------------------------------------------------
void sub_6FC50(__int16 a1)//250c50
{
	//int result; // eax
	posistruct *v2; // edx

	//result = a1;
	v2 = x_DWORD_E9B20[a1].posistruct;
	if (!v2->pointer)
		v2 = x_DWORD_E9B20[0].posistruct;
	x_DWORD_EA3D4 = v2;
	//return result * 4;
}
// E9B20: using guessed type int x_DWORD_E9B20[];
// EA3D4: using guessed type int x_DWORD_EA3D4;

//----- (0006FC80) --------------------------------------------------------
unsigned int sub_6FC80_pre_draw_text(char *a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int8 a5)//00250C80
{
	unsigned int v5; // kr04_4
	int v6; // esi
	int v7; // eax
	__int16 v9; // [esp+0h] [ebp-4h]

	v9 = a3 - a2;
	v5 = strlen(a1) + 1;
	if (v5 == 1)
	{
		v6 = a2 + v9 / 2;
	}
	else
	{
		v6 = a2 + v9 / 2 - (v5 - 1) * sub_6FC10_letter_width() / 2;
		sub_2BC10_draw_text((Bit8u*)a1, v6, a4, a5);
	}
	v7 = sub_6FC10_letter_width();
	return v6 + v7 * strlen(a1);
}

//----- (0006FD30) --------------------------------------------------------
//#error "6FD9C: positive sp value has been found (funcsize=32)"

//----- (0006FDA0) --------------------------------------------------------
int sub_6FDA0()//fix
{
	int v0; // eax
	int v1; // eax
	__int16 v2; // dx
	int result; // eax

	//fix it
	v2 = 0;
	//fix it

	v0 = (int)x_D41A0_BYTEARRAY_4;
	x_D41A0_BYTEARRAY_4[0x954] = 10022;
	*(x_DWORD *)(v0 + 2392) = 0;
	v1 = dos_getvect(8);
	x_WORD_F5334 = v2;
	x_DWORD_F5330 = v1;
	/* __outx_BYTE(0x43u, 0x36u);
	 __outx_BYTE(0x40u, x_D41A0_BYTEARRAY_4[0x954]);
	 __outx_BYTE(0x40u, x_D41A0_BYTEARRAY_4[0x954] >> 8);
	 result = dos_setvect(8, (x_DWORD)sub_6FD30, (unsigned __int16)__CS__);*/
	BYTE1(result) = 1;
	x_BYTE_DB734 = 1;
	return result;
}
// 6FD30: using guessed type int sub_6FD30();
// 99BA7: using guessed type x_DWORD dos_getvect(x_DWORD);
// 99BDB: using guessed type x_DWORD dos_setvect(x_DWORD, x_DWORD, x_DWORD);
// D41A4: using guessed type int x_DWORD_D41A4;
// DB734: using guessed type char x_BYTE_DB734;
// F5330: using guessed type int x_DWORD_F5330;
// F5334: using guessed type __int16 x_WORD_F5334;

//----- (0006FE20) --------------------------------------------------------
void sub_6FE20()//fix
{
	int v0; // et1
	//int v1; // eax

	if (x_BYTE_DB734 == 1)
	{
		v0 = x_D41A0_BYTEARRAY_4[0x94C];
		/*__outx_BYTE(0x43u, 0x36u);
		__outx_BYTE(0x40u, 0);
		__outx_BYTE(0x40u, 0);
		v1 = dos_setvect(8, x_DWORD_F5330, (unsigned __int16)x_WORD_F5334);*/
		_wcpp_1_unwind_leave__130(0/*v1*/);
	}
	x_BYTE_DB734 = 0;
}
// 6FE80: using guessed type int /*__fastcall*/ _wcpp_1_unwind_leave__130(x_DWORD);
// 99BDB: using guessed type x_DWORD dos_setvect(x_DWORD, x_DWORD, x_DWORD);
// D41A4: using guessed type int x_DWORD_D41A4;
// DB734: using guessed type char x_BYTE_DB734;
// F5330: using guessed type int x_DWORD_F5330;
// F5334: using guessed type __int16 x_WORD_F5334;

//----- (0006FE90) --------------------------------------------------------
int sub_6FE90(unsigned __int8 *a1, unsigned int a2)
{
	unsigned __int8 *v2; // eax
	int v3; // edx
	int v5; // ebx

	v2 = a1;
	v3 = 0;
	if ((unsigned int)a1 >= a2)
		return 0;
	do
	{
		v5 = *v2++;
		v3 += v5;
	} while ((unsigned int)v2 < a2);
	return v3;
}

//----- (0006FEC0) --------------------------------------------------------
int sub_6FEC0()
{
	int v0; // edx
	int result; // eax
	char v2; // dl
	int v3; // eax
	int v4; // ebx
	int v5; // eax
	int v6; // ebx
	int v7; // eax
	int v8; // ebx
	int v9; // eax
	int v10; // ebx
	int v11; // eax
	int v12; // ebx
	int v13; // eax
	int v14; // ebx
	int v15; // eax
	int v16; // ebx
	int v17; // eax
	int v18; // ebx
	int v19; // eax
	int v20; // ebx
	int v21; // eax
	int v22; // ebx
	int v23; // eax
	int v24; // ebx
	int v25; // eax
	int v26; // ebx
	int v27; // eax
	int v28; // ebx
	int v29; // eax
	int v30; // edx
	unsigned int v31; // eax
	__int16 v32; // bx
	__int16 v33; // bx
	__int16 v34; // bx
	__int16 v35; // bx
	__int16 v36; // bx
	__int16 v37; // bx
	__int16 v38; // bx
	int v39; // eax
	__int16 v40; // bx
	__int16 v41; // bx
	__int16 v42; // bx
	__int16 v43; // bx
	__int16 v44; // bx
	int *v45; // edi
	int v46; // ebx
	unsigned __int8 v47; // al
	int v48; // eax
	int v49; // eax
	__int16 v50; // bx
	__int16 v51; // bx
	__int16 v52; // bx
	__int16 v53; // bx
	__int16 v54; // bx
	__int16 v55; // bx
	__int16 v56; // bx
	__int16 v57; // bx
	__int16 v58; // bx
	__int16 v59; // bx
	__int16 v60; // bx
	__int16 v61; // bx
	__int16 v62; // bx
	__int16 v63; // bx
	//char v64; // [esp+0h] [ebp+7Eh]
	int i; // [esp+100h] [ebp+17Eh]

	v0 = 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
	result = v0 + (int)x_D41A0_BYTEARRAY_0;
	v2 = *(x_BYTE *)(v0 + x_D41A0_BYTEARRAY_0 + 11235);
	if (v2 & 8)
	{
		sub_6FC50(1);
		sub_2BC10_draw_text((Bit8u*)"Product name", 320, 0, x_BYTE_E9800);
		LOWORD(v3) = sub_6FC30_get34_sizey();
		v4 = v3;
		sub_2BC10_draw_text((Bit8u*)"Magic Carpet 2 (Netherworlds)", 320, v3, x_BYTE_E890F);
		LOWORD(v5) = sub_6FC30_get34_sizey();
		v6 = v5 + v4;
		sub_2BC10_draw_text((Bit8u*)"Version number", 320, v6, x_BYTE_E9800);
		LOWORD(v7) = sub_6FC30_get34_sizey();
		v8 = v7 + v6;
		sub_2BC10_draw_text((Bit8u*)"Beta", 320, v8, x_BYTE_E890F);
		LOWORD(v9) = sub_6FC30_get34_sizey();
		v10 = v9 + v8;
		sub_2BC10_draw_text((Bit8u*)"Version date", 320, v10, x_BYTE_E9800);
		LOWORD(v11) = sub_6FC30_get34_sizey();
		v12 = v11 + v10;
		sprintf_s(printbuffer, 512, "%s %s", "03:42:13", "Sep 06 1995");
		sub_2BC10_draw_text((Bit8u*)printbuffer, 320, v12, x_BYTE_E890F);
		LOWORD(v13) = sub_6FC30_get34_sizey();
		v14 = v13 + v12;
		sub_2BC10_draw_text((Bit8u*)"Programmer", 320, v14, x_BYTE_E9800);
		LOWORD(v15) = sub_6FC30_get34_sizey();
		v16 = v15 + v14;
		sub_2BC10_draw_text((Bit8u*)"Bullfrog, Alan Wright.", 320, v16, x_BYTE_E890F);
		LOWORD(v17) = sub_6FC30_get34_sizey();
		v18 = v17 + v16;
		sub_2BC10_draw_text((Bit8u*)"Supplied to", 320, v18, x_BYTE_E9800);
		LOWORD(v19) = sub_6FC30_get34_sizey();
		v20 = v19 + v18;
		sub_2BC10_draw_text((Bit8u*)"PUBLIC", 320, v20, x_BYTE_E890F);
		LOWORD(v21) = sub_6FC30_get34_sizey();
		v22 = v21 + v20;
		sub_2BC10_draw_text((Bit8u*)"Level Number", 320, v22, x_BYTE_E9800);
		LOWORD(v23) = sub_6FC30_get34_sizey();
		v24 = v23 + v22;
		sprintf_s(printbuffer, 512, "%d", x_D41A0_BYTEARRAY_4_struct.levelnumber_43);
		sub_2BC10_draw_text((Bit8u*)printbuffer, 320, v24, x_BYTE_E890F);
		LOWORD(v25) = sub_6FC30_get34_sizey();
		v26 = v25 + v24;
		if (x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10)
		{
			sub_2BC10_draw_text((Bit8u*)"Transfer rate:", 320, v26, x_BYTE_E9800);
			LOWORD(v27) = sub_6FC30_get34_sizey();
			v28 = v27 + v26;
			sprintf_s(printbuffer, 512, "%d", x_D41A0_BYTEARRAY_4[200]);
			sub_2BC10_draw_text((Bit8u*)printbuffer, 320, v28, x_BYTE_E890F);
			LOWORD(v29) = sub_6FC30_get34_sizey();
			v26 = v29 + v28;
		}
		v30 = 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
		x_DWORD_E9C14 = *(x_DWORD *)(v30 + x_D41A0_BYTEARRAY_0 + 11248);
		v31 = j___clock() / 0x64u;
		x_DWORD_E9C1C = v31;
		if (v31 != x_DWORD_E9C20)
		{
			x_DWORD_E9C20 = v31;
			x_DWORD_E9C24_fps = x_DWORD_E9C14 - x_DWORD_E9C18;
			x_DWORD_E9C18 = x_DWORD_E9C14;
		}
		sub_2BC10_draw_text((Bit8u*)"FPS", 320, v26, x_BYTE_E9800);
		v32 = sub_6FC30_get34_sizey() + v26;
		sprintf_s(printbuffer, 512, "%d", x_DWORD_E9C24_fps);
		sub_2BC10_draw_text((Bit8u*)printbuffer, 320, v32, x_BYTE_E890F);
		v33 = sub_6FC30_get34_sizey() + v32;
		sub_2BC10_draw_text((Bit8u*)"Sound Number", 320, v33, x_BYTE_E9800);
		v34 = sub_6FC30_get34_sizey() + v33;
		sprintf_s(printbuffer, 512, "%d", x_WORD_E37B6_sound_number);
		sub_2BC10_draw_text((Bit8u*)printbuffer, 320, v34, x_BYTE_E890F);
		v35 = sub_6FC30_get34_sizey() + v34;
		sub_2BC10_draw_text((Bit8u*)"Game turn", 320, v35, x_BYTE_E9800);
		v36 = sub_6FC30_get34_sizey() + v35;
		sprintf_s(printbuffer, 512, "%d %d", *(x_DWORD *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11248), x_DWORD_17DB54_game_turn2);
		sub_2BC10_draw_text((Bit8u*)printbuffer, 320, v36, x_BYTE_E890F);
		v37 = sub_6FC30_get34_sizey() + v36;
		sub_2BC10_draw_text((Bit8u*)"Thing", 320, v37, x_BYTE_E9800);
		v38 = sub_6FC30_get34_sizey() + v37;
		v39 = sub_4A810();
		sprintf_s(printbuffer, 512, "Thing %d, Active %d", 168, 1000 - v39);
		sub_2BC10_draw_text((Bit8u*)printbuffer, 320, v38, x_BYTE_E890F);
		v40 = sub_6FC30_get34_sizey() + v38;
		sprintf_s(printbuffer, 512, "Carpet %d", 224791);
		sub_2BC10_draw_text((Bit8u*)printbuffer, 320, v40, x_BYTE_E890F);
		v41 = sub_6FC30_get34_sizey() + v40;
		sprintf_s(printbuffer, 512, "Tape %d", 38547);
		sub_2BC10_draw_text((Bit8u*)printbuffer, 320, v41, x_BYTE_E890F);
		v42 = sub_6FC30_get34_sizey() + v41;
		sprintf_s(printbuffer, 512, "Heap %d", x_D41A0_BYTEARRAY_4_0xE6_heapsize);
		sub_2BC10_draw_text((Bit8u*)printbuffer, 320, v42, x_BYTE_E890F);
		v43 = sub_6FC30_get34_sizey() + v42;
		//sub_85350(); fix
		sub_2BC10_draw_text((Bit8u*)"Memory (Used/Free)", 320, v43, x_BYTE_E9800);
		v44 = sub_6FC30_get34_sizey() + v43;
		sprintf_s(printbuffer, 512, "%d/%d", x_DWORD_17FEA8_mem_used, x_DWORD_17FEA4_mem_free);
		sub_2BC10_draw_text((Bit8u*)printbuffer, 320, v44, x_BYTE_E890F);
		v45 = (int*)&x_DWORD_17ECA0;
		LOWORD(result) = sub_6FC30_get34_sizey();
		v46 = 0;
		for (i = 0; v45; v45 = (int *)v45[2])
		{
			sprintf_s(printbuffer, 512, "s%7.7d,u%01d", v45[1], *((unsigned __int8 *)v45 + 16));
			if (x_DWORD_17E0A4[3 * *((unsigned __int8 *)v45 + 17)])
				v47 = (unsigned __int8)*xadataclrd0dat.var28_begin_buffer;
			else
				v47 = x_BYTE_E9800;
			sub_2BC10_draw_text((Bit8u*)printbuffer, i, v46, v47);
			LOWORD(v48) = sub_6FC30_get34_sizey();
			v46 += v48;
			result = 400 - sub_6FC30_get34_sizey();
			if ((signed __int16)v46 > result)
			{
				LOWORD(v49) = sub_6FC10_letter_width();
				result = 12 * v49;
				i += result;
				v46 = 0;
			}
		}
	}
	else if (v2 & 0x40)
	{
		v50 = 6 * sub_6FC30_get34_sizey();
		sub_2BC10_draw_text((Bit8u*)"THING", 10, v50, x_BYTE_E9800);
		v51 = sub_6FC30_get34_sizey() + v50;
		sprintf_s(
			printbuffer, 512,
			"%ld / %ld",
			x_D41A0_BYTEARRAY_4[38396],
			(x_D41A0_BYTEARRAY_4[38396] - (x_D41A0_BYTEARRAY_0[28302])) / 168);
		sub_2BC10_draw_text((Bit8u*)printbuffer, 10, v51, x_BYTE_E89FF);
		v52 = sub_6FC30_get34_sizey() + v51;
		sub_2BC10_draw_text((Bit8u*)"CLASS / MODEL / STATE", 10, v52, x_BYTE_E9800);
		v53 = sub_6FC30_get34_sizey() + v52;
		sprintf_s(
			printbuffer, 512,
			"%ld / %ld / %ld",
			*(char *)(x_D41A0_BYTEARRAY_4[38396] + 63),
			*(char *)(x_D41A0_BYTEARRAY_4[38396] + 64),
			*(unsigned __int8 *)(x_D41A0_BYTEARRAY_4[38396] + 69));
		sub_2BC10_draw_text((Bit8u*)printbuffer, 10, v53, x_BYTE_E89FF);
		v54 = sub_6FC30_get34_sizey() + v53;
		sub_2BC10_draw_text((Bit8u*)"LIFE / MAX LIFE", 10, v54, x_BYTE_E9800);
		v55 = sub_6FC30_get34_sizey() + v54;
		sprintf_s(
			printbuffer, 512,
			"%ld / %ld",
			*(x_DWORD *)(x_D41A0_BYTEARRAY_4[38396] + 8),
			*(x_DWORD *)(x_D41A0_BYTEARRAY_4[38396] + 4));
		sub_2BC10_draw_text((Bit8u*)printbuffer, 10, v55, x_BYTE_E89FF);
		v56 = sub_6FC30_get34_sizey() + v55;
		sub_2BC10_draw_text((Bit8u*)"SPEED ACTUAL / MINIMUM / MAXIMUM", 10, v56, x_BYTE_E9800);
		v57 = sub_6FC30_get34_sizey() + v56;
		sprintf_s(
			printbuffer, 512,
			"%ld / %ld / %ld",
			*(signed __int16 *)(x_D41A0_BYTEARRAY_4[38396] + 130),
			*(signed __int16 *)(x_D41A0_BYTEARRAY_4[38396] + 132),
			*(signed __int16 *)(x_D41A0_BYTEARRAY_4[38396] + 134));
		sub_2BC10_draw_text((Bit8u*)printbuffer, 10, v57, x_BYTE_E89FF);
		v58 = sub_6FC30_get34_sizey() + v57;
		sub_2BC10_draw_text((Bit8u*)"ACTUAL X / Y / Z", 10, v58, x_BYTE_E9800);
		v59 = sub_6FC30_get34_sizey() + v58;
		sprintf_s(
			printbuffer, 512,
			"%ld / %ld / %ld",
			*(signed __int16 *)(x_D41A0_BYTEARRAY_4[38396] + 76),
			*(signed __int16 *)(x_D41A0_BYTEARRAY_4[38396] + 78),
			*(signed __int16 *)(x_D41A0_BYTEARRAY_4[38396] + 80));
		sub_2BC10_draw_text((Bit8u*)printbuffer, 10, v59, x_BYTE_E89FF);
		v60 = sub_6FC30_get34_sizey() + v59;
		sub_2BC10_draw_text((Bit8u*)"ID / WHO OWNS ME", 10, v60, x_BYTE_E9800);
		v61 = sub_6FC30_get34_sizey() + v60;
		sprintf_s(
			printbuffer, 512,
			"%ld / %ld",
			*(signed __int16 *)(x_D41A0_BYTEARRAY_4[38396] + 26),
			*(unsigned __int16 *)(x_D41A0_BYTEARRAY_4[38396] + 40));
		sub_2BC10_draw_text((Bit8u*)printbuffer, 10, v61, x_BYTE_E89FF);
		v62 = sub_6FC30_get34_sizey() + v61;
		sub_2BC10_draw_text((Bit8u*)"MANA ACTUAL / MAXIMUM", 10, v62, x_BYTE_E9800);
		v63 = sub_6FC30_get34_sizey() + v62;
		sprintf_s(
			printbuffer, 512,
			"%ld / %ld",
			*(x_DWORD *)(x_D41A0_BYTEARRAY_4[38396] + 144),
			*(x_DWORD *)(x_D41A0_BYTEARRAY_4[38396] + 140));
		sub_2BC10_draw_text((Bit8u*)printbuffer, 10, v63, x_BYTE_E89FF);
		LOWORD(result) = sub_6FC30_get34_sizey();
	}
	if (x_D41A0_BYTEARRAY_4[53] == 16273849)
		x_D41A0_BYTEARRAY_4[52] |= 2u;
	return result;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// 98786: using guessed type int /*__fastcall*/ j___clock(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// E37B6: using guessed type __int16 x_WORD_E37B6_sound_number;
// E890F: using guessed type char x_BYTE_E890F;
// E89FF: using guessed type char x_BYTE_E89FF;
// E9800: using guessed type char x_BYTE_E9800;
// E9C14: using guessed type int x_DWORD_E9C14;
// E9C18: using guessed type int x_DWORD_E9C18;
// E9C1C: using guessed type int x_DWORD_E9C1C;
// E9C20: using guessed type int x_DWORD_E9C20;
// E9C24: using guessed type int x_DWORD_E9C24_fps;
// 17DB54: using guessed type int x_DWORD_17DB54_game_turn2;
// 17E0A4: using guessed type int x_DWORD_17E0A4[];
// 17ECA0: using guessed type int x_DWORD_17ECA0;
// 17FEA4: using guessed type int x_DWORD_17FEA4_mem_free;
// 17FEA8: using guessed type int x_DWORD_17FEA8_mem_used;

//----- (00070890) --------------------------------------------------------
void sub_70890_print_header()
{
	myprintf("Copyright (c) 1995 Bullfrog Productions Ltd.\n");
	myprintf("All rights reserved.\n");
	myprintf("%s \n", "Magic Carpet 2 (Netherworlds)");
}

//----- (00070910) --------------------------------------------------------
char* sub_70910_print_string(char* a1)
{
	int result; // eax

	result = (int)x_D41A0_BYTEARRAY_4;
	if (x_D41A0_BYTEARRAY_4[0x17] & 1)//fix it
		result = myprintf("%s\n", a1);
	return (char*)result;
}
// D189C: using guessed type void *off_D189C;
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (00070940) --------------------------------------------------------
unsigned int sub_70940()
{
	x_WORD *v0; // ebx
	int v1; // edi
	unsigned int result; // eax
	int v3; // esi
	int i; // eax
	char v5; // dl
	int v6; // eax
	int v7; // [esp+0h] [ebp-10h]
	int v8; // [esp+4h] [ebp-Ch]
	int v9; // [esp+8h] [ebp-8h]
	char v10; // [esp+Ch] [ebp-4h]

	v0 = (x_WORD *)x_DWORD_EA3E4[*(unsigned __int16 *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240)];
	v1 = ((signed __int16)v0[38] + 128) >> 8;
	v9 = ((signed __int16)v0[39] + 128) >> 8;
	result = sub_10080(0, 128);
	v3 = result;
	if (result)
	{
		v10 = 0;
		while (sub_10130(v3, &v8, &v7) == 1 && !v10)
		{
			for (i = x_WORD_15B4E0[((unsigned __int8)(v9 + v7) << 8) + (unsigned __int8)(v1 + v8)];
				;
				i = *(unsigned __int16 *)(v6 + 22))
			{
				v6 = x_DWORD_EA3E4[i];
				if (v6 == x_DWORD_EA3E4[0] || v10)
					break;
				v5 = 1;
				if ((x_WORD *)v6 == v0 || *(x_BYTE *)(v6 + 63) == 15 && *(x_WORD *)(v6 + 26) == v0[13] || *(x_BYTE *)(v6 + 12) & 1)
					v5 = 0;
				if (v5)
				{
					v10 = 1;
					x_D41A0_BYTEARRAY_4[38396] = v6;
				}
			}
		}
		sub_10100(v3);
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA3E4: using guessed type int x_DWORD_EA3E4[];

//----- (00070A60) --------------------------------------------------------
void sub_70A60_open_tmaps()
{
	//char printbuffer[512];//char v1; // [esp+0h] [ebp-40h]

	sprintf_s(printbuffer, 512, "%c:%s/%s/%s.dat", x_D41A0_BYTEARRAY_4_struct.harddisk_number, "/netherw", "cdata", "tmaps0-0");
	x_DWORD_DB740_tmaps00file = sub_98817_open(printbuffer, 512);
	if (x_DWORD_DB740_tmaps00file == NULL)
	{
		sprintf_s(printbuffer, 512, "data/%s.dat", "tmaps0-0");
		x_DWORD_DB740_tmaps00file = sub_98817_open(printbuffer, 512);
	}
	sprintf_s(printbuffer, 512, "%c:%s/%s/%s.dat", x_D41A0_BYTEARRAY_4_struct.harddisk_number, "/netherw", "cdata", "tmaps1-0");
	x_DWORD_DB744_tmaps10file = sub_98817_open(printbuffer, 512);
	if (x_DWORD_DB744_tmaps10file == NULL)
	{
		sprintf_s(printbuffer, 512, "data/%s.dat", "tmaps1-0");
		x_DWORD_DB744_tmaps10file = sub_98817_open(printbuffer, 512);
	}
	sprintf_s(printbuffer, 512, "%c:%s/%s/%s.dat", x_D41A0_BYTEARRAY_4_struct.harddisk_number, "/netherw", "cdata", "tmaps2-0");
	x_DWORD_DB748_tmaps20file = sub_98817_open(printbuffer, 512);
	if (x_DWORD_DB748_tmaps20file == NULL)
	{
		sprintf_s(printbuffer, 512, "data/%s.dat", "tmaps2-0");
		x_DWORD_DB748_tmaps20file = sub_98817_open(printbuffer, 512);
	}
	x_DWORD_DB73C_tmapsfile = x_DWORD_DB740_tmaps00file;
	//return 1;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// D41A4: using guessed type int x_DWORD_D41A4;
// DB73C: using guessed type int x_DWORD_DB73C_tmapsfile;
// DB740: using guessed type int x_DWORD_DB740_tmaps00file;
// DB744: using guessed type int x_DWORD_DB744_tmaps10file;
// DB748: using guessed type int x_DWORD_DB748_tmaps20file;

//----- (00070BF0) --------------------------------------------------------
void sub_70BF0_close_tmaps()
{
	//int result; // eax

	if (x_DWORD_DB740_tmaps00file != NULL)
	{
		sub_98882_close(x_DWORD_DB740_tmaps00file);
		x_DWORD_DB740_tmaps00file = NULL;
	}
	if (x_DWORD_DB744_tmaps10file != NULL)
	{
		sub_98882_close(x_DWORD_DB744_tmaps10file);
		x_DWORD_DB744_tmaps10file = NULL;
	}
	if (x_DWORD_DB748_tmaps20file != NULL)
	{
		sub_98882_close(x_DWORD_DB748_tmaps20file);
		x_DWORD_DB748_tmaps20file = NULL;
	}
	x_DWORD_DB73C_tmapsfile = NULL;
	//return result;
}
// DB73C: using guessed type int x_DWORD_DB73C_tmapsfile;
// DB740: using guessed type int x_DWORD_DB740_tmaps00file;
// DB744: using guessed type int x_DWORD_DB744_tmaps10file;
// DB748: using guessed type int x_DWORD_DB748_tmaps20file;

//----- (00070C60) --------------------------------------------------------
int sub_70C60_decompress_tmap(unsigned __int16 a1, Bit8u* a2)
{
	int v2; // edi
	int v3; // ebx
	int result; // eax

	if (x_DWORD_DB73C_tmapsfile == NULL)
		return (int)x_DWORD_DB73C_tmapsfile;
	v2 = 10 * a1;
	sub_9891E_seek(x_DWORD_DB73C_tmapsfile, *(x_DWORD *)(v2 + TMAPS00TAB_BEGIN_BUFFER + 4), 0);//lseek
	v3 = TMAPS00TAB_BEGIN_BUFFER[10 * (a1 + 1) + 4] - TMAPS00TAB_BEGIN_BUFFER[v2 + 4];
	if (sub_988A7_read(x_DWORD_DB73C_tmapsfile, (Bit8u*)a2, v3) != v3)
		return -1;
	result = (int)sub_9894C_decompress(a2, a2);
	if (result >= 0)
	{
		if (!result)
			result = v3;
	}
	else
	{
		myprintf("ERROR decompressing tmap%03d\n");
		result = -2;
	}
	return result;
}
// DB73C: using guessed type int x_DWORD_DB73C_tmapsfile;
// F6ED0: using guessed type int TMAPS00TAB_BEGIN_BUFFER;

//----- (00070D20) --------------------------------------------------------
char sub_70D20(unsigned __int16 a1)
{
	unsigned __int16 v1; // ax
	__int16 v2; // di
	unsigned __int16 i; // bx
	x_BYTE **v4; // ecx
	x_DWORD *v5; // eax

	v1 = *(x_WORD *)(10 * a1 + TMAPS00TAB_BEGIN_BUFFER + 8);
	if (x_BYTE_F5340[v1])
		return 0;
	v2 = *(x_WORD *)(10 * a1 + TMAPS00TAB_BEGIN_BUFFER + 8);
	if (!x_DWORD_F66F0[v1])
		return 0;
	for (i = *(x_WORD *)(10 * a1 + TMAPS00TAB_BEGIN_BUFFER + 8); i < 0x1F8u && v2 == *(x_WORD *)(TMAPS00TAB_BEGIN_BUFFER + 10 * i + 8); i++)
	{
		v4 = (x_BYTE **)x_DWORD_F66F0[i];
		if (v4)
		{
			if (**v4 & 1)
			{
				v5 = (x_DWORD *)sub_724F0(x_DWORD_E9C08, i);
				sub_72410(v5);
			}
			sub_71F20(x_DWORD_E9C28, x_DWORD_F5F10[i]);
			x_DWORD_F66F0[i] = 0;
			x_DWORD_F5F10[i] = 0;
			x_DWORD_F5730[i] = 0;
		}
	}
	return 1;
}
// E9C08: using guessed type int x_DWORD_E9C08;
// E9C28: using guessed type int x_DWORD_E9C28;
// F6ED0: using guessed type int TMAPS00TAB_BEGIN_BUFFER;

//----- (00070E10) --------------------------------------------------------
char sub_70E10(unsigned __int16 a1)
{
	int v1; // edx
	__int16 v2; // di
	unsigned __int16 i; // bx
	x_BYTE **v4; // ecx
	x_DWORD *v5; // eax

	v1 = 10 * a1;
	v2 = *(x_WORD *)(v1 + TMAPS00TAB_BEGIN_BUFFER + 8);
	if (!x_DWORD_F66F0[*(unsigned __int16 *)(v1 + TMAPS00TAB_BEGIN_BUFFER + 8)])
		return 0;
	for (i = *(x_WORD *)(v1 + TMAPS00TAB_BEGIN_BUFFER + 8); i < 0x1F8u && v2 == *(x_WORD *)(TMAPS00TAB_BEGIN_BUFFER + 10 * i + 8); i++)
	{
		v4 = (x_BYTE **)x_DWORD_F66F0[i];
		if (v4)
		{
			if (**v4 & 1)
			{
				v5 = (x_DWORD *)sub_724F0(x_DWORD_E9C08, i);
				sub_72410(v5);
			}
			sub_71F20(x_DWORD_E9C28, x_DWORD_F5F10[i]);
			x_DWORD_F66F0[i] = 0;
			x_DWORD_F5F10[i] = 0;
			x_DWORD_F5730[i] = 0;
		}
	}
	return 1;
}
// E9C08: using guessed type int x_DWORD_E9C08;
// E9C28: using guessed type int x_DWORD_E9C28;
// F6ED0: using guessed type int TMAPS00TAB_BEGIN_BUFFER;

//----- (00070EF0) --------------------------------------------------------
int sub_70EF0(unsigned __int16 a1)
{
	unsigned __int16 v1; // dx
	int i; // ebx
	int v3; // ecx

	v1 = *(x_WORD *)(10 * a1 + TMAPS00TAB_BEGIN_BUFFER + 8);
	for (i = 0; v1 < 0x1F8u; i += *(x_DWORD *)(v3 + TMAPS00TAB_BEGIN_BUFFER) + 10)
	{
		v3 = 10 * v1;
		if (*(x_WORD *)(10 * a1 + TMAPS00TAB_BEGIN_BUFFER + 8) != *(x_WORD *)(v3 + TMAPS00TAB_BEGIN_BUFFER + 8))
			break;
		++v1;
	}
	return i;
}
// F6ED0: using guessed type int TMAPS00TAB_BEGIN_BUFFER;

//----- (00070F50) --------------------------------------------------------
int sub_70F50(unsigned __int16 a1)
{
	int result; // eax
	unsigned __int16 v2; // bx
	unsigned __int16 i; // si
	int v4; // edi
	int v5; // [esp+0h] [ebp-Ch]
	int v6; // [esp+8h] [ebp-4h]

	v5 = x_D41A0_BYTEARRAY_4[26];
	result = (int)TMAPS00TAB_BEGIN_BUFFER;
	v2 = *(x_WORD *)(10 * a1 + TMAPS00TAB_BEGIN_BUFFER + 8);
	for (i = *(x_WORD *)(10 * a1 + TMAPS00TAB_BEGIN_BUFFER + 8); i < 0x1F8u; i++)
	{
		result = 10 * i + (int)TMAPS00TAB_BEGIN_BUFFER;
		if (v2 != *(x_WORD *)(result + 8))
			break;
		v6 = i;
		if (!x_DWORD_F66F0[i])
		{
			result = sub_71E70(x_DWORD_E9C28, (unsigned __int16)(4 * ((unsigned int)(*(x_DWORD *)result + 13) >> 2)), i);
			v4 = result;
			if (result)
			{
				result = sub_70C60_decompress_tmap(i, *(Bit8u**)result);
				if (result != -1)
				{
					x_DWORD_F5F10[v6] = v4;
					x_DWORD_F66F0[v6] = v4;
					x_DWORD_F5730[v6] = v5;
					result = x_DWORD_F66F0[v6];
					if (**(x_BYTE **)result & 1)
						result = sub_721C0((unsigned __int16 *)x_DWORD_E9C08, (int *)result, i);
					if (v2 < 0x1E0u)
					{
						if (v2 != 311)
							continue;
					LABEL_14:
						result = *(x_DWORD *)x_DWORD_F66F0[i];
						*(x_BYTE *)result |= 0x20u;
						continue;
					}
					if (v2 <= 0x1E0u || v2 >= 0x1E8u && (v2 <= 0x1E8u || v2 == 496))
						goto LABEL_14;
				}
			}
		}
	}
	return result;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// E9C08: using guessed type int x_DWORD_E9C08;
// E9C28: using guessed type int x_DWORD_E9C28;
// F6ED0: using guessed type int TMAPS00TAB_BEGIN_BUFFER;

//----- (00071090) --------------------------------------------------------
unsigned int sub_71090(unsigned int a1)
{
	int v1; // eax
	unsigned __int16 v2; // dx
	int v3; // eax
	int v4; // ebx
	int v5; // ebx
	int v6; // ecx
	unsigned int v7; // eax
	int v8; // edx
	int v9; // esi
	int v10; // esi
	int v11; // edi
	int v12; // edi
	int v13; // esi
	int v14; // esi
	int v15; // edi
	unsigned __int16 v16; // di
	unsigned int v17; // ebx
	char v18; // al
	int v19; // esi
	int v21; // [esp+0h] [ebp-2Ch]
	int v22; // [esp+4h] [ebp-28h]
	int v23; // [esp+8h] [ebp-24h]
	int v24; // [esp+Ch] [ebp-20h]
	int v25; // [esp+10h] [ebp-1Ch]
	unsigned int v26; // [esp+14h] [ebp-18h]
	unsigned int v27; // [esp+18h] [ebp-14h]
	unsigned int v28; // [esp+1Ch] [ebp-10h]
	unsigned int v29; // [esp+20h] [ebp-Ch]
	unsigned int v30; // [esp+24h] [ebp-8h]
	char v31; // [esp+28h] [ebp-4h]

	//fix it
	v22 = 0;
	v23 = 0;
	v24 = 0;
	v27 = 0;
	v28 = 0;
	v29 = 0;
	v30 = 0;
	//fix it

	v31 = 1;
	v1 = 0;
	do
	{
		v2 = v1++;
		*(&v26 + v2) = -1;
		*(&v21 + v2) = -1;
	} while ((unsigned __int16)v1 < 5u);
	v3 = 0;
	do
	{
		v4 = *(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * (unsigned __int16)v3 + 8);
		if (x_DWORD_F66F0[v4] && !x_BYTE_F5340[v4])
			v31 = 0;
		while ((unsigned __int16)v3 < 0x1F8u
			&& *(unsigned __int16 *)(10 * ((unsigned __int16)v3 + 1) + TMAPS00TAB_BEGIN_BUFFER + 8) == v4)
			++v3;
		++v3;
	} while ((unsigned __int16)v3 < 0x1F8u);
	v5 = 0;
	do
	{
		v6 = *(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * (unsigned __int16)v5 + 8);
		if ((!x_BYTE_F5340[v6] || v31) && x_DWORD_F66F0[v6])
		{
			v7 = x_DWORD_F5730[v6];
			v8 = *(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * (unsigned __int16)v5 + 8);
			if (v7 < v26)
			{
				v9 = v7 ^ v26;
				v7 ^= v26 ^ v7;
				v26 = v7 ^ v9;
				v8 = v6 ^ v6 ^ v21;
				v21 ^= v8 ^ v6;
			}
			if (v7 < v27)
			{
				v10 = v7 ^ v27;
				v11 = v8 ^ v22;
				v7 ^= v27 ^ v7;
				v8 ^= v22 ^ v8;
				v27 = v7 ^ v10;
				v22 = v8 ^ v11;
			}
			if (v7 < v28)
			{
				v12 = v7 ^ v28;
				v13 = v8 ^ v23;
				v7 ^= v28 ^ v7;
				v8 ^= v23 ^ v8;
				v28 = v7 ^ v12;
				v23 = v8 ^ v13;
			}
			if (v7 < v29)
			{
				v14 = v7 ^ v29;
				v15 = v8 ^ v24;
				v7 ^= v29 ^ v7;
				v8 ^= v24 ^ v8;
				v29 = v7 ^ v14;
				v24 = v8 ^ v15;
			}
			if (v7 < v30)
			{
				v30 ^= v7 ^ v7 ^ v7 ^ v30;
				v25 ^= v8 ^ v8 ^ v8 ^ v25;
			}
		}
		while ((unsigned __int16)v5 < 0x1F8u
			&& *(unsigned __int16 *)(10 * ((unsigned __int16)v5 + 1) + TMAPS00TAB_BEGIN_BUFFER + 8) == v6)
			++v5;
		++v5;
	} while ((unsigned __int16)v5 < 0x1F8u);
	v16 = 0;
	v17 = 0;
	while (v16 < 5u)
	{
		if (v17 >= a1)
			break;
		v19 = 4 * v16;
		if (*(int *)((char *)&v21 + v19) <= -1)
			break;
		if (v31)
			v18 = sub_70E10(*(x_WORD *)((char *)&v21 + v19));
		else
			v18 = sub_70D20(*(x_WORD *)((char *)&v21 + v19));
		if (v18)
			v17 += sub_70EF0(*(x_WORD *)((char *)&v21 + v19));
		++v16;
	}
	return v17;
}
// F6ED0: using guessed type int TMAPS00TAB_BEGIN_BUFFER;

//----- (000712F0) --------------------------------------------------------
__int16 sub_712F0()
{
	x_DWORD_E9C28 = sub_71B40(x_D41A0_BYTEARRAY_4_0xE6_heapsize, 0x1F8u, (int)x_D41A0_BYTEARRAY_4_0xE2_heapbuffer);
	if (x_DWORD_E9C28)
		x_DWORD_E9C08 = sub_72120(0x1F8u);
	sub_70A60_open_tmaps();
	sub_71A70(*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308));
	memset(x_DWORD_F66F0, 0, 2016);
	memset(x_DWORD_F5F10, 0, 2016);
	memset(x_DWORD_F5730, 0, 2016);
	sub_71890();
	return sub_718F0();
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// E9C08: using guessed type int x_DWORD_E9C08;
// E9C28: using guessed type int x_DWORD_E9C28;

//----- (000713A0) --------------------------------------------------------
void sub_713A0()
{
	sub_720C0(&x_DWORD_E9C28);
	sub_72550(&x_DWORD_E9C08);
	sub_716A0();
	memset(x_DWORD_F66F0, 0, 2016);
	memset(x_DWORD_F5F10, 0, 2016);
	memset(x_DWORD_F5730, 0, 2016);
	x_BYTE_DB738 = 0;
	sub_70BF0_close_tmaps();
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// DB738: using guessed type char x_BYTE_DB738;
// E9C08: using guessed type int x_DWORD_E9C08;
// E9C28: using guessed type int x_DWORD_E9C28;

//----- (00071410) --------------------------------------------------------
void sub_71410_process_tmaps()
{
	Bit16u* v0; // esi
	int v1; // ebx
	unsigned __int16 v2; // di

	sub_70A60_open_tmaps();
	v0 = x_WORD_D951C;
	v1 = (int)x_DWORD_180628b_screen_buffer;
	while (v0[3] || v0[4])
	{
		v2 = *v0;
		memset((void*)v1, 0, TMAPS00TAB_BEGIN_BUFFER[10 * (*v0 + 1) + 4] - TMAPS00TAB_BEGIN_BUFFER[10 * *v0 + 4]);
		if (sub_70C60_decompress_tmap(v2, (Bit8u*)v1) == -1)
		{
			*(x_WORD *)(v1 + 2) = 255;
			*(x_WORD *)(v1 + 4) = 255;
			*(x_BYTE *)(v1 + 1) = 1;
		}
		if (!*(x_WORD *)(v1 + 4) || !*(x_WORD *)(v1 + 2))
		{
			*(x_WORD *)(v1 + 2) = 255;
			*(x_WORD *)(v1 + 4) = 255;
			*(x_BYTE *)(v1 + 1) = 1;
		}
		if (v0[3])
		{
			if (!v0[4])
				v0[4] = *(unsigned __int16 *)(v1 + 4) * v0[3] / *(unsigned __int16 *)(v1 + 2);
		}
		else
		{
			v0[3] = *(unsigned __int16 *)(v1 + 2) * v0[4] / *(unsigned __int16 *)(v1 + 4);
		}
		v0 += 7;
		*((x_BYTE *)v0 - 2) = *(x_BYTE *)(v1 + 1);
	}
	sub_70BF0_close_tmaps();
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D951C: using guessed type __int16 x_WORD_D951C[];
// F6ED0: using guessed type int TMAPS00TAB_BEGIN_BUFFER;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;

//----- (00071520) --------------------------------------------------------
bool sub_71520(unsigned __int16 a1)
{
	int v1; // esi
	int v2; // ebx
	signed int i; // ebx
	unsigned __int16 v4; // ax

	v1 = 0;
	v2 = sub_70EF0(a1);
	for (i = v2 - sub_71E60(x_DWORD_E9C28) + 20; i > 0; i -= sub_71090(i))
	{
		v4 = v1++;
		if (v4 >= 4u)
			break;
	}
	if (i <= 0)
	{
		sub_70F50(a1);
		x_D41A0_BYTEARRAY_4[177] = 5;
	}
	return x_DWORD_F66F0[a1] != 0;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// E9C28: using guessed type int x_DWORD_E9C28;

//----- (000715B0) --------------------------------------------------------
int sub_715B0()
{
	unsigned __int16 v0; // bx
	int result; // eax
	int *v2; // ecx
	char v3; // cl
	char v4; // cl
	int v5; // eax
	__int16 v6; // si
	unsigned __int16 i; // bx
	int *v8; // edi
	char v9; // cl
	int v10; // eax

	v0 = 0;
	do
	{
		result = 4 * v0;
		v2 = *(int **)((char *)x_DWORD_F66F0 + result);
		if (v2)
		{
			result = *v2;
			v3 = *(x_BYTE *)*v2;
			if (v3 & 8)
			{
				if (v3 & 0x20)
				{
					result = 5 * v0;
					v6 = *(x_WORD *)(TMAPS00TAB_BEGIN_BUFFER + 10 * v0 + 8);
					for (i = *(x_WORD *)(TMAPS00TAB_BEGIN_BUFFER + 10 * v0 + 8); i < 0x1F8u; i++)
					{
						result = 5 * i;
						if (v6 != *(x_WORD *)(TMAPS00TAB_BEGIN_BUFFER + 10 * i + 8))
							break;
						result = 4 * i;
						v8 = (int *)x_DWORD_F66F0[i];
						if (v8)
						{
							result = *v8;
							v9 = *(x_BYTE *)*v8 & 0xF7;
							*(x_BYTE *)*v8 = v9;
							if (v9 & 1)
							{
								v10 = sub_724F0(x_DWORD_E9C08, i);
								result = sub_72350(v10);
							}
						}
					}
					v0 = i - 1;
				}
				else
				{
					v4 = v3 & 0xF7;
					*(x_BYTE *)result = v4;
					if (v4 & 1)
					{
						v5 = sub_724F0(x_DWORD_E9C08, v0);
						result = sub_72350(v5);
					}
				}
			}
		}
		++v0;
	} while (v0 < 0x1F8u);
	return result;
}
// E9C08: using guessed type int x_DWORD_E9C08;
// F6ED0: using guessed type int TMAPS00TAB_BEGIN_BUFFER;

//----- (000716A0) --------------------------------------------------------
int sub_716A0()
{
	return (int)memset(x_BYTE_F5538, 0, 504);
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);

//----- (000716C0) --------------------------------------------------------
signed __int16 *sub_716C0(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3)
{
	signed __int16 *result; // eax
	unsigned __int16 *v4; // ebx
	unsigned __int16 v5; // cx

	result = (signed __int16 *)&unk_D7BD6;
	v4 = 0;
	while (*result >= 0)
	{
		if (*result == a1 && result[1] == a2)
			v4 = (unsigned __int16 *)(result + 2);
		result += 17;
	}
	if (v4)
	{
		while (1)
		{
			v5 = *v4;
			if ((*v4 & 0x8000u) != 0)
				break;
			++v4;
			result = (signed __int16 *)sub_71730(v5);
		}
	}
	else if ((a3 & 0x8000u) == 0)
	{
		result = (signed __int16 *)sub_71730(a3);
	}
	return result;
}

//----- (00071730) --------------------------------------------------------
int sub_71730(unsigned __int16 a1)
{
	__int16 *v1; // eax
	char v2; // bl
	int result; // eax

	v1 = (short*)&x_WORD_D951C[7 * a1];
	v2 = *((x_BYTE *)v1 + 11);
	result = *(unsigned __int16 *)(TMAPS00TAB_BEGIN_BUFFER + 10 * (unsigned __int16)*v1 + 8);
	x_BYTE_F5538[result] = v2;
	return result;
}
// D951C: using guessed type __int16 x_WORD_D951C[];
// F6ED0: using guessed type int TMAPS00TAB_BEGIN_BUFFER;

//----- (00071780) --------------------------------------------------------
char sub_71780()
{
	unsigned __int16 v0; // bx
	unsigned int v1; // eax
	char i; // bl
	unsigned __int16 j; // si
	unsigned int v4; // ST0C_4
	char v6; // [esp+4h] [ebp-4h]

	v6 = 0;
	if (!x_DWORD_E9C28)
		sub_712F0();
	sub_71A70(*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308));
	v0 = 0;
	memset(x_DWORD_F5730, 0, 2016);
	do
	{
		LOBYTE(v1) = v0;
		if (!x_BYTE_F5538[v0])
			LOBYTE(v1) = sub_70D20(v0);
		++v0;
	} while (v0 < 0x1F8u);
	for (i = -1; i && !v6; i--)
	{
		for (j = 0; j < 0x1F8u && !v6; j++)
		{
			if (i == x_BYTE_F5538[j] && !x_DWORD_F66F0[j])
			{
				v4 = sub_70EF0(j);
				if (sub_71E60(x_DWORD_E9C28) <= v4)
				{
					v1 = sub_71E60(x_DWORD_E9C28);
					if (v1 < 0x400)
						v6 = 1;
				}
				else
				{
					LOBYTE(v1) = sub_70F50(j);
				}
			}
		}
	}
	return v1;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// E9C28: using guessed type int x_DWORD_E9C28;

//----- (00071890) --------------------------------------------------------
char sub_71890()
{
	__int16 *v0; // ebx
	char result; // al

	v0 = (short*)x_WORD_D951C;
	result = (char)memset(x_BYTE_F5340, 0, 504);
	if (x_BYTE_DB74C)
	{
		while (v0[3] || v0[4])
		{
			if (*((x_BYTE *)v0 + 11) == -1)
			{
				result = *((x_BYTE *)v0 + 11);
				x_BYTE_F5340[(unsigned __int16)*v0] = result;
			}
			v0 += 7;
		}
	}
	return result;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D951C: using guessed type __int16 x_WORD_D951C[];
// DB74C: using guessed type char x_BYTE_DB74C;

//----- (000718F0) --------------------------------------------------------
__int16 sub_718F0()
{
	unsigned __int16 v0; // bx
	__int16 result; // ax

	v0 = 0;
	do
	{
		result = v0;
		if (x_BYTE_F5340[v0])
			result = sub_70F50(v0);
		++v0;
	} while (v0 < 0x1F8u);
	return result;
}

//----- (00071930) --------------------------------------------------------
int sub_71930()
{
	int result; // eax
	int v1; // ebx

	memset((void*)(x_D41A0_BYTEARRAY_0 + 57), 0, 508);
	result = 0;
	do
	{
		if (x_DWORD_F66F0[(unsigned __int16)result])
		{
			v1 = (unsigned __int16)result + (int)x_D41A0_BYTEARRAY_0;
			*(x_BYTE *)(v1 + 57) = 1;
			if (x_BYTE_F5340[(unsigned __int16)result])
				++*(x_BYTE *)(v1 + 57);
		}
		++result;
	} while ((unsigned __int16)result < 0x1F8u);
	return result;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00071990) --------------------------------------------------------
char sub_71990()
{
	unsigned __int16 v0; // bx
	unsigned int v1; // eax
	char i; // bl
	unsigned __int16 j; // si
	unsigned int v4; // ST04_4
	char v6; // [esp+4h] [ebp-4h]

	v6 = 0;
	if (!x_DWORD_E9C28)
		sub_712F0();
	v0 = 0;
	do
	{
		LOBYTE(v1) = v0;
		if (!*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + v0 + 57))
			LOBYTE(v1) = sub_70D20(v0);
		++v0;
	} while (v0 < 0x1F8u);
	for (i = 2; i && !v6; i--)
	{
		for (j = 0; j < 0x1F8u && !v6; j++)
		{
			LOBYTE(v1) = (int)x_D41A0_BYTEARRAY_0;
			if (i == *(x_BYTE *)(j + x_D41A0_BYTEARRAY_0 + 57) && !x_DWORD_F66F0[j])
			{
				v4 = sub_70EF0(j);
				if (sub_71E60(x_DWORD_E9C28) <= v4)
				{
					v1 = sub_71E60(x_DWORD_E9C28);
					if (v1 < 0x400)
						v6 = 1;
				}
				else
				{
					LOBYTE(v1) = sub_70F50(j);
				}
			}
		}
	}
	return v1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// E9C28: using guessed type int x_DWORD_E9C28;

//----- (00071A70) --------------------------------------------------------
unsigned __int8 sub_71A70(unsigned __int8 a1)
{
	FILE* v1; // edx
	unsigned __int8 result; // al

	v1 = x_DWORD_DB73C_tmapsfile;
	result = a1;
	if (a1 < 1u)
	{
		if (!a1)
			v1 = x_DWORD_DB740_tmaps00file;
	}
	else if (a1 <= 1u)
	{
		v1 = x_DWORD_DB744_tmaps10file;
	}
	else if (a1 == 2)
	{
		v1 = x_DWORD_DB748_tmaps20file;
	}
	x_DWORD_DB73C_tmapsfile = v1;
	return result;
}
// DB73C: using guessed type int x_DWORD_DB73C_tmapsfile;
// DB740: using guessed type int x_DWORD_DB740_tmaps00file;
// DB744: using guessed type int x_DWORD_DB744_tmaps10file;
// DB748: using guessed type int x_DWORD_DB748_tmaps20file;

//----- (00071AB0) --------------------------------------------------------
__int16 sub_71AB0(__int16 a1, char a2)
{
	x_BYTE *v2; // eax
	__int16 v3; // si
	__int16 i; // bx
	x_DWORD *v5; // ecx
	int v6; // eax

	LOWORD(v2) = 5 * a1;
	v3 = *(x_WORD *)(TMAPS00TAB_BEGIN_BUFFER + 10 * a1 + 8);
	for (i = *(x_WORD *)(TMAPS00TAB_BEGIN_BUFFER + 10 * a1 + 8); i < 504; i++)
	{
		LOWORD(v2) = v3;
		if (*(unsigned __int16 *)(10 * i + TMAPS00TAB_BEGIN_BUFFER + 8) != v3)
			break;
		v5 = (x_DWORD *)x_DWORD_F66F0[i];
		if (v5)
		{
			v2 = (x_BYTE *)*v5;
			if (*(x_BYTE *)*v5 & 1)
			{
				v6 = sub_724F0(x_DWORD_E9C08, i);
				LOWORD(v2) = sub_723B0(v6, a2);
			}
		}
	}
	return (signed __int16)v2;
}
// E9C08: using guessed type int x_DWORD_E9C08;
// F6ED0: using guessed type int TMAPS00TAB_BEGIN_BUFFER;

//----- (00071B40) --------------------------------------------------------
int sub_71B40(int a1, unsigned __int16 a2, int a3)
{
	unsigned __int16 v3; // di
	int v4; // eax
	int v5; // eax
	int v6; // edx
	int v7; // esi
	int v8; // eax
	int v10; // ebx
	int v11; // eax
	int v12; // eax
	int v13; // eax
	int v14; // [esp+0h] [ebp-Ch]

	v3 = a2;
	if (a3)
	{
		v4 = 14 * a2;
		v14 = v4;
		v5 = 4 * a2 + v4 + 26;
		v6 = a1 - v5;
		if (a1 == v5)
			return 0;
		*(x_WORD *)(a3 + 20) = 0;
		*(x_WORD *)(a3 + 24) = 2;
		*(x_DWORD *)a3 = v6;
		*(x_DWORD *)(a3 + 4) = v6;
		v7 = a3;
		*(x_WORD *)(a3 + 22) = a2;
		*(x_DWORD *)(a3 + 8) = a3 + 26;
		v8 = v14 + a3 + 26;
		*(x_DWORD *)(a3 + 12) = v8;
		*(x_DWORD *)(a3 + 16) = 4 * a2 + v8;
		while (--v3 != -1)
			*(x_DWORD *)(*(x_DWORD *)(a3 + 8) + 14 * v3 + 4) = 0;
	}
	else
	{
		v10 = (int)sub_83CD0_malloc2(26);
		v7 = v10;
		if (!v10
			|| (v11 = (int)sub_83CD0_malloc2(a1), (*(x_DWORD *)(v10 + 16) = v11) == 0)
			|| (v12 = (int)sub_83CD0_malloc2(14 * a2), (*(x_DWORD *)(v10 + 8) = v12) == 0)
			|| (v13 = (int)sub_83CD0_malloc2(4 * a2), (*(x_DWORD *)(v10 + 12) = v13) == 0))
		{
			if (v10)
			{
				if (*(x_DWORD *)(v10 + 16))
				{
					if (*(x_DWORD *)(v10 + 8))
						sub_83E80_sound_proc_99((Bit8u*)*(x_DWORD *)(v10 + 8));
					sub_83E80_sound_proc_99((Bit8u*)*(x_DWORD *)(v10 + 16));
				}
				sub_83E80_sound_proc_99((Bit8u*)v10);
			}
			exit(1);
		}
		*(x_WORD *)(v10 + 20) = 0;
		*(x_WORD *)(v10 + 24) = 1;
		*(x_WORD *)(v10 + 22) = a2;
		*(x_DWORD *)v10 = a1;
		*(x_DWORD *)(v10 + 4) = a1;
		while (--v3 != -1)
			*(x_DWORD *)(*(x_DWORD *)(v10 + 8) + 14 * v3 + 4) = 0;
	}
	return v7;
}

//----- (00071CD0) --------------------------------------------------------
signed int sub_71CD0(int a1)
{
	int i; // edx

	for (i = 0; (signed __int16)i < (signed int)*(unsigned __int16 *)(a1 + 22); i++)
	{
		if (!*(x_DWORD *)(14 * (signed __int16)i + *(x_DWORD *)(a1 + 8) + 4))
			return i;
	}
	return -1;
}

//----- (00071E60) --------------------------------------------------------
int sub_71E60(int a1)
{
	return *(x_DWORD *)(a1 + 4);
}

//----- (00071E70) --------------------------------------------------------
int sub_71E70(int a1, unsigned int a2, __int16 a3)
{
	signed __int16 v3; // si
	signed __int16 v4; // ax
	signed __int16 v5; // dx
	int v6; // ecx
	int v7; // eax
	int result; // eax

	v3 = -1;
	if (a2 < *(x_DWORD *)(a1 + 4))
	{
		v4 = sub_71CD0(a1);
		v5 = v4;
		v6 = v4;
		v3 = v4;
		if (v4 > -1)
		{
			v7 = 14 * v4;
			*(x_WORD *)(*(x_DWORD *)(a1 + 8) + v7 + 10) = v5;
			*(x_DWORD *)(*(x_DWORD *)(a1 + 8) + v7 + 4) = a2;
			*(x_DWORD *)(*(x_DWORD *)(a1 + 8) + v7) = *(x_DWORD *)a1 + *(x_DWORD *)(a1 + 16) - *(x_DWORD *)(a1 + 4);
			*(x_WORD *)(*(x_DWORD *)(a1 + 8) + v7 + 12) = a3;
			*(x_DWORD *)(a1 + 4) -= a2;
			*(x_WORD *)(*(x_DWORD *)(a1 + 8) + v7 + 8) = *(x_WORD *)(a1 + 20);
			*(x_DWORD *)(*(x_DWORD *)(a1 + 12) + 4 * (unsigned __int16)(*(x_WORD *)(a1 + 20))++) = *(x_DWORD *)(a1 + 8) + 14 * v6;
		}
	}
	if (v3 <= -1)
		result = 0;
	else
		result = 14 * v3 + *(x_DWORD *)(a1 + 8);
	return result;
}

//----- (00071F20) --------------------------------------------------------
__int16 sub_71F20(int a1, int a2)
{
	int v2; // eax
	int v3; // ecx
	unsigned __int16 v4; // bx
	int v5; // esi
	int v6; // ecx
	unsigned __int16 v7; // cx
	int v8; // edi
	int v9; // eax
	const void *v10; // esi
	char *i; // [esp+4h] [ebp-4h]

	LOWORD(v2) = *(x_WORD *)(a2 + 10);
	if ((unsigned __int16)v2 < *(x_WORD *)(a1 + 22))
	{
		v2 = 14 * (unsigned __int16)v2;
		v3 = v2 + *(x_DWORD *)(a1 + 8);
		if (*(x_DWORD *)(v3 + 4))
		{
			v4 = *(x_WORD *)(v3 + 8);
			v5 = *(x_DWORD *)(v3 + 4) + *(x_DWORD *)(a1 + 4);
			v6 = *(x_DWORD *)(a1 + 8);
			*(x_DWORD *)(a1 + 4) = v5;
			*(x_DWORD *)(v6 + v2 + 4) = 0;
			v2 = *(x_DWORD *)(*(x_DWORD *)(a1 + 8) + v2);
			for (i = (char *)v2; ; i += v2)
			{
				++v4;
				v7 = *(x_WORD *)(a1 + 20);
				if (v4 >= v7)
					break;
				v8 = 4 * v4;
				*(x_DWORD *)(v8 + *(x_DWORD *)(a1 + 12) - 4) = *(x_DWORD *)(v8 + *(x_DWORD *)(a1 + 12));
				v9 = *(x_DWORD *)(v8 + *(x_DWORD *)(a1 + 12));
				*(x_WORD *)(v9 + 8) = v4 - 1;
				v10 = *(const void **)v9;
				**(x_DWORD **)(v8 + *(x_DWORD *)(a1 + 12)) = (x_DWORD)i;
				qmemcpy(i, (void*)v10, *(x_DWORD *)(*(x_DWORD *)(v8 + *(x_DWORD *)(a1 + 12)) + 4));
				v2 = *(x_DWORD *)(*(x_DWORD *)(4 * v4 + *(x_DWORD *)(a1 + 12)) + 4);
			}
			*(x_WORD *)(a1 + 20) = v7 - 1;
		}
	}
	return v2;
}

//----- (000720C0) --------------------------------------------------------
void sub_720C0(int *a1)
{
	int v1; // edx

	v1 = *a1;
	if (*a1)
	{
		if (*(x_WORD *)(v1 + 24) == 1)
		{
			sub_83E80_sound_proc_99((Bit8u*)*(x_DWORD *)(v1 + 16));
			sub_83E80_sound_proc_99((Bit8u*)*(x_DWORD *)(*a1 + 8));
			sub_83E80_sound_proc_99((Bit8u*)*(x_DWORD *)(*a1 + 12));
			sub_83E80_sound_proc_99((Bit8u*)*a1);
		}
		*a1 = 0;
	}
}

//----- (00072120) --------------------------------------------------------
int sub_72120(unsigned __int16 a1)
{
	unsigned __int16 v1; // di
	int v2; // esi
	int v3; // ebx
	int v4; // eax
	int v5; // eax

	v1 = a1;
	sub_83CC0(9);
	v2 = (int)sub_83CD0_malloc2(6);
	v3 = v2;
	if (v2 && (v4 = (int)sub_83CD0_malloc2(28 * a1), (*(x_DWORD *)(v2 + 2) = v4) != 0))
	{
		*(x_WORD *)v2 = a1;
		while (--v1 != -1)
		{
			v5 = 7 * v1;
			*(x_DWORD *)(*(x_DWORD *)(v2 + 2) + 4 * v5 + 4) = 0;
			*(x_DWORD *)(*(x_DWORD *)(v2 + 2) + 4 * v5) = 0;
		}
	}
	else if (v2)
	{
		sub_83E80_sound_proc_99((Bit8u*)v2);
		v3 = 0;
	}
	sub_83CC0(10);
	return v3;
}

//----- (000721C0) --------------------------------------------------------
int sub_721C0(unsigned __int16 *a1, int *a2, __int16 a3)
{
	signed __int16 v3; // cx
	signed __int16 v4; // si
	signed __int16 i; // bx
	x_DWORD *v6; // edx
	int v7; // ebx
	int v8; // ecx
	__int16 v9; // ST08_2
	int v10; // edx
	signed __int16 v12; // [esp+Ch] [ebp-4h]

	v3 = -1;
	v4 = -1;
	if (!*a1)
		return 0;
	for (i = 0; i < (signed int)*a1; i++)
	{
		v6 = (x_DWORD *)(28 * i + *(x_DWORD *)(a1 + 1));
		if (v6[1])
		{
			if (!*v6)
				v4 = i;
		}
		else
		{
			v3 = i;
		}
	}
	v12 = v3 <= 0 ? v4 : v3;
	if (v12 <= -1)
		return 0;
	v7 = *a2;
	v8 = *(unsigned __int16 *)(*a2 + 4) * *(unsigned __int16 *)(*a2 + 2);
	v9 = *(x_WORD *)(v8 + *a2 + 6);
	v10 = 28 * v12;
	*(x_DWORD *)(v10 + *(x_DWORD *)(a1 + 1) + 4) = (x_DWORD)a2;
	*(x_WORD *)(v10 + *(x_DWORD *)(a1 + 1) + 12) = 6;
	*(x_WORD *)(v10 + *(x_DWORD *)(a1 + 1) + 14) = v8 + 6;
	*(x_WORD *)(v10 + *(x_DWORD *)(a1 + 1) + 16) = v9;
	*(x_WORD *)(v10 + *(x_DWORD *)(a1 + 1) + 18) = *(x_WORD *)(v7 + 2);
	*(x_WORD *)(v10 + *(x_DWORD *)(a1 + 1) + 20) = *(x_WORD *)(v7 + 4);
	*(x_DWORD *)(v10 + *(x_DWORD *)(a1 + 1) + 8) = v8 + 6;
	*(x_WORD *)(v10 + *(x_DWORD *)(a1 + 1) + 22) = 1;
	*(x_DWORD *)(v10 + *(x_DWORD *)(a1 + 1)) = 1;
	*(x_WORD *)(v10 + *(x_DWORD *)(a1 + 1) + 24) = v12;
	*(x_WORD *)(v10 + *(x_DWORD *)(a1 + 1) + 26) = a3;
	return v10 + *(x_DWORD *)(a1 + 1);
}

//----- (00072350) --------------------------------------------------------
int sub_72350(int a1)
{
	int v1; // esi
	int v2; // edi
	int v3; // eax
	__int16 v4; // cx
	int result; // eax

	if (*(x_WORD *)(a1 + 22) > *(x_WORD *)(a1 + 16))
	{
		*(x_WORD *)(a1 + 22) = 1;
		*(x_DWORD *)(a1 + 8) = *(unsigned __int16 *)(a1 + 14);
	}
	v1 = **(x_DWORD **)(a1 + 4);
	v2 = *(x_DWORD *)(a1 + 8);
	sub_765FC(*(x_WORD *)(a1 + 18), 0);
	v1 += 6;
	v3 = sub_76619(v1 + v2, v1);
	v4 = *(x_WORD *)(a1 + 22);
	result = v3 - v1;
	*(x_DWORD *)(a1 + 8) = result;
	*(x_WORD *)(a1 + 22) = v4 + 1;
	return result;
}

//----- (000723B0) --------------------------------------------------------
unsigned __int16 sub_723B0(int a1, char a2)
{
	unsigned __int16 result; // ax

	if (a2)
	{
		while (1)
		{
			result = *(x_WORD *)(a1 + 22);
			if (result > *(x_WORD *)(a1 + 16))
				break;
			sub_72350(a1);
		}
	}
	else
	{
		memset((void*)(**(x_DWORD **)(a1 + 4) + 6), 0, *(unsigned __int16 *)(a1 + 18) * *(unsigned __int16 *)(a1 + 20));
		*(x_WORD *)(a1 + 22) = 1;
		result = *(x_WORD *)(a1 + 14);
		*(x_DWORD *)(a1 + 8) = result;
	}
	return result;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);

//----- (00072410) --------------------------------------------------------
x_DWORD *sub_72410(x_DWORD *a1)
{
	x_DWORD *result; // eax

	result = a1;
	if (a1)
	{
		a1[0] = 0;
		a1[1] = 0;
	}
	return result;
}

//----- (000724F0) --------------------------------------------------------
int sub_724F0(int a1, __int16 a2)
{
	int result; // eax
	int v3; // edx

	HIWORD(v3) = HIWORD(a1);
	result = *(x_DWORD *)(a1 + 2);
	LOWORD(v3) = *(x_WORD *)a1;
	if (!*(x_WORD *)a1)
		return 0;
	while (!*(x_DWORD *)(result + 4) || a2 != *(x_WORD *)(result + 26))
	{
		--v3;
		result += 28;
		if (!(x_WORD)v3)
			return 0;
	}
	return result;
}

//----- (00072550) --------------------------------------------------------
void sub_72550(int *a1)
{
	if (*a1)
	{
		sub_83E80_sound_proc_99((Bit8u*)*(x_DWORD *)(*a1 + 2));
		*(x_DWORD *)(*a1 + 2) = 0;
		sub_83E80_sound_proc_99((Bit8u*)*a1);
		*a1 = 0;
	}
}

//----- (00072633) --------------------------------------------------------
Bit16u /*__spoils<>*/ sub_72633(Bit16s a1, Bit16s a2)//253633 //4c //3e
{
	//signed int v2; // ebx
	Bit16u result; // ax
	//int v4; // ebx
	//int v5; // eax
	//int v6; // ebx

	//debug
	//loadfromsnapshot((char*)"0160-00253633", (Bit8u*)&a1, 0x354ef8, 2);//4c
	//loadfromsnapshot((char*)"0160-00253633", (Bit8u*)&a2, 0x354efc, 2);//3e
	//loadfromsnapshot((char*)"0160-00253633", (Bit8u*)x_WORD_DE350, 0x2af350, 600);//fix it!
	//debug

	if (!a1)
	{
		if (!a2)
			return 0;
	}
	if (a1 < 0)
	{
		if (a2 < 0)
		{
			if (-a1 < -a2)
				result = 2048 - x_WORD_DE350[(-a1 << 8) / -a2];
			else
				result = x_WORD_DE350[(-a2 << 8) / -a1] + 1536;
		}
		else if (-a1 < a2)
		{
			result = x_WORD_DE350[(-a1 << 8) / a2] + 1024;
		}
		else
		{
			result = 1536 - x_WORD_DE350[(a2 << 8) / -a1];
		}
	}
	else if (a2 < 0)
	{
		if (a1 < -a2)
			result = x_WORD_DE350[(a1 << 8) / -a2];
		else
			result = 512 - x_WORD_DE350[(-a2 << 8) / a1];
	}
	else if (a1 < a2)
	{
		result = 1024 - x_WORD_DE350[(a1 << 8) / a2];
	}
	else
	{
		result = x_WORD_DE350[(a2 << 8) / a1] + 512;
	}
	return result;
}
// DE350: using guessed type __int16 x_WORD_DE350[];

//----- (0007277A) --------------------------------------------------------
unsigned int sub_7277A(unsigned int a1)
{
	int v1; // eax
	unsigned int i; // ebx

	if (!a1)
		return 0;
	x_BitScanReverse((unsigned long*)(unsigned int *)&v1, a1);
	for (i = (unsigned __int16)x_WORD_727B0[v1]; (signed int)(a1 / i) < (signed int)i; i = (a1 / i + i) >> 1)
		;
	return i;
}
// 727B0: using guessed type __int16 x_WORD_727B0[];

//----- (000727F0) --------------------------------------------------------
void sub_727F0(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)//fix
{
	/*__outx_BYTE(0x3C8u, a1);
	__outx_BYTE(0x3C9u, a2);
	__outx_BYTE(0x3C9u, a3);
	__outx_BYTE(0x3C9u, a4);*/
}

//----- (00072883) --------------------------------------------------------
void sub_72883_clear_text_mode(void *a2, unsigned __int16 a3, char a4)//253883
{
	int v4; // eax

	/*LOBYTE(a1) = a4;//0
	BYTE1(a1) = a4;//0*/
	v4 = (a4 << 24) + (a4 << 16);
	/*LOBYTE(v4) = a4;
	BYTE1(v4) = a4;*/
	v4 = (v4 & 0xff) + ((v4 & 0xff) << 16);
	memset32(a2, v4, 80 * a3);
}

//----- (000728A9) --------------------------------------------------------
void sub_728A9_clear_graphics_mode(void *a2, unsigned __int16 a3, char a4)//2538a9
{
	/*
cseg01:000728AF                 mov     edi, [ebp+arg_0]
cseg01:000728B6                 imul    ecx, [ebp+arg_4]*0A0h
cseg01:000728BC                 mov     eax=(257*[ebp+arg_8])<<10
cseg01:000728C5                 mov     al, [ebp+arg_8]
cseg01:000728C8                 mov     ah, [ebp+arg_8]
	*/

	//memset32(a2, a4*257*256, a3*160);

	//memset32(a2, 640 * 480, a3 * 160);//fixed
	//11 800 fffffff7 355142
	//00,00,00,00 12c00 1e0*a0 3aa0a4
	memset32(a2, a4, 4 * 160 * a3);
	//3aa0a4,1E0,0


	  /*LOBYTE(a1) = a4;
	  BYTE1(a1) = a4;
	  v4 = a1 << 16;
	  LOBYTE(v4) = a4;
	  BYTE1(v4) = a4;
	  memset32(a2, v4, 160 * a3);*/
}

//----- (00072C40) --------------------------------------------------------
void sub_72C40_draw_bitmap_640_setcolor(Bit16s posx, Bit16s posy, posistruct a3, Bit8u color)//253c40
{
	//Bit16u v4; // dx
	//Bit8u* v5; // esi
	//int result; // eax
	//int v7; // [esp+4h] [ebp-4h]

	//fix it
	//v7 = 0;
	//fix it

	//v4 = *(x_WORD *)(a3 + 4);
	//v5 = *(Bit8u **)a3;
	if (x_WORD_180660_VGA_type_resolution & 1)
	{
		sub_8F920(a3.sizex, a3.sizex, posy, posx, a3.pointer, color, 0);
		//result = v7;
	}
	else
	{
		if (x_WORD_180660_VGA_type_resolution & 8)
		{
			/*doublebyte tempdblbyte;
			tempdblbyte.byte1 = a3.sizex;
			tempdblbyte.byte2 = a3.sizey;*/
			sub_8F935_bitmap_draw_final(a3.sizex, a3.sizey, posy, posx, a3.pointer, color, 0);
		}
		//result = v7;
	}
	//return result;
}
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00072CB0) --------------------------------------------------------
int sub_72CB0(unsigned __int8 *a1, int a2)
{
	int v3; // [esp+4h] [ebp-Ch]
	int v4; // [esp+8h] [ebp-8h]
	unsigned __int8 *v5; // [esp+Ch] [ebp-4h]

	v5 = a1;
	v4 = a2;
	v3 = 0;
	while (v4)
	{
		--v4;
		v3 += *v5++;
	}
	return v3;
}

//----- (00072D04) --------------------------------------------------------
void sub_72D04()
{
	signed int i; // [esp+0h] [ebp-8h]
	signed int j; // [esp+4h] [ebp-4h]

	if (x_BYTE_E1274)
	{
		for (i = 0; x_WORD_E127A > i; i++)
		{
			while (*(x_BYTE *)(x_DWORD_E12AE[i] + 49) == -1)
				;
		}
		while (*(x_BYTE *)(x_DWORD_E12AA + 49) == -1)
			;
		sub_83E80_sound_proc_99((Bit8u*)x_DWORD_E12AA);
		for (j = 0; j < 8; j++)
		{
			sub_83E80_sound_proc_99((Bit8u*)x_DWORD_E12AE[j]);
			sub_83E80_sound_proc_99((Bit8u*)x_DWORD_E1286[j]);
		}
		sub_83E80_sound_proc_99((Bit8u*)x_DWORD_E127E);
		sub_83E80_sound_proc_99((Bit8u*)x_DWORD_E1282);
		x_BYTE_E1274 = 0;
	}
}
// E1274: using guessed type char x_BYTE_E1274;
// E127A: using guessed type __int16 x_WORD_E127A;
// E127E: using guessed type int x_DWORD_E127E;
// E1282: using guessed type int x_DWORD_E1282;
// E12AA: using guessed type int x_DWORD_E12AA;

//----- (00072DDE) --------------------------------------------------------
int sub_72DDE(signed __int16 *a1, int a2)
{
	//char v3; // [esp+0h] [ebp-1Ch]
	int result; // [esp+14h] [ebp-8h]

	sprintf_s(printbuffer, 512, "%s%d", "TESTER", a2);
	do
	{
		result = sub_74767(a1, (x_BYTE *)x_DWORD_E12AE[a2], (Bit8u*)printbuffer);
		if (result && (result == 13))
			sub_74A86((x_BYTE *)x_DWORD_E12AE[a2], (Bit8u*)printbuffer);
	} while (result == 13 && !x_WORD_E12A6);
	return result;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// E12A6: using guessed type __int16 x_WORD_E12A6;

//----- (00072E70) --------------------------------------------------------
int /*__fastcall*/ sub_72E70(int a1, int a2, signed __int16 *a3)
{
	int v3; // edx
	char v5; // [esp+0h] [ebp-30h]
	char v6[8]; // [esp+18h] [ebp-18h]
	int v7; // [esp+20h] [ebp-10h]
	int i; // [esp+28h] [ebp-8h]
	int v9; // [esp+2Ch] [ebp-4h]

	for (i = 0; x_WORD_E127A > i; i++)
	{
		if (x_WORD_E1276 != i)
			sub_74809(i);
	}
	memset(v6, 0, 8);
	v9 = 0;
	while (v9 < 2)
	{
		v3 = v6[x_WORD_E1276];
		if (v3 == x_WORD_E127A - 1 || x_WORD_E12A6)
			break;
		for (i = 0; x_WORD_E127A > i; i++)
		{
			if (x_WORD_E1276 != i)
			{
				v5 = *(x_BYTE *)(x_DWORD_E12AE[i] + 49);
				if (v5)
				{
					if (v5 == -1)
					{
						if (v9)
							sub_748F7(i);
					}
					else if (!v6[i])
					{
						++v6[x_WORD_E1276];
						v6[i] = 1;
					}
				}
				else if (++v9 == 1)
				{
					x_WORD_E12A8 = i;
				}
			}
		}
		sub_7C230(x_WORD_E127A, v3, a3);
	}
	v7 = v9;
	return v9;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// E1276: using guessed type __int16 x_WORD_E1276;
// E127A: using guessed type __int16 x_WORD_E127A;
// E12A6: using guessed type __int16 x_WORD_E12A6;
// E12A8: using guessed type __int16 x_WORD_E12A8;
// 72E70: using guessed type char var_18[8];

//----- (00072FBB) --------------------------------------------------------
signed int /*__fastcall*/ sub_72FBB(int a1, int a2, signed __int16 *a3)
{
	int v3; // edx
	int i; // [esp+4h] [ebp-4h]

	//fix it
	v3 = 0;
	//fix it

	sub_74809(0);
	for (i = x_DWORD_17DB54_game_turn2; ; sub_7C230(x_DWORD_17DB54_game_turn2 - i, v3, a3))
	{
		if (*(x_BYTE *)(x_DWORD_E12AE[0] + 49) != -1)
			return 1;
		if ((x_DWORD_17DB54_game_turn2 - i) > 0x78)
			break;
	}
	sub_748F7(0);
	return 0;
}
// 17DB54: using guessed type int x_DWORD_17DB54_game_turn2;

//----- (0007302E) --------------------------------------------------------
signed int sub_7302E()
{
	signed int i; // [esp+4h] [ebp-4h]

	for (i = 0; x_WORD_E127A > i && !x_WORD_E12A6; i++)
	{
		if (x_WORD_E1276 != i)
			sub_74B75(i);
	}
	return 1;
}
// E1276: using guessed type __int16 x_WORD_E1276;
// E127A: using guessed type __int16 x_WORD_E127A;
// E12A6: using guessed type __int16 x_WORD_E12A6;

//----- (0007308F) --------------------------------------------------------
int sub_7308F(signed __int16 *a1, Bit8u* a2, __int16 a3)
{
	Bit8u* v3; // edx
	int v4; // eax
	int v6; // [esp+4h] [ebp-24h]
	//char v7; // [esp+8h] [ebp-20h]
	int i; // [esp+1Ch] [ebp-Ch]
	int v9; // [esp+20h] [ebp-8h]

	//fix
	v3 = 0;
	//fix

	if (!x_BYTE_E1274 || x_BYTE_E1275)
		return -1;
	if (a3)
		x_WORD_E127A = a3;
	else
		x_WORD_E127A = 8;
	x_BYTE_E1275 = 0;
	x_WORD_E12A6 = 0;
	char testerstr[512] = "TESTER";
	strcpy_s(testerstr, 512, (char*)a2);
	for (i = 0; x_WORD_E127A > i; i++)
		x_BYTE_E12CE[i] = 0;
	for (i = 0; x_WORD_E127A > i; i++)
	{
		while (*(x_BYTE *)(x_DWORD_E12AE[i] + 49) == -1)
			;
	}
	while (*(x_BYTE *)(x_DWORD_E12AA + 49) == -1)
		;
	i = 0;
	x_WORD_E1276 = -1;
	while (x_WORD_E127A > i && x_WORD_E1276 == -1 && !x_WORD_E12A6)
	{
		v6 = sub_72DDE(a1, i);
		if (v6)
		{
			if (v6 == 255)
			{
				sub_748F7(i);
				i = x_WORD_E127A;
			}
		}
		else
		{
			x_WORD_E1276 = i;
		}
		++i;
	}
	if (x_WORD_E1276 == -1)
		return -1;
	for (i = 0; ; i++)
	{
		v4 = x_WORD_E127A;
		if (x_WORD_E127A <= i)
			break;
		if (x_WORD_E1276 != i)
		{
			strcpy_s((char*)(x_DWORD_E12AE[i] + 26), sizeof(x_DWORD_E12AE[i] + 26), (const char*)(x_DWORD_E12AE[x_WORD_E1276] + 26));
			v3 = x_DWORD_E12AE[x_WORD_E1276];
			LOBYTE(v3) = *(x_BYTE *)(v3 + 3);
			*(x_BYTE *)(x_DWORD_E12AE[i] + 3) = (int8)v3;
		}
	}
	LOWORD(v4) = x_WORD_E1276;
	if (x_WORD_E1276)
	{
		if (!sub_72FBB(v4, (int)v3, a1))
			x_WORD_E12A6 = 1;
	}
	else
	{
		sub_7302E();
		x_WORD_E12A8 = x_WORD_E1276;
	}
	if (x_WORD_E12A6 == 1)
	{
		for (i = 0; x_WORD_E127A > i; i++)
		{
			if (x_WORD_E1276 != i)
				sub_748F7(i);
		}
		sprintf_s(printbuffer, 512, "%s%d", testerstr, x_WORD_E1276);
		sub_74A86((x_BYTE *)x_DWORD_E12AE[x_WORD_E1276], (Bit8u*)printbuffer);
		v9 = -1;
	}
	else
	{
		sub_74F76();
		x_BYTE_E1275 = 1;
		v9 = x_WORD_E1276;
	}
	return v9;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// 99D46: using guessed type x_DWORD strcpy(x_DWORD, x_DWORD);
// E1274: using guessed type char x_BYTE_E1274;
// E1275: using guessed type char x_BYTE_E1275;
// E1276: using guessed type __int16 x_WORD_E1276;
// E127A: using guessed type __int16 x_WORD_E127A;
// E12A6: using guessed type __int16 x_WORD_E12A6;
// E12A8: using guessed type __int16 x_WORD_E12A8;
// E12AA: using guessed type int x_DWORD_E12AA;

//----- (00073669) --------------------------------------------------------
int sub_73669(__int16 a1)
{
	int result; // eax
	//char v2; // [esp+0h] [ebp-18h]
	int i; // [esp+14h] [ebp-4h]

	if (x_WORD_E1276 == a1)
	{
		for (i = 0; (signed __int16)i < x_WORD_E127A; i++)
		{
			if ((x_WORD)i != x_WORD_E1276)
			{
				sub_748F7(i);
				sub_74B19((x_BYTE *)x_DWORD_E12AE[(signed __int16)i]);
			}
		}
		sprintf_s(printbuffer, 512, "%s%d", "TESTER", x_WORD_E1276);
		result = sub_74A86((x_BYTE *)x_DWORD_E12AE[a1], (Bit8u*)printbuffer);
		x_BYTE_E1275 = 0;
	}
	else
	{
		sub_748F7(a1);
		result = sub_74B19((x_BYTE *)x_DWORD_E12AE[a1]);
	}
	return result;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// E1275: using guessed type char x_BYTE_E1275;
// E1276: using guessed type __int16 x_WORD_E1276;
// E127A: using guessed type __int16 x_WORD_E127A;

//----- (0007373D) --------------------------------------------------------
int sub_7373D(__int16 a1)
{
	Bit8u* result; // eax
	//char v2; // [esp+0h] [ebp-64h]
	char v3[8]; // [esp+54h] [ebp-10h]
	int i; // [esp+5Ch] [ebp-8h]

	//fix
	result = 0;
	//fix


	if (x_BYTE_E1274 && x_BYTE_E1275)
	{
		if ((unsigned __int16)x_WORD_E12A8 == a1)
		{
			if (x_WORD_E1276 == a1)
			{
				for (i = 0; x_WORD_E127A > i; i++)
					v3[i] = x_BYTE_E12CE[i] == 1;
				for (i = 0; x_WORD_E127A > i; i++)
				{
					if (v3[i] == 1)
						sub_74006(i, (int)v3, 8u);
				}
				result = (Bit8u*)sub_73669(a1);
			}
			else
			{
				sub_7404E(x_WORD_E12A8, (int)v3, 8u);
				sub_73669(a1);
				for (i = 0; x_WORD_E127A > i; i++)
				{
					if (v3[i] == 1)
					{
						x_WORD_E12A8 = i;
						v3[i] = 0;
						break;
					}
				}
				if ((unsigned __int16)x_WORD_E12A8 == x_WORD_E1276)
				{
					for (i = 0; ; i++)
					{
						result = (Bit8u*)x_WORD_E127A;
						if (x_WORD_E127A <= i)
							break;
						if (x_WORD_E1276 != i && v3[i] == 1)
						{
							sub_74B75(i);
							while (*(x_BYTE *)(x_DWORD_E12AE[i] + 49) == -1)
								;
							if (*(x_BYTE *)(x_DWORD_E12AE[i] + 49))
								sprintf_s(printbuffer, 512, "Error code (LISTEN) : %d", *(unsigned __int8 *)(x_DWORD_E12AE[i] + 49));
						}
					}
				}
				else
				{
					while (1)
					{
						sub_74809(x_WORD_E12A8);
						while (*(x_BYTE *)(x_DWORD_E12AE[(unsigned __int16)x_WORD_E12A8] + 49) == -1)
							;
						result = x_DWORD_E12AE[x_WORD_E12A8];
						if (!*(x_BYTE *)(result + 49))
							break;
						sprintf_s(printbuffer, 512, "Error code (CALL) : %d", *(unsigned __int8 *)(x_DWORD_E12AE[(unsigned __int16)x_WORD_E12A8] + 49));
					}
				}
			}
		}
		else
		{
			result = (Bit8u*)sub_73669(a1);
		}
	}
	return (int)result;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// E1274: using guessed type char x_BYTE_E1274;
// E1275: using guessed type char x_BYTE_E1275;
// E1276: using guessed type __int16 x_WORD_E1276;
// E127A: using guessed type __int16 x_WORD_E127A;
// E12A8: using guessed type __int16 x_WORD_E12A8;
// 7373D: using guessed type char var_10[8];

//----- (000739AD) --------------------------------------------------------
__int16 sub_739AD(__int16 a1)
{
	__int16 result; // ax
	//char v2; // [esp+0h] [ebp-18h]
	int i; // [esp+14h] [ebp-4h]

	if (x_WORD_E1276 == a1)
	{
		for (i = 0; (signed __int16)i < x_WORD_E127A; i++)
		{
			if ((x_WORD)i != x_WORD_E1276)
			{
				sub_748F7(i);
				sub_74B19((x_BYTE *)x_DWORD_E12AE[(signed __int16)i]);
			}
		}
		sprintf_s(printbuffer, 512, "%s%d", "TESTER", x_WORD_E1276);
		result = sub_74A86((x_BYTE *)x_DWORD_E12AE[a1], (Bit8u*)printbuffer);
		x_BYTE_E1275 = 0;
	}
	else
	{
		sub_748F7(a1);
		sub_74B19((x_BYTE *)x_DWORD_E12AE[a1]);
		result = x_WORD_E12A8;
		if (x_WORD_E1276 == (unsigned __int16)x_WORD_E12A8)
			result = sub_74B75(a1);
	}
	return result;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// E1275: using guessed type char x_BYTE_E1275;
// E1276: using guessed type __int16 x_WORD_E1276;
// E127A: using guessed type __int16 x_WORD_E127A;
// E12A8: using guessed type __int16 x_WORD_E12A8;

//----- (00073AA1) --------------------------------------------------------
__int16 sub_73AA1(__int16 a1)
{
	Bit8u* v1; // eax
	//char v3; // [esp+0h] [ebp-64h]
	char v4[8]; // [esp+54h] [ebp-10h]
	int i; // [esp+5Ch] [ebp-8h]

	//fix
	v1 = 0;
	//fix

	if (x_BYTE_E1274 && x_BYTE_E1275)
	{
		if (x_WORD_E12A8 == a1)
		{
			if (x_WORD_E1276 == a1)
			{
				for (i = 0; x_WORD_E127A > i; i++)
					v4[i] = x_BYTE_E12CE[i] == 1;
				for (i = 0; x_WORD_E127A > i; i++)
				{
					if (v4[i] == 1)
						sub_74006(i, (int)v4, 8u);
				}
				LOWORD(v1) = sub_739AD(a1);
			}
			else
			{
				sub_7404E(x_WORD_E12A8, (int)v4, 8u);
				sub_739AD(a1);
				for (i = 0; x_WORD_E127A > i; i++)
				{
					if (v4[i] == 1)
					{
						x_WORD_E12A8 = i;
						v4[i] = 0;
						break;
					}
				}
				if (x_WORD_E12A8 == x_WORD_E1276)
				{
					for (i = 0; ; i++)
					{
						LOWORD(v1) = x_WORD_E127A;
						if (x_WORD_E127A <= i)
							break;
						if (x_WORD_E1276 != i && v4[i] == 1)
						{
							sub_74B75(i);
							while (*(x_BYTE *)(x_DWORD_E12AE[i] + 49) == -1)
								;
							if (*(x_BYTE *)(x_DWORD_E12AE[i] + 49))
								sprintf_s(printbuffer, 512, "Error code (LISTEN) : %d", *(unsigned __int8 *)(x_DWORD_E12AE[i] + 49));
						}
					}
				}
				else
				{
					while (1)
					{
						sub_74809(x_WORD_E12A8);
						while (*(x_BYTE *)(x_DWORD_E12AE[x_WORD_E12A8] + 49) == -1)
							;
						v1 = x_DWORD_E12AE[x_WORD_E12A8];
						if (!*(x_BYTE *)(v1 + 49))
							break;
						sprintf_s(printbuffer, 512, "Error code (CALL) : %d", *(unsigned __int8 *)(x_DWORD_E12AE[x_WORD_E12A8] + 49));
					}
				}
			}
		}
		else
		{
			LOWORD(v1) = sub_739AD(a1);
		}
	}
	return (int)v1;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// E1274: using guessed type char x_BYTE_E1274;
// E1275: using guessed type char x_BYTE_E1275;
// E1276: using guessed type __int16 x_WORD_E1276;
// E127A: using guessed type __int16 x_WORD_E127A;
// E12A8: using guessed type __int16 x_WORD_E12A8;
// 73AA1: using guessed type char var_10[8];

//----- (00073D11) --------------------------------------------------------
__int16 sub_73D11(__int16 a1)
{
	__int16 result; // ax
	//char v2; // [esp+0h] [ebp-18h]
	int i; // [esp+14h] [ebp-4h]

	if (x_WORD_E1276 == a1)
	{
		for (i = 0; (signed __int16)i < x_WORD_E127A; i++)
		{
			if ((x_WORD)i != x_WORD_E1276)
			{
				sub_748F7(i);
				sub_74B19((x_BYTE *)x_DWORD_E12AE[(signed __int16)i]);
			}
		}
		sprintf_s(printbuffer, 512, "%s%d", "TESTER", x_WORD_E1276);
		result = sub_74A86((x_BYTE *)x_DWORD_E12AE[a1], (Bit8u*)printbuffer);
		x_BYTE_E1275 = 0;
	}
	else
	{
		sub_748F7(a1);
		sub_74B19((x_BYTE *)x_DWORD_E12AE[a1]);
		result = x_WORD_E12A8;
		if (x_WORD_E1276 == (unsigned __int16)x_WORD_E12A8)
			result = sub_74B75(a1);
	}
	return result;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// E1275: using guessed type char x_BYTE_E1275;
// E1276: using guessed type __int16 x_WORD_E1276;
// E127A: using guessed type __int16 x_WORD_E127A;
// E12A8: using guessed type __int16 x_WORD_E12A8;

//----- (00074006) --------------------------------------------------------
unsigned __int16 sub_74006(unsigned __int16 a1, int a2, unsigned int a3)
{
	unsigned __int16 result; // ax

	if (x_BYTE_E1274)
	{
		result = a1;
		if (x_BYTE_E12CE[a1] == 1)
			result = sub_74EF1((unsigned int)x_DWORD_E12AE[a1], a2, a3);
	}
	return result;
}
// E1274: using guessed type char x_BYTE_E1274;

//----- (0007404E) --------------------------------------------------------
unsigned __int16 sub_7404E(unsigned __int16 a1, int a2, unsigned int a3)
{
	unsigned __int16 result; // ax

	if (x_BYTE_E1274)
	{
		result = a1;
		if (x_BYTE_E12CE[a1] == 1)
			result = sub_74D41((unsigned int)x_DWORD_E12AE[a1], a2, a3);
	}
	return result;
}
// E1274: using guessed type char x_BYTE_E1274;

//----- (00074374) --------------------------------------------------------
__int16 sub_74374()
{
	return sub_74F76();
}

//----- (0007438A) --------------------------------------------------------
unsigned __int16 sub_7438A(int a1, unsigned int a2)
{
	unsigned __int16 result; // ax
	signed __int16 i; // [esp+4h] [ebp-4h]
	signed __int16 j; // [esp+4h] [ebp-4h]

	if (x_BYTE_E1274)
	{
		if (x_WORD_E1276 == (unsigned __int16)x_WORD_E12A8)
		{
			for (i = 0; i < x_WORD_E1278; i++)
			{
				if (i != x_WORD_E1276)
					sub_7404E(i, a1 + a2 * i, a2);
			}
			for (j = 0; ; j++)
			{
				result = j;
				if (j >= x_WORD_E1278)
					break;
				if (j != x_WORD_E1276)
					sub_74006(j, a1, a2 * x_WORD_E1278);
			}
		}
		else
		{
			sub_74006(x_WORD_E12A8, a1 + a2 * x_WORD_E1276, a2);
			result = sub_7404E(x_WORD_E12A8, a1, a2 * x_WORD_E1278);
		}
	}
	return result;
}
// E1274: using guessed type char x_BYTE_E1274;
// E1276: using guessed type __int16 x_WORD_E1276;
// E1278: using guessed type __int16 x_WORD_E1278;
// E12A8: using guessed type __int16 x_WORD_E12A8;

//----- (0007449C) --------------------------------------------------------
__int16 sub_7449C()
{
	__int16 result; // ax
	signed int i; // [esp+0h] [ebp-4h]

	if (x_BYTE_E1274)
	{
		result = x_WORD_E12A8;
		if (x_WORD_E1276 == (unsigned __int16)x_WORD_E12A8)
		{
			for (i = 0; ; i++)
			{
				result = x_WORD_E127A;
				if (x_WORD_E127A <= i)
					break;
				if (x_WORD_E1276 != i && *(x_BYTE *)(x_DWORD_E12AE[i] + 49) == -1)
					sub_748F7(i);
			}
		}
	}
	return result;
}
// E1274: using guessed type char x_BYTE_E1274;
// E1276: using guessed type __int16 x_WORD_E1276;
// E127A: using guessed type __int16 x_WORD_E127A;
// E12A8: using guessed type __int16 x_WORD_E12A8;

//----- (00074515) --------------------------------------------------------
int sub_74515()
{
	return (unsigned __int16)x_WORD_E12A8;
}
// E12A8: using guessed type __int16 x_WORD_E12A8;

//----- (00074536) --------------------------------------------------------
int sub_74536()
{
	return x_WORD_E1276;
}
// E1276: using guessed type __int16 x_WORD_E1276;

//----- (00074556) --------------------------------------------------------
Bit8u sub_74556()//255556 push ebp 355250
{
	signed int v2; // [esp+4h] [ebp-8h]
	signed int i; // [esp+8h] [ebp-4h]
	signed int j; // [esp+8h] [ebp-4h]

	v2 = 1;
	if (!x_BYTE_E1274 && !x_DWORD_E12AA)
	{
		x_DWORD_E12AA = (Bit8u*)sub_83D70_malloc1(66);
		if (x_DWORD_E12AA)
		{
			if (sub_74A11() == -1)//255a11
				return 0;
			x_DWORD_E127E = (Bit8u*)sub_83D70_malloc1(2048);
			if (x_DWORD_E127E)
			{
				x_DWORD_E1282 = (Bit8u*)sub_83D70_malloc1(2048);
				if (x_DWORD_E1282)
				{
					for (i = 0; i < 8; i++)
					{
						x_DWORD_E1286[i] = (Bit8u*)sub_83D70_malloc1(2048);
						if (!x_DWORD_E1286[i])
						{
							v2 = 0;
							break;
						}
						x_DWORD_E12AE[i] = (Bit8u*)sub_83D70_malloc1(66);
						if (!x_DWORD_E12AE[i])
						{
							v2 = 0;
							break;
						}
					}
					if (i == 8)
						x_BYTE_E1274 = 1;
				}
				else
				{
					v2 = 0;
				}
			}
			else
			{
				v2 = 0;
			}
		}
		else
		{
			v2 = 0;
		}
	}
	if (!v2)
	{
		x_BYTE_E1274 = 0;
		if (x_DWORD_E12AA)
			sub_83E80_sound_proc_99(x_DWORD_E12AA);
		if (x_DWORD_E127E)
			sub_83E80_sound_proc_99(x_DWORD_E127E);
		if (x_DWORD_E1282)
			sub_83E80_sound_proc_99(x_DWORD_E1282);
		for (j = 0; j < 8; j++)
		{
			if (x_DWORD_E12AE[j])
				sub_83E80_sound_proc_99(x_DWORD_E12AE[j]);
			if (x_DWORD_E1286[j])
				sub_83E80_sound_proc_99(x_DWORD_E1286[j]);
		}
	}
	return x_BYTE_E1274;
}
// E1274: using guessed type char x_BYTE_E1274;
// E127E: using guessed type int x_DWORD_E127E;
// E1282: using guessed type int x_DWORD_E1282;
// E12AA: using guessed type int x_DWORD_E12AA;

//----- (00074767) --------------------------------------------------------
signed int sub_74767(signed __int16 *a1, x_BYTE *a2, Bit8u* a3)
{
	int v3; // edx

	//fix it
	v3 = 0;
	//fix it

	strcpy_s(a2 + 26, sizeof(a2 + 26), (const char*)a3);
	while (strlen(a2 + 26) < 0xFu)
		strcat_s(a2 + 26, sizeof(a2 + 26), " ");
	a2[0] = -80;
	if (sub_75044((unsigned int)a2) == -1)
		return -99;
	while (a2[49] == -1 && !x_WORD_E12A6)
		sub_7C230((int)a2, v3, a1);
	return (unsigned __int8)a2[49];
}
// 99D46: using guessed type x_DWORD strcpy(x_DWORD, x_DWORD);
// 99D6B: using guessed type x_DWORD strlen(x_DWORD);
// 99D84: using guessed type x_DWORD strcat(x_DWORD, x_DWORD);
// E12A6: using guessed type __int16 x_WORD_E12A6;

//----- (00074809) --------------------------------------------------------
int sub_74809(__int16 a1)
{
	int v2; // [esp+14h] [ebp-8h]

	*(x_BYTE *)x_DWORD_E12AE[a1] = -112;
	sprintf_s((char*)(x_DWORD_E12AE[a1] + 10), 512, "%s%d", "TESTER", a1);
	while (strlen((const char*)(x_DWORD_E12AE[a1] + 10)) < 0xFu)
		strcat_s((char*)(x_DWORD_E12AE[a1] + 10), 512, " ");
	*(x_BYTE *)(x_DWORD_E12AE[a1] + 42) = 0;
	*(x_BYTE *)(x_DWORD_E12AE[a1] + 43) = 0;
	if (sub_75044((unsigned int)x_DWORD_E12AE[a1]) == -1)
		v2 = -99;
	else
		v2 = -*(unsigned __int8 *)(x_DWORD_E12AE[a1] + 49);
	return v2;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// 99D6B: using guessed type x_DWORD strlen(x_DWORD);
// 99D84: using guessed type x_DWORD strcat(x_DWORD, x_DWORD);

//----- (000748F7) --------------------------------------------------------
signed int sub_748F7(__int16 a1)
{
	if (*(x_BYTE *)(x_DWORD_E12AE[a1] + 49) != -1)
		return -*(unsigned __int8 *)(x_DWORD_E12AA + 49);
	*(x_BYTE *)x_DWORD_E12AA = 53;
	*(x_WORD *)(x_DWORD_E12AA + 6) = (unsigned int)x_DWORD_E12AE[a1] >> 4;
	if (sub_75044((unsigned int)x_DWORD_E12AA) != -1)
	{
		do
		{
			while (*(x_BYTE *)(x_DWORD_E12AA + 49) == -1)
				;
		} while (*(x_BYTE *)(x_DWORD_E12AE[a1] + 49) == -1);
		return -*(unsigned __int8 *)(x_DWORD_E12AA + 49);
	}
	return -99;
}
// E12AA: using guessed type int x_DWORD_E12AA;

//----- (00074A11) --------------------------------------------------------
signed int sub_74A11()//255a11
{
	__int16 v0; // dx

	//fix it
	v0 = 0;
	//fix it

	/*if ( !dos_getvect(92) && !v0 )
	  return -1;*/ //fix
	*(x_BYTE *)x_DWORD_E12AA = 127;
	if (sub_75044((unsigned int)x_DWORD_E12AA) == -1)//push ebx:1a6f44,push esi:1a7358,push edi:1a7358,push ebp:355234
		return -1;
	if (*(x_BYTE *)(x_DWORD_E12AA + 1) == 3)
		return 0;
	return -1;
}
// 99BA7: using guessed type x_DWORD dos_getvect(x_DWORD);
// E12AA: using guessed type int x_DWORD_E12AA;

//----- (00074A86) --------------------------------------------------------
int sub_74A86(x_BYTE *a1, Bit8u* a2)
{
	strcpy_s(a1 + 26, sizeof(a1 + 26), (const char*)a2);
	while (strlen(a1 + 26) < 0xFu)
		strcat_s(a1 + 26, sizeof(a1 + 26), " ");
	*a1 = -79;
	if (sub_75044((unsigned int)a1) == -1)
		return -99;
	while (a1[49] == -1)
		;
	return -(unsigned __int8)a1[49];
}
// 99D46: using guessed type x_DWORD strcpy(x_DWORD, x_DWORD);
// 99D6B: using guessed type x_DWORD strlen(x_DWORD);
// 99D84: using guessed type x_DWORD strcat(x_DWORD, x_DWORD);

//----- (00074B19) --------------------------------------------------------
int sub_74B19(x_BYTE *a1)
{
	*a1 = -110;
	if (sub_75044((unsigned int)a1) == -1)
		return -99;
	while (a1[49] == -1)
		;
	a1[2] = 0;
	return -(unsigned __int8)a1[49];
}

//----- (00074B75) --------------------------------------------------------
signed int sub_74B75(__int16 a1)
{
	//char v2; // [esp+0h] [ebp-18h]

	if (*(x_BYTE *)(x_DWORD_E12AE[a1] + 49) == -1)
		return -*(unsigned __int8 *)(x_DWORD_E12AE[a1] + 49);
	sprintf_s(printbuffer, 512, "%s%d", "TESTER", a1);
	*(x_BYTE *)x_DWORD_E12AE[a1] = -111;
	strcpy_s((char*)(x_DWORD_E12AE[a1] + 10), sizeof(x_DWORD_E12AE[a1] + 10), printbuffer);
	while (strlen((const char*)(x_DWORD_E12AE[a1] + 10)) < 0xFu)
		strcat_s((char*)(x_DWORD_E12AE[a1] + 10), sizeof(x_DWORD_E12AE[a1] + 10), " ");
	*(x_BYTE *)(x_DWORD_E12AE[a1] + 42) = 0;
	*(x_BYTE *)(x_DWORD_E12AE[a1] + 43) = 0;
	if (sub_75044((unsigned int)x_DWORD_E12AE[a1]) != -1)
	{
		*(x_WORD *)(x_DWORD_E12AE[a1] + 4) = 0;
		return -*(unsigned __int8 *)(x_DWORD_E12AE[a1] + 49);
	}
	return -99;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// 99D46: using guessed type x_DWORD strcpy(x_DWORD, x_DWORD);
// 99D6B: using guessed type x_DWORD strlen(x_DWORD);
// 99D84: using guessed type x_DWORD strcat(x_DWORD, x_DWORD);

//----- (00074C9D) --------------------------------------------------------
int sub_74C9D(unsigned int a1, int a2)
{
	*(x_BYTE *)a1 = -107;
	*(x_WORD *)(a1 + 6) = (unsigned int)x_DWORD_E1282 >> 4;
	*(x_WORD *)(a1 + 8) = 2048;
	if (sub_75044(a1) == -1)
		return -99;
	while (*(x_BYTE *)(a1 + 49) == -1)
		;
	if (*(x_BYTE *)(a1 + 49))
		return -*(unsigned __int8 *)(a1 + 49);
	memcpy((void*)a2, (void*)x_DWORD_E1282, *(unsigned __int16 *)(a1 + 8));
	return *(unsigned __int16 *)(a1 + 8);
}
// 99DBD: using guessed type x_DWORD memcpy(x_DWORD, x_DWORD, x_DWORD);
// E1282: using guessed type int x_DWORD_E1282;

//----- (00074D41) --------------------------------------------------------
int sub_74D41(unsigned int a1, int a2, unsigned int a3)
{
	int v3; // eax
	int v5; // [esp+0h] [ebp-10h]
	int v6; // [esp+4h] [ebp-Ch]
	unsigned int v7; // [esp+8h] [ebp-8h]
	int v8; // [esp+Ch] [ebp-4h]

	v8 = a2;
	v7 = 0;
	while (a3 >> 11 > v7)
	{
		v6 = sub_74C9D(a1, v8);
		if (v6 != 2048)
			return v6;
		++v7;
		v8 += 2048;
	}
	v3 = sub_74C9D(a1, v8);
	if ((a3 & 0x7FF) == v3)
		v5 = a3;
	else
		v5 = v3;
	return v5;
}

//----- (00074DD4) --------------------------------------------------------
signed int sub_74DD4(unsigned int a1, int a2, unsigned __int16 a3)
{
	signed int v4; // [esp+0h] [ebp-4h]

	*(x_BYTE *)a1 = -107;
	*(x_WORD *)(a1 + 6) = (unsigned int)x_DWORD_E1286[a3] >> 4;
	*(x_WORD *)(a1 + 8) = 2048;
	if (sub_75044(a1) == -1)
		v4 = -99;
	else
		v4 = 1;
	return v4;
}

//----- (00074E6D) --------------------------------------------------------
int sub_74E6D(unsigned int a1, int a2, int a3)
{
	memcpy((void*)x_DWORD_E127E, (void*)a2, a3);
	*(x_BYTE *)a1 = -108;
	*(x_WORD *)(a1 + 6) = (unsigned int)x_DWORD_E127E >> 4;
	*(x_WORD *)(a1 + 8) = a3;
	if (sub_75044(a1) == -1)
		return -99;
	while (*(x_BYTE *)(a1 + 49) == -1)
		;
	return -*(unsigned __int8 *)(a1 + 49);
}
// 99DBD: using guessed type x_DWORD memcpy(x_DWORD, x_DWORD, x_DWORD);
// E127E: using guessed type int x_DWORD_E127E;

//----- (00074EF1) --------------------------------------------------------
int sub_74EF1(unsigned int a1, int a2, unsigned int a3)
{
	unsigned int v5; // [esp+4h] [ebp-Ch]
	int v6; // [esp+8h] [ebp-8h]
	__int16 v7; // [esp+Ch] [ebp-4h]

	v6 = a2;
	v5 = 0;
	while (1)
	{
		if (a3 >> 11 <= v5)
			return sub_74E6D(a1, v6, a3 & 0x7FF);
		v7 = sub_74E6D(a1, v6, 2048);
		if (v7)
			break;
		++v5;
		v6 += 2048;
	}
	return v7;
}

//----- (00074F76) --------------------------------------------------------
__int16 sub_74F76()
{
	__int16 result; // ax
	__int16 i; // [esp+0h] [ebp-4h]

	for (i = 0; i < x_WORD_E127A; i++)
	{
		x_BYTE_E12CE[i] = sub_74FE1(i);
		if (x_BYTE_E12CE[i])
			x_WORD_E1278 = i + 1;
	}
	result = x_WORD_E127A;
	x_WORD_E1278 = x_WORD_E127A;
	return result;
}
// E1278: using guessed type __int16 x_WORD_E1278;
// E127A: using guessed type __int16 x_WORD_E127A;

//----- (00074FE1) --------------------------------------------------------
signed int sub_74FE1(__int16 a1)
{
	signed int v2; // [esp+0h] [ebp-4h]

	if (a1 == x_WORD_E1276)
		v2 = 2;
	else
		v2 = *(x_BYTE *)(x_DWORD_E12AE[a1] + 2) && !*(x_BYTE *)(x_DWORD_E12AE[a1] + 49);
	return v2;
}
// E1276: using guessed type __int16 x_WORD_E1276;

//----- (00075044) --------------------------------------------------------
int sub_75044(unsigned int a1)//256044
{
	/* fix it
  char v2; // [esp+0h] [ebp-7Ch]
  int v3; // [esp+10h] [ebp-6Ch]
  int v4; // [esp+1Ch] [ebp-60h]
  __int16 v5; // [esp+22h] [ebp-5Ah]
  __int16 v6; // [esp+24h] [ebp-58h]
  int v7; // [esp+34h] [ebp-48h]
  int v8; // [esp+38h] [ebp-44h]
  char *v9; // [esp+48h] [ebp-34h]
  char v10; // [esp+50h] [ebp-2Ch]
  int v11; // [esp+68h] [ebp-14h]
  char v12; // [esp+6Ch] [ebp-10h]
  int v13; // [esp+78h] [ebp-4h]

  //fix it
  v11 = 0;
  //fix it

  *(x_BYTE *)(a1 + 49) = 0;
  memset(&v2, 0, 50);
  v6 = a1 >> 4;
  v5 = a1 >> 4;
  v3 = 0;
  v4 = 256;
  memset(&v7, 0, 28);
  memset(&v10, 0, 28);
  memset(&v12, 0, 12);
  segread((SREGS*)&v12);
  v7 = 0x300;
  v8 = 0x5C;
  v9 = &v2;
  int386x(0x31, (REGS*)&v7, (REGS*)&v10, (SREGS*)&v12);//Simulate Real Mode Interrupt //mozna neco se siti, nebo klavesnici
  if ( v11 )
	v13 = -1;
  else
	v13 = 0;
  return v13;
  */
	return 1;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 99DE6: using guessed type x_DWORD segread(x_DWORD);
// 99E10: using guessed type x_DWORD int386x(x_DWORD, x_DWORD, x_DWORD, x_DWORD);

//----- (00075110) --------------------------------------------------------
HSAMPLE* sub_75110(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4, __int16 a5)
{
	return sub_8F100_sound_proc19(a1, a2, a3 >> 8, 127 * a4 / 0xFFFF, a5 + 100, 0, 3u);
}

//----- (00075160) --------------------------------------------------------
HSAMPLE* sub_75160(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4, __int16 a5)
{
	return sub_8F100_sound_proc19(a1, a2, a3 >> 8, 127 * a4 / 0xFFFF, a5 + 100, 0, 2u);
}

//----- (000751B0) --------------------------------------------------------
HSAMPLE* sub_751B0(__int16 a1, __int16 a2, __int16 a3, unsigned __int16 a4, __int16 a5)
{
	return sub_8F100_sound_proc19(a1, a2, a3 >> 8, 127 * a4 / 0xFFFF, a5 + 100, 0, 1u);
}

//----- (00075200) --------------------------------------------------------
//long sub_75200_VGA_Blit640_index= 0;
void sub_75200_VGA_Blit640(Bit16u height)//256200
{
	//Bit8u* v1; // esi
	//int v2; // esi
	  //save 4

	if (!x_BYTE_E3766)
		sub_8CACD_draw_cursor2();//26dacd

		//save 5
	  //debug
	  //x_DWORD_180628b_screen_buffer = (Bit8u*)malloc(0x10000);
	  //0x351628->3aa0a4
		/*int compsize;
		Bit8u origbyte = 0;
		Bit8u remakebyte = 0;
		if (sub_75200_VGA_Blit640_index >0) {
			compsize=compare_with_snapshot((char*)"0160-00256200-2", x_DWORD_180628b_screen_buffer, 0x3aa0a4, 640 * height,&origbyte,&remakebyte);//4c


		}*/
		//sub_75200_VGA_Blit640_index++;
		//debug

	VGA_Blit(640, height, x_DWORD_180628b_screen_buffer);
	mydelay(20);//set speed

	/*
	sub_9951B(0);//27a51b - objevil se kurzor
	save 6
	qmemcpy(&loc_A0000_vga_buffer, (void *)x_DWORD_180628b_screen_buffer, 0x10000u);//27a51b
	//v1 = &x_DWORD_180628b_screen_buffer[ 0x10000];
	sub_9951B(1);//27a51b - tady se uz neco zobrazilo - asi 1/4
	qmemcpy(&loc_A0000_vga_buffer, x_DWORD_180628b_screen_buffer+ 0x10000, 0x10000u);//buffer- 102 radku
	//v1 += 0x10000;
	sub_9951B(2);//27a51b //2/2
	qmemcpy(&loc_A0000_vga_buffer, x_DWORD_180628b_screen_buffer + 0x20000, 0x10000u);
	//v2 = (int)(v1 + 0x10000);
	sub_9951B(3);//3/4
	if ( height == 400 )
	{
	  qmemcpy(&loc_A0000_vga_buffer, x_DWORD_180628b_screen_buffer + 0x30000, 0xE800u);
	  sub_8CB1F();//2db1f //4/4
	}
	else
	{
	  qmemcpy(&loc_A0000_vga_buffer, x_DWORD_180628b_screen_buffer + 0x30000, 0x10000u);
	  sub_9951B(4);//4/4
	  qmemcpy(&loc_A0000_vga_buffer, x_DWORD_180628b_screen_buffer + 0x40000, 0xB000u);
	  if ( !x_BYTE_E3766 )
		sub_8CB1F();//prekresleni obrazovky
	}
	*/
}
// E3766: using guessed type char x_BYTE_E3766;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;

//----- (000752C0) --------------------------------------------------------
//#error "753C1: positive sp value has been found (funcsize=79)"

//----- (000753D0) --------------------------------------------------------
void sub_753D0()
{
	__int16 v0; // ax
	int v1; // edx
	int v2; // eax
	__int16 v3; // dx

	//fix it
	v3 = 0;
	v2 = 0;
	//fix it

	v0 = 0;
	while (v0 < 128)
	{
		v1 = v0++;
		x_BYTE_180664[v1] = 0;
	}
	//v2 = dos_getvect(9);
	x_WORD_17D434 = v3;
	x_DWORD_17D430 = v2;
	//return dos_setvect(9, (x_DWORD)sub_752C0, (unsigned __int16)__CS__);
	//return 0;//fix it
}
// 752C0: using guessed type int sub_752C0();
// 99BA7: using guessed type x_DWORD dos_getvect(x_DWORD);
// 99BDB: using guessed type x_DWORD dos_setvect(x_DWORD, x_DWORD, x_DWORD);
// 17D430: using guessed type int x_DWORD_17D430;
// 17D434: using guessed type __int16 x_WORD_17D434;

//----- (00075420) --------------------------------------------------------
int sub_75420()//256420
{
	return dos_setvect(9, x_DWORD_17D430, (unsigned __int16)x_WORD_17D434);
}
// 99BDB: using guessed type x_DWORD dos_setvect(x_DWORD, x_DWORD, x_DWORD);
// 17D430: using guessed type int x_DWORD_17D430;
// 17D434: using guessed type __int16 x_WORD_17D434;

//----- (00075440) --------------------------------------------------------
int sub_75440()
{
	signed int v0; // ebx
	int v1; // esi

	v0 = 96;
	do
	{
		v1 = v0 << 8;
		LOWORD(v1) = ((x_WORD)v0 << 8) | 0x7F;
		memset(&unk_17D6D4, 0, 50);
		x_DWORD_17D6F0 = v1;
		x_DWORD_17D6E4 = 0;
		x_DWORD_17D6EC = 0;
		x_DWORD_17D6E8 = 0;
		sub_75AE0((int)&unk_17D6D4);
		if ((v0 | 0x7F00) == x_DWORD_17D6F0)
			return v1 & 0xFF00;
		++v0;
	} while (v0 <= 112);
	return 0;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 17D6E4: using guessed type int x_DWORD_17D6E4;
// 17D6E8: using guessed type int x_DWORD_17D6E8;
// 17D6EC: using guessed type int x_DWORD_17D6EC;
// 17D6F0: using guessed type int x_DWORD_17D6F0;

//----- (000754C0) --------------------------------------------------------
int sub_754C0(int a1, x_DWORD *a2, int a3)
{
	int v3; // eax
	int v4; // ecx
	int i; // eax

	memset(&unk_17D6D4, 0, 50);
	v3 = a1;
	LOBYTE(v3) = a1 | 3;
	x_DWORD_17D6EC = 0;
	x_DWORD_17D6F0 = v3;
	x_DWORD_17D6E8 = 0;
	x_WORD_17D6F6 = x_WORD_17D708;
	sub_75AE0((int)&unk_17D6D4);
	v4 = x_DWORD_17D6C8;
	for (i = 0; i < x_DWORD_17D6EC; *(x_BYTE *)(a3 + i - 1) = *(x_BYTE *)(v4 + i - 1))
		++i;
	*a2 = x_DWORD_17D6EC;
	return x_DWORD_17D6F0;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 17D6C8: using guessed type int x_DWORD_17D6C8;
// 17D6E8: using guessed type int x_DWORD_17D6E8;
// 17D6EC: using guessed type int x_DWORD_17D6EC;
// 17D6F0: using guessed type int x_DWORD_17D6F0;
// 17D6F6: using guessed type __int16 x_WORD_17D6F6;
// 17D708: using guessed type __int16 x_WORD_17D708;

//----- (00075540) --------------------------------------------------------
int sub_75540(int a1, int a2)
{
	int v2; // ecx
	signed int v3; // eax
	int v4; // eax

	v2 = x_DWORD_17D6C8;
	v3 = 0;
	do
	{
		++v3;
		*(x_BYTE *)(v2 + v3 - 1) = *(x_BYTE *)(a2 + v3 - 1);
	} while (v3 < 256);
	memset(&unk_17D6D4, 0, 50);
	v4 = a1;
	LOBYTE(v4) = a1 | 4;
	x_DWORD_17D6EC = 0;
	x_DWORD_17D6F0 = v4;
	x_DWORD_17D6E8 = 0;
	x_WORD_17D6F6 = x_WORD_17D708;
	sub_75AE0((int)&unk_17D6D4);
	return x_DWORD_17D6F0;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 17D6C8: using guessed type int x_DWORD_17D6C8;
// 17D6E8: using guessed type int x_DWORD_17D6E8;
// 17D6EC: using guessed type int x_DWORD_17D6EC;
// 17D6F0: using guessed type int x_DWORD_17D6F0;
// 17D6F6: using guessed type __int16 x_WORD_17D6F6;
// 17D708: using guessed type __int16 x_WORD_17D708;

//----- (000755B0) --------------------------------------------------------
int sub_755B0(int a1, x_DWORD *a2, int a3)
{
	int v3; // eax
	int v4; // ecx
	int i; // eax

	memset(&unk_17D6D4, 0, 50);
	v3 = a1;
	LOBYTE(v3) = a1 | 5;
	x_DWORD_17D6EC = 0;
	x_DWORD_17D6F0 = v3;
	x_DWORD_17D6E8 = 0;
	x_WORD_17D6F6 = x_WORD_17D708;
	sub_75AE0((int)&unk_17D6D4);
	v4 = x_DWORD_17D6C8;
	for (i = 0; i < x_DWORD_17D6EC; *(x_BYTE *)(a3 + i - 1) = *(x_BYTE *)(v4 + i - 1))
		++i;
	*a2 = x_DWORD_17D6EC;
	return x_DWORD_17D6F0;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 17D6C8: using guessed type int x_DWORD_17D6C8;
// 17D6E8: using guessed type int x_DWORD_17D6E8;
// 17D6EC: using guessed type int x_DWORD_17D6EC;
// 17D6F0: using guessed type int x_DWORD_17D6F0;
// 17D6F6: using guessed type __int16 x_WORD_17D6F6;
// 17D708: using guessed type __int16 x_WORD_17D708;

//----- (00075650) --------------------------------------------------------
signed int sub_75650()
{
	signed int result; // eax
	char* v1; // eax
	signed int v2; // eax
	int v3; // eax
	char v4; // [esp+0h] [ebp-4h]

   //fix it
	v1 = 0;
	//fix it

	memset(&x_WORD_17D6CC, 0, 6);
	memset(&x_WORD_17D70A, 0, 7);
	x_DWORD_17D6C8 = sub_75B80_alloc_mem_block(256, &x_WORD_17D708, &x_WORD_17D706);
	if (!x_DWORD_17D6C8)
		return 0;
	//_dupenv_s((char**)v1,(size_t*)sizeof(v1), "VIPPORT");
	v1 = mygetenv("VIPPORT");
	if (v1)
	{
		v2 = sub_99FF0(v1, (unsigned __int8 **)&v4, 16);
		x_DWORD_17D6B0 = v2;
		x_DWORD_17D6A0 = v2 + 1;
		v3 = sub_75440();
		x_DWORD_17D640 = v3;
		if (v3)
		{
			if (sub_754C0(v3, &x_DWORD_17D648, (int)x_BYTE_17D440))
			{
				sub_75AB0();
				result = 0;
			}
			else
			{
				x_DWORD_17D644 = 0;
				x_DWORD_17D6A8 = 0;
				x_DWORD_17D698 = 0;
				x_DWORD_17D6AC = (int)&unk_17D540;
				while (x_DWORD_17D698 < x_DWORD_17D648)
				{
					x_DWORD_17D6A4 = x_BYTE_17D440[x_DWORD_17D698];
					if ((unsigned __int8)x_BYTE_17D441[x_DWORD_17D698] <= 7u)
						JUMPOUT(__CS__, (int*) *(&off_75628 + (unsigned __int8)x_BYTE_17D441[x_DWORD_17D698]));
					x_DWORD_17D698 += x_DWORD_17D6A4;
				}
				if (sub_75540(x_DWORD_17D640, (int)x_BYTE_17D440))
				{
					sub_75AB0();
					result = 0;
				}
				else
				{
					if (x_DWORD_17D6A8)
						x_BYTE_E12EC = 1;
					if (x_DWORD_17D644)
						x_BYTE_E12ED = 1;
					result = 1;
				}
			}
		}
		else
		{
			sub_75AB0();
			result = 0;
		}
	}
	else
	{
		x_DWORD_17D6B0 = 768;
		sub_75AB0();
		result = 0;
	}
	return result;
}
// 75628: using guessed type void *off_75628;
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 99E33: using guessed type x_DWORD getenv(x_DWORD);
// 9A050: using guessed type x_DWORD strcmp(x_DWORD, x_DWORD);
// E12EC: using guessed type char x_BYTE_E12EC;
// E12ED: using guessed type char x_BYTE_E12ED;
// 17D640: using guessed type int x_DWORD_17D640;
// 17D644: using guessed type int x_DWORD_17D644;
// 17D648: using guessed type int x_DWORD_17D648;
// 17D698: using guessed type int x_DWORD_17D698;
// 17D6A0: using guessed type int x_DWORD_17D6A0;
// 17D6A4: using guessed type int x_DWORD_17D6A4;
// 17D6A8: using guessed type int x_DWORD_17D6A8;
// 17D6AC: using guessed type int x_DWORD_17D6AC;
// 17D6B0: using guessed type int x_DWORD_17D6B0;
// 17D6B8: using guessed type int x_DWORD_17D6B8;
// 17D6BC: using guessed type int x_DWORD_17D6BC;
// 17D6C0: using guessed type int x_DWORD_17D6C0;
// 17D6C4: using guessed type int x_DWORD_17D6C4;
// 17D6C8: using guessed type int x_DWORD_17D6C8;
// 17D6CC: using guessed type __int16 x_WORD_17D6CC;
// 17D706: using guessed type __int16 x_WORD_17D706;
// 17D708: using guessed type __int16 x_WORD_17D708;
// 17D70A: using guessed type __int16 x_WORD_17D70A;
// 17D711: using guessed type char x_BYTE_17D711;

//----- (00075900) --------------------------------------------------------
int sub_75900()
{
	return sub_75AB0();
}

//----- (00075910) --------------------------------------------------------
signed int sub_75910()
{
	signed int result; // eax
	unsigned __int16 v1; // ax
	unsigned __int8 v2; // al

	if (sub_755B0(x_DWORD_17D640, &x_DWORD_17D648, (int)&unk_17D540))
	{
		sub_75AB0();
		result = 0;
	}
	else
	{
		if (x_BYTE_E12EC)
		{
			__GS__ = *(x_WORD *)&x_BYTE_17D674[4];
			x_WORD_17D6CC = __readgsx_WORD(*(unsigned int *)x_BYTE_17D674);
			v1 = __readgsx_WORD(*(x_DWORD *)x_BYTE_17D674 + 4);
			x_WORD_17D6CE = __readgsx_WORD(*(x_DWORD *)x_BYTE_17D674 + 2);
			x_WORD_17D6D0 = v1;
		}
		if (x_BYTE_E12ED)
		{
			__GS__ = *(x_WORD *)&x_BYTE_17D650[4];
			x_WORD_17D70A = __readgsx_WORD(*(unsigned int *)x_BYTE_17D650);
			x_WORD_17D70C = __readgsx_WORD(*(x_DWORD *)x_BYTE_17D650 + 2);
			v2 = __readgsx_BYTE(*(x_DWORD *)x_BYTE_17D650 + 6);
			x_WORD_17D70E = __readgsx_WORD(*(x_DWORD *)x_BYTE_17D650 + 4);
			x_BYTE_17D710 = v2;
		}
		result = 1;
	}
	return result;
}
// E12EC: using guessed type char x_BYTE_E12EC;
// E12ED: using guessed type char x_BYTE_E12ED;
// 17D640: using guessed type int x_DWORD_17D640;
// 17D648: using guessed type int x_DWORD_17D648;
// 17D6CC: using guessed type __int16 x_WORD_17D6CC;
// 17D6CE: using guessed type __int16 x_WORD_17D6CE;
// 17D6D0: using guessed type __int16 x_WORD_17D6D0;
// 17D70A: using guessed type __int16 x_WORD_17D70A;
// 17D70C: using guessed type __int16 x_WORD_17D70C;
// 17D70E: using guessed type __int16 x_WORD_17D70E;
// 17D710: using guessed type char x_BYTE_17D710;

//----- (000759B0) --------------------------------------------------------
int sub_759B0_set_mouse_minmax_vert()
{
	int result; // eax
	__int16 v1; // [esp+0h] [ebp-1Ch]
	unsigned __int16 v2; // [esp+4h] [ebp-18h]

	if (x_BYTE_E12EC)
	{
		memset(&v1, 0, 28);
		v1 = 0x6008;
		v2 = _byteswap_ushort(*(x_WORD *)(x_DWORD_17D6C4 + 2));
		result = int386(0x33, (REGS*)&v1, (REGS*)&v1);//set mouse minmax vertical
	}
	return result;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// E12EC: using guessed type char x_BYTE_E12EC;
// 17D6C4: using guessed type int x_DWORD_17D6C4;

//----- (00075A10) --------------------------------------------------------
unsigned __int8 sub_75A10(int a1, unsigned __int8 *a2)//256a10 // fix
{
	unsigned __int8 v2; // al
	unsigned __int8 *v3; // ebx
	char v4; // dl
	unsigned __int8 v5; // al
	signed int v6; // ecx
	unsigned __int8 v7; // al
	unsigned __int8 *v8; // ebx
	unsigned __int8 v9; // al
	unsigned __int8 result; // al

	v2 = 0;//fix

	/*__outx_BYTE(x_DWORD_17D6B0, 7u);
	__outx_BYTE(x_DWORD_17D6A0, 0xFFu);
	__outx_BYTE(x_DWORD_17D6B0, 6u);
	v2 = __inx_BYTE(x_DWORD_17D6A0);*/
	v3 = a2;
	v4 = v2 & 0xF8;
	if (a1)
	{
		if (a1 == 1)
			v5 = v4 | 1;
		else
			v5 = (v2 | 4) & 0xFE;
	}
	else
	{
		v5 = v4 | 3;
	}
	/*__outx_BYTE(x_DWORD_17D6A0, v5);
	__outx_BYTE(x_DWORD_17D6B0, 9u);
	__outx_BYTE(x_DWORD_17D6A0, 0);*/
	v6 = 0;
	//__outx_BYTE(x_DWORD_17D6B0, 0xAu);
	do
	{
		v7 = *v3;
		v8 = v3 + 1;
		//__outx_BYTE(x_DWORD_17D6A0, v7);
		v9 = *v8++;
		//__outx_BYTE(x_DWORD_17D6A0, v9);
		++v6;
		result = *v8;
		v3 = v8 + 1;
		//__outx_BYTE(x_DWORD_17D6A0, result);
	} while (v6 < 256);
	return result;
}
// 17D6A0: using guessed type int x_DWORD_17D6A0;
// 17D6B0: using guessed type int x_DWORD_17D6B0;

//----- (00075AB0) --------------------------------------------------------
int sub_75AB0()
{
	int result; // eax

	if (x_DWORD_17D6C8)
	{
		result = sub_75B50(x_WORD_17D706);
		x_DWORD_17D6C8 = 0;
	}
	return result;
}
// 17D6C8: using guessed type int x_DWORD_17D6C8;
// 17D706: using guessed type __int16 x_WORD_17D706;

//----- (00075AE0) --------------------------------------------------------
int sub_75AE0(int a1)
{
	int v2; // [esp+0h] [ebp-28h]
	int v3; // [esp+4h] [ebp-24h]
	int v4; // [esp+8h] [ebp-20h]
	int v5; // [esp+14h] [ebp-14h]
	__int16 v6; // [esp+1Ch] [ebp-Ch]

	memset(&v6, 0, 12);
	memset(&v2, 0, 28);
	v4 = 0;
	v5 = a1;
	v2 = 0x300;
	v3 = 0x33;
	v6 = __DS__;
	return int386x(0x31, (REGS*)&v2, (REGS*)&v2, (SREGS*)&v6);//mozna neco s mysi
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 99E10: using guessed type x_DWORD int386x(x_DWORD, x_DWORD, x_DWORD, x_DWORD);

//----- (00075B50) --------------------------------------------------------
int sub_75B50(__int16 a1)
{
	int v2; // [esp+0h] [ebp-1Ch]
	int v3; // [esp+Ch] [ebp-10h]

	v3 = a1;
	v2 = 0x101;
	return int386(0x31, (REGS*)&v2, (REGS*)&v2);//free memory block
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);

//----- (00075B80) --------------------------------------------------------
int sub_75B80_alloc_mem_block(int a1, x_WORD *a2, x_WORD *a3)
{
	int v3; // ebx
	int v5; // [esp+0h] [ebp-28h]
	unsigned int v6; // [esp+4h] [ebp-24h]
	int v7; // [esp+Ch] [ebp-1Ch]
	int v8; // [esp+18h] [ebp-10h]
	char v9; // [esp+1Ch] [ebp-Ch]

	//fix it
	v7 = 0;
	v8 = 0;
	//fix it

	*a2 = 0;
	*a3 = 0;
	segread((SREGS*)&v9);
	v3 = 0;
	v6 = (unsigned int)(a1 + 15) >> 4;
	v5 = 0x100;
	int386(0x31, (REGS*)&v5, (REGS*)&v5);//allocate memory block
	if (!v8)
	{
		*a2 = v5;
		*a3 = v7;
		v3 = 16 * (signed __int16)*a2;
	}
	return v3;
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// 99DE6: using guessed type x_DWORD segread(x_DWORD);

//----- (00075C50) --------------------------------------------------------
void sub_75C50()//fix
{
	/* __outx_BYTE(0x302u, 2u);
	 __outx_BYTE(0x303u, 1u);*/
	memset((void*)x_DWORD_180628b_screen_buffer, 0, x_DWORD_180624_resolution_y * x_DWORD_18062C_resolution_x);
	if (x_WORD_180660_VGA_type_resolution & 1)
		sub_90478_VGA_Blit320();
	else
		sub_75200_VGA_Blit640(480);
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 180624: using guessed type int x_DWORD_180624_resolution_y;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 18062C: using guessed type int x_DWORD_18062C_resolution_x;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00075CB0) --------------------------------------------------------
void sub_75CB0()//256cb0
{
	if (x_WORD_E12FE && sub_473E0())
	{
		x_WORD_17DB5A = 1;
	}
	else if (x_WORD_17DB5C && (x_BYTE_1806E4 || x_WORD_180746 || x_WORD_180744))
	{
		x_WORD_17DB5A = 1;
	}
	else
	{
		while (x_DWORD_17DB54_game_turn2 < x_DWORD_E3844)
		{
			if (x_WORD_E12FE && sub_473E0())
			{
				x_WORD_17DB5A = 1;
				return;
			}
			if (x_WORD_17DB5C && (x_BYTE_1806E4 || x_WORD_180746 || x_WORD_180744))
			{
				x_WORD_17DB5A = 1;
				return;
			}
		}
		x_DWORD_17DB54_game_turn2 = 0;
	}
}
// E12FE: using guessed type __int16 x_WORD_E12FE;
// E3844: using guessed type int x_DWORD_E3844;
// 17DB54: using guessed type int x_DWORD_17DB54_game_turn2;
// 17DB5A: using guessed type __int16 x_WORD_17DB5A;
// 17DB5C: using guessed type __int16 x_WORD_17DB5C;
// 1806E4: using guessed type char x_BYTE_1806E4;
// 180744: using guessed type __int16 x_WORD_180744;
// 180746: using guessed type __int16 x_WORD_180746;

//----- (00075D70) --------------------------------------------------------
void sub_75D70(Bit8u* a1, Bit32u a2)//256d70
{
	//unsigned int result; // eax

	if (a1)
	{
		//result = a2;
		qmemcpy(a1, (void *)x_DWORD_17DB50, a2);
		//qmemcpy(a1+a2, (void *)(x_DWORD_17DB50+a2), a2&3);
	}
	x_DWORD_17DB50 += a2;
	//return result;
}
// 17DB50: using guessed type int x_DWORD_17DB50;

//----- (00075DB0) --------------------------------------------------------
void sub_75DB0()//256db0
{
	//int result; // eax

	x_DWORD_17D730 = x_DWORD_E1300;
	sub_988A7_read(x_DWORD_17DB38_intro_file_handle, (Bit8u*)x_DWORD_17D720, 16);
	x_WORD_17D724 = x_DWORD_17D720[1] & 0xffff;
	x_WORD_17D726 = (x_DWORD_17D720[1] & 0xffff0000) >> 16;
	while (x_WORD_17D724 != 0xf1fa/*-3590*/)
		myprintf("ERROR UNKNOWN FRAME TYPE\n");
	sub_988A7_read(x_DWORD_17DB38_intro_file_handle, x_DWORD_E9C38_smalltit, x_DWORD_17D720[0] - 16);
	//result = x_DWORD_17D720[0];
	x_DWORD_E1300 += x_DWORD_17D720[0];
	//return result;
}
// E1300: using guessed type int x_DWORD_E1300;
// E9C38: using guessed type int x_DWORD_E9C38_smalltit;
// 17D720: using guessed type int x_DWORD_17D720;
// 17D724: using guessed type __int16 x_WORD_17D724;
// 17D730: using guessed type int x_DWORD_17D730;
// 17DB38: using guessed type int x_DWORD_17DB38_intro_file_handle;

//----- (00075E70) --------------------------------------------------------
void /*__fastcall*/ sub_75E70()//256e70
{
	//int v1; // eax
	unsigned int v2; // ebx
	char *v3; // esi
	char *v4; // edi
	char v5; // al
	char v6; // al
	char *v7; // esi
	char *v8; // esi
	char *v9; // edi
	char v10; // al
	char v11; // al
	char *v12; // esi
	char *v13; // edi
	char v14; // al
	char v15; // al
	char *v16; // edi
	char v17; // al
	char v18; // al
	char v19; // al
	Bit8u v20x[6]; // [esp+0h] [ebp-10h]
	Bit32u v20y; // [esp+0h] [ebp-10h]
	int v21; // [esp+4h] [ebp-Ch]
	Bit8u* v22; // [esp+8h] [ebp-8h]
	char v23; // [esp+Ch] [ebp-4h]

	//fix it
	v21 = 0;
	x_DWORD_17DB54_game_turn2 = 0x40;
	//fix it

	//HIBYTE(a1) = 0;
	v23 = 0;
	x_DWORD_17DB50 = x_DWORD_E9C38_smalltit;
	x_BYTE_17D738[0] = 0;
	if (x_WORD_17D724 == 0xf100)
	{
		sub_75D70(0, x_DWORD_17D720[0] - 16);
		/*v1 = */sub_75DB0();
		/*a1 = 0;*/sub_75E70(/*v1*/);
	}
	else if (x_WORD_17D724 == 0xF1FA)
	{
		v2 = 0;
		while (1)
		{
			//a1 = x_WORD_17D726;
			if (v2 >= x_WORD_17D726)
				break;
			v22 = x_DWORD_17DB50;
			sub_75D70(v20x, 6u);
			v20y = *(Bit32u*)&v20x;
			switch (*(Bit16u*)(&v20x[4]))//4? b
			{
			case 4:
				v3 = (char*)"COLOUR256 ";
				sub_76260_read_intro_pallette(0x100);
				v4 = &x_BYTE_17D738[strlen(x_BYTE_17D738)];
				do
				{
					v5 = v3[0];
					v4[0] = v3[0];
					if (!v5)
						break;
					v6 = v3[1];
					v3 += 2;
					v4[1] = v6;
					v4 += 2;
				} while (v6);
				v23 = 1;
				break;
			case 7:
				v7 = (char*)"SS2 ";
				sub_76300();//257300 - uz by mel byt vykreslen text
				goto LABEL_23;
			case 0xB:
				sub_76260_read_intro_pallette(0x40);
				v8 = (char*)"COLOUR ";
				v9 = &x_BYTE_17D738[strlen(x_BYTE_17D738)];
				do
				{
					v10 = *v8;
					*v9 = *v8;
					if (!v10)
						break;
					v11 = v8[1];
					v8 += 2;
					v9[1] = v11;
					v9 += 2;
				} while (v11);
				v23 = 1;
				break;
			case 0xC:
				v7 = (char*)"LC ";
				sub_76430();
				goto LABEL_23;
			case 0xD:
				memset((void*)x_DWORD_E12F4, 0, x_WORD_17DB48 * x_WORD_17DB4A);
				v7 = (char*)"BLACK ";
				goto LABEL_23;
			case 0xF:
				v7 = (char*)"BRUN ";//ok
				sub_76540();//257540
				goto LABEL_23;
			case 0x10:
				sub_75D70(x_DWORD_E12F4, x_WORD_17DB4A * x_WORD_17DB48);
				v12 = (char*)"COPY ";
				v13 = &x_BYTE_17D738[strlen(x_BYTE_17D738)];
				do
				{
					v14 = *v12;
					*v13 = *v12;
					if (!v14)
						break;
					v15 = v12[1];
					v12 += 2;
					v13[1] = v15;
					v13 += 2;
				} while (v15);
				v20y = x_WORD_17DB4A * x_WORD_17DB48;
				break;
			case 0x12:
				sub_75D70(0, v20y - 6);
				v7 = (char*)"PSTAMP ";
			LABEL_23:
				v16 = &x_BYTE_17D738[strlen(x_BYTE_17D738)];
				do
				{
					v17 = v7[0];
					v16[0] = v7[0];
					if (!v17)
						break;
					v18 = v7[1];
					v7 += 2;
					v16[1] = v18;
					v16 += 2;
				} while (v18);
				break;
			default:
				break;
			}
			v2++;
			x_DWORD_17DB50 = v20y + v22;
		}
	}
	if (x_DWORD_17DB3C)
		x_DWORD_17DB3C();
	sub_75CB0();//256cb0
	if (v23)
	{
		sub_9A0FC_wait_to_screen_beam();//27b0fc
		if (x_WORD_E12FC)
		{
			/*Bit8u origbyte = 0;
			Bit8u remakebyte = 0;
			long compar = compare_with_snapshot((char*)"0160-00256E70", unk_17D838, 0x34e838, 0x300, &origbyte, &remakebyte);
			*/

			sub_41A90_VGA_pallette_install(unk_17D838);
			v19 = sub_5BE80_test_pallette(unk_17D838, 0x3Fu, 0x3Fu, 0x3Fu);
			sub_2EC90(v19);//20fc90 -zde se prekresli texty
		}
	}
	if (x_BYTE_D41C1)
	{
		x_DWORD_180628b_screen_buffer += 0x26C0;
		sub_90478_VGA_Blit320();
		x_DWORD_180628b_screen_buffer -= 0x26C0;
	}
	else
	{
		sub_90478_VGA_Blit320();
	}
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D41C1: using guessed type char x_BYTE_D41C1;
// E12F4: using guessed type int x_DWORD_E12F4;
// E12FC: using guessed type __int16 x_WORD_E12FC;
// E9C38: using guessed type int x_DWORD_E9C38_smalltit;
// 17D720: using guessed type int x_DWORD_17D720;
// 17D724: using guessed type __int16 x_WORD_17D724;
// 17D726: using guessed type __int16 x_WORD_17D726;
// 17DB3C: using guessed type int (/*__fastcall*/ *x_DWORD_17DB3C)(x_DWORD);
// 17DB48: using guessed type __int16 x_WORD_17DB48;
// 17DB4A: using guessed type __int16 x_WORD_17DB4A;
// 17DB50: using guessed type int x_DWORD_17DB50;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;

long testcount = 0;
//----- (00076160) --------------------------------------------------------
void sub_76160_play_intro(__int16 a1, __int16 a2, Bit8u* a3)//257160
{
	//fix
	memset(&x_DWORD_180628b_screen_buffer[320 * 200], 0, 320);
	//fix
	FILE* tempfile; // eax
	//__int16 v4; // ax

	x_WORD_E12FC = a2;
	x_WORD_D4004 = 0;
	x_WORD_17DB58 = 0;
	x_WORD_17DB60 = 0;
	x_DWORD_E12F4 = x_DWORD_180628b_screen_buffer;
	tempfile = sub_98817_open(printbuffer, 512);
	x_DWORD_17DB38_intro_file_handle = tempfile;
	if (tempfile >= 0)
	{
		sub_988A7_read(tempfile, unk_17DB40, 12);//ecx=12
		x_WORD_17DB46 = *(Bit16s*)&unk_17DB40[6];
		x_WORD_17DB48 = *(Bit16s*)&unk_17DB40[8];
		x_WORD_17DB4A = *(Bit16s*)&unk_17DB40[0xa];

		x_WORD_180744 = 0;
		x_WORD_180746 = 0;
		x_DWORD_E1300 += 12;
		x_BYTE_1806E4 = 0;
		x_WORD_17DB5A = 0;
		sub_473B0();//2283b0
		x_WORD_17DB5C = a1;
		do
		{
			if (x_WORD_17DB5A)
				break;
			if (x_WORD_17DB60 >= x_WORD_17DB46 - 1)//34eb60 a 34eb46
				break;
			sub_1B280_draw_intro_text(a3);//1fc280 - asi vykresleni textu
			/*v4 = */sub_75DB0();//256db0 - read header

			sub_75E70(/*v4*/);//256e70 - draw intro frame

			/*
			//debug
			int compsize;
			if (testcount > 0)
			{
				Bit8u origbyte = 0;
				Bit8u remakebyte = 0;
				compsize = compare_with_snapshot((char*)"0160-00256E70", x_DWORD_180628b_screen_buffer, 0x3aa0a4, 320 * 231, &origbyte, &remakebyte);
			}
			testcount++;
			//debug
			*/
			x_WORD_17DB60++;
		} while (x_BYTE_1806E4 != 1);
		sub_98882_close(x_DWORD_17DB38_intro_file_handle);
	}
}
// D4004: using guessed type __int16 x_WORD_D4004;
// E12F4: using guessed type int x_DWORD_E12F4;
// E12FC: using guessed type __int16 x_WORD_E12FC;
// E1300: using guessed type int x_DWORD_E1300;
// 17DB38: using guessed type int x_DWORD_17DB38_intro_file_handle;
// 17DB46: using guessed type __int16 x_WORD_17DB46;
// 17DB58: using guessed type __int16 x_WORD_17DB58;
// 17DB5A: using guessed type __int16 x_WORD_17DB5A;
// 17DB5C: using guessed type __int16 x_WORD_17DB5C;
// 17DB60: using guessed type __int16 x_WORD_17DB60;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 1806E4: using guessed type char x_BYTE_1806E4;
// 180744: using guessed type __int16 x_WORD_180744;
// 180746: using guessed type __int16 x_WORD_180746;

//----- (00076260) --------------------------------------------------------
void sub_76260_read_intro_pallette(Bit8u a1)
{
	Bit8u* v0; // ebx
	int v1; // esi
	unsigned int result; // eax
	unsigned __int16 v3; // di
	Bit16u v4; // [esp+0h] [ebp-Ch]
	Bit32s v5; // [esp+4h] [ebp-8h]
	unsigned __int8 v6; // [esp+8h] [ebp-4h]

	v0 = unk_17D838;
	v1 = 0;
	/*result = */sub_75D70((Bit8u*)&v4, 2u);
	if (v4 > 0u)
	{
		do
		{
			sub_75D70(&v6, 1u);
			v0 += 3 * v6;
			v5 = 0;
			/*result = */sub_75D70((Bit8u*)&v5, 1u);
			if (!v5)
				v5 = 256;
			for (v3 = 0; v3 < v5;v3++)//mybe read pallette
			{
				sub_75D70(v0, 3u);
				v0 += 3;
			}
			v1++;
		} while (v1 < v4);
	}
	//return result;
}

//----- (00076300) --------------------------------------------------------
void sub_76300()//257300
{
	Bit32s v0; // edi
	Bit16s result; // ax
	Bit8u* v2; // esi
	Bit8u* v3; // ebx
	Bit16u v4; // cx
	Bit16u v5; // [esp+0h] [ebp-1Ch]
	//int v6; // [esp+4h] [ebp-18h]
	Bit32s i; // [esp+8h] [ebp-14h]
	Bit16s v8; // [esp+Ch] [ebp-10h]
	Bit16s v9; // [esp+10h] [ebp-Ch]
	Bit8s v10; // [esp+14h] [ebp-8h]
	Bit8u v11; // [esp+18h] [ebp-4h]

	  /*
	  int v0; // edi
	__int16 result; // ax
	Bit8u* v2; // esi
	Bit8u* v3; // ebx
	unsigned __int16 v4; // cx
	Bit16s v5; // [esp+0h] [ebp-1Ch]
	//int v6; // [esp+4h] [ebp-18h]
	int i; // [esp+8h] [ebp-14h]
	Bit16s v8; // [esp+Ch] [ebp-10h]
	Bit16s v9; // [esp+10h] [ebp-Ch]
	Bit8s v10; // [esp+14h] [ebp-8h]
	Bit8s v11; // [esp+18h] [ebp-4h]
	*/

	v0 = 0;
	/*result = */sub_75D70((Bit8u*)&v5, 2u);
	v2 = x_DWORD_E12F4;//2b22f4
	if (v5 > 0u)
	{
		do
		{
			v3 = v2;
			sub_75D70((Bit8u*)&v9, 2u);
			if ((v9 & 0x8000) == 0)
			{
				//v6 = v9;
				for (i = 0; i < v9; i++)
				{
					sub_75D70((Bit8u*)&v11, 1u);
					v3 += v11;
					sub_75D70((Bit8u*)&v10, 1u);
					if (v10 >= 0)
					{
						if (v10 > 0)
						{
							sub_75D70((Bit8u*)v3, 2 * v10);
							v3 += 2 * v10;
						}
					}
					else
					{
						sub_75D70((Bit8u*)&v8, 2u);
						v4 = 0;
						while (abs(v10) > v4)
						{
							v3 += 2;
							v4++;
							*((Bit16s*)v3 - 1) = v8;
						}
					}
				}
			}
			else if (v9 & 0x4000)
			{
				v0--;
				v2 += x_WORD_17DB48 * (abs(v9) - 1);
			}
			else
			{
				*(x_BYTE *)(v2 + x_WORD_17DB48 - 1) = v9;
			}
			//result = x_WORD_17DB48;
			v0++;
			v2 += x_WORD_17DB48;
		} while (v0 < v5);
	}
	//return result;
}
// E12F4: using guessed type int x_DWORD_E12F4;
// 17DB48: using guessed type __int16 x_WORD_17DB48;

//----- (00076430) --------------------------------------------------------
int sub_76430()
{
	Bit8u* v0; // edi
	int result; // eax
	char *v2; // ebx
	unsigned __int16 v3; // si
	int v4; // eax
	int v5; // [esp+0h] [ebp-18h]
	unsigned __int16 v6; // [esp+4h] [ebp-14h]
	unsigned __int8 v7; // [esp+8h] [ebp-10h]
	char v8; // [esp+Ch] [ebp-Ch]
	unsigned __int8 v9; // [esp+10h] [ebp-8h]
	unsigned __int8 v10; // [esp+14h] [ebp-4h]

	sub_75D70((Bit8u*)&v6, 2u);
	v0 = x_WORD_17DB48 * v6 + x_DWORD_E12F4;
	sub_75D70((Bit8u*)&v6, 2u);
	v5 = 0;
	result = 0;
	if (v6 > 0u)
	{
		do
		{
			v2 = (char *)v0;
			v3 = 0;
			sub_75D70((Bit8u*)&v9, 1u);
			while (v3 < (signed int)v9)
			{
				sub_75D70((Bit8u*)&v7, 1u);
				v2 += v7;
				sub_75D70((Bit8u*)&v8, 1u);
				if (v8 >= 0)
				{
					if (v8 <= 0)
						goto LABEL_8;
					sub_75D70((Bit8u*)v2, v8);
					v4 = v8;
				}
				else
				{
					sub_75D70((Bit8u*)&v10, 1u);
					memset(v2, v10, abs(v8));
					v4 = abs(v8);
				}
				v2 += v4;
			LABEL_8:
				++v3;
			}
			++v5;
			v0 += (unsigned __int16)x_WORD_17DB48;
			result = v5;
		} while ((unsigned __int16)v5 < v6);
	}
	return result;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// E12F4: using guessed type int x_DWORD_E12F4;
// 17DB48: using guessed type __int16 x_WORD_17DB48;

//----- (00076540) --------------------------------------------------------
int sub_76540()//257540
{
	Bit8u* v0; // esi
	char *v1; // ebx
	unsigned __int16 v2; // di
	int result; // eax
	int v4; // [esp+0h] [ebp-Ch]
	unsigned __int8 v5; // [esp+4h] [ebp-8h]
	char v6; // [esp+8h] [ebp-4h]

	v0 = x_DWORD_E12F4;
	v4 = 0;
	while (1)
	{
		result = v4;
		if (v4 >= x_WORD_17DB4A)
			break;
		v1 = (char *)v0;
		v2 = 0;
		sub_75D70(0, 1u);
		while (v2 < x_WORD_17DB48)
		{
			sub_75D70((Bit8u*)&v6, 1u);
			if (v6 >= 0)
			{
				if (v6 > 0)
				{
					sub_75D70((Bit8u*)&v5, 1u);
					memset(v1, v5, v6);
				}
			}
			else
			{
				v6 = abs(v6);
				sub_75D70((Bit8u*)v1, v6);
			}
			v2 += v6;
			v1 += v6;
		}
		++v4;
		v0 += x_WORD_17DB48;
	}
	return result;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// E12F4: using guessed type int x_DWORD_E12F4;
// 17DB48: using guessed type __int16 x_WORD_17DB48;
// 17DB4A: using guessed type __int16 x_WORD_17DB4A;

//----- (000765FC) --------------------------------------------------------
void sub_765FC(__int16 a1, __int16 a2)
{
	x_WORD_E130E = a1;
	x_WORD_E1310 = a2;
}
// E130E: using guessed type __int16 x_WORD_E130E;
// E1310: using guessed type __int16 x_WORD_E1310;

//----- (00076619) --------------------------------------------------------
int sub_76619(int a1, int a2)
{
	x_DWORD_E1308 = a1;
	x_DWORD_E1304 = a2;
	while (1)
	{
		qmemcpy(&x_WORD_E1312, (void *)x_DWORD_E1308, 4u);
		x_DWORD_E1308 += 4;
		qmemcpy(&x_WORD_E130C, (void *)x_DWORD_E1308, sizeof(x_WORD_E130C));
		x_DWORD_E1308 += 2;
		if (x_WORD_E130C != -20718)
			break;
		sub_76752();
	}
	if (x_WORD_E130C != -3590)
		return 0;
	sub_766A4();
	return x_DWORD_E1308;
}
// E1304: using guessed type int x_DWORD_E1304;
// E1308: using guessed type int x_DWORD_E1308;
// E130C: using guessed type __int16 x_WORD_E130C;
// E1312: using guessed type __int16 x_WORD_E1312;

//----- (000766A4) --------------------------------------------------------
__int16 sub_766A4()
{
	__int16 result; // ax

	qmemcpy(&x_WORD_E1316, (void *)x_DWORD_E1308, sizeof(x_WORD_E1316));
	x_DWORD_E1308 += 2;
	x_DWORD_E1308 += 8;
	while (x_WORD_E1316)
	{
		--x_WORD_E1316;
		qmemcpy(&x_WORD_E1312, (void *)x_DWORD_E1308, 4u);
		x_DWORD_E1308 += 4;
		qmemcpy(&x_WORD_E130C, (void *)x_DWORD_E1308, sizeof(x_WORD_E130C));
		x_DWORD_E1308 += 2;
		switch (x_WORD_E130C)
		{
		case 7:
			result = sub_7678D();
			break;
		case 4:
			result = sub_7677C();
			break;
		case 15:
			result = sub_76840();
			break;
		default:
			result = sub_7677C();
			break;
		}
	}
	return result;
}
// E1308: using guessed type int x_DWORD_E1308;
// E130C: using guessed type __int16 x_WORD_E130C;
// E1312: using guessed type __int16 x_WORD_E1312;
// E1316: using guessed type __int16 x_WORD_E1316;

//----- (00076752) --------------------------------------------------------
__int16 sub_76752()
{
	__int16 result; // ax

	x_WORD_E130E = *(x_WORD *)(x_DWORD_E1308 + 2);
	result = *(x_WORD *)(x_DWORD_E1308 + 4);
	x_WORD_E1310 = *(x_WORD *)(x_DWORD_E1308 + 4);
	x_DWORD_E1308 += 6;
	return result;
}
// E1308: using guessed type int x_DWORD_E1308;
// E130E: using guessed type __int16 x_WORD_E130E;
// E1310: using guessed type __int16 x_WORD_E1310;

//----- (0007677C) --------------------------------------------------------
int sub_7677C()
{
	int result; // eax

	result = (unsigned __int16)x_WORD_E1312 - 6;
	x_DWORD_E1308 += result;
	return result;
}
// E1308: using guessed type int x_DWORD_E1308;
// E1312: using guessed type __int16 x_WORD_E1312;

//----- (0007678D) --------------------------------------------------------
__int16 sub_7678D()
{
	x_WORD *v0; // edi
	x_WORD *v1; // esi
	__int16 result; // ax
	x_BYTE *v3; // edi
	x_BYTE *v4; // esi
	char v5; // dl
	x_WORD *v6; // [esp-4h] [ebp-14h]
	x_WORD *v7; // [esp+0h] [ebp-10h]
	__int16 i; // [esp+6h] [ebp-Ah]
	__int16 v9; // [esp+8h] [ebp-8h]
	int v10; // [esp+Ch] [ebp-4h]

	v10 = (unsigned __int16)x_WORD_E130E;
	v0 = (x_WORD *)x_DWORD_E1304;
	v1 = (x_WORD *)(x_DWORD_E1308 + 2);
	v9 = *(x_WORD *)x_DWORD_E1308;
	do
	{
		while (1)
		{
			result = *v1;
			++v1;
			v7 = v0;
			if (result >= 0)
				goto LABEL_10;
			if (!(result & 0x4000))
				break;
			v0 = (x_WORD *)((char *)v0 + v10 * -result);
		}
		v6 = v0;
		v3 = (char *)v0 + v10 - 1;
		if (x_BYTE_E2A20 == 1)
		{
			if ((x_BYTE)result)
				*v3 = result;
		}
		else
		{
			*v3 = result;
		}
		v0 = v6;
	LABEL_10:
		for (i = result; i; i--)
		{
			while (1)
			{
				LOBYTE(result) = *(x_BYTE *)v1;
				v4 = (char *)v1 + 1;
				result = (unsigned __int8)result;
				v0 = (x_WORD *)((char *)v0 + (unsigned __int8)result);
				v5 = *v4;
				v1 = (x_WORD*)(v4 + 1);
				if (v5 > 0)
					break;
				result = *v1;
				++v1;
				do
				{
					*v0 = result;
					++v0;
					++v5;
				} while (v5);
				if (!--i)
					goto LABEL_18;
			}
			do
			{
				*v0 = *v1;
				++v1;
				++v0;
				--v5;
			} while (v5);
		}
	LABEL_18:
		v0 = (x_WORD *)((char *)v7 + v10);
		--v9;
	} while (v9);
	x_DWORD_E1308 = (int)v1;
	return result;
}
// E1304: using guessed type int x_DWORD_E1304;
// E1308: using guessed type int x_DWORD_E1308;
// E130E: using guessed type __int16 x_WORD_E130E;
// E1310: using guessed type __int16 x_WORD_E1310;
// E1312: using guessed type __int16 x_WORD_E1312;
// E2A20: using guessed type char x_BYTE_E2A20;

//----- (00076840) --------------------------------------------------------
int sub_76840()
{
	x_BYTE *v0; // edi
	char *v1; // esi
	__int16 v2; // bx
	__int16 v3; // cx
	unsigned __int8 v4; // dl
	__int16 v5; // ax
	char v6; // dh
	char v7; // dh
	int result; // eax
	int v9; // [esp-8h] [ebp-Ch]
	int v10; // [esp-4h] [ebp-8h]
	__int16 v11; // [esp+2h] [ebp-2h]

	v11 = x_WORD_E130E;
	v0 = (x_BYTE *)x_DWORD_E1304;
	v1 = (char *)x_DWORD_E1308;
	v10 = (unsigned __int16)x_WORD_E1312 - 6;
	v9 = x_DWORD_E1308;
	v2 = x_WORD_E1310;
	do
	{
		++v1;
		v3 = v11;
		do
		{
			v4 = *v1++;
			if ((char)v4 > 0)
			{
				v3 -= v4;
			}
			else
			{
				HIBYTE(v5) = -1;
				LOBYTE(v5) = v4;
				v3 += v5;
			}
			if ((char)v4 > 0)
			{
				v7 = *v1++;
				do
				{
					if (x_BYTE_E2A20 == 1)
					{
						if (v7)
							*v0 = v7;
					}
					else
					{
						*v0 = v7;
					}
					++v0;
					--v4;
				} while (v4);
			}
			else
			{
				do
				{
					v6 = *v1++;
					if (x_BYTE_E2A20 == 1)
					{
						if (v6)
							*v0 = v6;
					}
					else
					{
						*v0 = v6;
					}
					++v0;
					++v4;
				} while (v4);
			}
		} while (v3);
		--v2;
	} while (v2);
	result = v10;
	x_DWORD_E1308 = v10 + v9;
	return result;
}
// E1304: using guessed type int x_DWORD_E1304;
// E1308: using guessed type int x_DWORD_E1308;
// E130E: using guessed type __int16 x_WORD_E130E;
// E1310: using guessed type __int16 x_WORD_E1310;
// E1312: using guessed type __int16 x_WORD_E1312;
// E2A20: using guessed type char x_BYTE_E2A20;

//----- (00076930) --------------------------------------------------------
signed int /*__fastcall*/ sub_76930_menus_and_intros(int a2, Bit16u a3)//257930
{
	//int v3; // eax
	int v4; // edx

	//fix it
	v4 = 0;
	//fix it

	//x_BYTE_E29DE = x_WORD_180660_VGA_type_resolution;//1 -351660
	x_BYTE_E29DF_skip_screen = x_BYTE_D41AD_skip_screen;
	x_WORD_E29DC = 0;
	if (x_BYTE_D41AD_skip_screen == 1 || x_WORD_E29D8)
	{
		sub_82670();
		sub_7AC00_load_and_set_graphics_and_pallette();
	}
	if (x_BYTE_D41AD_skip_screen == 1)
	{
		sub_76A40_lang_setting();
		x_WORD_E29D8 = 4;
	}
	memset(&x_DWORD_17DE38, 0, 613);
	x_DWORD_17DEE0_filedesc = NULL;
	sub_7BEC0();//25CEC0 // fix this structure
	sub_6EDB0_set_mouse_position_by_res();//24FDB0
	/*v3 = */sub_81DB0_read_config();//262DB0
	do
	{
		//x_WORD_E29D8 - prvni pruchod -0
		//v3 = x_WORD_E29D8;//2b39d8
		switch (x_WORD_E29D8)
		{
		case 0:
			/*v3 = */sub_76A40_lang_setting();//257A40 //asi inicializace + rovnou i nastaveni jazyka
			break;
		case 1:
			sub_76CF0();//257cf0 nastavi x_WORD_E29D8 na 3
			break;
		case 2:
			/*v3 = */_wcpp_1_unwind_leave__131(/*v3*/);//257d00 asi konec
			break;
		case 3:
			sub_76D10_intros(0);//257d10 intro		  
			x_WORD_E29D8 = 4;
			break;
		case 4:
			/*v3 = */sub_76FA0_main_menu(/*v3,*/ v4, a3);//257fa0 main menu loop
			break;
		case 5:
			x_WORD_E29DC = 1;
			break;
		case 12:
			sub_779E0_lang_setting_dialog(0);//2589e0 asi herni smycka
			break;
		default:
			break;
		}
	} while (!x_WORD_E29DC);
	sub_7ADE0(x_WORD_180660_VGA_type_resolution);//zase nejaka inicializace
	if (x_BYTE_E29E1)
		x_BYTE_E29E1 = 0;
	return sub_81DB0_read_config();//neco
}
// 76D00: using guessed type int /*__fastcall*/ _wcpp_1_unwind_leave__131(x_DWORD);
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D41AD: using guessed type char x_BYTE_D41AD_skip_screen;
// E29D8: using guessed type __int16 x_WORD_E29D8;
// E29DC: using guessed type __int16 x_WORD_E29DC;
// E29DE: using guessed type char x_BYTE_E29DE;
// E29E1: using guessed type char x_BYTE_E29E1;
// 17DE38: using guessed type int x_DWORD_17DE38;
// 17DEE0: using guessed type int x_DWORD_17DEE0_filedesc;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00076A40) --------------------------------------------------------
void sub_76A40_lang_setting()//257A40
{
	FILE* configdatfile; // ebx
	//int v1; // edi
	//Bit16s index; // si
	FILE* langfile; // eax
	//FILE* v4; // ebx
	//FILE* v5; // edi
	Bit32u filelenght; // esi
	int result; // eax
	//char v8; // [esp+0h] [ebp-42h]
	//char v9; // [esp+50h] [ebp+Eh]
	//char v10; // [esp+A0h] [ebp+5Eh]
	Bit8u v11[100]; // [esp+A4h] [ebp+62h]
	//int v12; // [esp+B4h] [ebp+72h]
	//__int16 v13; // [esp+BEh] [ebp+7Ch]
	Bit32s configdword1; // [esp+C0h] [ebp+7Eh]

	//fix
	//v10 = 0;
	//fix

	configdword1 = 0;
	memset(printbuffer, 0, 80);
	memset(&x_DWORD_17DE38, 0, 613);
	x_DWORD_17DEE0_filedesc = NULL;
	/*memset(&v10, 0, 32);fix it*/
	sprintf_s(printbuffer, 512, "%c%s", x_D41A0_BYTEARRAY_4_struct.harddisk_number, ":/NETHERW/CONFIG.DAT");
	configdatfile = sub_98817_open(printbuffer, 512);
	if (configdatfile == NULL)//config is not found
	{
		sub_7AC00_load_and_set_graphics_and_pallette();//25BC00 //zmena pomeru obrazovky
		sub_779E0_lang_setting_dialog(0);//2589E0 //nastaveni jazyka
		sub_7ADE0(1);//25BDE0x_D41A0_BYTEARRAY_4_struct.setting_216
	}
	else
	{
		sub_988A7_read(configdatfile, (Bit8u*)&configdword1, 4);//prvni dword
		if (configdword1 == -9)
		{
			sub_988A7_read(configdatfile, (Bit8u*)&v11, 28);

			x_D41A0_BYTEARRAY_4_struct.byteindex_4 = *(Bit16u*)&v11[0];
			x_D41A0_BYTEARRAY_4_struct.dwordindex_6 = *(Bit16u*)&v11[2];
			x_D41A0_BYTEARRAY_4_struct.dwordindex_8 = *(Bit16u*)&v11[4];
			x_D41A0_BYTEARRAY_4_struct.byteindex_A = *(Bit16u*)&v11[6];
			x_D41A0_BYTEARRAY_4_struct.dwordindex_12 = *(Bit16u*)&v11[8];

			x_BYTE_EB39E_keys[0] = *(Bit16u*)&v11[18];
			x_BYTE_EB39E_keys[1] = *(Bit16u*)&v11[19];
			x_BYTE_EB39E_keys[2] = *(Bit16u*)&v11[20];
			x_BYTE_EB39E_keys[3] = *(Bit16u*)&v11[21];
			x_BYTE_EB39E_keys[4] = *(Bit16u*)&v11[22];
			x_BYTE_EB39E_keys[5] = *(Bit16u*)&v11[23];
			x_BYTE_EB39E_keys[6] = *(Bit16u*)&v11[24];
			x_BYTE_EB39E_keys[7] = *(Bit16u*)&v11[25];
			x_BYTE_EB39E_keys[8] = *(Bit16u*)&v11[26];
			x_BYTE_EB39E_keys[9] = *(Bit16u*)&v11[27];

			sub_98882_close(configdatfile);
			sub_8E470_sound_proc17_volume(x_D41A0_BYTEARRAY_4_struct.dwordindex_6);
			sub_8E410_sound_proc16_xmidivolume(x_D41A0_BYTEARRAY_4_struct.dwordindex_8);

			sprintf_s(printbuffer, 512, "%c%s/L%d.txt", x_D41A0_BYTEARRAY_4_struct.harddisk_number, ":/NETHERW/LANGUAGE", x_D41A0_BYTEARRAY_4_struct.byteindex_4);
			for (Bit16s i = 0;i < 2;i++)
				//i = 0;
				//while (i < 2 )
			{
				x_D41A0_BYTEARRAY_4_struct.byteindex_179 = x_D41A0_BYTEARRAY_4_struct.byteindex_4;
				if (x_BYTE_E29E0 || x_DWORD_D41BC_langbuffer)
					sub_83E80_sound_proc_99(x_DWORD_D41BC_langbuffer);
				langfile = sub_98817_open(printbuffer, 512);
				//v4 = v3;
				//v5 = v3;
				if (langfile != NULL)
				{
					filelenght = x_filelength(langfile) - 4785;
					x_DWORD_D41BC_langbuffer = (Bit8u*)sub_83CD0_malloc2(filelenght);
					if (x_DWORD_D41BC_langbuffer)
					{
						sub_9891E_seek(langfile, 4785, 0);
						sub_988A7_read(langfile, (Bit8u*)x_DWORD_D41BC_langbuffer, filelenght);
					}
					sub_98882_close(langfile);
					sub_5B870(x_DWORD_D41BC_langbuffer, x_DWORD_E9C4C_langindexbuffer, 471);
					break;
				}
				//i++;
				sprintf_s(printbuffer, 512, "LANGUAGE/L%d.txt", x_D41A0_BYTEARRAY_4_struct.byteindex_179);
			}
		}
		else
		{
			sub_98882_close(configdatfile);
			sub_7AC00_load_and_set_graphics_and_pallette();
			sub_779E0_lang_setting_dialog(0);
			sub_7ADE0(1);
		}
	}
	//result = (uint8)x_D41A0_BYTEARRAY_4;
	if (x_D41A0_BYTEARRAY_4_struct.byteindex_179 != 2 || !x_BYTE_E3798_sound_active2)
		x_BYTE_D41C0 = 1;
	x_WORD_E29D8 = 1;
	//return result;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// 988DA: using guessed type x_DWORD filelength(x_DWORD);
// D41A4: using guessed type int x_DWORD_D41A4;
// D41BC: using guessed type int x_DWORD_D41BC_langbuffer;
// D41C0: using guessed type char x_BYTE_D41C0;
// E29D8: using guessed type __int16 x_WORD_E29D8;
// E29E0: using guessed type char x_BYTE_E29E0;
// E3798: using guessed type char x_BYTE_E3798_sound_active2;
// EB39E: using guessed type char x_BYTE_EB39E_keys;
// 17DE38: using guessed type int x_DWORD_17DE38;
// 17DEE0: using guessed type int x_DWORD_17DEE0_filedesc;

//----- (00076CF0) --------------------------------------------------------
void sub_76CF0()
{
	x_WORD_E29D8 = 3;
}
// E29D8: using guessed type __int16 x_WORD_E29D8;

//----- (00076D10) --------------------------------------------------------
void sub_76D10_intros(char a1)//257d10
{
	//int v1; // eax
	signed int v2; // eax
	signed int v3; // eax

	//x_DWORD_17DE48c = x_D41A0_BYTEARRAY_4_0xE2_heapbuffer;
	x_DWORD_17DE54 = &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x49ADB];// 301787;
	x_DWORD_17DEC0 = &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4B52F];//308527;
	x_DWORD_17DEC4 = &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4BB85 + 10];
	sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x49ADB], 0x164FCD, 0x35C);
	sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DEC0, 0x165329, 0x224);
	sub_7AA70_load_and_decompres_dat_file(0, 0, 0, 0);
	if (x_WORD_180660_VGA_type_resolution & 1)
		sub_98709_create_index_dattab_power(x_DWORD_17DEC0, x_DWORD_17DEC4, x_DWORD_17DE54, xy_DWORD_17DEC0_spritestr);
	else
		sub_9874D_create_index_dattab(x_DWORD_17DEC0, x_DWORD_17DEC4, x_DWORD_17DE54, xy_DWORD_17DEC0_spritestr);

	sub_2EB40();
	if (x_BYTE_E3798_sound_active2 && x_D41A0_BYTEARRAY_4_struct.byteindex_179 == 2)
	{
		x_BYTE_D41C1 = 0;
		x_BYTE_D41C0 = 0;
	}
	else
	{
		x_BYTE_D41C0 = 1;
		x_BYTE_D41C1 = 1;
	}
	sub_8CD27_set_cursor(*filearray_2aa18c[0].posistruct);
	sprintf_s(printbuffer, 512, "intro\\intro.dat");
	switch (a1)
	{
	case 0:
#ifndef debug_hide_graphics
		sub_83850_show_welcome_screen();//frog logo and wait
#endif
		sub_76160_play_intro(1, 1, unk_E17CC);//257160 intro .. 2b27cc
		/*v1 = */sub_2EB40();
		x_BYTE_D41C1 = 0;
		x_BYTE_D41C0 = 0;
		while (sub_9A10A_check_keyboard(/*v1*/))
		{
			x_BYTE_1806E4 = 0;
			/*v1 = */sub_7A060_get_mouse_and_keyboard_events();
		}
		j___delay(50);
		sprintf_s(printbuffer, 512, "intro\\intro2.dat");
		goto LABEL_17;
	case 1:
		sub_76160_play_intro(1, 1, unk_E17CC);
		break;
	case 2:
		x_BYTE_1806E4 = 0;
		x_BYTE_D41C1 = 0;
		x_BYTE_D41C0 = 0;
		sprintf_s(printbuffer, 512, "intro\\intro2.dat");
	LABEL_17:
		sub_76160_play_intro(1, 1, unk_E17CC + 0x160);//E192C
		break;
	}
	sub_90B27_VGA_pal_fadein_fadeout(0, 0x10u, 0);
	sub_8D8F0_sound_proc3_endsample();
	sub_8E020_sound_proc14_stopsequence();//?ac_sound_stop_music
	sub_7B5D0();
	v2 = 0;
	x_WORD_E29D8 = 4;
	x_BYTE_D41C0 = 0;
	x_BYTE_D41C1 = 0;
	v3 = sub_9A10A_check_keyboard(/*v2*/);
	if (v3)
		/*v3 = */sub_7A060_get_mouse_and_keyboard_events();
	x_BYTE_17DF11_last_key_status = 0;
	x_BYTE_17DF10_get_key_scancode = 0;
	if (!a1)
		/*v3 = */sub_7AC00_load_and_set_graphics_and_pallette();
	//return v3;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// 9A122: using guessed type x_DWORD j___delay(x_DWORD);
// D41A4: using guessed type int x_DWORD_D41A4;
// D41C0: using guessed type char x_BYTE_D41C0;
// D41C1: using guessed type char x_BYTE_D41C1;
// E29D8: using guessed type __int16 x_WORD_E29D8;
// E3798: using guessed type char x_BYTE_E3798_sound_active2;
// EB394: using guessed type int **filearray_2aa18c[0];
// 17DE48: using guessed type int x_DWORD_17DE48;
// 17DE54: using guessed type int (int)x_DWORD_17DE54;
// 17DEC0: using guessed type int (int)x_DWORD_17DEC0;
// 17DEC4: using guessed type int (int)x_DWORD_17DEC4;
// 17DF10: using guessed type char x_BYTE_17DF10_get_key_scancode;
// 17DF11: using guessed type char x_BYTE_17DF11_last_key_status;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;
// 1806E4: using guessed type char x_BYTE_1806E4;

//----- (00076F40) --------------------------------------------------------
//#error "76F96: positive sp value has been found (funcsize=32)"

//----- (00076FA0) --------------------------------------------------------
void /*__fastcall*/ sub_76FA0_main_menu(/*int a1, */int a2, Bit16u a3x)//257fa0
{
	int v3; // eax
	__int16 v4; // dx
	int result; // eax
	int v6; // eax
	int v7; // edx
	int v8; // edx
	int v9; // edx
	unsigned __int16 v10; // di
	//int v11; // eax
	unsigned __int16 v12; // si
	int v13; // eax
	//int v14; // edx
	Bit8u* v15; // esi
	int v16; // edx
	//int v17; // eax
	char v18; // dh
	//__int16 v19; // ax
	int v20; // edx
	//Bit8u* v21; // eax
	int v22; // edx
	int v23; // edx
	//__int16 v24; // [esp+0h] [ebp-24h]
	//__int16 v25; // [esp+Ch] [ebp-18h]
	int v26; // [esp+1Ch] [ebp-8h]
	int v27; // [esp+20h] [ebp-4h]

	//Bit16s a3t;

	//fix it
	v4 = 0;
	//fix it

	//fix it
	v7 = 0;
	v8 = 0;
	v9 = 0;
	v16 = 0;
	v20 = 0;
	v22 = 0;
	v23 = 0;
	//fix it

	//memset(x_DWORD_180628b_screen_buffer, 0, 640*480);//fixed

	/*memset(&v24, 0, 28);
	v24 = 0x3301;
	v25 = 0;
	int386(0x21, (REGS*)&v24, (REGS*)&v24);//get set ctrl break*/
	sub_86860(x_WORD_1803EC);//267860
	sub_84300_load_sound(0);//265300
	memset(&x_DWORD_17DBB8, 0, 16);
	x_BYTE_17DBC6 = 2;
	x_WORD_17DF04 = -1;
	x_DWORD_17DE44 = x_DWORD_E9C38_smalltit;
	sub_6EDB0_set_mouse_position_by_res();
	sub_8E020_sound_proc14_stopsequence();//26f020
	sub_8E160_sound_proc15_startsequence(4, 0x7Fu);//26f160
	sub_75420();//256420
	v3 = dos_getvect(9);
	a3x = 256;
	x_WORD_17DE26 = v4;
	x_DWORD_17DE22 = v3;
	//dos_setvect(9, sub_76F40, __CS__);
	if (x_BYTE_E29E1 || x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10 || (sub_77350_new_game_dialog(0), !x_WORD_E29DC))
	{
		x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 &= 0xEFu;
		sub_7A110_load_hscreen(x_WORD_180660_VGA_type_resolution, 4);
		sub_7B5A0_disable_enable();
		sub_8CD27_set_cursor(xy_DWORD_17DED4_spritestr[39]);
		//v6 = x_D41A0_BYTEARRAY_4;
		x_BYTE_17DF13 = x_D41A0_BYTEARRAY_4_struct.byteindex_A;
		v6 = x_BYTE_17DF13;
		x_DWORD_17DBB8[0] = j___clock();
		v26 = j___clock();
		v10 = x_DWORD_17DEE4_mouse_positionx;
		//v11 = x_BYTE_17DF10_get_key_scancode;
		v12 = x_DWORD_17DEE4_mouse_positiony;
		v27 = x_BYTE_17DF10_get_key_scancode;
		while (!x_WORD_E29DC)
		{
			v13 = j___clock();
			if ((v10 == x_DWORD_17DEE4_mouse_positionx) && (v12 == x_DWORD_17DEE4_mouse_positiony) && (x_BYTE_17DF10_get_key_scancode == v27))
			{
				if ((v13 - v26) / 0x64u > 0x3C)//after any time run intro
				{
					v15 = x_DWORD_E9C38_smalltit;
					x_DWORD_E9C38_smalltit = x_DWORD_17DE44;
					sub_83250_play_intros(SBYTE1(a3x));
					x_DWORD_E9C38_smalltit = v15;
					BYTE1(a3x) = (BYTE1(a3x) == 1) + 1;
					v12 = x_DWORD_17DEE4_mouse_positiony;
					v10 = x_DWORD_17DEE4_mouse_positionx;
					x_BYTE_17DF10_get_key_scancode = 0;
					v27 = 0;
					v26 = j___clock();
					sub_8E020_sound_proc14_stopsequence();
					LOBYTE(a3x) = 0;
					sub_8E160_sound_proc15_startsequence(4, 0x7Fu);
				}
			}
			else
			{
				v12 = x_DWORD_17DEE4_mouse_positiony;
				v10 = x_DWORD_17DEE4_mouse_positionx;
				v27 = x_BYTE_17DF10_get_key_scancode;
				v26 = j___clock();
			}
			if (x_BYTE_17DF10_get_key_scancode == 59)
			{
				//v17 = x_D41A0_BYTEARRAY_4;
				v18 = x_D41A0_BYTEARRAY_4_struct.byteindex_A;
				x_D41A0_BYTEARRAY_4_struct.byteindex_A = v18 != 1;
				x_BYTE_17DF13 = v18 != 1;
				//*(x_BYTE *)(v17 + 38402) = 1;
				x_D41A0_BYTEARRAY_4_struct.setting_38402 = 1;
			}
			if (x_WORD_180660_VGA_type_resolution & 1)
				sub_9A128_copy_screen_320(x_DWORD_E9C38_smalltit, x_DWORD_180628b_screen_buffer, 0xC8u);
			else
				sub_9A144_copy_screen_640(x_DWORD_E9C38_smalltit, x_DWORD_180628b_screen_buffer, 0x1E0u);

			/*v19 = */sub_7C120_draw_bitmap_640(185, 232, xy_DWORD_17DED4_spritestr[66]);//adress 25827a
			//ax,ebx,a3
			//6038,100,4?
			/*v21 = */sub_7AB00_draw_menu_animations(/*v19,*/ v20, (Bit16s*)a3x, 4u);//25bb00
			if (sub_7B250(/*(int)v21, v22*/))//25c250
			{
				v12 = x_DWORD_17DEE4_mouse_positiony;
				v10 = x_DWORD_17DEE4_mouse_positionx;
				LOBYTE(a3x) = 0;
				v27 = x_BYTE_17DF10_get_key_scancode;
				v26 = j___clock();
			}
			if (LOBYTE(a3x))
			{
				if (x_WORD_180660_VGA_type_resolution & 1)
					sub_90478_VGA_Blit320();
				else
					sub_75200_VGA_Blit640(480);
			}
			else
			{
				LOBYTE(a3x) = 1;
				//34ee38 20 0
				sub_90B27_VGA_pal_fadein_fadeout(x_DWORD_17DE38, 0x20u, 0);//tady
			}
			/*v11 = */sub_7A060_get_mouse_and_keyboard_events();
		}
		sub_41BC0();
		x_D41A0_BYTEARRAY_0[8592] = 0;
		//dos_setvect(9, x_DWORD_17DE22, x_WORD_17DE26);
		sub_753D0();
		//result = (int)x_DWORD_17DE44;
		x_DWORD_E9C38_smalltit = x_DWORD_17DE44;
	}
	else
	{
		sub_41BC0();
		x_D41A0_BYTEARRAY_0[8592] = 0;
		//dos_setvect(9, x_DWORD_17DE22, x_WORD_17DE26);
		/*result = */sub_753D0();
	}
	//  return result;
}
// 76F40: using guessed type int sub_76F40();
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 98786: using guessed type int /*__fastcall*/ j___clock(x_DWORD, x_DWORD, x_DWORD);
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// 99BA7: using guessed type x_DWORD dos_getvect(x_DWORD);
// 99BDB: using guessed type x_DWORD dos_setvect(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// E29DC: using guessed type __int16 x_WORD_E29DC;
// E29E1: using guessed type char x_BYTE_E29E1;
// E9C38: using guessed type int x_DWORD_E9C38_smalltit;
// 17DBB8: using guessed type int x_DWORD_17DBB8;
// 17DBC6: using guessed type char x_BYTE_17DBC6;
// 17DE22: using guessed type int x_DWORD_17DE22;
// 17DE26: using guessed type __int16 x_WORD_17DE26;
// 17DE38: using guessed type int x_DWORD_17DE38;
// 17DE44: using guessed type int x_DWORD_17DE44;
// 17DED4: using guessed type int (int)x_DWORD_17DED4;
// 17DEE4: using guessed type int x_DWORD_17DEE4_mouse_position;
// 17DF04: using guessed type __int16 x_WORD_17DF04;
// 17DF10: using guessed type char x_BYTE_17DF10_get_key_scancode;
// 17DF13: using guessed type char x_BYTE_17DF13;
// 1803EC: using guessed type __int16 x_WORD_1803EC;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00077350) --------------------------------------------------------
char sub_77350_new_game_dialog(Bit8u* a1)//258350
{
	unsigned __int16 v1; // bx
	char v2; // cl
	char result; // al
	unsigned __int8 v4; // al
	unsigned __int8 v5; // al
	//int v6; // eax
	char v7; // bl

	v1 = 0;
	v2 = x_D41A0_BYTEARRAY_0[2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 11232];
	x_WORD_E29D6_not_movex = 0;
	if (v2 & 2 && x_D41A0_BYTEARRAY_4_struct.levelnumber_43 == 24)
		sub_833C0();
	memset((void*)&unk_17DBA8str, 0, 16);
	unk_17DBA8str.x_BYTE_17DBB6 = 2;
	if (x_BYTE_D419C_level_num <= -1)
	{
		x_BYTE_17E09D = 0;
		x_BYTE_17E083 = 16;
		x_WORD_17E06E = 480;
		x_WORD_17E080 = 13;
		x_BYTE_17E09C = 0;
		x_BYTE_17E082 = 13;
		x_WORD_17E06C = 0;
		memset((void*)&x_DWORD_17DB70str, 0, 56);
		if (x_D41A0_BYTEARRAY_0[2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 11232] & 2)
			x_DWORD_17DB70str.x_BYTE_17DB8F = 4;
		else
			x_DWORD_17DB70str.x_BYTE_17DB8F = 1;
		sub_7A110_load_hscreen(x_WORD_180660_VGA_type_resolution, 6);//here init sprites
		sub_8CD27_set_cursor(*filearray_2aa18c[0].posistruct);
		sub_7B5A0_disable_enable();
		sub_90B27_VGA_pal_fadein_fadeout(0, 0x10u, 0);
		if (x_WORD_180660_VGA_type_resolution & 1)
		{
			v4 = sub_5BE80_test_pallette((unsigned __int8 *)x_DWORD_17DE38, 0, 0, 0);
			sub_72883_clear_text_mode((void *)x_DWORD_180628b_screen_buffer, 0xC8u, v4);
		}
		else
		{
			v5 = sub_5BE80_test_pallette((unsigned __int8 *)x_DWORD_17DE38, 0, 0, 0);
			sub_728A9_clear_graphics_mode((void *)x_DWORD_180628b_screen_buffer, 0x1E0u, v5);
		}
		if (x_WORD_180660_VGA_type_resolution & 1)
			sub_90478_VGA_Blit320();
		else
			sub_75200_VGA_Blit640(480);
		sub_41A90_VGA_pallette_install((unsigned __int8 *)x_DWORD_17DE38);
		sub_7DD70();
		x_WORD_17DEEC = 0;
		sub_6EDB0_set_mouse_position_by_res();
		sub_8CD27_set_cursor(xy_DWORD_17DED4_spritestr[239]);
		x_DWORD_17DB70str.x_WORD_17DB8A = x_D41A0_BYTEARRAY_4_struct.levelnumber_43;
		while (!v1)
		{
			if (x_BYTE_17DF10_get_key_scancode == 59)
			{
				v7 = x_D41A0_BYTEARRAY_4_struct.byteindex_A;
				x_D41A0_BYTEARRAY_4_struct.byteindex_A = v7 != 1;
				x_BYTE_17DF13 = v7 != 1;
				x_D41A0_BYTEARRAY_4_struct.setting_38402 = 1;
			}
			v1 = sub_7EAE0_new_game_draw(
				&x_DWORD_17DB70str.unk_17DB76_posx,
				&x_DWORD_17DB70str.unk_17DB78_posy,
				&x_DWORD_17DB70str.unk_17DB7E,
				&x_DWORD_17DB70str.unk_17DB80,
				(char*)&x_DWORD_17DB70str.x_BYTE_17DB8F,
				&x_DWORD_17DB70str.unk_17DB90);
			if (x_WORD_180660_VGA_type_resolution & 1)
				sub_90478_VGA_Blit320();
			else
				sub_75200_VGA_Blit640(480);
			sub_7A060_get_mouse_and_keyboard_events();
		}
		sub_86860(x_WORD_1803EC);
		x_D41A0_BYTEARRAY_0[2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 11232] = 0;
		sub_8D8F0_sound_proc3_endsample();
		x_WORD_E29D6_not_movex = 0;
		if (v1 >= 1u)
		{
			if (v1 <= 1u)
			{
				x_WORD_E29DC = 1;
				if (a1)
					*(x_DWORD *)(a1 + 4) = 0;
			}
			else if (v1 == 2 && a1)
			{
				*(x_DWORD *)(a1 + 4) = 1;
			}
		}
		sub_8CD27_set_cursor(*filearray_2aa18c[0].posistruct);
		sub_90B27_VGA_pal_fadein_fadeout(0, 0x10u, 0);
		result = 1;
	}
	else
	{
		x_WORD_E29DC = 1;
		x_D41A0_BYTEARRAY_4_struct.levelnumber_43 = x_BYTE_D419C_level_num;
		if (a1)
			*(x_DWORD *)(a1 + 4) = 0;
		result = 1;
	}
	return result;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D419C: using guessed type char x_BYTE_D419C_level_num;
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// E29D6: using guessed type __int16 x_WORD_E29D6;
// E29DC: using guessed type __int16 x_WORD_E29DC;
// EB394: using guessed type int **filearray_2aa18c[0];
// 17DB70: using guessed type int x_DWORD_17DB70;
// 17DB8A: using guessed type __int16 x_WORD_17DB8A;
// 17DB8F: using guessed type char x_BYTE_17DB8F;
// 17DBB6: using guessed type char x_BYTE_17DBB6;
// 17DE38: using guessed type int x_DWORD_17DE38;
// 17DED4: using guessed type int (int)x_DWORD_17DED4;
// 17DEEC: using guessed type __int16 x_WORD_17DEEC;
// 17DF10: using guessed type char x_BYTE_17DF10_get_key_scancode;
// 17DF13: using guessed type char x_BYTE_17DF13;
// 17E06C: using guessed type __int16 x_WORD_17E06C;
// 17E06E: using guessed type __int16 x_WORD_17E06E;
// 17E080: using guessed type __int16 x_WORD_17E080;
// 17E082: using guessed type char x_BYTE_17E082;
// 17E083: using guessed type char x_BYTE_17E083;
// 17E09C: using guessed type char x_BYTE_17E09C;
// 17E09D: using guessed type char x_BYTE_17E09D;
// 1803EC: using guessed type __int16 x_WORD_1803EC;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00077680) --------------------------------------------------------
char /*__fastcall*/ sub_77680(int a1, int a2, signed __int16 *a3)//258680
{
	char result; // al
	int v4; // eax
	int v5; // edx
	int v6; // eax
	__int16 v7; // dx
	char *v8; // esi
	//char v9; // [esp+0h] [ebp-4h]
	char v10; // [esp+50h] [ebp+4Ch]
	char v11; // [esp+60h] [ebp+5Ch]
	int v12; // [esp+74h] [ebp+70h]
	int v13; // [esp+78h] [ebp+74h]
	__int16 v14; // [esp+80h] [ebp+7Ch]
	char v15; // [esp+82h] [ebp+7Eh]

	//fix it
	v5 = 0;
	v14 = 0;
	//fix it

	x_WORD_E2094 = (unsigned __int8)x_BYTE_E2096;
	memset(printbuffer, 0, 80);
	memset(&v12, 0, 16);
	v15 = 2;
	sprintf_s(printbuffer, 512, "NETH%d", (unsigned __int16)x_WORD_17DEFA + 20);
	LOWORD(a3) = 0;
	x_WORD_17DEFC = sub_7308F(a3, (Bit8u*)printbuffer, 8);
	if (x_WORD_17DEFC == -1)
	{
		sub_8CD27_set_cursor(xy_DWORD_17DED4_spritestr[39]);
		result = 0;
	}
	else
	{
		sub_7A110_load_hscreen(x_WORD_180660_VGA_type_resolution, 7);
		x_WORD_17DEFE = 0;
		sub_8CD27_set_cursor(*filearray_2aa18c[0].posistruct);
		x_DWORD_17DEDC = 0;
		x_WORD_17DEEE = 0;
		sub_7B5A0_disable_enable();
		memset(x_BYTE_17DE68, 0, 88);
		memset(sub_7308F, 0, 80);
		x_WORD_17DEF6 = 5;
		x_WORD_17DEEC = 0;
		sub_6EDB0_set_mouse_position_by_res();
		x_DWORD_17DEE4_mouse_positionx = 0x140;
		x_DWORD_17DEE4_mouse_positiony = 0xf0;//test and fix it

		if (x_D41A0_BYTEARRAY_4_struct.levelnumber_43 >= 0x32u)
			x_BYTE_17DE72[11 * x_WORD_17DEFC] = *(x_BYTE *)(x_D41A0_BYTEARRAY_4_struct.levelnumber_43);
		else
			x_BYTE_17DE72[11 * x_WORD_17DEFC] = 50;
		x_BYTE_17DE71[11 * x_WORD_17DEFC] = 2;
		x_WORD_17DEEE = 0;
		while (!BYTE1(a3))
		{
			if (x_BYTE_17DF10_get_key_scancode == 59)
			{
				v4 = (uint8)x_D41A0_BYTEARRAY_4;
				x_D41A0_BYTEARRAY_4_struct.byteindex_A = x_D41A0_BYTEARRAY_4_struct.byteindex_A != 1;
				*(x_BYTE *)(v4 + 38402) = 1;
			}
			BYTE1(a3) = sub_7C390();
			v6 = (uint8)x_D41A0_BYTEARRAY_4;
			if (x_D41A0_BYTEARRAY_4_struct.byteindex_A == 1)
			{
				LOBYTE(v6) = v15;
				if (v15 == 2)
				{
					v13 = j___clock();
					if ((v13 - v12) / 0x64u > 1)
					{
						v7 = unk_E2516[46 + 9 * (signed __int16)(v14++ + 1)];
						if (!v7)
							v14 = 0;
						v12 = v13;
					}
					memset(&v10, 0, 36);
					v8 = (char *)&unk_E2516[45 + 9 * v14];
					qmemcpy(&v10, v8, 0x10u);
					qmemcpy(&v11, v8 + 16, 2u);
					sub_7E840_draw_textbox_with_line((Bit16u*)&v10, 21, 27);
				}
				else if (v15 == 3)
				{
					v13 = j___clock();
					if ((v13 - v12) / 0x64u > 1)
						v15 = 2;
				}
			}
			if (!(x_BYTE)a3)
			{
				sub_90B27_VGA_pal_fadein_fadeout((Bit8u*)x_DWORD_17DE38, 0x20u, 0);
				LOBYTE(a3) = 1;
				xy_DWORD_17DED4_spritestr[15];
			}
			if (x_WORD_180660_VGA_type_resolution & 1)
				sub_90478_VGA_Blit320();
			else
				sub_75200_VGA_Blit640(480);
			sub_7A060_get_mouse_and_keyboard_events();
		}
		sub_7B5D0();
		sub_7AA70_load_and_decompres_dat_file(0, 0, 0, 0);
		sub_7C710();
		result = 1;
	}
	return result;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// 98786: using guessed type int /*__fastcall*/ j___clock(x_DWORD, x_DWORD, x_DWORD);
// D41A4: using guessed type int x_DWORD_D41A4;
// E2094: using guessed type __int16 x_WORD_E2094;
// E2096: using guessed type char x_BYTE_E2096;
// EB394: using guessed type int **filearray_2aa18c[0];
// 17DE38: using guessed type int x_DWORD_17DE38;
// 17DED4: using guessed type int (int)x_DWORD_17DED4;
// 17DEDC: using guessed type int x_DWORD_17DEDC;
// 17DEE4: using guessed type int x_DWORD_17DEE4_mouse_position;
// 17DEEC: using guessed type __int16 x_WORD_17DEEC;
// 17DEEE: using guessed type __int16 x_WORD_17DEEE;
// 17DEF6: using guessed type __int16 x_WORD_17DEF6;
// 17DEFA: using guessed type __int16 x_WORD_17DEFA;
// 17DEFC: using guessed type __int16 x_WORD_17DEFC;
// 17DEFE: using guessed type __int16 x_WORD_17DEFE;
// 17DF10: using guessed type char x_BYTE_17DF10_get_key_scancode;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00077980) --------------------------------------------------------
char sub_77980_exit_dialog(Bit8u* a1)//258980
{
	__int16 v1; // ax
	char v2; // bl
	//a1 ma byt 2b2cb4
	v1 = sub_7BF20_draw_scroll_dialog((signed __int16 *)(a1 + 26));//draw exit dialog
	v2 = v1;
	if (v1 == 1)
	{
		x_WORD_E29DC = 1;
		x_D41A0_BYTEARRAY_0[2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 11234] = 1;
		//*(x_BYTE *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11234) = 1;
	}
	else if (v1 == 2)
	{
		v2 = 1;
		sub_7C020((x_WORD *)(a1 + 26));
	}
	return v2;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// E29DC: using guessed type __int16 x_WORD_E29DC;

//----- (000779E0) --------------------------------------------------------
char sub_779E0_lang_setting_dialog(Bit8u* a1x)//2589E0
{
	Bit8u* v1; // ebx  
	char *langfilename; // eax
	char v4; // al
	FILE* configfile2; // esi
	int v6; // eax
	int v7; // edx
	int v8; // eax
	Bit8u* v9; // esi
	__int16 v10; // si
	__int16 v11; // ax
	//int v12; // esi
	char v13; // al
	FILE* configfile; // ebx
	int v15; // eax
	//char v17; // [esp+0h] [ebp-142h]
	//char v18; // [esp+A0h] [ebp-A2h]
	//char v19[100]; // [esp+F0h] [ebp-52h]
	_finddata_t langfileL;
	//char v20; // [esp+10Eh] [ebp-34h]
	//char v21[100]; // [esp+11Ch] [ebp-26h]
	_finddata_t langfileD;
	//char v22; // [esp+13Ah] [ebp-8h]
	Bit8u v23[100]; // [esp+148h] [ebp+6h]
	Bit8u v24[100]; // [esp+158h] [ebp+16h]
	//int v25; // [esp+16Ch] [ebp+2Ah]
	//__int16 v26; // [esp+170h] [ebp+2Eh]
	//int v27; // [esp+180h] [ebp+3Eh]
	//char v28; // [esp+18Ah] [ebp+48h]
	int v29_old_time; // [esp+18Ch] [ebp+4Ah]
	int v30_actual_time; // [esp+190h] [ebp+4Eh]
	__int16 v31; // [esp+198h] [ebp+56h]
	char v32; // [esp+19Ah] [ebp+58h]
	Bit8u* v33; // [esp+19Ch] [ebp+5Ah]
	Bit8u v34; // [esp+1A0h] [ebp+5Eh]
	Bit8u* v35; // [esp+1A4h] [ebp+62h]
	Bit8u* v36; // [esp+1A8h] [ebp+66h]
	Bit8u* v37; // [esp+1ACh] [ebp+6Ah]
	//Bit8u* v38; // [esp+1B0h] [ebp+6Eh]
	int v39; // [esp+1B4h] [ebp+72h]
	Bit8u v40; // [esp+1B8h] [ebp+76h]
	int v41; // [esp+1BCh] [ebp+7Ah]

	//fix it
	v7 = 0;
	v31 = 0;
	v29_old_time = 0;
	//fix it

	v34 = 0;
	v41 = 0;
	v40 = 0;
	v39 = 0;
	sprintf_s(printbuffer2, 512, "%c%s", x_D41A0_BYTEARRAY_4_struct.harddisk_number, ":/NETHERW/CONFIG.DAT");
	/*memset(&v25, 0, 32);//355104 ->355120
	memset(&v29_old_time, 0, 16);
	qmemcpy(&v25, (void *)x_D41A0_BYTEARRAY_4, 0x14u);
	qmemcpy(&v27, (void *)(x_D41A0_BYTEARRAY_4[20]), 2u);
	fix it
	*/
	long langlhandle = NULL;
	long langdhandle = NULL;

	v32 = 2;
	sub_6EDB0_set_mouse_position_by_res();//24fdb0
	x_DWORD_17DEE4_mouse_positionx = 0x140;
	x_DWORD_17DEE4_mouse_positiony = 0xC8;
	if (a1x)//0x0
	{
		sub_7A110_load_hscreen(x_WORD_180660_VGA_type_resolution, 12);//load hscreen 25b110
		v1 = &x_DWORD_E9C38_smalltit[307200];//4B000
	}
	else
	{
		//v38 = x_DWORD_E9C38_smalltit;
		x_DWORD_E9C38_smalltit = x_D41A0_BYTEARRAY_4_0xE2_heapbuffer;//[[2a51a4]+e2]
		v1 = &x_DWORD_E9C38_smalltit[307200];//406514+4b000
		sub_7A110_load_hscreen(x_WORD_180660_VGA_type_resolution, 14);//25b110
	}
	sub_7B5A0_disable_enable();//25c5a0  disable //enabl
	sub_8CD27_set_cursor(*filearray_2aa18c[filearrayindex_POINTERSDATTAB].posistruct/*filearray_2aa18c[0]*/);//26dd27
	x_WORD_17DEEC = 0;
	langlhandle = unknown_libname_2_findfirst((char*)"LANGUAGE/L*.TXT", 0, &langfileL);
	if (langlhandle != NULL)// 27B166 - 355088
	{
		langdhandle = unknown_libname_2_findfirst((char*)"LANGUAGE/D*.TXT", 0, &langfileD); //v21=3550b4 3550b4
		if (langlhandle == NULL || langdhandle == NULL)
			langfilename = (char*)langfileL.name;//neco se nenaslo
		else
			langfilename = (char*)langfileD.name;//&v22;//naslo se oba v tom pripade prirad "D2.TXT", adresa 3550d2
		//35513c 355134 451414 3550d2
		//D2.TXT , [451514]000000, [355134]00100000-podobne v20,[35513c]0000
		//eax - 3550d2 d2.txt
		//ebx - 451514 - 0000000000000000000
		//[ebp+5a] 00100000
		//[ebp+62] 00000000a4a03a00
		posistruct v1_langdattab[1000];
		v4 = sub_7F7D0(&v35, &v33, v1, langfilename, v1_langdattab);//2607d0
		//D2.TXT , [451514]020058e2e2e2, [355134]c5274500->00000000,[35513c]b9274500->141545->020058e2e2e2
		x_D41A0_BYTEARRAY_4_struct.byteindex_179 = v4;
		unknown_libname_4_find_close(&langfileD, langdhandle);//27b1b3
		v36 = v35;
		v37 = v33;
		if (langlhandle == NULL)
		{
			configfile2 = sub_98817_open(printbuffer2, 512);
			if (configfile2 != NULL)
			{
				sub_988A7_read(configfile2, &v34, 4);
				if (v34 == -9)
				{
					sub_988A7_read(configfile2, &v40, 2);
					sprintf_s(printbuffer, 512, "L%d.TXT", v40);
					x_D41A0_BYTEARRAY_4_struct.byteindex_179 = sub_7F960(v36, v37, v1, printbuffer, v1_langdattab);//tady se pak zmeni v1 za v1_langdattab
				}
				sub_98882_close(configfile2);
			}
		}
		sub_7B5A0_disable_enable();//25c5a0
		x_WORD_17DEEE = 0;
		//[34eed4]+de? =48c81b ->3abe47001315
		sub_8CD27_set_cursor(xy_DWORD_17DED4_spritestr[0x25]);//26dd27 
		//kursor se nastavi zde!
		while (v39 != 2)//adress 258c30
		{
			if (x_BYTE_17DF10_get_key_scancode == 59)
			{
				v6 = (uint8)x_D41A0_BYTEARRAY_4;
				x_D41A0_BYTEARRAY_4_struct.byteindex_A = x_D41A0_BYTEARRAY_4_struct.byteindex_A != 1;
				*(x_BYTE *)(v6 + 38402) = 1;
			}
			if (x_WORD_180660_VGA_type_resolution & 1)
				sub_9A128_copy_screen_320(x_DWORD_E9C38_smalltit, x_DWORD_180628b_screen_buffer, 0xC8u);
			else
				sub_9A144_copy_screen_640(x_DWORD_E9C38_smalltit, x_DWORD_180628b_screen_buffer, 0x1E0u);//write default screan 27b144  adress 258c99
			v39 = sub_7E0E0_mouse_events();//25f0e0 adress 258ca1 - zmeni tlacitko, vrati stav kliknuti
			//4527b9=[ebp+66]+6 4527bf 161545005835->58e2e2e2e2e2
			//[ebp+66]+6//save1
			sub_2BB40_draw_bitmap(263, 134, v1_langdattab[1]);//20cb40 adress 258cba - zmeni vlajku
			//v8 = x_D41A0_BYTEARRAY_4_struct.dwordindex_0;//save2
			if (x_D41A0_BYTEARRAY_4_struct.byteindex_A == 1)//je 1  ne nula!
			{
				v8 = v32;
				if (v32 == 2)
				{
					v30_actual_time = j___clock();//279786 , adresa 258cd9
					//0x4a3-0x0 b
					if ((v30_actual_time - v29_old_time) / 100 > 1)//pokud ubehlo 100ms
					{
						if (!x_WORD_E24BE[9 * v31++])//2b34be
							v31 = 0;
						v29_old_time = v30_actual_time;
					}
					memset(&v23, 0, 36);//26db3a
					//esi=[ebp+56] 355130->01
					//edi=[ebp+6] 3550e0->00000000
					//eax=[0+esi*8] 8
					//esp+=c 354f8c+c=354f98
					//eax+=esi tj.9
					//esi=002b34bc
					//eax+=eax 18
					//ecx=18
					//esi=002b34bc+18

					v9 = &unk_E24BCx[18 * v31];//2b34bc
					qmemcpy(&v23, v9, 0x10u);
					qmemcpy(&v24, v9 + 16, 2u);
					//v23
					//c6012a012c018d

					sub_7E840_draw_textbox_with_line((Bit16u *)&v23, 83, 100);//25f840 adress 258d6a - prida text?
				  //save3
				}
				else if (v32 == 3)
				{
					v30_actual_time = j___clock();
					if ((v30_actual_time - v29_old_time) / 100 > 1)//pokud ubehlo 100ms
						v32 = 2;
				}
			}
			if (v41)
			{
				if (x_WORD_180660_VGA_type_resolution & 1)
					sub_90478_VGA_Blit320();
				else
					sub_75200_VGA_Blit640(480);//vykresleni //256200
			}
			else
			{
				sub_90B27_VGA_pal_fadein_fadeout((Bit8u*)x_DWORD_17DE38, 0x20u, 0);//271b27
				v41++;
			}
			v10 = v39;
			sub_7A060_get_mouse_and_keyboard_events();//25b060 adress 258ddf
			if (v10 == 1)
			{
				if (unknown_libname_3_findnext(&langfileL, langlhandle))//258193
				{
					unknown_libname_4_find_close(&langfileL, langlhandle);
					langlhandle = unknown_libname_2_findfirst((char*)"LANGUAGE/L*.TXT", 0, &langfileL);
				}
				// L2.TXT
				v11 = sub_7F960(v36, v37, v1, langfileL.name, v1_langdattab);//adress 258dec
				//v12 = (uint8)x_D41A0_BYTEARRAY_4;
				v40 = v11;
				if (x_D41A0_BYTEARRAY_4_struct.byteindex_179 == v11)
				{
					if (unknown_libname_3_findnext(&langfileL, langlhandle))
					{
						unknown_libname_4_find_close(&langfileL, langlhandle);
						langlhandle = unknown_libname_2_findfirst((char*)"LANGUAGE/L*.TXT", 0, &langfileL);
					}
					v13 = sub_7F960(v36, v37, v1, langfileL.name, v1_langdattab);
					//v12 = (uint8)x_D41A0_BYTEARRAY_4;
				}
				else
				{
					v13 = v40;
				}
				//*(x_BYTE *)(v12 + 179) = v13;
				x_D41A0_BYTEARRAY_4_struct.byteindex_179 = v13;
			}
		}
	}
	//adress 258ea1
	unknown_libname_4_find_close(&langfileL, langlhandle);//adress 258EA2
	configfile = sub_98817_open(printbuffer2, 546);
	if (configfile != NULL)
	{
		if (x_D41A0_BYTEARRAY_4_struct.setting_38402 == 1)
			x_D41A0_BYTEARRAY_4_struct.setting_38402 = 0;
		/*qmemcpy(&v25, (void *)x_D41A0_BYTEARRAY_4, 0x14u);
		qmemcpy(&v27, (void *)(x_D41A0_BYTEARRAY_4[0x14]), 2u);
		qmemcpy((char *)&v27 + 2, &x_BYTE_EB39E_keys, 8u);
		//qmemcpy(&v28, &x_BYTE_EB39E_keys + 8, 2u);//fix it
		v25 = -9;
		v26 = x_D41A0_BYTEARRAY_4_struct.byteindex_179;
		sub_98CAA_write(configfile, (Bit8u*)&v25, 32);*/
		//f7 ff ff ff 02 00 7f 00 7f 00 01 00 00 00 00 00
		//00 00 00 00 00 00 48 50 4b 4d 1c 1d 38 36 36 38

		//f7 ff ff ff 03 00 7f 00 7f 00 01 00 00 00 00 00
		//00 00 00 00 00 00 48 50 4b 4d 1c 1d 38 36 36 38
		Bit16u twobyte = 0xfff7;
		Bit8u helpbyte;
		sub_98CAA_write(configfile, (Bit8u*)&twobyte, 2);//0
		twobyte = 0xffff;
		sub_98CAA_write(configfile, (Bit8u*)&twobyte, 2);//2
		twobyte = x_D41A0_BYTEARRAY_4_struct.byteindex_179;
		sub_98CAA_write(configfile, (Bit8u*)&twobyte, 2);//4
		twobyte = x_D41A0_BYTEARRAY_4_struct.dwordindex_6;
		sub_98CAA_write(configfile, (Bit8u*)&twobyte, 2);//6
		twobyte = x_D41A0_BYTEARRAY_4_struct.dwordindex_8;
		sub_98CAA_write(configfile, (Bit8u*)&twobyte, 2);//8
		twobyte = x_D41A0_BYTEARRAY_4_struct.byteindex_A;
		sub_98CAA_write(configfile, (Bit8u*)&twobyte, 2);//10
		twobyte = x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
		sub_98CAA_write(configfile, (Bit8u*)&twobyte, 2);//12
		twobyte = 0x0000;
		sub_98CAA_write(configfile, (Bit8u*)&twobyte, 2);//14
		twobyte = 0x0000;
		sub_98CAA_write(configfile, (Bit8u*)&twobyte, 2);//16
		twobyte = 0x0000;
		sub_98CAA_write(configfile, (Bit8u*)&twobyte, 2);//18
		twobyte = 0x0000;
		sub_98CAA_write(configfile, (Bit8u*)&twobyte, 2);//20
		helpbyte = x_BYTE_EB39E_keys[0];
		sub_98CAA_write(configfile, (Bit8u*)&helpbyte, 1);//21
		helpbyte = x_BYTE_EB39E_keys[1];
		sub_98CAA_write(configfile, (Bit8u*)&helpbyte, 1);//22
		helpbyte = x_BYTE_EB39E_keys[2];
		sub_98CAA_write(configfile, (Bit8u*)&helpbyte, 1);//23
		helpbyte = x_BYTE_EB39E_keys[3];
		sub_98CAA_write(configfile, (Bit8u*)&helpbyte, 1);//24
		helpbyte = x_BYTE_EB39E_keys[4];
		sub_98CAA_write(configfile, (Bit8u*)&helpbyte, 1);//25
		helpbyte = x_BYTE_EB39E_keys[5];
		sub_98CAA_write(configfile, (Bit8u*)&helpbyte, 1);//26
		helpbyte = x_BYTE_EB39E_keys[6];
		sub_98CAA_write(configfile, (Bit8u*)&helpbyte, 1);//27
		helpbyte = x_BYTE_EB39E_keys[7];
		sub_98CAA_write(configfile, (Bit8u*)&helpbyte, 1);//28
		helpbyte = x_BYTE_EB39E_keys[8];
		sub_98CAA_write(configfile, (Bit8u*)&helpbyte, 1);//29
		helpbyte = x_BYTE_EB39E_keys[9];
		sub_98CAA_write(configfile, (Bit8u*)&helpbyte, 1);//30
		sub_98882_close(configfile);
	}
	/*LOWORD(v15) = */sub_90B27_VGA_pal_fadein_fadeout(0, 0x10u, 0);
	if (x_WORD_180660_VGA_type_resolution & 1)
	{
		v15 = (int)x_DWORD_180628b_screen_buffer;
		sub_72883_clear_text_mode(/*(int)x_DWORD_180628b_screen_buffer, */(void *)x_DWORD_180628b_screen_buffer, 0xC8u, 0);
	}
	else
	{
		sub_728A9_clear_graphics_mode((void *)x_DWORD_180628b_screen_buffer, 0x1E0u, 0);
	}
	if (x_WORD_180660_VGA_type_resolution & 1)
		sub_72883_clear_text_mode(/*v15, */(void *)x_DWORD_E9C38_smalltit, 0xC8u, 0);
	else
		sub_728A9_clear_graphics_mode((void *)x_DWORD_E9C38_smalltit, 0x1E0u, 0);
	sub_7B5A0_disable_enable();
	if (x_WORD_180660_VGA_type_resolution & 1)
		sub_90478_VGA_Blit320();
	else
		sub_75200_VGA_Blit640(480);
	if (langlhandle != NULL)//3551d4
	{
		sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", (Bit8u*)x_DWORD_17DE38, 0, 768);
		sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", (Bit8u*)x_DWORD_17DE40, x_DWORD_17DEDC, 168081);
		sub_41A90_VGA_pallette_install((unsigned __int8 *)x_DWORD_17DE38);
		sub_8CD27_set_cursor(*filearray_2aa18c[0].posistruct);//mozna xadatapointerstab
		sub_8CD27_set_cursor(xy_DWORD_17DED4_spritestr[39]);
		if (x_WORD_180660_VGA_type_resolution & 1)
			sub_9A128_copy_screen_320((void*)x_DWORD_180628b_screen_buffer, (void*)x_DWORD_E9C38_smalltit, 0xC8u);
		else
			sub_9A144_copy_screen_640((void*)x_DWORD_180628b_screen_buffer, (void*)x_DWORD_E9C38_smalltit, 0x1E0u);
		sub_7C120_draw_bitmap_640(185, 232, xy_DWORD_17DED4_spritestr[66]);
	}
	/*else
	{
	  x_DWORD_E9C38_smalltit = v38;
	}*/
	sub_7AA70_load_and_decompres_dat_file(0, 0, 0, 0);
	return 1;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// 98786: using guessed type int /*__fastcall*/ j___clock(x_DWORD, x_DWORD, x_DWORD);
// 9A166: using guessed type x_DWORD unknown_libname_2_findfirst(x_DWORD, x_DWORD, x_DWORD);
// 9A193: using guessed type x_DWORD unknown_libname_3(x_DWORD);
// 9A1B3: using guessed type int unknown_libname_4(x_DWORD);
// D41A4: using guessed type int x_DWORD_D41A4;
// E9C38: using guessed type int x_DWORD_E9C38_smalltit;
// EB394: using guessed type int **filearray_2aa18c[0];
// EB39E: using guessed type char x_BYTE_EB39E_keys;
// 17DE38: using guessed type int x_DWORD_17DE38;
// 17DE40: using guessed type int x_DWORD_17DE40;
// 17DED4: using guessed type int (int)x_DWORD_17DED4;
// 17DEDC: using guessed type int x_DWORD_17DEDC;
// 17DEE4: using guessed type int x_DWORD_17DEE4_mouse_position;
// 17DEEC: using guessed type __int16 x_WORD_17DEEC;
// 17DEEE: using guessed type __int16 x_WORD_17DEEE;
// 17DF10: using guessed type char x_BYTE_17DF10_get_key_scancode;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (000780F0) --------------------------------------------------------
char sub_780F0_load_game_dialog(Bit8u* a1)//0x2590f0
{
	x_WORD *v1; // ebx
	int v2; // edx
	char *v3; // esi
	Bit8u* v4; // edi
	char v5; // al
	char v6; // al
	int v7; // eax
	FILE* v8; // esi
	FILE* v9; // eax
	FILE* v10; // esi
	__int16 *v11; // edi
	__int16 v12; // ax
	x_WORD *v13; // esi
	x_WORD *v14; // eax
	__int16 v15; // si
	char *v16; // eax
	__int16 v17; // si
	char v18; // cl
	signed int j; // esi
	int v20; // eax
	unsigned __int8 v21; // di
	__int16 v22; // ax
	__int16 v23; // di
	signed __int16 k; // si
	//__int16 v25; // di
	char v26; // ch
	unsigned __int8 v27; // ST10_1
	__int16 v28; // ST0C_2
	__int16 v29; // ax
	__int16 v31; // [esp-8h] [ebp-5Eh]
	unsigned __int8 v32; // [esp-4h] [ebp-5Ah]
	//char v33; // [esp+0h] [ebp-56h]
	Bit16s v34[10]; // [esp+50h] [ebp-6h]
	//__int16 v35; // [esp+5Ah] [ebp+4h]//5
	//__int16 v36; // [esp+5Ch] [ebp+6h]//6
	//__int16 v37; // [esp+5Eh] [ebp+8h]//7
	//__int16 v38; // [esp+60h] [ebp+Ah]//8
	char v39; // [esp+7Ch] [ebp+26h]
	int v40; // [esp+88h] [ebp+32h]
	//char v41; // [esp+90h] [ebp+3Ah]
	int v42; // [esp+94h] [ebp+3Eh]
	int v43; // [esp+98h] [ebp+42h]
	int v44; // [esp+9Ch] [ebp+46h]
	//int v45; // [esp+A0h] [ebp+4Ah]
	Bit8u* v46; // [esp+A4h] [ebp+4Eh]
	int v47; // [esp+A8h] [ebp+52h]
	int v48; // [esp+ACh] [ebp+56h]
	int v49; // [esp+B0h] [ebp+5Ah]
	Bit8u* v50; // [esp+B4h] [ebp+5Eh]
	__int16 v51; // [esp+B8h] [ebp+62h]
	int v52; // [esp+BCh] [ebp+66h]
	int v53; // [esp+C0h] [ebp+6Ah]
	int i; // [esp+C4h] [ebp+6Eh]
	__int16 v55; // [esp+C8h] [ebp+72h]
	Bit8u v56; // [esp+CCh] [ebp+76h]
	Bit8u v57; // [esp+D0h] [ebp+7Ah]

	//fix it
	v40 = 0;
	//fix it

	v42 = 0;
	v44 = 0;
	v55 = 0;
	v1 = (x_WORD *)(a1 + 26);
	v57 = sub_5BE80_test_pallette((unsigned __int8 *)x_DWORD_17DE38, 0x3Fu, 0x3Fu, 0x3Fu);
	v56 = sub_5BE80_test_pallette((unsigned __int8 *)x_DWORD_17DE38, 0x16u, 0x10u, 9u);
	if (x_WORD_17DF04 == -1)
	{
		for (i = 1; i < 9; i++)
		{
			v2 = i;
			v48 = 43 * (i - 1);
			v3 = (char*)x_DWORD_E9C4C_langindexbuffer[414];//(char *)x_DWORD_EA2C4;//2bb2c4
			v4 = &x_BYTE_17DF14[v48];
			v46 = &x_BYTE_17DF14[v48];
			do
			{
				v5 = *v3;
				*v4 = *v3;
				if (!v5)
					break;
				v6 = v3[1];
				v3 += 2;
				v4[1] = v6;
				v4 += 2;
			} while (v6);
			v7 = v48;
			x_BYTE_17DF3D[v48] = 0;
			x_BYTE_17DF3E[v7] = 0;
			sprintf_s(printbuffer, 512, "%c:%s/save/save%d.gam", x_D41A0_BYTEARRAY_4_struct.harddisk_number, "/netherw", v2);
			v8 = sub_98817_open(printbuffer, 512);
			if (v8 != NULL)
			{
				sub_988A7_read(v8, (Bit8u*)&v43, 4);
				if (v43 == -9)
				{
					sub_988A7_read(v8, (Bit8u*)v46, 20);
					x_BYTE_17DF3D[v48] = 1;
				}
				sub_98882_close(v8);
			}
		}
		x_WORD_17DF04 = 0;
	}
	v51 = sub_7BF20_draw_scroll_dialog((signed __int16 *)(a1 + 26));
	if ((x_BYTE)v51)
	{
		sub_7C020((x_WORD *)(a1 + 26));
		if ((x_BYTE)v51 == 1 && x_WORD_17DF04 > 0)
		{
			sprintf_s(printbuffer, 512, "%c:%s/save/save%d.gam", x_D41A0_BYTEARRAY_4_struct.harddisk_number, "/netherw", x_WORD_17DF04);
			v9 = sub_98817_open(printbuffer, 512);
			v10 = v9;
			if (v9 != NULL)
			{
				sub_988A7_read(v9, (Bit8u*)&v43, 4);
				if (v43 == -9)
				{
					if (*(x_BYTE *)(a1 + 25))
						sub_7E640(0);
					sub_988A7_read(v10, (Bit8u*)&x_BYTE_17DF14[43 * (x_WORD_17DF04 - 1)], 20);
					sub_988A7_read(v10, (Bit8u*)x_D41A0_BYTEARRAY_4_struct.player_name_57, 32);
					v11 = x_WORD_E2970;
					sub_988A7_read(v10, (Bit8u*)x_D41A0_BYTEARRAY_4_struct.savestring_89, 32);
					while (v11 < &x_WORD_E2970[52])
					{
						sub_988A7_read(v10, (Bit8u*)&v39, 17);
						v12 = v40;
						v11[6] = v40;
						if (v12 == 1)
							v11[7] = 305;
						else
							v11[7] = 270;
						v11 = (__int16 *)((char *)v11 + 17);
					}
					sub_988A7_read(v10, (Bit8u*)x_D41A0_BYTEARRAY_0 + 8586, 16);
					sub_988A7_read(v10, (Bit8u*)&v42, 4);
					sub_988A7_read(v10, (Bit8u*)&v44, 4);
					sub_988A7_read(v10, (Bit8u*)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11230 + 1609), 505);
					sub_988A7_read(v10, (Bit8u*)x_DWORD_17DBC8, 500);
					sub_988A7_read(v10, (Bit8u*)x_DWORD_17DDBC, 100);
					sub_98882_close(v10);
					v13 = (x_WORD*)&unk_E17CC[0x194];
					*(x_WORD *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11232) = 0;
					while (v13[2])
					{
						v13 += 11;
						*((x_BYTE *)v13 - 4) = 2;
					}
					v14 = (x_WORD*)&unk_E17CC[0x194];
					v15 = 0;
					while (v15 < v42 && v14[2])
					{
						v14 += 11;
						v15++;
						*((x_BYTE *)v14 - 4) = 1;
					}
					v16 = (char *)&unk_E17CC[0x194];
					v17 = 0;
					while (*((x_WORD *)v16 + 2))
					{
						if (v16[18] == 1)
							x_D41A0_BYTEARRAY_4_struct.levelnumber_43 = v17;
						v16 += 22;
						v17++;
					}
					x_DWORD_17DB70str.x_BYTE_17DB8F = 1;
					memset(&x_DWORD_17DE28str, 0, 13);
					v18 = *(x_BYTE *)(a1 + 25);
					x_DWORD_17DB70str.x_WORD_17DB8A = -1;
					if (v18)
					{
						sub_81760_new_game_subdraw(a1);
					}
					else
					{
						x_WORD_17DF04 = -1;
						sub_77350_new_game_dialog(a1);
						*(x_DWORD *)(a1 + 4) = 2;
					}
				}
			}
		}
		x_WORD_17DF04 = -1;
		v55 = 1;
	}
	for (j = 1; (signed __int16)j < 9; j++)
	{
		sub_6FC50(1);
		if (*(signed __int16 *)(a1 + 36) > 16 * (signed __int16)j + 3 * sub_6FC30_get34_sizey())
		{
			sprintf_s(printbuffer, 512, "%d.", j);
			v53 = 16 * j;
			v20 = 43 * (j - 1);
			v50 = &x_BYTE_17DF14[v20];
			if (j == x_WORD_17DF04)
			{
				v20 = *v1;
				v52 = v20 + 20;
				v23 = v53 + *(x_WORD *)(a1 + 28) + 16;
				v47 = v57;
				sub_2BC10_draw_text((Bit8u*)printbuffer, v20 + 20, v23, v57);
				v32 = v47;
				v31 = v23;
				v22 = v52 + 3 * sub_6FC10_letter_width();
			}
			else
			{
				v21 = v56;
				sub_2BC10_draw_text((Bit8u*)printbuffer, *(x_WORD *)(a1 + 26) + 20, v53 + *(x_WORD *)(a1 + 28) + 16, v56);
				v32 = v21;
				v31 = v53 + *(x_WORD *)(a1 + 28) + 16;
				v22 = *v1 + 20 + 3 * sub_6FC10_letter_width();
			}
			sub_2BC10_draw_text((Bit8u*)v50, v22, v31, v32);
		}
	}
	if (*(x_WORD *)(a1 + 36) >= *(x_WORD *)(a1 + 34))
	{
		for (k = 1; k < 9; k++)
		{
			v34[5] = *v1 + 20;
			//v25 = 16 * k;
			v34[6] = 16 * k + *(x_WORD *)(a1 + 28) + 16;
			v34[7] = 100;
			//v45 = k;
			v34[8] = 16;
			v26 = x_BYTE_17DF3D[43 * (k - 1)];
			v49 = 43 * (k - 1);
			if (v26 && sub_7B200_in_region(v34, x_DWORD_17DEE4_mouse_positionx, x_DWORD_17DEE4_mouse_positiony))
			{
				if (x_WORD_17DEEE & 1)
				{
					x_WORD_17DF04 = k;
				}
				else
				{
					sprintf_s(printbuffer, 512, "%d.", k);
					v47 = v57;
					sub_2BC10_draw_text((Bit8u*)printbuffer, *(x_WORD *)(a1 + 26) + 20, 16 * k + *(x_WORD *)(a1 + 28) + 16, v57);
					v27 = v47;
					v28 = 16 * k + *(x_WORD *)(a1 + 28) + 16;
					v29 = sub_6FC10_letter_width();
					sub_2BC10_draw_text(&x_BYTE_17DF14[v49], *v1 + 20 + 3 * v29, v28, v27);
				}
			}
		}
	}
	return v55;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// E29D6: using guessed type __int16 x_WORD_E29D6;
// EA2C4: using guessed type int x_DWORD_EA2C4;
// 17DB8A: using guessed type __int16 x_WORD_17DB8A;
// 17DB8F: using guessed type char x_BYTE_17DB8F;
// 17DBC8: using guessed type int x_DWORD_17DBC8[];
// 17DDBC: using guessed type int x_DWORD_17DDBC[];
// 17DE28: using guessed type int x_DWORD_17DE28;
// 17DE38: using guessed type int x_DWORD_17DE38;
// 17DEE4: using guessed type int x_DWORD_17DEE4_mouse_position;
// 17DEEE: using guessed type __int16 x_WORD_17DEEE;
// 17DF04: using guessed type __int16 x_WORD_17DF04;

//----- (00078730) --------------------------------------------------------
char sub_78730_save_game_dialog(x_WORD *a1)//259730
{
	signed __int16 *v1; // ebx
	int v2; // edx
	int v3; // eax
	char *v4; // esi
	Bit8u* v5; // edi
	char v6; // al
	char v7; // al
	FILE* v8; // esi
	Bit8u* v9; // edi
	Bit8u* v10; // esi
	char v11; // al
	char v12; // al
	FILE* v13; // esi
	x_WORD *v14; // eax
	signed int j; // esi
	Bit8u* v16; // edi
	//unsigned __int8 v17; // ST10_1
	__int16 v18; // ST0C_2
	__int16 v19; // ST08_2
	signed __int16 v20; // ax
	int v21; // eax
	//unsigned __int8 v22; // ST10_1
	//__int16 v23; // ST0C_2
	//__int16 v24; // ST08_2
	__int16 v25; // ax
	Bit8u* v26; // esi
	Bit8u* v27; // edi
	//char v28; // al
	//char v29; // al
	//int v30; // eax
	int v31; // edi
	unsigned __int8 v32; // si
	__int16 v33; // ST0C_2
	__int16 v34; // ax
	int v35; // eax
	int v36; // eax
	unsigned __int8 v37; // ST10_1
	Bit8u* v38; // eax
	Bit8u* v39; // ST0C_4
	Bit8u* v40; // ST08_4
	__int16 v41; // ST04_2
	__int16 v42; // ax
	int v43; // edx
	Bit8u* v45; // [esp-4h] [ebp-46h]
	//char v46; // [esp+0h] [ebp-42h]
	Bit16s v47[10]; // [esp+50h] [ebp+Eh]
	//__int16 v48; // [esp+5Ah] [ebp+18h]//5
	//__int16 v49; // [esp+5Ch] [ebp+1Ah]//6
	//__int16 v50; // [esp+5Eh] [ebp+1Ch]//7
	//__int16 v51; // [esp+60h] [ebp+1Eh]//8
	//char v52; // [esp+7Ch] [ebp+3Ah]
	int v53; // [esp+80h] [ebp+3Eh]
	int v54; // [esp+84h] [ebp+42h]
	int v55; // [esp+88h] [ebp+46h]
	Bit8u* v56; // [esp+8Ch] [ebp+4Ah]
	//int v57; // [esp+90h] [ebp+4Eh]
	//int v58; // [esp+94h] [ebp+52h]
	__int16 v59; // [esp+98h] [ebp+56h]
	__int16 result; // [esp+9Ch] [ebp+5Ah]
	int v61; // [esp+A0h] [ebp+5Eh]
	int v62; // [esp+A4h] [ebp+62h]
	int v63; // [esp+A8h] [ebp+66h]
	int v64; // [esp+ACh] [ebp+6Ah]
	int i; // [esp+B0h] [ebp+6Eh]
	int k; // [esp+B4h] [ebp+72h]
	unsigned __int8 v67; // [esp+B8h] [ebp+76h]
	unsigned __int8 v68; // [esp+BCh] [ebp+7Ah]

	//fix it
	v43 = 0;
	//fix it

	result = 0;
	v68 = sub_5BE80_test_pallette(x_DWORD_17DE38, 0x3Fu, 0x3Fu, 0x3Fu);
	v67 = sub_5BE80_test_pallette(x_DWORD_17DE38, 0x16u, 0x10u, 9u);
	v1 = a1 + 13;
	if (x_WORD_17DF04 == -1)
	{
		for (i = 1; i < 9; i++)
		{
			v2 = i;
			v3 = 43 * (i - 1);
			v4 = (char*)x_DWORD_E9C4C_langindexbuffer[414];//(char *)x_DWORD_EA2C4;
			v5 = &x_BYTE_17DF14[v3];
			v45 = &x_BYTE_17DF14[v3];
			do
			{
				v6 = v4[0];
				v5[0] = v4[0];
				if (!v6)
					break;
				v7 = v4[1];
				v4 += 2;
				v5[1] = v7;
				v5 += 2;
			} while (v7);
			v56 = v45;
			sprintf_s(printbuffer, 512, "%c:%s/save/save%d.gam", x_D41A0_BYTEARRAY_4_struct.harddisk_number, "/netherw", v2);
			v8 = sub_98817_open(printbuffer, 512);
			if (v8 != NULL)
			{
				sub_988A7_read(v8, (Bit8u*)&v54, 4);
				if (v54 == -9)
					sub_988A7_read(v8, v56, 20);
				sub_98882_close(v8);
			}
		}
		x_WORD_17DF04 = 0;
	}
	v59 = sub_7BF20_draw_scroll_dialog(v1);
	if (v59)
	{
		sub_7C020(v1);
		if (v59 == 1 && x_WORD_17DF04 > 0)
		{
			v9 = &x_BYTE_17DF14[43 * (x_WORD_17DF04 - 1)];
			v10 = v9 + 20;
			do
			{
				v11 = v10[0];
				v9[0] = v10[0];
				if (!v11)
					break;
				v12 = v10[1];
				v10 += 2;
				v9[1] = v12;
				v9 += 2;
			} while (v12);
			sprintf_s(printbuffer, 512, "%c:%s/save/save%d.gam", x_D41A0_BYTEARRAY_4_struct.harddisk_number, "/netherw", x_WORD_17DF04);
			v13 = sub_98817_open(printbuffer, 546);
			if (v13 != NULL)
			{
				v14 = (x_WORD*)&unk_E17CC[0x194];
				v54 = -9;
				v55 = 0;
				while (v14[2] && v14[18] != 2)
				{
					v14 += 11;
					v55++;
				}
				v53 = *(signed __int16 *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11232);
				sub_98CAA_write(v13, (Bit8u*)&v54, 4);
				sub_98CAA_write(v13, (Bit8u*)&x_BYTE_17DF14[43 * (x_WORD_17DF04 - 1)], 20);
				sub_98CAA_write(v13, (Bit8u*)x_D41A0_BYTEARRAY_4_struct.player_name_57, 32);
				sub_98CAA_write(v13, (Bit8u*)x_D41A0_BYTEARRAY_4_struct.savestring_89, 32);
				sub_98CAA_write(v13, (Bit8u*)x_WORD_E2970, 102);
				sub_98CAA_write(v13, (Bit8u*)(x_D41A0_BYTEARRAY_0 + 8586), 16);
				sub_98CAA_write(v13, (Bit8u*)&v55, 4);
				sub_98CAA_write(v13, (Bit8u*)&v53, 4);
				sub_98CAA_write(v13, (Bit8u*)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11230 + 1609), 505);
				sub_98CAA_write(v13, (Bit8u*)x_DWORD_17DBC8, 500);
				sub_98CAA_write(v13, (Bit8u*)x_DWORD_17DDBC, 100);
				sub_98882_close(v13);
			}
		}
		x_WORD_17DF04 = -1;
		result = 1;
	}
	for (j = 1; j < 9; j++)
	{
		sub_6FC50(1);
		if (a1[18] > 16 * j + 3 * sub_6FC30_get34_sizey())//0160:259AB7
		{
			sprintf_s(printbuffer, 512, "%d.", j);
			v62 = 16 * j;
			v16 = &x_BYTE_17DF14[43 * (j - 1)];
			if (j == x_WORD_17DF04)
			{//draw edtited text line loc 78b10
				v20 = *v1;
				v21 = 16 * j + 20;
				v63 = v20 + 20;
				LOWORD(v21) = a1[14];
				//v57 = v68;
				//v58 = (signed __int16)(v21 + 16 + v62);
				v61 = v21 + 16 + v62;
				sub_2BC10_draw_text((Bit8u*)printbuffer, v63, v21 + 16 + v62, v68);//draw number
				//v22 = v57;
				//v23 = v58;
				//v24 = v63 + 3 * sub_6FC10_letter_width();
				sub_2BC10_draw_text((Bit8u*)v16 + 20, v63 + 3 * sub_6FC10_letter_width(), v21 + 16 + v62, v68);//draw text
			}
			else
			{
				//v57 = v67;
				sub_2BC10_draw_text((Bit8u*)printbuffer, a1[13] + 20, v62 + a1[14] + 16, v67);//draw number
				//v17 = v67;
				v18 = v62 + a1[14] + 16;
				v19 = *v1 + 20 + 3 * sub_6FC10_letter_width();
				sub_2BC10_draw_text((Bit8u*)v16, v19, v18, v67);//draw text
			}
		}
	}
	if (a1[18] >= a1[17])
	{
		for (k = 1; k < 9; k++)
		{
			v47[5] = v1[0] + 20;//x pos
			v25 = a1[14];
			v64 = 16 * k;
			v47[8] = 16;//y size
			v47[7] = 90;//x size
			v47[6] = v25 + 16 + 16 * k;//y pos
			/*
			v47 =355150
			6801 0000 2000 9ff33c00620041009051100088513500051100000
			*/
			if (sub_7B200_in_region(v47, x_DWORD_17DEE4_mouse_positionx, x_DWORD_17DEE4_mouse_positiony))
			{
				if (x_WORD_17DEEE & 1)
				{
					x_WORD_17DF04 = k;//clicked on first save
					v26 = &x_BYTE_17DF14[43 * (k - 1)];
					v27 = v26 + 20;
					/*do
					{
					  //v28 = v26[0];
					  v27[0] = v26[0];
					  if ( !v26[0])
						break;
					  v29 = v26[1];
					  v27[1] = v26[1];
					  v26 += 2;
					  v27 += 2;
					}
					while ( v29 );*/
					strcpy_s((char*)v27, strlen((const char*)v26) + 1, (const char*)v26);
					//v30 = 43 * (x_WORD_17DF04 - 1);
					x_BYTE_17DF3C[43 * (x_WORD_17DF04 - 1)] = 0;
					//LOWORD(v30) = *v1;
					//v30 += 20;
					v63 = v1[0] + 20;
					//LOWORD(v30) = a1[14];
					v61 = a1[14] + 16 + v64;
					x_BYTE_17DF3E[43 * (x_WORD_17DF04 - 1)] = 0;
				}
				else if (k != x_WORD_17DF04)
				{//draw text highlight
					v31 = 43 * (k - 1);
					sprintf_s(printbuffer, 512, "%d.", k);
					v32 = v68;
					sub_2BC10_draw_text((Bit8u*)printbuffer, a1[13] + 20, v64 + a1[14] + 16, v68);
					v33 = v64 + a1[14] + 16;
					v34 = sub_6FC10_letter_width();
					sub_2BC10_draw_text(&x_BYTE_17DF14[v31], v1[0] + 20 + 3 * v34, v33, v32);
				}
			}
		}
		if (x_WORD_17DF04)
		{
			sub_6FC50(1);
			if (x_BYTE_17DF10_get_key_scancode != 1 && x_BYTE_17DF10_get_key_scancode != 28 && x_BYTE_17DF10_get_key_scancode != 14
				|| (v35 = 43 * (x_WORD_17DF04 - 1), x_BYTE_17DF3E[v35]))
			{
				if (x_BYTE_17DF11_last_key_status)
				{
					if (sub_7C200(x_BYTE_17DF11_last_key_status))
					{
						v36 = 43 * (x_WORD_17DF04 - 1);
						if (!x_BYTE_17DF3E[v36])
						{
							x_BYTE_17DF3E[v36] = 1;
							sprintf_s((char*)&x_BYTE_17DF14[43 * (x_WORD_17DF04 - 1) + 20], 512, "%c", x_BYTE_17DF11_last_key_status);
							x_BYTE_17DF10_get_key_scancode = 0;
							x_BYTE_17DF11_last_key_status = 0;
						}
					}
				}
			}
			else
			{
				x_BYTE_17DF3E[v35] = 1;
			}
			v37 = v68;
			v38 = &x_BYTE_17DF14[43 * (x_WORD_17DF04 - 1)];
			v39 = v38 + 40;
			v40 = v38 + 20;
			v41 = v61;
			v42 = sub_6FC10_letter_width();
			sub_7F6A0((signed __int16)(v63 + 3 * v42), v43, v63 + 3 * v42, v41, (char*)v40, (char*)v39, v37);
		}
	}
	return result;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// EA2C4: using guessed type int x_DWORD_EA2C4;
// 17DBC8: using guessed type int x_DWORD_17DBC8[];
// 17DDBC: using guessed type int x_DWORD_17DDBC[];
// 17DE38: using guessed type int x_DWORD_17DE38;
// 17DEE4: using guessed type int x_DWORD_17DEE4_mouse_position;
// 17DEEE: using guessed type __int16 x_WORD_17DEEE;
// 17DF04: using guessed type __int16 x_WORD_17DF04;
// 17DF10: using guessed type char x_BYTE_17DF10_get_key_scancode;
// 17DF11: using guessed type char x_BYTE_17DF11_last_key_status;

//----- (00078E00) --------------------------------------------------------
char sub_78E00_set_player_name_dialog(/*int a1, int a2, */signed __int16 *a3)//259e00
{
	int v3; // eax
	int v4; // esi
	int v5; // esi
	const char *v6; // edi
	char *v7; // edx
	char v8; // al
	__int16 v9; // si
	unsigned __int8 v10; // al
	__int16 v11; // bx
	unsigned __int8 v12; // al
	Bit8u* v13; // esi
	Bit8u* v14; // edi
	char v15; // al
	char v16; // al
	Bit8u* v17; // edi
	Bit8u* v18; // esi
	char v19; // al
	char v20; // al
	Bit8u* v21; // edi
	Bit8u* v22; // esi
	char v23; // al
	char v24; // al
	int v26; // [esp+0h] [ebp-14h]
	int v27; // [esp+4h] [ebp-10h]
	char v28; // [esp+8h] [ebp-Ch]
	int v29; // [esp+Ch] [ebp-8h]
	char v30; // [esp+10h] [ebp-4h]

	v28 = 0;
	v26 = j___clock();
	/*v3 = */sub_6FC50(1);
	//LOWORD(v3) = a3[13];
	v29 = a3[13] + 10;
	//HIWORD(v3) = HIWORD(x_DWORD_17DED4);
	v3 = xy_DWORD_17DED4_spritestr[72].sizex;
	v27 = v29 + v3 - 22;
	v4 = a3[14] + a3[17] / 2;
	v5 = v4 - sub_6FC30_get34_sizey();
	v30 = sub_7BF20_draw_scroll_dialog(a3 + 13);
	if (a3[18] <= a3[17] / 2)
		goto LABEL_15;
	x_WORD_17DEF0 = strlen((const char *)x_DWORD_17DE50);
	if ((unsigned __int8)x_BYTE_17DF10_get_key_scancode < 0xFu)
	{
		if (x_BYTE_17DF10_get_key_scancode != 14)
		{
		LABEL_9:
			if ((unsigned __int16)x_WORD_17DEF0 < 0xCu && x_BYTE_17DF11_last_key_status && sub_7C200(x_BYTE_17DF11_last_key_status))
			{
				v7 = (char *)(x_DWORD_17DE50 + x_WORD_17DEF0);
				v8 = x_BYTE_17DF11_last_key_status;
				v7[1] = 0;
				*v7 = v8;
			}
			goto LABEL_13;
		}
	LABEL_7:
		if (x_WORD_17DEF0)
		{
			v6 = (const char *)x_DWORD_17DE50;
			*(x_BYTE *)(strlen((const char *)x_DWORD_17DE50) + x_DWORD_17DE50 - 1) = 0;
			x_WORD_17DEF0 = strlen(v6);
		}
		goto LABEL_13;
	}
	if ((unsigned __int8)x_BYTE_17DF10_get_key_scancode > 0xFu)
	{
		if (x_BYTE_17DF10_get_key_scancode != 83)
			goto LABEL_9;
		goto LABEL_7;
	}
LABEL_13:
	_strupr_s((char*)x_DWORD_17DE50, strlen((char*)x_DWORD_17DE50) + 1);
	sub_6FC50(1);
	v9 = sub_6FC30_get34_sizey() + v5;
	v10 = sub_5BE80_test_pallette(x_DWORD_17DE38, 0x16u, 0x10u, 9u);
	v11 = sub_6FC80_pre_draw_text((char *)x_DWORD_17DE50, v29, v27, v9, v10);
	if ((v26 - x_DWORD_17DED0) / 0xCu >= 1)
	{
		v12 = sub_5BE80_test_pallette(x_DWORD_17DE38, 0x16u, 0x10u, 9u);
		sub_2BC10_draw_text((Bit8u*)"_", v11 + 2, v9, v12);
		x_DWORD_17DED0 = v26;
	}
LABEL_15:
	if (v30)
	{
		if (v30 == 1)
		{
			v13 = x_DWORD_17DE50;
			v14 = &x_D41A0_BYTEARRAY_0[11230 + 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 927];
			do
			{
				v15 = *v13;
				*v14 = *v13;
				if (!v15)
					break;
				v16 = v13[1];
				v13 += 2;
				v14[1] = v16;
				v14 += 2;
			} while (v16);
			v17 = (Bit8u*)x_D41A0_BYTEARRAY_4_struct.player_name_57;//38cf89
			v18 = &x_D41A0_BYTEARRAY_0[2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 11230 + 927];
			do
			{
				v19 = *v18;
				*v17 = *v18;
				if (!v19)
					break;
				v20 = v18[1];
				v18 += 2;
				v17[1] = v20;
				v17 += 2;
			} while (v20);
		}
		else
		{
			*x_D41A0_BYTEARRAY_4_struct.player_name_57 = 0;//fixed x_D41A0_BYTEARRAY_4_struct.player_name_57 = 0;
		}
		v21 = x_DWORD_17DE50;
		v22 = &x_D41A0_BYTEARRAY_0[11230 + 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 927];
		do
		{
			v23 = *v22;
			*v21 = *v22;
			if (!v23)
				break;
			v24 = v22[1];
			v22 += 2;
			v21[1] = v24;
			v21 += 2;
		} while (v24);
		sub_7C020(a3 + 13);
		v28 = 1;
	}
	return v28;
}
// 98786: using guessed type int /*__fastcall*/ j___clock(x_DWORD, x_DWORD, x_DWORD);
// 9A20A: using guessed type x_DWORD _strupr_s(x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// 17DE38: using guessed type int x_DWORD_17DE38;
// 17DE50: using guessed type int (int)x_DWORD_17DE50;
// 17DED0: using guessed type int x_DWORD_17DED0;
// 17DED4: using guessed type int (int)x_DWORD_17DED4;
// 17DEF0: using guessed type __int16 x_WORD_17DEF0;
// 17DF10: using guessed type char x_BYTE_17DF10_get_key_scancode;
// 17DF11: using guessed type char x_BYTE_17DF11_last_key_status;

//----- (00079160) --------------------------------------------------------
char sub_79160_set_joystick_dialog(Bit8u* a1)//25a160
{
	signed __int16 *v1; // esi
	int v2; // eax
	int v3; // eax
	int v4; // edx
	int v5; // ebx
	int v6; // ebx
	signed __int16 *v7; // esi
	char *v8; // ST00_4
	int v9; // ebx
	signed __int16 *v10; // esi
	int v11; // eax
	x_WORD *v12; // esi
	int v13; // eax
	int v14; // esi
	unsigned int v15; // ebx
	__int16 v16; // cx
	unsigned __int8 v18; // al
	Bit16s v19[10]; // [esp+0h] [ebp-4Ch]
	//__int16 v20; // [esp+Ah] [ebp-42h] //5
	//__int16 v21; // [esp+Ch] [ebp-40h] //6
	//__int16 v22; // [esp+Eh] [ebp-3Eh] //7
	//__int16 v23; // [esp+10h] [ebp-3Ch] //8
	unsigned int v24; // [esp+2Ch] [ebp-20h]
	x_WORD *v25; // [esp+30h] [ebp-1Ch]
	int v26; // [esp+34h] [ebp-18h]
	__int16 v27; // [esp+38h] [ebp-14h]
	int v28; // [esp+3Ch] [ebp-10h]
	char v29; // [esp+40h] [ebp-Ch]
	unsigned __int8 v30; // [esp+44h] [ebp-8h]
	unsigned __int8 v31; // [esp+48h] [ebp-4h]

	v25 = 0;
	v27 = 0;
	v1 = (signed __int16 *)(a1 + 26);
	v31 = sub_5BE80_test_pallette((unsigned __int8 *)x_DWORD_17DE38, 0x3Fu, 0x3Fu, 0x3Fu);
	v30 = sub_5BE80_test_pallette((unsigned __int8 *)x_DWORD_17DE38, 0, 0, 0);
	BYTE1(v2) = *(x_BYTE *)(a1 + 25);
	if (!BYTE1(v2))
	{
		LOWORD(v2) = *v1;
		v26 = v2 + 10;
		//HIWORD(v3) = HIWORD(x_DWORD_17DED4);
		LOWORD(v3) = xy_DWORD_17DED4_spritestr[72].sizex;
		v4 = *(signed __int16 *)(a1 + 34);
		v28 = v26 + v3 - 22;
		v5 = *(signed __int16 *)(a1 + 28) + v4 / 2;
		v6 = v5 - 2 * sub_6FC30_get34_sizey();
		v29 = sub_7BF20_draw_scroll_dialog((signed __int16 *)(a1 + 26));
		if (*(x_WORD *)(a1 + 36) >= *(x_WORD *)(a1 + 34))
		{
			v7 = (signed __int16 *)&x_BYTE_E25ED[0xa3];
			sub_6FC50(1);
			while (v7[6])
			{
				if (v7[7])
				{
					sub_6FC50(1);
					v8 = (char *)x_DWORD_E9C4C_langindexbuffer[v7[6]];
					v25 = v7;
					sub_6FC80_pre_draw_text(v8, v26, v28, v6, v31);
				}
				else
				{
					sub_6FC50(1);
					sub_6FC80_pre_draw_text((char *)x_DWORD_E9C4C_langindexbuffer[v7[6]], v26, v28, v6, v30);
				}
				v7 += 9;
				LOWORD(v6) = sub_6FC30_get34_sizey() + v6;
			}
			v9 = *(signed __int16 *)(a1 + 28) + *(signed __int16 *)(a1 + 34) / 2;
			v6 = v9 - 2 * sub_6FC30_get34_sizey();
			v19[5] = v26;
			v10 = (signed __int16 *)&x_BYTE_E25ED[0xa3];
			v19[7] = xy_DWORD_17DED4_spritestr[72].sizex;
			v19[8] = sub_6FC30_get34_sizey();
			while (v10[6])
			{
				v19[6] = v6;
				if (sub_7B200_in_region(v19, x_DWORD_17DEE4_mouse_positionx, x_DWORD_17DEE4_mouse_positiony))
				{
					if (x_WORD_17DEEE & 1)
					{
						if (v25)
							v25[7] = 0;
						v10[7] = 1;
					}
					sub_6FC50(1);
					sub_6FC80_pre_draw_text((char *)x_DWORD_E9C4C_langindexbuffer[v10[6]], v26, v28, v6, v31);
				}
				LOWORD(v11) = sub_6FC30_get34_sizey();
				v10 += 9;
				v6 += v11;
			}
		}
		if (v29)
		{
			v12 = (x_WORD*)&x_BYTE_E25ED[0xa3];
			while (v12[6])
			{
				if (v12[7])
				{
					v25 = v12;
					break;
				}
				LOWORD(v13) = sub_6FC30_get34_sizey();
				v12 += 9;
				v6 += v13;
			}
			if (v29 != 1)
			{
				switch (x_WORD_1805C2)
				{
				case 4:
				case 11:
					x_WORD_1805C2 = 7;
					break;
				case 8:
					x_WORD_1805C2 = 1;
					break;
				case 9:
					x_WORD_1805C2 = 2;
					break;
				default:
					goto LABEL_41;
				}
				goto LABEL_41;
			}
			v27 = 1;
			v14 = (unsigned __int16)x_WORD_1805C2;
			if (!v25)
				goto LABEL_42;
			v15 = (unsigned __int16)x_WORD_1805C2 - 1;
			v24 = 4 * v15;
			v16 = v25[8];
			if (v16 == 2)
			{
				if ((signed __int16)sub_89B60_aplicate_setting(4u) == -1)
				{
					x_WORD_1805C2 = v14;
				}
				else if (v15 <= 0xC)
				{
					JUMPOUT(__CS__, (int*) *(void **)((char *)&off_790E4 + v24));
				}
			LABEL_41:
				v27 = 1;
				goto LABEL_42;
			}
			if (v16 != 1)
			{
			LABEL_42:
				sub_7C020((x_WORD *)(a1 + 26));
				return v27;
			}
			if (sub_89B60_aplicate_setting(0xBu) != -1)
			{
				if (v15 <= 8)
					JUMPOUT(__CS__, (int*) *(void **)((char *)&off_79118 + v24));
				*(x_BYTE *)(a1 + 25) = 1;
				v27 = 0;
				goto LABEL_42;
			}
			x_WORD_1805C2 = v14;
			sub_7C020((x_WORD *)(a1 + 26));
		}
		return v27;
	}
	v27 = 0;
	if (BYTE1(v2) >= 1u)
	{
		if (BYTE1(v2) <= 1u)
		{
			*(x_WORD *)(a1 + 38) = 439;
			*(x_WORD *)(a1 + 42) = 0;
		}
		else if (BYTE1(v2) == 2)
		{
			*(x_WORD *)(a1 + 38) = 439;
		}
	}
	sub_7BF20_draw_scroll_dialog(v1);
	if (*(x_WORD *)(a1 + 36) < *(x_WORD *)(a1 + 34))
		return v27;
	v18 = *(x_BYTE *)(a1 + 25);
	if (v18 < 2u)
	{
		if (v18 == 1)
		{
			*(x_BYTE *)(a1 + 25) = 2;
			return v27;
		}
		return v27;
	}
	if (v18 > 2u)
	{
		if (v18 != 3)
			return v27;
		*(x_BYTE *)(a1 + 25) = 0;
		*(x_WORD *)(a1 + 38) = 411;
		*(x_WORD *)(a1 + 42) = 3;
		sub_7C020((x_WORD *)(a1 + 26));
		return 1;
	}
	x_BYTE_17DF10_get_key_scancode = 0;
	sub_8C0E0((unsigned __int8(/*__fastcall*/ *)(signed int))sub_7A060_get_mouse_and_keyboard_events);
	if (x_BYTE_17DF10_get_key_scancode == 1)
	{
		if ((unsigned __int16)x_WORD_1805C2 < 0xCu)
		{
			if (x_WORD_1805C2 == 11)
				x_WORD_1805C2 = 7;
		}
		else if ((unsigned __int16)x_WORD_1805C2 <= 0xCu)
		{
			x_WORD_1805C2 = 1;
		}
		else if (x_WORD_1805C2 == 13)
		{
			x_WORD_1805C2 = 2;
		}
	}
	++*(x_BYTE *)(a1 + 25);
	return v27;
}
// 790E4: using guessed type void *off_790E4;
// 79118: using guessed type void *off_79118;
// 17DE38: using guessed type int x_DWORD_17DE38;
// 17DED4: using guessed type int (int)x_DWORD_17DED4;
// 17DEE4: using guessed type int x_DWORD_17DEE4_mouse_position;
// 17DEEE: using guessed type __int16 x_WORD_17DEEE;
// 17DF10: using guessed type char x_BYTE_17DF10_get_key_scancode;
// 1805C2: using guessed type __int16 x_WORD_1805C2;

/*void Debug_Blit()
{
	sub_75200_VGA_Blit640(480);
}*/

//----- (00079610) --------------------------------------------------------
char sub_79610_set_keys_dialog()//25a610
{
	int v0; // eax
	signed __int16 v1; // si
	signed __int16 *v2; // ebx
	Bit8u* v3; // edi
	int v4; // ST0C_4
	int v5; // ST04_4
	Bit8u* v6; // ST00_4
	x_WORD *i; // eax
	x_WORD *j; // ebx
	x_WORD *k; // eax
	x_WORD *l; // eax
	Bit8u* v13; // ebx
	Bit16s* v14; // edi
	Bit8u* m; // edi
	signed __int16 v16; // ax
	int v17; // eax
	char v18; // dl
	Bit8u* n; // eax
	signed __int16 v20; // ax
	int v21; // eax
	char v22; // dl
	Bit8u* ii; // eax
	signed __int16 v24; // dx
	unsigned int v25; // eax
	//int v26; // eax
	Bit8u v28[60]; // [esp+0h] [ebp-16h]
	Bit16s v29[10]; // [esp+3Ch] [ebp+26h]
	//__int16 v30; // [esp+46h] [ebp+30h]
	//__int16 v31; // [esp+48h] [ebp+32h]
	//__int16 v32; // [esp+4Ah] [ebp+34h]
	//__int16 v33; // [esp+4Ch] [ebp+36h]
	int v34; // [esp+68h] [ebp+52h]
	int v35; // [esp+6Ch] [ebp+56h]
	int v36; // [esp+70h] [ebp+5Ah]
	unsigned int v37; // [esp+74h] [ebp+5Eh]
	int v38; // [esp+78h] [ebp+62h]
	int v39; // [esp+7Ch] [ebp+66h]
	int v40; // [esp+80h] [ebp+6Ah]
	int v41; // [esp+84h] [ebp+6Eh]
	int v42; // [esp+88h] [ebp+72h]
	int v43; // [esp+8Ch] [ebp+76h]
	int v44; // [esp+90h] [ebp+7Ah]
	int v45; // [esp+94h] [ebp+7Eh]

	//HIWORD(v0) = HIWORD(x_DWORD_17DED4);
	v1 = 0;
	v39 = 359;
	v43 = 372;
	v42 = 410;
	v44 = 0;
	v41 = 0;
	v0 = xy_DWORD_17DED4_spritestr[107].sizey;
	v45 = 191;
	//LOWORD(v0) = (unsigned __int8)v0;
	v40 = v0;
	v38 = j___clock();
	v35 = v38;
	memset(v28, 0, 60);
	//v2 = (signed __int16 *)&unk_E28A8;
	v2 = (signed __int16 *)&x_BYTE_E25ED[0x2BB];
	sub_7A110_load_hscreen(x_WORD_180660_VGA_type_resolution, 15);
	v3 = x_DWORD_180628b_screen_buffer;
	x_DWORD_180628b_screen_buffer = x_DWORD_E9C38_smalltit;
	while (v2[0])
	{
		v4 = v2[1];
		v5 = v2[0];
		v6 = x_DWORD_E9C4C_langindexbuffer[v2[6]];
		v2 += 9;//ok
		sub_7FCB0_draw_text_with_border((int)v2, v6, v5, v39, v4, 4, 0, 0);
	}
	x_DWORD_180628b_screen_buffer = v3;
	sub_7B5A0_disable_enable();
	for (i = (x_WORD*)&x_BYTE_E25ED[0x2BB]; *i; *(i - 2) = 0)//delete
		i += 9;
	x_BYTE_E25ED[0x2BB + 14] = 1;

	sub_8CD27_set_cursor(xy_DWORD_17DED4_spritestr[110]);
	while (v44 != 2)
	{
		v34 = j___clock();
		v36 = v34;
		if (x_WORD_180660_VGA_type_resolution & 1)
			sub_9A128_copy_screen_320((void*)x_DWORD_E9C38_smalltit, (void*)x_DWORD_180628b_screen_buffer, 0xC8u);
		else
			sub_9A144_copy_screen_640((void*)x_DWORD_E9C38_smalltit, (void*)x_DWORD_180628b_screen_buffer, 0x1E0u);
		//backgroung
		if (x_WORD_17DEEE & 1)//switch blocks
		{
			for (j = (x_WORD*)&x_BYTE_E25ED[0x2BB]; *j; j += 9)//?
			{
				v29[5] = v45;
				v29[6] = j[1] - 4;
				v29[7] = v42;
				v29[8] = v40;
				if (sub_7B200_in_region(v29, x_DWORD_17DEE4_mouse_positionx, x_DWORD_17DEE4_mouse_positiony))
				{
					for (k = (x_WORD*)&x_BYTE_E25ED[0x2BB]; *k; *(k - 2) = 0)
						k += 9;//?
					j[7] = 1;
					v1 = 0;
					break;
				}
			}
		}
		v44 = sub_7E1F0_test_mouse_regions();
		if (v44 == 1)
		{
			x_D41A0_BYTEARRAY_4_struct.dwordindex_0 = 1;
			sub_5BCC0_set_any_variables1();
			for (l = (x_WORD*)&x_BYTE_E25ED[0x2BB]; *l; *(l - 2) = 0)
				l += 9;
			v1 = 0;
			x_BYTE_E25ED[0x2BB + 14] = 1;
		}
		v13 = &x_BYTE_EB39E_keys[0];//2bc39e
		v14 = (Bit16s*)&x_BYTE_E25ED[0x2BB];
		while (v13 < &x_BYTE_EB39E_keys[9] + 1)//drawing texts
		{
			memset(v28, 0, 60);
			if (!v14[7])
			{
				sub_79E10((char*)v28, *v13);
				sub_7FCB0_draw_text_with_border((int)v13, v28, v43, v42, v14[1], 4, 0, 0);
			}
			v13++;
			v14 += 9;
		}
		v2 = (signed __int16 *)&x_BYTE_E25ED[0x2BB];
		for (m = &x_BYTE_EB39E_keys[0]; m < &x_BYTE_EB39E_keys[9] + 1 && !v1; ++m)
		{
			v16 = v2[7];
			if (v16 >= 1u)
			{
				v37 = v34 - v38;
				if (v16 <= 1u)
				{
					memset(v28, 0, 60);
					sub_79E10((char*)v28, *m);
					sub_7FCB0_draw_text_with_border((int)v2, v28, v43, v42, v2[1], 4, 0, 0);
					if (v37 > 0x32)
					{
						v17 = v34;
						v2[7] = 2;
						v38 = v17;
					}
					sub_2BB40_draw_bitmap(v45, v2[1], xy_DWORD_17DED4_spritestr[107]);
					if (x_BYTE_17DF10_get_key_scancode && sub_79E10((char*)v28, x_BYTE_17DF10_get_key_scancode))
					{
						v18 = 0;
						if (m != &x_BYTE_EB39E_keys[6])
						{
							for (n = &x_BYTE_EB39E_keys[0]; n < &x_BYTE_EB39E_keys[9] + 1; n++)
							{
								if (x_BYTE_17DF10_get_key_scancode == *n)
								{
									v18 = 1;
									break;
								}
							}
						}
						if (!v18)
						{
							x_D41A0_BYTEARRAY_4_struct.dwordindex_0 = 1;
							v2 += 9;//?
							*m = x_BYTE_17DF10_get_key_scancode;
							*(v2 - 2) = 0;
							v20 = *v2;
							x_BYTE_17DF10_get_key_scancode = 0;
							if (v20)
							{
								v2[7] = 1;
							}
							else
							{
								v1 = 1;
								v38 = v34;
							}
						}
					}
				}
				else if (v16 == 2)
				{
					if ((v34 - v38) > 0x32)
					{
						v21 = v34;
						v2[7] = 1;
						v38 = v21;
					}
					sub_2BB40_draw_bitmap(v45, v2[1], xy_DWORD_17DED4_spritestr[107]);
					if (x_BYTE_17DF10_get_key_scancode)
					{
						if (sub_79E10((char*)v28, x_BYTE_17DF10_get_key_scancode))
						{
							v22 = 0;
							if (m != &x_BYTE_EB39E_keys[9] + 1)
							{
								for (ii = &x_BYTE_EB39E_keys[0]; ii < &x_BYTE_EB39E_keys[9] + 1; ++ii)
								{
									if (x_BYTE_17DF10_get_key_scancode == *ii)
									{
										v22 = 1;
										break;
									}
								}
							}
							if (!v22)
							{
								x_D41A0_BYTEARRAY_4_struct.dwordindex_0 = 1;
								*m = x_BYTE_17DF10_get_key_scancode;
								v2[7] = 0;
								x_BYTE_17DF10_get_key_scancode = 0;
								v24 = v2[9];
								v2 += 9;
								if (v24)
									v2[7] = 1;
								else
									v1 = 1;
							}
						}
					}
				}
			}
			v2 += 9;
		}
		//?
		if (v1 >= 1u)
		{
			v25 = v34 - v38;
			if (v1 <= 1u)
			{
				if (v25 > 0x32)
				{
					v1 = 2;
					v38 = v34;
				}
				sub_2BB40_draw_bitmap(283, 381, xy_DWORD_17DED4_spritestr[108]);
			}
			else if (v1 == 2 && v25 > 0x32)
			{
				v1 = 1;
				v38 = v34;
			}
		}
		if (x_WORD_180660_VGA_type_resolution & 1)
			sub_90478_VGA_Blit320();
		else
			sub_75200_VGA_Blit640(480);
		if (!v41)
		{
			sub_90B27_VGA_pal_fadein_fadeout(x_DWORD_17DE38, 0x20u, 0);
			v41 = 1;
		}
		if ((v36 - v35) > 0xA)
		{
			sub_7A060_get_mouse_and_keyboard_events();
			v35 = v36;
		}
		if (x_BYTE_17DF10_get_key_scancode == 1)
			v44 = 2;
		if (x_BYTE_17DF10_get_key_scancode == 28)
		{
			if (v1)
				v44 = 2;
		}
	}
	sub_81DB0_read_config();
	sub_90B27_VGA_pal_fadein_fadeout(0, 0x10u, 0);
	if (x_WORD_180660_VGA_type_resolution & 1)
	{
		sub_72883_clear_text_mode((void *)x_DWORD_180628b_screen_buffer, 0xC8u, 0);
	}
	else
	{
		sub_728A9_clear_graphics_mode((void *)x_DWORD_180628b_screen_buffer, 0x1E0u, 0);
	}
	if (x_WORD_180660_VGA_type_resolution & 1)
		sub_72883_clear_text_mode((void *)x_DWORD_E9C38_smalltit, 0xC8u, 0);
	else
		sub_728A9_clear_graphics_mode((void *)x_DWORD_E9C38_smalltit, 0x1E0u, 0);
	sub_7B5A0_disable_enable();
	if (x_WORD_180660_VGA_type_resolution & 1)
		sub_90478_VGA_Blit320();
	else
		sub_75200_VGA_Blit640(480);
	sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DE38, 0, 768);
	sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DE40, x_DWORD_17DEDC, 168081);
	sub_7AA70_load_and_decompres_dat_file(0, 0, 0, 0);
	sub_8CD27_set_cursor(*filearray_2aa18c[0].posistruct);
	sub_41A90_VGA_pallette_install(x_DWORD_17DE38);
	sub_8CD27_set_cursor(xy_DWORD_17DED4_spritestr[39]);
	if (x_WORD_180660_VGA_type_resolution & 1)
		sub_9A128_copy_screen_320((void*)x_DWORD_180628b_screen_buffer, (void*)x_DWORD_E9C38_smalltit, 0xC8u);
	else
		sub_9A144_copy_screen_640((void*)x_DWORD_180628b_screen_buffer, (void*)x_DWORD_E9C38_smalltit, 0x1E0u);
	return 1;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 98786: using guessed type int /*__fastcall*/ j___clock(x_DWORD, x_DWORD, x_DWORD);
// D41A4: using guessed type int x_DWORD_D41A4;
// E28B6: using guessed type __int16 x_WORD_E28B6;
// E9C38: using guessed type int x_DWORD_E9C38_smalltit;
// EB394: using guessed type int **filearray_2aa18c[0];
// EB39E: using guessed type char x_BYTE_EB39E_keys;
// EB3A4: using guessed type char x_BYTE_EB3A4;
// EB3A8: using guessed type char x_BYTE_EB3A8;
// 17DE38: using guessed type int x_DWORD_17DE38;
// 17DE40: using guessed type int x_DWORD_17DE40;
// 17DED4: using guessed type int (int)x_DWORD_17DED4;
// 17DEDC: using guessed type int x_DWORD_17DEDC;
// 17DEE4: using guessed type int x_DWORD_17DEE4_mouse_position;
// 17DEEE: using guessed type __int16 x_WORD_17DEEE;
// 17DF10: using guessed type char x_BYTE_17DF10_get_key_scancode;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00079E10) --------------------------------------------------------
signed int sub_79E10(char *a1, char a2)
{
	signed int result; // eax

	result = 0;
	switch (a2)
	{
	case 12://0c
	case 13://0d
		strcpy_s(a1, strlen("- ") + 1, "- ");
		result = 1;
		break;
	case 16://10
		strcpy_s(a1, strlen("Q ") + 1, "Q ");
		result = 1;
		break;
	case 17://11
		strcpy_s(a1, strlen("W ") + 1, "W ");
		result = 1;
		break;
	case 18://12
		strcpy_s(a1, strlen("E ") + 1, "E ");
		result = 1;
		break;
	case 20://14
		strcpy_s(a1, strlen("T ") + 1, "T ");
		result = 1;
		break;
	case 21://15
		strcpy_s(a1, strlen("Y ") + 1, "Y ");
		result = 1;
		break;
	case 22://16
		strcpy_s(a1, strlen("U ") + 1, "U ");
		result = 1;
		break;
	case 28://1c
		result = 1;
		strcpy_s(a1, strlen("ENTER") + 1, "ENTER");
		break;
	case 29://1d
		result = 1;
		strcpy_s(a1, strlen("CTRL") + 1, "CTRL");
		break;
	case 30://1e
		strcpy_s(a1, strlen("A ") + 1, "A ");
		result = 1;
		break;
	case 33://21
		strcpy_s(a1, strlen("F ") + 1, "F ");
		result = 1;
		break;
	case 34://22
		strcpy_s(a1, strlen("G ") + 1, "G ");
		result = 1;
		break;
	case 35://23
		strcpy_s(a1, strlen("H ") + 1, "H ");
		result = 1;
		break;
	case 36://24
		strcpy_s(a1, strlen("J ") + 1, "J ");
		result = 1;
		break;
	case 37://25
		strcpy_s(a1, strlen("K ") + 1, "K ");
		result = 1;
		break;
	case 39://27
		strcpy_s(a1, strlen("; ") + 1, "; ");
		result = 1;
		break;
	case 42://2a
		result = 1;
		strcpy_s(a1, strlen("Left Shift") + 1, "Left Shift");
		break;
	case 43://2b
		strcpy_s(a1, strlen("# ") + 1, "# ");
		result = 1;
		break;
	case 44://2c
		strcpy_s(a1, strlen("Z ") + 1, "Z ");
		result = 1;
		break;
	case 45://2d
		strcpy_s(a1, strlen("X ") + 1, "X ");
		result = 1;
		break;
	case 48://30
		strcpy_s(a1, strlen("B ") + 1, "B ");
		result = 1;
		break;
	case 49://31
		strcpy_s(a1, strlen("N ") + 1, "N ");
		result = 1;
		break;
	case 51://33
		strcpy_s(a1, strlen(", ") + 1, ", ");
		result = 1;
		break;
	case 52://34
		strcpy_s(a1, strlen(". ") + 1, ". ");
		result = 1;
		break;
	case 53://35
		strcpy_s(a1, strlen("/ ") + 1, "/ ");
		result = 1;
		break;
	case 54://36
		result = 1;
		strcpy_s(a1, strlen("Right Shift") + 1, "Right Shift");
		break;
	case 56://38
		strcpy_s(a1, strlen("Alt") + 1, "Alt");
		result = 1;
		break;
	case 72://48
		result = 1;
		strcpy_s(a1, strlen("UP") + 1, "UP");
		break;
	case 75://4b
		result = 1;
		strcpy_s(a1, strlen("LEFT") + 1, "LEFT");
		break;
	case 77://4d
		result = 1;
		strcpy_s(a1, strlen("RIGHT") + 1, "RIGHT");
		break;
	case 80://50
		result = 1;
		strcpy_s(a1, strlen("DOWN") + 1, "DOWN");
		break;
	default:
		return result;
	}
	return result;
}
// D1AE4: using guessed type int x_DWORD_D1AE4;
// D1B00: using guessed type __int16 x_WORD_D1B00;
// D1B04: using guessed type __int16 x_WORD_D1B04;
// D1B08: using guessed type __int16 x_WORD_D1B08;
// D1B0C: using guessed type __int16 x_WORD_D1B0C;
// D1B10: using guessed type __int16 x_WORD_D1B10;
// D1B14: using guessed type __int16 x_WORD_D1B14;
// D1B18: using guessed type __int16 x_WORD_D1B18;
// D1B1C: using guessed type __int16 x_WORD_D1B1C;
// D1B20: using guessed type __int16 x_WORD_D1B20;
// D1B24: using guessed type __int16 x_WORD_D1B24;
// D1B28: using guessed type __int16 x_WORD_D1B28;
// D1B2C: using guessed type __int16 x_WORD_D1B2C;
// D1B30: using guessed type __int16 x_WORD_D1B30;
// D1B34: using guessed type __int16 x_WORD_D1B34;
// D1B38: using guessed type __int16 x_WORD_D1B38;
// D1B3C: using guessed type __int16 x_WORD_D1B3C;
// D1B40: using guessed type __int16 x_WORD_D1B40;
// D1B44: using guessed type __int16 x_WORD_D1B44;
// D1B48: using guessed type __int16 x_WORD_D1B48;
// D1B4C: using guessed type __int16 x_WORD_D1B4C;
// D1B50: using guessed type __int16 x_WORD_D1B50;
// D1B54: using guessed type __int16 x_WORD_D1B54;

//----- (0007A060) --------------------------------------------------------
char sub_7A060_get_mouse_and_keyboard_events()//25B060
{
	char result; // al

	x_WORD_17DEEE = 0;
	if (x_WORD_180746)
		x_WORD_17DEEE = 1;
	if (x_WORD_180744)
		x_WORD_17DEEE |= 2;
	x_DWORD_17DEE4_mouse_positionx = x_WORD_E3760_mousex;//2b4760
	x_DWORD_17DEE4_mouse_positiony = x_WORD_E3762_mousey;//2b4762
	sub_7C050_get_keyboard_keys1();
	result = x_BYTE_17DF10_get_key_scancode;
	x_WORD_180744 = 0;
	x_WORD_180746 = 0;
	x_WORD_18074A = 0;
	x_WORD_18074C = 0;
	return result;
}
// E3760: using guessed type int x_DWORD_E3760;
// 17DEE4: using guessed type int x_DWORD_17DEE4_mouse_position;
// 17DEEE: using guessed type __int16 x_WORD_17DEEE;
// 17DF10: using guessed type char x_BYTE_17DF10_get_key_scancode;
// 180744: using guessed type __int16 x_WORD_180744;
// 180746: using guessed type __int16 x_WORD_180746;
// 18074A: using guessed type __int16 x_WORD_18074A;
// 18074C: using guessed type __int16 x_WORD_18074C;

//----- (0007A110) --------------------------------------------------------
void sub_7A110_load_hscreen(char a1, char a2)//25b110
{
	//int v2; // eax

	x_DWORD_17DE38 = *xadatapald0dat2.var28_begin_buffer;
	x_WORD_17DEEC = 0;
	x_DWORD_17DE40 = x_DWORD_180628b_screen_buffer;
	x_DWORD_17DEE0_filedesc = NULL;
	x_DWORD_17DEDC = 0;
	x_DWORD_17DE48c = x_D41A0_BYTEARRAY_4_0xE2_heapbuffer;
	sub_7B5D0();//25c5d0
	if (a1 == 8)
	{
		switch (a2)
		{
		case 4:
			x_DWORD_17DED8 = &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A + 0x36f44];//(Bit8u*)&loc_36F44 + x_DWORD_17DE48c;
			x_DWORD_17DED4 = &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A + 0x36c44];//(Bit8u*)&loc_36CAA + x_DWORD_17DE48c;
			x_DWORD_17DE4C = &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A + 0x36f44 + 2];//(Bit8u*)&loc_36F44 + x_DWORD_17DE48c + 2;
			x_DWORD_17DE54 = &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A + 0x36f44 + 16386];//(Bit8u*)&loc_36F44 + x_DWORD_17DE48c + 16386;
			x_DWORD_17DEC4 = &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A + 0x36f44 + 24631];//(Bit8u*)&loc_36F44 + x_DWORD_17DE48c + 24631;
			x_DWORD_17DE50 = &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A + 0x36f44 + 24631];//(Bit8u*)&loc_36F44 + x_DWORD_17DE48c + 24631;
			x_DWORD_17DEC0 = &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A + 0x36f44 + 22999];//(Bit8u*)&loc_36F44 + x_DWORD_17DE48c + 22999;
			qmemcpy(&x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A + 0x36f44 + 24631],
				//(char *)&loc_36F44 + x_DWORD_17DE48c + 24631,
				&x_D41A0_BYTEARRAY_0[11230 + 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 927],
				0x20u);
			x_DWORD_E9C38_smalltit = x_DWORD_17DE50 + 32;
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DE38, 0, 768);
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_E9C38_smalltit, x_DWORD_17DEDC, 168081);
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DE48c, x_DWORD_17DEDC, 102213);
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DED4, x_DWORD_17DEDC, 411);//19b
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DE54, 0x13ACCA, 1226);
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DEC0, 0x13B194, 548);//25ba70
			sub_7AA70_load_and_decompres_dat_file(0, 0, 0, 0);
			if (x_WORD_180660_VGA_type_resolution & 1)
				sub_98709_create_index_dattab_power(x_DWORD_17DED4, x_DWORD_17DED8, x_DWORD_17DE48c, xy_DWORD_17DED4_spritestr);
			else
				sub_9874D_create_index_dattab(x_DWORD_17DED4, x_DWORD_17DED8, x_DWORD_17DE48c, xy_DWORD_17DED4_spritestr);
			if (x_WORD_180660_VGA_type_resolution & 1)
				sub_98709_create_index_dattab_power(x_DWORD_17DEC0, x_DWORD_17DEC4, x_DWORD_17DE54, xy_DWORD_17DEC0_spritestr);
			else
				sub_9874D_create_index_dattab(x_DWORD_17DEC0, x_DWORD_17DEC4, x_DWORD_17DE54, xy_DWORD_17DEC0_spritestr);
			x_WORD_17DF06 = 72;
			x_WORD_17DF08 = 68;
			x_WORD_17DF0A = 69;
			x_WORD_17DF0C = 70;
			x_WORD_17DF0E = 71;
			break;
		case 6://adress 25b533
			x_DWORD_17DE54 = &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A + 301787];//(Bit8u*)x_DWORD_17DE48c + 301787;//49adb * //44ffef
			x_DWORD_17DEC4 = &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A + 316179];//(Bit8u*)x_DWORD_17DE48c + 316179;//4d313 //453827
			x_DWORD_17DE58 = &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A + 316179];//x_DWORD_17DE48c + 316179; * //453827
			x_DWORD_17DEC8 = &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A + 322754];//x_DWORD_17DE48c + 322754; * //4551d6
			x_DWORD_17DECC = &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A + 324380];//x_DWORD_17DE48c + 324380; //455830
			x_DWORD_17DED4 = &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A + 324380];//(Bit8u*)x_DWORD_17DE48c + 324380; *//455830
			x_DWORD_17DED8 = &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A + 326258];//(Bit8u*)x_DWORD_17DE48c + 326258; //455f86
			x_DWORD_17DE60 = x_DWORD_17DE44;//* //3f52a4
			x_DWORD_17DE64_game_world_map = &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A + 326258];//x_DWORD_17DE48c + 326258; * //455f86
			x_DWORD_17DE3C = &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A + 0x12C000 + 326258];//(Bit8u*)&unk_12C000 + x_DWORD_17DE48c + 326258;//* //581f86
			x_DWORD_17DEC0 = &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A + 314541];//(Bit8u*)x_DWORD_17DE48c + 314541; * //4531c1
			x_DWORD_17DE5C_border_bitmap = &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A + 0x12C000 + 326258 + 0x4000];//x_DWORD_17DE3C + 0x4000;//ok *//585f86
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DE54, 0x1641FC, 1214);//*
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DEC0, 0x1646BA, 589);
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DE58, 0x164907, 1191);
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DEC8, 0x164DAE, 543);//xx
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DE38, 0x13A9CA, 768);//ok
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DE64_game_world_map, 0xB2C47, 0x87D83);
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DE48c, 0x783BD, 103577);//ok
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DED4, 0x91856, 1027);
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DE3C, 0x13B3B8, 6760);
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DE60, 0x13CE20, 20581);
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DE5C_border_bitmap, 0x141E85, 13195);
			sub_7AA70_load_and_decompres_dat_file(0, 0, 0, 0);
			if (x_WORD_180660_VGA_type_resolution & 1)
			{
				sub_98709_create_index_dattab_power(x_DWORD_17DED4, x_DWORD_17DED8, x_DWORD_17DE48c, xy_DWORD_17DED4_spritestr);
				sub_98709_create_index_dattab_power(x_DWORD_17DEC0, x_DWORD_17DEC4, x_DWORD_17DE54, xy_DWORD_17DEC0_spritestr);//here
				sub_98709_create_index_dattab_power(x_DWORD_17DEC8, x_DWORD_17DECC, x_DWORD_17DE58, xy_DWORD_17DEC8_spritestr);
			}
			else
			{
				sub_9874D_create_index_dattab(x_DWORD_17DED4, x_DWORD_17DED8, x_DWORD_17DE48c, xy_DWORD_17DED4_spritestr);
				sub_9874D_create_index_dattab(x_DWORD_17DEC0, x_DWORD_17DEC4, x_DWORD_17DE54, xy_DWORD_17DEC0_spritestr);//here
				//34eec0 34eec4 34ee54
				sub_9874D_create_index_dattab(x_DWORD_17DEC8, x_DWORD_17DECC, x_DWORD_17DE58, xy_DWORD_17DEC8_spritestr);
			}

			x_WORD_17DF06 = 254;
			x_WORD_17DF08 = 255;
			x_WORD_17DF0A = 256;
			x_WORD_17DF0C = 257;
			x_WORD_17DF0E = 258;
			x_DWORD_17DEC0 += 6;
			xy_DWORD_17DEC0_spritestr = &xy_DWORD_17DEC0_spritestr[1];
			break;
		case 7:
			x_DWORD_17DE48c += 371200;
			x_DWORD_17DE54 = x_DWORD_17DE48c + 42428;
			x_DWORD_17DEC4 = x_DWORD_17DE48c + 50673;
			x_DWORD_17DED4 = x_DWORD_17DE48c + 50673;
			x_DWORD_17DED8 = x_DWORD_17DE48c + 50871;
			x_DWORD_17DE3C = x_DWORD_17DE48c + 50871;
			x_DWORD_17DE4C = x_DWORD_17DE48c + 51639;
			x_DWORD_17DEC0 = x_DWORD_17DE48c + 49041;
			x_DWORD_17DE50 = x_DWORD_17DE48c + 68023;
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DE38, 0x42471, 768);
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_D41A0_BYTEARRAY_4_0xE2_heapbuffer, x_DWORD_17DEDC, 82233);
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DE48c, 0x568AA, 21216);
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DED4, 375690, 148);
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DE54, 0x13ACCA, 1226);
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DEC0, 0x13B194, 548);
			if (x_WORD_180660_VGA_type_resolution & 1)
			{
				sub_98709_create_index_dattab_power(x_DWORD_17DED4, x_DWORD_17DED8, x_DWORD_17DE48c, xy_DWORD_17DED4_spritestr);
				sub_98709_create_index_dattab_power(x_DWORD_17DEC0, x_DWORD_17DEC4, x_DWORD_17DE54, xy_DWORD_17DEC0_spritestr);
			}
			else
			{
				sub_9874D_create_index_dattab(x_DWORD_17DED4, x_DWORD_17DED8, x_DWORD_17DE48c, xy_DWORD_17DED4_spritestr);
				sub_9874D_create_index_dattab(x_DWORD_17DEC0, x_DWORD_17DEC4, x_DWORD_17DE54, xy_DWORD_17DEC0_spritestr);
			}
			break;
		case 12:
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_E9C38_smalltit, 0x91C59, 134382);
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DE38, 0xB2947, 768);
			break;
		case 14:
			/*
			34EE48->55CCE4[4D54A]




			*/
			//[x_D41A0_BYTEARRAY_4_0xE2_heapbuffer+0x4D54A]

			x_DWORD_17DE54 = &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A + 224426];
			x_DWORD_17DEC4 = &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A + 232671];
			x_DWORD_17DED4 = &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A + 232671];
			x_DWORD_17DED8 = &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A + 233337];
			x_DWORD_17DE4C = &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A + 233339];
			x_DWORD_17DE50 = &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A + 249723];
			x_DWORD_17DEC0 = &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A + 231039];
			qmemcpy(
				&x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A + 249723],
				&x_D41A0_BYTEARRAY_0[11230 + 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 927],
				0x20u);//fix it
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DE54, 0x13ACCA, 1226);
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DEC0, 0x13B194, 548);
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A], 168849, 102213);
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DED4, 271062, 411);//19b
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_D41A0_BYTEARRAY_4_0xE2_heapbuffer, 0x91C59, 134382);
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DE38, 0xB2947, 768);
			if (x_WORD_180660_VGA_type_resolution & 1) {
				sub_98709_create_index_dattab_power(x_DWORD_17DED4, x_DWORD_17DED8, &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A], xy_DWORD_17DED4_spritestr);
				sub_98709_create_index_dattab_power(x_DWORD_17DEC0, x_DWORD_17DEC4, x_DWORD_17DE54, xy_DWORD_17DEC0_spritestr);
			}
			else
			{
				sub_9874D_create_index_dattab(x_DWORD_17DED4, x_DWORD_17DED8, &x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A], xy_DWORD_17DED4_spritestr);
				sub_9874D_create_index_dattab(x_DWORD_17DEC0, x_DWORD_17DEC4, x_DWORD_17DE54, xy_DWORD_17DEC0_spritestr);
			}

			//xy_DWORD_17DED4_spritestr[0x25]
			//-34eed4
			// 3dc74800d7c94800472c0b00050000004001c800
			// 48c73d - 000000000000020000005d5fc2220000
			//-34eed8
			// d7c94800
			//48c9d7(rozdil 29a) - 000000000000000000000000000000000
			//-34ee48
			//5e3a4500
			//453e5e - 6f005d3f3a13423a13200b	

			//pote
			//-34eed4
			// 3dc74800d7c94800472c0b00050000004001c800
			// 48c73d - 5e3a45000000603a45

			//dale [0034eed4]->48c73d->5e3a4500 ->6f005d3f3a13
			//+ d2=48c80f->47ae48 -> 26c2c2c2c2

			//48ae47002633 //47ae48->26c2c2c2c2c2

			/*
			34ee48=354f78->5e3a45
			34eed4=354f70->48c73d->000000000000000000

			*/
			break;
		case 15:
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", (Bit8u*)x_DWORD_E9C38_smalltit, 0x145210, 126188);
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", (Bit8u*)x_DWORD_17DE38, 0x163EFC, 768);
			break;
		default:
			return;
		}
	}
}
// 91856: using guessed type void *off_91856;
// B2947: using guessed type void *off_B2947;
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// E9C38: using guessed type int x_DWORD_E9C38_smalltit;
// EA3D8: using guessed type int *xadatapald0dat2.var28_begin_buffer;
// 17DE38: using guessed type int x_DWORD_17DE38;
// 17DE3C: using guessed type int x_DWORD_17DE3C;
// 17DE40: using guessed type int x_DWORD_17DE40;
// 17DE44: using guessed type int x_DWORD_17DE44;
// 17DE48: using guessed type int x_DWORD_17DE48;
// 17DE4C: using guessed type int (int)x_DWORD_17DE4C;
// 17DE50: using guessed type int (int)x_DWORD_17DE50;
// 17DE54: using guessed type int (int)x_DWORD_17DE54;
// 17DE58: using guessed type int x_DWORD_17DE58;
// 17DE5C: using guessed type int x_DWORD_17DE5C_border_bitmap;
// 17DE60: using guessed type int x_DWORD_17DE60;
// 17DE64: using guessed type int x_DWORD_17DE64_game_world_map;
// 17DEC0: using guessed type int (int)x_DWORD_17DEC0;
// 17DEC4: using guessed type int (int)x_DWORD_17DEC4;
// 17DEC8: using guessed type int x_DWORD_17DEC8;
// 17DECC: using guessed type int x_DWORD_17DECC;
// 17DED4: using guessed type int (int)x_DWORD_17DED4;
// 17DED8: using guessed type int x_DWORD_17DED8;
// 17DEDC: using guessed type int x_DWORD_17DEDC;
// 17DEE0: using guessed type int x_DWORD_17DEE0_filedesc;
// 17DEEC: using guessed type __int16 x_WORD_17DEEC;
// 17DF06: using guessed type __int16 x_WORD_17DF06;
// 17DF08: using guessed type __int16 x_WORD_17DF08;
// 17DF0A: using guessed type __int16 x_WORD_17DF0A;
// 17DF0C: using guessed type __int16 x_WORD_17DF0C;
// 17DF0E: using guessed type __int16 x_WORD_17DF0E;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0007AA70) --------------------------------------------------------
void sub_7AA70_load_and_decompres_dat_file(char* path, Bit8u* filebuffer, int position, int lenght)//25ba70
{
	//FILE* result; // eax

	if (x_DWORD_17DEE0_filedesc != NULL || (x_DWORD_17DEE0_filedesc = sub_98817_open(path, 512)))
	{
		//result = x_DWORD_17DEE0_filedesc;
		if (x_DWORD_17DEE0_filedesc != NULL)
		{
			if (filebuffer)
			{
				sub_9891E_seek(x_DWORD_17DEE0_filedesc, position, 0);
				sub_988A7_read(x_DWORD_17DEE0_filedesc, filebuffer, lenght);
				sub_5C3D0_file_decompress(filebuffer, filebuffer);
				x_DWORD_17DEDC = lenght + position;//endbuffer
			}
			else
			{
				sub_98882_close(x_DWORD_17DEE0_filedesc);
				x_DWORD_17DEE0_filedesc = NULL;
			}
		}
	}
	//return result;
}
// 17DEDC: using guessed type int x_DWORD_17DEDC;
// 17DEE0: using guessed type int x_DWORD_17DEE0_filedesc;

//----- (0007AB00) --------------------------------------------------------
void sub_7AB00_draw_menu_animations(/*__int16 a1,*/ int a2, signed __int16 *a3, unsigned __int8 a4)//25bb00
{
	//Bit8u* v4; // esi
	int v5; // eax
	int v6; // edi
	signed __int16 v7; // ax
	Bit8u* i; // ebx
	int v10; // [esp+0h] [ebp-4h]

	//HIBYTE(a1) = a4;//04
	//v4 = 0;
	if (a4 >= 4u)
	{
		if (a4 <= 4u)
		{
			a3 = (signed __int16 *)&unk_E1748;
		}
		else if (a4 == 6)
		{
			a3 = (signed __int16 *)&unk_E1784;
		}
	}
	while (a3[2])//fair animation
	{
		/*
		43d1be
		43d1f4 9c 213
		*/
		v5 = j___clock();
		v6 = v5;
		v10 = v5;
		sub_2BB40_draw_bitmap(a3[2], a3[3], xy_DWORD_17DED4_spritestr[a3[4]]);
		if ((v6 - *(Bit32s*)a3) >> 2 >= 1)
		{
			a2 = a3[4] + 1;
			v7 = *((Bit8u*)a3 + 11);
			a3[4] = a2;
			if (v7 < a2)
				a3[4] = *((Bit8u*)a3 + 10);
			//a1 = v10;
			*(Bit32s*)a3 = v10;
		}
		a3 += 6;
	}
	if (a4 == 4)//draw gold selected buttons
	{
		for (i = off_E1BAC; *((Bit32s*)(i + 10)); i += 44)
		{
			if (i[23] && i[24])
			{
				//v4 = i;
				sub_2BB40_draw_bitmap(*((Bit16s*)i + 5), *((Bit16s*)i + 6), xy_DWORD_17DED4_spritestr[i[21]]);
			}
		}
	}
	//return v4;
}
// 98786: using guessed type int /*__fastcall*/ j___clock(x_DWORD, x_DWORD, x_DWORD);
// 17DED4: using guessed type int (int)x_DWORD_17DED4;

//----- (0007AC00) --------------------------------------------------------
int sub_7AC00_load_and_set_graphics_and_pallette()//25BC00
{
	//char v0; // al
	//unsigned __int8 v1; // al
	//unsigned __int8 v2; // al

	if (!(x_WORD_180660_VGA_type_resolution & 8))
	{
		if (x_DWORD_E9C3C)
		{
			sub_83E80_sound_proc_99(x_DWORD_E9C3C);
			x_DWORD_E9C3C = 0;
		}
		sub_54600_mouse_reset();//235600 //mouse reset
		sub_6EBF0(&filearray_2aa18c[filearrayindex_POINTERSDATTAB]);//24FBF0 - 2AA18C//?tab
		if (x_WORD_180660_VGA_type_resolution == 1)
		{
			x_WORD_E29DA_type_resolution = x_WORD_180660_VGA_type_resolution;
			x_WORD_180660_VGA_type_resolution = 8;
			x_DWORD_E9C3C = (Bit8u*)sub_83CD0_malloc2(307200);
			sub_6EB90(&filearray_2aa18c[filearrayindex_POINTERSDATTAB]);
			memset((void*)*xadatapald0dat2.var28_begin_buffer, 0, 768);
			if (x_WORD_180660_VGA_type_resolution & 1)
			{
				//v0 = sub_5BE80_test_pallette(*xadatapald0dat2.var28_begin_buffer, 0, 0, 0);
				//sub_72883_clear_text_mode((int)x_DWORD_180628b_screen_buffer, (void *)x_DWORD_180628b_screen_buffer, 0xC8u, sub_5BE80_test_pallette(*xadatapald0dat2.var28_begin_buffer, 0, 0, 0));
			}
			else
			{
				//v1 = sub_5BE80_test_pallette(*xadatapald0dat2.var28_begin_buffer, 0, 0, 0);
				//sub_728A9_clear_graphics_mode(&x_DWORD_180628b_screen_buffer, 0x1E0u, sub_5BE80_test_pallette(*xadatapald0dat2.var28_begin_buffer, 0, 0, 0));//[351628d]3aa0a4,1E0,0 //fix it
			}
			memset((void*)*xadatapald0dat2.var28_begin_buffer, 0, 768);
			sub_41A90_VGA_pallette_install(*xadatapald0dat2.var28_begin_buffer);
			if (x_WORD_180660_VGA_type_resolution & 1)
				sub_90D6E_VGA_set_video_mode_320x200_and_pallette(*xadatapald0dat2.var28_begin_buffer);
			else
				sub_90E07_VGA_set_video_mode_640x480_and_pallette(*xadatapald0dat2.var28_begin_buffer);
			sub_41A90_VGA_pallette_install(*xadatapald0dat2.var28_begin_buffer);
			x_BYTE_EB3A8 = sub_5BE80_test_pallette(*xadatapald0dat2.var28_begin_buffer, 0, 0, 0);
			//x_BYTE_EB3A8 = v2;
			if (x_WORD_180660_VGA_type_resolution & 1)
				sub_72883_clear_text_mode(/*x_BYTE_EB3A8, */(void *)x_DWORD_180628b_screen_buffer, 0xC8u, x_BYTE_EB3A8);
			else
				sub_728A9_clear_graphics_mode(x_DWORD_180628b_screen_buffer, 0x1E0u, x_BYTE_EB3A8);
			sub_8CEDF_install_mouse();
			sub_8CD27_set_cursor(*filearray_2aa18c[0].posistruct);
		}
	}
	sub_8CD27_set_cursor(*filearray_2aa18c[0].posistruct);
	return 0;//fix it sub_8CD27_set_cursor((Bit8u**)**filearray_2aa18c[0]);
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D918C: using guessed type int **filearray_2aa18c;
// E29DA: using guessed type __int16 x_WORD_E29DA_type_resolution;
// E9C3C: using guessed type int x_DWORD_E9C3C;
// EA3D8: using guessed type int *xadatapald0dat2.var28_begin_buffer;
// EB394: using guessed type int **filearray_2aa18c[0];
// EB3A8: using guessed type char x_BYTE_EB3A8;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0007ADE0) --------------------------------------------------------
int sub_7ADE0(char a1)
{
	char v1; // al
	unsigned __int8 v2; // al
	unsigned __int8 v3; // al

	if (a1 == 1)
	{
		if (x_DWORD_E9C3C)
		{
			sub_83E80_sound_proc_99(x_DWORD_E9C3C);
			x_DWORD_E9C3C = 0;
		}
		sub_54600_mouse_reset();//mouse reset
		sub_6EBF0(&filearray_2aa18c[0]);
		x_WORD_180660_VGA_type_resolution = 1;
		x_WORD_E29DA_type_resolution = 1;
		x_DWORD_E9C3C = (Bit8u*)sub_83CD0_malloc2(64000);
		// fix it//sub_6EB90(&*filearray_2aa18c[0]);
		memset((void*)*xadatapald0dat2.var28_begin_buffer, 0, 768);
		if (x_WORD_180660_VGA_type_resolution & 1)
		{
			v1 = sub_5BE80_test_pallette(*xadatapald0dat2.var28_begin_buffer, 0, 0, 0);
			sub_72883_clear_text_mode(/*(int)x_DWORD_180628b_screen_buffer, */(void *)x_DWORD_180628b_screen_buffer, 0xC8u, v1);
		}
		else
		{
			v2 = sub_5BE80_test_pallette(*xadatapald0dat2.var28_begin_buffer, 0, 0, 0);
			sub_728A9_clear_graphics_mode((void *)x_DWORD_180628b_screen_buffer, 0x1E0u, v2);
		}
		memset((void*)*xadatapald0dat2.var28_begin_buffer, 0, 768);
		sub_41A90_VGA_pallette_install(*xadatapald0dat2.var28_begin_buffer);
		if (x_WORD_180660_VGA_type_resolution & 1)
			sub_90D6E_VGA_set_video_mode_320x200_and_pallette(*xadatapald0dat2.var28_begin_buffer);
		else
			sub_90E07_VGA_set_video_mode_640x480_and_pallette(*xadatapald0dat2.var28_begin_buffer);
		sub_41A90_VGA_pallette_install(*xadatapald0dat2.var28_begin_buffer);
		v3 = sub_5BE80_test_pallette(*xadatapald0dat2.var28_begin_buffer, 0, 0, 0);
		x_BYTE_EB3A8 = v3;
		if (x_WORD_180660_VGA_type_resolution & 1)
			sub_72883_clear_text_mode(/*v3, */(void *)x_DWORD_180628b_screen_buffer, 0xC8u, v3);
		else
			sub_728A9_clear_graphics_mode((void *)x_DWORD_180628b_screen_buffer, 0x1E0u, v3);
		sub_8CEDF_install_mouse();
	}
	sub_8CD27_set_cursor(*filearray_2aa18c[0].posistruct);
	return 0;//fix it sub_8CD27_set_cursor((Bit8u**)**filearray_2aa18c[0]);
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D918C: using guessed type int **filearray_2aa18c;
// E29DA: using guessed type __int16 x_WORD_E29DA_type_resolution;
// E9C3C: using guessed type int x_DWORD_E9C3C;
// EA3D8: using guessed type int *xadatapald0dat2.var28_begin_buffer;
// EB394: using guessed type int **filearray_2aa18c[0];
// EB3A8: using guessed type char x_BYTE_EB3A8;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0007B200) --------------------------------------------------------
bool sub_7B200_in_region(Bit16s* a1, Bit16s testx, Bit16s testy)//25c200
{
	Bit16s minx; // dx
	Bit16s miny; // bx
	bool result; // eax

	minx = a1[5];
	result = 0;
	if (testx >= minx && testx < minx + a1[7])
	{
		miny = a1[6];
		if (testy >= miny && testy < miny + a1[8])
			result = 1;
	}
	return result;
}

bool pre_sub_7B250(Bit32u var, Bit8u* var2) {
	bool callres = true;
	switch (var) {
	case 0x258350: {
		return sub_77350_new_game_dialog(var2);//258350 - new game
		break;
	}
	case 0x258980: {
		return sub_77980_exit_dialog(var2);//exit dialog
		break;
	}
	case 0x2589e0: {
		return sub_779E0_lang_setting_dialog(var2);
		break;
	}
	case 0x2590f0: {
		return sub_780F0_load_game_dialog(var2);//2590f0 - load
		break;
	}
	case 0x259730: {
		return sub_78730_save_game_dialog((Bit16s*)var2);//259730 -save
		break;
	}
	case 0x259e00: {
		return sub_78E00_set_player_name_dialog((Bit16s*)var2);//set user name
		break;
	}
	case 0x25a160: {//set joystick
		return sub_79160_set_joystick_dialog(var2);
		break;
	}
	case 0x25a610: {//set keys
		return sub_79610_set_keys_dialog();
		break;
	}
	case 0x25dcf0: {
		return sub_7CCF0(/*var*/);
		break;
	}
	case 0x25dd30: {
		return sub_7CD30(/*var*/);
		break;
	}
	case 0x25dca0: {
		return sub_7CCA0(/*var*/);
		break;
	}
	case 0x25dda0: {
		return sub_7CDA0(/*var*/);
		break;
	}
	case 0x25dbf0: {
		return sub_7CBF0(/*var*/);
		break;
	}
	case 0x25dc40: {
		return sub_7CC40(/*var*/);
		break;
	}
	}
	return callres;
}

//----- (0007B250) --------------------------------------------------------
char /*__fastcall*/ sub_7B250(/*int a1, int a2*//*, __int16 a3*/)//25c250
{
	Bit8u* i; // esi
	char result; // al
	Bit8u* j; // esi
	char v6; // ah
	__int16 v7; // bx
	Bit8u* v8; // esi
	Bit8u* v9; // edi
	Bit8u* v10; // edi
	//int v11; // eax
	int v12; // edx
	int v13; // eax
	Bit8u v14[36]; // [esp+0h] [ebp-24h]
	Bit8u v15[2]; // [esp+10h] [ebp-14h]

	//fix it
	v12 = 0;
	//fix it

	for (i = off_E1BAC; *((Bit16s*)i + 5); i += 44)
	{
		if (*((Bit16s*)i + 4) && *(Bit16s*)i)
		{
			if (pre_sub_7B250(*(Bit32u*)i, i))
			{
				*((Bit16s*)i + 4) = 0;
				sub_7B5A0_disable_enable();
			}
			if (*((Bit32s*)i + 1))
			{
				*((Bit16s*)i + 4) = 0;
				sub_6EDB0_set_mouse_position_by_res();
				sub_7A110_load_hscreen(x_WORD_180660_VGA_type_resolution, 4);
				sub_7B5A0_disable_enable();
				sub_8CD27_set_cursor(xy_DWORD_17DED4_spritestr[39]);
				if (*((Bit32s*)i + 1) == 2)
					*((Bit32s*)i + 1) = 0;
				return 1;
			}
			return 0;
		}
	}
	for (j = off_E1BAC; *((Bit16s*)j + 5); j += 44)//clear/set off_E1BAC
	{
		*((Bit16s*)j + 4) = 0;
		v6 = x_BYTE_17DF10_get_key_scancode;
		j[24] = 0;
		if (v6 == 1 && j[22] == 11)
			*((Bit16s*)j + 4) = 1;
	}
	if (x_BYTE_17DF10_get_key_scancode == 1)
	{
		x_BYTE_17DF10_get_key_scancode = 0;
	}
	else
	{
		j = off_E1BAC;
		if (*(Bit16s*)&off_E1BAC[10])
		{
			while (!sub_7B200_in_region((Bit16s*)j, x_DWORD_17DEE4_mouse_positionx, x_DWORD_17DEE4_mouse_positiony) || !j[23])
			{
				j += 44;
				if (!*((Bit16s*)j + 5))
					goto LABEL_28;
			}
			if (x_WORD_17DEEE & 1)
			{
				sub_8F100_sound_proc19(0, 14, 127, 64, 0x64u, 0, 3u);
				*((Bit16s*)j + 4) = 1;
				sub_7B5A0_disable_enable();
			}
			else
			{
				j[24] = 1;
				x_BYTE_17DBC6 = 1;
			}
		}
	}
LABEL_28:
	if (x_D41A0_BYTEARRAY_4_struct.byteindex_A != 1 || !x_BYTE_17DF13 || x_WORD_E29DC)
		return 0;
	//a3 = x_BYTE_17DBC6;
	if (x_BYTE_17DBC6 == 2)
	{
		x_DWORD_17DBB8[1] = j___clock();
		if ((x_DWORD_17DBB8[1] - x_DWORD_17DBB8[0]) / 0x64u > 1)
		{
			v7 = unk_E25DC[2 + 18 * (x_WORD_17DBC4++ + 1)];
			if (!v7)
				x_WORD_17DBC4 = 0;
			x_DWORD_17DBB8[0] = x_DWORD_17DBB8[1];
		}
		memset(&v14, 0, 36);
		v8 = &unk_E25DC[18 * x_WORD_17DBC4];
		qmemcpy(&v14, v8, 0x10u);
		qmemcpy(&v15, v8 + 0x10, 2u);
		v9 = off_E1BAC;
		sub_7E840_draw_textbox_with_line((Bit16u*)&v14, 80, 89);
		if (!*(Bit16s*)&off_E1BAC[10])
			return 0;
		do
		{
			if (v9[22] == x_BYTE_E25ED[18 * x_WORD_17DBC4])
			{
				v9[24] = 1;//turn on gold selection
				return 0;
			}
			v9 += 44;
		} while (*((Bit16s*)v9 + 5));
		result = 0;
	}
	else
	{
		if (x_BYTE_17DBC6 == 3)
		{
			x_DWORD_17DBB8[1] = j___clock();
			if ((x_DWORD_17DBB8[1] - x_DWORD_17DBB8[0]) / 0x64u > 1)
			{
				x_BYTE_17DBC6 = 2;
				return 0;
			}
			return 0;
		}
		v10 = (Bit8u*)&unk_E25DC;//2b35dc
		if (*((Bit16s*)&unk_E25DC + 1))
		{
			while (v10[17] != j[22])
			{
				v10 += 9;
				if (!v10[1])
					return 0;
			}
			memset(&v14, 0, 36);
			qmemcpy(&v14, v10, 0x10u);
			qmemcpy(&v15, v10 + 8, 2u);
			sub_7E840_draw_textbox_with_line((Bit16u*)&v14, 80, 89);
			v13 = j___clock();
			x_DWORD_17DBB8[1] = v13;
			x_DWORD_17DBB8[0] = v13;
			x_BYTE_17DBC6 = 3;
			result = 0;
		}
		else
		{
			result = 0;
		}
	}
	return result;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 98786: using guessed type int /*__fastcall*/ j___clock(x_DWORD, x_DWORD, x_DWORD);
// D41A4: using guessed type int x_DWORD_D41A4;
// E25DE: using guessed type __int16 x_WORD_E25DE[];
// E29DC: using guessed type __int16 x_WORD_E29DC;
// 17DBB8: using guessed type int x_DWORD_17DBB8;
// 17DBBC: using guessed type int x_DWORD_17DBBC;
// 17DBC4: using guessed type __int16 x_WORD_17DBC4;
// 17DBC6: using guessed type char x_BYTE_17DBC6;
// 17DED4: using guessed type int (int)x_DWORD_17DED4;
// 17DEE4: using guessed type int x_DWORD_17DEE4_mouse_position;
// 17DEEE: using guessed type __int16 x_WORD_17DEEE;
// 17DF10: using guessed type char x_BYTE_17DF10_get_key_scancode;
// 17DF13: using guessed type char x_BYTE_17DF13;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0007B5A0) --------------------------------------------------------
void sub_7B5A0_disable_enable()
{
	_disable();
	x_WORD_17DEEE = 0;
	x_WORD_180744 = 0;
	x_WORD_18074A = 0;
	x_WORD_180746 = 0;
	x_WORD_18074C = 0;
	_enable();
}
// 17DEEE: using guessed type __int16 x_WORD_17DEEE;
// 180744: using guessed type __int16 x_WORD_180744;
// 180746: using guessed type __int16 x_WORD_180746;
// 18074A: using guessed type __int16 x_WORD_18074A;
// 18074C: using guessed type __int16 x_WORD_18074C;

//----- (0007B5D0) --------------------------------------------------------
void sub_7B5D0()
{
	int v0; // eax

	sub_90B27_VGA_pal_fadein_fadeout(0, 0x10u, 0);
	v0 = (int)memset((void*)*xadatapald0dat2.var28_begin_buffer, 0, 768);
	BYTE1(v0) = x_WORD_180660_VGA_type_resolution;
	if (x_WORD_180660_VGA_type_resolution & 1)
		sub_72883_clear_text_mode(x_DWORD_180628b_screen_buffer, 0xC8u, 0);
	else
		sub_728A9_clear_graphics_mode(x_DWORD_180628b_screen_buffer, 0x1E0u, 0);
	if (x_WORD_180660_VGA_type_resolution & 1)
		sub_90478_VGA_Blit320();
	else
		sub_75200_VGA_Blit640(480);
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// EA3D8: using guessed type int *xadatapald0dat2.var28_begin_buffer;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0007B660) --------------------------------------------------------
int sub_7B660_draw_scroll_dialog2(int a1, int a2, __int16 a3, x_WORD *a4, Bit8u* a5, char a6)//25c660
{
	//int v6; // ebx
	unsigned __int8 v7; // al
	//Bit8u* v8; // edx
	//__int16 v9; // ax
	//int v10; // eax
	//int v11; // ecx
	//int v12; // eax
	//Bit8u* v13; // edx
	//int v14; // esi
	//int v15; // esi
	//int v16; // eax
	//Bit8u* v17; // ecx
	//__int16 v18; // bx
	//Bit8u* v19; // edx
	__int16 v20; // si
	__int16 v21; // ax
	__int16 v22; // cx
	__int16 v23; // bx
	int v24x; // edx
	//int v25x; // eax
	int v26; // eax
	__int16 v27; // cx
	//Bit8u* v28; // edx
	//Bit8u* v29; // eax
	int v30; // ebx
	unsigned __int8 v31; // al
	Bit16s v33[9]; // [esp+0h] [ebp-4Ch]
	//__int16 v34; // [esp+Ah] [ebp-42h]
	//__int16 v35; // [esp+Ch] [ebp-40h]
	//__int16 v36; // [esp+Eh] [ebp-3Eh]
	//__int16 v37; // [esp+10h] [ebp-3Ch]
	//int v38; // [esp+2Ch] [ebp-20h]
	//int v39; // [esp+30h] [ebp-1Ch]
	//int v40; // [esp+34h] [ebp-18h]
	//int v41; // [esp+38h] [ebp-14h]
	int v42; // [esp+3Ch] [ebp-10h]
	//int v43; // [esp+40h] [ebp-Ch]
	unsigned __int8 v44; // [esp+44h] [ebp-8h]
	unsigned __int8 v45; // [esp+48h] [ebp-4h]
	signed __int16 v46; // [esp+64h] [ebp+18h]


	//HIWORD(v6) = HIWORD(a4);
	v44 = 0;
	if (!a3)
	{
		sub_7C120_draw_bitmap_640(a1, a2, xy_DWORD_17DED4_spritestr[x_WORD_17DF06]);//unknown draw
		goto LABEL_31;
	}
	v45 = sub_5BE80_test_pallette(x_DWORD_17DE38, 0x25u, 0x1Fu, 0x19u);
	//v38 = (signed __int16)a2;
	//v41 = (signed __int16)a1;
	sub_7C120_draw_bitmap_640(a1, a2, xy_DWORD_17DED4_spritestr[x_WORD_17DF06]);//top scroll border
	v7 = sub_5BE80_test_pallette(x_DWORD_17DE38, 0x2Au, 0x24u, 0x1Du);
	sub_7C140_draw_text_background(
		(a1 + 10),
		a2 + xy_DWORD_17DED4_spritestr[x_WORD_17DF06].sizey - 2,
		xy_DWORD_17DED4_spritestr[x_WORD_17DF06].sizex - 22,
		a3,
		v7);
	//v39 = v45;
	//v40 = (signed __int16)(a3 + a2);
	sub_2BD10(a1 + 10, a2, a1 + 10, a3 + a2, v45);
	//v8 = xy_DWORD_17DED4_spritestr[x_WORD_17DF06].pointer;
	//v9 = a2 + xy_DWORD_17DED4_spritestr[x_WORD_17DF06].sizey - 2;
	sub_2BD10(a1 + xy_DWORD_17DED4_spritestr[x_WORD_17DF06].sizex - 12, a2 + xy_DWORD_17DED4_spritestr[x_WORD_17DF06].sizey - 2, a1 + xy_DWORD_17DED4_spritestr[x_WORD_17DF06].sizex - 12, a2 + xy_DWORD_17DED4_spritestr[x_WORD_17DF06].sizey - 2 + a3, v45); // to je ta linka, kterou je treba opravit
	sub_7C120_draw_bitmap_640(a1, a3 + a2, xy_DWORD_17DED4_spritestr[x_WORD_17DF06]);//bottom scroll border
	if (a4[5] >= a4[4])
	{
		switch (a6)
		{
		case 3:
			//v10 = a4[0];
			//v43 = v10 + 15;
			//v12 = 6 * x_WORD_17DF0C;
			//v13 = v12 + xy_DWORD_17DED4_spritestr[0].pointer;
			//v11 = a4[4];
			//v12 = a4[1];
			//v14 = xy_DWORD_17DED4_spritestr[x_WORD_17DF0C].sizey;
			//HIWORD(v14) = (signed __int16)a1 >> 15;
			//v15 = v11 + v12 - v14;
			v33[6] = a4[4] + a4[1] - xy_DWORD_17DED4_spritestr[x_WORD_17DF0C].sizey;//12 - v35
			v33[5] = a4[0] + 15;//10 - v34
			v33[7] = xy_DWORD_17DED4_spritestr[x_WORD_17DF0C].sizex;//14 adress 25c832
			v33[8] = xy_DWORD_17DED4_spritestr[x_WORD_17DF0C].sizey;//16
			if (sub_7B200_in_region(v33, x_DWORD_17DEE4_mouse_positionx, x_DWORD_17DEE4_mouse_positiony))//icon OK
			{
				sub_7C120_draw_bitmap_640(a4[0] + 15, v33[6], xy_DWORD_17DED4_spritestr[x_WORD_17DF0E]);
				if (x_WORD_17DEEE & 1)
					v44 = 1;
			}
			else
			{
				sub_7C120_draw_bitmap_640(a4[0] + 15, v33[6], xy_DWORD_17DED4_spritestr[x_WORD_17DF0C]);
			}
			//v16 = 3 * x_WORD_17DF06;
			//v16 = xy_DWORD_17DED4_spritestr[x_WORD_17DF06].sizex;
			//v6 = a4[0];
			v42 = xy_DWORD_17DED4_spritestr[x_WORD_17DF06].sizex - 12 + a4[0];
			//v17 = xy_DWORD_17DED4_spritestr[x_WORD_17DF06].pointer;
			//v16 = v42 - xy_DWORD_17DED4_spritestr[x_WORD_17DF08].sizex;
			//v33[6] = v15;
			//v18 = v42 - xy_DWORD_17DED4_spritestr[x_WORD_17DF08].sizex;
			v33[5] = v42 - xy_DWORD_17DED4_spritestr[x_WORD_17DF08].sizex;
			v33[7] = xy_DWORD_17DED4_spritestr[x_WORD_17DF08].sizex;
			//v39 = x_WORD_17DF0A;
			v33[8] = xy_DWORD_17DED4_spritestr[x_WORD_17DF0A].sizey;
			if (sub_7B200_in_region(v33, x_DWORD_17DEE4_mouse_positionx, x_DWORD_17DEE4_mouse_positiony))//icon X - cancel
			{
				sub_7C120_draw_bitmap_640(v42 - xy_DWORD_17DED4_spritestr[x_WORD_17DF08].sizex, v33[6], xy_DWORD_17DED4_spritestr[x_WORD_17DF0A]);
				if (x_WORD_17DEEE & 1)
					v44 = 2;
			}
			else
			{
				sub_7C120_draw_bitmap_640(v42 - xy_DWORD_17DED4_spritestr[x_WORD_17DF08].sizex, v33[6], xy_DWORD_17DED4_spritestr[x_WORD_17DF08]);//zlom
			}
			goto LABEL_23;
		case 1:
			//v19 = xy_DWORD_17DED4_spritestr[x_WORD_17DF0C].pointer;
			v20 = *a4 + 30;
			v21 = a4[4] + a4[1];
			v22 = xy_DWORD_17DED4_spritestr[x_WORD_17DF0C].sizey;
			v33[5] = *a4 + 30;
			v23 = v21 - v22;
			v33[5] = v21 - v22;
			v33[7] = xy_DWORD_17DED4_spritestr[x_WORD_17DF0C].sizex;
			v33[8] = xy_DWORD_17DED4_spritestr[x_WORD_17DF0C].sizey;
			if (sub_7B200_in_region(v33, x_DWORD_17DEE4_mouse_positionx, x_DWORD_17DEE4_mouse_positiony))
			{
				sub_7C120_draw_bitmap_640(v20, v23, xy_DWORD_17DED4_spritestr[x_WORD_17DF0E]);
				if (x_WORD_17DEEE & 1)
					v44 = 1;
				goto LABEL_23;
			}
			//v24 = (int)(int)x_DWORD_17DED4;
			v24x = x_WORD_17DF0E;
			break;
		case 2:
			v26 = 3 * x_WORD_17DF0C;
			v20 = *a4 + 40;
			v26 = xy_DWORD_17DED4_spritestr[x_WORD_17DF0C].sizey;
			v27 = a4[4];
			v42 = v26;
			v23 = v27 + a4[1] - v26;
			v33[6] = v27 + a4[1] - v26;
			//v39 = x_WORD_17DF08;
			//v28 = xy_DWORD_17DED4_spritestr[x_WORD_17DF0C].pointer;
			v33[5] = v20;
			v33[7] = xy_DWORD_17DED4_spritestr[x_WORD_17DF0C].sizex;
			v33[8] = xy_DWORD_17DED4_spritestr[x_WORD_17DF0C].sizey;
			if (sub_7B200_in_region(v33, x_DWORD_17DEE4_mouse_positionx, x_DWORD_17DEE4_mouse_positiony))
			{
				sub_7C120_draw_bitmap_640(v20, v23, xy_DWORD_17DED4_spritestr[x_WORD_17DF0A]);
				if (x_WORD_17DEEE & 1)
					v44 = 1;
				goto LABEL_23;
			}
			v24x = x_WORD_17DF08;
			//v25 = (int)x_DWORD_17DED4;
			break;
		default:
			goto LABEL_23;
		}
		sub_7C120_draw_bitmap_640(v20, v23, xy_DWORD_17DED4_spritestr[v24x]);
	LABEL_23:
		if (!v44)
		{
			if (x_BYTE_17DF10_get_key_scancode == 28)
			{
				v44 = 1;
			}
			else if (x_BYTE_17DF10_get_key_scancode == 1)
			{
				v44 = 2;
			}
		}
	}
	sub_6FC50(1);
	//v29 = xy_DWORD_17DED4_spritestr[x_WORD_17DF06].pointer;
	v30 = a1 + 10 + xy_DWORD_17DED4_spritestr[x_WORD_17DF06].sizex - 22;
	//v29 = xy_DWORD_17DED4_spritestr[x_WORD_17DF06].sizey;
	v46 = xy_DWORD_17DED4_spritestr[x_WORD_17DF06].sizey + 2 + a2;
	if (a5)
	{
		v31 = sub_5BE80_test_pallette(x_DWORD_17DE38, 0x16u, 0x10u, 9u);
		//"Exit Game" 16a 1c6 28 1 4c//adress 25cc27
		sub_7FCB0_draw_text_with_border(v30, a5, a1 + 10, v30, v46, 1, v31, 0);
	}
LABEL_31:
	if (v44)
		sub_8F100_sound_proc19(0, 14, 127, 64, 0x64u, 0, 3u);
	return v44;
}
// 17DE38: using guessed type int x_DWORD_17DE38;
// 17DED4: using guessed type int (int)x_DWORD_17DED4;
// 17DEE4: using guessed type int x_DWORD_17DEE4_mouse_position;
// 17DEEE: using guessed type __int16 x_WORD_17DEEE;
// 17DF06: using guessed type __int16 x_WORD_17DF06;
// 17DF08: using guessed type __int16 x_WORD_17DF08;
// 17DF0A: using guessed type __int16 x_WORD_17DF0A;
// 17DF0C: using guessed type __int16 x_WORD_17DF0C;
// 17DF0E: using guessed type __int16 x_WORD_17DF0E;
// 17DF10: using guessed type char x_BYTE_17DF10_get_key_scancode;

//----- (0007BEC0) --------------------------------------------------------
void sub_7BEC0()//
{
	Bit8u* result; // eax
	unsigned __int8 v1; // dl

	for (result = off_E1BAC; *((Bit16u*)result + 5); result += 44)
	{
		*((Bit16u*)result + 4) = 0;
		v1 = result[22];
		result[24] = 0;
		if (v1 >= 7u)
		{
			if (v1 <= 7u)
			{
				result[23] = x_D41A0_BYTEARRAY_4_struct.setting_216 != 0;
			}
			else if (v1 == 13)
			{
				result[23] = 1;
			}
		}
	}
	//return result;
	/*
	for (Bit32u i=0; *(Bit32u*)(off_E1BAC+i+10); i += 0x2c)//2b2bac
	{
		*(Bit32u*)(off_E1BAC + i + 8) = 0;
		*(off_E1BAC + i + 18) = 0;
		if (*(off_E1BAC + i + 16) >= 7u)
		{
			if (*(off_E1BAC + i + 16) <= 7u)
			{
				*(off_E1BAC + i + 17) = (x_D41A0_BYTEARRAY_4_struct.setting_216 != 0);
			}
			else if (*(off_E1BAC + i + 16) == 13)
			{
				*(off_E1BAC + i + 17) = 1;
			}
		}
	}*/
}
// D41A4: using guessed type int x_DWORD_D41A4;

//----- (0007BF20) --------------------------------------------------------
int sub_7BF20_draw_scroll_dialog(signed __int16 *a1)//25cf20
{
	Bit8u* v1; // esi
	int result; // eax
	int v3; // edx
	signed __int16 v4; // di
	signed __int16 v5; // cx
	int v6; // eax
	signed __int16 v7; // ax

	v1 = 0;
	result = 0;
	if (!*a1)
		return result;
	if (x_D41A0_BYTEARRAY_4_struct.byteindex_A == 1)
		x_BYTE_17DF13 = 0;
	sub_6FC50(1);
	if (!a1[7])
	{
		v4 = a1[5];
		if (v4)
		{
			if (v4 <= a1[4] - 1)
				a1[5] = v4 + 16;
			else
				a1[5] = a1[4];
		}
		else
		{
			a1[5]++;//next char
		}
		goto LABEL_14;
	}
	v5 = a1[5] - 16;
	a1[5] = v5;
	if (v5 >= 0)
	{
	LABEL_14:
		if (a1[5] > sub_6FC30_get34_sizey() + 10)
			v1 = x_DWORD_E9C4C_langindexbuffer[a1[6]];
		//160 1a 21 2b2cce? exit game 3
		v7 = sub_7B660_draw_scroll_dialog2(a1[0], a1[1], a1[5], a1, v1, a1[8] & 0xff);
		if (v7)
		{
			if (!a1[7])
				a1[7] = v7;
		}
		return 0;
	}
	a1[5] = 0;
	v6 = (int)x_D41A0_BYTEARRAY_4;
	LOWORD(v3) = a1[7];
	a1[7] = 0;
	if (*(x_BYTE *)(v6 + 10) == 1)
		x_BYTE_17DF13 = 1;
	return v3;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// 17DF13: using guessed type char x_BYTE_17DF13;

//----- (0007C020) --------------------------------------------------------
void sub_7C020(x_WORD *a1)//25d020
{
	//x_WORD *result; // eax

	//result = a1;
	if (a1[2])
	{
		a1[3] = 0;
		a1[2] = a1[3];
	}
	a1[5] = 0;
	//return result;
}

//----- (0007C050) --------------------------------------------------------
signed int /*__fastcall*/ sub_7C050_get_keyboard_keys1()//25d050
{
	Bit8u v2; // bl
	long v3; // eax  
	//Bit8u v3h;
	//Bit8u v4; // dx
	Bit8u v4h;
	Bit8u a1h;
	long v5; // esi
	bool ctrl_or_alt_pressed; // zf
	signed int result; // eax

	x_BYTE_17DF10_get_key_scancode = 0;
	x_BYTE_17DF11_last_key_status = 0;
	a1h = 2;

	//fix - __asm { int     16h; KEYBOARD - GET SHIFT STATUS }
	v2 = VGA_get_shift_status();
	//a1 = 1;
	//v2 = a1;
	if (v2)
	{
		if (v2 & 1)//right_shift
		{
			x_BYTE_17DF10_get_key_scancode = 54;
		}
		else if (v2 & 2)//left_shift
		{
			x_BYTE_17DF10_get_key_scancode = 42;
		}
		else if (v2 & 4)//ctrl
		{
			x_BYTE_17DF10_get_key_scancode = 29;
		}
		else if (v2 & 8)//alt
		{
			x_BYTE_17DF10_get_key_scancode = 56;
		}
	}
	v3 = j___clock();
	v5 = v3;
	do
	{
		/*ctrl_or_alt_pressed = (v2 & 1) == 0;
		if ( !(v2 & 1) )
		{
		  ctrl_or_alt_pressed = (v2 & 2) == 0;
		  if ( !(v2 & 2) )
		  {
			ctrl_or_alt_pressed = (v2 & 4) == 0;
			if ( !(v2 & 4) )
			{
			  ctrl_or_alt_pressed = (v2 & 8) == 0;
			  if ( !(v2 & 8) )
				break;//if not ctrl or alt end
			}
		  }
		}
		BYTE1(v3) = 2;
		HIBYTE(v4) = 2;
		a1 = VGA_get_shift_status();
		//fix - __asm { int     16h; KEYBOARD - GET SHIFT STATUS }
		if (ctrl_or_alt_pressed)
		  HIBYTE(v4) = 1;
		v2 = v3;
		v3 = j___clock() - v5;*/
		if (!(v2 & 1) && !(v2 & 2) && !(v2 & 4) && !(v2 & 8))
			break;
		v4h = 2;
		ctrl_or_alt_pressed = VGA_get_shift_status();
		if (ctrl_or_alt_pressed)
			v4h = 1;
		//v2 = v3;
		v3 = j___clock() - v5;
	} while (v3 <= 5);
	while (1)
	{
		result = sub_9A10A_check_keyboard(/*v3*/);//adress 25d101
		//'a' - 1e61
		//'b' - 3062
		//'UP' - 4800
		//'0' - 5230
		//'ENTER' - 1c0d
		if (!result)
			break;
		//BYTE1(result) = 0;
		result = VGA_read_char_from_buffer();
		// fix - __asm { int     16h; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY }
		x_BYTE_17DF11_last_key_status = result;
		v3 = result >> 8;
		x_BYTE_17DF10_get_key_scancode = v3;
	}
	return result;
}
// 98786: using guessed type int /*__fastcall*/ j___clock(x_DWORD, x_DWORD, x_DWORD);
// 17DF10: using guessed type char x_BYTE_17DF10_get_key_scancode;
// 17DF11: using guessed type char x_BYTE_17DF11_last_key_status;

//----- (0007C120) --------------------------------------------------------
void sub_7C120_draw_bitmap_640(Bit16s posx, Bit16s posy, posistruct tempstr)//25d120
{
	sub_2BB40_draw_bitmap(posx, posy, tempstr);//ebp
}

//----- (0007C140) --------------------------------------------------------
void sub_7C140_draw_text_background(Bit16s x1, Bit16s y1, Bit16s x2, Bit16s y2, unsigned __int8 a5)
{//black line in text
	Bit16s x1d; // si
	Bit16s y1d; // bx
	Bit16s x2d; // eax
	Bit16s y2d; // dx
	Bit16s v9; // cx

	x1d = x1;
	y1d = y1;
	x2d = x2;
	y2d = y2;
	if (x1 < 640 && y1 < 480)//neni vetsi nez obrazovka
	{
		if (y1 + y2 > 480)
			y2d = 480 - y1;
		if (x1 + x2 > 640)
			x2d = 640 - x1;
		if (x2d >= 1 && y2d >= 1)
		{
			if (y1 < 0)
			{
				y2d += y1;
				x1d = 0;
			}
			if ((x1 & 0x8000u) != 0)
			{
				x2d += x1;
				x1d = 0;
			}
			v9 = x2d;
			x2d += x1d;
			if (x2d >= 1)
			{
				x2d = y1d;
				if (y1d + y2d >= 1)
					sub_2BC80(x1d, x2d, v9, y2d, a5);
			}
		}
	}
}

//----- (0007C200) --------------------------------------------------------
char sub_7C200(unsigned __int8 a1)
{
	char result; // al

	result = 0;
	if (a1 == 32 || a1 >= 0x30u && a1 <= 0x39u || a1 >= 0x41u && a1 <= 0x5Au || a1 >= 0x61u && a1 <= 0x7Au)
		result = 1;
	return result;
}

//----- (0007C230) --------------------------------------------------------
int /*__fastcall*/ sub_7C230(int a1, int a2, signed __int16 *a3)
{
	//__int16 v3; // ax
	int v4; // edx
	x_WORD *v5; // eax
	int v6; // edx
	x_WORD *v7; // ebx
	int v8; // edx

	//fix it
	v4 = 0;
	v6 = 0;
	//fix it

	if (x_WORD_180660_VGA_type_resolution & 1)
	{
		a3 = (signed __int16 *)x_DWORD_E9C38_smalltit;
		sub_9A128_copy_screen_320((void*)x_DWORD_E9C38_smalltit, (void*)x_DWORD_180628b_screen_buffer, 0xC8u);
	}
	else
	{
		sub_9A144_copy_screen_640((void*)x_DWORD_E9C38_smalltit, (void*)x_DWORD_180628b_screen_buffer, 0x1E0u);
	}
	/*v3 = */sub_7C120_draw_bitmap_640(185, 232, xy_DWORD_17DED4_spritestr[66]);
	sub_7AB00_draw_menu_animations(/*v3,*/ v4, a3, 4u);
	v5 = (x_WORD *)sub_7BF20_draw_scroll_dialog(x_WORD_E1F70);
	v7 = v5;
	if ((x_WORD)v5)
	{
		x_WORD_E131A = 1;
		/*v5 = */sub_7C020(x_WORD_E1F70);
	}
	v8 = j___clock();
	if ((unsigned int)(v8 - x_DWORD_E208C) >> 2 >= 1)
	{
		if ((unsigned __int8)x_BYTE_E2097 >= x_WORD_E2094)
			++x_WORD_E2094;
		else
			x_WORD_E2094 = (unsigned __int8)x_BYTE_E2096;
		x_DWORD_E208C = v8;
	}
	sub_7C120_draw_bitmap_640(x_DWORD_17DEE4_mouse_positionx, x_DWORD_17DEE4_mouse_positiony, xy_DWORD_17DED4_spritestr[x_WORD_E2094]);
	if (x_WORD_180660_VGA_type_resolution & 1)
		sub_90478_VGA_Blit320();
	else
		sub_75200_VGA_Blit640(480);
	sub_7A060_get_mouse_and_keyboard_events();
	return (signed __int16)v7;
}
// 98786: using guessed type int /*__fastcall*/ j___clock(x_DWORD, x_DWORD, x_DWORD);
// E131A: using guessed type __int16 x_WORD_E131A;
// E208C: using guessed type int x_DWORD_E208C;
// E2094: using guessed type __int16 x_WORD_E2094;
// E2096: using guessed type char x_BYTE_E2096;
// E2097: using guessed type char x_BYTE_E2097;
// E9C38: using guessed type int x_DWORD_E9C38_smalltit;
// 17DED4: using guessed type int (int)x_DWORD_17DED4;
// 17DEE4: using guessed type int x_DWORD_17DEE4_mouse_position;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0007C390) --------------------------------------------------------
signed int sub_7C390()
{
	signed int result; // eax
	int *v1; // ebx
	x_WORD *v2; // ebx
	int v3; // esi
	signed __int16 v4; // dx
	__int16 i; // ax
	int v6; // [esp+0h] [ebp-8h]
	char *v7; // [esp+4h] [ebp-4h]

	v6 = (int)x_DWORD_E9C38_smalltit;
	x_DWORD_E9C38_smalltit = (Bit8u*)x_D41A0_BYTEARRAY_4_0xE2_heapbuffer;
	v7 = (char *)(x_DWORD_E9C38_smalltit[307200]);
	x_WORD_17DF00 = x_WORD_17DEFE;
	qmemcpy(x_BYTE_E1BA4, x_BYTE_E1B9C, sizeof(x_BYTE_E1BA4));
	if ((unsigned __int16)sub_7CE50())
	{
		x_DWORD_E9C38_smalltit = (Bit8u*)v6;
		result = 1;
	}
	else
	{
		qmemcpy(x_BYTE_E1B9C, &x_BYTE_17DE68[11 * sub_74515() + 1], sizeof(x_BYTE_E1B9C));
		v1 = (int *)(&off_E1E98 + 6 * x_WORD_17DEF4);
		if (x_WORD_180660_VGA_type_resolution & 1)
			sub_9A128_copy_screen_320((void*)x_DWORD_E9C38_smalltit, (void*)x_DWORD_180628b_screen_buffer, 0xC8u);
		else
			sub_9A144_copy_screen_640((void*)x_DWORD_E9C38_smalltit, (void*)x_DWORD_180628b_screen_buffer, 0x1E0u);
		switch (x_WORD_17DEF6)
		{
		case 1:
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", (Bit8u*)v7, *v1, v1[1]);
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", (Bit8u*)x_DWORD_17DE3C, v1[2], v1[3]);
			x_WORD_17DF02 = 0;
			x_WORD_17DEF6 = 3;
			v2 = off_E1D64;
			v3 = sub_7CB10();
			break;
		case 2:
			x_WORD_17DF02 += 16;
			sub_7C9D0(x_WORD_17DF02);
			if ((unsigned __int16)x_WORD_17DF02 < 0xFFu)
				goto LABEL_13;
			sub_7C7C0((unsigned __int8)x_WORD_17DEF2, (int)x_DWORD_E9C38_smalltit);
			x_WORD_17DEF6 = 1;
			v2 = off_E1D64;
			v3 = sub_7CB10();
			break;
		case 3:
			sub_7C720(x_WORD_17DEF4, v7);
			x_WORD_17DF02 += 16;
			sub_7C800(x_WORD_17DF02);
			if ((unsigned __int16)x_WORD_17DF02 <= 0xFEu)
				goto LABEL_13;
			x_WORD_17DEF6 = 4;
			v2 = off_E1D64;
			v3 = sub_7CB10();
			break;
		case 5:
			sub_7C7C0((unsigned __int8)x_WORD_17DEF2, (int)x_DWORD_E9C38_smalltit);
			x_WORD_17DF02 = 255;
			sub_7C9D0(255);
			x_WORD_17DEF6 = 1;
			x_BYTE_17DE72[11 * x_WORD_17DEFC] = x_BYTE_17DE72[11 * sub_74515()];
			goto LABEL_13;
		default:
		LABEL_13:
			v2 = off_E1D64;
			v3 = sub_7CB10();
			break;
		}
		while (v2[5])
		{
			if (*((x_BYTE *)v2 + 23) && *((x_BYTE *)v2 + 24))
				sub_7C120_draw_bitmap_640(v2[5], v2[6], xy_DWORD_17DED4_spritestr[v2[21]]);
			v2 += 22;
		}
		sub_7C140_draw_text_background(382, 18, 16, 16, 0);
		sprintf_s((char *const)(int)x_DWORD_17DE50, 512, "%d", (unsigned __int16)x_WORD_17DEFA);
		sub_7FAE0_draw_text((char *)(int)x_DWORD_17DE50, 382, 398, 18, 0);
		sub_7D380();
		sub_7D310();
		v4 = 0;
		for (i = 0; i < 8; i++)
		{
			if (x_BYTE_E1BA4[i] != x_BYTE_E1B9C[i])
			{
				v4 = 1;
				break;
			}
		}
		if (v4 || x_WORD_17DF00 != x_WORD_17DEFE)
			sub_41A90_VGA_pallette_install((unsigned __int8 *)x_DWORD_17DE38);
		x_DWORD_E9C38_smalltit = (Bit8u*)v6;
		result = v3;
	}
	return result;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// D41A4: using guessed type int x_DWORD_D41A4;
// E1E98: using guessed type void *off_E1E98;
// E9C38: using guessed type int x_DWORD_E9C38_smalltit;
// 17DE38: using guessed type int x_DWORD_17DE38;
// 17DE3C: using guessed type int x_DWORD_17DE3C;
// 17DE50: using guessed type int (int)x_DWORD_17DE50;
// 17DED4: using guessed type int (int)x_DWORD_17DED4;
// 17DEF2: using guessed type __int16 x_WORD_17DEF2;
// 17DEF4: using guessed type __int16 x_WORD_17DEF4;
// 17DEF6: using guessed type __int16 x_WORD_17DEF6;
// 17DEFA: using guessed type __int16 x_WORD_17DEFA;
// 17DEFC: using guessed type __int16 x_WORD_17DEFC;
// 17DEFE: using guessed type __int16 x_WORD_17DEFE;
// 17DF00: using guessed type __int16 x_WORD_17DF00;
// 17DF02: using guessed type __int16 x_WORD_17DF02;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0007C710) --------------------------------------------------------
void sub_7C710()
{
	x_WORD_17DF02 = 0;
}
// 17DF02: using guessed type __int16 x_WORD_17DF02;

//----- (0007C720) --------------------------------------------------------
int sub_7C720(unsigned __int8 a1, x_BYTE *a2)
{
	void **v2; // eax
	__int16 v3; // bx
	__int16 v4; // dx
	__int16 v5; // cx
	__int16 v6; // ax

	v2 = &off_E1E98 + 6 * a1;
	v3 = *((x_WORD *)v2 + 9);
	v4 = *((x_WORD *)v2 + 8);
	v5 = *((x_WORD *)v2 + 10);
	v6 = *((x_WORD *)v2 + 11);
	if (v3 + v6 > 480)
		v6 = 480 - v3;
	if (v5 + v4 > 640)
		v4 = v5 + v4 - 640;
	return sub_85BF5(a2, (int)x_DWORD_E9C38_smalltit, v4, v3, v5, v6);
}
// E1E98: using guessed type void *off_E1E98;
// E9C38: using guessed type int x_DWORD_E9C38_smalltit;

//----- (0007C7C0) --------------------------------------------------------
int sub_7C7C0(int a1, int a2)
{
	return sub_85C42(a2, 208, 111, 200, 369, 0x9Fu);
}

//----- (0007C800) --------------------------------------------------------
void sub_7C800(signed __int16 a1)
{
	signed __int16 v1; // bx
	unsigned __int8 *v2; // edx
	Bit8u* v3; // eax
	unsigned __int8 v4; // ch
	unsigned __int8 v5; // ch
	unsigned __int8 v6; // ch
	unsigned __int8 *v7; // edx
	unsigned __int8 v8; // ch
	x_BYTE *v9; // eax
	unsigned __int8 v10; // ch
	unsigned __int8 v11; // ch
	unsigned __int8 v12; // cl
	unsigned __int8 *v13; // edx
	unsigned __int8 v14; // ch
	int v15; // eax
	unsigned __int8 v16; // ch
	unsigned __int8 v17; // ch
	Bit8u* v19; // [esp+4h] [ebp-4h]

	v1 = a1;
	if ((unsigned __int16)a1 > 0xFFu)
		v1 = 255;
	v2 = (unsigned __int8 *)(x_DWORD_17DE3C + 477);
	v19 = x_DWORD_17DE38 + 765;
	v3 = (unsigned __int8 *)(x_DWORD_17DE38 + 477);
	while (v3 < v19)
	{
		v4 = *v2;
		if (*v3 < *v2)
			*v3 = (unsigned __int16)(v4 * v1) >> 8;
		else
			*v3 = v4;
		v5 = v2[1];
		if (v3[1] < v5)
			v3[1] = (unsigned __int16)(v5 * v1) >> 8;
		else
			v3[1] = v5;
		v6 = v2[2];
		if (v3[2] < v6)
			v3[2] = (unsigned __int16)(v6 * v1) >> 8;
		else
			v3[2] = v6;
		v3 += 3;
		v2 += 3;
	}
	v7 = (unsigned __int8 *)(x_DWORD_17DE38 + 444);
	v8 = *(x_BYTE *)(x_DWORD_17DE3C + 444);
	v9 = (x_BYTE *)(x_DWORD_17DE3C + 444);
	if (*(x_BYTE *)(x_DWORD_17DE38 + 444) < v8)
		*v7 = (unsigned __int16)(v8 * v1) >> 8;
	else
		*v7 = v8;
	v10 = v9[1];
	if (v7[1] < v10)
		v7[1] = (unsigned __int16)(v10 * v1) >> 8;
	else
		v7[1] = v10;
	v11 = v9[2];
	if (v7[2] < v11)
		v7[2] = (unsigned __int16)(v1 * (unsigned __int8)v9[2]) >> 8;
	else
		v7[2] = v11;
	v12 = v7[3];
	v13 = v7 + 3;
	v14 = v9[3];
	v15 = (int)(v9 + 3);
	if (v12 < v14)
		*v13 = (unsigned __int16)(v14 * v1) >> 8;
	else
		*v13 = v14;
	v16 = *(x_BYTE *)(v15 + 1);
	if (v13[1] < v16)
		v13[1] = (unsigned __int16)(v16 * v1) >> 8;
	else
		v13[1] = v16;
	v17 = *(x_BYTE *)(v15 + 2);
	if (v13[2] < v17)
		v13[2] = (unsigned __int16)(*(unsigned __int8 *)(v15 + 2) * v1) >> 8;
	else
		v13[2] = v17;
	sub_9A0FC_wait_to_screen_beam();
	sub_41A90_VGA_pallette_install((unsigned __int8 *)x_DWORD_17DE38);
}
// 17DE38: using guessed type int x_DWORD_17DE38;
// 17DE3C: using guessed type int x_DWORD_17DE3C;

//----- (0007C9D0) --------------------------------------------------------
void sub_7C9D0(signed __int16 a1)
{
	signed __int16 v1; // cx
	unsigned __int8 *i; // eax
	__int16 v3; // bx
	int v4; // eax
	int v5; // eax
	unsigned int v7; // [esp+4h] [ebp-4h]

	v1 = a1;
	if ((unsigned __int16)a1 > 0xFFu)
		v1 = 255;
	v7 = (int)x_DWORD_17DE38 + 765;
	for (i = (unsigned __int8 *)(x_DWORD_17DE38 + 477);
		(unsigned int)i < v7;
		*(i - 1) = v3 - ((unsigned __int16)(v3 * v1) >> 8))
	{
		*i -= (unsigned __int16)(v1 * *i) >> 8;
		i[1] -= (unsigned __int16)(v1 * i[1]) >> 8;
		v3 = i[2];
		i += 3;
	}
	v4 = (int)x_DWORD_17DE38;
	*(x_BYTE *)(x_DWORD_17DE38 + 447) -= (unsigned __int16)(v1 * *(unsigned __int8 *)(x_DWORD_17DE38 + 447)) >> 8;
	*(x_BYTE *)(v4 + 448) -= (unsigned __int16)(v1 * *(unsigned __int8 *)(v4 + 448)) >> 8;
	*(x_BYTE *)(v4 + 449) -= (unsigned __int16)(v1 * *(unsigned __int8 *)(v4 + 449)) >> 8;
	v5 = (int)x_DWORD_17DE38;
	*(x_BYTE *)(x_DWORD_17DE38 + 444) -= (unsigned __int16)(v1 * *(unsigned __int8 *)(x_DWORD_17DE38 + 444)) >> 8;
	*(x_BYTE *)(v5 + 445) -= (unsigned __int16)(v1 * *(unsigned __int8 *)(v5 + 445)) >> 8;
	*(x_BYTE *)(v5 + 446) -= (unsigned __int16)(*(unsigned __int8 *)(v5 + 446) * v1) >> 8;
	sub_9A0FC_wait_to_screen_beam();
	sub_41A90_VGA_pallette_install((unsigned __int8 *)x_DWORD_17DE38);
}
// 17DE38: using guessed type int x_DWORD_17DE38;

//----- (0007CB10) --------------------------------------------------------
int sub_7CB10()
{
	int(**i)(); // ebx
	int result; // eax
	int(**j)(); // ebx
	int(**v3)(); // ebx

	for (i = (int(**)())off_E1D64; *((x_WORD *)i + 5); i += 11)
	{
		if (*((x_WORD *)i + 4) && *i)
		{
			result = ((int(*)(int(**)()))*i)(i);
			if ((x_BYTE)result)
			{
				*((x_WORD *)i + 4) = 0;
				sub_7B5A0_disable_enable();
				result = 1;
			}
			else
			{
				LOWORD(result) = 0;
				*((x_WORD *)i + 4) = 0;
			}
			return result;
		}
	}
	for (j = (int(**)())off_E1D64; *((x_WORD *)j + 5); *((x_BYTE *)j - 20) = 0)
	{
		j += 11;
		*((x_WORD *)j - 18) = 0;
	}
	v3 = (int(**)())off_E1D64;
	if (!off_E1D64[5])
		return 0;
	while (!sub_7B200_in_region((x_WORD*)v3, x_DWORD_17DEE4_mouse_positionx, x_DWORD_17DEE4_mouse_positiony) || !*((x_BYTE *)v3 + 23))
	{
		v3 += 11;
		if (!*((x_WORD *)v3 + 5))
			return 0;
	}
	if (x_WORD_17DEEE & 1)
	{
		*((x_WORD *)v3 + 4) = 1;
		sub_7B5A0_disable_enable();
		sub_8F100_sound_proc19(0, 14, 127, 64, 0x64u, 0, 3u);
	}
	else
	{
		*((x_BYTE *)v3 + 24) = 1;
	}
	return 0;
}
// 17DEE4: using guessed type int x_DWORD_17DEE4_mouse_position;
// 17DEEE: using guessed type __int16 x_WORD_17DEEE;

//----- (0007CBF0) --------------------------------------------------------
char sub_7CBF0()//25dbf0
{
	x_WORD_17DEF8 = 0;
	x_BYTE_17DE71[11 * x_WORD_17DEFC] = 3;
	x_WORD_17DF02 = 0;
	x_WORD_17DEF6 = 2;
	x_WORD_17DEF2 = x_WORD_17DEF4;
	return 0;
}
// 17DEF2: using guessed type __int16 x_WORD_17DEF2;
// 17DEF4: using guessed type __int16 x_WORD_17DEF4;
// 17DEF6: using guessed type __int16 x_WORD_17DEF6;
// 17DEF8: using guessed type __int16 x_WORD_17DEF8;
// 17DEFC: using guessed type __int16 x_WORD_17DEFC;
// 17DF02: using guessed type __int16 x_WORD_17DF02;

//----- (0007CC40) --------------------------------------------------------
char sub_7CC40()//25dc40
{
	x_WORD_17DF02 = 0;
	x_WORD_17DEF8 = 1;
	x_BYTE_17DE71[11 * x_WORD_17DEFC] = 4;
	x_WORD_17DEF6 = 2;
	x_WORD_17DEF2 = x_WORD_17DEF4;
	return 0;
}
// 17DEF2: using guessed type __int16 x_WORD_17DEF2;
// 17DEF4: using guessed type __int16 x_WORD_17DEF4;
// 17DEF6: using guessed type __int16 x_WORD_17DEF6;
// 17DEF8: using guessed type __int16 x_WORD_17DEF8;
// 17DEFC: using guessed type __int16 x_WORD_17DEFC;
// 17DF02: using guessed type __int16 x_WORD_17DF02;

//----- (0007CCA0) --------------------------------------------------------
int sub_7CCA0()//25dca0
{
	int v0; // ebx
	int v1; // ebx

	v0 = x_WORD_17DEFC;
	if (v0 == sub_74515() && x_WORD_17DEFE == 1 || (v1 = x_WORD_17DEFC, v1 != sub_74515()))
		x_BYTE_17DE71[11 * x_WORD_17DEFC] = 1;
	return 0;
}
// 17DEFC: using guessed type __int16 x_WORD_17DEFC;
// 17DEFE: using guessed type __int16 x_WORD_17DEFE;

//----- (0007CCF0) --------------------------------------------------------
int sub_7CCF0()//25dcf0
{
	int v0; // eax
	char v1; // dl

	v0 = 11 * x_WORD_17DEFC;
	v1 = x_BYTE_17DE72[v0];
	if (v1 > 50)
	{
		x_BYTE_17DE72[v0] = v1 - 1;
		x_BYTE_17DE71[11 * x_WORD_17DEFC] = 6;
	}
	return 0;
}
// 17DEFC: using guessed type __int16 x_WORD_17DEFC;

//----- (0007CD30) --------------------------------------------------------
int sub_7CD30()//25dd30
{
	char *v0; // esi
	char v2; // [esp+0h] [ebp-Ch]
	char v3; // [esp+4h] [ebp-8h]

	v0 = (char*)(&off_D9204_wizards_names1)[1 + x_BYTE_17DE72[11 * x_WORD_17DEFC]];//fix it
	qmemcpy(&v2, v0, 4u);
	qmemcpy(&v3, v0 + 4, sizeof(v3));
	if (v2 && v2 != 48)
	{
		++x_BYTE_17DE72[11 * x_WORD_17DEFC];
		x_BYTE_17DE71[11 * x_WORD_17DEFC] = 6;
	}
	return 0;
}
// D9208: using guessed type const char *off_D9208;
// 17DEFC: using guessed type __int16 x_WORD_17DEFC;

//----- (0007CDA0) --------------------------------------------------------
int sub_7CDA0()//25dda0
{
	x_BYTE_17DE71[11 * x_WORD_17DEFC] = 5;
	return 0;
}
// 17DEFC: using guessed type __int16 x_WORD_17DEFC;

//----- (0007CDC0) --------------------------------------------------------
int sub_7CDC0(unsigned __int8 a1, unsigned __int8 a2)//25ddc0
{
	x_BYTE *v2; // eax
	int v3; // edx

	v2 = (x_BYTE *)(3 * (2 * a1 + 134) + *xadatapald0dat2.var28_begin_buffer);
	v3 = 3 * a2;
	*v2 = x_BYTE_E1711[v3];
	v2[1] = x_BYTE_E1712[v3];
	v2[2] = x_BYTE_E1713[v3];
	v2[3] = x_BYTE_E172C[v3];
	v2[4] = x_BYTE_E172D[v3];
	v2[5] = x_BYTE_E172E[v3];
	return 0;
}
// EA3D8: using guessed type int *xadatapald0dat2.var28_begin_buffer;

//----- (0007CE50) --------------------------------------------------------
signed int sub_7CE50()//25de50
{
	__int16 v0; // bx
	char *v1; // esi
	char *v2; // edx
	__int16 i; // bx
	int v4; // eax
	__int16 v5; // di
	x_BYTE *v6; // esi
	int v7; // edi
	int v8; // eax
	char v9; // ST10_1
	int v10; // edi
	int v11; // eax
	char v12; // ST10_1
	int v13; // edi
	int v14; // eax
	char v15; // ST10_1
	__int16 v16; // dx
	int v17; // eax
	char v18; // ch
	signed int v20; // [esp+0h] [ebp-Ch]

	v20 = 0;
	x_BYTE_17DE68[11 * x_WORD_17DEFC] = 1;
	sub_74374();
	v0 = 0;
	sub_7438A((int)x_BYTE_17DE68, 0xBu);
	do
	{
		v1 = &x_BYTE_17DE68[11 * sub_74515() + 1];
		v2 = &x_BYTE_17DE68[11 * v0 + 1];
		qmemcpy(v2, v1, 8u);
		++v0;
		qmemcpy(x_BYTE_E131C, v2, sizeof(x_BYTE_E131C));
	} while (v0 < 8);
	for (i = 0; i < 8; i++)
	{
		v4 = 11 * i;
		if (x_BYTE_17DE68[v4])
		{
			switch (x_BYTE_17DE71[v4])
			{
			case 1:
				v5 = 0;
				while (v5 < 7)
				{
					v6 = (x_BYTE *)(3 * (2 * v5 + 134) + x_DWORD_17DE38);
					*v6 = 0;
					v6 += 3;
					*(v6 - 2) = 0;
					*(v6 - 1) = 0;
					v6[1] = 0;
					v6[2] = 0;
					*v6 = 0;
					++v5;
					sub_41A90_VGA_pallette_install((unsigned __int8 *)x_DWORD_17DE38);
				}
				x_BYTE_17DE68[11 * i] = 0;
				sub_73AA1(i);
				if (i == x_WORD_17DEFC)
					v20 = 1;
				break;
			case 2:
				v7 = sub_74515();
				if (v7 == sub_74536())
				{
					if (i <= 0)
						x_BYTE_17DE69[11 * sub_74515() + i] = i;
					else
						x_BYTE_17DE69[11 * sub_74515() + i] = i - 1;
					v8 = sub_74515();
					v9 = sub_7D230(1, x_BYTE_17DE69[11 * v8 + i], i);
					x_BYTE_17DE69[11 * sub_74515() + i] = v9;
				}
				break;
			case 3:
				v13 = sub_74515();
				if (v13 == sub_74536() && (unsigned __int16)x_WORD_17DEFE < 7u)
				{
					v14 = sub_74515();
					v15 = sub_7D230(1, x_BYTE_17DE69[11 * v14 + i], i);
					x_BYTE_17DE69[11 * sub_74515() + i] = v15;
				}
				break;
			case 4:
				v10 = sub_74515();
				if (v10 == sub_74536() && (unsigned __int16)x_WORD_17DEFE < 7u)
				{
					v11 = sub_74515();
					v12 = sub_7D230(0, x_BYTE_17DE69[11 * v11 + i], i);
					x_BYTE_17DE69[11 * sub_74515() + i] = v12;
				}
				break;
			case 5:
				*(x_WORD *)(x_D41A0_BYTEARRAY_0 + 12) = x_WORD_17DEFC;
				v16 = x_BYTE_17DE72[11 * sub_74515()];
				v17 = (int)x_D41A0_BYTEARRAY_4;
				v18 = x_D41A0_BYTEARRAY_4_struct.setting_byte1_22;
				x_D41A0_BYTEARRAY_4_struct.levelnumber_43 = v16;
				*(x_BYTE *)(v17 + 22) = v18 | 0x10;
				*(x_WORD *)(x_D41A0_BYTEARRAY_0 + 14) = x_WORD_17DEFE;
				sub_7449C();
				x_WORD_E29DC = 1;
				v20 = 1;
				break;
			case 6:
				x_BYTE_17DE72[11 * x_WORD_17DEFC] = x_BYTE_17DE72[11 * i];
				break;
			default:
				continue;
			}
		}
	}
	x_BYTE_17DE71[11 * x_WORD_17DEFC] = 0;
	x_WORD_17DEF4 = x_BYTE_17DE69[11 * sub_74515() + x_WORD_17DEFC];
	sub_7D1F0();
	return v20;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// E29DC: using guessed type __int16 x_WORD_E29DC;
// 17DE38: using guessed type int x_DWORD_17DE38;
// 17DEF4: using guessed type __int16 x_WORD_17DEF4;
// 17DEFC: using guessed type __int16 x_WORD_17DEFC;
// 17DEFE: using guessed type __int16 x_WORD_17DEFE;

//----- (0007D1F0) --------------------------------------------------------
int sub_7D1F0()//25e1f0
{
	int result; // eax

	result = 0;
	x_WORD_17DEFE = 0;
	do
	{
		if (x_BYTE_17DE68[11 * (signed __int16)result])
			++x_WORD_17DEFE;
		++result;
	} while ((signed __int16)result < 8);
	return result;
}
// 17DEFE: using guessed type __int16 x_WORD_17DEFE;

//----- (0007D230) --------------------------------------------------------
signed int sub_7D230(char a1, unsigned __int8 a2, unsigned __int8 a3)//25e230
{
	signed int v3; // ebx
	__int16 v4; // si
	__int16 v5; // si
	signed __int16 v7; // [esp+0h] [ebp-8h]
	signed __int16 v8; // [esp+4h] [ebp-4h]

	v3 = a2;
	if (a1)
	{
		do
		{
			if ((--v3 & 0x8000u) != 0)
				v3 = 7;
			v5 = 0;
			v7 = 0;
			while (v5 < 8)
			{
				if (v5 != a3 && x_BYTE_17DE68[11 * v5] && x_BYTE_17DE69[11 * sub_74515() + v5] == (x_WORD)v3)
				{
					v7 = 1;
					break;
				}
				++v5;
			}
		} while (v7);
	}
	else
	{
		do
		{
			if ((signed __int16)++v3 > 7)
				v3 = 0;
			v4 = 0;
			v8 = 0;
			while (v4 < 8)
			{
				if (v4 != a3 && x_BYTE_17DE68[11 * v4] && x_BYTE_17DE69[11 * sub_74515() + v4] == (x_WORD)v3)
				{
					v8 = 1;
					break;
				}
				++v4;
			}
		} while (v8);
	}
	return v3;
}

//----- (0007D310) --------------------------------------------------------
int sub_7D310()//25e310
{
	__int16 v0; // bx
	int result; // eax
	int v2; // eax
	__int16 v3; // [esp+0h] [ebp-4h]

	v0 = 0;
	v3 = 0;
	do
	{
		result = 11 * v0;
		if (x_BYTE_17DE68[result])
		{
			if (v0 != x_WORD_17DEFC)
			{
				v2 = sub_74515();
				result = sub_7CDC0(v3++, x_BYTE_17DE69[11 * v2 + v0]);
			}
		}
		++v0;
	} while (v0 < 8);
	return result;
}
// 17DEFC: using guessed type __int16 x_WORD_17DEFC;

//----- (0007D380) --------------------------------------------------------
unsigned int sub_7D380()//25e380
{
	int v0; // eax
	//char v2; // [esp+0h] [ebp-28h]

	sub_85C42((int)x_DWORD_180628b_screen_buffer, 246, 14, 109, 14, 0x9Fu);
	sub_6FC50(1);
	v0 = x_BYTE_17DE72[11 * x_WORD_17DEFC];
	sprintf_s(printbuffer, 512, "%d. %s", v0 - 49, off_D9204_wizards_names1[v0]);
	return sub_7FAE0_draw_text(printbuffer, 246, 355, 14, 0);
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// D9204: using guessed type const char *off_D9204_wizards_names1[2];
// 17DEFC: using guessed type __int16 x_WORD_17DEFC;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;

//----- (0007D400) --------------------------------------------------------
void sub_7D400_draw_texts_and_play_sounds(int a1, __int16 a2, __int16 a3, char a4)//25e400
{
	x_WORD *v4; // ebx
	int v5; // edx
	__int16 v6; // cx
	Bit8u* i; // ebx
	unsigned __int8 v8; // al
	char v9; // cl
	x_WORD *jj; // ebx
	unsigned __int16 v11; // ax
	int v12; // edx
	char v13; // dl
	int v14; // edx
	int v15; // edx
	Bit16s v16; // eax
	int v17; // eax
	int v18; // edi
	char *v20; // eax
	char *v21; // edx
	x_WORD *v22; // eax
	__int16 v23; // bx
	signed __int16 *k; // eax
	Bit16u v25[18]; // [esp+0h] [ebp-54h]
	//__int16 v26; // [esp+2h] [ebp-52h] v25[1]
	//__int16 v27; // [esp+4h] [ebp-50h] v25[2]
	//__int16 v28; // [esp+6h] [ebp-4Eh] v25[3]
	//__int16 v29; // [esp+8h] [ebp-4Ch] v25[4]
	//__int16 v30; // [esp+Ch] [ebp-48h] v25[5]
	//__int16 v31; // [esp+Eh] [ebp-46h] v25[6]
	char v32; // [esp+10h] [ebp-44h]
	int v33; // [esp+24h] [ebp-30h]
	__int16 v34; // [esp+30h] [ebp-24h]
	__int16 v35; // [esp+32h] [ebp-22h]
	int v36; // [esp+34h] [ebp-20h]
	Bit8u* v37; // [esp+3Ch] [ebp-18h]
	Bit8u* v38; // [esp+40h] [ebp-14h]
	posistruct* v38s;
	int v39; // [esp+44h] [ebp-10h]
	x_WORD *v40; // [esp+48h] [ebp-Ch]
	char *v41; // [esp+4Ch] [ebp-8h]
	int v42; // [esp+50h] [ebp-4h]

	//fix it
	v5 = 0;
	v12 = 0;
	v14 = 0;
	v15 = 0;
	//fix it

	v42 = -1;
	v4 = (x_WORD*)&x_BYTE_E25ED[0xdb];
	v41 = 0;
	v40 = 0;
	v39 = j___clock();
	while (v4[4])
	{
		if (x_BYTE_E1B82 != 1 || (v6 = v4[6], v6 != 85) && v6 != 86)
			sub_81CA0(a2, v5, a2, a3, (int)v4);
		v4 += 15;
	}

	for (i = &unk_E17CC[0x194]; *((x_WORD *)i + 2); i += 22)//draw new game flag
	{
		v8 = i[18];
		if (v8 >= 1u)
		{
			if (v8 <= 1u)
			{
				v41 = (char*)i;
				sub_7E5A0_pre_draw(a2, v5, a2, a3, i, 37, 43);
			}
			else if (v8 == 2)
			{
				LOBYTE(v5) = a4;
				if (a4 == 3 || a4 == 5)
				{
					v9 = i[19];
					v40 = (x_WORD*)i;
					if (v9)
					{
						if (v9 == 1)
						{
							if (sub_7E5A0_pre_draw(a2, v5, a2, a3, i, 70, 83))
							{
								*((x_WORD *)i + 8) = 33;
								i[19] = 2;
							}
						}
						else
						{
							sub_7E5A0_pre_draw(a2, v5, a2, a3, i, 33, 35);
						}
					}
					else
					{
						sub_8F100_sound_proc19(0, 41, 127, 64, 0x64u, 0, 2u);
						i[19] = 1;
					}
				}
			}
		}
		if (i[18] == 2)
			break;
	}
	for (jj = x_WORD_E2970; jj[6]; jj = (x_WORD *)((char *)jj + 17))
	{
		v11 = jj[6];
		if (v11 < 1u)
			continue;
		if (v11 <= 1u)
		{
			memset(&v33, 0, 22);
			v33 = *(x_DWORD *)jj;
			LOWORD(v36) = jj[7];
			v34 = jj[4];
			v35 = jj[5];
			sub_7E5A0_pre_draw(a2, v12, a2, a3, (Bit8u*)&v33, 305, 311);
		LABEL_40:
			*(x_DWORD *)jj = v33;
			jj[7] = v36;
			continue;
		}
		if (v11 == 2 && a4 == 3)
		{
			v13 = *((x_BYTE *)jj + 16);
			if (!v13)
			{
				sub_8F100_sound_proc19(0, 41, 127, 64, 0x64u, 0, 2u);
				*((x_BYTE *)jj + 16) = 1;
				continue;
			}
			if (v13 != 1)
			{
				memset(&v33, 0, 22);
				v33 = *(x_DWORD *)jj;
				LOWORD(v36) = jj[7];
				v34 = jj[4];
				v35 = jj[5];
				sub_7E5A0_pre_draw(a2, v15, a2, a3, (Bit8u*)&v33, 270, 272);
				goto LABEL_40;
			}
			memset(&v33, 0, 22);
			v33 = *(x_DWORD *)jj;
			LOWORD(v36) = jj[7];
			v34 = jj[4];
			v35 = jj[5];
			if (sub_7E5A0_pre_draw(a2, v14, a2, a3, (Bit8u*)&v33, 70, 83))
			{
				jj[7] = 270;
				*((x_BYTE *)jj + 16) = 2;
			}
			else
			{
				jj[7] = v36;
			}
			*(x_DWORD *)jj = v33;
		}
	}

	//LOBYTE(j) = a4;
	if (a4 == 3 && x_D41A0_BYTEARRAY_4_struct.byteindex_A == 1)
	{
		v38 = x_DWORD_17DEC0;
		v37 = x_DWORD_17DEC4;
		x_DWORD_17DEC0 = x_DWORD_17DEC8;		
		x_DWORD_17DEC4 = x_DWORD_17DECC;

		v38s = xy_DWORD_17DEC0_spritestr;//fixed
		xy_DWORD_17DEC0_spritestr = xy_DWORD_17DEC8_spritestr;//fixed
		/*
		posistruct* xy_DWORD_17DED4_spritestr;
posistruct* xy_DWORD_17DEC0_spritestr;
posistruct* xy_DWORD_17DEC8_spritestr;
		*/

		//HIWORD(v16) = HIWORD(x_DWORD_17DECC);
		if (x_DWORD_17DB70str.x_WORD_17DB74 == 0)
		{
			if (!x_DWORD_17DB70str.x_WORD_17DB74)
			{
				v16 = v40 != 0;
				//BYTE1(v16) = 0;
				v17 = v16 + 1;
				x_DWORD_17DB70str.x_WORD_17DB74 = v17;
				x_DWORD_17DB70str.x_DWORD_17DB70 = j___clock();
			}
		}
		else if (x_DWORD_17DB70str.x_WORD_17DB74 == 1u)
		{
			if (v41)
			{
				if (3 == x_DWORD_17DB70str.x_BYTE_17DB8F)
				{
					memset(v25, 0, 36);
					qmemcpy(v25, unk_E24F2, 0x10u);
					qmemcpy(&v32, (char *)&unk_E24F2 + 0x10u, 2u);
					v25[1] = *((x_WORD *)v41 + 6) - 80 - a2;
					v25[2] = *((x_WORD *)v41 + 7) - 60 - a3;
					v25[3] = *((x_WORD *)v41 + 6) + 16 - a2;
					v25[4] = *((x_WORD *)v41 + 7) - 60 - a3;
					v25[6] = *((x_WORD *)v41 + 6) + 16 - a2;
					v25[7] = *((x_WORD *)v41 + 7) - 4 - a3;
					v25[0] = 464;
					v18 = (int)v40;
					sub_7E840_draw_textbox_with_line(v25, 238, 264);
					if (v18)
					{
						if ((v39 - x_DWORD_17DB70str.x_DWORD_17DB70) / 0x64u > 8)
						{
							x_DWORD_17DB70str.x_DWORD_17DB70 = v39;
							x_DWORD_17DB70str.x_WORD_17DB74 = 2;
						}
					}
				}
			}
		}
		else if (x_DWORD_17DB70str.x_WORD_17DB74 == 2)
		{
			if (v40)
			{
				if (x_DWORD_17DB70str.x_BYTE_17DB8F == 3)
				{
					memset(v25, 0, 36);
					v25[1] = v40[6] - 80 - a2;
					v25[2] = v40[7] - 60 - a3;
					v25[3] = v40[6] + 16 - a2;
					v25[4] = v40[7] - 60 - a3;
					v25[6] = v40[6] + 16 - a2;
					v25[7] = v40[7] - 4 - a3;
					v25[0] = 465;
					sub_7E840_draw_textbox_with_line(v25, 238, 264);
					if (v41)
					{
						if ((v39 - x_DWORD_17DB70str.x_DWORD_17DB70) / 0x64u > 8)
						{
							x_DWORD_17DB70str.x_DWORD_17DB70 = v39;
							x_DWORD_17DB70str.x_WORD_17DB74 = 1;
						}
					}
				}
			}
		}
		x_DWORD_17DEC0 = v38;
		x_DWORD_17DEC4 = v37;
		xy_DWORD_17DEC0_spritestr = v38s;
	}
	if (x_DWORD_17DB70str.x_BYTE_17DB8E)
		return;

	if (x_DWORD_17DB70str.x_WORD_17DB8A != -1)
	{
		v20 = (char *)&unk_E17CC[0x194];
		v21 = 0;
		while (*((x_WORD *)v20 + 2))
		{
			if (v20[18] == 1)
				v21 = v20;
			v20 += 22;
		}
		v22 = (x_WORD*)&unk_E17CC[0x194];
		v23 = 0;
		while (v22[2])
		{
			if (v23 == x_DWORD_17DB70str.x_WORD_17DB8A)
			{
				sub_7DA70(v22[6], v22[7], *((x_WORD *)v21 + 6), *((x_WORD *)v21 + 7), a2, a3);
				return;
			}
			v22 += 11;
			++v23;
		}
		for (k = x_WORD_E2970; k[6]; k = (signed __int16 *)((char *)k + 17))
		{
			if (x_DWORD_17DB70str.x_WORD_17DB8A == k[3])
			{
				sub_7DA70(k[4], k[5], x_WORD_E196C[11 * k[2]], x_WORD_E196E[11 * k[2]], a2, a3);
				return;
			}
		}
		return;
	}

	if (v41 && v40)
	{
		sub_7DA70(*((x_WORD *)v41 + 6), *((x_WORD *)v41 + 7), v40[6], v40[7], a2, a3);
		return;
	}

	if (!v41 || v40)
		return;
	sub_7DA70(*((x_WORD *)v41 + 6), *((x_WORD *)v41 + 7), x_WORD_E1B66, x_WORD_E1B68, a2, a3);
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 98786: using guessed type int /*__fastcall*/ j___clock(x_DWORD, x_DWORD, x_DWORD);
// D41A4: using guessed type int x_DWORD_D41A4;
// E196C: using guessed type __int16 x_WORD_E196C[];
// E196E: using guessed type __int16 x_WORD_E196E[];
// E1B66: using guessed type __int16 x_WORD_E1B66;
// E1B68: using guessed type __int16 x_WORD_E1B68;
// E1B82: using guessed type char x_BYTE_E1B82;
// 17DB70: using guessed type int x_DWORD_17DB70;
// 17DB74: using guessed type __int16 x_WORD_17DB74;
// 17DB8A: using guessed type __int16 x_WORD_17DB8A;
// 17DB8E: using guessed type char x_BYTE_17DB8E;
// 17DB8F: using guessed type char x_BYTE_17DB8F;
// 17DEC0: using guessed type int (int)x_DWORD_17DEC0;
// 17DEC4: using guessed type int (int)x_DWORD_17DEC4;
// 17DEC8: using guessed type int x_DWORD_17DEC8;
// 17DECC: using guessed type int x_DWORD_17DECC;

//----- (0007DA70) --------------------------------------------------------
void sub_7DA70(__int16 a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6)//25ea70
{
	int v6; // edx
	int v7; // ebx
	__int16 v8; // ax
	int v9; // edx
	__int16 v10; // ax
	Bit8u* v11; // ebx
	int v12; // edx
	__int16 v14; // [esp+0h] [ebp-10h]
	__int16 v15; // [esp+2h] [ebp-Eh]
	__int16 v16; // [esp+8h] [ebp-8h]
	__int16 v17; // [esp+Ah] [ebp-6h]

	x_WORD_17E074 = a3;
	v6 = xy_DWORD_17DED4_spritestr[37].sizex;
	x_WORD_17E06C = a1;
	v7 = v6 / 2;
	v8 = v6 / 2 + a3;
	v9 = xy_DWORD_17DED4_spritestr[37].sizey;
	x_WORD_17E074 = v8;
	v9 /= 2;
	x_WORD_17E076 = v9 + a4;
	x_WORD_17E06C = v7 + a1;
	x_WORD_17E06E = v9 + a2;
	v16 = v8;
	v17 = v9 + a4;
	v14 = v7 + a1;
	v15 = v9 + a2;
	v10 = sub_581E0((Bit16u*)&v16, (Bit16u*)&v14);
	if (v10 <= 1024 || v10 >= 1536)
	{
		if (v10 <= 1536 || v10 >= 2048)
		{
			if (v10 <= 2048 && v10 <= 0 || v10 >= 512)
			{
				if (v10 <= 512 || v10 >= 1024)
				{
					if (v10 != 2048 && v10)
					{
						if (v10 == 512)
						{
							if (x_BYTE_17E082 != 9)
							{
								x_WORD_17E080 = 9;
								x_BYTE_17E083 = 12;
								x_BYTE_17E082 = 9;
							}
						}
						else if (v10 == 1024)
						{
							if (x_BYTE_17E082 != 1)
							{
								x_BYTE_17E082 = 1;
								x_WORD_17E080 = 1;
								x_BYTE_17E083 = 4;
							}
						}
						else if (v10 == 1536 && x_BYTE_17E082 != 25)
						{
							x_WORD_17E080 = 25;
							x_BYTE_17E082 = 25;
							x_BYTE_17E083 = 28;
						}
					}
					else if (x_BYTE_17E082 != 17)
					{
						x_BYTE_17E082 = 17;
						x_WORD_17E080 = 17;
						x_BYTE_17E083 = 20;
					}
				}
				else if (x_BYTE_17E082 != 13)
				{
					x_WORD_17E080 = 13;
					x_BYTE_17E082 = 13;
					x_BYTE_17E083 = 16;
				}
			}
			else if (x_BYTE_17E082 != 5)
			{
				x_BYTE_17E082 = 5;
				x_WORD_17E080 = 5;
				x_BYTE_17E083 = 8;
			}
		}
		else if (x_BYTE_17E082 != 29)
		{
			x_WORD_17E080 = 29;
			x_BYTE_17E083 = 32;
			x_BYTE_17E082 = 29;
		}
	}
	else if (x_BYTE_17E082 != 21)
	{
		x_WORD_17E080 = 21;
		x_BYTE_17E082 = 21;
		x_BYTE_17E083 = 24;
	}
	x_WORD_17E07C = x_WORD_17E06C;
	x_WORD_17E07E = x_WORD_17E06E;
	v11 = xy_DWORD_17DED4_spritestr[x_WORD_17E080].pointer;
	v12 = x_WORD_17E06C - *(unsigned __int8 *)(v11 + 4) / 2 - a5;
	sub_81260(
		(signed __int16)v12,
		v12,
		(int)&unk_17E078,
		x_WORD_17E06C - *(unsigned __int8 *)(v11 + 4) / 2 - a5,
		x_WORD_17E06E - *(unsigned __int8 *)(v11 + 5) / 2 - a6);
}
// 17DED4: using guessed type int (int)x_DWORD_17DED4;
// 17E06C: using guessed type __int16 x_WORD_17E06C;
// 17E06E: using guessed type __int16 x_WORD_17E06E;
// 17E074: using guessed type __int16 x_WORD_17E074;
// 17E076: using guessed type __int16 x_WORD_17E076;
// 17E07C: using guessed type __int16 x_WORD_17E07C;
// 17E07E: using guessed type __int16 x_WORD_17E07E;
// 17E080: using guessed type __int16 x_WORD_17E080;
// 17E082: using guessed type char x_BYTE_17E082;
// 17E083: using guessed type char x_BYTE_17E083;

//----- (0007DD70) --------------------------------------------------------
int sub_7DD70()//25ed70
{
	int v0; // esi
	int result; // eax
	__int16 v2; // dx
	char v3; // bl

	v0 = (int)x_D41A0_BYTEARRAY_4;
	result = (int)&unk_E17CC[0x194];
	v2 = 0;
	while (*(x_WORD *)(result + 4))
	{
		v3 = *(x_BYTE *)(result + 18);
		*(x_BYTE *)(result + 20) = 0;
		if (v3 == 2)
			*(x_WORD *)(result + 16) = 70;
		if (*(x_BYTE *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11232) & 2
			&& *(unsigned __int16 *)(v0 + 43) == v2)
		{
			*(x_BYTE *)(result + 18) = 1;
		}
		if (*(x_BYTE *)(result + 18) == 1)
			*(x_WORD *)(result + 16) = 37;
		result += 22;
		++v2;
		*(x_BYTE *)(result - 3) = 0;
	}
	if (*(x_WORD *)(v0 + 43) > 0x18u)
	{
		for (result = (int)x_WORD_E2970; *(x_WORD *)(result + 12); result += 17)
		{
			if (*(unsigned __int16 *)(v0 + 43) == *(signed __int16 *)(result + 6))
			{
				if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 11232) & 2)
				{
					*(x_WORD *)(result + 12) = 1;
					*(x_WORD *)(result + 14) = 305;
				}
				else if (*(x_WORD *)(result + 12) == 3)
				{
					*(x_WORD *)(result + 12) = 2;
					*(x_WORD *)(result + 14) = 70;
				}
				x_BYTE_E1972[22 * *(signed __int16 *)(result + 4)] = 1;
				result = 22 * *(signed __int16 *)(result + 4);
				*(__int16 *)((char *)&x_WORD_E1970 + result) = 37;
				break;
			}
		}
	}
	x_D41A0_BYTEARRAY_4 = (Bit8u*)v0;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// E1970: using guessed type __int16 x_WORD_E1970;

//----- (0007DE80) --------------------------------------------------------
char sub_7DE80(int a1, int a2)//25ee80
{
	int v2; // edx
	int v3; // edi
	int v4; // eax
	signed __int16 *v5; // ebx
	int v6; // edx
	int v7; // esi
	int v8; // esi
	char v9; // al
	int v10; // edx
	bool v11; // zf
	__int16 v12; // si
	unsigned __int8 v13; // al
	__int16 v14; // si
	unsigned __int8 v15; // al
	int v16; // eax
	int v17; // edx
	//char v19; // [esp+0h] [ebp-20h]
	int v20; // [esp+Ch] [ebp-14h]
	__int16 v21; // [esp+10h] [ebp-10h]
	int v22; // [esp+14h] [ebp-Ch]
	char v23; // [esp+18h] [ebp-8h]
	char v24; // [esp+1Ch] [ebp-4h]

	//fix it
	v2 = 0;
	v17 = 0;
	//fix it

	v21 = 0;
	memset(printbuffer, 0, 10);
	*(x_DWORD *)(a2 + 4) = 0;
	v3 = j___clock();
	/*v4 = */sub_6FC50(1);
	LOWORD(v4) = *(x_WORD *)(a2 + 26);
	v22 = v4 + 10;
	//HIWORD(v4) = HIWORD(x_DWORD_17DED4);
	v5 = (signed __int16 *)(a2 + 26);
	LOWORD(v4) = xy_DWORD_17DED4_spritestr[72].sizex;
	v6 = *(signed __int16 *)(a2 + 34);
	v20 = v22 + v4 - 22;
	v7 = v6 / 2 + *(signed __int16 *)(a2 + 28);
	v8 = v7 - sub_6FC30_get34_sizey();
	v9 = sub_7BF20_draw_scroll_dialog((signed __int16 *)(a2 + 26));
	v10 = *(signed __int16 *)(a2 + 34);
	v23 = v9;
	if (*(signed __int16 *)(a2 + 36) <= v10 / 2)
		goto LABEL_13;
	if ((unsigned __int8)x_BYTE_17DF10_get_key_scancode < 0xFu)
	{
		v11 = x_BYTE_17DF10_get_key_scancode == 14;
		goto LABEL_6;
	}
	if ((unsigned __int8)x_BYTE_17DF10_get_key_scancode > 0xFu)
	{
		v11 = x_BYTE_17DF10_get_key_scancode == 83;
	LABEL_6:
		if (!v11
			&& (unsigned __int16)x_WORD_17DEF0 < 0xCu
			&& (unsigned __int8)x_BYTE_17DF11_last_key_status >= 0x30u
			&& (unsigned __int8)x_BYTE_17DF11_last_key_status <= 0x39u)
		{
			x_BYTE_E29DF_skip_screen = x_BYTE_17DF11_last_key_status - '0';
		}
	}
	sprintf_s(printbuffer, 512, "%d", (unsigned __int8)x_BYTE_E29DF_skip_screen);
	sub_6FC50(1);
	v12 = sub_6FC30_get34_sizey() + v8;
	v13 = sub_5BE80_test_pallette((unsigned __int8 *)x_DWORD_17DE38, 0, 0, 0);
	v5 = (signed __int16 *)v12;
	v14 = sub_6FC80_pre_draw_text(printbuffer, v22, v20, v12, v13);
	if ((v3 - x_DWORD_17DED0) / 0xCu >= 1)
	{
		sub_6FC50(1);
		v15 = sub_5BE80_test_pallette((unsigned __int8 *)x_DWORD_17DE38, 0, 0, 0);
		sub_2BC10_draw_text((Bit8u*)"_", v14 - 2, (__int16)v5, v15);
		x_DWORD_17DED0 = v3;
	}
LABEL_13:
	if (v23)
	{
		LOBYTE(v5) = v23;
		sub_7C020((x_WORD *)(a2 + 26));
		if ((x_BYTE)v5 == 1)
		{
			x_WORD_E131A = 0;
			x_WORD_17DEFA = (unsigned __int8)x_BYTE_E29DF_skip_screen;
			sub_7B5A0_disable_enable();
			if (1 == x_D41A0_BYTEARRAY_4_struct.byteindex_A)
				v24 = x_BYTE_17DF13;
			/*v16 = */sub_8CD27_set_cursor(*filearray_2aa18c[0].posistruct);
			v16 = 0;  //fix it
			*(x_DWORD *)(a2 + 4) = sub_77680(v16, v17, v5) != 0;
			if (x_D41A0_BYTEARRAY_4_struct.byteindex_A == 1)
				x_BYTE_17DF13 = v24;
		}
		else
		{
			x_BYTE_E29DF_skip_screen = x_WORD_17DEFA;
		}
		v21 = 1;
	}
	return v21;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// 98786: using guessed type int /*__fastcall*/ j___clock(x_DWORD, x_DWORD, x_DWORD);
// D41A4: using guessed type int x_DWORD_D41A4;
// E131A: using guessed type __int16 x_WORD_E131A;
// E29DF: using guessed type char x_BYTE_E29DF_skip_screen;
// EB394: using guessed type int **filearray_2aa18c[0];
// 17DE38: using guessed type int x_DWORD_17DE38;
// 17DED0: using guessed type int x_DWORD_17DED0;
// 17DED4: using guessed type int (int)x_DWORD_17DED4;
// 17DEF0: using guessed type __int16 x_WORD_17DEF0;
// 17DEFA: using guessed type __int16 x_WORD_17DEFA;
// 17DF10: using guessed type char x_BYTE_17DF10_get_key_scancode;
// 17DF11: using guessed type char x_BYTE_17DF11_last_key_status;
// 17DF13: using guessed type char x_BYTE_17DF13;

//----- (0007E0E0) --------------------------------------------------------
signed int sub_7E0E0_mouse_events()//25f0e0
{
	int v0; // esi
	//x_WORD *v2; // ebx
	int v3; // edx

	v0 = 0;
	if (x_BYTE_17DF10_get_key_scancode == 1)
		return 2;
	//v2 = x_WORD_E1F84;
	Bit32u i = 0;
	if (!(x_WORD_E1F84[5] + (x_WORD_E1F84[6] << 16)))
		return 0;
	do
	{
		if (!(x_WORD_17DEEE & 1) || v0)
		{//[34eee6] [34eee4] 2b2fb0
			if ((x_WORD_E1F84[i + 12] & 0xff) && sub_7B200_in_region(&x_WORD_E1F84[i], x_DWORD_17DEE4_mouse_positionx, x_DWORD_17DEE4_mouse_positiony))//confirm language
				v3 = x_WORD_E1F84[i + 10] & 0xff;
			else
				v3 = (x_WORD_E1F84[i + 10] & 0xff00) >> 8;
			/*
			[34eed4]+69+48c73d
			cd
			123
			*/
			//x_D41A0_BYTEARRAY_4_0xE2_heapbuffer[0x4D54A + 164829 - 1]
			//je asi &x_DWORD_17DED4[6 * v3]
			//123 cd
			sub_2BB40_draw_bitmap(x_WORD_E1F84[i + 5], x_WORD_E1F84[i + 6], xy_DWORD_17DED4_spritestr[v3]);
		}
		else if (sub_7B200_in_region(&x_WORD_E1F84[i], x_DWORD_17DEE4_mouse_positionx, x_DWORD_17DEE4_mouse_positiony))//change language
		{
			sub_8F100_sound_proc19(0, 14, 127, 64, 0x64u, 0, 3u);
			sub_2BB40_draw_bitmap(x_WORD_E1F84[i + 5], x_WORD_E1F84[i + 6], xy_DWORD_17DED4_spritestr[x_WORD_E1F84[i + 10] & 0xff]);//asi vykresleni stisknuteho tlacitka
			v0 = x_WORD_E1F84[i + 11] & 0xff;
		}
		i += 22;
	} while (x_WORD_E1F84[i + 10] & 0xff);
	return v0;
}
// 17DED4: using guessed type int (int)x_DWORD_17DED4;
// 17DEE4: using guessed type int x_DWORD_17DEE4_mouse_position;
// 17DEEE: using guessed type __int16 x_WORD_17DEEE;
// 17DF10: using guessed type char x_BYTE_17DF10_get_key_scancode;

//----- (0007E1F0) --------------------------------------------------------
Bit16s sub_7E1F0_test_mouse_regions()//25f1f0
{
	Bit16s* v0; // ebx
	Bit16s v1; // esi
	//int v3; // ecx
	//int v4; // edx

	v0 = x_WORD_E2008;
	v1 = 0;
	if (!x_WORD_E2008[5])
		return 0;
	do
	{
		//v3 = xy_DWORD_17DED4_spritestr[0].pointer;
		//v4 = v0[21];
		v0[7] = xy_DWORD_17DED4_spritestr[((Bit8u*)v0)[21]].sizex;
		v0[8] = xy_DWORD_17DED4_spritestr[((Bit8u*)v0)[21]].sizey;
		if (!(x_WORD_17DEEE & 1))
		{
			if (sub_7B200_in_region(v0, x_DWORD_17DEE4_mouse_positionx, x_DWORD_17DEE4_mouse_positiony))
				sub_2BB40_draw_bitmap(v0[5], v0[6], xy_DWORD_17DED4_spritestr[((Bit8u*)v0)[21]]);
			goto LABEL_9;
		}
		if (sub_7B200_in_region(v0, x_DWORD_17DEE4_mouse_positionx, x_DWORD_17DEE4_mouse_positiony))
		{
			sub_8F100_sound_proc19(0, 14, 127, 64, 0x64u, 0, 3u);
			sub_2BB40_draw_bitmap(v0[5], v0[6], xy_DWORD_17DED4_spritestr[((Bit8u*)v0)[21]]);
			v1 = ((Bit8u*)v0)[22];
			if (((Bit8u*)v0)[22])
				break;
		}
	LABEL_9:
		v0 += 22;
	} while (v0[5]);
	return v1;
}
// 17DED4: using guessed type int (int)x_DWORD_17DED4;
// 17DEE4: using guessed type int x_DWORD_17DEE4_mouse_position;
// 17DEEE: using guessed type __int16 x_WORD_17DEEE;

//----- (0007E320) --------------------------------------------------------
signed int sub_7E320_draw_bitmaps_and_play_sounds(__int16 a1, int a2)//25f320
{
	Bit8u* i; // esi
	Bit8u* v3; // esi
	Bit8u* j; // esi
	Bit8u v5; // al
	Bit8u* k; // esi
	//int v8; // edi
	int v9; // edx
	//int v10; // eax
	char *v11; // edi
	posistruct* v12; // edi
	Bit8u* v13; // esi
	char v14[36]; // [esp+0h] [ebp-24h]
	//char v15; // [esp+10h] [ebp-14h]

	for (i = off_E23E0; i[25]; i += 44)//draw buttons
	{
		if (i[23])
		{
			a2 = i[21];
			sub_7C120_draw_bitmap_640(*((x_WORD *)i + 5), *((x_WORD *)i + 6), xy_DWORD_17DED4_spritestr[a2]);
		}
	}
	if (x_DWORD_17DB70str.x_BYTE_17DB8E)
		return 0;
	v3 = off_E23E0;
	if (off_E23E0[25])
	{
		do//adress 25f57c
		{
			if (*((x_WORD *)v3 + 4) && *(x_DWORD *)v3)
			{
				v5 = v3[0];
				LOWORD(a2) = v5;
				if (!v5)
					return 1;
				*((x_WORD *)v3 + 4) = 0;
				sub_7B5A0_disable_enable();
				return a2;
			}
			v3 += 44;
		} while (v3[25]);
		j = off_E23E0;
		if (!off_E23E0[25])
		{
			k = off_E23E0;
			goto LABEL_34;
		}
		goto LABEL_17;
	}
	for (j = off_E23E0; j[25]; *(j - 20) = 0)
	{
	LABEL_17:
		if (j[23] && j[24])
			sub_7C120_draw_bitmap_640(*((x_WORD *)j + 5), *((x_WORD *)j + 6), xy_DWORD_17DED4_spritestr[j[20]]);
		j += 44;
		*((x_WORD *)j - 18) = 0;
	}
	for (k = off_E23E0; ; k += 44)
	{
	LABEL_34:
		if (!k[25])
		{
			sub_82510(/*a1*//*, (int *)&unk_17DBA8str.unk_17DBA8*/);
			return 0;
		}
		if (k[23])
		{
			//v8 = (int)x_DWORD_17DED4;
			v9 = k[20];
			*((x_WORD *)k + 7) = xy_DWORD_17DED4_spritestr[v9].sizex;
			*((x_WORD *)k + 8) = xy_DWORD_17DED4_spritestr[v9].sizey;
			if (sub_7B200_in_region((Bit16s*)k, x_DWORD_17DEE4_mouse_positionx, x_DWORD_17DEE4_mouse_positiony))
				break;
		}
	LABEL_33:
		;
	}
	if (x_WORD_17DEEE & 1)
	{
		*((x_WORD *)k + 4) = 1;
		sub_7B5A0_disable_enable();
		sub_8F100_sound_proc19(0, 14, 127, 64, 0x64u, 0, 3u);
		goto LABEL_33;
	}
	//v10 = (int)x_D41A0_BYTEARRAY_4;
	k[24] = 1;
	if (x_D41A0_BYTEARRAY_4_struct.byteindex_A != 1)
		return 0;
	v11 = (char *)&unk_E2516;
	if (!*((x_WORD *)&unk_E2516 + 1))
		return 0;
	do//adress 25f4e7
	{
		if (v11[17] == k[22])
		{
			memset(&v14, 0, 36);
			qmemcpy(&v14, v11, 0x12u);
			//qmemcpy(&v15, v11 + 16, 2u);
			v12 = xy_DWORD_17DEC0_spritestr;
			v13 = x_DWORD_17DEC4;

			xy_DWORD_17DEC0_spritestr = xy_DWORD_17DEC8_spritestr;
			x_DWORD_17DEC4 = x_DWORD_17DECC;
			sub_7E840_draw_textbox_with_line((Bit16u*)&v14, 238, 264);
			xy_DWORD_17DEC0_spritestr = v12;
			x_DWORD_17DEC4 = v13;
			return 0;
		}
		v11 += 18;
	} while (*((x_WORD *)v11 + 1));
	return 0;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D41A4: using guessed type int x_DWORD_D41A4;
// 17DB8E: using guessed type char x_BYTE_17DB8E;
// 17DEC0: using guessed type int (int)x_DWORD_17DEC0;
// 17DEC4: using guessed type int (int)x_DWORD_17DEC4;
// 17DEC8: using guessed type int x_DWORD_17DEC8;
// 17DECC: using guessed type int x_DWORD_17DECC;
// 17DED4: using guessed type int (int)x_DWORD_17DED4;
// 17DEE4: using guessed type int x_DWORD_17DEE4_mouse_position;
// 17DEEE: using guessed type __int16 x_WORD_17DEEE;

//----- (0007E5A0) --------------------------------------------------------
signed int sub_7E5A0_pre_draw(int a1, int a2, __int16 a3, __int16 a4, Bit8u* a5, __int16 a6, __int16 a7)
{
	int v7; // edx
	signed int v8; // esi
	__int16 v9; // ax

	v7 = j___clock();
	v8 = 0;
	if ((unsigned int)(v7 - *(x_DWORD *)a5) >> 3 >= 1)
	{
		v9 = *(x_WORD *)(a5 + 16);
		if (v9 <= a7)
		{
			*(x_WORD *)(a5 + 16) = v9 + 1;
		}
		else
		{
			v8 = 1;
			*(x_WORD *)(a5 + 16) = a6;
		}
		*(x_DWORD *)a5 = v7;
	}
	sub_7C120_draw_bitmap_640(*(x_WORD *)(a5 + 12) - a3, *(x_WORD *)(a5 + 14) - a4, xy_DWORD_17DED4_spritestr[*(signed __int16 *)(a5 + 16)]);
	return v8;
}
// 98786: using guessed type int /*__fastcall*/ j___clock(x_DWORD, x_DWORD, x_DWORD);
// 17DED4: using guessed type int (int)x_DWORD_17DED4;

//----- (0007E620) --------------------------------------------------------
signed int sub_7E620(int a1)
{
	*(x_WORD *)(a1 + 8) = 0;
	return 2;
}

//----- (0007E640) --------------------------------------------------------
signed int sub_7E640(int a1)
{
	signed __int16 v1; // ax
	x_WORD *i; // eax
	x_WORD *j; // eax
	signed int result; // eax

	if (a1)
		v1 = sub_7BF20_draw_scroll_dialog((signed __int16 *)(a1 + 26));
	else
		v1 = 1;
	if (v1 == 1)
	{
		x_D41A0_BYTEARRAY_4_struct.levelnumber_43 = 0;
		memset(x_DWORD_17DBC8, 0, 500);
		memset(x_DWORD_17DDBC, 0, 100);
		for (i = (x_WORD*)&unk_E17CC[0x194]; i[2]; *(i - 3) = 70)
		{
			i += 11;
			*((x_BYTE *)i - 4) = 2;
			*((x_BYTE *)i - 3) = 0;
		}
		for (j = x_WORD_E2970; j[6]; *((x_BYTE *)j - 1) = 0)
		{
			j = (x_WORD *)((char *)j + 17);
			*(x_WORD *)((char *)j - 5) = 3;
			*(x_WORD *)((char *)j - 3) = 70;
		}
		memset((void*)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11230 + 1609), 0, 505);
		sub_86860(x_WORD_1803EC);
		sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DE64_game_world_map, (int)&loc_B2C44 + 3, (int)&loc_87D80 + 3);
		sub_7AA70_load_and_decompres_dat_file(0, 0, 0, 0);
		x_BYTE_17E09D = 0;
		*(x_WORD *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11232) = 0;
		memset(&x_DWORD_17DB70str, 0, 56);
		x_WORD_17E080 = 13;
		x_WORD_17E06C = 0;
		x_BYTE_17E082 = 13;
		x_BYTE_17E09C = 0;
		x_WORD_17E06E = 480;
		x_BYTE_17E083 = 16;
		x_DWORD_17DB70str.x_BYTE_17DB8F = 1;
		if (a1)
		{
			*(x_WORD *)(a1 + 8) = 0;
			sub_7C020((x_WORD *)(a1 + 26));
		}
		result = 1;
	}
	else if (v1 == 2)
	{
		*(x_WORD *)(a1 + 8) = 0;
		sub_7C020((x_WORD *)(a1 + 26));
		result = 1;
	}
	else
	{
		result = 0;
	}
	return result;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// 17DB70: using guessed type int x_DWORD_17DB70;
// 17DB8F: using guessed type char x_BYTE_17DB8F;
// 17DBC8: using guessed type int x_DWORD_17DBC8[];
// 17DDBC: using guessed type int x_DWORD_17DDBC[];
// 17DE64: using guessed type int x_DWORD_17DE64_game_world_map;
// 17E06C: using guessed type __int16 x_WORD_17E06C;
// 17E06E: using guessed type __int16 x_WORD_17E06E;
// 17E080: using guessed type __int16 x_WORD_17E080;
// 17E082: using guessed type char x_BYTE_17E082;
// 17E083: using guessed type char x_BYTE_17E083;
// 17E09C: using guessed type char x_BYTE_17E09C;
// 17E09D: using guessed type char x_BYTE_17E09D;
// 1803EC: using guessed type __int16 x_WORD_1803EC;

//----- (0007E800) --------------------------------------------------------
char sub_7E800(x_WORD *a1)
{
	char result; // al

	result = sub_78730_save_game_dialog(a1);
	if (result)
		a1[4] = 0;
	return result;
}

//----- (0007E820) --------------------------------------------------------
char sub_7E820(int a1)
{
	char result; // al

	result = sub_780F0_load_game_dialog((Bit8u*)a1);
	if (result)
		*(x_WORD *)(a1 + 8) = 0;
	return result;
}

//----- (0007E840) --------------------------------------------------------
void sub_7E840_draw_textbox_with_line(Bit16u* a1, __int16 a2, __int16 a3)//25f840
{
	Bit16u* v3; // ebx
	signed __int16 v5; // si
	//signed __int16 v6; // di

	v3 = a1;
	if (!a1[1])
		return;
	do
	{
		if (v3[1])
		{
			v5 = v3[1];
			//v6 = v3[1];
			//zatim nic
			//18d 12a 141 ec - 18d 12a 141 ec -1
			//c4 26 11b 6a - c4 26 11b 6a -0 - chybi ocasek
			sub_81360_draw_bitmap_line(v3[3]/* + (v3[4] << 16)*/, v3[4], v3[6]/* + (v3[7] << 16)*/, v3[7], a3);//262360
			//pridany tecky
			sub_7FCB0_draw_text_with_border(v3[0], x_DWORD_E9C4C_langindexbuffer[v3[0]], v5, (v5 + 180), v3[2], 0, 0, a2);//260cb0
			//pridan ramecek s textem
		}
		v3 += 9;
	} while (v3[1]);
}

//----- (0007E8D0) --------------------------------------------------------
void sub_7E8D0(x_WORD *a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7)//25f8d0
{
	__int16 v7; // dx
	__int16 v8; // dx
	__int16 v9; // dx
	__int16 v10; // ax
	//int result; // eax
	__int16 v12; // di
	__int16 v13; // dx

	*a1 = a2 - a4;
	a1[1] = a3 - a5;
	a1[2] = 2 * abs(a1[0]);
	v7 = a1[0];
	a1[3] = 2 * abs(a1[1]);
	if (v7 >= 0)
	{
		if (v7)
			a1[4] = a6;
		else
			a1[4] = 0;
	}
	else
	{
		a1[4] = -a6;
	}
	v8 = a1[1];
	if (v8 >= 0)
	{
		if (v8)
			a1[5] = a7;
		else
			a1[5] = 0;
	}
	else
	{
		a1[5] = -a7;
	}
	a1[6] = a2;
	a1[7] = a3;
	v9 = a1[3];
	v10 = a1[2];
	if (v10 <= v9)
	{
		//result = v10 - (v9 >> 1);
		a1[8] = v10 - (v9 >> 1);
	}
	else
	{
		//result = v10 >> 1;
		a1[8] = v9 - v10 >> 1;
	}
	v12 = a1[6];
	a1[9] = 0;
	if (a4 >= v12)
	{
		if (a4 > v12)
			a1[10] = 1;
	}
	else
	{
		a1[10] = 2;
	}
	v13 = a1[7];
	if (a5 >= v13)
	{
		if (a5 > v13)
			a1[11] = 1;
	}
	else
	{
		a1[11] = 2;
	}
	//  return result;
}

//----- (0007E9D0) --------------------------------------------------------
signed int sub_7E9D0(x_WORD *a1, x_WORD *a2, x_WORD *a3)//25f9d0
{
	__int16 v4; // cx
	unsigned __int16 v5; // cx
	__int16 v6; // si
	__int16 v7; // di
	unsigned __int16 v8; // dx
	__int16 v9; // cx
	__int16 v10; // si

	if (a3[2] <= a3[3])
	{
		if (a2[0] == a3[7])
			return 1;
		if (a3[8] >= 0)
		{
			a1[0] += a3[4];
			a3[8] -= a3[3];
		}
		a2[0] += a3[5];
		v4 = a3[2];
	}
	else
	{
		if (a1[0] == a3[6])
			return 1;
		if (a3[8] >= 0)
		{
			a2[0] += a3[5];
			a3[8] -= a3[2];
		}
		a1[0] += a3[4];
		v4 = a3[3];
	}
	a3[8] += v4;
	v5 = a3[10];
	if (v5 >= 1u)
	{
		if (v5 <= 1u)
		{
			v6 = a3[6];
			if (a1[0] < v6)
				a1[0] = v6;
		}
		else if (v5 == 2)
		{
			v7 = a3[6];
			if (a1[0] > v7)
				a1[0] = v7;
		}
	}
	v8 = a3[11];
	if (v8 >= 1u)
	{
		if (v8 <= 1u)
		{
			v9 = a3[7];
			if (a2[0] < v9)
				a2[0] = v9;
		}
		else if (v8 == 2)
		{
			v10 = a3[7];
			if (a2[0] > v10)
				a2[0] = v10;
		}
	}
	return 0;
}

//----- (0007EAE0) --------------------------------------------------------
int sub_7EAE0_new_game_draw(Bit16s* posx, Bit16s* posy, __int16 *a3, __int16 *a4, char *a5, x_WORD *a6)//25fae0
{
	char v6; // al
	int v7; // eax
	x_WORD *v8; // eax
	char *v9; // eax
	int v10; // ecx
	int v11; // edx
	Bit16s* v12; // eax
	int v13; // ecx
	__int16 v14; // dx
	x_WORD *v15; // eax
	__int16 v16; // cx
	signed __int16 *i; // eax
	int v18; // ecx
	x_WORD *j; // eax
	int v20; // edx
	//int v21; // eax
	int v22; // edx
	__int16 v23; // cx
	//int v24; // eax
	int v25; // ST18_4
	int v26; // ST14_4
	int v28; // edx
	//__int16 v29; // cx
	//Bit16s nextposx; // dx
	//Bit16s nextposy; // dx
	int v32; // edx
	signed int v33; // eax
	__int16 v34; // dx
	char v35; // cl
	__int16 v36; // ax
	int v37; // edx
	signed int v38; // eax
	signed int v39; // eax
	//char v41; // ch
	char v42; // cl
	int v43; // ecx
	unsigned __int8 *v44; // edi
	int v45; // eax
	x_WORD *v46; // eax
	x_WORD *v47; // edi
	__int16 v48; // ST10_2
	__int16 v49; // ST0C_2
	__int16 v50; // ST08_2
	__int16 v51; // ax
	int v52; // eax
	__int16 v54; // [esp-Ch] [ebp-68h]
	Bit16s v55[10]; // [esp+0h] [ebp-5Ch]
	//__int16 v56; // [esp+Ah] [ebp-52h] //5
	//__int16 v57; // [esp+Ch] [ebp-50h] //6
	//__int16 v58; // [esp+Eh] [ebp-4Eh] //7
	//__int16 v59; // [esp+10h] [ebp-4Ch] //8
	int v60; // [esp+2Ch] [ebp-30h]
	x_WORD *v61; // [esp+30h] [ebp-2Ch]
	x_WORD *k; // [esp+34h] [ebp-28h]
	x_WORD *v63; // [esp+38h] [ebp-24h]
	x_WORD *v64; // [esp+3Ch] [ebp-20h]
	int v65; // [esp+40h] [ebp-1Ch]
	int v66; // [esp+44h] [ebp-18h]
	int v67; // [esp+48h] [ebp-14h]
	int v68; // [esp+4Ch] [ebp-10h]
	int v69; // [esp+50h] [ebp-Ch]
	char *v70; // [esp+54h] [ebp-8h]
	int v71; // [esp+58h] [ebp-4h]

	//fix it
	v22 = 0;
	v28 = 0;
	v32 = 0;
	v33 = 0;
	v37 = 0;
	v38 = 0;
	v39 = 0;
	//fix it

	v6 = *a5;
	v71 = 0;
	v67 = -1;
	switch (v6)
	{
	case 1://prepare 
		v12 = (Bit16s*)&unk_E17CC[0x194];
		v13 = 0;
		v61 = 0;
		while (*(Bit32u*)&v12[2])
		{
			if (*((Bit8s*)v12 + 18) == 1)
			{
				*posx = v12[2];
				v61 = v12;
				v14 = v12[3];
				v67 = v13;
				*posy = v14;
			}
			v12 += 11;
			v13++;
		}
		//adress 25fc6f
		if (v61 && x_DWORD_17DB70str.x_WORD_17DB8A != -1 && v67 != x_DWORD_17DB70str.x_WORD_17DB8A)
		{
			v15 = (x_WORD*)&unk_E17CC[0x194];
			v16 = 0;
			while (v15[2])
			{
				if (v16 == x_DWORD_17DB70str.x_WORD_17DB8A)
				{
					*posx = v15[2];
					*posy = v15[3];
					*a5 = 3;
					break;
				}
				v15 += 11;
				v16++;
			}
			if (*a5 != 3)
			{
				for (i = x_WORD_E2970; i[6]; i = (signed __int16 *)((char *)i + 17))
				{
					if (x_DWORD_17DB70str.x_WORD_17DB8A == i[3])
					{
						*posx = x_WORD_E1964[11 * i[2]];
						*posy = x_WORD_E1966[11 * i[2]];
						*a5 = 3;
						break;
					}
				}
			}
		}
		else
		{
			x_DWORD_17DB70str.x_WORD_17DB8A = -1;
		}
		memset(&x_DWORD_17DE28str, 0, 13);
		if (x_DWORD_17DB70str.x_WORD_17DB8A == -1)
		{
			v18 = 0;
			for (j = (x_WORD*)&unk_E17CC[0x194];*(Bit32s*)&j[2] != 0; j += 11)
			{
				v66 = v18;
				/*if ( !j[2] )
				  break;*/
				if (*((Bit8s*)j + 18) == 2)
				{
					*a3 = j[2];
					*a4 = j[3];
					if (v66)
					{
						*a5 = 2;
						/*j = (x_WORD *)*/sub_7E8D0(a6, *a3, *a4, *posx, *posy, 4, 4);
					}
					else
					{
						*posx = j[2];
						//LOWORD(j) = j[3];
						*posy = j[3];
						*a5 = 3;
						if (*posy > 480)
							*posy = 480;
						if (*posx > 640)
							*posx = 640;
						v20 = v66;
						*a5 = 3;
						if (v20 < 24)
						{
							x_DWORD_17DE28str.x_WORD_17DE30_posx = *posx;
							x_DWORD_17DE28str.x_WORD_17DE32_posy = *posy;
							//v21 = (int)x_D41A0_BYTEARRAY_4;
							x_DWORD_17DE28str.x_BYTE_17DE34 = ((x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 0x40) != 0) + 1;
							//v21 = x_DWORD_17DE28str.x_BYTE_17DE34;
							//j = (x_WORD *)j___clock();
							x_DWORD_17DE28str.x_DWORD_17DE28 = j___clock();
						}
					}
					break;
				}
				v18 = v66 + 1;
			}
			if (*a5 != 1 || x_DWORD_17DB70str.x_BYTE_17DB8E)
				goto LABEL_66;
		}
		else
		{
			memset(&x_DWORD_17DE28str, 0, 13);
			//j = (x_WORD*)&unk_E17CC[0x194];
			v23 = 0;
			//while ( j[2] )
			for (j = (x_WORD*)&unk_E17CC[0x194];j[2] != 0; j += 11)
			{
				if (*((x_BYTE *)j + 18) == 2)
				{
					if (v23 < 24)
					{
						x_DWORD_17DE28str.x_WORD_17DE30_posx = *posx;
						x_DWORD_17DE28str.x_WORD_17DE32_posy = *posy;
						//v24 = (int)x_D41A0_BYTEARRAY_4;
						x_DWORD_17DE28str.x_BYTE_17DE34 = ((x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 0x40) != 0) + 1;
						//LOBYTE(v24) = x_DWORD_17DE28str.x_BYTE_17DE34;
						//j = (x_WORD *)j___clock();
						x_DWORD_17DE28str.x_DWORD_17DE28 = j___clock();
					}
					break;
				}
				//j += 11;
				v23++;
			}
		}
		*a5 = 3;
	LABEL_66:
		sub_81760_new_game_subdraw((Bit8u*)j);//draw cursor
		
		goto LABEL_92;
	case 2:
		v25 = *a4;
		v26 = *a3;
		if (sub_7E9D0(posx, posy, a6))
		{
			*a5 = 3;
			memset(&x_DWORD_17DE28str, 0, 13);
			x_DWORD_17DE28str.x_WORD_17DE30_posx = *posx;
			x_DWORD_17DE28str.x_WORD_17DE32_posy = *posy;
			x_DWORD_17DE28str.x_BYTE_17DE34 = ((x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 0x40) != 0) + 1;
			x_DWORD_17DE28str.x_DWORD_17DE28 = j___clock();
		}
		goto LABEL_92;
	case 3:
		if (x_DWORD_17DB70str.x_BYTE_17DB8E)
			goto LABEL_92;
		//x_WORD_E29D6 = x_DWORD_17DEE4_mouse_positionx;
		x_WORD_E29D6_not_movex = 1;
		if (x_DWORD_17DEE4_mouse_positionx)//mousex>0
		{
			if (x_DWORD_17DEE4_mouse_positionx < 638)
				goto LABEL_75;
			*posx += x_DWORD_17DB70str.x_WORD_17DB82_shift_step;//shift position by step
		}
		else//mousex==0
		{
			*posx -= x_DWORD_17DB70str.x_WORD_17DB82_shift_step;//shift position by step
		}
		x_WORD_E29D6_not_movex = 0;//add
		//x_WORD_E29D6 = v29;
		//*posx = nextposx;
	LABEL_75:
		if (x_DWORD_17DEE4_mouse_positiony)//mousey>0
		{
			if (x_DWORD_17DEE4_mouse_positiony < 478)
				goto LABEL_80;
			*posy += x_DWORD_17DB70str.x_WORD_17DB82_shift_step;//shift position by step
		}
		else//mousey==0
		{
			*posy -= x_DWORD_17DB70str.x_WORD_17DB82_shift_step;//shift position by step
		}
		x_WORD_E29D6_not_movex = 0;//shift right up or down
		//*posy = nextposy;
	LABEL_80:
		if (*posx >= 0)
		{
			if (*posx >= 638)
				*posx = 638;
		}
		else
		{
			*posx = 0;
		}
		if (*posy >= 0)
		{
			if (*posy >= 478)
				*posy = 478;
		}
		else
		{
			*posy = 0;
		}
		if (x_WORD_E29D6_not_movex)
		{
			x_DWORD_17DB70str.x_WORD_17DB82_shift_step = 0;
		}
		else
		{
			x_DWORD_17DB70str.x_WORD_17DB82_shift_step += 4;
			if (x_DWORD_17DB70str.x_WORD_17DB82_shift_step > 24)
				x_DWORD_17DB70str.x_WORD_17DB82_shift_step = 24;
		}
		goto LABEL_92;
	case 4:
		if (x_DWORD_17DB70str.x_WORD_17DB8A > 24)
		{
			v8 = sub_824E0(x_DWORD_17DB70str.x_WORD_17DB8A);
			if (!v8)
				goto LABEL_10;
			*posx = x_WORD_E1964[11 * (signed __int16)v8[2]];
			v7 = 11 * (signed __int16)v8[2];
		}
		else
		{
			v7 = 11 * x_DWORD_17DB70str.x_WORD_17DB8A;
			*posx = x_WORD_E1964[v7];
		}
		*posy = x_WORD_E1966[v7];
	LABEL_10:
		if (x_BYTE_17DF10_get_key_scancode || x_WORD_17DEEE)
		{
			*a5 = 1;
			x_WORD_17DEEE = 0;
			x_BYTE_17DF11_last_key_status = 0;
			x_BYTE_17DF10_get_key_scancode = 0;
		}
		v9 = (char *)&unk_E17CC[0x194];
		v64 = 0;
		v70 = 0;
		while (*((x_WORD *)v9 + 2))
		{
			if (v9[18] == 2)
			{
				v64 = (x_WORD*)v9;
				break;
			}
			v9 += 22;
			v70++;
		}
		v10 = (int)v64;
		if (v64)
		{
			LOWORD(v9) = v64[2];
			*((x_BYTE *)v64 - 4) = 2;
			v70 = v9;
			*(x_WORD *)(v10 + 4) = 0;
		}
		sub_81760_new_game_subdraw((Bit8u*)v9);
		if (v64)
		{
			v11 = (int)v64;
			*((x_BYTE *)v64 - 4) = 1;
			*(x_WORD *)(v11 + 4) = (x_WORD)v70;
		}
	LABEL_92:
		if (x_WORD_E29D6_not_movex)
		{
			sub_85C8B_draw_new_game_map_background(x_DWORD_17DE64_game_world_map, x_DWORD_180628b_screen_buffer, *posx, *posy, 160, 480);//draw game word map
			sub_7D400_draw_texts_and_play_sounds(*posx, *posx, *posy, *a5);//draw helps, cursor, flags
			/*LOWORD(v38) = */sub_81EE0_draw_and_sound_dragon_and_fire(*posx, v37, (int)posy, (signed __int16)a5, *posx, *posy); // fair animation
			//LOBYTE(v38) = x_DWORD_17DB70str.x_BYTE_17DB8E;
			if (x_DWORD_17DB70str.x_BYTE_17DB8E)
			{
				v38 = sub_80D40_move_graphics_and_play_sounds((__int16)posx, *posx, *posy, x_DWORD_17DB70str.x_WORD_17DB84, x_DWORD_17DB70str.x_WORD_17DB86, x_DWORD_17DB70str.x_WORD_17DB88);
				v71 = v38;
				if (v38)
				{
					v38 = 0;
					x_DWORD_17DB70str.x_BYTE_17DB8E = 0;
				}
			}
			//HIBYTE(v34) = BYTE1(x_DWORD_17DE5C_border_bitmap);
			sub_85CC3_draw_round_frame((Bit16u*)x_DWORD_17DE5C_border_bitmap);//maybe round frame
			v34 = *a5;
			if (*a5 == 4)
			{
				v36 = x_DWORD_17DB70str.x_WORD_17DB8A;
				goto LABEL_107;
			}
			if ((x_BYTE)v34 == 5)
			{
				v36 = x_DWORD_17DB70str.x_WORD_17DB8C;
				goto LABEL_107;
			}
		}
		else
		{
			sub_85C8B_draw_new_game_map_background(x_DWORD_17DE64_game_world_map, x_DWORD_180628b_screen_buffer, *posx, *posy, 160, 480);
			
			sub_7D400_draw_texts_and_play_sounds(*posx, *posx, *posy, *a5);//draw helps, cursor, flags
			
			/*LOWORD(v33) = */sub_81EE0_draw_and_sound_dragon_and_fire(*posx, v32, (int)posy, (signed __int16)a5, *posx, *posy);
			
			if (x_DWORD_17DB70str.x_BYTE_17DB8E)
			{
				v33 = sub_80D40_move_graphics_and_play_sounds((__int16)posx, *posx, *posy, x_DWORD_17DB70str.x_WORD_17DB84, x_DWORD_17DB70str.x_WORD_17DB86, x_DWORD_17DB70str.x_WORD_17DB88);
				v71 = v33;
				if (v33)
					x_DWORD_17DB70str.x_BYTE_17DB8E = 0;
			}
			sub_85CC3_draw_round_frame(/*v33, posy,*/ (unsigned __int16 *)x_DWORD_17DE5C_border_bitmap);
			
			v34 = 1;
			v35 = *a5;
			x_WORD_E29D6_not_movex = 1;
			if (v35 == 4)
			{
				v36 = x_DWORD_17DB70str.x_WORD_17DB8A;
			LABEL_107:
				sub_82C20(v36);
				goto LABEL_108;
			}
			if (v35 == 5)
			{
				v36 = x_DWORD_17DB70str.x_WORD_17DB8C;
				goto LABEL_107;
			}
		}
	LABEL_108:
		v39 = sub_7E320_draw_bitmaps_and_play_sounds(v34, (int)a5);//four buttons in corners and helps
		
		v69 = v39;
		if (!x_DWORD_17DB70str.x_BYTE_17DB8E && !v71 && !v39)
		{
			//v41 = *a5;
			if (*a5 == 3)
			{
				if (x_BYTE_17DF11_last_key_status == 111 || x_BYTE_17DF11_last_key_status == 79)
				{
					v42 = x_DWORD_17DE28str.x_BYTE_17DE34;
					if (x_DWORD_17DE28str.x_BYTE_17DE34 == 1)
					{
						v39 = x_DWORD_17DE28str.x_DWORD_17DE2C;
						x_DWORD_17DE28str.x_DWORD_17DE28 = x_DWORD_17DE28str.x_DWORD_17DE2C;
						x_DWORD_17DE28str.x_BYTE_17DE34 = 2;
						x_BYTE_17E09D = v42;
					}
					else if (x_DWORD_17DE28str.x_BYTE_17DE34 == 2)
					{
						v39 = j___clock();
						x_DWORD_17DE28str.x_DWORD_17DE2C = v39;
						x_DWORD_17DE28str.x_BYTE_17DE34 = 1;
						x_DWORD_17DE28str.x_DWORD_17DE28 = v39;
						x_BYTE_17E09D = 0;
					}
				}
				//LOBYTE(v39) = x_DWORD_17DE28str.x_BYTE_17DE34;
				if (x_DWORD_17DE28str.x_BYTE_17DE34 == 1)
				{
					v43 = j___clock();
					x_DWORD_17DE28str.x_DWORD_17DE2C = v43;
					v60 = 100;
					if ((v43 - x_DWORD_17DE28str.x_DWORD_17DE28) / 0x64u > 0xF)
					{
						x_DWORD_17DE28str.x_DWORD_17DE28 = v43;
						x_DWORD_17DE28str.x_BYTE_17DE34 = 2;
					}
					if (x_DWORD_17DE28str.x_WORD_17DE32_posy < 478)
						v54 = 280;
					else
						v54 = 60;
					//adress 2602a0

					sub_80C30_draw_texts(130, v54, 380);//divny text
					
				}
				else if (x_DWORD_17DE28str.x_BYTE_17DE34 <= 2u || x_DWORD_17DE28str.x_BYTE_17DE34 == 3)
				{
					//adress 2602a7
					sub_80C30_draw_texts(0, 0, 0);
				}
			}
		}
		if (v69 == 2 && !v71 && !x_DWORD_17DB70str.x_BYTE_17DB8E)
			v71 = v69;
		if (!v69 && !v71)
		{
			if (*a5 == 3 && !v71)
			{
				//BYTE1(v39) = x_DWORD_17DB70str.x_BYTE_17DB8E;
				if (!x_DWORD_17DB70str.x_BYTE_17DB8E)
				{
					if (x_WORD_17DEEE & 1)
					{
						v44 = (unsigned __int8 *)&unk_E17CC[0x194];
						v68 = 0;
						while (*((x_WORD *)v44 + 2))
						{
							v55[5] = *((x_WORD *)v44 + 6) - *posx;
							v55[6] = *((x_WORD *)v44 + 7) - *posy;
							v55[7] = *((x_WORD *)v44 + 4);
							v55[8] = *((x_WORD *)v44 + 5);
							if (sub_7B200_in_region(v55, x_DWORD_17DEE4_mouse_positionx, x_DWORD_17DEE4_mouse_positiony))
							{
								x_DWORD_17DB70str.x_WORD_17DB84 = *((x_WORD *)v44 + 6);
								x_DWORD_17DB70str.x_WORD_17DB86 = *((x_WORD *)v44 + 7);
								x_DWORD_17DB70str.x_WORD_17DB88 = v44[18];
								sub_80D40_move_graphics_and_play_sounds((__int16)posx, *posx, *posy, *((x_WORD *)v44 + 6), *((x_WORD *)v44 + 7), v44[18]);
								v45 = (int)x_D41A0_BYTEARRAY_4;
								x_DWORD_17DB70str.x_BYTE_17DB8E = 1;
								x_D41A0_BYTEARRAY_4_struct.levelnumber_43 = v68;
								if (v44[18] == 1)
									*(x_BYTE *)(v45 + 38545) |= 4u;
								v46 = sub_824B0(x_D41A0_BYTEARRAY_4_struct.levelnumber_43);
								if (v46 && v46[6] == 2)
									x_D41A0_BYTEARRAY_4[38545] |= 0x10u;
								if (x_D41A0_BYTEARRAY_4_struct.levelnumber_43 == 24)
									x_D41A0_BYTEARRAY_4[38545] |= 0x20u;
								break;
							}
							if (v44[18] == 2)
								break;
							v44 += 22;
							v68++;
						}
						if (!v71 && !x_DWORD_17DB70str.x_BYTE_17DB8E)
						{
							v47 = x_WORD_E2970;
							if (x_WORD_E2970[4])
							{
								while (1)
								{
									if (v47[6] != 3)
									{
										v55[5] = v47[4] - *posx;
										v55[6] = v47[5] - *posy;
										v55[7] = 40;
										v55[8] = 40;
										if (sub_7B200_in_region(v55, x_DWORD_17DEE4_mouse_positionx, x_DWORD_17DEE4_mouse_positiony))
											break;
									}
									v47 = (x_WORD *)((char *)v47 + 17);
									if (!v47[4])
										goto LABEL_179;
								}
								if (v47[6] == 1)
									x_D41A0_BYTEARRAY_4[38545] |= 4u;
								x_DWORD_17DB70str.x_WORD_17DB84 = v47[4];
								x_DWORD_17DB70str.x_WORD_17DB86 = v47[5];
								v48 = v47[4];
								v49 = *posy;
								v50 = *posx;
								x_DWORD_17DB70str.x_WORD_17DB88 = 1;
								sub_80D40_move_graphics_and_play_sounds((__int16)posx, v50, v49, v48, x_DWORD_17DB70str.x_WORD_17DB86, 1);
								v51 = v47[3];
								x_DWORD_17DB70str.x_BYTE_17DB8E = 1;
								x_D41A0_BYTEARRAY_4_struct.levelnumber_43 = v51;
							}
						}
					}
					else if (x_WORD_17DEEE & 2)
					{
						LOBYTE(v39) = 0;
						v63 = (x_WORD*)&unk_E17CC[0x194];
						v65 = v39;
						while (v63[2])
						{
							v55[5] = v63[6] - *posx;
							v55[6] = v63[7] - *posy;
							v55[7] = v63[4];
							v55[8] = v63[5];
							if (sub_7B200_in_region(v55, x_DWORD_17DEE4_mouse_positionx, x_DWORD_17DEE4_mouse_positiony))
							{
								if (*((x_BYTE *)v63 + 18) == 1)
								{
									x_DWORD_17DB70str.x_WORD_17DB8C = v65;
									*a5 = 5;
									x_WORD_17DEEE = 0;
								}
								break;
							}
							v63 += 11;
							v65++;
						}
						if (*a5 != 5)
						{
							for (k = x_WORD_E2970; k[4]; k = (x_WORD *)((char *)k + 17))
							{
								if (k[6] != 3)
								{
									v55[5] = k[4] - *posx;
									v55[6] = k[5] - *posy;
									v55[7] = 40;
									v55[8] = 40;
									if (sub_7B200_in_region(v55, x_DWORD_17DEE4_mouse_positionx, x_DWORD_17DEE4_mouse_positiony))
									{
										v52 = (int)k;
										if (k[6] == 1)
										{
											*a5 = 5;
											x_DWORD_17DB70str.x_WORD_17DB8C = *(x_WORD *)(v52 + 6);
										}
										break;
									}
								}
							}
						}
					}
				}
			}
		LABEL_179:
			if (!v71 && x_BYTE_17DF10_get_key_scancode == 1)
				v71 = 2;
		}
		return v71;
	case 5:
		if (x_BYTE_17DF10_get_key_scancode || x_WORD_17DEEE)
		{
			x_WORD_17DEEE = 0;
			*a5 = 3;
			x_BYTE_17DF11_last_key_status = 0;
			x_BYTE_17DF10_get_key_scancode = 0;
		}
		goto LABEL_92;
	default:
		goto LABEL_92;
	}
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 98786: using guessed type int /*__fastcall*/ j___clock(x_DWORD, x_DWORD, x_DWORD);
// D41A4: using guessed type int x_DWORD_D41A4;
// E1964: using guessed type __int16 x_WORD_E1964[];
// E1966: using guessed type __int16 x_WORD_E1966[];
// E29D6: using guessed type __int16 x_WORD_E29D6;
// 17DB82: using guessed type __int16 x_WORD_17DB82;
// 17DB84: using guessed type __int16 x_WORD_17DB84;
// 17DB86: using guessed type __int16 x_WORD_17DB86;
// 17DB88: using guessed type __int16 x_WORD_17DB88;
// 17DB8A: using guessed type __int16 x_WORD_17DB8A;
// 17DB8C: using guessed type __int16 x_WORD_17DB8C;
// 17DB8E: using guessed type char x_BYTE_17DB8E;
// 17DE28: using guessed type int x_DWORD_17DE28;
// 17DE2C: using guessed type int x_DWORD_17DE2C;
// 17DE30: using guessed type __int16 x_WORD_17DE30;
// 17DE32: using guessed type __int16 x_WORD_17DE32;
// 17DE34: using guessed type char x_BYTE_17DE34;
// 17DE5C: using guessed type int x_DWORD_17DE5C_border_bitmap;
// 17DE64: using guessed type int x_DWORD_17DE64_game_world_map;
// 17DEE4: using guessed type int x_DWORD_17DEE4_mouse_position;
// 17DEEE: using guessed type __int16 x_WORD_17DEEE;
// 17DF10: using guessed type char x_BYTE_17DF10_get_key_scancode;
// 17DF11: using guessed type char x_BYTE_17DF11_last_key_status;
// 17E09D: using guessed type char x_BYTE_17E09D;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;

//----- (0007F6A0) --------------------------------------------------------
int sub_7F6A0(int a1, int a2, __int16 a3, __int16 a4, char *a5, x_BYTE *a6, unsigned __int8 a7)//2606a0
{
	Bit8u v7; // al
	__int16 v8; // si
	int v10; // [esp+0h] [ebp-4h]

	v10 = j___clock();
	v7 = x_BYTE_17DF10_get_key_scancode;
	*a6 = strlen(a5);
	if (v7 < 0xFu)
	{
		if (v7 < 1u)
			goto LABEL_12;
		if (v7 <= 1u)
			goto LABEL_16;
		if (v7 != 14)
			goto LABEL_12;
	}
	else
	{
		if (v7 <= 0xFu)
			goto LABEL_16;
		if (v7 < 0x1Cu)
			goto LABEL_12;
		if (v7 <= 0x1Cu)
			goto LABEL_16;
		if (v7 != 83)
		{
		LABEL_12:
			if (*a6 < 0xFu && x_BYTE_17DF11_last_key_status && sub_7C200(x_BYTE_17DF11_last_key_status))
			{
				a5[(unsigned __int8)*a6] = x_BYTE_17DF11_last_key_status;
				a5[(unsigned __int8)*a6 + 1] = 0;
			}
			goto LABEL_16;
		}
	}
	if (*a6)
	{
		a5[strlen(a5) - 1] = 0;
		*a6 = strlen(a5);
	}
LABEL_16:
	_strupr_s(a5, strlen(a5) + 1);
	sub_2BC10_draw_text((Bit8u*)a5, a3, a4, a7);
	if ((v10 - x_DWORD_17DED0) / 0xCu >= 1)
	{
		v8 = sub_6FC10_letter_width();
		sub_2BC10_draw_text((Bit8u*)"_", a3 + v8 * strlen(a5), a4, a7);
		x_DWORD_17DED0 = v10;
	}
	return 0;
}
// 98786: using guessed type int /*__fastcall*/ j___clock(x_DWORD, x_DWORD, x_DWORD);
// 9A20A: using guessed type x_DWORD _strupr_s(x_DWORD);
// 17DED0: using guessed type int x_DWORD_17DED0;
// 17DF10: using guessed type char x_BYTE_17DF10_get_key_scancode;
// 17DF11: using guessed type char x_BYTE_17DF11_last_key_status;

//----- (0007F7D0) --------------------------------------------------------
int sub_7F7D0(Bit8u** a1, Bit8u** a2, Bit8u* a3, char* langfilename, posistruct* a3dattabindex)//2607d0
{
	//int v4; // edi
	FILE* langfile; // eax
	//FILE* v6; // ebx
	//int v7; // ebx
	//Bit8u* v8; // eax
	//unsigned __int8 v9; // bl
	//char v10; // cl
	//char v12; // [esp+0h] [ebp-5Ch]
	Bit16u langfilelenght; // [esp+50h] [ebp-Ch]
	//FILE* v14; // [esp+54h] [ebp-8h]
	//unsigned __int8 i; // [esp+58h] [ebp-4h]

	//Bit8u a3x[5000];//fix it

	//v4 = 0;
	//fix it
	//v9=0;//fix it
	//fix it
	sprintf_s(printbuffer, 512, "%c%s/%s", x_D41A0_BYTEARRAY_4_struct.harddisk_number, ":/NETHERW/LANGUAGE", langfilename);
	for (Bit8u i = 0; i < 2; i++)//[ebp-4]=354f70
	{
		//v4 = atoi(langfilename +1);
		//v4 = unknown_libname_1_atoi((char*)(a4 + 1));
		langfile = sub_98817_open(printbuffer, 512);//279f9e
		//v6 = langfile;
		//v14 = langfile;
		if (langfile != NULL)
		{
			langfilelenght = x_filelength(langfile);
			sub_988A7_read(langfile, a3, 4773);//2798a7
			sub_988A7_read(langfile, (a3 + 4773), 12);
			if (x_BYTE_E29E0 || x_DWORD_D41BC_langbuffer)//[2b39e0]00 || [2a51bc]00
				sub_83E80_sound_proc_99(x_DWORD_D41BC_langbuffer);
			//v7 = langfilelenght - 4785;
			x_DWORD_D41BC_langbuffer = (Bit8u*)sub_83CD0_malloc2(langfilelenght - 4785);
			//x_DWORD_D41BC_langbuffer = (Bit8u*)v8;
			if (x_DWORD_D41BC_langbuffer)
			{
				x_BYTE_E29E0 = 1;
				sub_988A7_read(langfile, x_DWORD_D41BC_langbuffer, langfilelenght - 4785);
			}
			sub_98882_close(langfile);
			break;
		}
		//v9 = i;
		sprintf_s(printbuffer, 512, "LANGUAGE/%s", langfilename);
	}
	*a1 = a3 + 4773;//35513c
	//v10 = x_WORD_180660_VGA_type_resolution;
	*a2 = a3 + 4785;
	//posistruct a3dattab[1000];
	if (x_WORD_180660_VGA_type_resolution & 1)
		sub_98709_create_index_dattab_power(*a1, a3 + 4785, a3, a3dattabindex);
	else
		sub_9874D_create_index_dattab(*a1, a3 + 4785, a3, a3dattabindex);
	sub_5B870(x_DWORD_D41BC_langbuffer, x_DWORD_E9C4C_langindexbuffer, 471);//fix it //2a51bc
	return atoi(langfilename + 1);
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// 988DA: using guessed type x_DWORD filelength(x_DWORD);
// 98F9E: using guessed type x_DWORD unknown_libname_1_atoi(x_DWORD);
// D41A4: using guessed type int x_DWORD_D41A4;
// D41BC: using guessed type int x_DWORD_D41BC_langbuffer;
// E29E0: using guessed type char x_BYTE_E29E0;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0007F960) --------------------------------------------------------
int sub_7F960(Bit8u* a1, Bit8u* a2, Bit8u* a3, char* langcountstring, posistruct* a3dattabindex)
//int sub_7F7D0(Bit8u** a1, Bit8u** a2, Bit8u* a3, char* langfilename, posistruct* a3dattabindex)//2607d0
{
	Bit16u langcount; // esi
	FILE* langfile; // eax
	//FILE* v6; // ebx
	//FILE* v7; // edi
	int v8; // ebx
	Bit8u* v9; // eax
	unsigned __int8 v10; // bl
	//char v12; // [esp+0h] [ebp-58h]
	int v13; // [esp+50h] [ebp-8h]
	unsigned __int8 i; // [esp+54h] [ebp-4h]

	langcount = 0;
	sprintf_s(printbuffer, 512, "%c%s/%s", x_D41A0_BYTEARRAY_4_struct.harddisk_number, ":/NETHERW/LANGUAGE", langcountstring);
	for (i = 0; i < 2u; i = v10 + 1)
	{
		langcount = atoi((langcountstring + 1));
		langfile = sub_98817_open(printbuffer, 512);
		//v6 = v5;
		//v7 = v5;
		if (langfile != NULL)
		{
			v13 = x_filelength(langfile);
			sub_988A7_read(langfile, a3, 4773);
			sub_988A7_read(langfile, a3 + 4773, 12);
			if (x_BYTE_E29E0 || x_DWORD_D41BC_langbuffer)
				sub_83E80_sound_proc_99(x_DWORD_D41BC_langbuffer);
			v8 = v13 - 4785;
			v9 = (Bit8u*)sub_83CD0_malloc2(v13 - 4785);
			x_DWORD_D41BC_langbuffer = v9;
			if (v9)
			{
				x_BYTE_E29E0 = 1;
				sub_988A7_read(langfile, v9, v8);
			}
			sub_98882_close(langfile);
			break;
		}
		v10 = i;
		sprintf_s(printbuffer, 512, "LANGUAGE/%s", langcountstring);
	}
	if (x_WORD_180660_VGA_type_resolution & 1)
		sub_98709_create_index_dattab_power(a1, a2, a3, a3dattabindex);
	else
		sub_9874D_create_index_dattab(a1, a2, a3, a3dattabindex);
	sub_5B870(x_DWORD_D41BC_langbuffer, x_DWORD_E9C4C_langindexbuffer, 471);
	return langcount;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// 988DA: using guessed type x_DWORD filelength(x_DWORD);
// 98F9E: using guessed type x_DWORD unknown_libname_1_atoi(x_DWORD);
// D41A4: using guessed type int x_DWORD_D41A4;
// D41BC: using guessed type int x_DWORD_D41BC_langbuffer;
// E29E0: using guessed type char x_BYTE_E29E0;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0007FAE0) --------------------------------------------------------
Bit32u sub_7FAE0_draw_text(char* text, Bit16s a2, Bit16s a3, Bit16s posy, Bit8u a5)//260ae0
{
	Bit32u helpstrlen; // kr04_4
	Bit16s v6; // bx
	Bit32s posx; // ebx

	helpstrlen = strlen(text);
	v6 = a3 - a2;//ebx[ebx+1c] - 1e2 edx[ebp+18] - 12a
	if (helpstrlen == 1)
	{
		posx = a2 + v6 / 2;
	}
	else
	{
		posx = v6 / 2 + a2 - xy_DWORD_17DEC0_spritestr[65].sizex * helpstrlen / 2;
		sub_7FB90_draw_text(text, posx, posy, a5);//"clisk here to" 13d 138 0
	}
	return posx + xy_DWORD_17DEC0_spritestr[65].sizex * strlen(text);
}
// 17DEC0: using guessed type int (int)x_DWORD_17DEC0;

//----- (0007FB90) --------------------------------------------------------
void sub_7FB90_draw_text(char* textbuffer, Bit16s posx, Bit16s posy, Bit8u color)//260b90
{
	char *temptextbuffer; // esi
	Bit16s tempposx; // ebx
	Bit16s tempposy; // di
	char v7; // ax
	int v8; // eax
	//int result; // eax
	int v10; // [esp+0h] [ebp-4h]

	temptextbuffer = textbuffer;
	tempposx = posx;
	tempposy = posy;
	if (color)
		x_WORD_E36D4 = 64;
	/*if ((posx & 0x8000u) != 0)
		tempposx = 0;*///fix
	v10 = tempposx;
	while (temptextbuffer[0] && tempposx < 640)
	{
		v7 = temptextbuffer[0];
		if (v7 < 0xAu)//formating char
		{
			if (!temptextbuffer[0])
			{
				temptextbuffer++;
				continue;
			}//goto LABEL_21;
			if (v7 == 0x9u)//tab char
			{
				v8 = xy_DWORD_17DEC0_spritestr[65].sizex;
				tempposx += v8;
				temptextbuffer++;
				continue;
			}
			//goto LABEL_20;
	  //LABEL_16:
			if (temptextbuffer[0])//not end char
			{
				if (color)
					sub_72C40_draw_bitmap_640_setcolor(tempposx, tempposy, xy_DWORD_17DEC0_spritestr[temptextbuffer[0]], color);
				else
					sub_7C120_draw_bitmap_640(tempposx, tempposy, xy_DWORD_17DEC0_spritestr[temptextbuffer[0]]);
			}
			v8 = xy_DWORD_17DEC0_spritestr[65].sizex;
			tempposx += v8;
			temptextbuffer++;
			continue;
			//goto LABEL_20;
		}
		if (v7 <= 0xAu) // formating char
		{
			tempposx = v10;
			tempposy += xy_DWORD_17DEC0_spritestr[65].sizey;
			{
				temptextbuffer++;
				continue;
			}//goto LABEL_21;
		}
		if (v7 == 0xDu) // formating char cariage return
		{
			temptextbuffer++;
			continue;
		}//goto LABEL_21;
		if ((v7 < 0xDu) || (v7 != 32)) // formating char
		{
			if (temptextbuffer[0])//not end char
			{
				if (color)
					sub_72C40_draw_bitmap_640_setcolor(tempposx, tempposy, xy_DWORD_17DEC0_spritestr[temptextbuffer[0]], color);
				else
					sub_7C120_draw_bitmap_640(tempposx, tempposy, xy_DWORD_17DEC0_spritestr[temptextbuffer[0]]);
			}
			v8 = xy_DWORD_17DEC0_spritestr[65].sizex;
			tempposx += v8;
			temptextbuffer++;
			continue;
		}//goto LABEL_16;
		/*
		if ( v7 != 32 )//not space
		{
			if (temptextbuffer[0])//not end char
			{
				if (a4)
					sub_72C40_draw_bitmap_640_setcolor(tempposx, tempposy, xy_DWORD_17DEC0_spritestr[temptextbuffer[0]], a4);
				else
					sub_7C120_draw_bitmap_640(tempposx, tempposy, xy_DWORD_17DEC0_spritestr[temptextbuffer[0]]);
			}
			v8 = xy_DWORD_17DEC0_spritestr[65].sizex;
			tempposx += v8;
			temptextbuffer++;
			continue;
		}//goto LABEL_16;*/
		//LABEL_20:
			//HIWORD(v8) = HIWORD(x_DWORD_17DEC0);
		v8 = xy_DWORD_17DEC0_spritestr[65].sizex;
		tempposx += v8;
		//LABEL_21:
		temptextbuffer++;
	}
	//result = v5;
	x_WORD_E36D4 = 0;
	//return result;
}
// E36D4: using guessed type __int16 x_WORD_E36D4;
// 17DEC0: using guessed type int (int)x_DWORD_17DEC0;

//----- (0007FCB0) --------------------------------------------------------
int sub_7FCB0_draw_text_with_border(int a1, Bit8u* a2, Bit32s a3, Bit32s a4, int a5, Bit8u a6, unsigned __int8 a7, Bit32u a8)//260cb0
{
	int v8; // esi
	signed __int16 j; // di
	Bit8u v10; // eax
	int v11; // ebx
	Bit8u v12; // al
	int v13; // edi
	__int16 v14; // ST0C_2
	int v15; // eax
	int v16; // eax
	signed __int16 i; // di
	Bit8u v18; // eax
	Bit8u* v19; // ecx
	__int16 v20; // di
	Bit8u v21; // eax
	char v22; // al
	char v23; // ah
	char v24; // cl
	__int16 v25; // ax
	int v26; // esi
	unsigned __int8 v27; // al
	int v28; // esi
	__int16 v29; // ST0C_2
	int v30; // eax
	Bit8u *v31; // ecx
	signed __int16 v32; // ax
	__int16 v33; // si
	int v34; // eax
	__int16 v35; // ST0C_2
	__int16 v36; // ST08_2
	signed __int16 v37; // di
	Bit8u *v38; // ecx
	__int16 v39; // si
	unsigned __int16 v40; // ax
	__int16 v41; // di
	int v42; // eax
	int v43; // eax
	int v44; // eax
	unsigned __int8 v45; // al
	int v46; // esi
	__int16 v47; // ST0C_2
	int v48; // edi
	__int16 v49; // ST0C_2
	int v50; // eax
	int v51; // ebx
	unsigned __int8 v52; // al
	__int16 v53; // ST0C_2
	int v54; // ST08_4
	int v55; // eax
	signed __int16 v56; // si
	signed __int16 v57; // si
	x_BYTE *v58; // ecx
	int v59; // eax
	__int16 v60; // ax
	int v61; // edi
	int v62; // eax
	int v63; // ebx
	Bit8u *v64; // ecx
	signed __int16 v65; // di
	__int16 v66; // si
	int v67; // eax
	signed __int16 v68; // si
	__int16 v69; // ST0C_2
	__int16 v70; // ST08_2
	int v71; // eax
	x_BYTE *v72; // ecx
	signed __int16 l; // si
	__int16 v74; // ax
	int v75; // esi
	int v76; // eax
	int v77; // ebx
	Bit8u *v78; // ecx
	signed __int16 v79; // si
	__int16 v80; // ax
	int v81; // eax
	signed __int16 v82; // si
	__int16 v83; // ST08_2
	int v84; // eax
	Bit8u v86; // [esp-4h] [ebp-FCh]
	char* v86b; // [esp-4h] [ebp-FCh]
	char v87[180]; // [esp+0h] [ebp-F8h]
	int v88; // [esp+B4h] [ebp-44h]
	int v89; // [esp+B8h] [ebp-40h]
	int v90; // [esp+BCh] [ebp-3Ch]
	int v91; // [esp+C0h] [ebp-38h]
	//int v92; // [esp+C4h] [ebp-34h]
	Bit32s v93; // [esp+C8h] [ebp-30h]
	Bit32s v94; // [esp+CCh] [ebp-2Ch]
	int v95; // [esp+D0h] [ebp-28h]
	int v96; // [esp+D4h] [ebp-24h]
	unsigned __int16 v97; // [esp+D8h] [ebp-20h]
	int v98; // [esp+DCh] [ebp-1Ch]
	int v99; // [esp+E0h] [ebp-18h]
	Bit32s k; // [esp+E4h] [ebp-14h]
	Bit32s v101; // [esp+E8h] [ebp-10h]
	int v102; // [esp+ECh] [ebp-Ch]
	int v103; // [esp+F0h] [ebp-8h]
	Bit32s v104; // [esp+F4h] [ebp-4h]

	//debug
	//loadfromsnapshot((char*)"0160-00260CB0", (Bit8u*)&v87, 0x354e80,180);//zbytecne
	/*loadfromsnapshot((char*)"0160-00260CB0", (Bit8u*)&a6, 0x354f6c, 1);
	loadfromsnapshot((char*)"0160-00260CB0", (Bit8u*)&a4, 0x354f64, 4);
	loadfromsnapshot((char*)"0160-00260CB0", (Bit8u*)&a3, 0x354f60, 4);
	loadfromsnapshot((char*)"0160-00260CB0", (Bit8u*)&a8, 0x354f74, 4);*/
	/*loadfromsnapshot2((char*)"0160-00260CB0", (Bit8u*)x_DWORD_17DED4, 0x34eed4, 1000);
	a2 = (Bit8u*)malloc(0x10000);
	loadfromsnapshot((char*)"0160-00260CB0", (Bit8u*)a2, 0x354f5c, 0x10000);*/
	//a5 = 0x12c;

	//debug

	//fix it
	v86 = a7;
	//fix it

	v8 = a5;
	v98 = a5;
	v102 = a5;
	v95 = 0;
	v103 = 0;
	v104 = 0;
	memset(v87, 0, 180);
	if (a6)
	{
		if (a6 == 2 || a6 == 5)
		{
			v104 = a4 - a3;
			if (a8)
			{
				v103 = xy_DWORD_17DED4_spritestr[275].sizex;
				v90 = xy_DWORD_17DED4_spritestr[275].sizex;
				v94 = v104 / v90;
				if (v104 % v90)
				{
					v16 = v103 * (v94++ + 1);
					v104 = v16;
					a4 = v16 + a3 - xy_DWORD_17DED4_spritestr[274].sizex;
				}
				for (i = 0; i < v104; i += v103)
					sub_7C120_draw_bitmap_640(i + a3, a5, xy_DWORD_17DED4_spritestr[275]);
				//HIWORD(v18) = HIWORD(xy_DWORD_17DED4_spritestr);
				v18 = xy_DWORD_17DED4_spritestr[275].sizey;
				v8 = v18 + a5;
				v19 = (x_DWORD_180628b_screen_buffer + a3 + 640 * (v18 + a5));
				for (v93 = 0;v93 < xy_DWORD_17DED4_spritestr[274].sizey;v93++)
				{
					for (v20 = 0;v20 < a4 - (v90 + a3);v20++)
					{
						v90 = xy_DWORD_17DED4_spritestr[274].sizex;
						HIBYTE(v97) = 15;
						LOBYTE(v97) = *v19;
						v19++;
						*(v19 - 1) = x_DWORD_17DE3C[v97];
					}
					v19 += 640 - v20;
				}
				sub_7C120_draw_bitmap_640(a3, v8, xy_DWORD_17DED4_spritestr[274]);
				sub_7C120_draw_bitmap_640(a4 - xy_DWORD_17DED4_spritestr[274].sizex, v8, xy_DWORD_17DED4_spritestr[274]);
			}
			if (a8)
			{
				//HIWORD(v21) = HIWORD(xy_DWORD_17DED4_spritestr);
				v21 = xy_DWORD_17DED4_spritestr[274].sizey;
				a1 = v21 + v8;
				v98 += v21;
			}
			else
			{
				v98 = v8;
			}
		}
	}
	else
	{//ramecek s textem
		v104 = a4 - a3;//adress 260cf1
		v88 = a8;
		//v92 = (int)xy_DWORD_17DED4_spritestr;
		v103 = xy_DWORD_17DED4_spritestr[a8].sizex;//10
		if ((a4 - a3) % v103)
		{
			v104 = ((a4 - a3) / v103 + 1) * v103;
			a4 = v104 + a3 - xy_DWORD_17DED4_spritestr[(v88 - 1)].sizex;
		}
		for (j = 0; j < v104; j += v103)//ramecek - horni vodorovna linka
			sub_7C120_draw_bitmap_640(j + a3, a5, xy_DWORD_17DED4_spritestr[a8]);//25d120

//HIWORD(v10) = HIWORD(xy_DWORD_17DED4_spritestr); 
		v10 = xy_DWORD_17DED4_spritestr[a8].sizey;//adress 260da7
		v11 = v10 + a5;
		v98 += v10;
		v12 = sub_5BE80_test_pallette(x_DWORD_17DE38, 0, 0, v86);
		v86 = v12;
		v13 = 6 * (a8 - 1);
		v14 = xy_DWORD_17DED4_spritestr[v13 / 6].sizey;
		v91 = v11;
		v90 = a3;
		sub_7C140_draw_text_background(a3, v11, v104, v14, v12);//prvni cerna linka
		sub_7C120_draw_bitmap_640(v90, v91, xy_DWORD_17DED4_spritestr[v13 / 6]);//prvni levy svisly dilek
		sub_7C120_draw_bitmap_640(a4, v91, xy_DWORD_17DED4_spritestr[v13 / 6]);//prvni pravy svisly dilek
		//HIWORD(v15) = HIWORD(xy_DWORD_17DED4_spritestr);
		v15 = xy_DWORD_17DED4_spritestr[v13 / 6].sizey;
		a1 = v15 + v11;
		v98 += v15;
	}
	v99 = a3;
	if (!a6)//adress 261023
		v98 = v8 + 12;
	v96 = 0;
	v101 = 0;
	for (k = 0; ; k++)
	{
		v22 = 0;
		if (a6)
		{
			v24 = a2[k];
			if (v24 == ' ' || v24==0)
			{
			LABEL_38:
				v22 = 1;
				goto LABEL_39;
			}
		}
		else
		{
			v23 = a2[k];
			if (v23 == ' ' || v23==0 || v23 == ',' || v23 == '-' || v23 == '.')
				goto LABEL_38;
		}
	LABEL_39:
		if (v22)//space in text adress 26107c
		{
			if (v101)
			{
				if (a6 && a6 != 4 && a6 != 5)//adress 261091
				{
					sub_6FC50(1/*v86*/);
					v25 = sub_6FC10_letter_width();
				}
				else
				{
					v25 = xy_DWORD_17DEC0_spritestr[65].sizex;
				}
				v89 = k;
				v26 = v99;
				if (v99 + v25 * (k - v96) <= a4 - 3 * v25)//adress 2610c2
				{
					v86b = &v87[strlen(v87)];
					qmemcpy(v86b, &a2[v101 + 1], v89 - v101);
				}
				else//width is higher then line size
				{
					if (a6 && a6 != 4)
					{
						if (a6 == 2)
						{
							sub_6FC50(1/*v86*/);
							v31 = &x_DWORD_180628b_screen_buffer[v26 + 640 * a1];							
							for (v32 = 0;v32 < xy_DWORD_17DED4_spritestr[274].sizey;v32++)
							{
								for (v33 = 0;v33 < a4 - (v99 - xy_DWORD_17DED4_spritestr[274].sizex);v33++)
								{
									HIBYTE(v97) = 15;
									LOBYTE(v97) = *v31;									
									v31++;
									*(v31 - 1) = x_DWORD_17DE3C[v97];
								}								
								v31 += 640 - v33;
							}
							sub_7C120_draw_bitmap_640(v99, a1, xy_DWORD_17DED4_spritestr[274]);
							sub_7C120_draw_bitmap_640(a4, a1, xy_DWORD_17DED4_spritestr[274]);
							//HIWORD(v34) = HIWORD(xy_DWORD_17DED4_spritestr);
							v34 = xy_DWORD_17DED4_spritestr[274].sizey;
							a1 += v34;
							v86 = a7;
							v35 = v98;
							v36 = a4 - 2 * sub_6FC10_letter_width();
							sub_6FC80_pre_draw_text(v87, v99 + xy_DWORD_17DED4_spritestr[275].sizex, v36, v35, a7);
						}
						else if (a6 == 5)
						{
							if (a8)
							{
								v38 = &x_DWORD_180628b_screen_buffer[v99 + 640 * a1];
								for (v37 = 0;v37 < xy_DWORD_17DED4_spritestr[274].sizey;v37++)
								{
									for (v39 = 0;v39 < a4 - (xy_DWORD_17DED4_spritestr[274].sizex + v99); v39++)
									{
										HIBYTE(v40) = 15;
										LOBYTE(v40) = *v38;
										v38++;
										*(v38 - 1) = x_DWORD_17DE3C[v40];
									}
									v38 += 640 - v39;
								}
								v41 = v99;
								sub_7C120_draw_bitmap_640(v99, a1, xy_DWORD_17DED4_spritestr[274]);
								v86 = *xy_DWORD_17DED4_spritestr[274].pointer;
								sub_7C120_draw_bitmap_640(a4 - xy_DWORD_17DED4_spritestr[274].sizex, a1, xy_DWORD_17DED4_spritestr[274]);
								//HIWORD(v42) = HIWORD(xy_DWORD_17DED4_spritestr);
								v42 = xy_DWORD_17DED4_spritestr[274].sizey;
								a1 += v42;
								//2613b3
								sub_7FAE0_draw_text(v87, v41, a4, v98, 0/*v86*/);
							}
							else
							{
								sub_7FAE0_draw_text(v87, v99, a4, v98, 0/*v86*/);
							}
						}
						else
						{
							sub_6FC80_pre_draw_text(v87, v99, a4, v98, a7);
						}
					}
					else
					{
						if (!a6)
						{
							v27 = sub_5BE80_test_pallette(x_DWORD_17DE38, 0, 0, v86);
							v86 = v27;
							v28 = 6 * (a8 - 1);
							v29 = xy_DWORD_17DED4_spritestr[v28 / 6].sizey;
							v90 = v99;
							sub_7C140_draw_text_background(v99, a1, v104, v29, v27);
							sub_7C120_draw_bitmap_640(v90, a1, xy_DWORD_17DED4_spritestr[v28 / 6]);
							sub_7C120_draw_bitmap_640(a4, a1, xy_DWORD_17DED4_spritestr[v28 / 6]);
							//HIWORD(v30) = HIWORD(xy_DWORD_17DED4_spritestr);
							v30 = xy_DWORD_17DED4_spritestr[v28 / 6].sizey;
							a1 += v30;
						}
						//"click here" 12a 1e2 138 00
						sub_7FAE0_draw_text(v87, v99, a4, v98, 0/*v86*/);//adress 261197 (80197)
					}
					if (a6 && a6 != 4 && a6 != 5)
					{
						LOWORD(v44) = sub_6FC30_get34_sizey();
						v98 += v44 + 2;
					}
					else
					{
						//HIWORD(v43) = HIWORD(x_DWORD_17DEC0);
						v43 = xy_DWORD_17DEC0_spritestr[65].sizey;
						v98 += v43;
					}
					memset(v87, 0, 180);
					v86b = v87;
					qmemcpy(v87, &a2[v101 + 1], k - v101);
					v96 = v101;
				}
			}
			else
			{
				v86b = v87;
				qmemcpy(v87, a2, k + 1);//copy first text word
			}
			v101 = k;
		}
		if (!a2[k])
			break;
	}
	if (!v95)//adress 2614e2 (804e2) discoverwhich
	{
		if (a6 && a6 != 4)
		{
			sub_6FC50(1/*v86*/);
			if (a6 == 2)
			{
				sub_6FC50(1/*v86*/);				
				v58 = (x_BYTE *)(v99 + 640 * a1);
				v59 = (int)x_DWORD_180628b_screen_buffer;
				for (v57 = 0;v57 < xy_DWORD_17DED4_spritestr[274].sizey;v57++)
				{
					v58 += v59;
					for (v60 = 0;v60 < a4 - (v99 - v91);v60++)
					{
						v91 = xy_DWORD_17DED4_spritestr[274].sizex;
						HIBYTE(v97) = 15;
						LOBYTE(v97) = *v58;
						v58++;
						*(v58 - 1) = x_DWORD_17DE3C[v97];
					}
					v59 = 640 - v60;
				}
				v61 = v99;
				sub_7C120_draw_bitmap_640(v99, a1, xy_DWORD_17DED4_spritestr[274]);
				sub_7C120_draw_bitmap_640(a4, a1, xy_DWORD_17DED4_spritestr[274]);
				//HIWORD(v62) = HIWORD(xy_DWORD_17DED4_spritestr);
				v62 = xy_DWORD_17DED4_spritestr[274].sizey;
				v63 = v62 + a1;
				sub_6FC50(1/*v86*/);
				v64 = &x_DWORD_180628b_screen_buffer[640 * v63 + v61];				
				for (v65 = 0;v65 < xy_DWORD_17DED4_spritestr[274].sizey;v65++)
				{					
					for (v66 = 0;v66 < a4 - (v99 - v91);v66++)
					{
						v91 = xy_DWORD_17DED4_spritestr[274].sizex;
						if (v66 >= a4 - (v99 - v91))
							break;
						HIBYTE(v97) = 15;
						LOBYTE(v97) = *v64;
						v64++;
						*(v64 - 1) = x_DWORD_17DE3C[v97];
					}
					v64 += 640 - v66;
				}
				sub_7C120_draw_bitmap_640(v99, v63, xy_DWORD_17DED4_spritestr[274]);
				sub_7C120_draw_bitmap_640(a4, v63, xy_DWORD_17DED4_spritestr[274]);
				//HIWORD(v67) = HIWORD(xy_DWORD_17DED4_spritestr);
				v67 = xy_DWORD_17DED4_spritestr[274].sizey;
				v68 = 0;
				a1 = v67 + v63;
				while (v68 < v104)
				{
					sub_7C120_draw_bitmap_640(v68 + a3, a1, xy_DWORD_17DED4_spritestr[275]);
					v68 += v103;
				}
				v86 = a7;
				v69 = v98;
				v70 = a4 - 2 * sub_6FC10_letter_width();
				sub_6FC80_pre_draw_text(v87, v99 + xy_DWORD_17DED4_spritestr[275].sizex, v70, v69, a7);
			}
			else if (a6 == 5)
			{
				if (a8)
				{
					v71 = 640 * a1 + v99;
					v72 = (x_BYTE *)x_DWORD_180628b_screen_buffer;
					for (l = 0;l < xy_DWORD_17DED4_spritestr[274].sizey; l++)
					{
						v72 += v71;
						v74 = 0;
						for (v74 = 0;v74 < a4 - (xy_DWORD_17DED4_spritestr[274].sizex + v99);v74++)
						{
							HIBYTE(v97) = 15;
							LOBYTE(v97) = *v72;
							v72++;
							*(v72 - 1) = x_DWORD_17DE3C[v97];
						}
						v71 = 640 - v74;
					}
					v75 = v99;
					sub_7C120_draw_bitmap_640(v99, a1, xy_DWORD_17DED4_spritestr[274]);
					v86 = *xy_DWORD_17DED4_spritestr[274].pointer;
					sub_7C120_draw_bitmap_640(a4 - xy_DWORD_17DED4_spritestr[274].sizex, a1, xy_DWORD_17DED4_spritestr[274]);
					//HIWORD(v76) = HIWORD(xy_DWORD_17DED4_spritestr);
					v76 = xy_DWORD_17DED4_spritestr[274].sizey;
					v77 = v76 + a1;
					v78 = &x_DWORD_180628b_screen_buffer[640 * v77 + v75];
					v79 = 0;
					for (v79 = 0;v79 < xy_DWORD_17DED4_spritestr[274].sizey;v79++)
					{
						v80 = 0;
						for (v80 = 0;v80 < a4 - (xy_DWORD_17DED4_spritestr[274].sizex + v99);v80++)
						{
							HIBYTE(v97) = 15;
							LOBYTE(v97) = *v78;
							v78++;
							*(v78 - 1) = x_DWORD_17DE3C[v97];
						}
						v78 += 640 - v80;
					}
					sub_7C120_draw_bitmap_640(v99, v77, xy_DWORD_17DED4_spritestr[274]);
					v86 = *xy_DWORD_17DED4_spritestr[274].pointer;
					sub_7C120_draw_bitmap_640(a4 - xy_DWORD_17DED4_spritestr[274].sizex, v77, xy_DWORD_17DED4_spritestr[274]);
					//HIWORD(v81) = HIWORD(xy_DWORD_17DED4_spritestr);
					v81 = xy_DWORD_17DED4_spritestr[274].sizey;

					a1 = v81 + v77;
					for (v82 = 0;v82 < v104;v82 += v103)
					{
						v83 = v82 + a3;
						sub_7C120_draw_bitmap_640(v83, a1, xy_DWORD_17DED4_spritestr[275]);
					}
					sub_7FAE0_draw_text(v87, v99 + xy_DWORD_17DED4_spritestr[275].sizex, a4, v98, 0);
				}
				else
				{
					sub_7FAE0_draw_text(v87, v99, a4, v98, 0/*v86*/);
				}
			}
			else
			{
				sub_6FC80_pre_draw_text(v87, v99, a4, v98, a7);
			}
		}
		else
		{
			if (!a6)
			{
				v45 = sub_5BE80_test_pallette(x_DWORD_17DE38, 0, 0, v86);
				v86 = v45;
				v46 = 6 * (a8 - 1);
				v47 = xy_DWORD_17DED4_spritestr[v46 / 6].sizey;
				v91 = v104;
				v48 = v99;
				v90 = a1;
				sub_7C140_draw_text_background(v99, a1, v104, v47, v45);//vykresli dalsi cerny radek
				sub_7C120_draw_bitmap_640(v48, v90, xy_DWORD_17DED4_spritestr[v46 / 6]);//vykresli dalsi levy sloupek ramecku
				v49 = v90;
				v90 = a4;
				sub_7C120_draw_bitmap_640(a4, v49, xy_DWORD_17DED4_spritestr[v46 / 6]);//vykresli dalsi pravy sloupek ramecku
				//HIWORD(v50) = HIWORD(xy_DWORD_17DED4_spritestr);
				v50 = xy_DWORD_17DED4_spritestr[v46 / 6].sizey;
				v51 = v50 + a1;
				v52 = sub_5BE80_test_pallette(x_DWORD_17DE38, 0, 0, v86);//?
				v86 = v52;
				v53 = xy_DWORD_17DED4_spritestr[v46 / 6].sizey;
				v54 = v91;
				v91 = v51;
				sub_7C140_draw_text_background(v48, v51, v54, v53, v52);//vykresli dalsi cerny radek
				sub_7C120_draw_bitmap_640(v48, v91, xy_DWORD_17DED4_spritestr[v46 / 6]);//vykresli dalsi levy sloupek ramecku
				sub_7C120_draw_bitmap_640(v90, v91, xy_DWORD_17DED4_spritestr[v46 / 6]);//vykresli dalsi pravy sloupek ramecku
				//HIWORD(v55) = HIWORD(xy_DWORD_17DED4_spritestr);
				v55 = xy_DWORD_17DED4_spritestr[v46 / 6].sizey;
				v56 = 0;
				a1 = v55 + v51;
				while (v56 < v104)
				{
					sub_7C120_draw_bitmap_640(v56 + v99, a1, xy_DWORD_17DED4_spritestr[a8]);//vykresli spodni linku ramecku
					v56 += v103;
				}
			}
			sub_7FAE0_draw_text(v87, v99, a4, v98, 0/*v86*/);//prida text + mozna je to i dotazeni palety
		}
	}
	if (a6)
		return v98 - v102;
	//HIWORD(v84) = HIWORD(xy_DWORD_17DED4_spritestr);
	v84 = xy_DWORD_17DED4_spritestr[(a8 + 2)].sizey;

	//debug
	//compare_with_snapshot((char*)"0x45678", (Bit8u*)&v8, 0x4589, 4);
	//debug

	return a1 - v102 + v84;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 17DE38: using guessed type int x_DWORD_17DE38;
// 17DE3C: using guessed type int x_DWORD_17DE3C;
// 17DEC0: using guessed type int (int)x_DWORD_17DEC0;
// 17DED4: using guessed type int (int)x_DWORD_17DED4;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 7FCB0: using guessed type char var_F8[180];


//----- (00080C30) --------------------------------------------------------
void sub_80C30_draw_texts(__int16 a1, __int16 a2, __int16 a3)//261c30
{
	signed int v3; // ebx
	char *v4; // eax
	signed int v5; // edx
	Bit16s* i; // eax
	unsigned __int8 v7; // ST14_1
	int v8; // ST08_4
	__int16 v9; // ax

	v3 = -1;
	v4 = (char *)&unk_E17CC[0x194];
	v5 = 0;
	while (*(Bit32s*)((Bit16s*)v4 + 2))
	{
		if (v4[18] == 2)
		{
			v3 = v5;
			break;
		}
		v4 += 22;
		v5++;
	}
	if (a2 + a1 > 0)
	{
		for (i = x_WORD_E2970; *(Bit32s*)&i[6]; i = (x_WORD *)((char *)i + 17))
		{
			if (*(Bit32s*)&i[6] != 3 && v3 == i[2])
			{
				x_DWORD_17DE28str.x_BYTE_17DE34 = 3;
				return;
			}
		}
		sub_6FC50(1);
		v7 = sub_5BE80_test_pallette((unsigned __int8 *)x_DWORD_17DE38, 0x3Fu, 0x3Fu, 0x3Fu);
		v8 = (signed __int16)(a1 + a3 - 3 * sub_6FC10_letter_width());
		v9 = sub_6FC10_letter_width();
		sub_7FCB0_draw_text_with_border(v3, x_DWORD_E9C4C_langindexbuffer[23 + v3], (signed __int16)(a1 + 4 * v9), v8, a2, 5, v7, 1);		
	}
	if (x_DWORD_17DE28str.x_BYTE_17DE34 != 3 && x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 0x40 && !x_BYTE_17E09D)
	{
		x_BYTE_17E09D = 1;
		if ((signed __int16)v3 != -1)
			sub_86EB0(v3, 0, 0);
	}
}
// D41A4: using guessed type int x_DWORD_D41A4;
// 17DE34: using guessed type char x_BYTE_17DE34;
// 17DE38: using guessed type int x_DWORD_17DE38;
// 17E09D: using guessed type char x_BYTE_17E09D;

//----- (00080D40) --------------------------------------------------------
signed int sub_80D40_move_graphics_and_play_sounds(__int16 a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6)//261d40
{
	signed int v6; // ebx
	char *v7; // eax
	char v8; // dl
	int v10; // edx
	int v11; // ebx
	__int16 v12; // ax
	int v13; // edx
	int v14; // edx
	__int16 v15; // si
	__int16 v16; // ax
	char v17; // dh
	signed __int16 v18; // cx
	Bit8u* v19; // ecx
	int v20; // edx
	__int16 v21; // [esp+0h] [ebp-10h]
	__int16 v22; // [esp+2h] [ebp-Eh]
	__int16 v23; // [esp+8h] [ebp-8h]
	__int16 v24; // [esp+Ah] [ebp-6h]

	v6 = 1;
	if (x_BYTE_17E09C >= 1u)
	{
		if (x_BYTE_17E09C > 2u)
			return v6;
		v15 = 0;
		while (v15 < 3)
		{
			v15++;
			v6 = sub_7E9D0(&x_WORD_17E06C, &x_WORD_17E06E, (x_WORD*)&unk_17E084);
		}
		v23 = x_WORD_17E074;
		v24 = x_WORD_17E076;
		v21 = x_WORD_17E06C;
		v22 = x_WORD_17E06E;
		v16 = sub_581E0((Bit16u*)&v23, (Bit16u*)&v21);
		if (v16 > 1024 && v16 < 1536)
		{
			if (x_BYTE_17E082 != 21)
			{
				x_WORD_17E080 = 21;
				x_BYTE_17E082 = 21;
				x_BYTE_17E083 = 24;
			}
			goto LABEL_54;
		}
		if (v16 <= 1536 || v16 >= 2048)
		{
			if ((v16 > 2048 || v16 > 0) && v16 < 512)
			{
				if (x_BYTE_17E082 != 5)
				{
					x_WORD_17E080 = 5;
					x_BYTE_17E082 = 5;
					x_BYTE_17E083 = 8;
				}
				goto LABEL_54;
			}
			if (v16 <= 512 || v16 >= 1024)
			{
				switch (v16)
				{
				case 2048:
				case 0:
					if (x_BYTE_17E082 != 17)
					{
						x_WORD_17E080 = 17;
						x_BYTE_17E082 = 17;
						x_BYTE_17E083 = 20;
					}
					goto LABEL_54;
				case 512:
					if (x_BYTE_17E082 == 9)
						goto LABEL_54;
					x_BYTE_17E082 = 9;
					v17 = 12;
					x_WORD_17E080 = 9;
					goto LABEL_53;
				case 1024:
					if (x_BYTE_17E082 != 1)
					{
						x_WORD_17E080 = 1;
						x_BYTE_17E082 = 1;
						x_BYTE_17E083 = 4;
					}
					goto LABEL_54;
				}
				if (v16 != 1536 || x_BYTE_17E082 == 25)
				{
				LABEL_54:
					x_WORD_17E07C = x_WORD_17E06C;
					x_WORD_17E07E = x_WORD_17E06E;
					if (a6 != 1
						&& x_BYTE_17E09C != 2
						&& !(x_WORD)v6
						&& (abs(x_WORD_17E06E - x_WORD_17E072) > 8 || abs(x_WORD_17E06C - x_WORD_17E070) > 8))
					{
						if (x_DWORD_17DB70str.x_WORD_17DB8A == -1)
							sub_812D0(x_WORD_17E07C, x_WORD_17E07E);
						x_WORD_17E070 = x_WORD_17E06C;
						x_WORD_17E072 = x_WORD_17E06E;
					}
					v19 = xy_DWORD_17DED4_spritestr[x_WORD_17E080].pointer;
					v20 = x_WORD_17E06C - *(unsigned __int8 *)(v19 + 4) / 2 - a2;
					sub_81260(
						(signed __int16)v20,
						v20,
						(int)&unk_17E078,
						x_WORD_17E06C - *(unsigned __int8 *)(v19 + 4) / 2 - a2,
						x_WORD_17E06E - *(unsigned __int8 *)(v19 + 5) / 2 - a3);
					if ((x_WORD)v6)
						x_BYTE_17E09C = 3;
					return v6;
				}
				v18 = 25;
				x_BYTE_17E082 = 25;
				v17 = 28;
			}
			else
			{
				if (x_BYTE_17E082 == 13)
					goto LABEL_54;
				v18 = 13;
				x_BYTE_17E082 = 13;
				v17 = 16;
			}
			x_WORD_17E080 = v18;
		}
		else
		{
			if (x_BYTE_17E082 == 29)
				goto LABEL_54;
			x_BYTE_17E082 = 29;
			v17 = 32;
			x_WORD_17E080 = 29;
		}
	LABEL_53:
		x_BYTE_17E083 = v17;
		goto LABEL_54;
	}
	if (!x_BYTE_17E09C)
	{
		if (x_DWORD_17DB70str.x_WORD_17DB8A == -1)
		{
			v7 = (char *)&unk_E17CC[0x194];
			a1 = 0;
			x_WORD_17E06C = 0;
			x_WORD_17E06E = 0;
			while (*((x_WORD *)v7 + 2))
			{
				v8 = v7[18];
				if (v8 == 1)
				{
					x_WORD_17E06C = *((x_WORD *)v7 + 6);
					x_WORD_17E06E = *((x_WORD *)v7 + 7);
				}
				else if (v8 == 2 && !a1)
				{
					return 1;
				}
				v7 += 22;
				++a1;
			}
		}
		x_WORD_17E074 = a4;
		v10 = xy_DWORD_17DED4_spritestr[37].sizex;
		x_WORD_17E076 = a5;
		v11 = v10 / 2;
		v12 = v10 / 2 + a4;
		v13 = xy_DWORD_17DED4_spritestr[37].sizey;
		x_WORD_17E074 = v12;
		v14 = v13 / 2;
		x_WORD_17E076 = v14 + a5;
		if (x_DWORD_17DB70str.x_WORD_17DB8A == -1)
		{
			x_WORD_17E06C += v11;
			x_WORD_17E06E += v14;
		}
		sub_7E8D0((x_WORD*)&unk_17E084, x_WORD_17E074, x_WORD_17E076, x_WORD_17E06C, x_WORD_17E06E, 2, 2);
		x_BYTE_17E09C = (a1 == 0) + 1;
		x_WORD_17E070 = x_WORD_17E06C;
		x_WORD_17E072 = x_WORD_17E06E;
		v6 = 0;
		if (abs(x_WORD_17E074 - x_WORD_17E06C) > 5 && abs(x_WORD_17E076 - x_WORD_17E06E) > 6)
		{
			sub_8F100_sound_proc19(0, 19, (unsigned __int8)x_BYTE_E1324, 64, 0x64u, 0, 2u);
			return 0;
		}
	}
	return v6;
}
// E1324: using guessed type char x_BYTE_E1324;
// 17DB8A: using guessed type __int16 x_WORD_17DB8A;
// 17DED4: using guessed type int (int)x_DWORD_17DED4;
// 17E06C: using guessed type __int16 x_WORD_17E06C;
// 17E06E: using guessed type __int16 x_WORD_17E06E;
// 17E070: using guessed type __int16 x_WORD_17E070;
// 17E072: using guessed type __int16 x_WORD_17E072;
// 17E074: using guessed type __int16 x_WORD_17E074;
// 17E076: using guessed type __int16 x_WORD_17E076;
// 17E07C: using guessed type __int16 x_WORD_17E07C;
// 17E07E: using guessed type __int16 x_WORD_17E07E;
// 17E080: using guessed type __int16 x_WORD_17E080;
// 17E082: using guessed type char x_BYTE_17E082;
// 17E083: using guessed type char x_BYTE_17E083;
// 17E09C: using guessed type char x_BYTE_17E09C;

//----- (00081260) --------------------------------------------------------
void sub_81260(int a1, int a2, int a3, __int16 a4, __int16 a5)//262260
{
	int v5; // ecx

	v5 = j___clock();
	if ((unsigned int)(v5 - *(x_DWORD *)a3) >> 4 >= 1)
	{
		if (*(signed __int16 *)(a3 + 8) <= *(unsigned __int8 *)(a3 + 11) - 1)
			++*(x_WORD *)(a3 + 8);
		else
			*(x_WORD *)(a3 + 8) = *(unsigned __int8 *)(a3 + 10);
		*(x_DWORD *)a3 = v5;
	}
	sub_7C120_draw_bitmap_640(a4, a5, xy_DWORD_17DED4_spritestr[*(signed __int16 *)(a3 + 8)]);
}
// 98786: using guessed type int /*__fastcall*/ j___clock(x_DWORD, x_DWORD, x_DWORD);
// 17DED4: using guessed type int (int)x_DWORD_17DED4;

//----- (000812D0) --------------------------------------------------------
int sub_812D0(__int16 a1, __int16 a2)//2622d0
{
	int v2; // edi
	__int16 v3; // si
	__int16 v4; // bx
	int result; // eax

	//_disable();
	v2 = (int)x_DWORD_180628b_screen_buffer;
	x_DWORD_180628b_screen_buffer = x_DWORD_17DE64_game_world_map;
	v3 = x_DWORD_180624_resolution_y;
	x_DWORD_180644_map_resolution2_y = 960;
	x_DWORD_180624_resolution_y = 960;
	v4 = x_DWORD_18062C_resolution_x;
	x_DWORD_180648_map_resolution2_x = 1280;
	x_DWORD_18062C_resolution_x = 1280;
	sub_7C120_draw_bitmap_640(a1, a2, xy_DWORD_17DED4_spritestr[139]);
	x_DWORD_18062C_resolution_x = v4;
	x_DWORD_180624_resolution_y = v3;
	x_DWORD_180648_map_resolution2_x = v4;
	result = v3;
	x_DWORD_180628b_screen_buffer = (Bit8u*)v2;
	x_DWORD_180644_map_resolution2_y = v3;
	//_enable();
	return result;
}
// 17DE64: using guessed type int x_DWORD_17DE64_game_world_map;
// 17DED4: using guessed type int (int)x_DWORD_17DED4;
// 180624: using guessed type int x_DWORD_180624_resolution_y;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 18062C: using guessed type int x_DWORD_18062C_resolution_x;
// 180644: using guessed type int x_DWORD_180644_map_resolution2_y;
// 180648: using guessed type int x_DWORD_180648_map_resolution2_x;

//----- (00081360) --------------------------------------------------------
void sub_81360_draw_bitmap_line(Bit16s minx, Bit16s miny, Bit16s maxx, Bit16s maxy, __int16 a5)//262360
{
	Bit32s v5; // edi
	Bit32s v6; // esi
	Bit16s v7; // bx
	Bit16s v8; // ax
	//int v9; // ecx
	Bit32s v10; // eax
	Bit32s v11; // eax
	Bit32s v12; // eax
	Bit32s v13; // eax
	Bit32s v14; // eax
	Bit32s v15; // edx
	Bit32s v17; // edx
	Bit32s v18; // eax
	//Bit16u v19[2]; // [esp+0h] [ebp-38h]
	Bit16s v20; // [esp+2h] [ebp-36h]
	//Bit16u v21; // [esp+8h] [ebp-30h]
	Bit16s v22; // [esp+Ah] [ebp-2Eh]
	//int v23; // [esp+10h] [ebp-28h]
	Bit32s v24; // [esp+14h] [ebp-24h]
	Bit32s v25; // [esp+18h] [ebp-20h]
	Bit32s v26; // [esp+1Ch] [ebp-1Ch]
	Bit32s v27; // [esp+20h] [ebp-18h]
	Bit32u v28; // [esp+24h] [ebp-14h]
	Bit32s v29; // [esp+28h] [ebp-10h]
	Bit32s v30; // [esp+2Ch] [ebp-Ch]
	Bit32s v31; // [esp+30h] [ebp-8h]
	Bit32s v32; // [esp+34h] [ebp-4h]

	//fix it

	//loadfromsnapshot((char*)"0160-00262360", (Bit8u*)&a6, 0x354f6c, 1);
	  //354f10->35f418 +2->35012a .. 012a
	  //354f14->354f20 +2->350168 .. 0168
	  //0168-18a=3e
	  //354f10->35f418->ec0141 .. 0141
	  //354f14->354f20->012a018d .. 018d
	  //18d-141=4c
	//a3 = 0x00000141;
	//a1 = 0x0000018d;
	//a4 = 0x000000ec;
	//a2 = 0x0000012a;
	//loadfromsnapshot2((char*)"0160-00262360", (Bit8u*)x_DWORD_17DED4, 0x34eed4, 0x300);//3e
	//x_D41A0_BYTEARRAY_4[v9 + 4] = 0x0b;
	//fix it

	v5 = minx/* & 0xffff*/;
	v6 = miny/* & 0xffff*/;
	//v21 = a1;
	//v19 = a3;
	v22 = miny/* & 0xffff*/;
	v20 = maxy/* & 0xffff*/;
	v7 = 0;
	v29 = 0;
	v28 = 0;
	v8 = sub_581E0((Bit16u*)&maxx, (Bit16u*)&minx);//2391E0
	/*minx &= 0xffff;
	miny &= 0xffff;
	maxx &= 0xffff;
	maxy &= 0xffff;*/
	if (v8 <= 1024 || v8 >= 1536)
	{
		if (v8 <= 1536 || v8 >= 2048)
		{
			if (v8 <= 2048 && v8 <= 0 || v8 >= 512)
			{
				if (v8 <= 512 || v8 >= 1024)
				{
					if (v8 != 2048 && v8)
					{
						switch (v8)
						{
						case 512:
							v7 = a5 - 3;
							break;
						case 1024:
							v7 = a5 - 5;
							break;
						case 1536:
							v7 = a5 + 3;
							break;
						}
					}
					else
					{
						v7 = a5 - 1;
					}
				}
				else
				{
					v7 = a5 - 4;
				}
			}
			else
			{
				v7 = a5 - 2;
			}
		}
		else
		{
			v7 = a5 + 2;
		}
	}
	else
	{
		v7 = a5 + 4;
	}
	v24 = maxx - minx;
	//v9 = 6 * a5;
	v25 = maxy - miny;
	//v23 = x_DWORD_17DED4[v9 + 4];
	//6*a5
	//dosbox - 258
	//toto - 64
	v31 = 2 * abs((maxx - minx) / xy_DWORD_17DED4_spritestr[a5].sizex);//find errors
	//v23 = x_DWORD_17DED4[v9 + 5];
	v30 = 2 * abs((maxy - miny) / xy_DWORD_17DED4_spritestr[a5].sizey);
	v10 = maxx - minx;
	if ((maxx - minx) >= 0)
	{
		if (maxx != minx)
		{
			//HIWORD(v10) = HIWORD(x_DWORD_17DED4);
			v10 = xy_DWORD_17DED4_spritestr[a5].sizex;
		}
	}
	else
	{
		//HIWORD(v11) = HIWORD(x_DWORD_17DED4);
		v11 = xy_DWORD_17DED4_spritestr[a5].sizex;
		v10 = -v11;
	}
	v27 = v10;
	v12 = v25;
	if ((v25 & 0x8000u) == 0)
	{
		if (v25)
		{
			v12 = xy_DWORD_17DED4_spritestr[a5].sizey;
		}
	}
	else
	{
		v13 = xy_DWORD_17DED4_spritestr[a5].sizey;
		v12 = -v13;
	}
	v26 = v12;
	if (minx >= maxx)
	{
		if (minx > maxx)
			v29 = 1;
	}
	else
	{
		v29 = 2;
	}
	if (miny >= maxy)
	{
		if (miny > maxy)
			v28 = 1;
	}
	else
	{
		v28 = 2;
	}
	if (v31 <= v30)
	{
		v14 = v30;
		v15 = v31;
	}
	else
	{
		v14 = v31;
		v15 = v30;
	}
	v32 = v15 - (v14 >> 1);
	while (1)
	{
		if (v31 <= v30)
		{
			if (v6 == maxy)
			{
				sub_7C120_draw_bitmap_640(v5, maxy, xy_DWORD_17DED4_spritestr[v7]);
				return;
			}
			if ((v32 & 0x8000u) == 0)
			{
				v5 += v27;
				v32 -= v30;
			}
			v17 = v32;
			v6 += v26;
			v18 = v31;
		}
		else
		{
			if (v5 == maxx)
			{
				sub_7C120_draw_bitmap_640(maxx, v6, xy_DWORD_17DED4_spritestr[v7]);
				return;
			}
			if ((v32 & 0x8000u) == 0)
			{
				v6 += v26;
				v32 -= v31;
			}
			v17 = v32;
			v5 += v27;
			v18 = v30;
		}
		v32 = v18 + v17;
		if (v29 >= 1u)
		{
			if (v29 <= 1u)
			{
				if (v5 < maxx)
				{
					sub_7C120_draw_bitmap_640(maxx, maxy, xy_DWORD_17DED4_spritestr[v7]);//draw ending
					//ma byt ec a 141
					return;
				}
			}
			else if (v29 == 2 && v5 > maxx)
			{
				sub_7C120_draw_bitmap_640(maxx, maxy, xy_DWORD_17DED4_spritestr[v7]);
				return;
			}
		}
		if (v28 < 1u)
			goto LABEL_70;
		if (v28 > 1u)
			break;
		if (v6 < maxy)
		{
			sub_7C120_draw_bitmap_640(maxx, maxy, xy_DWORD_17DED4_spritestr[v7]);
			return;
		}
	LABEL_70:
		//18d 12a 141 ec - 18d 12a 141 ec -1
		  //c4 26 11b 6a - c4 26 11b 6a -0 - chybi ocasek
		sub_7C120_draw_bitmap_640(v5, v6, xy_DWORD_17DED4_spritestr[a5]);
	}
	if (v28 != 2 || v6 <= maxy)
		goto LABEL_70;
	sub_7C120_draw_bitmap_640(maxx, maxy, xy_DWORD_17DED4_spritestr[v7]);//draw ending
}
// 17DED4: using guessed type int (int)x_DWORD_17DED4;

//----- (00081760) --------------------------------------------------------
void sub_81760_new_game_subdraw(Bit8u* a1)//262760
{
	signed int v1; // esi
	__int16 v2; // bx
	__int16 v3; // di
	x_WORD *i; // ebx
	int v5; // edx
	int v6; // edi
	char *v7; // ebx
	signed __int16 v8; // cx
	char *v9; // edx
	int k; // eax
	int v11; // edi
	int v12; // ebx
	char v14; // [esp+0h] [ebp-44h]
	int v15; // [esp+18h] [ebp-2Ch]
	int j; // [esp+1Ch] [ebp-28h]
	Bit8u* v17; // [esp+20h] [ebp-24h]
	Bit8u* v18; // [esp+24h] [ebp-20h]
	Bit8u* v19; // [esp+28h] [ebp-1Ch]
	int l; // [esp+2Ch] [ebp-18h]
	Bit8u* v21; // [esp+30h] [ebp-14h]
	Bit8u* v22; // [esp+34h] [ebp-10h]
	Bit8u* v23; // [esp+38h] [ebp-Ch]
	int v24; // [esp+3Ch] [ebp-8h]
	Bit8u* v25; // [esp+40h] [ebp-4h]

	// fix it
	v17 = 0;
	v18 = 0;
	v19 = 0;
	// fix it

	v1 = 0;
	v24 = 0;
	if (x_BYTE_E1B82 == 1)
	{
		//_disable();
		v15 = (int)x_DWORD_180628b_screen_buffer;
		x_DWORD_180628b_screen_buffer = x_DWORD_17DE64_game_world_map;
		v2 = x_DWORD_180624_resolution_y;
		x_DWORD_180644_map_resolution2_y = 960;
		x_DWORD_180624_resolution_y = 960;
		v3 = x_DWORD_18062C_resolution_x;
		x_DWORD_180648_map_resolution2_x = 1280;
		x_DWORD_18062C_resolution_x = 1280;
		sub_7C120_draw_bitmap_640(518, 17, xy_DWORD_17DED4_spritestr[285]);
		sub_7C120_draw_bitmap_640(583, 17, xy_DWORD_17DED4_spritestr[286]);
		sub_7C120_draw_bitmap_640(657, 17, xy_DWORD_17DED4_spritestr[287]);
		sub_7C120_draw_bitmap_640(696, 17, xy_DWORD_17DED4_spritestr[288]);
		sub_7C120_draw_bitmap_640(518, 88, xy_DWORD_17DED4_spritestr[289]);
		sub_7C120_draw_bitmap_640(574, 88, xy_DWORD_17DED4_spritestr[290]);
		sub_7C120_draw_bitmap_640(657, 88, xy_DWORD_17DED4_spritestr[291]);
		sub_7C120_draw_bitmap_640(706, 88, xy_DWORD_17DED4_spritestr[292]);
		sub_7C120_draw_bitmap_640(518, 156, xy_DWORD_17DED4_spritestr[293]);
		sub_7C120_draw_bitmap_640(582, 156, xy_DWORD_17DED4_spritestr[294]);
		sub_7C120_draw_bitmap_640(657, 156, xy_DWORD_17DED4_spritestr[295]);
		sub_7C120_draw_bitmap_640(703, 156, xy_DWORD_17DED4_spritestr[296]);
		x_DWORD_18062C_resolution_x = v3;
		x_DWORD_180624_resolution_y = v2;
		x_DWORD_180648_map_resolution2_x = v3;
		x_DWORD_180644_map_resolution2_y = v2;
		//HIWORD(a1) = HIWORD(v15);
		x_DWORD_180628b_screen_buffer = (Bit8u*)v15;
		//_enable();
	}
	for (i = (x_WORD*)&unk_E17CC[0x194]; *(Bit32s*)&i[2]; i += 11)
	{
		if (*((Bit8s*)i + 18) == 1 && !v24)
		{
			LOWORD(a1) = i[6];
			v17 = a1;
			LOWORD(a1) = i[7];
			v19 = a1;
			v17 += xy_DWORD_17DED4_spritestr[37].sizex / 2;
			a1 += xy_DWORD_17DED4_spritestr[37].sizey / 2;
			v24 = 1;
		LABEL_19:
			v19 = a1;
			continue;
		}
		if (v24 && *((Bit8s*)i + 18) == 1)
		{
			LOWORD(a1) = i[7];
			v5 = xy_DWORD_17DED4_spritestr[37].sizex;
			v21 = a1;
			v6 = v5 / 2 + (signed __int16)i[6];
			v21 = xy_DWORD_17DED4_spritestr[37].sizey / 2 + a1;
			memset(&v14, 0, 24);
			sub_7E8D0((Bit16s*)&v14, v6, (int)v21, (int)v17, (int)v19, 2, 2);
			v25 = v17;
			v22 = v19;
			while (!v1)
			{
				for (j = v1; ; j = v1)
				{
					while (j < 3)
					{
						v1 = sub_7E9D0((Bit16s*)&v17, (Bit16s*)&v19, (Bit16s*)&v14);
						j++;
					}
					if (abs((signed __int16)v19 - (signed __int16)v22) <= 8
						&& abs((signed __int16)v17 - (signed __int16)v25) <= 8)
					{
						break;
					}
					sub_812D0((int)v17, (int)v19);
					v25 = v17;
					v22 = v19;
					if (v1)
						goto LABEL_18;
				}
			}
		LABEL_18:
			a1 = v21;
			v17 = (Bit8u*)v6;
			v1 = 0;
			goto LABEL_19;
		}
	}
	if (x_DWORD_17DB70str.x_WORD_17DB8A != -1)
	{
		v7 = (char *)&unk_E17CC[0x194];
		v8 = 0;
		v9 = 0;
		for (k = 0; *((Bit16s*)v7 + 2); k++)
		{
			if (v7[18] == 1)
			{
				v8 = 1;
				v9 = v7;
			}
			if (v7[18] == 2)
				break;
			v7 += 22;
		}
		if (k < 24 && v8)
		{
			LOWORD(k) = *((Bit16s*)v9 + 6);
			v17 = (Bit8u*)k;
			LOWORD(k) = *((Bit16s*)v9 + 7);
			v19 = (Bit8u*)k;
			v17 += xy_DWORD_17DED4_spritestr[37].sizex / 2;
			v19 = xy_DWORD_17DED4_spritestr[37].sizey / 2 + (Bit8u*)k;
			v11 = xy_DWORD_17DED4_spritestr[37].sizex / 2 + *((signed __int16 *)v7 + 6);
			v12 = xy_DWORD_17DED4_spritestr[37].sizey / 2 + *((signed __int16 *)v7 + 7);
			memset(&v14, 0, 24);
			sub_7E8D0((Bit16s*)&v14, v11, v12, (int)v17, (int)v19, 2, 2);
			v1 = 0;
			v18 = v17;
			v23 = v19;
			while (!v1)
			{
				for (l = v1; ; l = v1)
				{
					while (l < 3)
					{
						v1 = sub_7E9D0((x_WORD*)&v17, (x_WORD*)&v19, (x_WORD*)&v14);
						l++;
					}
					if (abs((signed __int16)v19 - (signed __int16)v23) <= 8
						&& abs((signed __int16)v17 - (signed __int16)v18) <= 8)
					{
						break;
					}
					sub_812D0((int)v17, (int)v19);
					v18 = v17;
					v23 = v19;
					if (v1)
						return;
				}
			}
		}
	}
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// E1B82: using guessed type char x_BYTE_E1B82;
// 17DB8A: using guessed type __int16 x_WORD_17DB8A;
// 17DE64: using guessed type int x_DWORD_17DE64_game_world_map;
// 17DED4: using guessed type int (int)x_DWORD_17DED4;
// 180624: using guessed type int x_DWORD_180624_resolution_y;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 18062C: using guessed type int x_DWORD_18062C_resolution_x;
// 180644: using guessed type int x_DWORD_180644_map_resolution2_y;
// 180648: using guessed type int x_DWORD_180648_map_resolution2_x;

//----- (00081CA0) --------------------------------------------------------
unsigned int sub_81CA0(int a1, int a2, __int16 a3, __int16 a4, int a5)//262ca0
{
	unsigned int result; // eax
	unsigned __int8 v6; // dl
	unsigned int v7; // ecx
	int v8; // eax

	result = j___clock();
	v6 = *(x_BYTE *)(a5 + 20);
	v7 = result;
	if (v6 < 1u)
	{
		if (!v6)
		{
			*(x_BYTE *)(a5 + 20) = 2;
			*(x_DWORD *)a5 = result;
			*(x_DWORD *)(a5 + 4) = result;
		}
	}
	else if (v6 <= 1u)
	{
		if ((result - *(x_DWORD *)(a5 + 4)) >> 3 >= 1)
		{
			if (*(signed __int16 *)(a5 + 16) <= *(signed __int16 *)(a5 + 14) - 2)
			{
				++*(x_WORD *)(a5 + 16);
			}
			else
			{
				if (*(x_BYTE *)(a5 + 21) == 1)
				{
					v8 = *(signed __int16 *)(a5 + 22);
					*(x_BYTE *)(a5 + 20) = 0;
				}
				*(x_WORD *)(a5 + 16) = *(x_WORD *)(a5 + 12);
			}
			*(x_DWORD *)(a5 + 4) = v7;
		}
		/*result = */sub_7C120_draw_bitmap_640(
			*(x_WORD *)(a5 + 8) - a3,
			*(x_WORD *)(a5 + 10) - a4,
			xy_DWORD_17DED4_spritestr[*(x_WORD *)(a5 + 16)]);
		if (x_WORD_17DEEE & 1)
			++*(x_WORD *)(a5 + 16);
	}
	else if (v6 == 2)
	{
		result = (result - *(x_DWORD *)a5) / 0x64;
		if (result > *(signed __int16 *)(a5 + 18))
		{
			result = *(signed __int16 *)(a5 + 22);
			*(x_BYTE *)(a5 + 20) = 1;
			if (result != -1)
				result = (unsigned int)sub_8F100_sound_proc19(
					0,
					*(x_WORD *)(a5 + 24),
					(unsigned __int8)x_BYTE_E1324,
					64,
					0x64u,
					*(x_BYTE *)(a5 + 28),
					*(x_BYTE *)(a5 + 26));
		}
	}
	return result;
}
// 98786: using guessed type int /*__fastcall*/ j___clock(x_DWORD, x_DWORD, x_DWORD);
// E1324: using guessed type char x_BYTE_E1324;
// 17DED4: using guessed type int (int)x_DWORD_17DED4;
// 17DEEE: using guessed type __int16 x_WORD_17DEEE;

//----- (00081DB0) --------------------------------------------------------
signed int sub_81DB0_read_config()//262db0
{
	signed int result; // eax
	FILE* configdatfile; // ebx
	//char v2; // [esp+0h] [ebp-70h]
	//int v3; // [esp+50h] [ebp-20h]
	__int16 v4; // [esp+54h] [ebp-1Ch]
	int v5; // [esp+64h] [ebp-Ch]
	char v6; // [esp+6Eh] [ebp-2h]

	result = 0;
	if (x_D41A0_BYTEARRAY_4_struct.setting_38402 == 1)
	{
		memset(printbuffer, 0, 80);
		sprintf_s(printbuffer, 512, "%c%s", x_D41A0_BYTEARRAY_4_struct.harddisk_number, ":/NETHERW/CONFIG.DAT");
		memset(readbuffer, 0, 32);
		configdatfile = sub_98817_open(printbuffer, 546);
		if (configdatfile != NULL)
		{
			qmemcpy(readbuffer, (void *)x_D41A0_BYTEARRAY_4, 0x14u);
			qmemcpy(&v5, (void *)x_D41A0_BYTEARRAY_4[20], 2u);
			qmemcpy((char *)&v5 + 2, &x_BYTE_EB39E_keys, 8u);
			qmemcpy(&v6, &x_BYTE_EB39E_keys + 8, 2u);
			readbuffer[0] = 0xf7;
			v4 = x_D41A0_BYTEARRAY_4_struct.byteindex_179;
			sub_98CAA_write(configdatfile, readbuffer, 32);
			sub_98882_close(configdatfile);
		}
		result = 1;
		x_D41A0_BYTEARRAY_4_struct.dwordindex_0 = 0;
	}
	return result;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// D41A4: using guessed type int x_DWORD_D41A4;
// EB39E: using guessed type char x_BYTE_EB39E_keys;

//----- (00081EE0) --------------------------------------------------------
void sub_81EE0_draw_and_sound_dragon_and_fire(int a1, int a2, int a3, signed __int16 a4, __int16 a5, __int16 a6)//262ee0
{
	int v6; // eax
	Bit16s* v7; // ebx
	int v8; // esi
	signed __int16 result; // ax
	unsigned __int8 v10; // al
	unsigned __int8 v11; // cl
	char v12; // ah
	__int16 v13; // ax
	unsigned __int8 v14; // ST18_1
	int v15; // ST08_4
	__int16 v16; // ST04_2
	int v17; // ST18_4
	int v18; // ST14_4
	unsigned __int8 v19; // ST18_1
	int v20; // ST08_4
	char v21; // dh
	__int16 v22; // ST04_2
	int v23x; // edx
	//int v24; // eax
	x_WORD *v25; // edx
	signed __int16 v26; // ax
	char v27; // al
	__int16 v28; // ax
	int v29; // ST18_4
	int v30; // ST14_4
	unsigned __int8 v31; // ST18_1
	int v32; // ST08_4
	char v33; // dl
	__int16 v34; // ST04_2
	x_WORD *v35; // edx
	__int16 v36; // ax
	unsigned __int8 v37; // al
	char v38; // ch
	int v39; // ST18_4
	int v40; // ST14_4
	__int16 v41; // ST2C_2
	__int16 v42; // ST30_2
	int v43; // ST1C_4
	int v44; // edx
	__int16 v45; // ST14_2
	__int16 v46; // ST10_2
	__int16 k; // [esp+8h] [ebp-14h]
	__int16 i; // [esp+Ch] [ebp-10h]
	__int16 j; // [esp+18h] [ebp-4h]

	v6 = j___clock();
	v7 = x_WORD_E20A4;
	v8 = v6;
	for (result = x_WORD_E20A4[11]; result; result = v7[11])
	{
		v10 = *((x_BYTE *)v7 + 42);
		if (v10 == 1)
		{
			v11 = *((x_BYTE *)v7 + 43);
			switch (v11)
			{
			case 0u:
				v12 = *((x_BYTE *)v7 + 43);
				*(x_DWORD *)v7 = v8;
				*((x_BYTE *)v7 + 43) = v12 + 1;
				break;
			case 1u:
				if ((v8 - *(x_DWORD *)v7) / 0x64u > v7[20])
					*((x_BYTE *)v7 + 43) = v11 + 1;
				break;
			case 2u:
				v7[9] = v7[11];
				v13 = v7[12];
				v7[10] = v13;
				sub_7E8D0((signed __int16 *)((char *)v7 + 45), v7[13], v7[14], v7[11], v13, 2, 2);
				v7[17] = v7[15];
				v14 = *((x_BYTE *)v7 + 12);
				v15 = (unsigned __int8)x_BYTE_E1324;
				v16 = v7[5];
				++*((x_BYTE *)v7 + 43);
				sub_8F100_sound_proc19(0, v16, v15, 64, 0x64u, 0, v14);
				break;
			case 3u:
				for (i = 0; i < 4; i++)
				{
					v17 = v7[14];
					v18 = v7[13];
					a4 = sub_7E9D0(v7 + 9, v7 + 10, (signed __int16 *)((char *)v7 + 45));
				}
				if ((unsigned int)(v8 - *(x_DWORD *)v7) >> 3 >= 1)
				{
					if (v7[17] <= v7[16] - 1)
						++v7[17];
					else
						v7[17] = v7[15];
					*(x_DWORD *)v7 = v8;
				}
				sub_7C120_draw_bitmap_640(v7[9] - a5, v7[10] - a6, xy_DWORD_17DED4_spritestr[v7[17]]);
				if (a4)
				{
					v7[17] = v7[18];
					v19 = *((x_BYTE *)v7 + 16);
					v20 = (unsigned __int8)x_BYTE_E1324;
					v21 = *((x_BYTE *)v7 + 43);
					v22 = v7[7];
					*(x_DWORD *)v7 = v8;
					*((x_BYTE *)v7 + 43) = v21 + 1;
					sub_8F100_sound_proc19(0, v22, v20, 64, 0x64u, 0, v19);
				}
				break;
			case 4u:
				a4 = 0;
				if ((unsigned int)(v8 - *(x_DWORD *)v7) >> 3 >= 1)
				{
					if (v7[17] <= v7[19] - 1)
					{
						++v7[17];
					}
					else
					{
						a4 = 1;
						v7[17] = v7[18];
					}
					*(x_DWORD *)v7 = v8;
				}
				if (!a4)
				{
					//v23 = (int)x_DWORD_17DED4;
					v23x = v7[17];
					goto LABEL_85;
				}
				*((x_BYTE *)v7 + 43) = 0;
				break;
			}
		}
		else if (v10 == 2u)
		{
			if (x_DWORD_17DB70str.x_BYTE_17DB8F != 4)
			{
				v25 = (x_WORD*)&unk_E17CC[0x194];
				v26 = 0;
				while (v25[2] && *((x_BYTE *)v25 + 18) != 2)
				{
					v25 += 11;
					++v26;
				}
				if (v26 == 25)
					v26 = 24;
				if (v26 == *((unsigned __int8 *)v7 + 44))
				{
					switch (*((x_BYTE *)v7 + 43))
					{
					case 0:
						v27 = *((x_BYTE *)v7 + 43);
						*(x_DWORD *)v7 = v8;
						*((x_BYTE *)v7 + 43) = v27 + 1;
						break;
					case 1:
						goto LABEL_42;
					case 2:
						for (j = 0; j < 4; j++)
						{
							v29 = v7[14];
							v30 = v7[13];
							a4 = sub_7E9D0(v7 + 9, v7 + 10, (signed __int16 *)((char *)v7 + 45));
						}
						if ((unsigned int)(v8 - *(x_DWORD *)v7) >> 3 >= 1)
						{
							if (v7[17] <= v7[16] - 1)
								++v7[17];
							else
								v7[17] = v7[15];
							*(x_DWORD *)v7 = v8;
						}
						sub_7C120_draw_bitmap_640(v7[9] - a5, v7[10] - a6, xy_DWORD_17DED4_spritestr[v7[17]]);
						if (a4)
						{
							v7[17] = v7[18];
							v31 = *((x_BYTE *)v7 + 16);
							v32 = (unsigned __int8)x_BYTE_E1324;
							v33 = *((x_BYTE *)v7 + 43);
							v34 = v7[7];
							*(x_DWORD *)v7 = v8;
							*((x_BYTE *)v7 + 43) = v33 + 1;
							sub_8F100_sound_proc19(0, v34, v32, 64, 0x64u, 0, v31);
						}
						break;
					case 3:
						a4 = 0;
						if ((unsigned int)(v8 - *(x_DWORD *)v7) >> 3 >= 1)
						{
							if (v7[17] <= v7[19] - 1)
							{
								++v7[17];
							}
							else
							{
								a4 = 1;
								v7[17] = v7[18];
							}
							*(x_DWORD *)v7 = v8;
						}
						if (!a4)
							goto LABEL_84;
						++*((x_BYTE *)v7 + 43);
						break;
					default:
						break;
					}
				}
				else
				{
					*((x_BYTE *)v7 + 43) = 0;
				}
			}
		}
		else if (v10 == 3)
		{
			v35 = (x_WORD*)&unk_E17CC[0x194];
			v36 = 0;
			while (v35[2] && *((x_BYTE *)v35 + 18) != 2)
			{
				v35 += 11;
				++v36;
			}
			if (v36)
				--v36;
			if (v36 == *((unsigned __int8 *)v7 + 44))
			{
				v37 = *((x_BYTE *)v7 + 43);
				if (v37 < 1u)
				{
					if (!v37)
					{
						v38 = *((x_BYTE *)v7 + 43);
						*(x_DWORD *)v7 = v8;
						*((x_BYTE *)v7 + 43) = v38 + 1;
					}
				}
				else if (v37 <= 1u)
				{
				LABEL_42:
					v7[9] = v7[11];
					v28 = v7[12];
					v7[10] = v28;
					sub_7E8D0((signed __int16 *)((char *)v7 + 45), v7[13], v7[14], v7[11], v28, 2, 2);
					v7[17] = v7[15];
					++*((x_BYTE *)v7 + 43);
					sub_8F100_sound_proc19(0, v7[5], (unsigned __int8)x_BYTE_E1324, 64, 0x64u, 0, *((x_BYTE *)v7 + 12));
				}
				else if (v37 == 2)
				{
					for (k = 0; k < 4; k++)
					{
						v39 = v7[14];
						v40 = v7[13];
						a4 = sub_7E9D0(v7 + 9, v7 + 10, (signed __int16 *)((char *)v7 + 45));
					}
					if ((unsigned int)(v8 - *(x_DWORD *)v7) >> 3 >= 1)
					{
						if (v7[17] <= v7[16] - 1)
							++v7[17];
						else
							v7[17] = v7[15];
						*(x_DWORD *)v7 = v8;
					}
					if (x_BYTE_E1B82 == 1)
					{
						_disable();
						v41 = x_DWORD_18062C_resolution_x;
						v42 = x_DWORD_180624_resolution_y;
						v43 = (int)x_DWORD_180628b_screen_buffer;
						x_DWORD_180628b_screen_buffer = x_DWORD_17DE64_game_world_map;
						v44 = v7[17];
						x_DWORD_180648_map_resolution2_x = 1280;
						x_DWORD_18062C_resolution_x = 1280;
						v45 = v7[10];
						v46 = v7[9];
						x_DWORD_180644_map_resolution2_y = 960;
						x_DWORD_180624_resolution_y = 960;
						sub_7C120_draw_bitmap_640(v46, v45, xy_DWORD_17DED4_spritestr[v44]);
						x_DWORD_18062C_resolution_x = v41;
						x_DWORD_180624_resolution_y = v42;
						x_DWORD_180648_map_resolution2_x = v41;
						x_DWORD_180644_map_resolution2_y = v42;
						x_DWORD_180628b_screen_buffer = (Bit8u*)v43;
						_enable();
					}
					else
					{
					LABEL_84:
						v23x = v7[17];
						//v24 = (int)x_DWORD_17DED4;
					LABEL_85:
						sub_7C120_draw_bitmap_640(v7[9] - a5, v7[10] - a6, xy_DWORD_17DED4_spritestr[v23x]);
					}
				}
			}
			else
			{
				*((x_BYTE *)v7 + 43) = 0;
			}
		}
		v7 = (signed __int16 *)((char *)v7 + 69);
	}
	//return result;
}
// 98786: using guessed type int /*__fastcall*/ j___clock(x_DWORD, x_DWORD, x_DWORD);
// E1324: using guessed type char x_BYTE_E1324;
// E1B82: using guessed type char x_BYTE_E1B82;
// 17DB8F: using guessed type char x_BYTE_17DB8F;
// 17DE64: using guessed type int x_DWORD_17DE64_game_world_map;
// 17DED4: using guessed type int (int)x_DWORD_17DED4;
// 180624: using guessed type int x_DWORD_180624_resolution_y;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 18062C: using guessed type int x_DWORD_18062C_resolution_x;
// 180644: using guessed type int x_DWORD_180644_map_resolution2_y;
// 180648: using guessed type int x_DWORD_180648_map_resolution2_x;

//----- (000824B0) --------------------------------------------------------
x_WORD *sub_824B0(__int16 a1)//2634b0
{
	x_WORD *result; // eax

	result = x_WORD_E2970;
	if (!x_WORD_E2970[6])
		return 0;
	while (a1 != result[2])
	{
		result = (x_WORD *)((char *)result + 17);
		if (!result[6])
			return 0;
	}
	return result;
}

//----- (000824E0) --------------------------------------------------------
x_WORD *sub_824E0(__int16 a1)//2634e0
{
	x_WORD *result; // eax

	result = x_WORD_E2970;
	if (!x_WORD_E2970[6])
		return 0;
	while (a1 != result[3])
	{
		result = (x_WORD *)((char *)result + 17);
		if (!result[6])
			return 0;
	}
	return result;
}

//----- (00082510) --------------------------------------------------------
void sub_82510(/*__int16 a1*//*, int *a2*/)//263510
{
	int v2; // eax
	int v3; // edx
	__int16 v4; // dx
	char *v5; // esi
	Bit8u* v6; // edx
	int v7; // eax
	int v8; // ecx
	int result; // eax
	char v10[36]; // [esp+0h] [ebp-2Ch]
	//char v11[2]; // [esp+10h] [ebp-1Ch]
	Bit8u* v12; // [esp+24h] [ebp-8h]
	Bit8u* v13; // [esp+28h] [ebp-4h]
	posistruct* v13s;

	Bit8u switchbit = 0;

	v13 = x_DWORD_17DEC0;
	v12 = x_DWORD_17DEC4;
	x_DWORD_17DEC0 = x_DWORD_17DEC8;
	x_DWORD_17DEC4 = x_DWORD_17DECC;

	v13s = xy_DWORD_17DEC0_spritestr;//fixed
	xy_DWORD_17DEC0_spritestr = xy_DWORD_17DEC8_spritestr;//fixed

	if (x_D41A0_BYTEARRAY_4_struct.byteindex_A == 1)
	{
		switchbit = unk_17DBA8str.x_BYTE_17DBB6;//*((x_BYTE *)a2 + 14);
		if (switchbit == 2)
		{
			v2 = j___clock();
			v3 = unk_17DBA8str.unk_17DBA8;
			unk_17DBA8str.unk_17DBAC = v2;
			if ((v2 - v3) / 0x64u > 1)
			{
				v4 = unk_17DBA8str.unk_17DBB4 + 1;
				unk_17DBA8str.unk_17DBB4 = v4;
				if (!unk_E2516[9 * v4 + 1])
					unk_17DBA8str.unk_17DBB4 = 0;
				unk_17DBA8str.unk_17DBA8 = unk_17DBA8str.unk_17DBAC;//a2[0] = a2[1];
			}
			memset(&v10, 0, 36);//3550c0
			v5 = (char *)&unk_E2516[9 * unk_17DBA8str.unk_17DBB4];
			v6 = off_E23E0;
			qmemcpy(&v10, v5, 0x12u);
			//qmemcpy(&v11, v5 + 0x10u, 2u);
			while (v6[25])
			{
				if (v6[23] && v6[22] == (int)(unk_E2516[8 + 9 * unk_17DBA8str.unk_17DBB4] >> 8))// x_BYTE_E2527[18 * *((signed __int16 *)a2 + 6)] )
				{
					v6[24] = 1;
					break;
				}
				v6 += 44;
			}
			sub_7E840_draw_textbox_with_line((Bit16u*)&v10, 238, 264);//draw help
		}
		else if (switchbit == 3)
		{
			v7 = j___clock();
			v8 = unk_17DBA8str.unk_17DBA8;
			unk_17DBA8str.unk_17DBAC = v7;
			if ((v7 - v8) / 0x64u > 1)
				unk_17DBA8str.x_BYTE_17DBB5 = 2;
		}
	}
	x_DWORD_17DEC0 = v13;
	x_DWORD_17DEC4 = v12;

	xy_DWORD_17DEC0_spritestr= v13s;//fixed
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 98786: using guessed type int /*__fastcall*/ j___clock(x_DWORD, x_DWORD, x_DWORD);
// D41A4: using guessed type int x_DWORD_D41A4;
// E2518: using guessed type __int16 x_WORD_E2518[];
// 17DEC0: using guessed type int (int)x_DWORD_17DEC0;
// 17DEC4: using guessed type int (int)x_DWORD_17DEC4;
// 17DEC8: using guessed type int x_DWORD_17DEC8;
// 17DECC: using guessed type int x_DWORD_17DECC;

//----- (00082670) --------------------------------------------------------
__int16 sub_82670()//263670
{
	__int16 v0; // si
	x_WORD *v1; // eax
	Bit8u* v2; // eax
	void **v3; // ebx
	__int16 v4; // cx
	x_WORD *v5; // edi
	int v6; // eax
	int v7; // eax
	int v8; // eax
	//char v10; // [esp+0h] [ebp-54h]
	unsigned __int8 v11; // [esp+50h] [ebp-4h]

	//fix it
	v7 = 0;
	//fix it

	v0 = 0;
	v11 = x_WORD_180660_VGA_type_resolution;
	LOWORD(v1) = (unsigned __int8)x_WORD_180660_VGA_type_resolution;
	x_BYTE_1806E4 = 0;
	if (!x_BYTE_E29E1)
	{
		LOWORD(v1) = (uint16)x_D41A0_BYTEARRAY_4;
		if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte1_22 & 0x10))
		{
			v2 = x_D41A0_BYTEARRAY_4_0xE2_heapbuffer;
			x_BYTE_D41C1 = 0;
			x_DWORD_17DE48c = v2;
			x_DWORD_17DE54 = (Bit8u*)v2 + 301787;
			x_DWORD_17DEC0 = (Bit8u*)v2 + 308527;
			x_DWORD_17DEC4 = (Bit8u*)&algn_4BB85[*v2 + 10];//fix ti
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", (Bit8u*)(v2 + 301787), (int)&unk_164FCD, 860);
			sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", (Bit8u*)(int)x_DWORD_17DEC0, (int)&unk_165329, 548);
			sub_7AA70_load_and_decompres_dat_file(0, 0, 0, 0);
			if (*(x_BYTE *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11232) & 2
				|| (LOWORD(v1) = (uint16)x_D41A0_BYTEARRAY_4, x_D41A0_BYTEARRAY_4_struct.levelnumber_43 > 0x18u))
			{
				v3 = &off_E16E0;
				LOWORD(v1) = 1;
				while (*((x_BYTE *)v3 + 4))
				{
					if (x_D41A0_BYTEARRAY_4_struct.levelnumber_43 + 1 == *((unsigned __int8 *)v3 + 4))
					{
						if (!*((x_BYTE *)v3 + 5))
						{
							v0 = (signed __int16)v1;
							*((x_BYTE *)v3 + 5) = 1;
						}
						break;
					}
					v3 = (void **)((char *)v3 + 7);
					LOWORD(v1) = (x_WORD)v1 + 1;
				}
				if (!v0)
				{
					LOWORD(v1) = (uint16)x_D41A0_BYTEARRAY_4;
					v4 = x_D41A0_BYTEARRAY_4_struct.levelnumber_43;
					if ((unsigned __int16)v4 > 0x18u)
					{
						v1 = sub_824E0(v4);
						v5 = v1;
						if (v1)
						{
							v3 = &off_E16E0;
							LOWORD(v1) = 1;
							while (*((x_BYTE *)v3 + 4))
							{
								if ((signed __int16)v5[2] + 1 == *((unsigned __int8 *)v3 + 4))
								{
									if (!*((x_BYTE *)v3 + 5))
									{
										v0 = (signed __int16)v1;
										*((x_BYTE *)v3 + 5) = 1;
									}
									break;
								}
								v3 = (void **)((char *)v3 + 7);
								LOWORD(v1) = (x_WORD)v1 + 1;
							}
						}
					}
				}
				if (v0)
				{
					if (x_D41A0_BYTEARRAY_4_struct.byteindex_179 == 2 && x_BYTE_E3798_sound_active2 || v0 >= 6)
					{
						x_BYTE_D41C1 = 0;
						x_BYTE_D41C0 = 0;
					}
					else
					{
						sub_2EB40();
						x_BYTE_D41C1 = 1;
						x_BYTE_D41C0 = 1;
					}
					sub_8CD27_set_cursor(*filearray_2aa18c[0].posistruct);
					memset((void*)x_DWORD_180628b_screen_buffer, 0, 307200);
					if (x_WORD_180660_VGA_type_resolution != 1)
					{
						sub_54600_mouse_reset();
						v6 = (int)memset((void*)*xadatapald0dat2.var28_begin_buffer, 0, 768);
						if (x_WORD_180660_VGA_type_resolution & 1)
							sub_72883_clear_text_mode(/*(int)x_DWORD_180628b_screen_buffer, */(void *)x_DWORD_180628b_screen_buffer, 0xC8u, 0);
						else
							sub_728A9_clear_graphics_mode((void *)x_DWORD_180628b_screen_buffer, 0x1E0u, 0);
						sub_41A90_VGA_pallette_install(*xadatapald0dat2.var28_begin_buffer);
						x_WORD_180660_VGA_type_resolution = 1;
						sub_90D6E_VGA_set_video_mode_320x200_and_pallette(*xadatapald0dat2.var28_begin_buffer);
						sub_8CEDF_install_mouse();
						sub_8CD27_set_cursor(*filearray_2aa18c[0].posistruct);
					}
					if (x_WORD_180660_VGA_type_resolution & 1)
						sub_98709_create_index_dattab_power((Bit8u*)(int)x_DWORD_17DEC0, (Bit8u*)(int)x_DWORD_17DEC4, (Bit8u*)(int)x_DWORD_17DE54, (new posistruct));
					else
						sub_9874D_create_index_dattab((Bit8u*)(int)x_DWORD_17DEC0, (Bit8u*)(int)x_DWORD_17DEC4, (Bit8u*)(int)x_DWORD_17DE54, (new posistruct));
					sprintf_s(printbuffer2, 512, "intro\\cut%d.dat", *((unsigned __int8 *)v3 + 6));
					sprintf_s(printbuffer, 512, printbuffer2);
					sub_76160_play_intro(0, 1, (Bit8u*)*v3);
					sub_90B27_VGA_pal_fadein_fadeout(0, 0x10u, 0);
					sub_8D8F0_sound_proc3_endsample();
					sub_8E020_sound_proc14_stopsequence();
					sub_7B5D0();
					if (x_WORD_180660_VGA_type_resolution & 1)
						sub_72883_clear_text_mode(/*v7, */(void *)x_DWORD_180628b_screen_buffer, 0xC8u, 0);
					else
						sub_728A9_clear_graphics_mode((void *)x_DWORD_180628b_screen_buffer, 0x1E0u, 0);
					if (x_WORD_180660_VGA_type_resolution & 1)
						sub_90478_VGA_Blit320();
					else
						sub_75200_VGA_Blit640(480);
					LOWORD(v1) = v11;
					if (v11 != x_WORD_180660_VGA_type_resolution)
					{
						sub_54600_mouse_reset();
						v8 = (int)memset((void*)*xadatapald0dat2.var28_begin_buffer, 0, 768);
						if (x_WORD_180660_VGA_type_resolution & 1)
							sub_72883_clear_text_mode(/*v8, */(void *)x_DWORD_180628b_screen_buffer, 0xC8u, 0);
						else
							sub_728A9_clear_graphics_mode((void *)x_DWORD_180628b_screen_buffer, 0x1E0u, 0);
						sub_41A90_VGA_pallette_install(*xadatapald0dat2.var28_begin_buffer);
						x_WORD_180660_VGA_type_resolution = v11;
						if (v11 & 1)
							sub_90D6E_VGA_set_video_mode_320x200_and_pallette(*xadatapald0dat2.var28_begin_buffer);
						else
							sub_90E07_VGA_set_video_mode_640x480_and_pallette(*xadatapald0dat2.var28_begin_buffer);
						sub_8CEDF_install_mouse();
						// fix it//LOWORD(v1) = sub_8CD27_set_cursor((Bit8u**)*filearray_2aa18c[0]);
						sub_8CD27_set_cursor(*filearray_2aa18c[0].posistruct);
					}
				}
			}
		}
	}
	x_BYTE_D41C1 = 0;
	return (signed __int16)v1;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// D41C0: using guessed type char x_BYTE_D41C0;
// D41C1: using guessed type char x_BYTE_D41C1;
// E16E0: using guessed type void *off_E16E0;
// E29E1: using guessed type char x_BYTE_E29E1;
// E3798: using guessed type char x_BYTE_E3798_sound_active2;
// EA3D8: using guessed type int *xadatapald0dat2.var28_begin_buffer;
// EB394: using guessed type int **filearray_2aa18c[0];
// 17DE48: using guessed type int x_DWORD_17DE48;
// 17DE54: using guessed type int (int)x_DWORD_17DE54;
// 17DEC0: using guessed type int (int)x_DWORD_17DEC0;
// 17DEC4: using guessed type int (int)x_DWORD_17DEC4;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;
// 1806E4: using guessed type char x_BYTE_1806E4;

//----- (00082AB0) --------------------------------------------------------
int sub_82AB0(unsigned __int8 a1)
{
	int v1; // eax
	int v2; // edx
	int result; // eax
	x_WORD *v4; // ebx
	__int16 i; // cx
	int v6; // eax
	int v7; // edx

	if (a1 > 0x18u)
	{
		v4 = x_WORD_E2970;
		for (i = 0; v4[6]; i++)
		{
			result = a1;
			if (a1 == v4[3])
			{
				v6 = (int)x_D41A0_BYTEARRAY_0;
				v7 = 5 * i;
				x_DWORD_17DDBC[v7] = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 12605);
				x_DWORD_17DDC0[v7] = *(x_DWORD *)(2124 * *(signed __int16 *)(v6 + 12) + v6 + 12609);
				x_DWORD_17DDC4[v7] = *(x_DWORD *)(2124 * *(signed __int16 *)(v6 + 12) + v6 + 12601);
				x_DWORD_17DDC8[v7] = *(x_DWORD *)(2124 * *(signed __int16 *)(v6 + 12) + v6 + 12613);
				result = *(x_DWORD *)(2124 * *(signed __int16 *)(v6 + 12) + v6 + 12621);
				x_DWORD_17DDCC[v7] = result;
			}
			v4 = (x_WORD *)((char *)v4 + 17);
		}
	}
	else
	{
		v1 = (int)x_D41A0_BYTEARRAY_0;
		v2 = 5 * a1;
		x_DWORD_17DBC8[v2] = *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 12605);
		x_DWORD_17DBCC[v2] = *(x_DWORD *)(2124 * *(signed __int16 *)(v1 + 12) + v1 + 12609);
		x_DWORD_17DBD0[v2] = *(x_DWORD *)(2124 * *(signed __int16 *)(v1 + 12) + v1 + 12601);
		x_DWORD_17DBD4[v2] = *(x_DWORD *)(2124 * *(signed __int16 *)(v1 + 12) + v1 + 12613);
		result = *(x_DWORD *)(2124 * *(signed __int16 *)(v1 + 12) + v1 + 12621);
		x_DWORD_17DBD8[v2] = result;
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// 17DBC8: using guessed type int x_DWORD_17DBC8[];
// 17DBCC: using guessed type int x_DWORD_17DBCC[];
// 17DBD0: using guessed type int x_DWORD_17DBD0[];
// 17DBD4: using guessed type int x_DWORD_17DBD4[];
// 17DDBC: using guessed type int x_DWORD_17DDBC[];
// 17DDC0: using guessed type int x_DWORD_17DDC0[];
// 17DDC4: using guessed type int x_DWORD_17DDC4[];
// 17DDC8: using guessed type int x_DWORD_17DDC8[];

//----- (00082C20) --------------------------------------------------------
void sub_82C20(__int16 a1)
{
	x_WORD *v1; // edx
	__int16 v2; // si
	int v3; // ebx
	signed __int16 v4; // bx
	__int16 v5; // si
	int v6; // edx
	signed __int16 v7; // bx
	unsigned int v8; // esi
	int v9; // edx
	int v10; // eax
	int v11; // esi
	int v12; // edi
	signed __int16 i; // bx
	int v14; // eax
	x_BYTE *v15; // ebx
	__int16 v16; // ax
	unsigned __int16 v17; // dx
	signed __int16 j; // bx
	int v19; // eax
	__int16 v20; // di
	signed int v21; // ebx
	int v22; // edx
	//char v23; // [esp+0h] [ebp-12h]
	char *v24; // [esp+28h] [ebp+16h]
	Bit8u* v25; // [esp+2Ch] [ebp+1Ah]
	Bit8u* v26; // [esp+30h] [ebp+1Eh]
	Bit8u* v27; // [esp+34h] [ebp+22h]
	Bit8u* v28; // [esp+38h] [ebp+26h]
	Bit8u* v29; // [esp+3Ch] [ebp+2Ah]
	int v30; // [esp+40h] [ebp+2Eh]
	int v31; // [esp+44h] [ebp+32h]
	int v32; // [esp+48h] [ebp+36h]
	int v33; // [esp+4Ch] [ebp+3Ah]
	int v34; // [esp+50h] [ebp+3Eh]
	int v35; // [esp+54h] [ebp+42h]
	int v36; // [esp+58h] [ebp+46h]
	int v37; // [esp+5Ch] [ebp+4Ah]
	int v38; // [esp+60h] [ebp+4Eh]
	int v39; // [esp+64h] [ebp+52h]
	int v40; // [esp+68h] [ebp+56h]
	int v41; // [esp+6Ch] [ebp+5Ah]
	int v42; // [esp+70h] [ebp+5Eh]
	int v43; // [esp+74h] [ebp+62h]
	int v44; // [esp+78h] [ebp+66h]
	int v45; // [esp+7Ch] [ebp+6Ah]
	int v46; // [esp+80h] [ebp+6Eh]
	int v47; // [esp+84h] [ebp+72h]
	int v48; // [esp+88h] [ebp+76h]
	int v49; // [esp+8Ch] [ebp+7Ah]

	v42 = 50;
	v48 = 50;
	if (a1 > -1)
	{
		v24 = (char*)off_D9204_wizards_names1[a1];
		v25 = x_DWORD_E9C4C_langindexbuffer[386];
		v26 = x_DWORD_E9C4C_langindexbuffer[385];
		v30 = 0;
		v27 = x_DWORD_E9C4C_langindexbuffer[384];
		v31 = 0;
		v28 = x_DWORD_E9C4C_langindexbuffer[377];
		v37 = 0;
		v29 = x_DWORD_E9C4C_langindexbuffer[394];
		if (a1 > 24)
		{
			v1 = x_WORD_E2970;
			v2 = 0;
			while (v1[6])
			{
				if (a1 == v1[3])
				{
					v3 = 5 * v2;
					v32 = x_DWORD_17DDBC[v3];
					v33 = x_DWORD_17DDC0[v3];
					v34 = x_DWORD_17DDC4[v3];
					v35 = x_DWORD_17DDC8[v3];
					v36 = x_DWORD_17DDCC[v3];
				}
				v1 = (x_WORD *)((char *)v1 + 17);
				++v2;
			}
		}
		else
		{
			v32 = x_DWORD_17DBC8[5 * a1];
			v33 = x_DWORD_17DBCC[5 * a1];
			v34 = x_DWORD_17DBD0[5 * a1];
			v35 = x_DWORD_17DBD4[5 * a1];
			v36 = x_DWORD_17DBD8[5 * a1];
		}
		v4 = 1;
		v5 = strlen(v24);
		while (v4 < 6)
		{
			v6 = v4;
			if (strlen((&v24)[v6]) > v5)
				v5 = strlen((&v24)[v6]);
			++v4;
		}
		v7 = 1;
		v8 = strlen(v24);
		while (v7 < 6)
		{
			v9 = v7;
			if (strlen((&v24)[v9]) > (signed __int16)v8)
				v8 = strlen((&v24)[v9]);
			++v7;
		}
		//HIWORD(v10) = HIWORD(x_DWORD_17DEC0);
		LOWORD(v10) = xy_DWORD_17DEC0_spritestr[65].sizex;
		v11 = 2 * v10 * v8;
		v12 = 320 - (signed __int16)v11 / 2;
		v44 = xy_DWORD_17DED4_spritestr[275].sizex;
		v40 = (unsigned __int8)v44;
		if ((signed __int16)v11 % (signed int)(unsigned __int8)v44)
			v11 = ((signed __int16)v11 / (signed int)(unsigned __int8)v44 + 1) * v44;
		for (i = 0; i < (signed __int16)v11; i += v44)
			sub_7C120_draw_bitmap_640(i + v12, v48, xy_DWORD_17DED4_spritestr[275]);
		//HIWORD(v14) = HIWORD(x_DWORD_17DED4);
		LOWORD(v14) = xy_DWORD_17DED4_spritestr[275].sizey;
		v49 = 0;
		v48 += v14;
		do
		{
			v41 = (signed __int16)v12 + xy_DWORD_17DED4_spritestr[274].sizex;
			v39 = (signed __int16)v48;
			v40 = (signed __int16)v48;
			v15 = (x_BYTE *)(v41 + 640 * (signed __int16)v48 + x_DWORD_180628b_screen_buffer);
			sub_7C120_draw_bitmap_640(v12, v48, xy_DWORD_17DED4_spritestr[274]);
			sub_7C120_draw_bitmap_640(v11 + v12 - xy_DWORD_17DED4_spritestr[274].sizex, v40, xy_DWORD_17DED4_spritestr[274]);
			v45 = 0;
			while (xy_DWORD_17DED4_spritestr[274].sizey > (signed __int16)v45)
			{
				v16 = 0;
				while (v16 < (signed __int16)v11 - 2 * xy_DWORD_17DED4_spritestr[274].sizex)
				{
					HIBYTE(v17) = 15;
					LOBYTE(v17) = *v15;
					v41 = v17;
					++v15;
					++v16;
					*(v15 - 1) = *(x_BYTE *)(v17 + x_DWORD_17DE3C);
				}
				++v45;
				v15 += 640 - v16;
				++v48;
			}
			++v49;
		} while ((signed __int16)v49 < 12);
		for (j = 0; j < (signed __int16)v11; j += v44)
			sub_7C120_draw_bitmap_640(j + v12, v48, xy_DWORD_17DED4_spritestr[275]);
		//HIWORD(v19) = HIWORD(x_DWORD_17DED4);//fix it
		LOWORD(v19) = xy_DWORD_17DED4_spritestr[274].sizex;
		v47 = 2 * v19 + v42;
		LOWORD(v19) = xy_DWORD_17DED4_spritestr[65].sizex;
		v20 = v19 + v12;
		sub_7FAE0_draw_text(v24, v20, v11 - (unsigned __int8)v19 + v20, v47, 0);
		v21 = 1;
		v47 += 5;
		while (1)
		{
			v46 = v47 + 2;
			if ((signed __int16)v21 >= 5)
			{
				sub_7FB90_draw_text(
					(char*)v29,
					(signed __int16)(v20 + 2 * xy_DWORD_17DEC0_spritestr[65].sizex),
					//v46 + 5 * *(unsigned __int8 *)((int)x_DWORD_17DEC0 + 395) + *(unsigned __int8 *)((int)x_DWORD_17DEC0 + 395),
					v46 + 6 * xy_DWORD_17DEC0_spritestr[v46].sizey,
					0);
				v39 = 60;
				v41 = v36 % 3600 / 60;
				v38 = v36 % 3600 / 60;
				sprintf_s(printbuffer, 512, "%02d:%02d:%02d", v36 / 3600, v41, v36 % 3600 % 60);
				sub_7FB90_draw_text(
					printbuffer,
					(signed __int16)(v20 + v11 - 14 * xy_DWORD_17DEC0_spritestr[65].sizex),
					//v46 + 5 * *(unsigned __int8 *)((int)x_DWORD_17DEC0 + 395) + *(unsigned __int8 *)((int)x_DWORD_17DEC0 + 395),
					v46 + 6 * xy_DWORD_17DEC0_spritestr[v46].sizey,
					0);
				return;
			}
			v22 = (signed __int16)v21;
			if ((&v24)[v22])
				break;
		LABEL_47:
			++v21;
		}
		if (x_D41A0_BYTEARRAY_4_struct.byteindex_179 != 2)
		{
			v43 = v21 * xy_DWORD_17DEC0_spritestr[65].sizey;
			sub_7FB90_draw_text((&v24)[v22], (signed __int16)(v20 + 2 * xy_DWORD_17DEC0_spritestr[65].sizex), v43 + v46, 0);
			exit(-1);
		}
		if ((unsigned __int16)v21 < 2u)
			goto LABEL_44;
		if ((unsigned __int16)v21 <= 2u)
		{
			sub_7FB90_draw_text(
				(char*)"Hit Accuracy",
				(signed __int16)(v20 + 2 * xy_DWORD_17DEC0_spritestr[65].sizex),
				v46 + v21 * xy_DWORD_17DEC0_spritestr[65].sizey,
				0);
		}
		else
		{
			if ((x_WORD)v21 != 4)
			{
			LABEL_44:
				sub_7FB90_draw_text(
					(&v24)[(signed __int16)v21],
					(signed __int16)(v20 + 2 * xy_DWORD_17DEC0_spritestr[65].sizex),
					xy_DWORD_17DEC0_spritestr[65].sizey * (x_WORD)v21 + v47 + 2,
					0);
				exit(-1);
			}
			sub_7FB90_draw_text(
				(char*)"Mana Collected",
				(signed __int16)(v20 + 2 * xy_DWORD_17DEC0_spritestr[65].sizex),
				v46 + 4 * xy_DWORD_17DEC0_spritestr[65].sizey,
				0);
		}
	LABEL_46:
		sprintf_s(printbuffer, 512, "%3d%%", *(&v31 + (signed __int16)v21));
		sub_7FB90_draw_text(
			printbuffer,
			(signed __int16)(v20 + v11 - 8 * xy_DWORD_17DEC0_spritestr[65].sizex),
			v47 + 2 + v21 * xy_DWORD_17DEC0_spritestr[65].sizey,
			0);
		goto LABEL_47;
	}
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// D41A4: using guessed type int x_DWORD_D41A4;
// D9204: using guessed type const char *off_D9204_wizards_names1[2];
// EA230: using guessed type int x_DWORD_EA230;
// EA24C: using guessed type int x_DWORD_EA24C;
// EA250: using guessed type int x_DWORD_EA250;
// EA254: using guessed type int x_DWORD_EA254;
// EA274: using guessed type int x_DWORD_EA274;
// 17DBC8: using guessed type int x_DWORD_17DBC8[];
// 17DBCC: using guessed type int x_DWORD_17DBCC[];
// 17DBD0: using guessed type int x_DWORD_17DBD0[];
// 17DBD4: using guessed type int x_DWORD_17DBD4[];
// 17DDBC: using guessed type int x_DWORD_17DDBC[];
// 17DDC0: using guessed type int x_DWORD_17DDC0[];
// 17DDC4: using guessed type int x_DWORD_17DDC4[];
// 17DDC8: using guessed type int x_DWORD_17DDC8[];
// 17DE3C: using guessed type int x_DWORD_17DE3C;
// 17DEC0: using guessed type int (int)x_DWORD_17DEC0;
// 17DED4: using guessed type int (int)x_DWORD_17DED4;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;

//----- (00083250) --------------------------------------------------------
void sub_83250_play_intros(char a1)
{
	int v1; // eax

	sub_8CD27_set_cursor(*filearray_2aa18c[0].posistruct);
	memset((void*)x_DWORD_180628b_screen_buffer, 0, 307200);
	if (x_WORD_180660_VGA_type_resolution != 1)
	{
		sub_54600_mouse_reset();
		memset((void*)*xadatapald0dat2.var28_begin_buffer, 0, 768);
		x_WORD_180660_VGA_type_resolution = 1;
		sub_90D6E_VGA_set_video_mode_320x200_and_pallette(*xadatapald0dat2.var28_begin_buffer);
		sub_8CEDF_install_mouse();
		sub_8CD27_set_cursor(*filearray_2aa18c[0].posistruct);
	}
	sub_76D10_intros(a1);
	sub_54600_mouse_reset();
	v1 = (int)memset((void*)*xadatapald0dat2.var28_begin_buffer, 0, 768);
	BYTE1(v1) = x_WORD_180660_VGA_type_resolution;
	if (x_WORD_180660_VGA_type_resolution & 1)
		sub_72883_clear_text_mode(/*v1, */(void *)x_DWORD_180628b_screen_buffer, 0xC8u, 0);
	else
		sub_728A9_clear_graphics_mode((void *)x_DWORD_180628b_screen_buffer, 0x1E0u, 0);
	sub_41A90_VGA_pallette_install(*xadatapald0dat2.var28_begin_buffer);
	x_WORD_180660_VGA_type_resolution = 8;
	sub_90E07_VGA_set_video_mode_640x480_and_pallette(*xadatapald0dat2.var28_begin_buffer);
	sub_8CEDF_install_mouse();
	sub_8CD27_set_cursor(*filearray_2aa18c[0].posistruct);
	sub_6EDB0_set_mouse_position_by_res();
	sub_7A110_load_hscreen(x_WORD_180660_VGA_type_resolution, 4);
	sub_7B5A0_disable_enable();
	sub_8CD27_set_cursor(xy_DWORD_17DED4_spritestr[39]);
	x_WORD_17DEEE = 0;
	x_BYTE_17DF10_get_key_scancode = 0;
	sub_84300_load_sound(0);
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// EA3D8: using guessed type int *xadatapald0dat2.var28_begin_buffer;
// EB394: using guessed type int **filearray_2aa18c[0];
// 17DED4: using guessed type int (int)x_DWORD_17DED4;
// 17DEEE: using guessed type __int16 x_WORD_17DEEE;
// 17DF10: using guessed type char x_BYTE_17DF10_get_key_scancode;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (000833C0) --------------------------------------------------------
void sub_833C0()
{
	Bit8u* v0; // eax
	Bit8u* v1; // eax
	int v2; // edx
	signed int v3; // eax
	signed int v4; // esi
	int v5; // ebx
	int v6; // eax
	int v7; // edx
	int v8; // eax
	unsigned int v9; // eax
	int v10; // edi
	char *v11; // ecx
	int v12; // eax
	int v13; // edx
	int v14; // eax
	unsigned __int8 v15; // al
	int v16; // eax
	int v17; // eax
	int v18; // [esp+0h] [ebp-14h]
	int v19; // [esp+8h] [ebp-Ch]
	signed __int16 v20; // [esp+Ch] [ebp-8h]
	int i; // [esp+10h] [ebp-4h]

	//fix it
	v2 = 0;
	v6 = 0;
	v7 = 0;
	v13 = 0;
	//fix it

	v19 = 0;
	v20 = 0;
	x_DWORD_17DE38 = *xadatapald0dat2.var28_begin_buffer;
	x_WORD_17DEEC = 0;
	x_DWORD_17DE40 = x_DWORD_180628b_screen_buffer;
	x_DWORD_17DEE0_filedesc = NULL;
	v0 = x_D41A0_BYTEARRAY_4_0xE2_heapbuffer;
	x_DWORD_17DEDC = 0;
	x_DWORD_17DE48c = v0;
	sub_7B5D0();
	x_DWORD_17DE54 = x_DWORD_17DE48c + 301787;
	x_DWORD_17DEC4 = x_DWORD_17DE48c + 316179;
	x_DWORD_17DE58 = x_DWORD_17DE48c + 316179;
	x_DWORD_17DEC8 = x_DWORD_17DE48c + 322754;
	x_DWORD_17DECC = x_DWORD_17DE48c + 324380;
	x_DWORD_17DED4 = x_DWORD_17DE48c + 324380;
	x_DWORD_17DED8 = x_DWORD_17DE48c + 326258;
	x_DWORD_17DE60 = x_DWORD_17DE44;
	x_DWORD_17DE64_game_world_map = x_DWORD_17DE48c + 326258;
	v1 = (0x12C000 + x_DWORD_17DE48c + 326258);//fix it
	x_DWORD_17DE3C = v1;
	x_DWORD_17DEC0 = x_DWORD_17DE48c + 314541;
	x_DWORD_17DE5C_border_bitmap = (v1 + 0x4000);
	v3 = j___clock();
	v4 = v3;
	while (sub_9A10A_check_keyboard(/*v3*/))
	{
		x_BYTE_1806E4 = 0;
		LOBYTE(v3) = sub_7A060_get_mouse_and_keyboard_events();
	}
	sub_8CD27_set_cursor(*filearray_2aa18c[0].posistruct);
	sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", (Bit8u*)(int)x_DWORD_17DE54, 0x1641FC, 1214);
	sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", (Bit8u*)(int)x_DWORD_17DEC0, 0x1646BA, 589);
	sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", (Bit8u*)x_DWORD_17DE58, 0x164907, 1191);
	sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", (Bit8u*)x_DWORD_17DEC8, 0x164DAE, 543);
	sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", (Bit8u*)x_DWORD_17DE38, 0x178B5F, 768);
	sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_17DE64_game_world_map, 0x16554D, 79378);
	sub_7AA70_load_and_decompres_dat_file(0, 0, 0, 0);
	if (x_WORD_180660_VGA_type_resolution & 1)
		sub_98709_create_index_dattab_power((Bit8u*)(int)x_DWORD_17DEC0, (Bit8u*)(int)x_DWORD_17DEC4, (Bit8u*)(int)x_DWORD_17DE54, (new posistruct));
	else
		sub_9874D_create_index_dattab((Bit8u*)(int)x_DWORD_17DEC0, (Bit8u*)(int)x_DWORD_17DEC4, (Bit8u*)(int)x_DWORD_17DE54, (new posistruct));
	if (x_WORD_180660_VGA_type_resolution & 1)
		sub_98709_create_index_dattab_power((Bit8u*)x_DWORD_17DEC8, (Bit8u*)x_DWORD_17DECC, (Bit8u*)x_DWORD_17DE58, (new posistruct));
	else
		sub_9874D_create_index_dattab((Bit8u*)x_DWORD_17DEC8, (Bit8u*)x_DWORD_17DECC, (Bit8u*)x_DWORD_17DE58, (new posistruct));
	x_BYTE_17DF10_get_key_scancode = 0;
	v5 = (int)x_DWORD_17DEC0 + 6;
	x_WORD_17DEEE = 0;
	x_DWORD_17DEC0 += 6;
	while (!x_BYTE_17DF10_get_key_scancode && !x_WORD_17DEEE)
	{
		if (x_WORD_180660_VGA_type_resolution & 1)
			sub_9A128_copy_screen_320((void*)x_DWORD_17DE64_game_world_map, (void*)x_DWORD_180628b_screen_buffer, 0xC8u);
		else
			sub_9A144_copy_screen_640((void*)x_DWORD_17DE64_game_world_map, (void*)x_DWORD_180628b_screen_buffer, 0x1E0u);
		v8 = j___clock();
		v5 = v19;
		v18 = v8;
		for (i = 0; ; i += v16 + 2)
		{
			v9 = (v18 - v4) / 0x64u;
			v10 = (signed __int16)v5;
			v11 = (char*)off_DB558[v10];
			if (!v11)
			{
				if (v9 > 5)
				{
					v12 = j___clock();
					v5 = 0;
					v4 = v12;
					v19 = 0;
				}
				goto LABEL_24;
			}
			if (!_stricmp(v11, "!"))
				break;
			v15 = sub_5BE80_test_pallette((unsigned __int8 *)x_DWORD_17DE38, 0x3Fu, 0x3Fu, 0x3Fu);
			sub_7FCB0_draw_text_with_border(v5, (Bit8u*)off_DB558[v10], 10, 620, (signed __int16)(i + 200), 5, v15, 0);
			//HIWORD(v16) = HIWORD(x_DWORD_17DEC0);
			LOWORD(v16) = xy_DWORD_17DEC0_spritestr[65].sizey;
			++v5;
		}
		if ((v18 - v4) / 0x64u > 2)
		{
			v14 = j___clock();v5++;
			v4 = v14;
			v19 = v5;
		}
	LABEL_24:
		sub_7A060_get_mouse_and_keyboard_events();
		if (v20)
		{
			if (x_WORD_180660_VGA_type_resolution & 1)
				sub_90478_VGA_Blit320();
			else
				sub_75200_VGA_Blit640(480);
		}
		else
		{
			sub_90B27_VGA_pal_fadein_fadeout((Bit8u*)x_DWORD_17DE38, 0x20u, 0);
			v20 = 1;
		}
	}
	sub_90B27_VGA_pal_fadein_fadeout(0, 0x10u, 0);
	v17 = (int)memset((void*)*xadatapald0dat2.var28_begin_buffer, 0, 768);
	LOBYTE(v17) = x_WORD_180660_VGA_type_resolution;
	if (x_WORD_180660_VGA_type_resolution & 1)
		sub_72883_clear_text_mode(/*v17, */(void *)x_DWORD_180628b_screen_buffer, 0xC8u, 0);
	else
		sub_728A9_clear_graphics_mode((void *)x_DWORD_180628b_screen_buffer, 0x1E0u, 0);
	if (x_WORD_180660_VGA_type_resolution & 1)
		sub_90478_VGA_Blit320();
	else
		sub_75200_VGA_Blit640(480);
	while (x_BYTE_17DF10_get_key_scancode || x_WORD_17DEEE)
		sub_7A060_get_mouse_and_keyboard_events();
	x_BYTE_17DF10_get_key_scancode = 0;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 98786: using guessed type int /*__fastcall*/ j___clock(x_DWORD, x_DWORD, x_DWORD);
// 98F5D: using guessed type x_DWORD stricmp(x_DWORD, x_DWORD);
// D41A4: using guessed type int x_DWORD_D41A4;
// DB558: using guessed type const char *off_DB558[3];
// EA3D8: using guessed type int *xadatapald0dat2.var28_begin_buffer;
// EB394: using guessed type int **filearray_2aa18c[0];
// 17DE38: using guessed type int x_DWORD_17DE38;
// 17DE3C: using guessed type int x_DWORD_17DE3C;
// 17DE40: using guessed type int x_DWORD_17DE40;
// 17DE44: using guessed type int x_DWORD_17DE44;
// 17DE48: using guessed type int x_DWORD_17DE48;
// 17DE54: using guessed type int (int)x_DWORD_17DE54;
// 17DE58: using guessed type int x_DWORD_17DE58;
// 17DE5C: using guessed type int x_DWORD_17DE5C_border_bitmap;
// 17DE60: using guessed type int x_DWORD_17DE60;
// 17DE64: using guessed type int x_DWORD_17DE64_game_world_map;
// 17DEC0: using guessed type int (int)x_DWORD_17DEC0;
// 17DEC4: using guessed type int (int)x_DWORD_17DEC4;
// 17DEC8: using guessed type int x_DWORD_17DEC8;
// 17DECC: using guessed type int x_DWORD_17DECC;
// 17DED4: using guessed type int (int)x_DWORD_17DED4;
// 17DED8: using guessed type int x_DWORD_17DED8;
// 17DEDC: using guessed type int x_DWORD_17DEDC;
// 17DEE0: using guessed type int x_DWORD_17DEE0_filedesc;
// 17DEEC: using guessed type __int16 x_WORD_17DEEC;
// 17DEEE: using guessed type __int16 x_WORD_17DEEE;
// 17DF10: using guessed type char x_BYTE_17DF10_get_key_scancode;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;
// 1806E4: using guessed type char x_BYTE_1806E4;

//----- (00083850) --------------------------------------------------------
int sub_83850_show_welcome_screen()//264850
{
	signed int v0; // eax
	signed int v1; // ebx
	int v2; // edx
	int v3; // edx
	int v4; // esi
	int v5; // eax
	//int v6; // eax
	signed int v7; // eax

	//fix it
	v2 = 0;
	v3 = 0;
	v7 = 0;
	//fix it

	sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", x_DWORD_E9C38_smalltit, 0x178E5F, 0x32B9);
	sub_7AA70_load_and_decompres_dat_file((char*)"DATA/SCREENS/HSCREEN0.DAT", *xadatapald0dat2.var28_begin_buffer, 0x17C118, 0x300);
	sub_7AA70_load_and_decompres_dat_file((char*)"\0", 0, 0, 0);
	//v0 = (int)sub_7AA70_load_and_decompres_dat_file(0, 0, 0, 0); //fix it
	v0 = 0;//fix it
	v1 = 0;
	v5 = j___clock();
	v4 = v5;
	//BYTE1(v5) = 0;
	x_BYTE_1806E4 = 0;
	while (!x_BYTE_1806E4 && !x_WORD_180746 && !x_WORD_180744 && (j___clock() - v4) / 0x64u <= 0x14)
	{
		if (x_WORD_180660_VGA_type_resolution & 1)
			sub_9A128_copy_screen_320(x_DWORD_E9C38_smalltit, x_DWORD_180628b_screen_buffer, 0xC8u);
		else
			sub_9A144_copy_screen_640(x_DWORD_E9C38_smalltit, x_DWORD_180628b_screen_buffer, 0x1E0u);
		if (v1)
		{
			if (x_WORD_180660_VGA_type_resolution & 1)
				sub_90478_VGA_Blit320();
			else
				sub_75200_VGA_Blit640(480);
		}
		else
		{
			v1 = 1;
			/*LOWORD(v5) = */sub_90B27_VGA_pal_fadein_fadeout(*xadatapald0dat2.var28_begin_buffer, 0x20u, 0);
		}
	}
	/*LOWORD(v6) = */sub_90B27_VGA_pal_fadein_fadeout(0, 0x10u, 0);
	if (x_WORD_180660_VGA_type_resolution & 1)
		sub_72883_clear_text_mode(/*x_DWORD_180628b_screen_buffer,*/ x_DWORD_180628b_screen_buffer, 0xC8u, 0);
	else
		sub_728A9_clear_graphics_mode(x_DWORD_180628b_screen_buffer, 0x1E0u, 0);
	if (x_WORD_180660_VGA_type_resolution & 1)
		sub_90478_VGA_Blit320();
	else
		sub_75200_VGA_Blit640(480);
	while (sub_9A10A_check_keyboard(/*v7*/))
	{
		x_BYTE_1806E4 = 0;
		v7 = sub_7A060_get_mouse_and_keyboard_events();
	}
	return j___delay(50);
}
// 98786: using guessed type int /*__fastcall*/ j___clock(x_DWORD, x_DWORD, x_DWORD);
// 9A122: using guessed type x_DWORD j___delay(x_DWORD);
// E9C38: using guessed type int x_DWORD_E9C38_smalltit;
// EA3D8: using guessed type int *xadatapald0dat2.var28_begin_buffer;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;
// 1806E4: using guessed type char x_BYTE_1806E4;
// 180744: using guessed type __int16 x_WORD_180744;
// 180746: using guessed type __int16 x_WORD_180746;

//----- (00083B50) --------------------------------------------------------
void sub_83B50()//264B50
{
	//int result; // eax
	//int v1; // edx
	//int v2; // edx
	//int v3; // eax
	//int v4; // ST04_4

	//result = x_D41A0_BYTEARRAY_4;//2A51A4d == ff //fix
	if (!(x_D41A0_BYTEARRAY_4_0xE2_heapbuffer))//2A51B2F = ff
	{
		x_BYTE_D41B5 = 32;
		x_BYTE_DB74C = 1;
		/*if ( (unsigned int)x_DWORD_17FEAC <= 0x800000 )//fix
		{
		  if ( (unsigned int)x_DWORD_17FEAC <= 0x700000 )
		  {
			v1 = x_DWORD_17FEAC - 2398576;
			if ( (unsigned int)x_DWORD_17FEAC <= 0x600000 )
			{
			  if ( (unsigned int)x_DWORD_17FEAC <= 0x500000 )
			  {
				if ( (unsigned int)x_DWORD_17FEAC <= 0x400000 )
				{
				  if ( (unsigned int)x_DWORD_17FEAC <= 0x300000 )
				  {
					x_D41A0_BYTEARRAY_4_0xE6_heapsize = 0x200000;
					x_BYTE_D41B5 = 16;
				  }
				  else
				  {
					x_D41A0_BYTEARRAY_4_0xE6_heapsize = x_DWORD_17FEAC - 1398576;
				  }
				  sub_9A230_set_x_WORD_E37B4(811);
				}
				else
				{
				  x_D41A0_BYTEARRAY_4_0xE6_heapsize = v1;
				  sub_9A230_set_x_WORD_E37B4(811);
				}
			  }
			  else
			  {
				x_D41A0_BYTEARRAY_4_0xE6_heapsize = v1;
				sub_9A230_set_x_WORD_E37B4(822);
			  }
			}
			else
			{
			  x_D41A0_BYTEARRAY_4_0xE6_heapsize = v1;
			  sub_9A230_set_x_WORD_E37B4(822);
			}
			*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8628) = 0;
		  }
		  else
		  {
			x_D41A0_BYTEARRAY_4_0xE6_heapsize = x_DWORD_17FEAC - 3398576;
			sub_9A230_set_x_WORD_E37B4(822);
		  }
		}
		else*/
		{
			x_D41A0_BYTEARRAY_4_0xE6_heapsize = 0x400000;
			sub_9A230_set_x_WORD_E37B4(822);
		}
		//v2 = (int)sub_83CD0_malloc2(x_D41A0_BYTEARRAY_4_0xE6_heapsize);
		//v3 = x_D41A0_BYTEARRAY_4;
		x_D41A0_BYTEARRAY_4_0xE2_heapbuffer = (Bit8u*)sub_83CD0_malloc2(x_D41A0_BYTEARRAY_4_0xE6_heapsize);
		if (!x_D41A0_BYTEARRAY_4_0xE2_heapbuffer)
		{
			//v4 = x_D41A0_BYTEARRAY_4[230]; //fix
			myprintf("ERROR 1: NOT ENOUGH MEMORY. (%ld / %ld)\n");
			exit(1);
		}
		sub_54630_load_psxblock(x_BYTE_D41B5);
		sub_5B7A0_prepare_pallette();//23C7A0
	}
	//return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// D41B5: using guessed type char x_BYTE_D41B5;
// DB74C: using guessed type char x_BYTE_DB74C;
// 17FEAC: using guessed type int x_DWORD_17FEAC;

//----- (00083CC0) --------------------------------------------------------
void sub_83CC0(char a1)
{
	//char result; // al

	//result = a1;
	x_BYTE_E29E8 = a1;
	//  return result;
}
// E29E8: using guessed type char x_BYTE_E29E8;

//----- (00083CD0) --------------------------------------------------------
void* sub_83CD0_malloc2(size_t a1) {
	return malloc(a1);
}
void* sub_83CD0_malloc2_orig(int a1)
{
	int *v1; // eax
	int v2; // ecx
	int *v3; // ebx
	unsigned int v4; // esi
	//unsigned int v5; // edx

	sub_85070();//tady se to nakrmi
	v1 = (int*)x_DWORD_17ECA0;// fix it 34FCA0 +4 //prvne zjisteny problem uz zde
	v2 = -1;
	v4 = a1 + 0x103;
	v3 = 0;
	LOWORD(v4) = (a1 + 0x103) & 0xFFFC;
	/*while ( v1 )
	{
	  v5 = v1[1];
	  if ( v4 <= v5 &&
		  v2 > v5 &&
		  !*((x_BYTE *)v1 + 16) &&
		  !x_DWORD_17E0A4[3 * *((unsigned __int8 *)v1 + 17)] )
	  {
		v3 = v1;
		v2 = v1[1];
	  }
	  v1 = (int *)v1[2];
	  //v1 = &(v1[2]);
	}*/ //fix it

	//v3 nesmi byt 0 
	/*if ( !v3 || !sub_83E00((int)v3, v4) )//problem je uz tady
	  return sub_83D70_malloc1(v4);//problem?
	sub_85350();
	memset((void*)*v3, 0, v4);*/ //fix ti
	return (void*)*v3;
	//return malloc(a1*sizeof(Bit8u));
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 17E0A4: using guessed type int x_DWORD_17E0A4[];
// 17ECA0: using guessed type int x_DWORD_17ECA0;

//----- (00083D70) --------------------------------------------------------
void* sub_83D70_malloc1(int a1)
{
	/*int *v1; // eax
	unsigned int v2; // edi
	int *v3; // ebx
	unsigned int v4; // esi
	unsigned int v5; // edx

	sub_85070();
	v1 = (int*)&x_DWORD_17ECA0;
	v2 = -1;
	v4 = a1 + 271;
	v3 = 0;
	LOWORD(v4) = (a1 + 271) & 0xFFF0;
	while ( v1 )
	{
	  v5 = v1[1];
	  if ( v4 <= v5 && v2 > v5 && !*((x_BYTE *)v1 + 16) && x_DWORD_17E0A4[3 * *((unsigned __int8 *)v1 + 17)] )
	  {
		v3 = v1;
		v2 = v1[1];
	  }
	  v1 = (int *)v1[2];
	}
	if ( !v3 || !sub_83E00((int)v3, v4) )
	  return 0;
	sub_85350();
	memset((void*)*v3, 0, v4);//problm
	return (void*)*v3;*/
	return malloc(a1);
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 17E0A4: using guessed type int x_DWORD_17E0A4[];
// 17ECA0: using guessed type int x_DWORD_17ECA0;

//----- (00083E00) --------------------------------------------------------
char sub_83E00(int a1, int a2)
{
	int *i; // eax
	char v4; // bl
	int v5; // edi

	if (a2 == *(x_DWORD *)(a1 + 4))
	{
		*(x_BYTE *)(a1 + 16) = x_BYTE_E29E8;
	}
	else
	{
		for (i = (int*)&x_DWORD_17ECA0; i < &x_DWORD_17FEA0 && i[1]; i = (int *)((char *)i + 18))
			;
		if (i == &x_DWORD_17FEA0)//problem problem
			return 0;
		i[1] = *(x_DWORD *)(a1 + 4) - a2;
		*i = a2 + *(x_DWORD *)a1;
		v4 = x_BYTE_E29E8;
		*(x_DWORD *)(a1 + 4) = a2;
		*(x_BYTE *)(a1 + 16) = v4;
		*((x_BYTE *)i + 17) = *(x_BYTE *)(a1 + 17);
		i[2] = *(x_DWORD *)(a1 + 8);
		i[3] = a1;
		v5 = *(x_DWORD *)(a1 + 8);
		if (v5)
			*(x_DWORD *)(v5 + 12) = (x_DWORD)i;
		*(x_DWORD *)(a1 + 8) = (x_DWORD)i;
	}
	return 1;
}
// E29E8: using guessed type char x_BYTE_E29E8;
// 17ECA0: using guessed type int x_DWORD_17ECA0;
// 17FEA0: using guessed type int x_DWORD_17FEA0;

//----- (00083E80) --------------------------------------------------------
void sub_83E80_sound_proc_99(Bit8u* a1)
{
	Bit8u* v1; // eax
	char v2; // bl
	int *i; // ebx

	if (a1)
	{
		v1 = (Bit8u*)&x_DWORD_17ECA0;
		v2 = 0;
		while (v1)
		{
			if ((int)a1 == v1[0])//fix
			{
				v2 = 1;
				*((x_BYTE *)v1 + 16) = 0;
				break;
			}
			v1 = (Bit8u*)(int *)v1[2];
		}
		if (v2 == 1)
		{
			for (i = (int*)&x_DWORD_17ECA0; i; i = (int *)i[2])
			{
				if (!*((x_BYTE *)i + 16))
					sub_84000((int)i);
			}
		}
		//sub_85350(); //fix
	}
}
// 17ECA0: using guessed type int x_DWORD_17ECA0;

//----- (00084000) --------------------------------------------------------
int sub_84000(int a1)
{
	int result; // eax
	int v2; // edx
	int v3; // ebx

	result = a1;
	if (*(x_DWORD *)(a1 + 12))
	{
		*(x_BYTE *)(a1 + 16) = 0;
		v2 = *(x_DWORD *)(a1 + 12);
		if (*(x_BYTE *)(a1 + 17) == *(x_BYTE *)(v2 + 17) && !*(x_BYTE *)(v2 + 16))
		{
			v3 = *(x_DWORD *)(a1 + 8);
			if (v3)
				*(x_DWORD *)(v3 + 12) = v2;
			*(x_DWORD *)(*(x_DWORD *)(a1 + 12) + 8) = *(x_DWORD *)(a1 + 8);
			*(x_DWORD *)(*(x_DWORD *)(a1 + 12) + 4) += *(x_DWORD *)(a1 + 4);
			*(x_DWORD *)(a1 + 4) = 0;
		}
	}
	return result;
}

//----- (00084050) --------------------------------------------------------
int sub_84050()
{
	char v0; // sf
	int result; // eax
	char v2; // [esp+0h] [ebp-8h]
	char v3; // [esp+1h] [ebp-7h]
	char v4; // [esp+2h] [ebp-6h]
	char v5; // [esp+3h] [ebp-5h]
	char v6; // [esp+4h] [ebp-4h]

	//fix it
	v0 = 0;
	//fix it

	sub_840B8(0, 0, v0, 0);
	v2 = x_BYTE_E29EC;
	v4 = x_BYTE_E29ED;
	v5 = x_BYTE_E29EE;
	v6 = x_BYTE_E29EF;
	v3 = x_BYTE_E29F0;
	if (x_BYTE_E29EC == 5)
	{
		result = (int)x_D41A0_BYTEARRAY_4;
		x_D41A0_BYTEARRAY_4[4 + 34] = 1;
	}
	else
	{
		result = (int)x_D41A0_BYTEARRAY_4;
		x_D41A0_BYTEARRAY_4[4 + 34] = 0;
	}
	return result;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D41A4: using guessed type int x_DWORD_D41A4;
// E29EC: using guessed type char x_BYTE_E29EC;
// E29ED: using guessed type char x_BYTE_E29ED;
// E29EE: using guessed type char x_BYTE_E29EE;
// E29EF: using guessed type char x_BYTE_E29EF;
// E29F0: using guessed type char x_BYTE_E29F0;

//----- (000840B8) --------------------------------------------------------
void sub_840B8(char a1, bool a2, char a3, char a4)
{
	unsigned int v4; // et0
	__int16 v5; // fps

	//fix it
	v5 = 0;
	//fix it

	v4 = x__readeflags();
	sub_840D3(a1, a2, a3, a4);
	sub_841CE(v5);
	x__writeeflags(v4);
}

//----- (000840D3) --------------------------------------------------------
__int16 sub_840D3(char _CF, bool _ZF, char _SF, char _OF)
{
	unsigned int v5; // et0
	unsigned int v6; // ecx
	unsigned int v7; // et0
	unsigned int v8; // et0
	unsigned int v9; // ecx
	unsigned int v10; // et0
	int *v16; // esi
	x_BYTE *v17; // edi
	signed int v18; // ecx
	__int16 v24; // [esp-6h] [ebp-Ah]

	//fix it
	v24 = 0;
	//fix it

	// fix this - __asm { pushfw }
	LOWORD(_EAX) = (v24 | 0xF000) & 0xF000;
	x_BYTE_E29EC = 2;
	if ((x_WORD)_EAX)
	{
		v5 = x__readeflags();
		v6 = v5;
		x__writeeflags((unsigned int)&loc_40000 ^ v5);
		v7 = x__readeflags();
		LOWORD(_EAX) = v6 ^ v7;
		x_BYTE_E29EC = 3;
		if (v6 != v7)
		{
			x_BYTE_E29EC = 4;
			v8 = x__readeflags();
			v9 = v8;
			x__writeeflags(v8 ^ 0x200000);
			v10 = x__readeflags();
			LOWORD(_EAX) = v9 ^ v10;
			if (v9 != v10)
			{
				x_BYTE_E2A06 = 1;
				_EAX = 0;
				//__asm { cpuid }
				x_DWORD_E29FA = _EBX;
				x_DWORD_E29FE = _EDX;
				x_DWORD_E2A02 = _ECX;
				v16 = &x_DWORD_E29FA;
				v17 = &unk_E2A08;
				v18 = 1;
				do
				{
					if (!v18)
						break;
					_ZF = *(x_BYTE *)v16 == *v17;
					v16 = (int *)((char *)v16 + 1);
					++v17;
					--v18;
				} while (_ZF);
				if (!v18)
					x_BYTE_E29ED = 1;
				_EAX = 1;
				//__asm { cpuid }
				x_DWORD_E29F6 = _EAX;
				x_BYTE_E29EC = (unsigned __int16)(_EAX & 0xF00) >> 8;
				x_BYTE_E29EF = _EAX & 0xF;
				x_BYTE_E29EE = (unsigned __int8)(_EAX & 0xF0) >> 4;
			}
		}
	}
	return _EAX;
}
// E29EC: using guessed type char x_BYTE_E29EC;
// E29ED: using guessed type char x_BYTE_E29ED;
// E29EE: using guessed type char x_BYTE_E29EE;
// E29EF: using guessed type char x_BYTE_E29EF;
// E29F6: using guessed type int x_DWORD_E29F6;
// E29FA: using guessed type int x_DWORD_E29FA;
// E29FE: using guessed type int x_DWORD_E29FE;
// E2A02: using guessed type int x_DWORD_E2A02;
// E2A06: using guessed type char x_BYTE_E2A06;

//----- (000841CE) --------------------------------------------------------
void /*__spoils<st0>*/ sub_841CE(__int16 a1)
{
	__int16 v1; // fps
	double v2; // st6
	bool v3; // c0
	char v4; // c2
	bool v5; // c3

	//fix
	v1 = 0;
	//fix

	//__asm { fninit }
	x_WORD_E29F4 = a1;
	if ((x_BYTE)a1)
	{
		x_BYTE_E29F0 = 0;
	}
	else if ((x_WORD_E29F4 & 0x103F) == 63)
	{
		x_BYTE_E29F0 = 1;
		if (x_BYTE_E29EC == 3)
		{
			v2 = 0;// fix it: -(1.0 / 0.0);
			v3 = v2 < 0;//fix it: v3 = v2 < 1.0 / 0.0;
			v4 = 0;
			v5 = v2 == 0.0;//fix it: v5 = v2 == 1.0 / 0.0;
			x_WORD_E29F4 = v1;
			x_BYTE_E29F1 = 2;
			if (v2 != 0.0)//if ( v2 != 1.0 / 0.0 )
				x_BYTE_E29F1 = 3;
		}
	}
	else
	{
		x_BYTE_E29F0 = 0;
	}
}
// E29EC: using guessed type char x_BYTE_E29EC;
// E29F0: using guessed type char x_BYTE_E29F0;
// E29F1: using guessed type char x_BYTE_E29F1;
// E29F4: using guessed type __int16 x_WORD_E29F4;

//----- (00084250) --------------------------------------------------------
bool sub_84250_load_file_array(int psindex)//265250
{
	//Pathstruct v1; // ebx
	Bit16u result; // si
	//Pathstruct v3; // ebx
	__int16 v4; // ax
	//char str[50];//char v6; // [esp+0h] [ebp-64h]

	int oldpsindex = psindex;
	sub_85070(); //fix it
	//v1 = pstr[psindex];//ebx=edi
	result = 0;//esi=0
	if (pstr[psindex].var28_begin_buffer)
	{
		do
		{
			sub_9A2F5(pstr[psindex++]);
			//v1 = pstr[++psindex];
		} while (pstr[psindex].var28_begin_buffer);
	}
	psindex = oldpsindex;
	//v3 = pstr[psindex];
	//oldpsindex = psindex;
	while (pstr[psindex].var28_begin_buffer)
	{
		v4 = sub_9A32D_malloc_open_unpack(pstr[psindex]);//27B32d - dalo mu to 1 - set 2bab20

		if (v4 >= 0)
		{
			if (v4)
			{
				psindex++;
				//v3 = pstr[++psindex];
				continue;
			}
			//goto LABEL_10;
			sub_41A90_VGA_pallette_install(*xadatapald0dat2.var28_begin_buffer); //fix it mozna instalace palety
			myprintf("ERROR: File %s.\n");
		}
		else
		{
			sub_41A90_VGA_pallette_install(*xadatapald0dat2.var28_begin_buffer);//fix it mozna instalace palety
			myprintf("ERROR: Allocation %s.\n");
		}
		myprintf("Press return to continue\n");
		result++;
		getc(stdin);
		//gets((x_DWORD)&v6);
	//LABEL_10:
		psindex++;
	}
	return result;
}
// 9A464: using guessed type x_DWORD gets(x_DWORD);
// EA3D8: using guessed type int *xadatapald0dat2.var28_begin_buffer;

//----- (00084300) --------------------------------------------------------
Bit32s sub_84300_load_sound(Bit8u a1)//265300
{
	FILE* v1; // eax
	FILE* v2; // ebx
	FILE* v3; // edi
	int v4; // eax
	Bit16s v6[6]; // [esp+0h] [ebp-14h]
	Bit32s v7; // [esp+Ch] [ebp-8h]
	int v8; // [esp+10h] [ebp-4h] - musi byt asi vstup

	//fix it
	v8 = 0;
	//fix it

	if (x_BYTE_E3798_sound_active2 && x_BYTE_E37AD_actual_sound != a1)
	{
		if (x_WORD_E2A14_sound_activeh)
			sub_8D8F0_sound_proc3_endsample();
		v1 = sub_98817_open((char*)"SOUND/SOUND.DAT", 512);
		v2 = v1;
		v3 = v1;
		if (v1 != NULL)
		{
			sub_9891E_seek(v1, 0, 2);
			v4 = myftell(v2);
			sub_9891E_seek(v2, v4 - 4, 0);
			sub_988A7_read(v2, (Bit8u*)&v7, 4);
			sub_9891E_seek(v2, v7, 0);
			sub_988A7_read(v2, (Bit8u*)v6, 12);
			if (x_WORD_E37B6_sound_number < 0x336u)
			{
				if (x_WORD_E37B6_sound_number >= 0x320u)
				{
					if (x_WORD_E37B6_sound_number <= 0x320u)
					{
						v8 = 5;
					}
					else if (x_WORD_E37B6_sound_number == 811)
					{
						v8 = 4;
					}
				}
			}
			else if (x_WORD_E37B6_sound_number <= 0x336u)
			{
				v8 = 3;
			}
			else if (x_WORD_E37B6_sound_number < 0x656u)
			{
				if (x_WORD_E37B6_sound_number == 1611)
					v8 = 2;
			}
			else if (x_WORD_E37B6_sound_number <= 0x656u)
			{
				v8 = 1;
			}
			else if (x_WORD_E37B6_sound_number == 1644)
			{
				v8 = 0;
			}
			if ((a1 + 1) > v6[v8])
			{
				sub_98882_close(v3);
				return 1;
			}
			sub_9891E_seek(v3, 96 * a1, 1);//seek to finded sound
			if (!sub_844F0_read_and_decompress_sound(v3, v8))
			{
				sub_98882_close(v3);
				return 1;
			}
			x_BYTE_E37AD_actual_sound = a1;
			sub_98882_close(v3);
		}
	}
	return 0;
}
// 9A510: using guessed type x_DWORD tell(x_DWORD);
// E2A14: using guessed type __int16 x_WORD_E2A14_sound_active;
// E3798: using guessed type char x_BYTE_E3798_sound_active2;
// E37AD: using guessed type char x_BYTE_E37AD_actual_sound;
// E37B6: using guessed type __int16 x_WORD_E37B6_sound_number;
// 84300: using guessed type __int16 var_14[6];

//----- (000844A0) --------------------------------------------------------
void sub_844A0_sound_proc5()
{
	__int16 v0; // bx
	Bit8u* v1; // eax
	int v2; // esi

	v0 = x_WORD_180B50;
	if (x_DWORD_E37A0_sound_buffer2 && x_DWORD_E37A8_sound_buffer1)
	{
		v1 = x_DWORD_E37A0_sound_buffer2 + 32;
		v0 = 0;
		while (v1 < x_DWORD_E37A4_sound_buffer3)
		{
			v2 = *(x_DWORD *)(v1 + 18);
			v1 += 32;
			++v0;
			*(x_DWORD *)(v1 - 14) = (int32)x_DWORD_E37A8_sound_buffer1 + v2;
		}
	}
	x_WORD_180B50 = v0;
}
// E37A0: using guessed type int x_DWORD_E37A0_sound_buffer2;
// E37A4: using guessed type int x_DWORD_E37A4_sound_buffer3;
// E37A8: using guessed type int x_DWORD_E37A8_sound_buffer1;
// 180B50: using guessed type __int16 x_WORD_180B50;

//----- (000844F0) --------------------------------------------------------
char sub_844F0_read_and_decompress_sound(FILE* a1, unsigned __int8 a2)//2654f0
{
	int v2; // ebx
	//Bit8u* v3; // eax
	char result; // al
	int v5; // eax
	Bit8u* v6; // ebx
	Bit8u* v7; // esi
	char v8[96]; // [esp+0h] [ebp-60h]//3550d8
	//char _4[96]; // [esp+4h] [ebp-5Ch]//3550dc
	//char _8[96]; // [esp+8h] [ebp-58h]
	//char _C[96]; // [esp+Ch] [ebp-54h]

	myftell(a1);
	v2 = 16 * a2;
	//3550d8 60
	sub_988A7_read(a1, (Bit8u*)v8, 96);
	if (*(x_DWORD *)&v8[v2 + 4] == -1)//ebp-5c
		return 0;
	if (!x_WORD_E2A14_sound_activeh)
	{
		x_DWORD_E37A8_sound_buffer1 = (Bit8u*)sub_83CD0_malloc2(*(x_DWORD *)&v8[v2 + 12] + 256);
		x_DWORD_E37A0_sound_buffer2 = (Bit8u*)sub_83CD0_malloc2(3100);
		x_WORD_E2A14_sound_activel = 1;
		if (!x_DWORD_E37A8_sound_buffer1 || !x_DWORD_E37A0_sound_buffer2)
		{
			sub_83E80_sound_proc_99(x_DWORD_E37A8_sound_buffer1);
			sub_83E80_sound_proc_99(x_DWORD_E37A0_sound_buffer2);
			x_WORD_E2A14_sound_activel = 0;
			result = 0;
			x_BYTE_E37AD_actual_sound = -1;
			return result;
		}
		x_DWORD_E2A18 = *(x_DWORD *)&v8[v2 + 12] + 256;
		x_WORD_E2A14_sound_activeh = 1;
		x_DWORD_E2A1C = 3100;
	}
	x_BYTE_E3798_sound_active2 = 0;
	if (!x_DWORD_E37A8_sound_buffer1 || !x_DWORD_E37A0_sound_buffer2)
		return 0;
	memset((void*)x_DWORD_E37A8_sound_buffer1, 0, x_DWORD_E2A18);
	memset((void*)x_DWORD_E37A0_sound_buffer2, 0, x_DWORD_E2A1C);
	v5 = 16 * a2;
	v6 = x_DWORD_E37A0_sound_buffer2;
	x_DWORD_E37A4_sound_buffer3 = x_DWORD_E37A0_sound_buffer2 + *(x_DWORD *)&v8[v5 + 8];
	v7 = x_DWORD_E37A8_sound_buffer1;
	sub_9891E_seek(a1, *(x_DWORD *)&v8[v5 + 4], 0);
	sub_988A7_read(a1, x_DWORD_E37A8_sound_buffer1, 8);
	if (v7[0] != 82 || v7[1] != 78 || v7[2] != 67)
	{
		sub_988A7_read(a1, (x_DWORD_E37A8_sound_buffer1 + 8), *(x_DWORD *)&v8[16 * a2 + 12] - 8);
	}
	else
	{
		sub_988A7_read(
			a1,
			(x_DWORD_E37A8_sound_buffer1 + 8),
			v7[7]
			+ ((v7[6] + ((v7[5] + (v7[4] << 8)) << 8)) << 8)
			- 8);
		sub_9894C_decompress(v7, v7);
	}
	sub_9891E_seek(a1, *(x_DWORD *)&v8[16 * a2], 0);
	sub_988A7_read(a1, x_DWORD_E37A0_sound_buffer2, 8);
	if (*v6 != 82 || v6[1] != 78 || v6[2] != 67)
	{
		sub_988A7_read(a1, (x_DWORD_E37A0_sound_buffer2 + 8), *(x_DWORD *)&v8[16 * a2 + 8] - 8);
	}
	else
	{
		sub_988A7_read(
			a1,
			(x_DWORD_E37A0_sound_buffer2 + 8),
			v6[7]
			+ ((v6[6] + ((v6[5] + (v6[4] << 8)) << 8)) << 8)
			- 8);
		sub_9894C_decompress(v6, v6);
	}
	sub_844A0_sound_proc5();
	x_BYTE_E3798_sound_active2 = 1;
	return 1;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 9A510: using guessed type x_DWORD tell(x_DWORD);
// E2A14: using guessed type __int16 x_WORD_E2A14_sound_active;
// E2A18: using guessed type int x_DWORD_E2A18;
// E2A1C: using guessed type int x_DWORD_E2A1C;
// E3798: using guessed type char x_BYTE_E3798_sound_active2;
// E37A0: using guessed type int x_DWORD_E37A0_sound_buffer2;
// E37A4: using guessed type int x_DWORD_E37A4_sound_buffer3;
// E37A8: using guessed type int x_DWORD_E37A8_sound_buffer1;
// E37AD: using guessed type char x_BYTE_E37AD_actual_sound;
// 844F0: using guessed type char var_60[96];

//----- (00084790) --------------------------------------------------------
int sub_84790()
{
	int result; // eax

	memset((void*)(x_D41A0_BYTEARRAY_0 + 222796), 0, 1950);
	result = (int)x_D41A0_BYTEARRAY_0;
	*(x_WORD *)(x_D41A0_BYTEARRAY_0 + 224762) = 0;
	*(x_DWORD *)(result + 224754) = (x_DWORD)&loc_3A013;
	return result;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (000847D0) --------------------------------------------------------
char sub_847D0(int a1, char a2, char a3, char a4)
{
	__int16 v4; // dx
	unsigned __int8 v5; // dh
	int v6; // eax

	LOBYTE(v4) = 0;
	if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8598))
	{
		v5 = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308);
		if (v5 >= 1u && v5 <= 2u && *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 224762) < 50)
		{
			v6 = (int)x_D41A0_BYTEARRAY_0 + 222796;
			HIBYTE(v4) = 0;
			while (v4 < 50 && *(x_BYTE *)v6)
			{
				++v4;
				v6 += 39;
			}
			*(x_BYTE *)v6 = 1;
			*(x_BYTE *)(v6 + 1) = a4;
			*(x_BYTE *)(v6 + 2) = a2;
			*(x_BYTE *)(v6 + 3) = a3;
			*(x_DWORD *)(v6 + 4) = *(x_DWORD *)(a1 + 76);
			*(x_WORD *)(v6 + 8) = *(x_WORD *)(a1 + 80);
			*(x_DWORD *)(v6 + 10) = a1;
			*(x_BYTE *)(a1 + 14) |= 8u;
			memset((void*)(v6 + 14), 0, 25);
			LOBYTE(v4) = 1;
			++*(x_WORD *)(x_D41A0_BYTEARRAY_0 + 224762);
		}
	}
	return v4;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00084880) --------------------------------------------------------
int sub_84880(x_BYTE *a1)
{
	int result; // eax

	*a1 = 0;
	result = (int)x_D41A0_BYTEARRAY_0;
	--*(x_WORD *)(result + 224762);
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (000848A0) --------------------------------------------------------
char sub_848A0()
{
	unsigned __int16 v0; // ax
	int v1; // edx
	__int16 v2; // bx
	__int16 v3; // si
	int v4; // eax
	unsigned __int16 v5; // di
	unsigned __int16 v6; // di
	unsigned __int16 v7; // di
	unsigned __int16 v8; // di
	unsigned __int16 v9; // di
	unsigned __int16 v10; // di
	unsigned __int16 v11; // di
	unsigned __int16 v12; // di
	unsigned __int16 v13; // di
	unsigned __int16 v14; // di
	unsigned __int16 v15; // di
	unsigned __int16 v16; // di
	unsigned __int16 v17; // di
	unsigned __int16 v18; // di
	unsigned __int16 v19; // di
	unsigned __int16 v20; // di
	unsigned __int16 v21; // di
	unsigned __int16 v22; // di
	unsigned __int16 v23; // di
	unsigned __int16 v24; // di
	unsigned __int16 v25; // di
	unsigned __int16 v26; // di
	unsigned __int16 v27; // di
	char v28; // ch
	unsigned __int16 v29; // di
	__int16 v31; // [esp+4h] [ebp-4h]

	LOBYTE(v0) = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308);
	if ((unsigned __int8)v0 >= 1u && (unsigned __int8)v0 <= 2u)
	{
		v0 = *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 224762);
		v31 = v0;
		if (v0)
		{
			v1 = (int)x_D41A0_BYTEARRAY_0 + 222796;
			v2 = 0;
			v3 = 0;
			while (v2 < 50 && v3 < v31)
			{
				if (*(x_BYTE *)v1)
				{
					v4 = *(signed __int16 *)(v1 + 4) >> 8;
					BYTE1(v4) = (*(x_WORD *)(v1 + 6) >> 8) - 2;
					LOBYTE(v4) = v4 - 2;
					v5 = v4;
					LOBYTE(v4) = v4 + 1;
					x_BYTE_12B4E0[v5] -= *(x_BYTE *)(v1 + 14);
					v6 = v4;
					LOBYTE(v4) = v4 + 1;
					x_BYTE_12B4E0[v6] -= *(x_BYTE *)(v1 + 15);
					v7 = v4;
					LOBYTE(v4) = v4 + 1;
					x_BYTE_12B4E0[v7] -= *(x_BYTE *)(v1 + 16);
					v8 = v4;
					LOBYTE(v4) = v4 + 1;
					x_BYTE_12B4E0[v8] -= *(x_BYTE *)(v1 + 17);
					v9 = v4;
					++BYTE1(v4);
					x_BYTE_12B4E0[v9] -= *(x_BYTE *)(v1 + 18);
					v10 = v4;
					LOBYTE(v4) = v4 - 1;
					x_BYTE_12B4E0[v10] -= *(x_BYTE *)(v1 + 19);
					v11 = v4;
					LOBYTE(v4) = v4 - 1;
					x_BYTE_12B4E0[v11] -= *(x_BYTE *)(v1 + 20);
					v12 = v4;
					LOBYTE(v4) = v4 - 1;
					x_BYTE_12B4E0[v12] -= *(x_BYTE *)(v1 + 21);
					v13 = v4;
					LOBYTE(v4) = v4 - 1;
					x_BYTE_12B4E0[v13] -= *(x_BYTE *)(v1 + 22);
					v14 = v4;
					++BYTE1(v4);
					x_BYTE_12B4E0[v14] -= *(x_BYTE *)(v1 + 23);
					v15 = v4;
					LOBYTE(v4) = v4 + 1;
					x_BYTE_12B4E0[v15] -= *(x_BYTE *)(v1 + 24);
					v16 = v4;
					LOBYTE(v4) = v4 + 1;
					x_BYTE_12B4E0[v16] -= *(x_BYTE *)(v1 + 25);
					v17 = v4;
					LOBYTE(v4) = v4 + 1;
					x_BYTE_12B4E0[v17] -= *(x_BYTE *)(v1 + 26);
					v18 = v4;
					LOBYTE(v4) = v4 + 1;
					x_BYTE_12B4E0[v18] -= *(x_BYTE *)(v1 + 27);
					v19 = v4;
					++BYTE1(v4);
					x_BYTE_12B4E0[v19] -= *(x_BYTE *)(v1 + 28);
					v20 = v4;
					LOBYTE(v4) = v4 - 1;
					x_BYTE_12B4E0[v20] -= *(x_BYTE *)(v1 + 29);
					++v3;
					x_BYTE_12B4E0[(unsigned __int16)v4] -= *(x_BYTE *)(v1 + 30);
					LOBYTE(v4) = v4 - 1;
					v21 = v4;
					LOBYTE(v4) = v4 - 1;
					x_BYTE_12B4E0[v21] -= *(x_BYTE *)(v1 + 31);
					v22 = v4;
					LOBYTE(v4) = v4 - 1;
					x_BYTE_12B4E0[v22] -= *(x_BYTE *)(v1 + 32);
					v23 = v4;
					HIBYTE(v0) = BYTE1(v4) + 1;
					x_BYTE_12B4E0[v23] -= *(x_BYTE *)(v1 + 33);
					v24 = v0;
					LOBYTE(v0) = v0 + 1;
					x_BYTE_12B4E0[v24] -= *(x_BYTE *)(v1 + 34);
					v25 = v0;
					LOBYTE(v0) = v0 + 1;
					x_BYTE_12B4E0[v25] -= *(x_BYTE *)(v1 + 35);
					v26 = v0;
					LOBYTE(v0) = v0 + 1;
					x_BYTE_12B4E0[v26] -= *(x_BYTE *)(v1 + 36);
					v27 = v0;
					v28 = x_BYTE_12B4E0[v0] - *(x_BYTE *)(v1 + 37);
					LOBYTE(v0) = v0 + 1;
					x_BYTE_12B4E0[v27] = v28;
					v29 = v0;
					LOBYTE(v0) = *(x_BYTE *)(v1 + 38);
					x_BYTE_12B4E0[v29] -= v0;
				}
				++v2;
				v1 += 39;
			}
		}
	}
	return v0;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00084B80) --------------------------------------------------------
int sub_84B80()
{
	int result; // eax
	unsigned __int8 v1; // dl
	int v2; // esi
	int v3; // esi
	unsigned __int16 v4; // bx
	int v5; // eax
	int i; // [esp+0h] [ebp-10h]
	int v7; // [esp+4h] [ebp-Ch]
	__int16 v8; // [esp+8h] [ebp-8h]
	signed __int16 v9; // [esp+Ch] [ebp-4h]

	result = (int)x_D41A0_BYTEARRAY_0;
	v1 = *(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308);
	if (v1 >= 1u && v1 <= 2u)
	{
		v9 = *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 224762);
		if (v9)
		{
			result = (int)x_D41A0_BYTEARRAY_0 + 222796;
			v8 = 0;
			v7 = 0;
			for (i = (int)x_D41A0_BYTEARRAY_0 + 222796; v8 < 50; i += 39)
			{
				result = v7;
				if ((signed __int16)v7 >= v9)
					break;
				result = i;
				if (*(x_BYTE *)i)
				{
					v2 = *(x_DWORD *)(i + 10);
					++v7;
					if (*(x_DWORD *)(v2 + 8) < 0 || *(x_BYTE *)(v2 + 13) & 4)
					{
						result = sub_84880((x_BYTE *)i);
					}
					else
					{
						v3 = v2 + 76;
						*(x_DWORD *)(i + 4) = *(x_DWORD *)v3;
						*(x_WORD *)(i + 8) = *(x_WORD *)(v3 + 4);
						LOBYTE(v4) = *(x_WORD *)(i + 4) >> 8;
						HIBYTE(v4) = *(x_WORD *)(i + 6) >> 8;
						v5 = (int)x_D41A0_BYTEARRAY_0;
						*(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 224754) = 9377 * *(x_DWORD *)(x_D41A0_BYTEARRAY_0 + 224754) + 9439;
						LOWORD(v3) = *(x_DWORD *)(v5 + 224754) % (unsigned int)*(unsigned __int8 *)(i + 3)
							- *(unsigned __int8 *)(i + 3) / 2;
						HIBYTE(v4) -= 2;
						LOBYTE(v4) = v4 - 2;
						sub_84EA0(v4, i, 0, v3);
						LOBYTE(v4) = v4 + 1;
						sub_84EA0(v4, i, 1, v3);
						LOBYTE(v4) = v4 + 1;
						sub_84EA0(v4, i, 2, v3);
						LOBYTE(v4) = v4 + 1;
						sub_84EA0(v4, i, 3, v3);
						LOBYTE(v4) = v4 + 1;
						sub_84EA0(v4, i, 4, v3);
						++HIBYTE(v4);
						sub_84EA0(v4, i, 5, v3);
						LOBYTE(v4) = v4 - 1;
						sub_84EA0(v4, i, 6, v3);
						LOBYTE(v4) = v4 - 1;
						sub_84EA0(v4, i, 7, v3);
						LOBYTE(v4) = v4 - 1;
						sub_84EA0(v4, i, 8, v3);
						LOBYTE(v4) = v4 - 1;
						sub_84EA0(v4, i, 9, v3);
						++HIBYTE(v4);
						sub_84EA0(v4, i, 10, v3);
						LOBYTE(v4) = v4 + 1;
						sub_84EA0(v4, i, 11, v3);
						LOBYTE(v4) = v4 + 1;
						sub_84EA0(v4, i, 12, v3);
						LOBYTE(v4) = v4 + 1;
						sub_84EA0(v4, i, 13, v3);
						LOBYTE(v4) = v4 + 1;
						sub_84EA0(v4, i, 14, v3);
						++HIBYTE(v4);
						sub_84EA0(v4, i, 15, v3);
						LOBYTE(v4) = v4 - 1;
						sub_84EA0(v4, i, 16, v3);
						LOBYTE(v4) = v4 - 1;
						sub_84EA0(v4, i, 17, v3);
						LOBYTE(v4) = v4 - 1;
						sub_84EA0(v4, i, 18, v3);
						LOBYTE(v4) = v4 - 1;
						sub_84EA0(v4, i, 19, v3);
						++HIBYTE(v4);
						sub_84EA0(v4, i, 20, v3);
						LOBYTE(v4) = v4 + 1;
						sub_84EA0(v4, i, 21, v3);
						LOBYTE(v4) = v4 + 1;
						sub_84EA0(v4, i, 22, v3);
						LOBYTE(v4) = v4 + 1;
						sub_84EA0(v4, i, 23, v3);
						LOBYTE(v4) = v4 + 1;
						result = sub_84EA0(v4, i, 24, v3);
					}
				}
				++v8;
			}
		}
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;

//----- (00084EA0) --------------------------------------------------------
int sub_84EA0(unsigned __int16 a1, int a2, char a3, __int16 a4)
{
	signed int v4; // esi
	signed int v5; // edi
	int v6; // ebx
	int v7; // ecx
	int v8; // edx
	signed int v9; // ebx
	int v10; // edx
	int result; // eax
	__int16 v12; // [esp+0h] [ebp-8h]
	__int16 v13; // [esp+2h] [ebp-6h]
	__int16 v14; // [esp+4h] [ebp-4h]

	v4 = 31;
	v5 = (unsigned __int8)x_BYTE_12B4E0[a1];
	LOBYTE(v6) = 0;
	if (v5 < 63)
	{
		v12 = ((unsigned __int8)a1 << 8) + 128;
		v13 = (HIBYTE(a1) << 8) + 128;
		v14 = sub_10C40(&v12);
		v7 = sub_84FB0((signed __int16 *)(a2 + 4), &v12);
		if (v7 < 294912)
		{
			if (*(x_BYTE *)(a2 + 1) & 1)
			{
				v8 = *(x_DWORD *)(a2 + 10);
				v9 = *(x_DWORD *)(v8 + 8);
				if (v9 <= 0)
				{
					v4 = 0;
				}
				else if (v9 < 31)
				{
					v4 = *(x_DWORD *)(v8 + 8);
				}
			}
			v10 = 31 * (294912 - v7) / 294912 * *(unsigned __int8 *)(a2 + 2);
			v6 = a4 + ((v10 - (__CFSHL__(v10 >> 31, 7) + (v10 >> 31 << 7))) >> 7);
			if (v6 > v4)
				v6 = v4;
			if (v5 + v6 > 63)
				v6 = 63 - v5;
			if (v6 < 0)
				LOBYTE(v6) = 0;
			x_BYTE_12B4E0[a1] += v6;
		}
	}
	result = a2 + a3;
	*(x_BYTE *)(result + 14) = v6;
	return result;
}

//----- (00084FB0) --------------------------------------------------------
int sub_84FB0(signed __int16 *a1, signed __int16 *a2)
{
	int v2; // eax
	int v3; // edx
	int v4; // eax

	v2 = a1[1] - a2[1];
	v3 = v2 * v2;
	v4 = *a1 - *a2;
	return v4 * v4 + v3 + (a1[2] - a2[2]) * (a1[2] - a2[2]);
}

//----- (00085060) --------------------------------------------------------
int sub_85060(int a1)
{
	return *(x_DWORD *)(a1 + 4);
}

//----- (00085070) --------------------------------------------------------
void sub_85070()// fix it 34FCA0
{
	signed int v0; // ebx
	//int *v1; // ST04_4
	signed int v2; // ebx
	//char *v3; // ST04_4
	unsigned int v4; // ebx
	int v5; // esi
	//void* v6; // eax
	//int v7; // edi
	//int v8; // edx
	int v9; // eax
	signed int i; // ebx
	//char* v11; // eax
	signed int j; // edi
	int k; // ebx
	int v14; // edx
	int v15; // eax
	signed int v16; // ebx
	int v17; // eax
	int l; // ebx
	int v19; // edx
	int v20; // eax
	void* v21; // [esp+0h] [ebp-Ch]
	int v22; // [esp+8h] [ebp-4h]

	//fix
	v9 = 0;
	//fix

	/*
	eax=1
	ecx=0
	edx=0
	*/

	if (!x_DWORD_17E0A8)//34f0a8
	{

		v21 = sub_85450_allocate_mem_pool(0x10000);
		/*
		1f01c02
		prepi se 3
		0
		1f0
		*/

		//v0 = 0;
		/*esp=355148
		espx += 4;
		[ebp-0xc(355158-c)]=v21;*/
		v0 = 0;
		do
		{
			memset(&x_DWORD_17E0A0[3 * v0++], 0, 12);
		} while (v0 < 0x100);
		v2 = 0;
		while (v2 < 0x100)
		{
			memset(&x_DWORD_17ECA0[18 * v2++], 0, 18);
		}
		v4 = 0xA0000;//(char *)&loc_A0000_vga_buffer; fix it 34FCA0 +4 //2660F9
		v5 = 0;
		/*while ( (signed int)v4 >= 0x400 )//fix it maybe
		{
		  v6 = sub_85450_allocate_mem_pool(v4);//vraci same nuly
		  if ( v6 )
		  {
			v7 = (unsigned __int16)v6;//vraci nulu
			v8 = (int)v6 >> 16;
			v9 = 3 * v5;
			x_DWORD_17E0A8[v9] = (int)v4;
			++v5;
			x_DWORD_17E0A4[v9] = v8;
			v4 += 0x400;
			x_DWORD_17E0A0[v9] = 16 * v7;
		  }
		  v4 -= 0x400;
		}*/
		for (i = 0x1000000; i >= 0x1000; i -= 0x1000)
		{
			x_DWORD_17E0A0[3 * v5] = (char*)malloc(i * sizeof(Bit8u));
			if (x_DWORD_17E0A0[3 * v5])
			{
				for (j = 4096; j > 0; j -= 16)
				{
					v22 = 3 * v5;
					if (x_expand(x_DWORD_17E0A0[3 * v5], i + j))
					{
						x_DWORD_17E0A8[v22] = i + j;
						x_DWORD_17E0A4[v22] = 0;
						break;
					}
				}
				i += 4096;
				++v5;
			}
		}
		for (k = 4096; k >= 16; k -= 16)
		{
			v14 = (int)malloc(k * sizeof(Bit8u));
			v15 = 3 * v5;
			x_DWORD_17E0A0[3 * v5] = (char*)v14;
			if (v14)
			{
				++v5;
				x_DWORD_17E0A8[v15] = k;
				k += 0x1000;
				x_DWORD_17E0A4[v15] = 0;
			}
		}
		v16 = 0;
		qsort(x_DWORD_17E0A0, v5, 12, (int(*)(const void *, const void *))sub_85060);
		do
		{
			v17 = 9 * v16++;
			*(int *)((char *)&x_DWORD_17ECA4 + 2 * v17) = 0;
		} while (v16 < 0x100);
		for (l = 0; l < v5; l++)
		{
			v19 = 18 * l;
			*(int *)((char *)&x_DWORD_17ECA0 + v19) = (int)x_DWORD_17E0A0[3 * l];
			*(int *)((char *)&x_DWORD_17ECA4 + v19) = x_DWORD_17E0A8[3 * l];
			if (l)
				*(int *)((char *)&x_DWORD_17ECAC + v19) = (int)&x_DWORD_17ECA0 + 18 * (l - 1);
			else
				*(int *)((char *)&x_DWORD_17ECAC + v19) = 0;
			v20 = 9 * l;
			*(int *)((char *)&x_DWORD_17ECA8 + 2 * v20) = (int)&x_DWORD_17ECA0 + 18 * (l + 1);
			x_BYTE_17ECB0[2 * v20] = 0;
			x_BYTE_17ECB1[2 * v20] = l;
		}
		*(int *)((char *)&x_DWORD_17ECA8 + 18 * (v5 - 1)) = 0;
		sub_9AD16_free_mem_pool(v21);
	}
}
// 10000: using guessed type void /*__noreturn*/ sub_10000();
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 9A522: using guessed type x_DWORD malloc(x_DWORD);
// 9A61E: using guessed type x_DWORD expand(x_DWORD, x_DWORD);
// 9A8EE: using guessed type x_DWORD qsort(x_DWORD, x_DWORD, x_DWORD, x_DWORD);
// 17E0A0: using guessed type int x_DWORD_17E0A0[];
// 17E0A4: using guessed type int x_DWORD_17E0A4[];
// 17ECA0: using guessed type int x_DWORD_17ECA0;
// 17ECA4: using guessed type int x_DWORD_17ECA4;
// 17ECA8: using guessed type int x_DWORD_17ECA8;
// 17ECAC: using guessed type int x_DWORD_17ECAC;
/*
//----- (00085350) --------------------------------------------------------
int *sub_85350()
{
  int *result; // eax
  unsigned int v1; // edx
  int v2; // edx

  result = (int*)&x_DWORD_17ECA0;
  x_DWORD_17FEA0 = 0;
  x_DWORD_17FEA4_mem_free = 0;
  x_DWORD_17FEA8_mem_used = 0;
  x_DWORD_17FEAC = 0;
  x_DWORD_17FEB0 = -1;
  while ( result )
  {
	if ( *((x_BYTE *)result + 16) )
	{
	  v2 = result[1];
	  x_DWORD_17FEA8_mem_used += v2;
	  x_DWORD_17FEA0 += v2;
	}
	else
	{
	  v1 = result[1];
	  x_DWORD_17FEA4_mem_free += v1;
	  if ( v1 > x_DWORD_17FEAC )
		x_DWORD_17FEAC = v1;
	  if ( result[1] < (unsigned int)x_DWORD_17FEB0 )
		x_DWORD_17FEB0 = result[1];
	  x_DWORD_17FEA0 += result[1];
	}
	result = (int *)result[2];
  }
  LOBYTE(x_DWORD_17FEA0) = x_DWORD_17FEA0 & 0xFC;
  LOBYTE(x_DWORD_17FEA4_mem_free) = x_DWORD_17FEA4_mem_free & 0xFC;
  LOBYTE(x_DWORD_17FEAC) = x_DWORD_17FEAC & 0xFC;
  LOBYTE(x_DWORD_17FEA8_mem_used) = x_DWORD_17FEA8_mem_used & 0xFC;
  LOBYTE(x_DWORD_17FEB0) = x_DWORD_17FEB0 & 0xFC;
  return result;
}
// 17ECA0: using guessed type int x_DWORD_17ECA0;
// 17FEA0: using guessed type int x_DWORD_17FEA0;
// 17FEA4: using guessed type int x_DWORD_17FEA4_mem_free;
// 17FEA8: using guessed type int x_DWORD_17FEA8_mem_used;
// 17FEAC: using guessed type int x_DWORD_17FEAC;
// 17FEB0: using guessed type int x_DWORD_17FEB0;
*/
//----- (00085450) --------------------------------------------------------
//void *dpmi_real_malloc( int size, ushort *selector )
void* sub_85450_allocate_mem_pool(unsigned int size)//nutno doresit
{
	/*int v1; // ebx
	int v3; // [esp+0h] [ebp-38h]
	unsigned int v4; // [esp+4h] [ebp-34h]
	int v5; // [esp+1Ch] [ebp-1Ch]
	int v6; // [esp+28h] [ebp-10h]
	int v7; // [esp+34h] [ebp-4h]

	//fix it
	v6 = 0;
	v7 = 0;
	//fix it

	v1 = 0;
	if ( a1 < 0xA0000 )
	{
	  v4 = (a1 + 15) >> 4;
	  v3 = 0x0100;
	  int386(49, (REGS*)&v3, (REGS*)&v5);
	  if ( !v7 )
		v1 = v5 | (v6 << 16);
	}
	return v1;*/
	//
	/*REGS r;

	memset(&r, 0, sizeof(r));
	r.eax = 0x0100;				// DPMI allocate DOS memory
	r.ebx = (size + 15) >> 4;	// Number of paragraphs requested
	int386(0x31, &r, &r);

	if (r.cflag)  // Failed
		return ((uint)0);

	if (selector != NULL)
		*selector = r.edx & 0xFFFF;

	return (void *)((r.eax & 0xFFFF) << 4);*/

	if (size < 0xA0000)
		return malloc(size * 16 * sizeof(Bit8u));
	else
		return 0;
	/*
	100
	1000
	35513C
	168 --selector

	1C02 --base adress
	1000 --size
	35513C
	1F0 - selector


	*/
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);

//----- (000856D0) --------------------------------------------------------
__int16 sub_856D0(int a1, int a2, __int16 a3, int a4)
{
	unsigned __int8 v4; // dl
	unsigned __int8 v5; // dh
	__int16 v6; // di
	__int16 v7; // si
	int v8; // eax
	int v9; // ecx
	unsigned __int8 v10; // cl
	x_BYTE *v11; // edx
	__int16 v12; // si
	char v13; // cl
	int v14; // edi
	int v15; // esi
	x_BYTE *v16; // eax
	char v17; // ch
	bool v18; // zf
	int v19; // edx
	char v20; // cl
	char v21; // cl
	unsigned __int8 v22; // cl
	int v23; // edi
	int v24; // eax
	x_BYTE *v25; // eax
	char v26; // ch
	unsigned __int8 v27; // ch
	int v29; // [esp+0h] [ebp-38h]
	int v30; // [esp+8h] [ebp-30h]
	int v31; // [esp+Ch] [ebp-2Ch]
	int v32; // [esp+10h] [ebp-28h]
	int v33; // [esp+14h] [ebp-24h]
	int v34; // [esp+1Ch] [ebp-1Ch]
	__int16 v35; // [esp+24h] [ebp-14h]
	unsigned __int8 v36; // [esp+28h] [ebp-10h]
	unsigned __int8 v37; // [esp+2Ch] [ebp-Ch]
	unsigned __int8 v38; // [esp+30h] [ebp-8h]

	v4 = *(x_BYTE *)(a4 + 4);
	v5 = *(x_BYTE *)(a4 + 5);
	v6 = x_DWORD_17FEC0 + a2;
	v7 = x_DWORD_17FEC8 + a3;
	v8 = -a2;
	if ((-(signed __int16)a2 & 0x8000u) != 0 || (x_WORD)a2 == 0)
	{
		v36 = 0;
	}
	else
	{
		if ((signed __int16)v8 >= v4)
			return v8;
		v36 = -(char)a2;
	}
	v9 = v4;
	LOWORD(v8) = v4 + v6 - x_DWORD_17FEC4;
	if ((signed __int16)v8 > 0)
	{
		if ((signed __int16)v8 >= v4)
			return v8;
		v4 = x_DWORD_17FEC4 - v6;
	}
	LOWORD(v8) = -a3;
	if (a3 >= 0)
	{
		v10 = 0;
	}
	else
	{
		v9 = v5;
		if ((signed __int16)v8 >= v5)
			return v8;
		v10 = -(char)a3;
	}
	LOWORD(v8) = v7 + v5 - x_DWORD_17FECC;
	if ((signed __int16)v8 > 0)
	{
		if ((signed __int16)v8 >= v5)
			return v8;
		v5 = x_DWORD_17FECC - v7;
	}
	v37 = v4 - v36;
	BYTE1(v9) = v5 - v10;
	v8 = *(x_DWORD *)a4;
	v35 = x_DWORD_18062C_resolution_x;
	v11 = (x_BYTE *)(x_DWORD_18062C_resolution_x * (v7 + (unsigned __int8)v9) + x_DWORD_180628b_screen_buffer + v6 + v36);
	if ((x_BYTE)v9)
	{
		v12 = v10;
		do
		{
			while (*(x_BYTE *)v8 > 0)
				v8 += *(char *)v8 + 1;
			v13 = *(x_BYTE *)v8++;
		} while (v13 || --v12);
	}
	v14 = (signed __int16)x_DWORD_18062C_resolution_x;
	v15 = (int)&v11[(signed __int16)x_DWORD_18062C_resolution_x];
	v29 = (int)&v11[(signed __int16)x_DWORD_18062C_resolution_x];
	LOWORD(v15) = v37;
	LOWORD(v9) = BYTE1(v9);
	v34 = v9;
	if (v36)
	{
	LABEL_68:
		if (!v36)
			goto LABEL_22;
		v38 = v36;
		while (1)
		{
			while (1)
			{
				v21 = *(x_BYTE *)v8;
				if (*(x_BYTE *)v8 > 0)
					break;
				if (!*(x_BYTE *)v8)
				{
					v15 = 0;
					goto LABEL_22;
				}
				v14 = v21;
				v9 = -v38;
				if (v14 < v9)
				{
					LOBYTE(v9) = -*(x_BYTE *)v8 - v38;
					if ((unsigned __int8)v9 > v37)
						LOBYTE(v9) = v37;
					v14 = (unsigned __int8)v9;
					++v8;
					v11 += (unsigned __int8)v9;
					BYTE1(v9) = 0;
					v15 -= v9;
					goto LABEL_22;
				}
				v27 = *(x_BYTE *)v8++ + v38;
				v38 = v27;
				if (!v27)
					goto LABEL_22;
			}
			v14 = v21;
			v9 = v38;
			if (v38 < v14)
				break;
			v38 -= *(x_BYTE *)v8;
			v9 = v14 + 1;
			v8 += v14 + 1;
			if (!v38)
				goto LABEL_22;
		}
		v22 = *(x_BYTE *)v8 - v38;
		if (v22 > v37)
			v22 = v37;
		v31 = (int)&v11[v22];
		v23 = *(char *)v8;
		v24 = v8 + 1;
		v33 = v24 + v23;
		v25 = (x_BYTE *)(v38 + v24);
		v15 -= v22;
		v14 = *(x_WORD *)(a1 + 4) & 0xC000;
		if ((unsigned __int16)v14 >= 0x4000u)
		{
			if ((unsigned __int16)v14 > 0x4000u)
			{
				if ((x_WORD)v14 != -32768)
					goto LABEL_105;
				while (1)
				{
					if (*v25 >= 1u)
					{
						if (*v25 > 1u)
						{
							if (*v25 != 2)
								goto LABEL_104;
						LABEL_103:
							v18 = (*(x_BYTE *)(a1 + 4) & 2) == 0;
							goto LABEL_104;
						}
						if (!(*(x_BYTE *)(a1 + 4) & 1))
							goto LABEL_103;
					}
				LABEL_104:
					++v25;
					++v11;
					if (!--v22)
						goto LABEL_105;
				}
			}
			while (1)
			{
				if (*v25 >= 1u)
				{
					if (*v25 > 1u)
					{
						if (*v25 != 2)
							goto LABEL_96;
					LABEL_95:
						v18 = (*(x_BYTE *)(a1 + 4) & 2) == 0;
						goto LABEL_96;
					}
					if (!(*(x_BYTE *)(a1 + 4) & 1))
						goto LABEL_95;
				}
			LABEL_96:
				++v25;
				++v11;
				if (!--v22)
				{
					v8 = v33;
					v11 = (x_BYTE *)v31;
					goto LABEL_22;
				}
			}
		}
		if ((x_WORD)v14)
		{
		LABEL_105:
			v8 = v33;
			v11 = (x_BYTE *)v31;
			goto LABEL_22;
		}
		while (1)
		{
			if (*v25 >= 1u)
			{
				if (*v25 > 1u)
				{
					if (*v25 != 2 || !(*(x_BYTE *)(a1 + 4) & 2))
						goto LABEL_88;
					v26 = *(x_BYTE *)(a1 + 7);
					goto LABEL_87;
				}
				if (*(x_BYTE *)(a1 + 4) & 1)
				{
					v26 = *(x_BYTE *)(a1 + 6);
				LABEL_87:
					*v11 = v26;
					goto LABEL_88;
				}
			}
		LABEL_88:
			++v25;
			++v11;
			if (!--v22)
				goto LABEL_105;
		}
	}
LABEL_22:
	while (2)
	{
		while (2)
		{
			if ((signed __int16)v15 <= 0)
			{
				HIWORD(v15) = HIWORD(v34);
				LOWORD(v15) = v34 - 1;
				v18 = (x_WORD)v34 == 1;
				v34 = v15;
				if (v18)
					return v8;
				do
				{
					while (*(x_BYTE *)v8 > 0)
						v8 += *(char *)v8 + 1;
					v20 = *(x_BYTE *)v8++;
				} while (v20);
				v11 = (x_BYTE *)v29;
				v9 = v35;
				v14 = v29 + v35;
				LOWORD(v15) = v37;
				v29 += v35;
				goto LABEL_68;
			}
			LOBYTE(v9) = *(x_BYTE *)v8;
			if (*(x_BYTE *)v8 > 0)
			{
				if ((char)v9 >= (signed __int16)v15)
					v9 = (signed __int16)v15;
				else
					v9 = *(char *)v8;
				LOWORD(v14) = *(char *)v8;
				v15 -= v14;
				v32 = (int)&v11[(unsigned __int8)v9];
				v30 = *(char *)v8 + v8 + 1;
				v14 = *(x_WORD *)(a1 + 4) & 0xC000;
				v16 = (x_BYTE *)(v8 + 1);
				if ((unsigned __int16)v14 >= 0x4000u)
				{
					if ((unsigned __int16)v14 > 0x4000u)
					{
						if ((x_WORD)v14 != -32768)
							goto LABEL_58;
						while (1)
						{
							if (*v16 >= 1u)
							{
								if (*v16 > 1u)
								{
									if (*v16 != 2)
										goto LABEL_57;
								LABEL_56:
									v18 = (*(x_BYTE *)(a1 + 4) & 2) == 0;
									goto LABEL_57;
								}
								if (!(*(x_BYTE *)(a1 + 4) & 1))
									goto LABEL_56;
							}
						LABEL_57:
							++v16;
							++v11;
							LOBYTE(v9) = v9 - 1;
							if (!(x_BYTE)v9)
								goto LABEL_58;
						}
					}
					while (1)
					{
						if (*v16 >= 1u)
						{
							if (*v16 > 1u)
							{
								if (*v16 != 2)
									goto LABEL_49;
							LABEL_48:
								v18 = (*(x_BYTE *)(a1 + 4) & 2) == 0;
								goto LABEL_49;
							}
							if (!(*(x_BYTE *)(a1 + 4) & 1))
								goto LABEL_48;
						}
					LABEL_49:
						++v16;
						++v11;
						LOBYTE(v9) = v9 - 1;
						if (!(x_BYTE)v9)
						{
							v11 = (x_BYTE *)v32;
							v8 = v30;
							goto LABEL_22;
						}
					}
				}
				if ((x_WORD)v14)
				{
				LABEL_58:
					v11 = (x_BYTE *)v32;
					v8 = v30;
					continue;
				}
				while (1)
				{
					if (*v16 >= 1u)
					{
						if (*v16 > 1u)
						{
							if (*v16 != 2 || !(*(x_BYTE *)(a1 + 4) & 2))
								goto LABEL_41;
							v17 = *(x_BYTE *)(a1 + 7);
							goto LABEL_40;
						}
						if (*(x_BYTE *)(a1 + 4) & 1)
						{
							v17 = *(x_BYTE *)(a1 + 6);
						LABEL_40:
							*v11 = v17;
							goto LABEL_41;
						}
					}
				LABEL_41:
					++v16;
					++v11;
					LOBYTE(v9) = v9 - 1;
					if (!(x_BYTE)v9)
						goto LABEL_58;
				}
			}
			break;
		}
		if (*(x_BYTE *)v8 < 0)
		{
			LOWORD(v9) = (char)v9;
			v15 += v9;
			v9 = *(char *)v8++;
			v11 -= v9;
			continue;
		}
		break;
	}
	HIWORD(v19) = HIWORD(v34);
	LOWORD(v19) = v34 - 1;
	v18 = (x_WORD)v34 == 1;
	v34 = v19;
	if (!v18)
	{
		v11 = (x_BYTE *)v29;
		v9 = v35;
		v15 = v29 + v35;
		++v8;
		v29 += v35;
		LOWORD(v15) = v37;
		goto LABEL_68;
	}
	return v8;
}
// 17FEC0: using guessed type int x_DWORD_17FEC0;
// 17FEC4: using guessed type int x_DWORD_17FEC4;
// 17FEC8: using guessed type int x_DWORD_17FEC8;
// 17FECC: using guessed type int x_DWORD_17FECC;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 18062C: using guessed type int x_DWORD_18062C_resolution_x;

//----- (00085AF0) --------------------------------------------------------
unsigned int *sub_85AF0(int a1)
{
	unsigned int *result; // eax
	unsigned int v2; // ecx

	result = *(unsigned int **)a1;
	if (*(x_DWORD *)a1 < *(x_DWORD *)(a1 + 4))
	{
		do
		{
			v2 = *(x_DWORD *)(a1 + 8);
			if (*result < v2)
				*result += v2;
			result = (unsigned int *)((char *)result + 6);
		} while ((unsigned int)result < *(x_DWORD *)(a1 + 4));
	}
	return result;
}

//----- (00085B20) --------------------------------------------------------
int sub_85B20(x_BYTE *a1, x_WORD *a2, unsigned __int16 a3)
{
	x_BYTE *v3; // esi
	x_WORD *v4; // edi
	int result; // eax
	__int16 v6; // bx
	signed __int16 v7; // cx
	__int16 v8; // ax
	x_BYTE *v9; // esi
	x_WORD *v10; // edi
	signed __int16 v11; // cx
	__int16 v12; // ax
	x_BYTE *v13; // esi
	x_WORD *v14; // edi
	signed int v15; // ecx
	x_BYTE *v16; // [esp-14h] [ebp-1Ch]
	int v17; // [esp+4h] [ebp-4h]

	//fix it
	v17 = 0;
	//fix it

	v3 = a1;
	v4 = a2;
	if (x_WORD_180660_VGA_type_resolution & 1)
	{
		sub_9A128_copy_screen_320(a1, a2, 0xC8u);
		result = v17;
	}
	else
	{
		v6 = a3 >> 1;
		do
		{
			v16 = v3;
			v7 = 40;
			do
			{
				LOBYTE(v8) = *v3;
				v9 = v3 + 1;
				HIBYTE(v8) = v8;
				*v4 = v8;
				v10 = v4 + 1;
				LOBYTE(v8) = *v9++;
				HIBYTE(v8) = v8;
				*v10 = v8;
				++v10;
				LOBYTE(v8) = *v9++;
				HIBYTE(v8) = v8;
				*v10 = v8;
				++v10;
				LOBYTE(v8) = *v9++;
				HIBYTE(v8) = v8;
				*v10 = v8;
				++v10;
				LOBYTE(v8) = *v9++;
				HIBYTE(v8) = v8;
				*v10 = v8;
				++v10;
				LOBYTE(v8) = *v9++;
				HIBYTE(v8) = v8;
				*v10 = v8;
				++v10;
				LOBYTE(v8) = *v9++;
				HIBYTE(v8) = v8;
				*v10 = v8;
				++v10;
				LOBYTE(v8) = *v9;
				v3 = v9 + 1;
				HIBYTE(v8) = v8;
				*v10 = v8;
				v4 = v10 + 1;
				--v7;
			} while (v7);
			v3 = v16;
			v11 = 40;
			do
			{
				LOBYTE(v12) = *v3;
				v13 = v3 + 1;
				HIBYTE(v12) = v12;
				*v4 = v12;
				v14 = v4 + 1;
				LOBYTE(v12) = *v13++;
				HIBYTE(v12) = v12;
				*v14 = v12;
				++v14;
				LOBYTE(v12) = *v13++;
				HIBYTE(v12) = v12;
				*v14 = v12;
				++v14;
				LOBYTE(v12) = *v13++;
				HIBYTE(v12) = v12;
				*v14 = v12;
				++v14;
				LOBYTE(v12) = *v13++;
				HIBYTE(v12) = v12;
				*v14 = v12;
				++v14;
				LOBYTE(v12) = *v13++;
				HIBYTE(v12) = v12;
				*v14 = v12;
				++v14;
				LOBYTE(v12) = *v13++;
				HIBYTE(v12) = v12;
				*v14 = v12;
				++v14;
				LOBYTE(v12) = *v13;
				v3 = v13 + 1;
				HIBYTE(v12) = v12;
				*v14 = v12;
				v4 = v14 + 1;
				--v11;
			} while (v11);
			--v6;
		} while (v6);
		if (a2 != (x_WORD *)&loc_A0000_vga_buffer && a3 >= 0x190u)
		{
			v15 = 12800;
			do
			{
				*(x_DWORD *)v4 = 0;
				v4 += 2;
				--v15;
			} while (v15);
		}
		result = v17;
	}
	return result;
}
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00085BF5) --------------------------------------------------------
int sub_85BF5(x_BYTE *a1, int a2, int a3, int a4, int a5, int a6)
{
	x_BYTE *v6; // esi
	x_BYTE *v7; // edi
	int v8; // edx
	int v9; // ecx
	int v11; // [esp+4h] [ebp-4h]

	//fix it
	v11 = 0;
	//fix it

	v6 = a1;
	v7 = (x_BYTE *)(a3 + 640 * a4 + a2);
	v8 = a6;
	do
	{
		v9 = a5;
		do
		{
			if (*v6 && *v6 != -1)
			{
				*v7++ = *v6++;
			}
			else
			{
				++v6;
				++v7;
			}
			--v9;
		} while (v9);
		v7 = &v7[-a5 + 640];
		--v8;
	} while (v8);
	return v11;
}

//----- (00085C42) --------------------------------------------------------
int sub_85C42(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6)
{
	unsigned __int8 *v6; // edi
	int v7; // edx
	int v8; // ecx
	int v10; // [esp+4h] [ebp-4h]

	//fix it
	v10 = 0;
	//fix it

	v6 = (unsigned __int8 *)(a2 + 640 * a3 + a1);
	v7 = a5;
	do
	{
		v8 = a4;
		do
		{
			if (*v6 >= a6)
				*v6 = 0;
			++v6;
			--v8;
		} while (v8);
		v6 = &v6[-a4 + 640];
		--v7;
	} while (v7);
	return v10;
}

//----- (00085C8B) --------------------------------------------------------
void sub_85C8B_draw_new_game_map_background(Bit8u* a1, Bit8u* a2, int a3, int a4, int a5, int a6)
{
	int v6; // edx
	char *v7; // edi
	char *v8; // esi

	v6 = a6;
	v7 = (char*)a2;
	v8 = (char *)(a3 + 1280 * a4 + a1);
	do
	{
		qmemcpy(v7, v8, 4 * a5);
		v7 += 4 * a5;
		v8 += 4 * a5 + 640;
		--v6;
	} while (v6);
}

//----- (00085CC3) --------------------------------------------------------
void sub_85CC3_draw_round_frame(Bit16u* buffer)
{
	Bit16u* v3; // esi
	Bit8u* v4; // edi
	Bit16s v5; // edx
	unsigned __int16 *v6; // ST04_4
	Bit16s v7; // ST02_2
	Bit8u* v8; // esi
	char v9; // al
	Bit8u* v10; // edx
	unsigned int v11; // ecx
	Bit8u* v12; // edi
	Bit8u* v13; // ebx
	char v14; // al
	int v15; // [esp-1Eh] [ebp-2Eh]
	Bit16s v16; // [esp-1Ah] [ebp-2Ah]
	Bit8u* v17; // [esp+0h] [ebp-10h]
	Bit8u* v18; // [esp+4h] [ebp-Ch]
	Bit8u* v19; // [esp+8h] [ebp-8h]
	int v20; // [esp+Ch] [ebp-4h]

	//fix it
	Bit16s a1 = 0;
	int a2 = 0;
	//fix it

	v3 = buffer;
	v4 = x_DWORD_180628b_screen_buffer;
	v19 = x_DWORD_180628b_screen_buffer + 306560;
	v17 = x_DWORD_180628b_screen_buffer + 640;
	v18 = x_DWORD_180628b_screen_buffer + 307200;
	v20 = 0;
	a2 = 240;
	do
	{
		while (1)
		{
			while (1)
			{
				v5 = *v3;
				v3++;
				if (v5 <= 0)
					break;
				a1 = v5;
				qmemcpy(v4, v3, v5);
				v10 = &v4[v5];
				qmemcpy(v19, v3, a1);
				v19 += a1;
				v16 = a1;
				v15 = a2;
				v11 = a1;
				v12 = v17;
				v13 = v18;
				do
				{
					v14 = *(Bit8u*)v3;
					*v12 = *(Bit8u*)v3;
					*v13 = v14;
					v3 = (Bit16u*)((Bit8u*)v3 + 1);
					v12--;
					v13--;
					v11--;
				} while (v11);
				v17 = v12;
				v18 = v13;
				v4 = v10;
				a2 = v15;
				a1 = v16;
			}
			if ((v5 & 0x8000u) == 0 && !v5)
				break;
			v5 = -v5;
			v4 += v5;
			v20 += a1 + v5;
			v19 += v5;
			v17 -= v5;
			v18 -= v5;
		}
		if (a2 > 221)
		{
			v6 = v3;
			v7 = a1;
			v8 = (Bit8u*)v3 - 3;
			v9 = *v8;
			*v4 = *v8;
			*v19 = v9;
			a1 = v7;
			v3 = v6;
		}
		v4 = &v4[0 - a1 + 640 - v20];
		v19 = &v19[0 - a1 - 640 - v20];
		v17 += v20 + a1 + 640;
		v18 = v20 + a1 + v18 - 640;
		v20 = 0;
		a2 = a2 - 1;
	} while (a2);
}
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;

//----- (00085E40) --------------------------------------------------------
int sub_85E40()
{
	/*signed __int16 result; // ax

	if ( x_WORD_E2A24 )
	  return 1;
	x_DWORD_17FF10 = 4096;//ax
	x_DWORD_17FF0C = 256;//bx - size
	int386(49, (REGS*)&x_DWORD_17FF0C, (REGS*)&x_DWORD_17FF0C);
	x_WORD_E2A24 = x_DWORD_17FF0C;//2B3A24 AA0
	x_WORD_17FF5A = x_WORD_17FF18;//350F5A 1C8
	LOBYTE(result) = x_DWORD_17FF24 == 0;//desriptor
	HIBYTE(result) = 0;
	return result;*/
	int size = 0x1000;
	if (x_WORD_E2A24)//==0
		return 1;
	x_WORD_E2A24 = (Bit8u*)malloc(size * 16 * sizeof(Bit8u));
	return size & 0xff;
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// E2A24: using guessed type __int16 x_WORD_E2A24;
// 17FF0C: using guessed type int x_DWORD_17FF0C;
// 17FF10: using guessed type int x_DWORD_17FF10;
// 17FF18: using guessed type __int16 x_WORD_17FF18;
// 17FF24: using guessed type int x_DWORD_17FF24;
// 17FF5A: using guessed type __int16 x_WORD_17FF5A;

//----- (00085EB0) --------------------------------------------------------
int sub_85EB0_alloc_memory(int32 a1)//malloc
{
	/*__int16 result; // ax

	LOWORD(x_DWORD_17FF10) = a1;
	LOWORD(x_DWORD_17FF0C) = 256;
	int386(49, (REGS*)&x_DWORD_17FF0C, (REGS*)&x_DWORD_17FF0C);
	if ( x_DWORD_17FF24 )
	  result = 0;
	else
	  result = x_DWORD_17FF0C;
	return result;*/
	x_DWORD_17FF0C = (int)malloc(a1 * 16 * sizeof(Bit8u));
	//if (x_DWORD_17FF0C > 0)return a1;
	return x_DWORD_17FF0C;
	//return (Bit8u*)malloc(a1*sizeof(Bit8u));
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// 17FF0C: using guessed type int x_DWORD_17FF0C;
// 17FF10: using guessed type int x_DWORD_17FF10;
// 17FF24: using guessed type int x_DWORD_17FF24;

//----- (00085F00) --------------------------------------------------------
__int16 sub_85F00_free_memory(__int16 a1)
{
	/*__int16 result; // ax

	x_WORD_17FF18 = a1;
	LOWORD(x_DWORD_17FF0C) = 0x100;
	int386(49, (REGS*)&x_DWORD_17FF0C, (REGS*)&x_DWORD_17FF0C);
	if ( x_DWORD_17FF24 )
	  myprintf("fdm:error freeing %lx\n");
	LOBYTE(result) = x_DWORD_17FF24 == 0;
	HIBYTE(result) = 0;
	return result;*/

	//__int16 result; // ax
	free((void*)x_DWORD_17FF24);
	if (x_DWORD_17FF24)
	{
		myprintf("fdm:error freeing %lx\n");
		return 1;
	}
	return 0;
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// 17FF0C: using guessed type int x_DWORD_17FF0C;
// 17FF18: using guessed type __int16 x_WORD_17FF18;
// 17FF24: using guessed type int x_DWORD_17FF24;

//----- (00085F60) --------------------------------------------------------
int sub_85F60(int a1)
{
	return 75 * BYTE1(a1) + 4500 * BYTE2(a1) + (unsigned __int8)a1;
}

//----- (00085FD0) --------------------------------------------------------
bool sub_85FD0()
{
	//int v0; // ax
	// 2B3A6C - D5020000A11A0000
	//x_DWORD_E2A6C
	x_DWORD_E2A6C = sub_85EB0_alloc_memory(0x2);
	x_DWORD_E2A70 = sub_85EB0_alloc_memory(0x100);
	return x_DWORD_E2A6C && x_DWORD_E2A70;
}
// E2A6C: using guessed type int x_DWORD_E2A6C;
// E2A70: using guessed type int x_DWORD_E2A70;

//----- (00086010) --------------------------------------------------------
int sub_86010()
{
	x_DWORD_17FF38 = 0;//nemeni se
	x_DWORD_17FF44 = 0x1500;//nemeni se
	x_DWORD_17FF0C = 0x300;//nemeni se
	x_DWORD_17FF10 = 0x2f;//nemeni se
	x_DWORD_17FF14 = 0;//nemeni se
	x_DWORD_17FF20 = (int)&unk_17FF28;//350f28 //nemeni se
	/*
	int386(49, (REGS*)&x_DWORD_17FF0C, (REGS*)&x_DWORD_17FF0C);
	*/
	if (x_DWORD_17FF10 == 0)x_DWORD_17FF38 = 0;

	x_WORD_1803EA = x_DWORD_17FF38;//0
	x_WORD_1803EC = x_DWORD_17FF40;//0
	return x_DWORD_17FF38;
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// 17FF0C: using guessed type int x_DWORD_17FF0C;
// 17FF10: using guessed type int x_DWORD_17FF10;
// 17FF14: using guessed type int x_DWORD_17FF14;
// 17FF20: using guessed type int x_DWORD_17FF20;
// 17FF38: using guessed type int x_DWORD_17FF38;
// 17FF40: using guessed type int x_DWORD_17FF40;
// 17FF44: using guessed type int x_DWORD_17FF44;
// 1803EA: using guessed type __int16 x_WORD_1803EA;
// 1803EC: using guessed type __int16 x_WORD_1803EC;

//----- (00086180) --------------------------------------------------------
__int16 sub_86180(unsigned __int16 a1)
{
	int v1; // ecx
	__int16 result; // ax
	char *v3; // esi
	int v4; // ebx
	__int16 v5; // ax

	if (!x_DWORD_E2A6C)
		return 0;
	v1 = x_DWORD_E2A70;
	if (!x_DWORD_E2A70)
		return 0;
	v3 = (char *)(16 * x_DWORD_E2A6C);
	*v3 = 26;
	v3[1] = 0;
	v3[2] = 3;
	*(x_WORD *)(v3 + 3) = 0;
	v3[13] = 0;
	*((x_WORD *)v3 + 9) = 5;
	*((x_WORD *)v3 + 10) = 0;
	*(x_DWORD *)(v3 + 22) = 0;
	v4 = 16 * v1;
	*(x_DWORD *)(v3 + 14) = v1 << 16;
	v5 = x_DWORD_E2A6C;
	*(x_BYTE *)(16 * v1) = 6;
	x_WORD_17FF4A = v5;
	x_DWORD_17FF38 = 0;
	x_DWORD_17FF10 = 47;
	x_DWORD_17FF14 = 0;
	x_DWORD_17FF40 = a1;
	x_DWORD_17FF44 = 0x1510;
	x_DWORD_17FF0C = 0x300;
	x_DWORD_17FF20 = (int)&unk_17FF28;
	int386(0x31, (REGS*)&x_DWORD_17FF0C, (REGS*)&x_DWORD_17FF0C);//return display params
	qmemcpy(&unk_1803C0, v3, 0x1Au);
	result = x_WORD_1803C3;
	unk_180498 = *(x_DWORD *)v4;
	*((x_BYTE *)&unk_180498 + 4) = *(x_BYTE *)(v4 + 4);
	return result;
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// E2A6C: using guessed type int x_DWORD_E2A6C;
// E2A70: using guessed type int x_DWORD_E2A70;
// 17FF0C: using guessed type int x_DWORD_17FF0C;
// 17FF10: using guessed type int x_DWORD_17FF10;
// 17FF14: using guessed type int x_DWORD_17FF14;
// 17FF20: using guessed type int x_DWORD_17FF20;
// 17FF38: using guessed type int x_DWORD_17FF38;
// 17FF40: using guessed type int x_DWORD_17FF40;
// 17FF44: using guessed type int x_DWORD_17FF44;
// 17FF4A: using guessed type __int16 x_WORD_17FF4A;
// 1803C3: using guessed type __int16 x_WORD_1803C3;

//----- (00086270) --------------------------------------------------------
__int16 sub_86270(unsigned __int16 a1)
{
	int v1; // ecx
	__int16 result; // ax
	char *v3; // esi
	int v4; // ebx

	if (!x_DWORD_E2A6C)
		return 0;
	v1 = x_DWORD_E2A70;
	if (!x_DWORD_E2A70)
		return 0;
	v3 = (char *)(16 * x_DWORD_E2A6C);
	*v3 = 26;
	v3[1] = 0;
	v3[2] = 3;
	*(x_WORD *)(v3 + 3) = 0;
	v3[13] = 0;
	*((x_WORD *)v3 + 9) = 7;
	*((x_WORD *)v3 + 10) = 0;
	*(x_DWORD *)(v3 + 22) = 0;
	v4 = 16 * v1;
	*(x_DWORD *)(v3 + 14) = v1 << 16;
	*(x_BYTE *)(16 * v1) = 10;
	x_WORD_17FF58 = 0;
	x_WORD_17FF56 = 0;
	x_WORD_17FF4A = x_DWORD_E2A6C;
	x_DWORD_17FF38 = 0;
	x_DWORD_17FF14 = 0;
	x_DWORD_17FF10 = 47;
	x_DWORD_17FF40 = a1;
	x_DWORD_17FF44 = 0x1510;
	x_DWORD_17FF0C = 0x300;
	x_DWORD_17FF20 = (int)&unk_17FF28;
	int386(0x31, (REGS*)&x_DWORD_17FF0C, (REGS*)&x_DWORD_17FF0C);//Return Physical Display Parms
	qmemcpy(&unk_1803C0, v3, 0x1Au);
	result = x_WORD_1803C3;
	unk_180470 = *(x_DWORD *)v4;
	*((x_WORD *)&unk_180470 + 2) = *(x_WORD *)(v4 + 4);
	*((x_BYTE *)&unk_180470 + 6) = *(x_BYTE *)(v4 + 6);
	return result;
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// E2A6C: using guessed type int x_DWORD_E2A6C;
// E2A70: using guessed type int x_DWORD_E2A70;
// 17FF0C: using guessed type int x_DWORD_17FF0C;
// 17FF10: using guessed type int x_DWORD_17FF10;
// 17FF14: using guessed type int x_DWORD_17FF14;
// 17FF20: using guessed type int x_DWORD_17FF20;
// 17FF38: using guessed type int x_DWORD_17FF38;
// 17FF40: using guessed type int x_DWORD_17FF40;
// 17FF44: using guessed type int x_DWORD_17FF44;
// 17FF4A: using guessed type __int16 x_WORD_17FF4A;
// 17FF56: using guessed type __int16 x_WORD_17FF56;
// 17FF58: using guessed type __int16 x_WORD_17FF58;
// 1803C3: using guessed type __int16 x_WORD_1803C3;

//----- (00086370) --------------------------------------------------------
__int16 sub_86370(unsigned __int16 a1, char a2)
{
	int v2; // ecx
	__int16 result; // ax
	char *v4; // esi
	int v5; // ebx

	if (!x_DWORD_E2A6C)
		return 0;
	v2 = x_DWORD_E2A70;
	if (!x_DWORD_E2A70)
		return 0;
	v4 = (char *)(16 * x_DWORD_E2A6C);
	*v4 = 26;
	v4[1] = 0;
	v4[2] = 3;
	*(x_WORD *)(v4 + 3) = 0;
	v4[13] = 0;
	*((x_WORD *)v4 + 9) = 7;
	*((x_WORD *)v4 + 10) = 0;
	*(x_DWORD *)(v4 + 22) = 0;
	v5 = 16 * v2;
	*(x_DWORD *)(v4 + 14) = v2 << 16;
	*(x_BYTE *)v5 = 11;
	*(x_BYTE *)(v5 + 1) = a2;
	x_DWORD_17FF38 = 0;
	x_DWORD_17FF10 = 47;
	x_WORD_17FF4A = x_DWORD_E2A6C;
	x_DWORD_17FF14 = 0;
	x_DWORD_17FF40 = a1;
	x_DWORD_17FF44 = 0x1510;
	x_DWORD_17FF0C = 0x300;
	x_DWORD_17FF20 = (int)&unk_17FF28;
	int386(0x31, (REGS*)&x_DWORD_17FF0C, (REGS*)&x_DWORD_17FF0C);//joystick, nebo grafika
	qmemcpy(&unk_1803C0, v4, 0x1Au);
	result = x_WORD_1803C3;
	unk_180484 = *(x_DWORD *)v5;
	*((x_WORD *)&unk_180484 + 2) = *(x_WORD *)(v5 + 4);
	*((x_BYTE *)&unk_180484 + 6) = *(x_BYTE *)(v5 + 6);
	return result;
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// E2A6C: using guessed type int x_DWORD_E2A6C;
// E2A70: using guessed type int x_DWORD_E2A70;
// 17FF0C: using guessed type int x_DWORD_17FF0C;
// 17FF10: using guessed type int x_DWORD_17FF10;
// 17FF14: using guessed type int x_DWORD_17FF14;
// 17FF20: using guessed type int x_DWORD_17FF20;
// 17FF38: using guessed type int x_DWORD_17FF38;
// 17FF40: using guessed type int x_DWORD_17FF40;
// 17FF44: using guessed type int x_DWORD_17FF44;
// 17FF4A: using guessed type __int16 x_WORD_17FF4A;
// 1803C3: using guessed type __int16 x_WORD_1803C3;

//----- (00086460) --------------------------------------------------------
void sub_86460(Bit16u a1)
{
	int v1; // ecx
	//__int16 result; // ax
	char *v3; // esi
	int v4; // ebx
	__int16 v5; // ax

	if (!x_DWORD_E2A6C)
		return;
	v1 = x_DWORD_E2A70;
	if (!x_DWORD_E2A70)
		return;
	v3 = (char *)(16 * x_DWORD_E2A6C);
	*v3 = 26;
	v3[1] = 0;
	v3[2] = 3;
	*(x_WORD *)(v3 + 3) = 0;
	v3[13] = 0;
	*((x_WORD *)v3 + 9) = 11;
	*((x_WORD *)v3 + 10) = 0;
	*(x_DWORD *)(v3 + 22) = 0;
	v4 = 16 * v1;
	*(x_DWORD *)(v3 + 14) = v1 << 16;
	v5 = x_DWORD_E2A6C;
	*(x_BYTE *)(16 * v1) = 12;
	x_WORD_17FF4A = v5;
	x_DWORD_17FF38 = 0;
	x_DWORD_17FF10 = 47;
	x_DWORD_17FF14 = 0;
	x_DWORD_17FF40 = a1;
	x_DWORD_17FF44 = 0x1510;
	x_DWORD_17FF0C = 0x300;
	x_DWORD_17FF20 = (int)&unk_17FF28;
	int386(0x31, (REGS*)&x_DWORD_17FF0C, (REGS*)&x_DWORD_17FF0C);//joystick nebo grafika
	qmemcpy(&unk_1803C0, v3, 0x1Au);
	//result = x_WORD_1803C3;
	unk_18048B = *(x_DWORD *)v4;
	*((x_DWORD *)&unk_18048B + 1) = *(x_DWORD *)(v4 + 4);
	*((x_WORD *)&unk_18048B + 4) = *(x_WORD *)(v4 + 8);
	*((x_BYTE *)&unk_18048B + 10) = *(x_BYTE *)(v4 + 10);
	//return result;
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// E2A6C: using guessed type int x_DWORD_E2A6C;
// E2A70: using guessed type int x_DWORD_E2A70;
// 17FF0C: using guessed type int x_DWORD_17FF0C;
// 17FF10: using guessed type int x_DWORD_17FF10;
// 17FF14: using guessed type int x_DWORD_17FF14;
// 17FF20: using guessed type int x_DWORD_17FF20;
// 17FF38: using guessed type int x_DWORD_17FF38;
// 17FF40: using guessed type int x_DWORD_17FF40;
// 17FF44: using guessed type int x_DWORD_17FF44;
// 17FF4A: using guessed type __int16 x_WORD_17FF4A;
// 1803C3: using guessed type __int16 x_WORD_1803C3;

//----- (00086550) --------------------------------------------------------
int sub_86550()
{
	/*x_DWORD_17FF38 = 0;
	x_DWORD_17FF44 = 5388;
	x_DWORD_17FF0C = 768;
	x_DWORD_17FF10 = 47;
	x_DWORD_17FF14 = 0;
	x_DWORD_17FF20 = (int)&unk_17FF28;
	int386(49, (REGS*)&x_DWORD_17FF0C, (REGS*)&x_DWORD_17FF0C);
	return x_DWORD_17FF38;*/
	return (int)malloc(768 * sizeof(Bit8u));
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// 17FF0C: using guessed type int x_DWORD_17FF0C;
// 17FF10: using guessed type int x_DWORD_17FF10;
// 17FF14: using guessed type int x_DWORD_17FF14;
// 17FF20: using guessed type int x_DWORD_17FF20;
// 17FF38: using guessed type int x_DWORD_17FF38;
// 17FF44: using guessed type int x_DWORD_17FF44;

//----- (00086780) --------------------------------------------------------
char sub_86780(unsigned __int16 a1, int a2, int a3)
{
	char *v4; // esi

	if (!x_BYTE_E2A28)
		return 0;
	if (!x_DWORD_E2A6C || !x_DWORD_E2A70)
		return 0;
	v4 = (char *)(16 * x_DWORD_E2A70);
	*v4 = 22;
	v4[1] = 0;
	v4[2] = -124;
	*(x_WORD *)(v4 + 3) = 0;
	v4[13] = 0;
	*(x_DWORD *)(v4 + 14) = a2;
	*(x_DWORD *)(v4 + 18) = a3;
	x_DWORD_17FF38 = 0;
	x_DWORD_17FF10 = 47;
	x_DWORD_17FF14 = 0;
	x_WORD_17FF4A = x_DWORD_E2A70;
	x_DWORD_17FF20 = (int)&unk_17FF28;
	x_DWORD_17FF40 = a1;
	x_DWORD_17FF0C = 0x300;
	x_DWORD_17FF44 = 0x1510;
	int386(0x31, (REGS*)&x_DWORD_17FF0C, (REGS*)&x_DWORD_17FF0C);//joystick nebo grafika
	qmemcpy(&unk_1803A8, v4, 0x16u);
	return x_WORD_1803AB;
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// E2A28: using guessed type char x_BYTE_E2A28;
// E2A6C: using guessed type int x_DWORD_E2A6C;
// E2A70: using guessed type int x_DWORD_E2A70;
// 17FF0C: using guessed type int x_DWORD_17FF0C;
// 17FF10: using guessed type int x_DWORD_17FF10;
// 17FF14: using guessed type int x_DWORD_17FF14;
// 17FF20: using guessed type int x_DWORD_17FF20;
// 17FF38: using guessed type int x_DWORD_17FF38;
// 17FF40: using guessed type int x_DWORD_17FF40;
// 17FF44: using guessed type int x_DWORD_17FF44;
// 17FF4A: using guessed type __int16 x_WORD_17FF4A;
// 1803AB: using guessed type __int16 x_WORD_1803AB;

//----- (00086860) --------------------------------------------------------
char sub_86860(unsigned __int16 a1)//267860
{
	int v2; // esi
	__int16 v3; // ax

	if (!x_BYTE_E2A28)
		return 0;
	if (!x_DWORD_E2A6C || !x_DWORD_E2A70)
		return 0;
	v2 = 16 * x_DWORD_E2A70;
	*(x_BYTE *)v2 = 13;
	v3 = x_DWORD_E2A70;
	*(x_BYTE *)(v2 + 1) = 0;
	*(x_BYTE *)(v2 + 2) = -123;
	*(x_WORD *)(v2 + 3) = 0;
	x_WORD_17FF4A = v3;
	x_DWORD_17FF38 = 0;
	x_DWORD_17FF10 = 47;
	x_DWORD_17FF14 = 0;
	x_DWORD_17FF20 = (int)&unk_17FF28;
	x_DWORD_17FF40 = a1;
	x_DWORD_17FF0C = 0x300;
	x_DWORD_17FF44 = 0x1510;
	int386(0x31, (REGS*)&x_DWORD_17FF0C, (REGS*)&x_DWORD_17FF0C);//Return Physical Display Parms
	unk_180452 = *(x_DWORD *)v2;
	v2 += 4;
	*((x_DWORD *)&unk_180452 + 1) = *(x_DWORD *)v2;
	v2 += 4;
	*((x_DWORD *)&unk_180452 + 2) = *(x_DWORD *)v2;
	*((x_BYTE *)&unk_180452 + 12) = *(x_BYTE *)(v2 + 4);
	return x_WORD_180455;
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// E2A28: using guessed type char x_BYTE_E2A28;
// E2A6C: using guessed type int x_DWORD_E2A6C;
// E2A70: using guessed type int x_DWORD_E2A70;
// 17FF0C: using guessed type int x_DWORD_17FF0C;
// 17FF10: using guessed type int x_DWORD_17FF10;
// 17FF14: using guessed type int x_DWORD_17FF14;
// 17FF20: using guessed type int x_DWORD_17FF20;
// 17FF38: using guessed type int x_DWORD_17FF38;
// 17FF40: using guessed type int x_DWORD_17FF40;
// 17FF44: using guessed type int x_DWORD_17FF44;
// 17FF4A: using guessed type __int16 x_WORD_17FF4A;
// 180455: using guessed type __int16 x_WORD_180455;

//----- (00086930) --------------------------------------------------------
char sub_86930(unsigned __int16 a1)
{
	int v2; // esi
	__int16 v3; // ax

	if (!x_BYTE_E2A28)
		return 0;
	if (!x_DWORD_E2A6C || !x_DWORD_E2A70)
		return 0;
	v2 = 16 * x_DWORD_E2A70;
	*(x_BYTE *)v2 = 13;
	v3 = x_DWORD_E2A70;
	*(x_BYTE *)(v2 + 1) = 0;
	*(x_BYTE *)(v2 + 2) = -120;
	*(x_WORD *)(v2 + 3) = 0;
	x_WORD_17FF4A = v3;
	x_DWORD_17FF38 = 0;
	x_DWORD_17FF10 = 47;
	x_DWORD_17FF14 = 0;
	x_DWORD_17FF20 = (int)&unk_17FF28;
	x_DWORD_17FF40 = a1;
	x_DWORD_17FF0C = 0x300;
	x_DWORD_17FF44 = 0x1510;
	int386(0x31, (REGS*)&x_DWORD_17FF0C, (REGS*)&x_DWORD_17FF0C);
	unk_180460 = *(x_DWORD *)v2;
	v2 += 4;
	*((x_DWORD *)&unk_180460 + 1) = *(x_DWORD *)v2;
	v2 += 4;
	*((x_DWORD *)&unk_180460 + 2) = *(x_DWORD *)v2;
	*((x_BYTE *)&unk_180460 + 12) = *(x_BYTE *)(v2 + 4);
	return x_WORD_180463;
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// E2A28: using guessed type char x_BYTE_E2A28;
// E2A6C: using guessed type int x_DWORD_E2A6C;
// E2A70: using guessed type int x_DWORD_E2A70;
// 17FF0C: using guessed type int x_DWORD_17FF0C;
// 17FF10: using guessed type int x_DWORD_17FF10;
// 17FF14: using guessed type int x_DWORD_17FF14;
// 17FF20: using guessed type int x_DWORD_17FF20;
// 17FF38: using guessed type int x_DWORD_17FF38;
// 17FF40: using guessed type int x_DWORD_17FF40;
// 17FF44: using guessed type int x_DWORD_17FF44;
// 17FF4A: using guessed type __int16 x_WORD_17FF4A;
// 180463: using guessed type __int16 x_WORD_180463;

//----- (00086A00) --------------------------------------------------------
void sub_86A00_some_allocs()
{
	//int result; // eax
	int v1; // ebx
	int v2x; // ebx
	unsigned __int16 v2; // bx
	int v3; // esi
	int v4; // ST04_4
	signed __int16 v5; // bx
	unsigned __int16 i; // ax
	int v7; // edi
	unsigned __int16 v8; // bx
	int v9; // eax
	unsigned __int16 v10; // bx
	int v11; // esi
	int v12; // eax
	unsigned __int16 v13; // ax
	int v14; // edx
	int v15; // ecx

	//sub_85E40();
	//v0 = malloc(1000 * sizeof(Bit8u));//
	//result =sub_85FD0();// fix it//2B3A6C - D5020000A11A0000

	if (sub_85FD0())//v0=1
	{
		if (sub_86010())
		{
			sub_86550();
			v1 = 0;
			while (1)
			{
				v2x = sub_86270((unsigned __int16)x_WORD_1803EC);
				if ((v2x & 0x8000) == 0)
					break;
				j___delay(1000);
				if ((_WORD)++v1 == 4)
					sub_86BD0_freemem1();
			}
			x_BYTE_1804A1 = x_BYTE_180471;
			v2 = (unsigned __int8)x_BYTE_180471;
			x_BYTE_18049E = x_BYTE_180472;
			while (v2 <= (signed int)(unsigned __int8)x_BYTE_180472)
			{
				sub_86370(x_WORD_1803EC, v2);
				v3 = v2;
				v4 = x_DWORD_180486;
				x_BYTE_1803EE[v2++] = (x_BYTE_18048A & 0x40) == 0;
				x_DWORD_180084[v3] = sub_85F60(v4);
			}
			v5 = 0;
			for (i = (unsigned __int8)x_BYTE_180471; i <= (signed int)(unsigned __int8)x_BYTE_180472; i++)
			{
				if (x_BYTE_1803EE[i])
					v5 = 1;
			}
			if (v5)
			{
				v7 = x_DWORD_180088[0];
				v8 = (unsigned __int8)x_BYTE_180471;
				while (1)
				{
					v9 = v8;
					if (v8 > (signed int)(unsigned __int8)x_BYTE_180472)
						break;
					++v8;
					x_DWORD_180084[v9] -= v7;
				}
				v10 = (unsigned __int8)x_BYTE_180471;
				while (v10 <= (signed int)(unsigned __int8)x_BYTE_180472)
				{
					v11 = v10;
					if (v10 == (unsigned __int8)x_BYTE_180472)
						v12 = sub_85F60(x_DWORD_180473) - v7;
					else
						v12 = x_DWORD_180088[v11];
					x_DWORD_180214[v11] = v12;
					v13 = v10;
					v14 = x_DWORD_180084[v10];
					v15 = x_DWORD_180214[v10++];
					x_DWORD_180214[v13] = v15 - v14;
				}
				sub_86460(x_WORD_1803EC);
				x_BYTE_E2A28 = 1;
			}
			else
			{
				sub_86BD0_freemem1();
			}
		}
		else
		{
			sub_86BD0_freemem1();//23759B - 264CD0
		}
	}
	//return result;
}
// 9A122: using guessed type x_DWORD j___delay(x_DWORD);
// E2A28: using guessed type char x_BYTE_E2A28;
// 180084: using guessed type int x_DWORD_180084[];
// 180088: using guessed type int x_DWORD_180088[];
// 1803EC: using guessed type __int16 x_WORD_1803EC;
// 180471: using guessed type char x_BYTE_180471;
// 180472: using guessed type char x_BYTE_180472;
// 180473: using guessed type int x_DWORD_180473;
// 180486: using guessed type int x_DWORD_180486;
// 18048A: using guessed type char x_BYTE_18048A;
// 18049E: using guessed type char x_BYTE_18049E;
// 1804A1: using guessed type char x_BYTE_1804A1;

//----- (00086BD0) --------------------------------------------------------
bool sub_86BD0_freemem1()
{
	char result; // al
	result = 1;//fix it
	if (x_DWORD_E2A6C)//2B3A6C - D5020000A11A0000
		result = sub_85F00_free_memory(x_DWORD_E2A6C);//264CDC - 266070 
	if (x_DWORD_E2A70)
		result = sub_85F00_free_memory(x_DWORD_E2A70);
	x_BYTE_E2A28 = 0;
	x_DWORD_E2A6C = 0;
	x_DWORD_E2A70 = 0;
	return result;
}
// E2A28: using guessed type char x_BYTE_E2A28;
// E2A6C: using guessed type int x_DWORD_E2A6C;
// E2A70: using guessed type int x_DWORD_E2A70;

//----- (00086EA0) --------------------------------------------------------
void sub_86EA0(/*int a1, int a2, int a3*/ HMDIDRIVER user)
{
	sub_47760(/*a1, */(Bit32u)user/*, a3*/);
	//return 0;
}

//----- (00086EB0) --------------------------------------------------------
void sub_86EB0(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
	int v3; // eax
	unsigned __int8 v4; // dl
	int v5; // eax
	__int16 v6; // bx
	__int16 v7; // ax

	v3 = 42 * a1;
	v4 = x_BYTE_DB080[v3];
	v5 = 4 * a2 + v3;
	v6 = *(__int16 *)((char *)x_WORD_DB082 + v5);
	v7 = *(__int16 *)((char *)x_WORD_DB084 + v5);
	if (v4 && v7)
	{
		if (a3)
			sub_86F70_sound_proc12(v4, v6, v7);
		else
			sub_86FF0(v4, v6, v7);
	}
}
// DB082: using guessed type __int16 x_WORD_DB082[];
// DB084: using guessed type __int16 x_WORD_DB084[];

//----- (00086F20) --------------------------------------------------------
void sub_86F20(char a1)
{
	int v1; // eax
	unsigned __int8 v2; // dl
	__int16 v3; // bx
	__int16 v4; // ax

	v1 = 21 * ((a1 != 0) + 25);
	v2 = x_BYTE_DB080[v1 * 2];
	v3 = x_WORD_DB082[v1];
	v4 = x_WORD_DB084[v1];
	if (v2)
	{
		if (v4)
			sub_86F70_sound_proc12(v2, v3, v4);
	}
}
// DB082: using guessed type __int16 x_WORD_DB082[];
// DB084: using guessed type __int16 x_WORD_DB084[];

//----- (00086F70) --------------------------------------------------------
void sub_86F70_sound_proc12(unsigned __int8 a1, __int16 a2, __int16 a3)
{
	if (x_BYTE_E2A28 && (x_BYTE_E37FC || x_BYTE_E3798_sound_active2))
	{
		x_DWORD_180078 = sub_92600_AIL_register_timer(sub_86EA0);
		sub_92930_AIL_set_timer_frequency(x_DWORD_180078, 0x32u);
		sub_92BA0_AIL_start_timer(x_DWORD_180078);
		sub_86FF0(a1, a2, a3);
		sub_92DC0_AIL_release_timer_handle(x_DWORD_180078);
	}
}
// E2A28: using guessed type char x_BYTE_E2A28;
// E3798: using guessed type char x_BYTE_E3798_sound_active2;
// E37FC: using guessed type char x_BYTE_E37FC;
// 180078: using guessed type int x_DWORD_180078;

//----- (00086FF0) --------------------------------------------------------
void sub_86FF0(unsigned __int8 a1, __int16 a2, __int16 a3)
{
	if (x_BYTE_E2A28 && (x_BYTE_E37FC || x_BYTE_E3798_sound_active2))
	{
		x_WORD_1803E8 = a1;
		sub_86860(x_WORD_1803EC);
		if ((unsigned __int16)x_WORD_1803E8 >= (signed int)(unsigned __int8)x_BYTE_1804A1
			&& (unsigned __int16)x_WORD_1803E8 <= (signed int)(unsigned __int8)x_BYTE_18049E)
		{
			if (x_BYTE_1803EE[(unsigned __int16)x_WORD_1803E8])
				sub_86780(x_WORD_1803EC, x_DWORD_180084[(unsigned __int16)x_WORD_1803E8] + a2, a3);
		}
	}
}
// E2A28: using guessed type char x_BYTE_E2A28;
// E3798: using guessed type char x_BYTE_E3798_sound_active2;
// E37FC: using guessed type char x_BYTE_E37FC;
// 180084: using guessed type int x_DWORD_180084[];
// 1803E8: using guessed type __int16 x_WORD_1803E8;
// 1803EA: using guessed type __int16 x_WORD_1803EA;
// 1803EC: using guessed type __int16 x_WORD_1803EC;
// 18049E: using guessed type char x_BYTE_18049E;
// 1804A1: using guessed type char x_BYTE_1804A1;

//----- (00087090) --------------------------------------------------------
Bit8u* sub_87090()
{
	signed int i; // edx
	Bit8u* result; // al
	Bit8u* v2; // eax
	int v3; // edx

	memset(&unk_1804B0, 0, 171);
	for (i = 1; i < 120 && !x_DWORD_180516; i++)
	{
		if (!x_WORD_E2A74[15 * i])
			x_DWORD_180516 = i - 1;
	}
	result = (Bit8u*)sub_871E0();
	if (result)
	{
		x_BYTE_180552 = 1;
		x_WORD_1804C0 = 8;
		x_WORD_1804C2 = 14;
		x_WORD_1804BE = 400;
		x_WORD_1804C6 = 600;
		x_WORD_1804C8 = 80;
		x_WORD_1804CA = 260;
		x_WORD_1804C4 = 40;
		qmemcpy(x_WORD_1804E3, &unk_1804B0, 0x30u);
		qmemcpy(&x_WORD_1804E3[24], (char *)&unk_1804B0 + 48, 3u);
		v2 = off_E2A92;
		x_WORD_1804FD = 370;
		x_WORD_1804F7 = 30;
		x_WORD_1804F9 = 610;
		x_WORD_1804FB = 30;
		v3 = 0;
		while (v3 < x_DWORD_180516)
		{
			v2[4] = v2[6];
			if (!*((x_BYTE *)v2 + 29))
				*((x_BYTE *)v2 + 29) = *((x_BYTE *)v2 + 28);
			v2 = ((Bit8u*)v2 + 30);
			*(Bit8u*)((char *)v2 - 18) = 0;
			++v3;
			*(Bit8u*)((char *)v2 - 10) = 0;
		}
		x_DWORD_180532 = x_D41A0_BYTEARRAY_0[8];
		result = sub_88B20();
	}
	return result;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// E2A74: using guessed type __int16 x_WORD_E2A74[];
// E2A92: using guessed type void *off_E2A92;
// 1804BE: using guessed type __int16 x_WORD_1804BE;
// 1804C0: using guessed type __int16 x_WORD_1804C0;
// 1804C2: using guessed type __int16 x_WORD_1804C2;
// 1804C4: using guessed type __int16 x_WORD_1804C4;
// 1804C6: using guessed type __int16 x_WORD_1804C6;
// 1804C8: using guessed type __int16 x_WORD_1804C8;
// 1804CA: using guessed type __int16 x_WORD_1804CA;
// 1804F7: using guessed type __int16 x_WORD_1804F7;
// 1804F9: using guessed type __int16 x_WORD_1804F9;
// 1804FB: using guessed type __int16 x_WORD_1804FB;
// 1804FD: using guessed type __int16 x_WORD_1804FD;
// 180516: using guessed type int x_DWORD_180516;
// 180532: using guessed type int x_DWORD_180532;
// 180552: using guessed type char x_BYTE_180552;

//----- (000871E0) --------------------------------------------------------
char sub_871E0()
{
	return 1;
}

//----- (000871F0) --------------------------------------------------------
int sub_871F0()
{
	Bit8u* v0; // eax
	char v1; // bl
	int v2; // eax
	int v4; // eax

	v0 = (Bit8u*)sub_872A0();
	BYTE1(v0) = x_WORD_18054E;
	v1 = 1;
	if (x_WORD_18054E & 0x10)
	{
		v0 = (Bit8u*)sub_87C10();
	}
	else
	{
		if (x_WORD_18054E & 0x2000 || x_WORD_18054E & 0x1000)
			v1 = 0;
		if (x_WORD_18054E & 2 || x_WORD_18054E & 0x800)
			v1 = 1;
		if (v1)
		{
			if (x_WORD_180536)
			{
				sub_87610();
				sub_87B30();
			}
			else if (--x_DWORD_180522 <= 0)
			{
				sub_87580();
			}
			v0 = sub_87B70();
		}
		else
		{
			if (x_WORD_18054E & 0x1000)
			{
				v2 = sub_87A30();
				return _wcpp_1_unwind_leave__132(v2);
			}
			if (x_WORD_18054E & 0x2000)
			{
				v4 = sub_87860();
				return _wcpp_1_unwind_leave__132(v4);
			}
		}
	}
	return _wcpp_1_unwind_leave__132((x_DWORD)v0);
}
// 87BD0: using guessed type int /*__fastcall*/ _wcpp_1_unwind_leave__132(x_DWORD);
// 180522: using guessed type int x_DWORD_180522;
// 180536: using guessed type __int16 x_WORD_180536;
// 18054E: using guessed type __int16 x_WORD_18054E;

//----- (000872A0) --------------------------------------------------------
int sub_872A0()
{
	int v0; // edx
	unsigned __int8 v1; // al
	int v2; // esi
	char v3; // dh
	int v4; // ebx
	int v5; // edx
	int v6; // ebx
	int v7; // eax
	char v8; // cl
	char v9; // bh
	int result; // eax
	char v11; // ch
	__int16 v12; // cx
	int v13; // ebx

	v0 = 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
	v1 = *(x_BYTE *)(v0 + x_D41A0_BYTEARRAY_0 + 12221);
	v2 = x_DWORD_EA3E4[*(unsigned __int16 *)(v0 + x_D41A0_BYTEARRAY_0 + 11240)];
	if (v1 < 6u || v1 > 8u)
		LOBYTE(x_WORD_18054E) = x_WORD_18054E & 0xFA;
	else
		LOBYTE(x_WORD_18054E) = x_WORD_18054E | 5;
	x_WORD_18054E &= 0xC7FDu;
	v3 = *(x_BYTE *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 12221);
	if (v3 != 5 && v3 != 8)
	{
		x_DWORD_18051E = 20;
		x_BYTE_180554 = 0;
		x_BYTE_180555 = -1;
	}
	else
	{
		LOBYTE(x_WORD_18054E) = x_WORD_18054E | 2;
		v4 = *(x_DWORD *)(v2 + 164);
		x_DWORD_18051E = 6;
		v5 = *(char *)(v4 + 1112);
		v6 = v4 + 611;
		if (v5 != (unsigned __int8)x_BYTE_180555 || *(char *)(v6 + 502) != (unsigned __int8)x_BYTE_180556)
		{
			v7 = (unsigned __int8)x_BYTE_D94FF[*(char *)(v6 + 501)];
			if ((unsigned __int8)x_BYTE_180554 > 1u || !*(x_WORD *)(v6 + 2 * v7 + 208) || !x_BYTE_D41B6 && v7 == 25)
				sub_87C10();
			x_BYTE_180554 = 0;
			sub_88D40();
			x_DWORD_180526 = 0;
		}
		x_BYTE_180555 = *(x_BYTE *)(v6 + 501);
		x_BYTE_180556 = *(x_BYTE *)(v6 + 502);
	}
	if (*(x_BYTE *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 12221) == 7)
	{
		HIBYTE(x_WORD_18054E) |= 8u;
	}
	else if (x_WORD_E2A74[15 * x_WORD_180536] == 12)
	{
		sub_87C10();
	}
	if (x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 1)
		HIBYTE(x_WORD_18054E) |= 0x20u;
	if (*(x_BYTE *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 12221) == 3)
		HIBYTE(x_WORD_18054E) |= 0x10u;
	if (*(x_WORD *)(v2 + 130))
		x_DWORD_18053A = 0;
	else
		++x_DWORD_18053A;
	v8 = HIBYTE(x_WORD_18054E) & 0xFB;
	HIBYTE(x_WORD_18054E) &= 0xFBu;
	if (*(x_BYTE *)(v2 + 69) == 3)
		HIBYTE(x_WORD_18054E) = v8 | 4;
	LOBYTE(x_WORD_18054E) = x_WORD_18054E & 0xEF;
	if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 224772)
		|| x_D41A0_BYTEARRAY_4[0xE1]
		|| (v9 = *(x_BYTE *)(v2 + 69), v9 == 12)
		|| v9 == 11
		|| (result = 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + (int)x_D41A0_BYTEARRAY_0, v11 = *(x_BYTE *)(result + 12221), v11 == 13)
		|| v11 == 14)
	{
		result = x_DWORD_18051E;
		x_DWORD_180522 = x_DWORD_18051E;
		LOBYTE(x_WORD_18054E) = x_WORD_18054E | 0x10;
	}
	if (x_WORD_180536)
	{
		result = 30 * x_WORD_180536;
		v12 = *(__int16 *)((char *)x_WORD_E2A74 + result);
		if (v12 == 2 || v12 == 8)
		{
			if (!(x_WORD_18054E & 0x200)
				|| (result = 30 * x_WORD_180536, x_BYTE_E2A76[30 * x_WORD_180536] >= 0)
				&& ((v13 = *(int *)((char *)&x_DWORD_E2A80 + result)) == 0
					|| (result = *(int *)((char *)&x_DWORD_E2A80 + result), *(x_DWORD *)(v13 + 8) < 0)
					|| *(x_BYTE *)(v13 + 13) & 4))
			{
				result = sub_87C10();
			}
		}
		if (*(x_BYTE *)(v2 + 69) == 2)
			result = sub_87C10();
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// D41B6: using guessed type char x_BYTE_D41B6;
// E2A74: using guessed type __int16 x_WORD_E2A74[];
// E2A80: using guessed type int x_DWORD_E2A80;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// 18051E: using guessed type int x_DWORD_18051E;
// 180522: using guessed type int x_DWORD_180522;
// 180526: using guessed type int x_DWORD_180526;
// 180536: using guessed type __int16 x_WORD_180536;
// 18053A: using guessed type int x_DWORD_18053A;
// 18054C: using guessed type __int16 x_WORD_18054C;
// 18054E: using guessed type __int16 x_WORD_18054E;
// 180554: using guessed type char x_BYTE_180554;
// 180555: using guessed type char x_BYTE_180555;
// 180556: using guessed type char x_BYTE_180556;

//----- (00087580) --------------------------------------------------------
void sub_87580()
{
	int v0; // eax

	sub_87BE0();
	if (x_WORD_18054E & 0x400)
	{
		sub_884D0(91, 1, (int)&unk_E3522, 1, 0);
	}
	else if (x_WORD_18054E & 2)
	{
		sub_88D40();
	}
	else if (x_WORD_18054E & 0x800)
	{
		sub_89360();
	}
	else
	{
		sub_87CF0();
		v0 = sub_88450();
		sub_884D0(v0, 1, (int)&x_WORD_E2A74[15 * v0 + 2], ((x_BYTE_E2A76[30 * v0] & 4) == 0) + 1, 0);
	}
}
// E2A74: using guessed type __int16 x_WORD_E2A74[];
// 18054E: using guessed type __int16 x_WORD_18054E;

//----- (00087610) --------------------------------------------------------
char sub_87610()
{
	const char *v0; // edi
	__int16 *v1; // esi
	char result; // al
	__int16 v3; // ax
	signed int v4; // esi
	int v5; // edi
	unsigned __int8 v6; // al
	x_BYTE *v7; // ST04_4
	char v8; // [esp+0h] [ebp-80h]

	v0 = (const char *)x_DWORD_E9C4C_langindexbuffer[x_WORD_18053E[0]];
	v1 = &x_WORD_E2A74[15 * x_WORD_180536];
	if (*((x_BYTE *)v1 + 3) & 1)
	{
		v0 = &v8;
		sub_89AC0(&v8, x_WORD_180536);
	}
	*((x_BYTE *)&unk_1804B0 + 48) = x_BYTE_E98FF;
	*((x_BYTE *)&unk_1804B0 + 49) = (unsigned __int8)*xadataclrd0dat.var28_begin_buffer;
	*((x_BYTE *)&unk_1804B0 + 50) = x_BYTE_E9800;
	result = x_BYTE_180553;
	if ((unsigned __int8)x_BYTE_180553 >= 2u)
	{
		if ((unsigned __int8)x_BYTE_180553 <= 2u)
		{
			*((x_WORD *)&unk_1804B0 + 14) = v1[4];
			v3 = v1[5];
			*((x_WORD *)&unk_1804B0 + 6) = 220;
			*((x_WORD *)&unk_1804B0 + 15) = v3;
			if (x_WORD_18054E & 8)
			{
				sub_89830((x_WORD*)&unk_1804B0);
				sub_89420((x_WORD*)&unk_1804B0, v0);
				sub_89520((signed __int16 *)&unk_1804B0);
				sub_89980((signed __int16 *)&unk_1804B0);
			}
			sub_898A0((x_WORD*)&unk_1804B0);
			sub_2E790(
				*((x_WORD *)&unk_1804B0 + 18),
				*((signed __int16 *)&unk_1804B0 + 19),
				*((signed __int16 *)&unk_1804B0 + 20),
				*((signed __int16 *)&unk_1804B0 + 21),
				*((x_BYTE *)&unk_1804B0 + 49));
			sub_895D0((int)&unk_1804B0, v0);
		}
		else
		{
			if (x_BYTE_180553 != 3)
				goto LABEL_22;
			*((x_WORD *)&unk_1804B0 + 14) = v1[4];
			*((x_WORD *)&unk_1804B0 + 15) = v1[5];
			sub_89830((x_WORD*)&unk_1804B0);
			sub_89920((x_WORD*)&unk_1804B0, (unsigned __int8)x_BYTE_180550, (int)x_WORD_18053E);
			sub_89520((signed __int16 *)&unk_1804B0);
			sub_89980((signed __int16 *)&unk_1804B0);
			sub_898A0((x_WORD*)&unk_1804B0);
			v4 = 0;
			sub_2E790(
				*((x_WORD *)&unk_1804B0 + 18),
				*((signed __int16 *)&unk_1804B0 + 19),
				*((signed __int16 *)&unk_1804B0 + 20),
				*((signed __int16 *)&unk_1804B0 + 21),
				*((x_BYTE *)&unk_1804B0 + 49));
			v5 = *((signed __int16 *)&unk_1804B0 + 5);
			while (v4 < (unsigned __int8)x_BYTE_180550)
			{
				if (v4 == (unsigned __int8)x_BYTE_180551)
					v6 = *((x_BYTE *)&unk_1804B0 + 50);
				else
					v6 = *((x_BYTE *)&unk_1804B0 + 48);
				v7 = (x_BYTE *)x_DWORD_E9C4C_langindexbuffer[x_WORD_18053E[v4++]];
				sub_2BC10_draw_text((Bit8u*)v7, *((x_WORD *)&unk_1804B0 + 4), v5, v6);
				v5 += *((signed __int16 *)&unk_1804B0 + 9);
			}
		}
		sub_89A30((x_WORD*)&unk_1804B0);
		goto LABEL_21;
	}
	if (x_BYTE_180553 == 1)
	{
		if (x_WORD_18054E & 8)
		{
			*((x_WORD *)&unk_1804B0 + 0) = 320;
			*((x_WORD *)&unk_1804B0 + 1) = 80;
			*((x_WORD *)&unk_1804B0 + 6) = 320;
			sub_89420((x_WORD*)&unk_1804B0, v0);
			sub_89520((signed __int16 *)&unk_1804B0);
			sub_89980((signed __int16 *)&unk_1804B0);
		}
		sub_2E790(
			*((x_WORD *)&unk_1804B0 + 18),
			*((signed __int16 *)&unk_1804B0 + 19),
			*((signed __int16 *)&unk_1804B0 + 20),
			*((signed __int16 *)&unk_1804B0 + 21),
			*((x_BYTE *)&unk_1804B0 + 49));
		sub_895D0((int)&unk_1804B0, v0);
	LABEL_21:
		result = sub_89690((signed __int16 *)&unk_1804B0);
	}
LABEL_22:
	LOBYTE(x_WORD_18054E) = x_WORD_18054E & 0xF7;
	return result;
}
// E2A74: using guessed type __int16 x_WORD_E2A74[];
// E9800: using guessed type char x_BYTE_E9800;
// E98FF: using guessed type char x_BYTE_E98FF;
// 180536: using guessed type __int16 x_WORD_180536;
// 18054E: using guessed type __int16 x_WORD_18054E;
// 180550: using guessed type char x_BYTE_180550;
// 180551: using guessed type char x_BYTE_180551;
// 180553: using guessed type char x_BYTE_180553;

//----- (00087860) --------------------------------------------------------
int sub_87860()
{
	__int16 *v0; // eax
	const char *v1; // ebx
	__int16 v2; // dx
	int result; // eax

	if (x_BYTE_18055A >= 0)
	{
		sub_87970();
		v0 = &x_WORD_E2A74[15 * (x_BYTE_18055A + 86)];
		v1 = (const char *)x_DWORD_E9C4C_langindexbuffer[v0[2]];
		v2 = v0[4];
		LOWORD(v0) = v0[5];
		x_WORD_1804FF = v2;
		x_WORD_180501 = (signed __int16)v0;
		x_BYTE_180513 = x_BYTE_E98FF;
		x_WORD_1804EF = 220;
		x_BYTE_180514 = (unsigned __int8)*xadataclrd0dat.var28_begin_buffer;
		sub_89830(x_WORD_1804E3);
		sub_89420(x_WORD_1804E3, v1);
		sub_89520(x_WORD_1804E3);
		sub_89980(x_WORD_1804E3);
		sub_898A0(x_WORD_1804E3);
		sub_2E790(x_WORD_180507, x_WORD_180509, x_WORD_18050B, x_WORD_18050D, x_BYTE_180514);
		sub_895D0((int)x_WORD_1804E3, v1);
		sub_89A30(x_WORD_1804E3);
		result = sub_89690(x_WORD_1804E3);
	}
	return result;
}
// E2A74: using guessed type __int16 x_WORD_E2A74[];
// E98FF: using guessed type char x_BYTE_E98FF;
// 1804EF: using guessed type __int16 x_WORD_1804EF;
// 1804FF: using guessed type __int16 x_WORD_1804FF;
// 180501: using guessed type __int16 x_WORD_180501;
// 180507: using guessed type __int16 x_WORD_180507;
// 180509: using guessed type __int16 x_WORD_180509;
// 18050B: using guessed type __int16 x_WORD_18050B;
// 18050D: using guessed type __int16 x_WORD_18050D;
// 180513: using guessed type char x_BYTE_180513;
// 180514: using guessed type char x_BYTE_180514;
// 18055A: using guessed type char x_BYTE_18055A;

//----- (00087970) --------------------------------------------------------
int sub_87970()
{
	int result; // eax
	int v1; // [esp+0h] [ebp-10h]
	int v2; // [esp+4h] [ebp-Ch]
	int v3; // [esp+8h] [ebp-8h]
	int v4; // [esp+Ch] [ebp-4h]

	sub_2FFE0(&v4, &v3, &v2, &v1);
	x_WORD_E3490 = v2 + v4 - 12;
	x_WORD_E3492 = v3 + 6;
	x_WORD_E34AE = v2 + v4 - 12;
	x_WORD_E34B0 = v1 + v3 + 6;
	x_WORD_E34CC = v4 + v2 / 2 - 12;
	x_WORD_E34CE = v3 + 2 * v1 + 6;
	x_WORD_E34EA = v2 + v4 - 12;
	x_WORD_E34EC = v3 + 2 * v1 + 6;
	x_WORD_E3508 = v2 + v4 - 12;
	result = v3 + 3 * v1 + 6;
	x_WORD_E350A = v3 + 3 * v1 + 6;
	return result;
}
// E3490: using guessed type __int16 x_WORD_E3490;
// E3492: using guessed type __int16 x_WORD_E3492;
// E34AE: using guessed type __int16 x_WORD_E34AE;
// E34B0: using guessed type __int16 x_WORD_E34B0;
// E34CC: using guessed type __int16 x_WORD_E34CC;
// E34CE: using guessed type __int16 x_WORD_E34CE;
// E34EA: using guessed type __int16 x_WORD_E34EA;
// E34EC: using guessed type __int16 x_WORD_E34EC;
// E3508: using guessed type __int16 x_WORD_E3508;
// E350A: using guessed type __int16 x_WORD_E350A;

//----- (00087A30) --------------------------------------------------------
int sub_87A30()
{
	int result; // eax
	__int16 *v1; // eax
	int v2; // ebx
	const char *v3; // ebx

	BYTE1(result) = x_BYTE_180559;
	if (x_BYTE_180559 > 0)
	{
		v1 = &x_WORD_E2A74[15 * x_BYTE_180559];
		v2 = v1[2];
		x_WORD_1804FF = v1[4];
		v3 = (const char *)x_DWORD_E9C4C_langindexbuffer[v2];
		x_WORD_180501 = v1[5];
		x_BYTE_180513 = x_BYTE_E98FF;
		x_WORD_1804EF = 220;
		x_BYTE_180514 = (unsigned __int8)*xadataclrd0dat.var28_begin_buffer;
		sub_89830(x_WORD_1804E3);
		sub_89420(x_WORD_1804E3, v3);
		sub_89520(x_WORD_1804E3);
		sub_89980(x_WORD_1804E3);
		sub_898A0(x_WORD_1804E3);
		sub_2E790(x_WORD_180507, x_WORD_180509, x_WORD_18050B, x_WORD_18050D, x_BYTE_180514);
		sub_895D0((int)x_WORD_1804E3, v3);
		sub_89A30(x_WORD_1804E3);
		result = sub_89690(x_WORD_1804E3);
	}
	return result;
}
// E2A74: using guessed type __int16 x_WORD_E2A74[];
// E98FF: using guessed type char x_BYTE_E98FF;
// 1804EF: using guessed type __int16 x_WORD_1804EF;
// 1804FF: using guessed type __int16 x_WORD_1804FF;
// 180501: using guessed type __int16 x_WORD_180501;
// 180507: using guessed type __int16 x_WORD_180507;
// 180509: using guessed type __int16 x_WORD_180509;
// 18050B: using guessed type __int16 x_WORD_18050B;
// 18050D: using guessed type __int16 x_WORD_18050D;
// 180513: using guessed type char x_BYTE_180513;
// 180514: using guessed type char x_BYTE_180514;
// 180559: using guessed type char x_BYTE_180559;

//----- (00087B30) --------------------------------------------------------
int sub_87B30()
{
	int result; // eax

	if (++x_DWORD_180526 >= x_DWORD_18052A || (result = 15 * x_WORD_180536, !(x_BYTE_E2A76[30 * x_WORD_180536] & 1)))
		result = sub_87C10();
	return result;
}
// 180526: using guessed type int x_DWORD_180526;
// 18052A: using guessed type int x_DWORD_18052A;
// 180536: using guessed type __int16 x_WORD_180536;

//----- (00087B70) --------------------------------------------------------
Bit8u* sub_87B70()
{
	Bit8u* result; // eax
	int i; // ebx
	int v2; // edx
	Bit8u v3; // ecx
	int v4; // edx
	char v5; // dl

	result = off_E2A92;
	for (i = 0; i < x_DWORD_180516; result = (Bit8u*)((char *)result + 30))
	{
		v2 = (int)result[4] + 1;
		v3 = result[6];
		result[4] = v2;
		v4 = v2 - (x_DWORD)v3;
		if (v4 > 0 && v4 > 2 * (signed int)v3)
		{
			result[4] = result[6];
			v5 = *((x_BYTE *)result + 29) + 1;
			*((x_BYTE *)result + 29) = v5;
			if (v5 < 0)
				*((x_BYTE *)result + 29) = 0;
			if (*((x_BYTE *)result + 29) > 5)
				*((x_BYTE *)result + 29) = 5;
		}
		++i;
	}
	return result;
}
// E2A92: using guessed type void *off_E2A92;
// 180516: using guessed type int x_DWORD_180516;

//----- (00087BE0) --------------------------------------------------------
Bit8u* sub_87BE0()
{
	Bit8u* result; // eax
	int i; // edx
	char v2; // bl

	result = off_E2A92;
	for (i = 0; i < x_DWORD_180516; *((x_BYTE *)result - 28) = v2 & 0xFE)
	{
		v2 = *((x_BYTE *)result + 2);
		result = (Bit8u*)((char *)result + 30);
		++i;
	}
	return result;
}
// E2A92: using guessed type void *off_E2A92;
// 180516: using guessed type int x_DWORD_180516;

//----- (00087C10) --------------------------------------------------------
int sub_87C10()
{
	int result; // eax
	int v1; // edx
	int v2; // eax

	result = (int)x_D41A0_BYTEARRAY_4;
	if (x_D41A0_BYTEARRAY_4_struct.byteindex_A)
	{
		x_DWORD_18051A = 0;
		x_WORD_18054E &= 0xFEDFu;
		v1 = x_WORD_180536;
		x_DWORD_180522 = x_DWORD_18051E;
		v2 = 15 * x_WORD_180536;
		x_BYTE_E2A76[2 * v2] &= 0xFDu;
		*(int *)((char *)&x_DWORD_E2A84 + 2 * v2) = 0;
		*(int *)((char *)&x_DWORD_E2A80 + 2 * v2) = 0;
		x_BYTE_E2A91[2 * v2] = x_BYTE_E2A90[2 * v2];
		result = sub_889F0(v1);
		x_WORD_180536 = 0;
	}
	return result;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// E2A80: using guessed type int x_DWORD_E2A80;
// E2A84: using guessed type int x_DWORD_E2A84;
// 18051A: using guessed type int x_DWORD_18051A;
// 18051E: using guessed type int x_DWORD_18051E;
// 180522: using guessed type int x_DWORD_180522;
// 180536: using guessed type __int16 x_WORD_180536;
// 18054E: using guessed type __int16 x_WORD_18054E;

//----- (00087CF0) --------------------------------------------------------
int sub_87CF0()
{
	signed int v0; // ecx
	x_DWORD *v1; // esi
	x_WORD *v2; // edx
	unsigned __int16 v3; // bx
	int v4; // edi
	int v5; // eax
	signed int v6; // ebx
	int v7; // eax
	int v8; // eax
	Bit8u* v9; // ebx
	char v10; // ah
	char v11; // dh
	int v12; // eax
	bool v13; // zf
	int v14; // eax
	signed __int16 v15; // bx
	bool v16; // bl
	int v17; // edx
	int v18; // edx
	bool v19; // al
	char v20; // al
	signed int v21; // edx
	Bit8u* v22; // ebx
	signed int v23; // edx
	Bit8u* v24; // ebx
	char v25; // ah
	int result; // eax
	signed int v27; // edx
	Bit8u* v28; // ebx
	int v29; // [esp+0h] [ebp-28h]
	bool v30; // [esp+8h] [ebp-20h]
	bool v31; // [esp+Ch] [ebp-1Ch]
	bool v32; // [esp+10h] [ebp-18h]
	signed int v33; // [esp+14h] [ebp-14h]
	int v34; // [esp+18h] [ebp-10h]
	unsigned int v35; // [esp+1Ch] [ebp-Ch]
	int v36; // [esp+20h] [ebp-8h]
	signed int v37; // [esp+24h] [ebp-4h]

	v34 = 0;
	v37 = -1;
	v0 = -1;
	v1 = (x_DWORD *)x_DWORD_EA3E4[*(unsigned __int16 *)(x_D41A0_BYTEARRAY_0 + 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + 11240)];
	v2 = (x_WORD *)v1[41];
	v3 = v2[29];
	v4 = (int)v2 + 611;
	if (v3)
		v5 = x_DWORD_EA3E4[v3];
	else
		v5 = 0;
	v36 = v5;
	v6 = 0;
	v29 = 0;
	while (v6 < 26)
	{
		v7 = *(x_WORD *)(v4 + 2 * v6++ + 208) != 0;
		v29 += v7;
	}
	if (v29)
	{
		v30 = *(x_WORD *)((char *)v2 + 823) != 0;
		v32 = *(x_WORD *)((char *)v2 + 821) != 0;
		v31 = *(x_WORD *)((char *)v2 + 819) != 0;
		v0 = *(signed __int16 *)((char *)v2 + 1105);
		v37 = *(signed __int16 *)((char *)v2 + 1107);
	}
	v8 = (int)x_D41A0_BYTEARRAY_0 + 11 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
	if (x_BYTE_3659C[v8])
		v33 = -1;
	else
		v33 = *(char *)(x_D41A0_BYTEARRAY_0 + 10 * (unsigned __int8)x_BYTE_3659D[v8] + 222540);
	v35 = 1;
	v9 = off_E2A92;
	while ((signed int)v35 <= x_DWORD_180516)
	{
		switch (*(x_WORD *)v9)
		{
		case 1:
			if (v35 >= 1 && (v35 <= 2 || v35 == 92))
				goto LABEL_32;
			break;
		case 2:
			v10 = *((x_BYTE *)v9 + 2);
			if (v10 & 0x18)
				*((x_BYTE *)v9 + 2) = v10 | 1;
			break;
		case 3:
			if (v36)
			{
				if (v35 != 35)
					goto LABEL_32;
				if (!v33)
				{
					v12 = (int)x_D41A0_BYTEARRAY_0;
					*((x_BYTE *)v9 + 2) |= 1u;
					/*x_WORD_E2E96 = (*(unsigned __int16 *)(0x2FED5 + v12) << 6) / 100
							   + *(unsigned __int8 *)(**filearray_2aa18c[6] + 244)
							   + 60;*/ // fix it
					x_WORD_E2E98 = 38;
				}
			}
			break;
		case 5:
		case 7:
		case 0xC:
		case 0xD:
			break;
		case 6:
			v13 = (x_WORD_18054E & 2) == 0;
			goto LABEL_31;
		case 8:
			v11 = *((x_BYTE *)v9 + 2);
			if (v11 & 0x10 || v11 & 0x40)
				*((x_BYTE *)v9 + 2) |= 1u;
			if (*((x_BYTE *)v9 + 2) & 0x40)
				++v34;
			break;
		default:
			v13 = v35 == 85;
		LABEL_31:
			if (!v13)
				LABEL_32 :
				*((x_BYTE *)v9 + 2) |= 1u;
			break;
		}
		v9 = (Bit8u*)((char *)v9 + 30);
		++v35;
	}
	if (x_WORD_18054E & 4)
	{
		x_WORD_E2AB8 = 190;
		x_WORD_E2ABA = 202;
	}
	else
	{
		x_WORD_E2AB8 = 64;
		x_WORD_E2ABA = 66;
	}
	if (!v34 && !(x_WORD_18054E & 4))
		x_BYTE_E2AEE |= 1u;
	if (v1[1] >> 2 >= v1[2])
		x_BYTE_E2B0C |= 1u;
	if (*(x_BYTE *)(v1[41] + 610))
		x_BYTE_E2AD0 |= 1u;
	x_BYTE_E2BA2 |= 4u;
	x_BYTE_E2BC0 |= 4u;
	x_BYTE_E2BDE |= 4u;
	if (v29)
	{
		v14 = x_WORD_18054E & 0x40;
		if (x_WORD_18054E & 0x80)
		{
			if (v31)
			{
				x_BYTE_E2BA2 |= 1u;
				if (v0 && v37)
				{
					x_BYTE_E2BFC |= 1u;
				}
				else
				{
					x_BYTE_E2BA2 &= 0xFBu;
					if (v0)
						v15 = 600;
					else
						v15 = 540;
					x_WORD_E2BA8 = v15;
					x_WORD_E2BAA = 32;
				}
			}
			else
			{
				x_BYTE_E2B48 |= 1u;
			}
			LOBYTE(x_WORD_18054E) = x_WORD_18054E & 0x7F;
		}
		if (v14)
		{
			if (v32)
			{
				x_BYTE_E2BC0 |= 1u;
				if (v0 != 1 && v37 != 1)
				{
					x_BYTE_E2BFC |= 1u;
				}
				else
				{
					x_BYTE_E2BC0 &= 0xFBu;
					if (v0 == 1)
						x_WORD_E2BC6 = 540;
					else
						x_WORD_E2BC6 = 600;
					x_WORD_E2BC8 = 32;
				}
			}
			else
			{
				x_BYTE_E2B84 |= 1u;
			}
			LOBYTE(x_WORD_18054E) = x_WORD_18054E & 0xBF;
		}
		if (v30)
		{
			if (!v36)
			{
				x_BYTE_E2BDE |= 1u;
				if (v0 != 2 && v37 != 2)
				{
					x_BYTE_E2BFC |= 1u;
				}
				else
				{
					x_BYTE_E2BDE &= 0xFBu;
					if (v0 == 2)
						x_WORD_E2BE4 = 540;
					else
						x_WORD_E2BE4 = 600;
					x_WORD_E2BE6 = 32;
				}
			}
		}
		else
		{
			x_BYTE_E2B66 |= 1u;
		}
	}
	else
	{
		x_BYTE_E2B2A |= 1u;
	}
	if (v36)
	{
		if (v1[36] >= *(x_DWORD *)(x_DWORD_EA3E4[*(signed __int16 *)(v4 + 212)] + 140) && *(x_DWORD *)(v36 + 16) < 6)
			x_BYTE_E2C1A |= 1u;
		if (*(x_BYTE *)(v1[41] + 405))
			x_DWORD_E2C86 = 100;
		if (x_DWORD_E2C86)
			--x_DWORD_E2C86;
		if (x_DWORD_E2C86)
			x_BYTE_E2C74 |= 1u;
	}
	if (v29)
	{
		if (v0 > -1)
			x_BYTE_E2EEA |= 1u;
		if (v37 > -1)
			x_BYTE_E2F08 |= 1u;
		if (v0 > -1)
		{
			x_WORD_E2F2C = 540;
			x_BYTE_E2F26 |= 1u;
			x_WORD_E2F2E = 40;
			x_BYTE_E2F62 |= 1u;
			x_WORD_E2F6A = 16;
			x_WORD_E2F68 = 560;
		}
		v16 = 0;
		if (v0 > -1)
		{
			v17 = x_DWORD_EA3E4[*(signed __int16 *)(v4 + 2 * v0 + 208)];
			if (v0 == 2)
			{
				if (v1[36] < *(x_DWORD *)(v17 + 140))
					v16 = 1;
			}
			else
			{
				v16 = sub_68D50(v17, v1) == 0;
			}
			if (v16)
			{
				x_WORD_E2F4A = 540;
				x_WORD_E2F4C = 48;
				x_BYTE_E2F44 |= 1u;
			}
		}
		if (v37 > -1 && !v16)
		{
			v18 = x_DWORD_EA3E4[*(signed __int16 *)(v4 + 2 * v37 + 208)];
			v19 = v37 == 2 ? v1[36] < *(x_DWORD *)(v18 + 140) : sub_68D50(v18, v1) == 0;
			if (v19)
			{
				x_BYTE_E2F44 |= 1u;
				x_WORD_E2F4C = 48;
				x_WORD_E2F4A = 600;
			}
		}
	}
	if (v33 == -1)
	{
		v20 = 1;
		x_BYTE_E33D6 |= 1u;
		if (x_BYTE_E3430 & 0x40)
			x_BYTE_E3430 |= 1u;
	}
	else
	{
		v20 = 0;
		switch (v33)
		{
		case 0:
			x_BYTE_E32E6 |= 1u;
			break;
		case 1:
			x_BYTE_E3340 |= 1u;
			break;
		case 2:
			x_BYTE_E3304 |= 1u;
			break;
		case 3:
			x_BYTE_E337C |= 1u;
			break;
		case 5:
			x_BYTE_E33B8 |= 1u;
			break;
		case 7:
			x_BYTE_E335E |= 1u;
			break;
		case 8:
			x_BYTE_E339A |= 1u;
			break;
		case 9:
			x_BYTE_E3322 |= 1u;
			break;
		default:
			break;
		}
	}
	if (x_DWORD_18053A > 100)
	{
		x_BYTE_E2C38 |= 1u;
		x_BYTE_E2C56 |= 1u;
	}
	if (v20)
	{
		v21 = 1;
		v22 = off_E2A92;
		while (v21 <= x_DWORD_180516)
		{
			if (*((x_BYTE *)v22 + 3) & 4)
				*((x_BYTE *)v22 + 2) &= 0xFEu;
			++v21;
			v22 = (Bit8u*)((char *)v22 + 30);
		}
	}
	if (x_WORD_18054E & 4)
	{
		v23 = 1;
		v24 = off_E2A92;
		while (v23 <= x_DWORD_180516)
		{
			v25 = *((x_BYTE *)v24 + 2);
			if (v25 & 0x20)
				*((x_BYTE *)v24 + 2) = v25 & 0xFE;
			++v23;
			v24 = (Bit8u*)((char *)v24 + 30);
		}
	}
	result = (int)x_D41A0_BYTEARRAY_0;
	if (!*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 8590))
	{
		v27 = 1;
		v28 = off_E2A92;
		while (v27 <= x_DWORD_180516)
		{
			if (*((x_BYTE *)v28 + 3) & 2)
				*((x_BYTE *)v28 + 2) &= 0xFEu;
			++v27;
			v28 = (Bit8u*)((char *)v28 + 30);
		}
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// E2A92: using guessed type void *off_E2A92;
// E2AB8: using guessed type __int16 x_WORD_E2AB8;
// E2ABA: using guessed type __int16 x_WORD_E2ABA;
// E2AD0: using guessed type char x_BYTE_E2AD0;
// E2AEE: using guessed type char x_BYTE_E2AEE;
// E2B0C: using guessed type char x_BYTE_E2B0C;
// E2B2A: using guessed type char x_BYTE_E2B2A;
// E2B48: using guessed type char x_BYTE_E2B48;
// E2B66: using guessed type char x_BYTE_E2B66;
// E2B84: using guessed type char x_BYTE_E2B84;
// E2BA2: using guessed type char x_BYTE_E2BA2;
// E2BA8: using guessed type __int16 x_WORD_E2BA8;
// E2BAA: using guessed type __int16 x_WORD_E2BAA;
// E2BC0: using guessed type char x_BYTE_E2BC0;
// E2BC6: using guessed type __int16 x_WORD_E2BC6;
// E2BC8: using guessed type __int16 x_WORD_E2BC8;
// E2BDE: using guessed type char x_BYTE_E2BDE;
// E2BE4: using guessed type __int16 x_WORD_E2BE4;
// E2BE6: using guessed type __int16 x_WORD_E2BE6;
// E2BFC: using guessed type char x_BYTE_E2BFC;
// E2C1A: using guessed type char x_BYTE_E2C1A;
// E2C38: using guessed type char x_BYTE_E2C38;
// E2C56: using guessed type char x_BYTE_E2C56;
// E2C74: using guessed type char x_BYTE_E2C74;
// E2C86: using guessed type int x_DWORD_E2C86;
// E2E96: using guessed type __int16 x_WORD_E2E96;
// E2E98: using guessed type __int16 x_WORD_E2E98;
// E2EEA: using guessed type char x_BYTE_E2EEA;
// E2F08: using guessed type char x_BYTE_E2F08;
// E2F26: using guessed type char x_BYTE_E2F26;
// E2F2C: using guessed type __int16 x_WORD_E2F2C;
// E2F2E: using guessed type __int16 x_WORD_E2F2E;
// E2F44: using guessed type char x_BYTE_E2F44;
// E2F4A: using guessed type __int16 x_WORD_E2F4A;
// E2F4C: using guessed type __int16 x_WORD_E2F4C;
// E2F62: using guessed type char x_BYTE_E2F62;
// E2F68: using guessed type __int16 x_WORD_E2F68;
// E2F6A: using guessed type __int16 x_WORD_E2F6A;
// E32E6: using guessed type char x_BYTE_E32E6;
// E3304: using guessed type char x_BYTE_E3304;
// E3322: using guessed type char x_BYTE_E3322;
// E3340: using guessed type char x_BYTE_E3340;
// E335E: using guessed type char x_BYTE_E335E;
// E337C: using guessed type char x_BYTE_E337C;
// E339A: using guessed type char x_BYTE_E339A;
// E33B8: using guessed type char x_BYTE_E33B8;
// E33D6: using guessed type char x_BYTE_E33D6;
// E3430: using guessed type char x_BYTE_E3430;
// EA3DC: using guessed type int **filearray_2aa18c[6];
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// 180516: using guessed type int x_DWORD_180516;
// 18053A: using guessed type int x_DWORD_18053A;
// 18054E: using guessed type __int16 x_WORD_18054E;

//----- (00088450) --------------------------------------------------------
int sub_88450()
{
	signed int v0; // ebx
	int v1; // edx
	Bit8u* v2; // eax
	int v3; // ecx
	int v4; // edi

	if (x_WORD_180538)
	{
		v1 = x_WORD_180538;
		x_WORD_180538 = 0;
	}
	else
	{
		v0 = 6;
		v1 = 0;
		while (v0 >= 0 && !v1)
		{
			v2 = off_E2A92;
			v3 = 0;
			v4 = 0;
			while (v3 < x_DWORD_180516)
			{
				if (*((x_BYTE *)v2 + 2) & 1
					&& v0 == *((char *)v2 + 29)
					&& (x_BYTE *)v2[4] - (x_BYTE *)v2[6] > 0
					&& (x_BYTE *)v2[4] - (x_BYTE *)v2[6] > v4)
				{
					v1 = v3 + 1;
					v4 = (x_BYTE *)v2[4] - (x_BYTE *)v2[6];
				}
				++v3;
				v2 = (Bit8u*)((char *)v2 + 30);
			}
			--v0;
		}
	}
	return v1;
}
// E2A92: using guessed type void *off_E2A92;
// 180516: using guessed type int x_DWORD_180516;
// 180538: using guessed type __int16 x_WORD_180538;

//----- (000884D0) --------------------------------------------------------
void sub_884D0(int a1, __int16 a2, int a3, char a4, char a5)
{
	signed int i; // eax
	char v6; // dl

	if (a1)
	{
		x_DWORD_18052A = x_WORD_E2A7A[15 * a1];
		x_BYTE_180553 = a4;
		x_WORD_180536 = a1;
		LOBYTE(x_WORD_18054E) = x_WORD_18054E | 8;
		x_BYTE_180551 = a5;
		x_DWORD_180526 = 0;
		x_BYTE_180550 = a2;
		for (i = 0; i < a2; *((x_WORD *)&x_DWORD_18053A + i + 1) = *(x_WORD *)(a3 + 2 * i - 2))
			++i;
		v6 = x_BYTE_E2A76[30 * a1] | 3;
		x_BYTE_E2A76[30 * a1] = v6;
		if (v6 & 8)
		{
			LOBYTE(x_WORD_18054E) = x_WORD_18054E | 0x20;
		}
		else if (v6 & 0x10)
		{
			HIBYTE(x_WORD_18054E) |= 1u;
		}
	}
}
// E2A7A: using guessed type __int16 x_WORD_E2A7A[];
// 180526: using guessed type int x_DWORD_180526;
// 18052A: using guessed type int x_DWORD_18052A;
// 180536: using guessed type __int16 x_WORD_180536;
// 18053A: using guessed type int x_DWORD_18053A;
// 18054E: using guessed type __int16 x_WORD_18054E;
// 180550: using guessed type char x_BYTE_180550;
// 180551: using guessed type char x_BYTE_180551;
// 180553: using guessed type char x_BYTE_180553;

//----- (00088580) --------------------------------------------------------
Bit8u* sub_88580()
{
	signed int v0; // edx
	Bit8u* result; // eax

	v0 = 1;
	for (result = off_E2A92; v0 <= x_DWORD_180516; result = (Bit8u*)((char *)result + 30))
	{
		if (*(x_WORD *)result >= 2u && (*(x_WORD *)result <= 2u || *(x_WORD *)result == 8))
		{
			*((x_BYTE *)result + 2) &= 0xA7u;
			if (result[3])
			{
				if (*((x_BYTE *)result + 2) & 2)
					HIBYTE(x_WORD_18054E) &= 0xFDu;
				else
					result[3] = 0;
			}
		}
		++v0;
	}
	return result;
}
// E2A92: using guessed type void *off_E2A92;
// 180516: using guessed type int x_DWORD_180516;
// 18054E: using guessed type __int16 x_WORD_18054E;

//----- (000885E0) --------------------------------------------------------
char sub_885E0(int a1, int a2, int a3, unsigned __int16 a4)
{
	signed int v4; // eax
	int v5; // edx
	unsigned int v6; // ebx
	int v7; // ebx
	char v8; // al
	char v9; // dl
	char v10; // dh
	char v12; // [esp+0h] [ebp-4h]

	LOBYTE(v4) = (uint8)x_D41A0_BYTEARRAY_4;
	v5 = 0;
	if (x_D41A0_BYTEARRAY_4_struct.byteindex_A)
	{
		LOBYTE(v4) = a4;
		if (!(x_BYTE_E2A76[30 * (signed __int16)a4] & 8))
		{
			if (x_WORD_180660_VGA_type_resolution & 1)
			{
				a2 *= 2;
				a3 *= 2;
			}
			LOBYTE(v4) = a4;
			v6 = 30 * (signed __int16)a4;
			if (x_BYTE_E2A76[v6] & 2)
			{
				if (a1 == *(int *)((char *)&x_DWORD_E2A80 + v6) && !(x_WORD_18054E & 0x20))
				{
					v9 = x_BYTE_E2A76[v6] | 0x10;
					x_WORD_E2A7C[v6 / 2] = a2;
					x_BYTE_E2A76[v6] = v9;
					LOBYTE(v4) = a3;
					v10 = HIBYTE(x_WORD_18054E) | 2;
					x_WORD_E2A7E[v6 / 2] = a3;
					HIBYTE(x_WORD_18054E) = v10;
				}
			}
			else
			{
				v12 = 0;
				if (!a1
					|| (v4 = sub_58490(
					(x_WORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12
						+ x_D41A0_BYTEARRAY_0
						+ 11240)]
						+ 76),
						(x_WORD *)(a1 + 76)),
						v5 = v4,
						!*(int *)((char *)&x_DWORD_E2A80 + v6))
					|| v4 < *(int *)((char *)&x_DWORD_E2A88 + v6))
				{
					v12 = 1;
				}
				if (v12)
				{
					v7 = 15 * (signed __int16)a4;
					*(int *)((char *)&x_DWORD_E2A80 + 2 * v7) = a1;
					v8 = x_BYTE_E2A76[30 * (signed __int16)a4];
					*(int *)((char *)&x_DWORD_E2A88 + 2 * v7) = v5;
					LOBYTE(v4) = v8 | 0x10;
					x_BYTE_E2A76[2 * v7] = v4;
				}
			}
		}
		if (a4 >= 0x51u && a4 <= 0x53u)
		{
			LOBYTE(v4) = a4;
			x_BYTE_E2A76[30 * (signed __int16)a4] |= 0x40u;
		}
	}
	return v4;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// E2A7C: using guessed type __int16 x_WORD_E2A7C[];
// E2A7E: using guessed type __int16 x_WORD_E2A7E[];
// E2A80: using guessed type int x_DWORD_E2A80;
// E2A88: using guessed type int x_DWORD_E2A88;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// 18054E: using guessed type __int16 x_WORD_18054E;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00088740) --------------------------------------------------------
void sub_88740(int a1, int a2, int a3)
{
	int v3; // esi
	int v4; // edx
	unsigned __int8 v5; // al
	unsigned __int8 v6; // al
	unsigned __int8 v7; // al
	unsigned __int8 v8; // al
	char v9; // cl
	signed int v10; // eax
	unsigned __int8 v11; // al
	unsigned int v12; // edi
	signed int v13; // eax
	int v14; // esi
	char v15; // dl
	char v16; // dh
	char v17; // bl
	char v18; // [esp+0h] [ebp-4h]

	v3 = 0;
	if (x_WORD_18054E & 1)
		return;
	v4 = x_DWORD_EA3E4[*(unsigned __int16 *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240)];
	v5 = *(x_BYTE *)(a1 + 63);
	if (v5 < 5u)
	{
		if (v5 >= 2u)
		{
			if (v5 <= 2u)
			{
				v6 = *(x_BYTE *)(a1 + 64);
				if (v6 >= 1u)
				{
					if (v6 <= 1u)
					{
						v3 = 27;
					}
					else if (v6 == 2)
					{
						v3 = 22;
					}
				}
			}
			else if (v5 == 3)
			{
				v11 = *(x_BYTE *)(a1 + 64);
				if (v11 < 2u)
				{
					if (v11 == 1)
						v3 = 28;
				}
				else if (v11 <= 2u)
				{
					v3 = (*(x_WORD *)(a1 + 26) != *(x_WORD *)(v4 + 26)) + 24;
				}
				else if (v11 == 3)
				{
					if (*(x_WORD *)(a1 + 26) == *(x_WORD *)(v4 + 26))
						v3 = 23;
					else
						v3 = 26;
				}
			}
		}
		goto LABEL_48;
	}
	if (v5 > 5u)
	{
		if (v5 >= 0xAu)
		{
			if (v5 <= 0xAu)
			{
				if (*(x_BYTE *)(a1 + 64) == 39 && *(unsigned __int16 *)(a1 + 148) != *(signed __int16 *)(v4 + 26))
					v3 = 18;
			}
			else if (v5 == 15 && !(*(x_BYTE *)(a1 + 12) & 1))
			{
				v3 = 20;
			}
		}
		goto LABEL_48;
	}
	if (*(x_WORD *)(a1 + 26) != *(x_WORD *)(v4 + 26))
	{
		v7 = *(x_BYTE *)(a1 + 64);
		if (v7 < 0xCu)
			goto LABEL_30;
		if (v7 > 0xEu)
		{
			if (v7 == 22)
			{
				if (*(x_BYTE *)(a1 + 69) != -76 && *(unsigned __int16 *)(a1 + 148) != *(signed __int16 *)(v4 + 26))
					v3 = 18;
				goto LABEL_48;
			}
		LABEL_30:
			v8 = *(x_BYTE *)(a1 + 69);
			if (v8 < 0xE8u || v8 > 0xEAu)
			{
				v9 = *(x_BYTE *)(a1 + 73);
				v10 = 1;
				if ((v9 == 14 || v9 == 13) && *(unsigned __int16 *)(a1 + 40) == *(signed __int16 *)(v4 + 26))
					v10 = 0;
				if (v10)
					v3 = 19;
			}
			goto LABEL_48;
		}
	}
LABEL_48:
	if (v3)
	{
		if (x_WORD_180660_VGA_type_resolution & 1)
		{
			a2 *= 2;
			a3 *= 2;
		}
		v12 = 30 * v3;
		if (x_BYTE_E2A76[30 * v3] & 2)
		{
			if (a1 == *(int *)((char *)&x_DWORD_E2A80 + v12))
			{
				v16 = HIBYTE(x_WORD_18054E);
				if (!(x_WORD_18054E & 0x100))
				{
					v17 = x_BYTE_E2A76[v12] | 8;
					x_WORD_E2A7C[v12 / 2] = a2;
					x_BYTE_E2A76[v12] = v17;
					x_WORD_E2A7E[v12 / 2] = a3;
					HIBYTE(x_WORD_18054E) = v16 | 2;
				}
			}
		}
		else
		{
			v18 = 0;
			v13 = sub_58490((x_WORD *)(v4 + 76), (x_WORD *)(a1 + 76));
			if (!*(int *)((char *)&x_DWORD_E2A80 + v12) || v13 < *(int *)((char *)&x_DWORD_E2A88 + v12) && v13 > 1024)
				v18 = 1;
			if (v18)
			{
				v14 = 15 * v3;
				*(int *)((char *)&x_DWORD_E2A88 + 2 * v14) = v13;
				v15 = x_BYTE_E2A76[2 * v14];
				*(int *)((char *)&x_DWORD_E2A80 + 2 * v14) = a1;
				x_BYTE_E2A76[2 * v14] = v15 | 8;
			}
		}
	}
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// E2A7C: using guessed type __int16 x_WORD_E2A7C[];
// E2A7E: using guessed type __int16 x_WORD_E2A7E[];
// E2A80: using guessed type int x_DWORD_E2A80;
// E2A88: using guessed type int x_DWORD_E2A88;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// 18054E: using guessed type __int16 x_WORD_18054E;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (000889F0) --------------------------------------------------------
int sub_889F0(int a1)
{
	int result; // eax

	result = a1;
	if ((unsigned __int16)a1 < 0x15u)
	{
		if ((unsigned __int16)a1 < 0x12u)
		{
			if ((x_WORD)a1 == 15)
			{
				x_BYTE_E2C71 = 6;
				return result;
			}
			goto LABEL_22;
		}
		if ((unsigned __int16)a1 > 0x12u)
		{
			if ((x_WORD)a1 != 19)
				goto LABEL_22;
			goto LABEL_19;
		}
	LABEL_18:
		LOBYTE(x_WORD_18054E) = x_WORD_18054E | 0x40;
		return result;
	}
	if ((unsigned __int16)a1 <= 0x15u)
		goto LABEL_18;
	if ((unsigned __int16)a1 < 0x1Cu)
	{
		if ((unsigned __int16)a1 < 0x19u || (unsigned __int16)a1 > 0x1Au)
			goto LABEL_22;
		goto LABEL_19;
	}
	if ((unsigned __int16)a1 <= 0x1Cu)
		goto LABEL_19;
	if ((unsigned __int16)a1 < 0x52u)
	{
	LABEL_22:
		if (x_WORD_E2A74[15 * (signed __int16)a1] == 7)
		{
			switch (*(x_BYTE *)(x_D41A0_BYTEARRAY_0
				+ 10 * (unsigned __int8)x_BYTE_3659D[11 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + (int)x_D41A0_BYTEARRAY_0]
				+ 222540))
			{
			case 0:
				LOBYTE(x_WORD_18054E) = x_WORD_18054E | 0x40;
				break;
			case 1:
			case 2:
			case 3:
			case 7:
			case 8:
			case 9:
				LOBYTE(x_WORD_18054E) = x_WORD_18054E | 0x80;
				break;
			default:
				break;
			}
		}
		if ((x_WORD)a1 == 79)
		{
			x_BYTE_E2ACD = 6;
			x_BYTE_E340F = 6;
		}
		return result;
	}
	if ((unsigned __int16)a1 <= 0x52u)
	{
	LABEL_19:
		LOBYTE(x_WORD_18054E) = x_WORD_18054E | 0x80;
		return result;
	}
	if ((x_WORD)a1 != 93)
		goto LABEL_22;
	if (*(x_WORD *)(*(x_DWORD *)(x_DWORD_EA3E4[*(unsigned __int16 *)(x_D41A0_BYTEARRAY_0
		+ 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12
		+ 11240)]
		+ 164)
		+ 58))
		x_WORD_180538 = 94;
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// E2A74: using guessed type __int16 x_WORD_E2A74[];
// E2ACD: using guessed type char x_BYTE_E2ACD;
// E2C71: using guessed type char x_BYTE_E2C71;
// E340F: using guessed type char x_BYTE_E340F;
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// 180538: using guessed type __int16 x_WORD_180538;
// 18054E: using guessed type __int16 x_WORD_18054E;

//----- (00088B20) --------------------------------------------------------
Bit8u* sub_88B20()
{
	Bit8u* result; // eax
	signed int v1; // edx
	Bit8u* v2; // ebx

	result = x_D41A0_BYTEARRAY_4;
	if (x_D41A0_BYTEARRAY_0[10])
	{
		v1 = 1;
		v2 = off_E2A92;
		while (v1 <= x_DWORD_180516)
		{
			if (*(x_WORD *)v2 == 7)
			{
				result = (Bit8u*)(15 * v1);
				x_BYTE_E2A91[30 * v1] = 6;
			}
			++v1;
			v2 = (Bit8u*)((char *)v2 + 30);
		}
	}
	return result;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// E2A92: using guessed type void *off_E2A92;
// 180516: using guessed type int x_DWORD_180516;

//----- (00088B60) --------------------------------------------------------
int sub_88B60()
{
	int result; // eax

	result = x_D41A0_BYTEARRAY_0[4];
	if (x_D41A0_BYTEARRAY_4[4 + 10])
		x_BYTE_E2F5F = 6;
	return result;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// E2F5F: using guessed type char x_BYTE_E2F5F;

//----- (00088BA0) --------------------------------------------------------
char sub_88BA0()
{
	char result; // al
	int v1; // ebx

	result = -1;
	if (x_D41A0_BYTEARRAY_4[4 + 10])
	{
		v1 = x_D41A0_BYTEARRAY_0[11] * *(signed __int16 *)(x_D41A0_BYTEARRAY_4_struct.dwordindex_12);
		if (!x_BYTE_3659C[v1])
			result = *(x_BYTE *)(x_D41A0_BYTEARRAY_0[10] * (unsigned __int8)x_BYTE_3659D[v1] + 222540);
		if (result == -1)
		{
			x_WORD_180538 = 80;
		LABEL_15:
			x_DWORD_18051E = 8;
			result = sub_87C10();
		}
		else
		{
			switch (result)
			{
			case 0:
				x_WORD_180538 = 72;
				x_DWORD_18051E = 8;
				result = sub_87C10();
				break;
			case 1:
				x_WORD_180538 = 75;
				x_DWORD_18051E = 8;
				result = sub_87C10();
				break;
			case 2:
				x_WORD_180538 = 73;
				x_DWORD_18051E = 8;
				result = sub_87C10();
				break;
			case 3:
				x_WORD_180538 = 77;
				x_DWORD_18051E = 8;
				result = sub_87C10();
				break;
			case 5:
				x_WORD_180538 = 79;
				x_DWORD_18051E = 8;
				result = sub_87C10();
				break;
			case 7:
				x_WORD_180538 = 76;
				x_DWORD_18051E = 8;
				result = sub_87C10();
				break;
			case 8:
				x_WORD_180538 = 78;
				x_DWORD_18051E = 8;
				result = sub_87C10();
				break;
			case 9:
				x_WORD_180538 = 74;
				x_DWORD_18051E = 8;
				result = sub_87C10();
				break;
			default:
				goto LABEL_15;
			}
		}
	}
	return result;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// 18051E: using guessed type int x_DWORD_18051E;
// 180538: using guessed type __int16 x_WORD_180538;

//----- (00088D00) --------------------------------------------------------
int sub_88D00()
{
	int result; // eax

	result = (int)x_D41A0_BYTEARRAY_4;
	if (x_D41A0_BYTEARRAY_4_struct.byteindex_A)
		x_WORD_180538 = 93;
	return result;
}
// D41A4: using guessed type int x_DWORD_D41A4;
// 180538: using guessed type __int16 x_WORD_180538;

//----- (00088D40) --------------------------------------------------------
char sub_88D40()
{
	unsigned __int16 v0; // dx
	int v1; // ebx
	signed int v2; // eax
	int v3; // edx
	signed int v4; // ebx
	int v5; // ecx
	int v6; // edx
	int v7; // ebx
	int v8; // edi
	int v9; // ecx
	int v10; // esi
	int v11; // edi
	int v12; // eax
	char v13; // cl
	int v20; // [esp+0h] [ebp-2h]
	__int16 v21; // [esp+Ch] [ebp+Ah]
	int i; // [esp+18h] [ebp+16h]
	int v23; // [esp+1Ch] [ebp+1Ah]
	int v24; // [esp+24h] [ebp+22h]
	int v25; // [esp+28h] [ebp+26h]
	int v26; // [esp+2Ch] [ebp+2Ah]
	int v27; // [esp+30h] [ebp+2Eh]
	int v28; // [esp+34h] [ebp+32h]
	int v29; // [esp+38h] [ebp+36h]
	int v30; // [esp+3Ch] [ebp+3Ah]
	int v32; // [esp+44h] [ebp+42h]
	int v33; // [esp+48h] [ebp+46h]
	int v34; // [esp+4Ch] [ebp+4Ah]
	int v35; // [esp+50h] [ebp+4Eh]
	int v36; // [esp+54h] [ebp+52h]
	int v37; // [esp+58h] [ebp+56h]
	char *v39; // [esp+60h] [ebp+5Eh]
	int v40; // [esp+64h] [ebp+62h]
	int v41; // [esp+68h] [ebp+66h]
	int v42; // [esp+6Ch] [ebp+6Ah]
	int v43; // [esp+70h] [ebp+6Eh]
	char v44; // [esp+78h] [ebp+76h]
	char v45; // [esp+7Ch] [ebp+7Ah]
	bool v46; // [esp+80h] [ebp+7Eh]

	v40 = 0;
	v45 = 0;
	v42 = 0;
	v34 = 0;
	v36 = x_DWORD_EA3E4[*(unsigned __int16 *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 11240)];
	v0 = *(x_WORD *)(*(x_DWORD *)(v36 + 164) + 58);
	if (v0)
		v40 = x_DWORD_EA3E4[v0];
	v1 = 0;
	v30 = *(x_DWORD *)(v36 + 164) + 611;
	v2 = 0;
	while (v2 < 26)
	{
		v3 = *(x_WORD *)(v30 + 2 * v2++ + 208) != 0;
		v1 += v3;
	}
	if (v1)
	{
		if (x_WORD_180660_VGA_type_resolution & 1)
			v4 = 400;
		else
			v4 = 480;
		// fix it//v5 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 539);
		// fix it//v6 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 532);
		v5 = 0;v6 = 0;  //fix it
		v32 = v4 - 2 * v5;
		v26 = v6;
		// fix it//v23 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 538);
		v7 = v5;
		v41 = (unsigned __int8)x_BYTE_D94FF[*(char *)(v30 + 501)];
		v46 = *(x_WORD *)(v30 + 2 * v41 + 208) != 0;
		if (*(x_BYTE *)(x_D41A0_BYTEARRAY_0 + 196308) != 2 && v41 == 25)
			v46 = 0;
		v35 = *(char *)(v41 + v30 + 442);
		v8 = *(char *)(v30 + 501);
		v39 = (char*)*xadataspellsdat.var28_begin_buffer[80 * v41 + 2];
		v43 = 13;
		// fix it//v20 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 982);
		v20 = 0;v23 = 0;  //fix it
		v9 = 3 * v20;
		v33 = v23 / 2 + v23 * (v8 % 13) + v26;
		v43 = 13;
		// fix it//v10 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 983);
		v10 = 0;  //fix it
		v37 = v32 - v10;
		v29 = v7 / 2 + v7 * (v8 / 13) + v32;
		v11 = v33 - 3 * v20 / 2;
		if (v11 <= 640 - 3 * v20)
		{
			if (v11 < 0)
				v11 = 0;
		}
		else
		{
			v11 = 640 - v9;
		}
		v12 = v9 / 2;
		v13 = 0;
		v25 = v11 + v12;
		for (i = 0; i < 8 && !v13; i++)
		{
			v44 = 2;
			v34 = 1;
			if ((unsigned __int8)x_BYTE_180554 <= 6u)
			{
				v43 = 4 * (unsigned __int8)x_BYTE_180554;
				v24 = v10 / 2;
				v28 = v20 / 2;
				v27 = v10 / 2 + v37;
				JUMPOUT(__CS__, (int*) *(&off_88D1C + (unsigned __int8)x_BYTE_180554));
			}
			if ((unsigned __int8)++x_BYTE_180554 > 7u)
				x_BYTE_180554 = 0;
		}
		if (v42)
			sub_884D0(v42, v34, (int)&v21, v44, v45);
	}
	return v42;
}
// 88D1C: using guessed type void *off_88D1C;
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// E2F2C: using guessed type __int16 x_WORD_E2F2C;
// E2F2E: using guessed type __int16 x_WORD_E2F2E;
// E2F4A: using guessed type __int16 x_WORD_E2F4A;
// E2F4C: using guessed type __int16 x_WORD_E2F4C;
// E2F68: using guessed type __int16 x_WORD_E2F68;
// E2F6A: using guessed type __int16 x_WORD_E2F6A;
// E3292: using guessed type __int16 x_WORD_E3292;
// E32AC: using guessed type __int16 x_WORD_E32AC;
// E32B0: using guessed type __int16 x_WORD_E32B0;
// E32B2: using guessed type __int16 x_WORD_E32B2;
// E32CE: using guessed type __int16 x_WORD_E32CE;
// E32D0: using guessed type __int16 x_WORD_E32D0;
// E3472: using guessed type __int16 x_WORD_E3472;
// E3474: using guessed type __int16 x_WORD_E3474;
// EA3DC: using guessed type int **filearray_2aa18c[6];
// EA3E4: using guessed type int x_DWORD_EA3E4[];
// 180554: using guessed type char x_BYTE_180554;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00089360) --------------------------------------------------------
char sub_89360()
{
	char v0; // al
	int v1; // ebx
	int v2; // eax
	int v4; // [esp+0h] [ebp-4h]

	v0 = 0;
	v1 = 0;
	if (x_BYTE_180557)
	{
		x_BYTE_180557 = 0;
		if (x_BYTE_180558 && *(x_WORD *)(x_D41A0_BYTEARRAY_0 + 14) > 1u)
		{
			x_WORD_E35BC = x_WORD_18054A;
			v1 = 96;
			x_WORD_E35BE = x_WORD_18054C;
		}
		else
		{
			v0 = 1;
		}
	}
	else
	{
		v0 = 1;
		x_BYTE_180557 = 1;
	}
	if (v0)
	{
		v1 = 95;
		x_WORD_E359E = x_WORD_180546;
		x_BYTE_180558 = 0;
		x_WORD_E35A0 = x_WORD_180548;
	}
	if (v1)
	{
		v2 = 15 * v1;
		LOWORD(v2) = x_WORD_E2A78[15 * v1];
		v4 = v2;
		sub_884D0(v1, 1, (int)&v4, 2, 0);
	}
	return v1;
}
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// E2A78: using guessed type __int16 x_WORD_E2A78[];
// E359E: using guessed type __int16 x_WORD_E359E;
// E35A0: using guessed type __int16 x_WORD_E35A0;
// E35BC: using guessed type __int16 x_WORD_E35BC;
// E35BE: using guessed type __int16 x_WORD_E35BE;
// 180546: using guessed type __int16 x_WORD_180546;
// 180548: using guessed type __int16 x_WORD_180548;
// 18054A: using guessed type __int16 x_WORD_18054A;
// 18054C: using guessed type __int16 x_WORD_18054C;
// 180557: using guessed type char x_BYTE_180557;
// 180558: using guessed type char x_BYTE_180558;

//----- (00089420) --------------------------------------------------------
int sub_89420(x_WORD *a1, const char *a2)
{
	int result; // eax
	unsigned int v3; // kr04_4
	signed int v4; // ecx
	signed int v5; // ebx
	unsigned int v6; // ecx
	unsigned int v7; // edx
	x_BYTE *i; // ecx
	signed __int16 v9; // [esp+4h] [ebp-4h]

	result = 0;
	v3 = strlen(a2) + 1;
	v9 = 1;
	a1[2] = 0;
	a1[3] = 0;
	if (v3 != 1)
	{
		HIWORD(result) = 0;
		v4 = (signed __int16)a1[8] * strlen(a2);
		v5 = (signed __int16)a1[6];
		if (v4 <= v5)
		{
			a1[2] = v4;
		}
		else
		{
			result = v5 / 2;
			if (v4 % v5 < v5 / 2)
			{
				while (1)
				{
					result = v5 / 2;
					if (v4 % v5 >= v5 / 2 || v5 <= 0)
						break;
					v5 -= (signed __int16)a1[8];
				}
			}
			if (v5 > 0)
			{
				result = (v5 + (signed __int16)a1[8] - 1) / (signed __int16)a1[8];
				v9 = 0;
				v6 = (unsigned int)a2;
				v7 = (unsigned int)&a2[v3 - 1];
				while (v6 < v7)
				{
					for (i = (x_BYTE *)(result + v6); *i != 32 && (unsigned int)i < v7; i--)
						;
					v6 = (unsigned int)(i + 1);
					++v9;
				}
				a1[2] = v5;
			}
		}
		LOWORD(result) = a1[9];
		a1[3] = result * v9;
	}
	return result;
}

//----- (00089520) --------------------------------------------------------
int sub_89520(signed __int16 *a1)
{
	int v1; // edi
	int v2; // ecx
	int v3; // esi
	int result; // eax
	int v5; // [esp+0h] [ebp-Ch]
	int v6; // [esp+4h] [ebp-8h]
	int v7; // [esp+8h] [ebp-4h]

	v5 = a1[2];
	v1 = a1[3];
	v2 = *a1 - v5 / 2;
	v3 = a1[1] - v1 / 2;
	if (v2 < a1[10])
		v2 = a1[10];
	if (v3 < a1[12])
		v3 = a1[12];
	v7 = a1[11];
	if (v2 + v5 >= v7)
		LOWORD(v2) = v7 - v5;
	v6 = a1[13];
	if (v3 + v1 >= v6)
		v3 = v6 - v1;
	*a1 = v2 + a1[2] / 2;
	a1[4] = v2;
	a1[5] = v3;
	result = v3 + v1 / 2;
	a1[1] = result;
	return result;
}

//----- (000895D0) --------------------------------------------------------
int sub_895D0(int a1, const char *a2)
{
	unsigned int v2; // edi
	int result; // eax
	char *i; // ebx
	char *v5; // eax
	char *v6; // edx
	char v7; // cl
	unsigned __int8 v8; // ST0C_1
	__int16 v9; // ST04_2
	int v10; // ebx
	char v11; // [esp+0h] [ebp-12h]
	int v12; // [esp+80h] [ebp+6Eh]
	int v13; // [esp+84h] [ebp+72h]
	unsigned int v14; // [esp+88h] [ebp+76h]

	v14 = (unsigned int)a2;
	v13 = *(signed __int16 *)(a1 + 10);
	v2 = (unsigned int)&a2[strlen(a2)];
	result = *(signed __int16 *)(a1 + 4) / *(signed __int16 *)(a1 + 16);
	v12 = *(signed __int16 *)(a1 + 4) / *(signed __int16 *)(a1 + 16);
	if (v2 > (unsigned int)a2)
	{
		do
		{
			for (i = (char *)(v12 + v14); *i != 32 && (unsigned int)i < v2; i--)
				;
			v5 = (char *)v14;
			v6 = &v11;
			while (v5 < i)
			{
				++v6;
				v7 = *v5++;
				*(v6 - 1) = v7;
			}
			*v6 = 0;
			v8 = *(x_BYTE *)(a1 + 48);
			v9 = *(x_WORD *)(a1 + 8);
			v14 = (unsigned int)(i + 1);
			v10 = v13;
			sub_2BC10_draw_text((Bit8u*)&v11, v9, v13, v8);
			result = *(signed __int16 *)(a1 + 18);
			v13 = result + v10;
		} while (v2 > v14);
	}
	return result;
}

//----- (00089690) --------------------------------------------------------
int sub_89690(signed __int16 *a1)
{
	__int16 v1; // ST0C_2
	int v2; // edi
	int v3; // esi
	//__int16 v4; // bx
	__int16 v5; // bx
	int result; // eax
	int i; // ebx
	__int16 v8; // [esp+Ch] [ebp-1Ch]
	int v9; // [esp+10h] [ebp-18h]
	__int16 v10; // [esp+14h] [ebp-14h]
	int v11; // [esp+18h] [ebp-10h]
	int v12; // [esp+1Ch] [ebp-Ch]
	int v13; // [esp+20h] [ebp-8h]
	__int16 v14; // [esp+24h] [ebp-4h]

				 // fix it//v11 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 1042);
				 // fix it//v12 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 1036);
				 // fix it//v1 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 1031);
				 // fix it//v10 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 1037);
	v12 = 0;  //fix it
	v2 = a1[18] - v12;
	v3 = a1[20] + a1[18];
	// fix it//v14 = a1[19] - *(unsigned __int8 *)(**filearray_2aa18c[6] + 1043);
	v8 = a1[19] + a1[21];
	// fix it//v4 = a1[19] - *(unsigned __int8 *)(**filearray_2aa18c[6] + 1043);
	v9 = a1[3] / a1[9];
	// fix it//sub_2BB40_draw_bitmap(a1[18] - v12, v14, (Bit8u**)(**filearray_2aa18c[6] + 1026));
	// fix it//sub_2BB40_draw_bitmap(v3, v4, (Bit8u**)(**filearray_2aa18c[6] + 1026));
	v1 = 0;v14 = 0;  //fix it
	v13 = 0;
	v5 = v1 + v14;
	while (v13 < v9)
	{
		// fix it//sub_2BB40_draw_bitmap(v2, v5, (Bit8u**)(**filearray_2aa18c[6] + 1032));
		// fix it//sub_2BB40_draw_bitmap(v3, v5, (Bit8u**)(**filearray_2aa18c[6] + 1032));
		v10 = 0;  //fix it
		v5 += v10;
		++v13;
	}
	// fix it//sub_2BB40_draw_bitmap(v2, v5, (Bit8u**)(**filearray_2aa18c[6] + 1026));
	// fix it//result = sub_2BB40_draw_bitmap(v3, v5, (Bit8u**)(**filearray_2aa18c[6] + 1026));
	v11 = 0;result = 0;  //fix it
	for (i = v2 + v12; i < v3; i += v11)
	{
		// fix it//sub_2BB40_draw_bitmap(i, v14, (Bit8u**)(**filearray_2aa18c[6] + 1038));
		// fix it//result = sub_2BB40_draw_bitmap(i, v8, (Bit8u**)(**filearray_2aa18c[6] + 1038));
	}
	return result;
}
// EA3DC: using guessed type int **filearray_2aa18c[6];

//----- (00089830) --------------------------------------------------------
int sub_89830(x_WORD *a1)
{
	int v1; // eax
	__int16 v2; // si
	int result; // eax
	int v4; // [esp+0h] [ebp-4h]

	v1 = (signed __int16)a1[14];
	v2 = v1 + 25;
	v4 = (signed __int16)a1[15];
	if ((signed __int16)a1[11] < v1 + 135)
		v2 = v1 - 135;
	result = v4 - 94;
	if (v4 - 94 + 28 < (signed __int16)a1[12])
		result = v4 + 66;
	*a1 = v2;
	a1[1] = result;
	return result;
}

//----- (000898A0) --------------------------------------------------------
x_WORD *sub_898A0(x_WORD *a1)
{
	x_WORD *result; // eax
	int v2; // ebx
	int v3; // edx
	__int16 v4; // dx
	int v5; // edx
	int v6; // ebx
	__int16 v7; // dx

	result = a1;
	v2 = (signed __int16)a1[18];
	v3 = (signed __int16)a1[14];
	if (v3 >= v2 - 30)
	{
		if (v3 <= (signed __int16)a1[20] + v2 + 30)
			v4 = *a1;
		else
			v4 = a1[20] + a1[18];
	}
	else
	{
		v4 = a1[18] - 2;
	}
	a1[16] = v4;
	v5 = (signed __int16)a1[19];
	v6 = (signed __int16)a1[15];
	if (v6 >= v5 - 30)
	{
		if (v6 > (signed __int16)a1[21] + v5 + 30)
		{
			a1[17] = a1[21] + a1[19];
			return result;
		}
		v7 = a1[1];
	}
	else
	{
		v7 = a1[19] - 2;
	}
	a1[17] = v7;
	return result;
}

//----- (00089920) --------------------------------------------------------
int sub_89920(x_WORD *a1, __int16 a2, int a3)
{
	signed int v3; // edx
	int v4; // ebx
	int result; // eax
	unsigned int v6; // kr04_4
	__int16 v7; // dx

	v3 = 0;
	v4 = 0;
	while (v3 < a2)
	{
		result = 0;
		v6 = strlen((const char *)x_DWORD_E9C4C_langindexbuffer[*(signed __int16 *)(a3 + 2 * v3)]) + 1;
		if ((signed int)(v6 - 1) > v4)
			v4 = v6 - 1;
		++v3;
	}
	v7 = a1[9];
	a1[2] = a1[8] * v4;
	a1[3] = v7 * a2;
	return result;
}

//----- (00089980) --------------------------------------------------------
int sub_89980(signed __int16 *a1)
{
	__int16 v1; // di
	int v2; // ecx
	__int16 v3; // ST00_2
	signed __int16 v4; // ax
	int v5; // edx
	signed __int16 v6; // ax
	int v7; // edx
	int result; // eax

				// fix it//v1 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 1043);
				// fix it//v2 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 1037);
				// fix it//v3 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 1031);
				// fix it//v4 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 1042)
				// fix it//   * (unsigned __int16)((*(unsigned __int8 *)(**filearray_2aa18c[6] + 1042) - 1 + a1[2] + 8)
				// fix it//                     / *(unsigned __int8 *)(**filearray_2aa18c[6] + 1042));
	v4 = 0;v2 = 0;v3 = 0; v1 = 0; //fix it
	v5 = a1[2];
	a1[20] = v4;
	a1[18] = a1[4] - (v4 - v5) / 2;
	v6 = (v2 - 1 + a1[3]) / v2 * v2 + 2 * (v3 - v1);
	v7 = a1[3];
	a1[21] = v6;
	result = (v6 - v7) / 2;
	a1[19] = a1[5] - result;
	return result;
}
// EA3DC: using guessed type int **filearray_2aa18c[6];

//----- (00089A30) --------------------------------------------------------
void sub_89A30(x_WORD *a1)
{
	__int16 v1; // si
	__int16 result = 0; // ax //fix it

	v1 = ((x_WORD_180660_VGA_type_resolution & 1) != 0) + 1;
	if (a1[16] != *a1 || (result = a1[17], result != a1[1]))
	{
		sub_2BD10(a1[14], a1[15], a1[16], a1[17], (unsigned __int8)*xadataclrd0dat.var28_begin_buffer);
		/*result = */sub_2BD10(a1[14] + v1, a1[15], v1 + a1[16], a1[17], x_BYTE_E9800);
	}
	//return result;
}
// E9800: using guessed type char x_BYTE_E9800;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00089AC0) --------------------------------------------------------
int sub_89AC0(x_BYTE *a1, int a2)
{
	int result; // eax
	signed int v3; // eax

	result = a2;
	if ((unsigned __int16)a2 < 0x5Cu)
		a1[0] = 0;
	else {
		if ((unsigned __int16)a2 <= 0x5Cu)
			return sprintf_s(a1, 512, "[F1] %s", x_DWORD_E9C4C_langindexbuffer[14]);
		if ((x_WORD)a2 == 96)
		{
			v3 = sub_61790((unsigned __int8)x_BYTE_180558);
			result = sprintf_s(a1, 512, (const char *)x_DWORD_E9C4C_langindexbuffer[353], (&off_D93A0_wizards_names2)[v3]);
		}
		else
		{
			a1[0] = 0;
		}
	}
	return result;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// D93A0: using guessed type const char *off_D93A0_wizards_names2;
// E9C84: using guessed type int x_DWORD_E9C84;
// EA1D0: using guessed type int x_DWORD_EA1D0;
// 180558: using guessed type char x_BYTE_180558;

//----- (00089B60) --------------------------------------------------------
Bit16s sub_89B60_aplicate_setting(Bit8u a1)
{
	Bit16s v1; // esi
	__int16 v2; // ax
	bool v3; // zf

	v1 = -1;
	x_DWORD_1805AC = 0;
	x_DWORD_1805A8 = 0;
	x_DWORD_1805A4 = 0;
	x_DWORD_180598 = 0;
	x_DWORD_180594 = 0;
	x_DWORD_180590 = 0;
	x_DWORD_1805A0 = 0;
	x_DWORD_18059C = 0;
	x_WORD_1805C8 = 0;
	switch (a1)
	{
	case 1u:
		v1 = sub_8B600((int)&unk_18058C);//fix it
		if ((signed __int16)v1 != -1)
			goto LABEL_3;
		break;
	case 2u:
		if ((unsigned __int16)sub_75650())//fix it
		{
			v1 = 1;
			myprintf("VFX INITIALISED\n");
			x_WORD_1805C8 = 1;
			v2 = a1;
			x_DWORD_1805A0 = 0;
			x_DWORD_18059C = 0;
			goto LABEL_12;
		}
		break;
	case 4u:
		memset(&unk_180560, 0, 44);//fix it
		sub_8BB40((int)&unk_180560, 8);
		v3 = x_BYTE_180584 == 0;
		goto LABEL_10;
	case 6u:
		memset(&unk_180560, 0, 44);//fix it
		v1 = 1;
		v2 = a1;
		goto LABEL_12;
	case 7u:
		v2 = a1;
		v1 = 1;
		goto LABEL_12;
	case 8u:
	case 9u:
	LABEL_3:
		x_WORD_1805C8 = 1;
		break;
	case 0xBu:
		memset(&unk_180560, 0, 44);//fix it
		sub_8BB40((int)&unk_180560, 4);
		v3 = x_BYTE_180584 == 0;
	LABEL_10:
		if (!v3)//fix it
		{
			sub_8BBE0((int)&unk_180560);
			v1 = 1;
			v2 = a1;
		LABEL_12:
			x_WORD_1805C2 = v2;
		}
		break;
	default:
		break;
	}
	x_WORD_1805C2 = a1;
	if ((signed __int16)v1 > 0)
		x_BYTE_E36D1 = a1;
	return v1;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// E36D1: using guessed type char x_BYTE_E36D1;
// 180584: using guessed type char x_BYTE_180584;
// 180590: using guessed type int x_DWORD_180590;
// 180594: using guessed type int x_DWORD_180594;
// 180598: using guessed type int x_DWORD_180598;
// 18059C: using guessed type int x_DWORD_18059C;
// 1805A0: using guessed type int x_DWORD_1805A0;
// 1805A4: using guessed type int x_DWORD_1805A4;
// 1805A8: using guessed type int x_DWORD_1805A8;
// 1805AC: using guessed type int x_DWORD_1805AC;
// 1805C2: using guessed type __int16 x_WORD_1805C2;
// 1805C8: using guessed type __int16 x_WORD_1805C8;

//----- (00089D10) --------------------------------------------------------
int sub_89D10()
{
	char v0; // bl
	char v2; // dl
	unsigned __int8 v3; // al
	int v4; // eax
	int v5; // ecx
	unsigned __int8 v6; // al
	int v7; // ebx
	signed int v8; // edx
	int v9; // edx
	signed int v10; // eax
	signed int v11; // eax
	signed int v12; // ecx
	int v13; // eax
	signed int v14; // edx
	signed int v15; // eax
	int v16; // ecx
	//signed int v17; // eax
	//signed int v18; // eax
	//unsigned __int8 v19; // al
	//int v20; // esi
	int v21; // ecx
	int v22; // ebx
	int v23; // eax
	//int v24; // ecx
	int v25; // eax
	__int64 v26; // rax
	__int64 v27; // rax
	__int16 v28; // si
	char v29; // dl
	char v30; // cl
	unsigned __int8 v31; // al
	int v32; // edx
	unsigned __int8 v33; // al
	int v34; // edx
	signed int v35; // edx
	signed int v36; // eax
	char v37; // ch
	int v38; // edx
	int v39; // edx
	signed int v40; // edx
	int v41; // ebx
	signed int v42; // eax
	signed int v43; // ecx
	//signed int v44; // eax
	//int v45; // ebx
	//int v46; // ecx
	//signed int v47; // eax
	//int v48; // esi
	//signed int v49; // eax
	//unsigned __int8 v50; // al
	//int v51; // esi
	int v52; // ecx
	int v53; // ebx
	int v54; // eax
	//int v55; // ecx
	char v56; // [esp+0h] [ebp-48h]
	int v57; // [esp+34h] [ebp-14h]
	int v58; // [esp+38h] [ebp-10h]
	int v59; // [esp+3Ch] [ebp-Ch]
	int v60; // [esp+40h] [ebp-8h]
	int v61; // [esp+44h] [ebp-4h]

	v61 = -1;
	if (!x_BYTE_E36D0)
	{
		x_DWORD_1805A0 = 0;
		x_DWORD_18059C = 0;
		x_BYTE_E36D0 = 1;
	}
	if (!x_BYTE_E36D1)
		return v61;
	switch (x_WORD_1805C2)
	{
	case 1:
	case 8:
	case 12:
		x_WORD_1805C8 = 1;
		v61 = sub_8B790((x_DWORD*)&unk_18058C);
		if (x_WORD_1805C2 != 8 && x_WORD_1805C2 != 12)
		{
			x_DWORD_1805B0 = x_WORD_E3760_mousex;
			x_DWORD_1805B4 = x_WORD_E3762_mousey;
			x_DWORD_1805B8 = x_WORD_E375C_mouse_position_x;
			x_DWORD_1805BC = x_WORD_E375E_mouse_position_y;
			v0 = x_BYTE_180664[x_BYTE_EB39E_keys[0]];
			x_WORD_1805C0 = 0;
			if (v0)
				x_WORD_1805C0 = 1;
			if (x_BYTE_180664[x_BYTE_EB39E_keys[1]])
				LOBYTE(x_WORD_1805C0) = x_WORD_1805C0 | 2;
			if (x_BYTE_180664[x_BYTE_EB39E_keys[2]])
				LOBYTE(x_WORD_1805C0) = x_WORD_1805C0 | 4;
			if (x_BYTE_180664[x_BYTE_EB39E_keys[3]])
				LOBYTE(x_WORD_1805C0) = x_WORD_1805C0 | 8;
			x_DWORD_18059C = 0;
			if (x_WORD_180746)
				x_DWORD_18059C = 1;
			if (x_WORD_180744)
				LOBYTE(x_DWORD_18059C) = x_DWORD_18059C | 2;
			if (x_WORD_18074C)
				LOBYTE(x_DWORD_18059C) = x_DWORD_18059C | 4;
			if (x_WORD_18074A)
				LOBYTE(x_DWORD_18059C) = x_DWORD_18059C | 8;
			if (x_BYTE_180664[x_BYTE_EB39E_keys[5]])
				LOBYTE(x_DWORD_18059C) = x_DWORD_18059C | 0x10;
		}
		x_DWORD_180594 *= 4;
		x_DWORD_180590 = (x_DWORD_180590 << 11) / 360;
		if (x_WORD_1805C2 == 8)
			goto LABEL_53;
		if (x_WORD_1805C2 == 12)
			goto LABEL_217;
		return v61;
	case 2:
	case 9:
	case 13:
		x_WORD_1805C8 = 1;
		sub_75910();
		if (x_WORD_1805C2 != 9 && x_WORD_1805C2 != 13)
		{
			x_DWORD_1805B0 = x_WORD_E3760_mousex;
			x_DWORD_1805B4 = x_WORD_E3762_mousey;
			x_DWORD_1805B8 = x_WORD_E375C_mouse_position_x;
			x_DWORD_1805BC = x_WORD_E375E_mouse_position_y;
			v2 = x_BYTE_180664[x_BYTE_EB39E_keys[0]];
			x_WORD_1805C0 = 0;
			if (v2)
				x_WORD_1805C0 = 1;
			if (x_BYTE_180664[x_BYTE_EB39E_keys[1]])
				LOBYTE(x_WORD_1805C0) = x_WORD_1805C0 | 2;
			if (x_BYTE_180664[x_BYTE_EB39E_keys[2]])
				LOBYTE(x_WORD_1805C0) = x_WORD_1805C0 | 4;
			if (x_BYTE_180664[x_BYTE_EB39E_keys[3]])
				LOBYTE(x_WORD_1805C0) = x_WORD_1805C0 | 8;
			x_DWORD_18059C = 0;
			if (x_WORD_180746)
				x_DWORD_18059C = 1;
			if (x_WORD_180744)
				LOBYTE(x_DWORD_18059C) = x_DWORD_18059C | 2;
			if (x_WORD_18074C)
				LOBYTE(x_DWORD_18059C) = x_DWORD_18059C | 4;
			if (x_WORD_18074A)
				LOBYTE(x_DWORD_18059C) = x_DWORD_18059C | 8;
			if (x_BYTE_180664[x_BYTE_EB39E_keys[5]])
				LOBYTE(x_DWORD_18059C) = x_DWORD_18059C | 0x10;
		}
		x_DWORD_180590 = -2048 * x_WORD_17D6CC / 0xFFFFu & 0x7FF;
		if (x_BYTE_1806E4 == 46)
			sub_759B0_set_mouse_minmax_vert();
		if (x_WORD_1805C2 == 9)
			goto LABEL_53;
		if (x_WORD_1805C2 == 13)
			goto LABEL_217;
		x_DWORD_180594 = 0;
		return v61;
	case 4:
	LABEL_53:
		x_WORD_1805C0 = 0;
		sub_8BBE0((int)&unk_180560);
		goto LABEL_54;
	case 6:
		memset(&v56, 0, 50);
		sub_8C140(*(x_WORD *)x_DWORD_E36C4, (int)&v56);
		x_DWORD_180590 = *(x_DWORD *)(x_DWORD_E36C4 + 4);
		v28 = *(x_WORD *)(x_DWORD_E36C4 + 62);
		x_DWORD_180594 = *(x_DWORD *)(x_DWORD_E36C4 + 8);
		if (!v28)
		{
			x_DWORD_1805B0 = x_WORD_E3760_mousex;
			x_DWORD_1805B4 = x_WORD_E3762_mousey;
			x_DWORD_1805B8 = x_WORD_E375C_mouse_position_x;
			x_DWORD_1805BC = x_WORD_E375E_mouse_position_y;
			v29 = x_BYTE_180664[x_BYTE_EB39E_keys[0]];
			x_WORD_1805C0 = 0;
			if (v29)
				x_WORD_1805C0 = 1;
			if (x_BYTE_180664[x_BYTE_EB39E_keys[1]])
				LOBYTE(x_WORD_1805C0) = x_WORD_1805C0 | 2;
			if (x_BYTE_180664[x_BYTE_EB39E_keys[2]])
				LOBYTE(x_WORD_1805C0) = x_WORD_1805C0 | 4;
			if (x_BYTE_180664[x_BYTE_EB39E_keys[3]])
				LOBYTE(x_WORD_1805C0) = x_WORD_1805C0 | 8;
			x_DWORD_18059C = 0;
			if (x_WORD_180746)
				x_DWORD_18059C = 1;
			if (x_WORD_180744)
				LOBYTE(x_DWORD_18059C) = x_DWORD_18059C | 2;
			if (x_WORD_18074C)
				LOBYTE(x_DWORD_18059C) = x_DWORD_18059C | 4;
			if (x_WORD_18074A)
				LOBYTE(x_DWORD_18059C) = x_DWORD_18059C | 8;
			if (x_BYTE_180664[x_BYTE_EB39E_keys[5]])
			{
				LOBYTE(x_DWORD_18059C) = x_DWORD_18059C | 0x10;
				return v61;
			}
			return v61;
		}
		if (v28 != 4)
		{
			if (v28 != 11)
				return v61;
			x_BYTE_180586 = *(x_BYTE *)(x_DWORD_E36C4 + 16);
			x_BYTE_180588 = x_DWORD_1805B0;
			x_BYTE_180589 = x_DWORD_1805B4;
		LABEL_218:
			if (!(x_BYTE_180586 & 1) || x_BYTE_180587 & 1)
			{
				if (!(x_BYTE_180586 & 1) && x_BYTE_180587 & 1)
				{
					LOBYTE(x_DWORD_18059C) = x_DWORD_18059C & 0xFA;
					x_BYTE_180587 &= 0xFEu;
				}
			}
			else
			{
				x_DWORD_1805B8 = x_DWORD_1805B0;
				LOBYTE(x_DWORD_18059C) = x_DWORD_18059C | 5;
				x_DWORD_1805BC = x_DWORD_1805B4;
				x_BYTE_180587 |= 1u;
			}
			if (!(x_BYTE_180586 & 2) || x_BYTE_180587 & 2)
			{
				if (!(x_BYTE_180586 & 2) && x_BYTE_180587 & 2)
				{
					LOBYTE(x_DWORD_18059C) = x_DWORD_18059C & 0xF5;
					x_BYTE_180587 &= 0xFDu;
				}
			}
			else
			{
				x_DWORD_1805B8 = x_DWORD_1805B0;
				LOBYTE(x_DWORD_18059C) = x_DWORD_18059C | 0xA;
				x_DWORD_1805BC = x_DWORD_1805B4;
				x_BYTE_180587 |= 2u;
			}
			if (x_BYTE_180664[x_BYTE_EB39E_keys[5]])
			{
				x_BYTE_180587 &= 0xF7u;
				x_BYTE_180586 &= 0xF7u;
				LOBYTE(x_DWORD_18059C) = x_DWORD_18059C | 0x10;
			}
			else if (!(x_BYTE_180586 & 8) || x_BYTE_180587 & 8 || x_DWORD_18059C & 0x10)
			{
				if (x_BYTE_180586 & 8 || !(x_BYTE_180587 & 8) || x_DWORD_18059C & 0x10)
				{
					if (x_BYTE_180586 & 8 && x_BYTE_180587 & 8 && x_DWORD_18059C & 0x10)
					{
						x_BYTE_180587 &= 0xF7u;
						x_BYTE_180586 &= 0xF7u;
					}
					else if (!(x_BYTE_180586 & 8) && !(x_BYTE_180587 & 8) && x_DWORD_18059C & 0x10)
					{
						LOBYTE(x_DWORD_18059C) = x_DWORD_18059C & 0xEF;
					}
				}
				else
				{
					LOBYTE(x_DWORD_18059C) = x_DWORD_18059C | 0x10;
				}
			}
			else
			{
				x_BYTE_180587 |= 8u;
			}
			v31 = *(x_BYTE *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 12221);
			if (v31 < 5u)
			{
				if (v31 == 3)
				{
					/*if ( 82 - *(unsigned __int8 *)(**filearray_2aa18c[6] + 934) <= x_DWORD_1805B0 ) //fix it
					{
					  if ( x_DWORD_1805B0 >= 384 )
					  {
						if ( x_WORD_180660_VGA_type_resolution & 1 )
						  v49 = 400;
						else
						  v49 = 480;
						v60 = v49 - 72;
						if ( v49 - 46 >= x_DWORD_1805B4 )
						  v50 = *(x_BYTE *)(**filearray_2aa18c[6] + 1558);
						else
						  v50 = *(x_BYTE *)(**filearray_2aa18c[6] + 946);
						v42 = (signed int)v50 >> 2;
						v9 = ((signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 947) >> 1) + v60 + 26;
						v51 = ((signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 1559) >> 1) + 4 + v60;
						v59 = 0;
						v60 = v51;
						v41 = 640;
						v43 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 1559);
					  }
					  else
					  {
						if ( x_WORD_180660_VGA_type_resolution & 1 )
						  v47 = 400;
						else
						  v47 = 480;
						v60 = v47 - 72;
						v48 = ((signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 929) >> 1) + 32 + v47 - 72;
						v59 = 0;
						v60 = v48;
						v41 = 640;
						v9 = v48;
						v42 = (signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 928) >> 2;
						v43 = (signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 929) >> 1;
					  }
					}
					else
					{
					  if ( x_WORD_180660_VGA_type_resolution & 1 )
						v44 = 400;
					  else
						v44 = 480;
					  v60 = v44 - 72;
					  v45 = ((signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 935) >> 1) + 28 + v44 - 72;
					  v60 = v45;
					  v59 = ((signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 934) >> 1) + 4;
					  v46 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 935);
					  v9 = v45 + v46;
					  v43 = v46 >> 1;
					  v42 = (signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 934) >> 2;
					  v41 = v59 + 640 - ((signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 934) >> 1);
					}*/
					goto LABEL_301;
				}
			}
			else if (v31 <= 5u || v31 == 8)
			{
				v32 = (int)x_D41A0_BYTEARRAY_0 + 11230 + 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12;
				v33 = *(x_BYTE *)(v32 + 2109);
				v34 = v32 + 1609;
				if (v33)
				{
					if (v33 <= 2u)
					{
						// fix it//v58 = 3 * *(unsigned __int8 *)(**filearray_2aa18c[6] + 982);
						v37 = *(x_BYTE *)(v34 + 501);
						if (v37 < 13)
							v38 = v37;
						else
							v38 = v37 - 13;
						/*v39 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 532)
							+ *(unsigned __int8 *)(**filearray_2aa18c[6] + 538) * v38
							+ ((signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 538) >> 1)
							- (v58 >> 1);*/ //fix it
						v39 = 0;v58 = 0;  //fix it
						v59 = v39;
						if (640 - v58 >= v39)
						{
							if (v39 < 0)
								v59 = 0;
						}
						else
						{
							v59 = 640 - v58;
						}
						v41 = v58 + v59;
						if (x_WORD_180660_VGA_type_resolution & 1)
							v40 = 400;
						else
							v40 = 480;
						/*v9 = v40
						   - 2 * *(unsigned __int8 *)(**filearray_2aa18c[6] + 539)
						   - ((signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 539) >> 1);
						v60 = v9;
						v42 = (signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 982) >> 2;
						v43 = (signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 983) >> 1;*/ //fix it
					}
					else
					{
						v41 = 640;
						v9 = 480;
						v42 = 12;
						v43 = 32;
						v59 = 0;
						v60 = 0;
					}
				}
				else
				{
					v41 = 640;
					v59 = 0;
					if (x_WORD_180660_VGA_type_resolution & 1)
						v35 = 400;
					else
						v35 = 480;
					// fix it//v9 = v35 - ((signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 539) >> 1);
					if (x_WORD_180660_VGA_type_resolution & 1)
						v36 = 400;
					else
						v36 = 480;
					v60 = v36;
					// fix it//v60 = v36 - 2 * *(unsigned __int8 *)(**filearray_2aa18c[6] + 539);
					// fix it//v60 += (signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 539) >> 1;
					// fix it//v42 = (signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 538) >> 2;
					// fix it//v43 = (signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 539) >> 1;
				}
				goto LABEL_301;
			}
			if (x_D41A0_BYTEARRAY_4[0x9692])
			{
				sub_30BE0(&v59, &v60);
				// fix it//v59 += (signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 1546) >> 1;
				// fix it//v52 = ((signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 1547) >> 1) + v60;
				v52 = 0;  //fix it
				v60 = v52;
				// fix it//v42 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 1546);
				v42 = 0;  //fix it
				v9 = v52;
				v41 = v42 + v59;
				v43 = 0;
			}
			else if (x_D41A0_BYTEARRAY_4[0xE1])
			{
				v53 = x_D41A0_BYTEARRAY_4[0xBA];
				v43 = 4;
				v60 = 67;
				v54 = (v53 >> 1) + (640 - v53) / 2;
				v9 = 393;
				x_DWORD_1805B0 = v54;
				v41 = (v53 >> 1) + (640 - v53) / 2;
				v59 = v54;
				v42 = 0;
			}
			else if (x_D41A0_BYTEARRAY_4[0x96BF])
			{
				sub_2FFE0(&v59, &v60, &v58, &v57);
				v58 -= 2;
				v41 = v58 + v59;
				v9 = 4 * v57 + 12 + v60;
				v43 = 0;
				v42 = 4;
				v60 += 4 * v57 + 12;
			}
			else if (x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 1)
			{
				/*v58 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 1048);
				v57 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 1073)
					+ *(unsigned __int8 *)(**filearray_2aa18c[6] + 1061)
					+ *(unsigned __int8 *)(**filearray_2aa18c[6] + 1055)
					+ *(unsigned __int8 *)(**filearray_2aa18c[6] + 1049);
				v60 = ((signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 1049) >> 1) + (400 - v57) / 2 - 60;
				v59 = ((signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 1048) >> 2) + (640 - v58) / 2;
				v55 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 1049);
				v9 = v57 + v60 - v55;
				v43 = v55 >> 2;
				v42 = (signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 1048) >> 2;
				v41 = v58 + v59 - ((signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 1048) >> 1);*/ // fix it
			}
			else
			{
				v41 = 640;
				v9 = 480;
				v43 = 32;
				v59 = 0;
				v60 = 0;
				v42 = 12;
			}
		LABEL_301:
			if (!(x_DWORD_18059C & 0x10)
				&& !(x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 1)
				&& !x_D41A0_BYTEARRAY_4[0x9692]
				&& !x_D41A0_BYTEARRAY_4[0xE1]
				&& *(x_BYTE *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 12221) != 3)
			{
				if (x_BYTE_180586 & 4)
				{
					if (x_BYTE_180589 < 0)
						x_WORD_1805C0 |= 1u;
					if (x_BYTE_180589 > 0)
						LOBYTE(x_WORD_1805C0) = x_WORD_1805C0 | 2;
					if (x_BYTE_180588 < 0)
						LOBYTE(x_WORD_1805C0) = x_WORD_1805C0 | 4;
					if (x_BYTE_180588 > 0)
						LOBYTE(x_WORD_1805C0) = x_WORD_1805C0 | 8;
				}
				else
				{
					x_WORD_E36CC = x_BYTE_180588;
					x_WORD_E36CE = x_BYTE_180589;
					x_DWORD_1805B0 = 2 * x_BYTE_180588 + 320;
					x_DWORD_1805B4 = 2 * x_BYTE_180589 + 200;
					if (x_BYTE_180664[x_BYTE_EB39E_keys[0]])
						x_WORD_1805C0 |= 1u;
					if (x_BYTE_180664[x_BYTE_EB39E_keys[1]])
						LOBYTE(x_WORD_1805C0) = x_WORD_1805C0 | 2;
					if (x_BYTE_180664[x_BYTE_EB39E_keys[2]])
						LOBYTE(x_WORD_1805C0) = x_WORD_1805C0 | 4;
					if (x_BYTE_180664[x_BYTE_EB39E_keys[3]])
					{
						LOBYTE(x_WORD_1805C0) = x_WORD_1805C0 | 8;
						return v61;
					}
				}
				return v61;
			}
			if (x_BYTE_180589 >= 0)
			{
				if (x_BYTE_180589 > 0)
					x_DWORD_1805B4 += v43;
			}
			else
			{
				x_DWORD_1805B4 -= v43;
			}
			if (x_BYTE_180588 >= 0)
			{
				if (x_BYTE_180588 > 0)
					x_DWORD_1805B0 += v42;
			}
			else
			{
				x_DWORD_1805B0 -= v42;
			}
			if (x_DWORD_1805B0 >= v59)
			{
				if (v41 < x_DWORD_1805B0)
					x_DWORD_1805B0 = v41;
			}
			else
			{
				x_DWORD_1805B0 = v59;
			}
			v25 = x_DWORD_1805B4;
			if (x_DWORD_1805B4 < v60)
			{
				x_DWORD_1805B4 = v60;
				return v61;
			}
		LABEL_157:
			if (v9 >= v25)
				return v61;
			x_DWORD_1805B4 = v9;
			return v61;
		}
		x_BYTE_180586 = *(x_BYTE *)(x_DWORD_E36C4 + 16);
		x_BYTE_180588 = x_DWORD_1805B0;
		x_BYTE_180589 = x_DWORD_1805B4;
	LABEL_54:
		if (!(x_BYTE_180586 & 1) || x_BYTE_180587 & 1)
		{
			if (!(x_BYTE_180586 & 1) && x_BYTE_180587 & 1)
			{
				LOBYTE(x_DWORD_18059C) = x_DWORD_18059C & 0xFA;
				x_BYTE_180587 &= 0xFEu;
			}
		}
		else
		{
			LOBYTE(x_DWORD_18059C) = x_DWORD_18059C | 5;
			x_DWORD_1805B8 = x_DWORD_1805B0;
			x_BYTE_180587 |= 1u;
			x_DWORD_1805BC = x_DWORD_1805B4;
		}
		if (!(x_BYTE_180586 & 2) || x_BYTE_180587 & 2)
		{
			if (!(x_BYTE_180586 & 2) && x_BYTE_180587 & 2)
			{
				LOBYTE(x_DWORD_18059C) = x_DWORD_18059C & 0xF5;
				x_BYTE_180587 &= 0xFDu;
			}
		}
		else
		{
			LOBYTE(x_DWORD_18059C) = x_DWORD_18059C | 0xA;
			x_DWORD_1805B8 = x_DWORD_1805B0;
			x_BYTE_180587 |= 2u;
			x_DWORD_1805BC = x_DWORD_1805B4;
		}
		if (x_BYTE_180664[x_BYTE_EB39E_keys[5]])
		{
			x_BYTE_180586 &= 0xF7u;
			LOBYTE(x_DWORD_18059C) = x_DWORD_18059C | 0x10;
			x_BYTE_180587 &= 0xF7u;
		}
		else if (!(x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 1))
		{
			if (!(x_BYTE_180586 & 8) || x_BYTE_180587 & 8 || x_DWORD_18059C & 0x10)
			{
				if (x_BYTE_180586 & 8 || !(x_BYTE_180587 & 8) || x_DWORD_18059C & 0x10)
				{
					if (x_BYTE_180586 & 8 && x_BYTE_180587 & 8 && x_DWORD_18059C & 0x10)
					{
						x_BYTE_180587 &= 0xF7u;
						x_BYTE_180586 &= 0xF7u;
					}
					else if (!(x_BYTE_180586 & 8) && !(x_BYTE_180587 & 8) && x_DWORD_18059C & 0x10)
					{
						LOBYTE(x_DWORD_18059C) = x_DWORD_18059C & 0xEF;
					}
				}
				else
				{
					LOBYTE(x_DWORD_18059C) = x_DWORD_18059C | 0x10;
				}
			}
			else
			{
				x_BYTE_180587 |= 8u;
			}
		}
		v3 = *(x_BYTE *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 12221);
		if (v3 < 5u)
		{
			if (v3 == 3)
			{
				/*if ( 82 - *(unsigned __int8 *)(**filearray_2aa18c[6] + 934) <= x_DWORD_1805B0 ) // fix it
				{
				  if ( x_DWORD_1805B0 >= 384 )
				  {
					if ( x_WORD_180660_VGA_type_resolution & 1 )
					  v18 = 400;
					else
					  v18 = 480;
					v60 = v18 - 72;
					if ( v18 - 46 >= x_DWORD_1805B4 )
					  v19 = *(x_BYTE *)(**filearray_2aa18c[6] + 1558);
					else
					  v19 = *(x_BYTE *)(**filearray_2aa18c[6] + 946);
					v11 = (signed int)v19 >> 2;
					v9 = v60 + 26 + ((signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 947) >> 1);
					v20 = ((signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 1559) >> 1) + 4 + v60;
					v59 = 0;
					v60 = v20;
					v7 = 640;
					v12 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 1559);
				  }
				  else
				  {
					if ( x_WORD_180660_VGA_type_resolution & 1 )
					  v17 = 400;
					else
					  v17 = 480;
					v60 = v17 - 72;
					v9 = ((signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 929) >> 1) + 32 + v17 - 72;
					v59 = 0;
					v60 = v9;
					v7 = 640;
					v11 = (signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 928) >> 2;
					v12 = (signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 929) >> 1;
				  }
				}
				else*/
				{
					if (x_WORD_180660_VGA_type_resolution & 1)
						v15 = 400;
					else
						v15 = 480;
					v60 = v15 - 72;
					// fix it//v60 = ((signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 935) >> 1) + 28 + v15 - 72;
					// fix it//v59 = ((signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 934) >> 1) + 4;
					// fix it//v16 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 935);
					v16 = 0;  //fix it
					v9 = v60 + v16;
					v12 = v16 >> 1;
					// fix it//v11 = (signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 934) >> 2;
					// fix it//v7 = v59 + 640 - ((signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 934) >> 1);
				}
				goto LABEL_138;
			}
		}
		else if (v3 <= 5u || v3 == 8)
		{
			v4 = 2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + (int)x_D41A0_BYTEARRAY_0 + 11230;
			v5 = v4 + 1609;
			v6 = *(x_BYTE *)(v4 + 2109);
			if (!v6)
			{
				v7 = 640;
				v59 = 0;
				if (x_WORD_180660_VGA_type_resolution & 1)
					v8 = 400;
				else
					v8 = 480;
				// fix it//v9 = v8 - ((signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 539) >> 1);
				if (x_WORD_180660_VGA_type_resolution & 1)
					v10 = 400;
				else
					v10 = 480;
				v60 = v10;
				// fix it//v60 = v10 - 2 * *(unsigned __int8 *)(**filearray_2aa18c[6] + 539);
				// fix it//v60 += (signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 539) >> 1;
				// fix it//v11 = (signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 538) >> 2;
				// fix it//v12 = (signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 539) >> 1;
				goto LABEL_138;
			}
			if (v6 <= 2u)
			{
				// fix it//v58 = 3 * *(unsigned __int8 *)(**filearray_2aa18c[6] + 982);
				LOBYTE(v13) = *(x_BYTE *)(v5 + 501);
				if ((char)v13 < 13)
					v13 = (char)v13;
				else
					v13 = (char)v13 - 13;
				/*v59 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 538) * v13
					+ *(unsigned __int8 *)(**filearray_2aa18c[6] + 532)
					+ ((signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 538) >> 1)
					- (v58 >> 1);*/ //fix it
				if (640 - v58 >= v59)
				{
					if (v59 < 0)
						v59 = 0;
				}
				else
				{
					v59 = 640 - v58;
				}
				v7 = v58 + v59;
				if (x_WORD_180660_VGA_type_resolution & 1)
					v14 = 400;
				else
					v14 = 480;
				/*v9 = v14
				   - 2 * *(unsigned __int8 *)(**filearray_2aa18c[6] + 539)
				   - ((signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 539) >> 1);
				v60 = v9;
				v11 = (signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 982) >> 2;
				v12 = (signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 983) >> 1;*/ //fix it
				goto LABEL_138;
			}
			goto LABEL_137;
		}
		if (x_D41A0_BYTEARRAY_4[0x9692])
		{
			sub_30BE0(&v59, &v60);
			/*v59 += (signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 1546) >> 1;
			v21 = ((signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 1547) >> 1) + v60;
			v60 = v21;
			v11 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 1546);*/ // fix it
			v21 = 0; v11 = 0; //fix it
			v9 = v21;
			v7 = v11 + v59;
			v12 = 0;
			goto LABEL_138;
		}
		if (x_D41A0_BYTEARRAY_4[0xE1])
		{
			v22 = x_D41A0_BYTEARRAY_4[0xBA];
			v12 = 4;
			v60 = 67;
			v23 = (v22 >> 1) + (640 - v22) / 2;
			v9 = 393;
			x_DWORD_1805B0 = v23;
			v7 = (v22 >> 1) + (640 - v22) / 2;
			v59 = v23;
			v11 = 0;
			goto LABEL_138;
		}
		if (x_D41A0_BYTEARRAY_4[0x96BF])
		{
			sub_2FFE0(&v59, &v60, &v58, &v57);
			v58 -= 2;
			v7 = v58 + v59;
			v9 = 4 * v57 + 12 + v60;
			v12 = 0;
			v11 = 4;
			v60 += 4 * v57 + 12;
			goto LABEL_138;
		}
		if (x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 1)
		{
			/*v58 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 1048);
			v57 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 1073)
				+ *(unsigned __int8 *)(**filearray_2aa18c[6] + 1061)
				+ *(unsigned __int8 *)(**filearray_2aa18c[6] + 1055)
				+ *(unsigned __int8 *)(**filearray_2aa18c[6] + 1049);
			v60 = ((signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 1049) >> 1) + (400 - v57) / 2 - 60;
			v59 = ((signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 1048) >> 2) + (640 - v58) / 2;
			v24 = *(unsigned __int8 *)(**filearray_2aa18c[6] + 1049);
			v9 = v57 + v60 - v24;
			v12 = v24 >> 2;
			v11 = (signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 1048) >> 2;
			v7 = v58 + v59 - ((signed int)*(unsigned __int8 *)(**filearray_2aa18c[6] + 1048) >> 1);
			goto LABEL_138;*/ //fix it
		}
	LABEL_137:
		v7 = 640;
		v9 = 480;
		v12 = 32;
		v59 = 0;
		v60 = 0;
		v11 = 12;
	LABEL_138:
		if (x_DWORD_18059C & 0x10
			|| x_D41A0_BYTEARRAY_4_struct.setting_byte3_24 & 1
			|| x_D41A0_BYTEARRAY_4[0x9692]
			|| x_D41A0_BYTEARRAY_4[0xE1]
			|| *(x_BYTE *)(2124 * x_D41A0_BYTEARRAY_4_struct.dwordindex_12 + x_D41A0_BYTEARRAY_0 + 12221) == 3)
		{
			if (x_BYTE_180589 >= 0)
			{
				if (x_BYTE_180589 > 0)
					x_DWORD_1805B4 += v12;
			}
			else
			{
				x_DWORD_1805B4 -= v12;
			}
			if (x_BYTE_180588 >= 0)
			{
				if (x_BYTE_180588 > 0)
					x_DWORD_1805B0 += v11;
			}
			else
			{
				x_DWORD_1805B0 -= v11;
			}
			if (x_DWORD_1805B0 >= v59)
			{
				if (v7 < x_DWORD_1805B0)
					x_DWORD_1805B0 = v7;
			}
			else
			{
				x_DWORD_1805B0 = v59;
			}
			v25 = x_DWORD_1805B4;
			if (x_DWORD_1805B4 < v60)
			{
				x_DWORD_1805B4 = v60;
				return v61;
			}
			goto LABEL_157;
		}
		if (x_BYTE_180586 & 4)
		{
			if (x_BYTE_180589 < 0)
				x_WORD_1805C0 |= 1u;
			if (x_BYTE_180589 > 0)
				LOBYTE(x_WORD_1805C0) = x_WORD_1805C0 | 2;
			if (x_BYTE_180588 < 0)
				LOBYTE(x_WORD_1805C0) = x_WORD_1805C0 | 4;
			if (x_BYTE_180588 > 0)
			{
				LOBYTE(x_WORD_1805C0) = x_WORD_1805C0 | 8;
				return v61;
			}
		}
		else
		{
			v26 = 28 * (signed __int16)(32 * x_BYTE_180588 + x_WORD_E36CC);
			x_WORD_E36CC = (signed int)(v26 - (__CFSHL__(HIDWORD(v26), 5) + 32 * HIDWORD(v26))) >> 5;
			v27 = 31 * (signed __int16)(16 * x_BYTE_180589 + x_WORD_E36CE);
			x_WORD_E36CE = (signed int)(v27 - (__CFSHL__(HIDWORD(v27), 5) + 32 * HIDWORD(v27))) >> 5;
			x_DWORD_1805B0 = 2 * x_WORD_E36CC + 320;
			x_DWORD_1805B4 = 2 * x_WORD_E36CE + 200;
			if (x_BYTE_180664[x_BYTE_EB39E_keys[0]])
				x_WORD_1805C0 |= 1u;
			if (x_BYTE_180664[x_BYTE_EB39E_keys[1]])
				LOBYTE(x_WORD_1805C0) = x_WORD_1805C0 | 2;
			if (x_BYTE_180664[x_BYTE_EB39E_keys[2]])
				LOBYTE(x_WORD_1805C0) = x_WORD_1805C0 | 4;
			if (x_BYTE_180664[x_BYTE_EB39E_keys[3]])
			{
				LOBYTE(x_WORD_1805C0) = x_WORD_1805C0 | 8;
				return v61;
			}
		}
		return v61;
	case 7:
		x_DWORD_1805B0 = x_WORD_E3760_mousex;
		x_DWORD_1805B4 = x_WORD_E3762_mousey;
		x_DWORD_1805B8 = x_WORD_E375C_mouse_position_x;
		x_DWORD_1805BC = x_WORD_E375E_mouse_position_y;
		v30 = x_BYTE_180664[x_BYTE_EB39E_keys[0]];
		x_WORD_1805C0 = 0;
		if (v30)
			x_WORD_1805C0 = 1;
		if (x_BYTE_180664[x_BYTE_EB39E_keys[1]])
			LOBYTE(x_WORD_1805C0) = x_WORD_1805C0 | 2;
		if (x_BYTE_180664[x_BYTE_EB39E_keys[2]])
			LOBYTE(x_WORD_1805C0) = x_WORD_1805C0 | 4;
		if (x_BYTE_180664[x_BYTE_EB39E_keys[3]])
			LOBYTE(x_WORD_1805C0) = x_WORD_1805C0 | 8;
		x_DWORD_18059C = 0;
		if (x_WORD_180746)
			x_DWORD_18059C = 1;
		if (x_WORD_180744)
			LOBYTE(x_DWORD_18059C) = x_DWORD_18059C | 2;
		if (x_WORD_18074C)
			LOBYTE(x_DWORD_18059C) = x_DWORD_18059C | 4;
		if (x_WORD_18074A)
			LOBYTE(x_DWORD_18059C) = x_DWORD_18059C | 8;
		if (!x_BYTE_180664[x_BYTE_EB39E_keys[5]])
			return v61;
		LOBYTE(x_DWORD_18059C) = x_DWORD_18059C | 0x10;
		return v61;
	case 11:
	LABEL_217:
		x_WORD_1805C0 = 0;
		sub_8BBE0((int)&unk_180560);
		goto LABEL_218;
	default:
		return v61;
	}
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D41A0: using guessed type int x_D41A0_BYTEARRAY_0;
// D41A4: using guessed type int x_DWORD_D41A4;
// E36C4: using guessed type int x_DWORD_E36C4;
// E36CC: using guessed type __int16 x_WORD_E36CC;
// E36CE: using guessed type __int16 x_WORD_E36CE;
// E36D0: using guessed type char x_BYTE_E36D0;
// E36D1: using guessed type char x_BYTE_E36D1;
// E375C: using guessed type __int16 x_WORD_E375C_mouse_position_x;
// E375E: using guessed type __int16 x_WORD_E375E_mouse_position_y;
// E3760: using guessed type int x_DWORD_E3760;
// EA3DC: using guessed type int **filearray_2aa18c[6];
// EB39E: using guessed type char x_BYTE_EB39E_keys;
// EB39F: using guessed type char x_BYTE_EB39F;
// EB3A0: using guessed type char x_BYTE_EB3A0;
// EB3A1: using guessed type char x_BYTE_EB3A1;
// EB3A3: using guessed type char x_BYTE_EB3A3;
// 17D6CC: using guessed type __int16 x_WORD_17D6CC;
// 180586: using guessed type char x_BYTE_180586;
// 180587: using guessed type char x_BYTE_180587;
// 180588: using guessed type char x_BYTE_180588;
// 180589: using guessed type char x_BYTE_180589;
// 180590: using guessed type int x_DWORD_180590;
// 180594: using guessed type int x_DWORD_180594;
// 180598: using guessed type int x_DWORD_180598;
// 18059C: using guessed type int x_DWORD_18059C;
// 1805A0: using guessed type int x_DWORD_1805A0;
// 1805B0: using guessed type int x_DWORD_1805B0;
// 1805B4: using guessed type int x_DWORD_1805B4;
// 1805B8: using guessed type int x_DWORD_1805B8;
// 1805BC: using guessed type int x_DWORD_1805BC;
// 1805C0: using guessed type __int16 x_WORD_1805C0;
// 1805C2: using guessed type __int16 x_WORD_1805C2;
// 1805C8: using guessed type __int16 x_WORD_1805C8;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;
// 1806E4: using guessed type char x_BYTE_1806E4;
// 180744: using guessed type __int16 x_WORD_180744;
// 180746: using guessed type __int16 x_WORD_180746;
// 18074A: using guessed type __int16 x_WORD_18074A;
// 18074C: using guessed type __int16 x_WORD_18074C;

//----- (0008B5A0) --------------------------------------------------------
int sub_8B5A0()
{
	if (x_BYTE_E36D1)
	{
		switch (x_WORD_1805C2)
		{
		case 1:
			sub_8B770();
			break;
		case 9:
			sub_75900();
			break;
		default:
			break;
		}
		x_BYTE_E36D1 = 0;
	}
	return 0;
}
// E36D1: using guessed type char x_BYTE_E36D1;
// 1805C2: using guessed type __int16 x_WORD_1805C2;

//----- (0008B600) --------------------------------------------------------
signed int sub_8B600(int a1)
{
	int v1; // edi
	char v2; // bl
	__int16 v3; // dx
	char v4; // al
	int v5; // edx
	int v6; // eax
	int v7; // eax
	char v9; // [esp+0h] [ebp-40h]
	char v10; // [esp+3Ch] [ebp-4h]

	//fix it
	v5 = 0;
	//fix it

	v1 = sub_9AD9C(3);
	memset(&v9, 0, 60);
	memset((void*)(a1 + 66), 0, 84);
	v2 = 1;
	switch (*(x_WORD *)(a1 + 58))
	{
	case 1:
		v2 = 0;
		break;
	case 3:
		v2 = 2;
		break;
	case 4:
		v2 = 3;
		break;
	default:
		break;
	}
	v3 = *(x_WORD *)(a1 + 56);
	switch (v3)
	{
	case 1200:
		v4 = sub_8B880((int *)(a1 + 66), v2, 1200, v1);
		break;
	case 2400:
		v4 = sub_8B880((int *)(a1 + 66), v2, 2400, v1);
		break;
	case 4800:
		v4 = sub_8B880((int *)(a1 + 66), v2, 4800, v1);
		break;
	case 9600:
		v4 = sub_8B880((int *)(a1 + 66), v2, 9600, v1);
		break;
	case 19200:
		v4 = sub_8B880((int *)(a1 + 66), v2, 19200, v1);
		break;
	default:
		goto LABEL_16;
	}
	v10 = v4;
LABEL_16:
	sub_9B498(v10);
	myprintf("%s.\n");
	sub_8BA10((int)&v9, v5, (int *)(a1 + 66), &v9, v1);
	myprintf(&v9);
	myprintf(&unk_D1F0C);
	v6 = sub_9AD9C(2);
	sub_9B038((int *)(a1 + 66), (char *)&off_D1F10, v6);
	v7 = sub_9AD9C(2);
	if (!sub_9B038((int *)(a1 + 66), (char*)"!M1,P,B\r", v7))
		return 1;
	sub_9B234((int *)(a1 + 66));
	myprintf("Could not send Info to Tracker\n");
	return -1;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// D1F10: using guessed type void *off_D1F10;

//----- (0008B770) --------------------------------------------------------
int sub_8B770()
{
	return sub_9B234((int *)&unk_1805CE);
}

//----- (0008B790) --------------------------------------------------------
signed int sub_8B790(x_DWORD *a1)
{
	int v1; // eax
	signed int v2; // esi
	signed int v3; // eax
	double v4; // st7
	double v5; // st7
	int v6; // eax
	double v7; // st7
	int v8; // eax
	int v9; // ecx
	int v10; // edi
	int v11; // eax
	int v12; // ecx
	int v13; // eax
	int v14; // edx

	//fix it
	v6 = 0;
	v8 = 0;
	//fix it

	v1 = sub_9AD9C(1);
	v2 = 1;
	if (sub_9B274((x_DWORD *)((char *)a1 + 66), v1 / 2))
		v2 = -1;
	v3 = sub_9B260((x_DWORD **)((char *)a1 + 66));
	v4 = (double)*(signed int *)((char *)a1 + 94) * flt_D1F40;
	_CHP(v3);
	a1[1] = (signed int)v4;
	v5 = (double)*(signed int *)((char *)a1 + 90) * flt_D1F40;
	_CHP(v6);
	a1[2] = (signed int)v5;
	v7 = (double)*(signed int *)((char *)a1 + 98) * flt_D1F40;
	_CHP(v8);
	a1[3] = (signed int)v7;
	if (x_BYTE_1806E4 == 46)
	{
		x_DWORD_1805A4 = x_DWORD_180590;
		x_DWORD_1805A8 = x_DWORD_180594;
		x_DWORD_1805AC = x_DWORD_180598;
	}
	else
	{
		v9 = a1[2];
		v10 = a1[3];
		v11 = a1[7];
		a1[1] -= a1[6];
		v12 = v9 - v11;
		v13 = a1[8];
		a1[2] = v12;
		a1[3] = v10 - v13;
	}
	v14 = -a1[2];
	a1[1] = -a1[1];
	a1[2] = v14;
	return v2;
}
// 9B4F6: using guessed type double /*__fastcall*/ _CHP(x_DWORD);
// D1F40: using guessed type float flt_D1F40;
// 180590: using guessed type int x_DWORD_180590;
// 180594: using guessed type int x_DWORD_180594;
// 180598: using guessed type int x_DWORD_180598;
// 1805A4: using guessed type int x_DWORD_1805A4;
// 1805A8: using guessed type int x_DWORD_1805A8;
// 1805AC: using guessed type int x_DWORD_1805AC;
// 1806E4: using guessed type char x_BYTE_1806E4;

//----- (0008B880) --------------------------------------------------------
char sub_8B880(int *a1, char a2, signed int a3, int a4)
{
	int v4; // esi
	char result; // al
	int v6; // eax
	int v7; // eax
	int v8; // eax
	int v9; // edx

	//fix it
	v9 = 0;
	//fix it

	switch (a2)
	{
	case 0:
		v4 = 0;
		goto LABEL_7;
	case 1:
		v4 = 1;
		goto LABEL_7;
	case 2:
		v4 = 2;
		goto LABEL_7;
	case 3:
		v4 = 3;
	LABEL_7:
		v6 = (int)calloc(1, 90);
		*a1 = v6;
		if (v6)
		{
			v7 = sub_9BE18(v6, v4, 1, 0x400u, 0x400u);
			if (v7)
			{
				if (v7 == -1)
				{
					myprintf("NO SERIAL\n");
					result = 1;
				}
				else
				{
					myprintf("NO MEMORY\n");
					result = 9;
				}
			}
			else
			{
				sub_9BAC4(*a1, a3);
				sub_9CCF8(*a1, 1);
				sub_9CD9C(*a1, 1);
				v8 = sub_9CCB4(*a1, 0);
				result = sub_8B980(v8, v9, (x_DWORD **)a1, a4);
			}
		}
		else
		{
			myprintf("No memory for serial data.\n");
			result = 1;
		}
		break;
	default:
		result = 1;
		break;
	}
	return result;
}
// 9B513: using guessed type x_DWORD calloc(x_DWORD, x_DWORD);

//----- (0008B980) --------------------------------------------------------
char sub_8B980(int a1, int a2, x_DWORD **a3, int a4)
{
	int v4; // edi
	bool v5; // eax
	int v6; // edx
	int v7; // esi
	int v9; // eax
	int v10; // edx
	int v11; // eax

	//fix it
	v5 = 0;
	v6 = 0;
	v10 = 0;
	//fix it

	v4 = j_j___clock(a1, a2, (x_DWORD)a3);
	sub_9CBBC(*a3);
	do
	{
		v7 = j_j___clock(v5, v6, (x_DWORD)a3);
		sub_9AEEC(a3, (char *)&off_D1F10);
		do
		{
			if (!sub_9C9D0((int)*a3) && sub_9C938(*a3) == 79)
				return 0;
			v9 = sub_9ADB4(1);
			v11 = sub_9AE04(v9, v10, (int)a3, v7, v9);
		} while (!v11);
		v5 = sub_9AE04(v11, a4, (int)a3, v4, a4);
	} while (!v5);
	return 3;
}
// 9ADFC: using guessed type int /*__fastcall*/ j_j___clock(x_DWORD, x_DWORD, x_DWORD);
// D1F10: using guessed type void *off_D1F10;

//----- (0008BA10) --------------------------------------------------------
char sub_8BA10(int a1, int a2, int *a3, char *a4, int a5)
{
	int v5; // esi
	bool v6; // eax
	int v7; // edx
	int v8; // eax
	int v9; // edx
	char v10; // ah
	unsigned int i; // edx
	char v12; // cl
	double v13; // rax
	int v15; // eax
	int v16; // edx
	int v17; // eax
	int v18; // [esp+8h] [ebp-4h]

	//fix it
	v6 = 0;
	v7 = 0;
	v8 = 0;
	v9 = 0;
	v16 = 0;
	//fix it

	v5 = j_j___clock(a1, a2, (x_DWORD)a4);
	sub_9CBBC((x_DWORD *)*a3);
	while (2)
	{
		v18 = j_j___clock(v6, v7, (x_DWORD)a4);
		sub_9AEEC((x_DWORD **)a3, (char *)&off_D1F78);
		do
		{
			sub_9AEEC((x_DWORD **)a3, (char *)&off_D1F78);
			sub_9AE90(v8, v9, (int)a4, a3, a4, 60, a5);
			v10 = *a4;
			a4[59] = 0;
			if (v10 == 77)
			{
				for (i = 0; i < strlen(a4); i++)
				{
					v12 = a4[i];
					if (v12 == 70 || v12 == 102)
					{
						LODWORD(v13) = strtod(&a4[i + 1], 0);
						if (v13 < dbl_D1F7C)
							x_DWORD_E36C8 = 0;
						return 0;
					}
				}
				return 0;
			}
			v15 = sub_9ADB4(1);
			v17 = sub_9AE04(v18, v16, (int)a4, v18, v15);
		} while (!v17);
		v6 = sub_9AE04(v17, a5, (int)a4, v5, a5);
		if (!v6)
			continue;
		break;
	}
	return 3;
}
// 9ADFC: using guessed type int /*__fastcall*/ j_j___clock(x_DWORD, x_DWORD, x_DWORD);
// 9CF81: using guessed type x_DWORD strtod(x_DWORD, x_DWORD);
// D1F78: using guessed type void *off_D1F78;
// D1F7C: using guessed type double dbl_D1F7C;
// E36C8: using guessed type int x_DWORD_E36C8;

//----- (0008BB10) --------------------------------------------------------
int sub_8BB10(int a1)
{
	int result; // eax

	result = a1;
	*(x_BYTE *)(a1 + 36) = 2;
	*(x_DWORD *)(a1 + 8) = 10000000;
	*(x_DWORD *)(a1 + 20) = 10000000;
	*(x_DWORD *)(a1 + 12) = 0;
	*(x_DWORD *)(a1 + 24) = 0;
	return result;
}

//----- (0008BB40) --------------------------------------------------------
int sub_8BB40(int a1, char a2)
{
	int result; // eax

	*(x_BYTE *)(a1 + 37) = a2;
	result = sub_8BB10(a1);
	BYTE1(result) = a2;
	if (a2 == 8)
	{
		*(x_BYTE *)(a1 + 37) = 7;
		*(x_BYTE *)(a1 + 36) = 3;
	}
	return result;
}

//----- (0008BBE0) --------------------------------------------------------
signed int sub_8BBE0(int a1)//fix
{
	char v1; // dl
	unsigned __int8 v2; // al
	char v3; // al
	signed int result; // eax
	signed int v5; // ecx
	unsigned __int8 v6; // al
	signed int v7; // ecx
	unsigned __int8 v8; // al
	signed int v9; // ecx
	unsigned __int8 v10; // al
	unsigned __int8 v11; // al
	int v12; // esi
	int v13; // esi
	int v14; // edi
	int v15; // ecx
	int v16; // eax
	int v17; // ecx
	int v18; // esi
	int v19; // eax
	int v20; // eax
	int v21; // ecx
	int v22; // esi
	int v23; // eax
	int v24; // ecx
	int v25; // edi
	int v26; // eax
	int v27; // ecx
	int v28; // esi
	int v29; // eax
	int v30; // eax
	int v31; // ecx
	int v32; // esi
	int v33; // eax
	char v34; // al
	int v35; // edx
	int v36; // esi
	unsigned __int8 v37; // al
	int v38; // eax
	char v39; // dh
	int v40; // [esp+0h] [ebp-14h]
	int v41; // [esp+4h] [ebp-10h]
	int v42; // [esp+8h] [ebp-Ch]
	int v43; // [esp+Ch] [ebp-8h]
	unsigned __int8 v44; // [esp+10h] [ebp-4h]
	char v45; // [esp+10h] [ebp-4h]

	//fix it
	v6 = 0;
	v10 = 0;
	//fix it

	v1 = 0;
	v43 = 0;
	v42 = 0;
	v41 = 0;
	v40 = 0;
	v44 = 0;
	if (*(x_BYTE *)(a1 + 36))
	{
		_disable();
		v2 = *(x_BYTE *)(a1 + 37);
		switch (v2)
		{
		case 0u:
		LABEL_3:
			*(x_BYTE *)(a1 + 38) = 0;
			*(x_BYTE *)(a1 + 43) = 0;
			v3 = *(x_BYTE *)(a1 + 43);
			*(x_BYTE *)(a1 + 42) = v3;
			*(x_BYTE *)(a1 + 41) = v3;
			*(x_BYTE *)(a1 + 40) = v3;
			return 0;
		case 1u:
		case 2u:
		case 3u:
		case 4u:
			v5 = 10000;
			_disable();
			v1 = 1;
			//__outx_BYTE(0x201u, v2);
			do
			{
				// v6 = __inx_BYTE(0x201u);
				if (!(v6 & 3))
					break;
				if (v6 & 1)
					++v43;
				if (v6 & 2)
					++v42;
				--v5;
			} while (v5);
			_enable();
			v44 = v6;
			if (!v5)
				*(x_BYTE *)(a1 + 36) = 0;
			break;
		case 5u:
		case 6u:
			v7 = 10000;
			_disable();
			v1 = 1;
			//__outx_BYTE(0x201u, v2);
			do
			{
				v8 = __inx_BYTE(0x201u);
				if (!(v8 & 0xB))
					break;
				if (v8 & 1)
					++v43;
				if (v8 & 2)
					++v42;
				if (v8 & 8)
					++v40;
				--v7;
			} while (v7);
			_enable();
			v44 = v8;
			if (!v7)
				*(x_BYTE *)(a1 + 36) = 0;
			break;
		case 7u:
			v9 = 10000;
			_disable();
			v1 = 1;
			//__outx_BYTE(0x201u, v2);
			do
			{
				//v10 = __inx_BYTE(0x201u);

				if (!(v10 & 0xF))
					break;
				if (v10 & 1)
					++v43;
				if (v10 & 2)
					++v42;
				if (v10 & 4)
					++v41;
				if (v10 & 8)
					++v40;
				--v9;
			} while (v9);
			_enable();
			v44 = v10;
			if (!v9)
			{
				if (*(x_BYTE *)(a1 + 36) == 3)
				{
					v1 = 123;
					*(x_BYTE *)(a1 + 37) = 2;
				}
				else
				{
					*(x_BYTE *)(a1 + 36) = 1;
				}
			}
			break;
		default:
			break;
		}
		_enable();
	}
	v45 = (~v44 >> 4) & 0xF;
	v11 = *(x_BYTE *)(a1 + 37);
	if (v11 < 3u)
	{
		if (v11 != 1)
			exit(-1);
		goto LABEL_45;
	}
	if (v11 <= 3u || v11 == 5)
		LABEL_45:
	v45 &= 3u;
LABEL_46:
	switch (*(x_BYTE *)(a1 + 36))
	{
	case 0:
		goto LABEL_3;
	case 1:
		*(x_BYTE *)(a1 + 38) = v45;
		switch (*(x_BYTE *)(a1 + 37))
		{
		case 1:
		case 2:
			goto LABEL_52;
		case 3:
		case 4:
			goto LABEL_66;
		case 5:
		case 6:
			switch (8 * v40 / *(x_DWORD *)(a1 + 32))
			{
			case 0:
				*(x_BYTE *)(a1 + 42) = 0;
				*(x_BYTE *)(a1 + 43) = -1;
				goto LABEL_66;
			case 1:
			case 2:
				*(x_BYTE *)(a1 + 42) = 1;
				break;
			case 3:
			case 4:
				*(x_BYTE *)(a1 + 42) = 0;
				*(x_BYTE *)(a1 + 43) = 1;
				goto LABEL_66;
			case 5:
			case 6:
				*(x_BYTE *)(a1 + 42) = -1;
				break;
			default:
				*(x_BYTE *)(a1 + 42) = 0;
				break;
			}
			*(x_BYTE *)(a1 + 43) = 0;
		LABEL_66:
			v14 = *(x_DWORD *)(a1 + 16);
			v15 = v43 - v14;
			if (v43 - v14 < 0)
			{
				v20 = (*(x_DWORD *)(a1 + 8) - v14) >> 3;
				v21 = v15 - v20;
				v22 = *(x_DWORD *)(a1 + 8) - v14 - 2 * v20;
				if (v21 <= 0)
				{
					if (*(x_DWORD *)(a1 + 8) - v14 == 2 * v20)
						v22 = 1;
					v23 = -127 * v21 / v22;
					if (v23 <= -127)
						*(x_BYTE *)(a1 + 40) = -127;
					else
						*(x_BYTE *)(a1 + 40) = v23;
				}
				else
				{
					*(x_BYTE *)(a1 + 40) = 0;
				}
			}
			else
			{
				v16 = (*(x_DWORD *)(a1 + 12) - v14) >> 3;
				v17 = v15 - v16;
				v18 = *(x_DWORD *)(a1 + 12) - v14 - 2 * v16;
				if (v17 >= 0)
				{
					if (*(x_DWORD *)(a1 + 12) - v14 == 2 * v16)
						v18 = 1;
					v19 = 127 * v17 / v18;
					if (v19 >= 127)
						*(x_BYTE *)(a1 + 40) = 127;
					else
						*(x_BYTE *)(a1 + 40) = v19;
				}
				else
				{
					*(x_BYTE *)(a1 + 40) = 0;
				}
			}
			v24 = v42 - *(x_DWORD *)(a1 + 28);
			if (v24 < 0)
			{
				v30 = (*(x_DWORD *)(a1 + 20) - *(x_DWORD *)(a1 + 28)) >> 3;
				v31 = v24 - v30;
				v32 = *(x_DWORD *)(a1 + 20) - *(x_DWORD *)(a1 + 28) - 2 * v30;
				if (v31 <= 0)
				{
					if (*(x_DWORD *)(a1 + 20) - *(x_DWORD *)(a1 + 28) == 2 * v30)
						v32 = 1;
					v33 = -127 * v31 / v32;
					if (v33 <= -127)
						*(x_BYTE *)(a1 + 41) = -127;
					else
						*(x_BYTE *)(a1 + 41) = v33;
					result = 0;
				}
				else
				{
					*(x_BYTE *)(a1 + 41) = 0;
					result = 0;
				}
			}
			else
			{
				v25 = *(x_DWORD *)(a1 + 28);
				v26 = (*(x_DWORD *)(a1 + 24) - v25) >> 3;
				v27 = v24 - v26;
				v28 = *(x_DWORD *)(a1 + 24) - v25 - 2 * v26;
				if (v27 >= 0)
				{
					if (*(x_DWORD *)(a1 + 24) - v25 == 2 * v26)
						v28 = 1;
					v29 = 127 * v27 / v28;
					if (v29 >= 127)
						*(x_BYTE *)(a1 + 41) = 127;
					else
						*(x_BYTE *)(a1 + 41) = v29;
					result = 0;
				}
				else
				{
					*(x_BYTE *)(a1 + 41) = 0;
					result = 0;
				}
			}
			break;
		case 7:
			if (v41 < *(x_DWORD *)(a1 + 32))
				*(x_BYTE *)(a1 + 38) |= 0x10u;
			if (v40 < *(x_DWORD *)(a1 + 32))
				*(x_BYTE *)(a1 + 38) |= 0x20u;
		LABEL_52:
			v12 = *(x_DWORD *)(a1 + 16);
			if ((v12 + *(x_DWORD *)(a1 + 8)) >> 1 <= v43)
				*(x_BYTE *)(a1 + 40) = (v12 + *(x_DWORD *)(a1 + 12)) >> 1 < v43;
			else
				*(x_BYTE *)(a1 + 40) = -1;
			v13 = *(x_DWORD *)(a1 + 28);
			if ((v13 + *(x_DWORD *)(a1 + 20)) >> 1 <= v42)
				*(x_BYTE *)(a1 + 41) = (v13 + *(x_DWORD *)(a1 + 24)) >> 1 < v42;
			else
				*(x_BYTE *)(a1 + 41) = -1;
			*(x_DWORD *)a1 = v43;
			*(x_DWORD *)(a1 + 4) = v42;
			result = 0;
			break;
		default:
			goto LABEL_123;
		}
		return result;
	case 2:
		*(x_BYTE *)(a1 + 38) = 0;
		*(x_BYTE *)(a1 + 43) = 0;
		v34 = *(x_BYTE *)(a1 + 43);
		*(x_BYTE *)(a1 + 42) = v34;
		*(x_BYTE *)(a1 + 41) = v34;
		*(x_BYTE *)(a1 + 40) = v34;
		if (!(v45 & 1)
			|| (*(x_DWORD *)(a1 + 16) = v43,
				*(x_DWORD *)(a1 + 28) = v42,
				v35 = *(x_DWORD *)(a1 + 16),
				v35 <= *(x_DWORD *)(a1 + 8))
			|| v35 >= *(x_DWORD *)(a1 + 12)
			|| (v36 = *(x_DWORD *)(a1 + 28), *(x_DWORD *)(a1 + 20) >= v36)
			|| v36 >= *(x_DWORD *)(a1 + 24))
		{
			if (v43 < *(x_DWORD *)(a1 + 8))
				*(x_DWORD *)(a1 + 8) = v43;
			if (v43 > *(x_DWORD *)(a1 + 12))
				*(x_DWORD *)(a1 + 12) = v43;
			if (v42 < *(x_DWORD *)(a1 + 20))
				*(x_DWORD *)(a1 + 20) = v42;
			if (v42 > *(x_DWORD *)(a1 + 24))
				*(x_DWORD *)(a1 + 24) = v42;
			return 1;
		}
		v37 = *(x_BYTE *)(a1 + 37);
		if (v37 < 5u)
			goto LABEL_122;
		if (v37 <= 6u)
		{
			v38 = v40;
		}
		else
		{
			if (v37 != 7)
				goto LABEL_122;
			v38 = (v40 + v41) >> 2;
		}
		*(x_DWORD *)(a1 + 32) = v38;
	LABEL_122:
		*(x_BYTE *)(a1 + 36) = 1;
	LABEL_123:
		result = 0;
		break;
	case 3:
		if (v1 == 123)
			goto LABEL_123;
		*(x_DWORD *)(a1 + 16) = v43;
		*(x_DWORD *)(a1 + 28) = v42;
		*(x_DWORD *)(a1 + 12) = v43 / 2 + v43;
		*(x_DWORD *)(a1 + 24) = v42 / 2 + v42;
		*(x_DWORD *)(a1 + 8) = v43 / 6;
		v39 = *(x_BYTE *)(a1 + 37);
		*(x_DWORD *)(a1 + 20) = v42 / 6;
		if (v39 == 7)
			*(x_DWORD *)(a1 + 32) = (v40 + v41) >> 2;
		goto LABEL_122;
	default:
		goto LABEL_123;
	}
	return result;
}

//----- (0008C0E0) --------------------------------------------------------
void sub_8C0E0(unsigned __int8(/*__fastcall*/ *a1)(signed int))
{
	signed int v1; // eax
	signed int v2; // eax

	x_BYTE_180586 = 0;
	while (!(x_BYTE_180586 & 1))
	{
		v1 = sub_8BBE0((int)&unk_180560);
		if (a1 && a1(v1))
			return;
	}
	while (x_BYTE_180586 & 1)
	{
		v2 = sub_8BBE0((int)&unk_180560);
		if (a1)
		{
			if (a1(v2))
				break;
		}
	}
}
// 180586: using guessed type char x_BYTE_180586;

//----- (0008C140) --------------------------------------------------------
char sub_8C140(unsigned __int16 a1, int a2)
{
	int v3; // [esp+0h] [ebp-28h]
	int v4; // [esp+4h] [ebp-24h]
	int v5; // [esp+14h] [ebp-14h]
	char v6; // [esp+1Ch] [ebp-Ch]

	memset(&v3, 0, 28);
	v4 = a1;
	v3 = 0x300;
	segread((SREGS*)&v6);
	v5 = a2;
	int386x(0x31, (REGS*)&v3, (REGS*)&v3, (SREGS*)&v6);
	return *(x_BYTE *)(a2 + 28);
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 99DE6: using guessed type x_DWORD segread(x_DWORD);
// 99E10: using guessed type x_DWORD int386x(x_DWORD, x_DWORD, x_DWORD, x_DWORD);

//----- (0008C21F) --------------------------------------------------------
int sub_8C21F_any_graphics_command()
{
	/*char v1; // [esp+0h] [ebp-38h]
	int v2; // [esp+1Ch] [ebp-1Ch]

	v2 = (unsigned __int16)x_WORD_180662_graphics_handle;
	return int386(0x10, (REGS*)&v2, (REGS*)&v1);//grafika*/
	return(0);//fix it
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// 180662: using guessed type __int16 x_WORD_180662_graphics_handle;

//----- (0008C2CD) --------------------------------------------------------
void sub_8C2CD()
{
	;
}

//----- (0008C2DE) --------------------------------------------------------
void sub_8C2DE()
{
	;
}

//----- (0008C329) --------------------------------------------------------
int sub_8C329()//26D329
{
	int result; // eax
	x_BYTE *v1; // eax
	x_BYTE *v2; // eax

	x_DWORD_1806E8_mousex = x_WORD_E3760_mousex;
	x_DWORD_1806E8_mousey = x_WORD_E3762_mousey;//fix it

	if (x_WORD_180660_VGA_type_resolution & 1)
	{
		x_DWORD_1806E8_mousex >>= 1;
		x_DWORD_1806E8_mousey >>= 1;
	}
	x_DWORD_1806F4_mouse_byte_index2 = (x_DWORD_1806E8_mousex >> 16) + (x_DWORD_1806E8_mousey >> 16) * x_DWORD_18062C_resolution_x;
	if (x_WORD_180660_VGA_type_resolution & 8)
	{
		HIWORD(x_DWORD_18073A) = HIWORD(x_DWORD_1806F4_mouse_byte_index2);
		sub_9951B(SHIWORD(x_DWORD_1806F4_mouse_byte_index2));//GET VIDEO STATE
	}
	unk_1806EC = x_DWORD_18062C_resolution_x - x_DWORD_1806E8_mousex;
	if ((signed __int16)(x_DWORD_18062C_resolution_x - x_DWORD_1806E8_mousex) > x_WORD_18072C_cursor_sizex)
		unk_1806EC = x_WORD_18072C_cursor_sizex;
	x_WORD_1806EE = x_DWORD_180624_resolution_y - x_DWORD_1806E8_mousey;
	if ((signed __int16)(x_DWORD_180624_resolution_y - x_DWORD_1806E8_mousey) > x_WORD_18072E_cursor_sizey)
		x_WORD_1806EE = x_WORD_18072E_cursor_sizey;
	x_DWORD_180714 = x_DWORD_1806F0;
	x_DWORD_180708 = (Bit8u*)&loc_A0000_vga_buffer + (unsigned __int16)x_DWORD_1806F4_mouse_byte_index2;
	x_DWORD_18070C = x_DWORD_180730_cursor_data;
	if (x_WORD_180660_VGA_type_resolution & 1)
	{
		for (x_WORD_180738 = 0; ; ++x_WORD_180738)
		{
			result = unk_1806EC >> 16;
			if ((signed int)(unsigned __int16)x_WORD_180738 >= (unk_1806EC >> 16))
				break;
			LOWORD(x_DWORD_18073A) = 0;
			while ((unsigned __int16)x_DWORD_18073A < (x_DWORD_1806E8_mousey >> 16))
			{
				v1 = (x_BYTE *)x_DWORD_180714++;
				*v1 = *(x_BYTE *)x_DWORD_180708;
				if (*(x_BYTE *)x_DWORD_18070C != -2)
					*(x_BYTE *)x_DWORD_180708 = *(x_BYTE *)x_DWORD_18070C;
				++x_DWORD_180708;
				++x_DWORD_18070C;
				LOWORD(x_DWORD_18073A) = x_DWORD_18073A + 1;
			}
			x_DWORD_180708 += x_DWORD_18062C_resolution_x - (x_DWORD_1806E8_mousey >> 16);
			x_DWORD_18070C += (*(int *)((char *)&x_DWORD_180730_cursor_data + 2) >> 16) - (x_DWORD_1806E8_mousey >> 16);
		}
	}
	else
	{
		for (x_WORD_180738 = 0; ; ++x_WORD_180738)
		{
			result = unk_1806EC >> 16;
			if ((signed int)(unsigned __int16)x_WORD_180738 >= unk_1806EC >> 16)
				break;
			LOWORD(x_DWORD_18073A) = 0;
			while ((unsigned __int16)x_DWORD_18073A < x_DWORD_1806E8_mousey >> 16)
			{
				v2 = (x_BYTE *)x_DWORD_180714++;
				*v2 = *(x_BYTE *)x_DWORD_180708;
				if (*(x_BYTE *)x_DWORD_18070C != -2)
					*(x_BYTE *)x_DWORD_180708 = *(x_BYTE *)x_DWORD_18070C;
				if (++x_DWORD_180708 >= (Bit8u*)&loc_AFFFE + 2)
				{
					++HIWORD(x_DWORD_18073A);
					sub_9951B(SHIWORD(x_DWORD_18073A));
					x_DWORD_180708 -= (signed int)sub_10000;
				}
				++x_DWORD_18070C;
				LOWORD(x_DWORD_18073A) = x_DWORD_18073A + 1;
			}
			x_DWORD_180708 += x_DWORD_18062C_resolution_x - (x_DWORD_1806E8_mousey >> 16);
			if (x_DWORD_180708 >= (Bit8u*)&loc_AFFFE + 2)
			{
				++HIWORD(x_DWORD_18073A);
				sub_9951B(SHIWORD(x_DWORD_18073A));
				x_DWORD_180708 -= (signed int)sub_10000;
			}
			x_DWORD_18070C += (*(int *)((char *)&x_DWORD_180730_cursor_data + 2) >> 16) - (x_DWORD_1806E8_mousey >> 16);
		}
	}
	return result;
}
// 10000: using guessed type void /*__noreturn*/ sub_10000();
// E3760: using guessed type int x_DWORD_E3760;
// 180624: using guessed type int x_DWORD_180624_resolution_y;
// 18062C: using guessed type int x_DWORD_18062C_resolution_x;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;
// 1806E8: using guessed type int x_DWORD_1806E8;
// 1806EE: using guessed type __int16 x_WORD_1806EE;
// 1806F0: using guessed type int x_DWORD_1806F0;
// 1806F4: using guessed type int x_DWORD_1806F4_mouse_byte_index2;
// 180708: using guessed type int x_DWORD_180708;
// 18070C: using guessed type int x_DWORD_18070C;
// 180714: using guessed type int x_DWORD_180714;
// 18072C: using guessed type __int16 x_WORD_18072C_cursor_sizex;
// 18072E: using guessed type __int16 x_WORD_18072E_cursor_sizey;
// 180730: using guessed type int x_DWORD_180730_cursor_data;
// 180738: using guessed type __int16 x_WORD_180738;
// 18073A: using guessed type int x_DWORD_18073A;

//----- (0008C635) --------------------------------------------------------
void sub_8C635_draw_cursor()//26d635
{
	//int result; // eax
	Bit8u* v1; // eax
	Bit8u* v2; // edx

	x_DWORD_1806F8_mousex = x_WORD_E3760_mousex;
	x_DWORD_1806E8_mousex = x_WORD_E3760_mousex;
	x_DWORD_1806F8_mousey = x_WORD_E3762_mousey;
	x_DWORD_1806E8_mousey = x_WORD_E3762_mousey;
	if (x_WORD_180660_VGA_type_resolution & 1)
	{
		x_DWORD_1806F8_mousex >>= 1;
		x_DWORD_1806F8_mousey >>= 1;
	}
	x_DWORD_180704_mouse_byte_index1 = x_DWORD_1806F8_mousex + x_DWORD_1806F8_mousey * x_DWORD_18062C_resolution_x;
	x_DWORD_1806F4_mouse_byte_index2 = x_DWORD_180704_mouse_byte_index1;
	x_DWORD_1806FC_mouse_invx = x_DWORD_18062C_resolution_x - x_DWORD_1806F8_mousex;
	if (x_DWORD_1806FC_mouse_invx > x_WORD_18072C_cursor_sizex)//35172c je to 13001500!
		x_DWORD_1806FC_mouse_invx = x_WORD_18072C_cursor_sizex;
	unk_1806EC = x_DWORD_1806FC_mouse_invx;
	x_DWORD_1806FC_mouse_invy = x_DWORD_180624_resolution_y - x_DWORD_1806F8_mousey;
	if (x_DWORD_1806FC_mouse_invy > x_WORD_18072E_cursor_sizey)
		x_DWORD_1806FC_mouse_invy = x_WORD_18072E_cursor_sizey;
	x_WORD_1806EE = x_DWORD_1806FC_mouse_invy;
	x_DWORD_180714 = x_DWORD_180700;
	x_DWORD_180718 = x_DWORD_1806F0;
	x_DWORD_180708 = x_DWORD_180704_mouse_byte_index1 + x_DWORD_180628b_screen_buffer;
	x_DWORD_18070C = x_DWORD_180730_cursor_data;
	for (x_WORD_180738 = 0;x_WORD_180738 < x_DWORD_1806FC_mouse_invy; x_WORD_180738++)
	{
		for (x_DWORD_18073A = 0;x_DWORD_18073A < x_DWORD_1806FC_mouse_invx; x_DWORD_18073A++)
		{
			v1 = x_DWORD_180714++;//adresa1
			v1[0] = x_DWORD_180708[0];//uloz na adresu
			v2 = x_DWORD_180718++;//adresa2
			v2[0] = x_DWORD_180708[0];//uloz na adresu
			if (x_DWORD_18070C[0] != 0xfe)
				x_DWORD_180708[0] = x_DWORD_18070C[0];
			x_DWORD_180708++;//351708 - finalni obraz
			x_DWORD_18070C++;//35170c - kurzor
		}
		x_DWORD_180708 += x_DWORD_18062C_resolution_x - x_DWORD_1806FC_mouse_invx;
		x_DWORD_18070C += x_DWORD_180734 - x_DWORD_1806FC_mouse_invx;
	}
}
// E3760: using guessed type int x_DWORD_E3760;
// 180624: using guessed type int x_DWORD_180624_resolution_y;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 18062C: using guessed type int x_DWORD_18062C_resolution_x;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;
// 1806E8: using guessed type int;
// 1806EE: using guessed type __int16 x_WORD_1806EE;
// 1806F0: using guessed type int x_DWORD_1806F0;
// 1806F4: using guessed type int x_DWORD_1806F4_mouse_byte_index2;
// 1806F8: using guessed type int x_DWORD_1806F8;
// 1806FC: using guessed type int x_DWORD_1806FC_mouse_inv_x;
// 180700: using guessed type int x_DWORD_180700;
// 180704: using guessed type int x_DWORD_180704_mouse_byte_index1;
// 180708: using guessed type int x_DWORD_180708;
// 18070C: using guessed type int x_DWORD_18070C;
// 180714: using guessed type int x_DWORD_180714;
// 180718: using guessed type int x_DWORD_180718;
// 18072C: using guessed type __int16 x_WORD_18072C_cursor_sizex;
// 18072E: using guessed type __int16 x_WORD_18072E_cursor_sizey;
// 180730: using guessed type int x_DWORD_180730_cursor_data;
// 180738: using guessed type __int16 x_WORD_180738;
// 18073A: using guessed type int x_DWORD_18073A;

//----- (0008C839) --------------------------------------------------------
int sub_8C839()
{
	int result; // eax
	x_BYTE *v1; // eax
	x_BYTE *v2; // edx
	x_BYTE *v3; // eax
	x_BYTE *v4; // edx

	if (!(x_WORD_180660_VGA_type_resolution & 1))
	{
		HIWORD(x_DWORD_18073A) = HIWORD(x_DWORD_1806F4_mouse_byte_index2);
		sub_9951B(SHIWORD(x_DWORD_1806F4_mouse_byte_index2));
	}
	x_DWORD_180714 = x_DWORD_1806F0;
	x_DWORD_180708 = (Bit8u*)&loc_A0000_vga_buffer + (unsigned __int16)x_DWORD_1806F4_mouse_byte_index2;//graphics memory maybe
	if (x_WORD_180660_VGA_type_resolution & 1)
	{
		for (x_WORD_180738 = 0; ; ++x_WORD_180738)
		{
			result = unk_1806EC >> 16;
			if ((signed int)(unsigned __int16)x_WORD_180738 >= unk_1806EC >> 16)
				break;
			LOWORD(x_DWORD_18073A) = 0;
			while ((unsigned __int16)x_DWORD_18073A < (x_DWORD_1806E8_mousey >> 16))
			{
				v1 = (x_BYTE *)x_DWORD_180714++;
				v2 = (x_BYTE *)x_DWORD_180708++;
				*v2 = *v1;
				LOWORD(x_DWORD_18073A) = x_DWORD_18073A + 1;
			}
			x_DWORD_180708 += x_DWORD_18062C_resolution_x - (x_DWORD_1806E8_mousey >> 16);
		}
	}
	else
	{
		for (x_WORD_180738 = 0; ; ++x_WORD_180738)
		{
			result = unk_1806EC >> 16;
			if ((signed int)(unsigned __int16)x_WORD_180738 >= unk_1806EC >> 16)
				break;
			LOWORD(x_DWORD_18073A) = 0;
			while ((unsigned __int16)x_DWORD_18073A < (x_DWORD_1806E8_mousey >> 16))
			{
				v3 = (x_BYTE *)x_DWORD_180714++;
				v4 = (x_BYTE *)x_DWORD_180708++;
				*v4 = *v3;
				if (x_DWORD_180708 >= (Bit8u*)0xAFFFE + 2)
				{
					++HIWORD(x_DWORD_18073A);
					sub_9951B(SHIWORD(x_DWORD_18073A));
					x_DWORD_180708 -= 0x10000;
				}
				LOWORD(x_DWORD_18073A) = x_DWORD_18073A + 1;
			}
			x_DWORD_180708 += x_DWORD_18062C_resolution_x - (x_DWORD_1806E8_mousey >> 16);
			if (x_DWORD_180708 >= (Bit8u*)0xAFFFE + 2)
			{
				++HIWORD(x_DWORD_18073A);
				sub_9951B(SHIWORD(x_DWORD_18073A));
				x_DWORD_180708 -= 0x10000;
			}
		}
	}
	return result;
}
// 10000: using guessed type void /*__noreturn*/ sub_10000();
// 18062C: using guessed type int x_DWORD_18062C_resolution_x;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;
// 1806E8: using guessed type int x_DWORD_1806E8;
// 1806F0: using guessed type int x_DWORD_1806F0;
// 1806F4: using guessed type int x_DWORD_1806F4_mouse_byte_index2;
// 180708: using guessed type int x_DWORD_180708;
// 180714: using guessed type int x_DWORD_180714;
// 180738: using guessed type __int16 x_WORD_180738;
// 18073A: using guessed type int x_DWORD_18073A;

//----- (0008CA16) --------------------------------------------------------
int sub_8CA16()
{
	int result; // eax
	x_BYTE *v1; // eax
	x_BYTE *v2; // edx

	x_DWORD_180714 = x_DWORD_180700;
	x_DWORD_180708 = x_DWORD_180704_mouse_byte_index1 + x_DWORD_180628b_screen_buffer;
	for (x_WORD_180738 = 0; ; ++x_WORD_180738)
	{
		result = x_DWORD_1806FC_mouse_invx >> 16;
		if (x_WORD_180738 >= x_DWORD_1806FC_mouse_invx >> 16)
			break;
		LOWORD(x_DWORD_18073A) = 0;
		while (x_DWORD_18073A < x_DWORD_1806F8_mousey >> 16)
		{
			v1 = (x_BYTE *)x_DWORD_180714++;
			v2 = (x_BYTE *)x_DWORD_180708++;
			*v2 = *v1;
			LOWORD(x_DWORD_18073A) = x_DWORD_18073A + 1;
		}
		x_DWORD_180708 += x_DWORD_18062C_resolution_x - (x_DWORD_1806F8_mousex >> 16);
	}
	return result;
}
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 18062C: using guessed type int x_DWORD_18062C_resolution_x;
// 1806F8: using guessed type int x_DWORD_1806F8;
// 1806FC: using guessed type int x_DWORD_1806FC_mouse_inv_x;
// 180700: using guessed type int x_DWORD_180700;
// 180704: using guessed type int x_DWORD_180704_mouse_byte_index1;
// 180708: using guessed type int x_DWORD_180708;
// 180714: using guessed type int x_DWORD_180714;
// 180738: using guessed type __int16 x_WORD_180738;
// 18073A: using guessed type int x_DWORD_18073A;

//----- (0008CACD) --------------------------------------------------------
void sub_8CACD_draw_cursor2()
{
	if (x_DWORD_E3768)
	{
		x_DWORD_E3758 = 1;
		sub_8C635_draw_cursor();
	}
}
// E3758: using guessed type int x_DWORD_E3758;
// E3768: using guessed type int x_DWORD_E3768;

//----- (0008CB1F) --------------------------------------------------------
void sub_8CB1F()
{
	x_DWORD_E3758 = 0;
}
// E3758: using guessed type int x_DWORD_E3758;

void mouse_events(Bit32u buttons, int x, int y) {
	sub_8CB3A(buttons, x, 0, y);//26db3a
};

int x_BYTE_E3767;
int x_DWORD_180710_mouse_buttons_states;
int x_WORD_18073E;
int word_E3764;
int x_WORD_180742;
int x_WORD_180748;
int x_WORD_180740;
//----- (0008CB3A) --------------------------------------------------------
void sub_8CB3A(Bit32u mouse_states, Bit32s mouse_posx, Bit32s a3, Bit32s mouse_posy)//26db3a
{
	//((void (*)(x_DWORD))_GETDS)((unsigned __int16)__DS__);
	Bit16s temp_mouse_x; // [esp+4h] [ebp-8h]
	Bit16s temp_mouse_y; // [esp+8h] [ebp-4h]
	void *retaddr[2]; // [esp+1Ch] [ebp+10h]

	temp_mouse_x = mouse_posx;
	temp_mouse_y = mouse_posy;
	if (x_DWORD_E3768)//2b4768 - 00000001
	{
		x_BYTE_E3767 = 1;
		x_DWORD_180710_mouse_buttons_states = mouse_states;//[ebp-c] - 00000001 // stav tlacitek 1 -zmena pozice
		/*if (x_WORD_180660_VGA_type_resolution & 8)
		{
			temp_mouse_x = mouse_posx >> 3;//[ss:ebp-8] 0 - x
			temp_mouse_y = mouse_posy >> 3;//[ss:ebp-4] 0 - y
		}*/
		x_WORD_E3760_mousex = temp_mouse_x; //nastav x
		//mouse_state = temp_mouse_y;
		x_WORD_E3762_mousey = temp_mouse_y; //nastav y
		if (temp_mouse_x > 638)//pokud je x>638 nastav je na 638
			x_WORD_E3760_mousex = 638;
		if (x_WORD_E3762_mousey > 478)//pokud je y>478 nastav je na 478
			x_WORD_E3762_mousey = 478;
		if (x_DWORD_180710_mouse_buttons_states & 2) // left button pressed
		{
			if (!x_WORD_18074C)//first cycle after press
			{
				if (x_WORD_18073E <= 0)
				{
					//mouse_state = word_E3764;
					x_WORD_18073E = word_E3764;
				}
				else
				{
					x_WORD_180742 = 1;
				}
			}
			if (!x_WORD_18074C && !x_WORD_180746)//first cycle after press and ...
			{
				x_WORD_180746 = 1;
				x_WORD_E375C_mouse_position_x = temp_mouse_x;
				//mouse_state = temp_mouse_y;
				x_WORD_E375E_mouse_position_y = temp_mouse_y;
			}
			x_WORD_18074C = 1;
		}
		if (x_DWORD_180710_mouse_buttons_states & 4)// left button released
			x_WORD_18074C = 0;
		if (x_DWORD_180710_mouse_buttons_states & 8)// right button pressed
		{
			if (!x_WORD_18074A && !x_WORD_180744)//first cycle after press and ...
			{
				x_WORD_180744 = 1;
				x_WORD_E375C_mouse_position_x = temp_mouse_x;
				//mouse_state = temp_mouse_y;
				x_WORD_E375E_mouse_position_y = temp_mouse_y;
			}
			x_WORD_18074A = 1;
		}
		if (x_DWORD_180710_mouse_buttons_states & 0x10)// right button released
			x_WORD_18074A = 0;
		if (x_DWORD_180710_mouse_buttons_states & 0x20)// middle button pressed?
		{
			if (!x_WORD_180748 && !x_WORD_180740)
			{
				x_WORD_180740 = 1;
				x_WORD_E375C_mouse_position_x = temp_mouse_x;
				//mouse_state = temp_mouse_y;
				x_WORD_E375E_mouse_position_y = temp_mouse_y;
			}
			x_WORD_180748 = 1;
		}
		if (x_DWORD_180710_mouse_buttons_states & 0x40)// middle button released?
			x_WORD_180748 = 0;
		if (!x_DWORD_E3758)
		{
			HIWORD(x_DWORD_180734) = x_WORD_E3BA4;
			sub_8C839();//draw cursor maybe
			/*mouse_state = */sub_8C329();
			if (x_WORD_180660_VGA_type_resolution & 8)
				/*mouse_state = */sub_9951B(SHIWORD(x_DWORD_180734));
		}
	}
	//return MK_FP(retaddr[0], retaddr[0])(a1, a2);
}
// 8CB3A: could not find valid save-restore pair for ebx
// 8CB3A: could not find valid save-restore pair for ebp
// 8CB3A: could not find valid save-restore pair for edi
// 8CB3A: could not find valid save-restore pair for esi
// E3758: using guessed type int x_DWORD_E3758;
// E375C: using guessed type __int16 x_WORD_E375C_mouse_position_x;
// E375E: using guessed type __int16 x_WORD_E375E_mouse_position_y;
// E3760: using guessed type int x_DWORD_E3760;
// E3767: using guessed type char x_BYTE_E3767;
// E3768: using guessed type int x_DWORD_E3768;
// E3BA4: using guessed type __int16 x_WORD_E3BA4;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;
// 180710: using guessed type int x_DWORD_180710_mouse_buttons_states;
// 180734: using guessed type int x_DWORD_180734;
// 18073E: using guessed type __int16 x_WORD_18073E;
// 180740: using guessed type __int16 x_WORD_180740;
// 180742: using guessed type __int16 x_WORD_180742;
// 180744: using guessed type __int16 x_WORD_180744;
// 180746: using guessed type __int16 x_WORD_180746;
// 180748: using guessed type __int16 x_WORD_180748;
// 18074A: using guessed type __int16 x_WORD_18074A;
// 18074C: using guessed type __int16 x_WORD_18074C;


posistruct pathstr_to_posistr(Pathstruct in)
{
	posistruct out;
	out.pointer = *in.var28_begin_buffer;
	out.sizex = *in.var28_begin_buffer[4];
	out.sizey = *in.var28_begin_buffer[5];
	return out;
};
//----- (0008CD27) --------------------------------------------------------
void sub_8CD27_set_cursor(posistruct a2)//26dd27
{

	//a2
	// 446f1a00 80 52 35 00 e0 9e 2b
	// 1a6f44: 78651a00 00 00
	// 1a6578: 0b0005a1a1a1a1a10005

	int result; // eax
	unsigned int i; // [esp+0h] [ebp-10h]
	Bit32s v3; // [esp+4h] [ebp-Ch]
	//__int16 v4; // [esp+8h] [ebp-8h]
	//int v5; // [esp+Ch] [ebp-4h]
	x_DWORD_E3758 = 1;//2b4758
	//v5 = (int)x_DWORD_180628b_screen_buffer;
	Bit8u* tempscrbuff = x_DWORD_180628b_screen_buffer;
	x_DWORD_180628b_screen_buffer = x_DWORD_180730_cursor_data;//351730
	//x_DWORD_180730_cursor_data = x_DWORD_180628b_screen_buffer;// hack
	if (a2.pointer)
	{
		x_WORD_18072C_cursor_sizex = a2.sizex;
		x_WORD_18072E_cursor_sizey = a2.sizey;
	}
	else
	{
		x_WORD_18072C_cursor_sizex = 0;
		x_WORD_18072E_cursor_sizey = 0;
	}
	if (x_WORD_180660_VGA_type_resolution & 1)
	{
		x_WORD_18072C_cursor_sizex >>= 1;
		x_WORD_18072E_cursor_sizey >>= 1;
	}
	x_DWORD_18065C = x_DWORD_180650_positiony;
	x_DWORD_180640_help_screen_height = x_DWORD_180630_screen_height;
	x_DWORD_180638 = x_DWORD_18063C_sprite_sizex;
	x_DWORD_18064C_help_screen_width = x_DWORD_180634_screen_width;
	x_DWORD_180658 = x_DWORD_180648_map_resolution2_x;
	x_DWORD_180654 = x_DWORD_180644_map_resolution2_y;
	x_DWORD_180650_positiony = 0;
	x_DWORD_180630_screen_height = 64;
	x_DWORD_18063C_sprite_sizex = 0;
	x_DWORD_180634_screen_width = 64;
	x_DWORD_180648_map_resolution2_x = 64;
	x_DWORD_180644_map_resolution2_y = 64;
	//v4 = x_WORD_E36D4;
	x_WORD_E36D4 = 0;
	v3 = x_DWORD_18062C_resolution_x;
	x_DWORD_18062C_resolution_x = 64;
	//x_DWORD_180730_cursor_data = (Bit8u*)malloc(0x1000);//fix it
	for (i = 0; i < 0x1000; i++)
	{
		x_DWORD_180730_cursor_data[i] = 0xfe;
		//printf("%d",i);
	}
	if (a2.pointer)
		sub_8F8B0_draw_bitmap320(0, 0, a2);//2708B0 super inicializace //a2 ma byt 86 nebo a1 nema nikam ukazovat
	x_DWORD_180628b_screen_buffer = tempscrbuff;
	x_DWORD_18062C_resolution_x = v3;
	x_WORD_E36D4 = x_WORD_E36D4;//355230
	x_DWORD_180650_positiony = x_DWORD_18065C;
	x_DWORD_180630_screen_height = x_DWORD_180640_help_screen_height;
	x_DWORD_18063C_sprite_sizex = x_DWORD_180638;
	x_DWORD_180634_screen_width = x_DWORD_18064C_help_screen_width;
	x_DWORD_180648_map_resolution2_x = x_DWORD_180658;
	x_DWORD_180644_map_resolution2_y = x_DWORD_180654;
	//result = v5;
	//x_DWORD_180628b_screen_buffer = (Bit8u*)v5;
	x_DWORD_E3758 = 0;

	//sub_90478_VGA_Blit320();//debug
	//return result;
}
// E36D4: using guessed type __int16 x_WORD_E36D4;
// E3758: using guessed type int x_DWORD_E3758;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 18062C: using guessed type int x_DWORD_18062C_resolution_x;
// 180630: using guessed type int x_DWORD_180630_screen_height;
// 180634: using guessed type int x_DWORD_180634_screen_width;
// 180638: using guessed type int x_DWORD_180638;
// 18063C: using guessed type int x_DWORD_18063C_sprite_sizex;
// 180640: using guessed type int x_DWORD_180640_help_screen_height;
// 180644: using guessed type int x_DWORD_180644_map_resolution2_y;
// 180648: using guessed type int x_DWORD_180648_map_resolution2_x;
// 18064C: using guessed type int x_DWORD_18064C_help_screen_width;
// 180650: using guessed type int x_DWORD_180650_positiony;
// 180654: using guessed type int x_DWORD_180654;
// 180658: using guessed type int x_DWORD_180658;
// 18065C: using guessed type int x_DWORD_18065C;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;
// 18072C: using guessed type __int16 x_WORD_18072C_cursor_sizex;
// 18072E: using guessed type __int16 x_WORD_18072E_cursor_sizey;
// 180730: using guessed type int x_DWORD_180730_cursor_data;

//----- (0008CEDF) --------------------------------------------------------
signed int sub_8CEDF_install_mouse()//26dedf
{
	//__int16 v1; // [esp+0h] [ebp-54h]
	//__int16 v2; // [esp+1Ch] [ebp-38h]
	__int16 v3; // [esp+24h] [ebp-30h]
	void(*v4)(Bit32u a1, Bit32s a2, Bit32s a3, Bit32s a4); // [esp+28h] [ebp-2Ch]
	__int16 v5; // [esp+38h] [ebp-1Ch]
	void(*v6)(Bit32u a1, Bit32s a2, Bit32s a3, Bit32s a4); // [esp+44h] [ebp-10h]
	int v7; // [esp+48h] [ebp-Ch]
	int i; // [esp+4Ch] [ebp-8h]

	x_DWORD_E3768 = 0;
	//segread((SREGS*)&v5);
	//v2 = 0;
	//int386(0x33, (REGS*)&v2, (REGS*)&v1);//mouse reset
	//if ( v1 != -1 )
	//  return 0;
	//v2 = 0xc;
	v3 = 127;
	LOWORD(v7) = __CS__;
	v6 = sub_8CB3A;
	v4 = sub_8CB3A;
	v5 = __CS__;
	/*
	adress: 160:26db3a - sub_8CB3A
	mask:7f
	http://stanislavs.org/helppc/int_33-c.html
	*/
	//int386x(0x33, (REGS*)&v2, (REGS*)&v1, (SREGS*)&v5);//set mouse subroutine
	sub_8D12F_set_mouse_viewport();
	if (!x_DWORD_180730_cursor_data)
		x_DWORD_180730_cursor_data = (Bit8u*)sub_83CD0_malloc2(4096);//image buffers?-blit?
	if (!x_DWORD_180700)
		x_DWORD_180700 = (Bit8u*)sub_83CD0_malloc2(4096);
	if (!x_DWORD_1806F0)
		x_DWORD_1806F0 = (Bit8u*)sub_83CD0_malloc2(4096);
	if (!x_DWORD_180730_cursor_data || !x_DWORD_180700 || !x_DWORD_1806F0)
		return 0;
	x_WORD_18072C_cursor_sizex = 0;
	x_WORD_18072E_cursor_sizey = 0;
	LOWORD(x_DWORD_180734) = 64;
	for (i = 0; i < 4096; i++)
		*(x_BYTE *)(i + x_DWORD_180730_cursor_data) = -2;
	if (x_DWORD_180720)
		;// fix it! sub_8CD27_set_cursor((Bit8u**)x_DWORD_180720);
	//v2 = 2;
	//int386(0x33, (REGS*)&v2, (REGS*)&v1);//hide mouse
	if (x_WORD_180660_VGA_type_resolution & 8)
	{
		//v2 = 0xF;
		v3 = 1;
		LOWORD(v4) = 1;
		//int386(0x33, (REGS*)&v2, (REGS*)&v1);//set pixel ratio
	}
	x_DWORD_E3768 = 1;//fix it
	return 1;
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// 99DE6: using guessed type x_DWORD segread(x_DWORD);
// 99E10: using guessed type x_DWORD int386x(x_DWORD, x_DWORD, x_DWORD, x_DWORD);
// E3768: using guessed type int x_DWORD_E3768;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;
// 1806F0: using guessed type int x_DWORD_1806F0;
// 180700: using guessed type int x_DWORD_180700;
// 180720: using guessed type int x_DWORD_180720;
// 18072C: using guessed type __int16 x_WORD_18072C_cursor_sizex;
// 18072E: using guessed type __int16 x_WORD_18072E_cursor_sizey;
// 180730: using guessed type int x_DWORD_180730_cursor_data;
// 180734: using guessed type int x_DWORD_180734;

//----- (0008D12F) --------------------------------------------------------
int sub_8D12F_set_mouse_viewport()
{
	/*int result; // eax
	char v1; // [esp+0h] [ebp-38h]
	__int16 v2; // [esp+1Ch] [ebp-1Ch]
	__int16 v3; // [esp+24h] [ebp-14h]
	__int16 v4; // [esp+28h] [ebp-10h]

	if ( x_WORD_180660_VGA_type_resolution == 8 )
	{
	  v2 = 7;
	  v3 = 0;
	  v4 = 5120;
	  int386(0x33, (REGS*)&v2, (REGS*)&v1);//set mouse hor minmax
	  v2 = 8;
	  v3 = 0;
	  v4 = 3840;
	  result = int386(0x33, (REGS*)&v2, (REGS*)&v1);//set mouse vert minmax
	}
	if ( x_WORD_180660_VGA_type_resolution == 2 )
	{
	  v2 = 7;
	  v3 = 0;
	  v4 = 640;
	  int386(0x33, (REGS*)&v2, (REGS*)&v1);//set mouse hor minmax
	  v2 = 8;
	  v3 = 0;
	  v4 = 480;
	  result = int386(0x33, (REGS*)&v2, (REGS*)&v1);//set mouse vert minmax
	}
	if ( x_WORD_180660_VGA_type_resolution == 4 )
	{
	  v2 = 7;
	  v3 = 0;
	  v4 = 640;
	  int386(0x33, (REGS*)&v2, (REGS*)&v1);//set mouse hor minmax
	  v2 = 8;
	  v3 = 0;
	  v4 = 400;
	  result = int386(0x33, (REGS*)&v2, (REGS*)&v1);//set mouse vert minmax
	}
	if ( x_WORD_180660_VGA_type_resolution == 1 )
	{
	  v2 = 7;
	  v3 = 0;
	  v4 = 640;
	  int386(0x33, (REGS*)&v2, (REGS*)&v1);//set mouse hor minmax
	  v2 = 8;
	  v3 = 0;
	  v4 = 400;
	  result = int386(0x33, (REGS*)&v2, (REGS*)&v1);//set mouse vert minmax
	}
	return result;*/
	return 0;
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (0008D290) --------------------------------------------------------
void sub_8D290_init_sound(char* a1/*, int a2, int a3*/)//26e290
{
	//int (*v3)(int); // eax
	//x_DWORD *v4; // eax
	IO_PARMS v5 = {}; // [esp+4h] [ebp-3Ch]
	char v6; // [esp+1Ch] [ebp-24h]
	//errno_t v7x; // [esp+2Ch] [ebp-14h]
	char* v7;
	Bit32u v8; // [esp+34h] [ebp-Ch]
	int v9; // [esp+38h] [ebp-8h]
	char v10; // [esp+3Ch] [ebp-4h]

	//fix it
	//v7 = 0;
	//v5 = 0;
	//fix it

	//char v8x[200];
	//IO_PARMS v9x = {};

	v10 = 0;
	if (!x_BYTE_E3798_sound_active2)
		return;
	x_WORD_E37B6_sound_number = x_WORD_E37B4;
	if (!x_WORD_E37B4)
	{
		if (!x_BYTE_E37FC)
		{
			if (x_BYTE_E37B8)
				sub_919C0();
		}
		x_BYTE_E3798_sound_active2 = 0;
		x_BYTE_E3799 = 0;
		myprintf("\nCould not load any digital samples\n");
		return;
	}
	if (!x_BYTE_E37B8)
	{
		sub_90F60();//set 355140
		//sub_9D3F0_set_malloc_type(sub_83CD0_malloc2);
		//v3 = sub_9D420(( (*)(void*))sub_83E80_sound_proc_99);
		//((void (*)(int (*)(int)))loc_917D0)(v3);
		sub_917D0(/*v3*/);
		//fixed
		x_DWORD_181DAC[0] = 0xc8;
		x_DWORD_181DAC[1] = 0x01;//DB0
		x_DWORD_181DAC[2] = 0x800;//DB4
		x_DWORD_181DAC[3] = 0x64;//DB8
		x_DWORD_181DAC[4] = 0x10;//DBC
		x_DWORD_181DAC[5] = 0x64;//DC0
		x_DWORD_181DAC[6] = 0x28f;//DC4
		x_DWORD_181DAC[7] = 0x00;//DC8
		x_DWORD_181DAC[8] = 0x00;//DCC
		x_DWORD_181DAC[9] = 0x01;//DD0
		x_DWORD_181DAC[10] = 0x00;//DD4
		x_DWORD_181DAC[11] = 0x78;//DD8
		x_DWORD_181DAC[12] = 0x08;//DDC
		x_DWORD_181DAC[13] = 0x7f;//DE0
		x_DWORD_181DAC[14] = 0x01;//DE4
		x_DWORD_181DAC[15] = 0x00;//DE8
		x_DWORD_181DAC[16] = 0x02;//DEC
		x_DWORD_181DAC[17] = 0x01;//DF0
		x_DWORD_181DAC[18] = 0x01;//DF4

		//x_DWORD_181DB4 = 0x800;//fixed
		//x_DWORD_181DB8 = 0x64;//fixed
		//x_DWORD_181DBC = 0x10;//fixed
		//x_DWORD_181DC0 = 0x64;//fixed
		//x_DWORD_181DC4 = 0x028f;//fixed
		//x_DWORD_181DC8 = 0x00;//fixed
		//x_DWORD_181DCC = 0x00;//fixed
		//x_DWORD_181DD0 = 0x01;//fixed
		//x_DWORD_181DD4 = 0x00;//fixed
		//x_DWORD_181DD8 = 0x78;//fixed
		//x_DWORD_181DDC = 0x08;//fixed
		//x_DWORD_181DE0 = 0x7f;//fixed
		//x_DWORD_181DE4 = 0x01;//fixed
		//x_DWORD_181DE8 = 0x00;//fixed
		//x_DWORD_181DEC = 0x02;//fixed
		//x_DWORD_181DF0 = 0x01;//fixed
		//x_DWORD_181DF4 = 0x01;//fixed


		//x_DWORD_181DF8 = 0x00;//fixed
		//x_DWORD_181DFC = 0x00;//fixed
		//x_DWORD_181E00 = 0x00;//fixed
		//fixed

		x_BYTE_E37B8 = 1;
	}
	if (sub_90EE0() == -1)
	{
		x_BYTE_E3798_sound_active2 = 0;
		x_BYTE_E3799 = 0;
		if (x_BYTE_E37FC && x_BYTE_E37FE)
		{
			sub_99C90();
		}
		else
		{
			x_BYTE_E37FC = 0;
			x_BYTE_E37FD = 0;
			sub_919C0();
		}
		return;
	}
	size_t sz = 0;
	//v7x = _dupenv_s(&v7,&sz, "MDSOUND");//fix v7
	v7 = mygetenv("MDSOUND");
	if (v7)
	{
		sscanf_s((char *const)v7, "%s %x %d %d %d", (unsigned int)&v6);
		x_DWORD_180B48 = sub_93330_AIL_install_DIG_driver_file(/*(int)a1, */&v6, &v5);
		if (!x_DWORD_180B48)
		{
			if (!x_BYTE_E37FC)
				sub_919C0();
			sub_90F20_restore_old_directory();
			x_BYTE_E3798_sound_active2 = 0;
			x_BYTE_E3799 = 0;
			return;
		}
		sprintf_s(unk_180A30.driver_name, 512, "%s", &v6);
		x_WORD_180B30 = v5.IO;//fixed
		sub_93480_AIL_uninstall_DIG_driver((unsigned int *)x_DWORD_180B48);
		v10 = 1;
	}
	else
	{
		/*x_WORD_E2A14_sound_active = 1;// sound fixed
		x_WORD_E3804 = 6;// sound fixed
		return; // sound fixed*/
		if (sub_92190_AIL_read_INI(&unk_180A30, (char*)"DIG.INI"/*, unk_180AB0, v9x*/)) // sound driver
		{
			if (!_stricmp(unk_180A30.driver_name, "None"))//351ab0
			{
				if (!x_BYTE_E37FC)
					sub_919C0();
				sub_90F20_restore_old_directory();
				x_BYTE_E3798_sound_active2 = 0;
				x_BYTE_E3799 = 0;
				return;
			}
			if (!sub_931F0_AIL_install_DIG_INI(/*(int)a1, */&x_DWORD_180B48))//351b48
			{
				sub_93480_AIL_uninstall_DIG_driver((unsigned int *)x_DWORD_180B48);
				v10 = 1;
			}
		}
		if (!v10)
		{
			if (!x_BYTE_E37FC)
				sub_919C0();
			sub_90F20_restore_old_directory();
			x_BYTE_E3798_sound_active2 = 0;
			x_BYTE_E3799 = 0;
			return;
		}
		sub_90F20_restore_old_directory();
	}
	sub_90F20_restore_old_directory();
	sub_8D800_sound_proc2();
	if (x_WORD_E37B6_sound_number)
	{
		if (x_WORD_E37B6_sound_number < 0x336u)
		{
			if (x_WORD_E37B6_sound_number < 0x320u)
			{
				if (!x_WORD_E37B6_sound_number)
				{
					x_BYTE_E3798_sound_active2 = 0;
					x_BYTE_E3799 = 0;
					myprintf("\nCould not load any digital samples\n");
					return;
				}
			}
			else if (x_WORD_E37B6_sound_number <= 0x320u)
			{
				x_DWORD_E37BC = 11025;
				x_BYTE_E37AE = 0;
			}
			else if (x_WORD_E37B6_sound_number == 811)
			{
				x_DWORD_E37BC = 11025;
				x_BYTE_E37AE = 0;
			}
		}
		else if (x_WORD_E37B6_sound_number <= 0x336u)
		{
			x_DWORD_E37BC = 22050;
			x_BYTE_E37AE = 0;
		}
		else if (x_WORD_E37B6_sound_number < 0x656u)
		{
			if (x_WORD_E37B6_sound_number == 1611)
			{
				x_DWORD_E37BC = 11025;
				x_BYTE_E37AE = 1;
			}
		}
		else if (x_WORD_E37B6_sound_number <= 0x656u)
		{
			x_DWORD_E37BC = 22050;
			x_BYTE_E37AE = 1;
		}
		else if (x_WORD_E37B6_sound_number == 1644)
		{
			x_DWORD_E37BC = 44100;
			x_BYTE_E37AE = 1;
		}
		sub_91A80_AIL_set_preference(0, 200);
		sub_91A80_AIL_set_preference(1, x_DWORD_E37BC);
		sub_91A80_AIL_set_preference(3, 100);
		sub_91A80_AIL_set_preference(4, x_DWORD_E3794_sound_buffer3_lenght + 1);
		sub_91A80_AIL_set_preference(5, 127);
		sub_91A80_AIL_set_preference(6, 655);
		if (x_BYTE_E379C)
			sub_91A80_AIL_set_preference(7, 1);
		else
			sub_91A80_AIL_set_preference(7, 0);
		if (!x_BYTE_E379B)
			sub_91A80_AIL_set_preference(17, 0);
		if (x_BYTE_E37AE)
		{
			sub_91A80_AIL_set_preference(8, 1);
			sub_91A80_AIL_set_preference(9, 1);
		}
		else
		{
			sub_91A80_AIL_set_preference(8, 0);
			sub_91A80_AIL_set_preference(9, 0);
		}
		sub_90EE0();
		x_DWORD_180B48 = sub_93330_AIL_install_DIG_driver_file(/*(int)a1, */unk_180A30.driver_name, &unk_181D90);
		if (x_DWORD_180B48)//
		{
			sub_90F20_restore_old_directory();
			if (x_BYTE_E3798_sound_active2)
			{
				//x_DWORD_180B4C_end_sound_buffer3 = (Bit8u*)unk_180750_sound_buffer3 + 23 * x_DWORD_E3794_sound_buffer3_lenght;
				x_DWORD_180B4C_end_sound_buffer3_endindex = x_DWORD_E3794_sound_buffer3_lenght;
				//v8 = unk_180750_sound_buffer3;
				v8 = 0;
				v9 = 0;
				while (v8 < x_DWORD_180B4C_end_sound_buffer3_endindex)
				{
					unk_180750_sound_buffer3[v8] = sub_93510_AIL_allocate_sample_handle(x_DWORD_180B48);
					unk_180750_sound_buffer3[v8]->len_4_5[1] = 0;
					v8++;
					v9++;
				}
				x_BYTE_E379A = 1;
				sub_8E470_sound_proc17_volume(x_DWORD_E37B0);
			}
		}
		else
		{
			if (!x_BYTE_E37FC)
				sub_919C0();
			sub_90F20_restore_old_directory();
			x_BYTE_E3798_sound_active2 = 0;
			x_BYTE_E3799 = 0;
			sub_83E80_sound_proc_99(x_DWORD_E37A0_sound_buffer2);
			x_DWORD_E37A4_sound_buffer3 = 0;
			sub_83E80_sound_proc_99(x_DWORD_E37A8_sound_buffer1);
		}
	}
	else
	{
		if (!x_BYTE_E37FC)
			sub_919C0();
		x_BYTE_E3798_sound_active2 = 0;
		x_BYTE_E3799 = 0;
		myprintf("\nCould not load any digital samples\n");
	}
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// 98F5D: using guessed type x_DWORD stricmp(x_DWORD, x_DWORD);
// 99E33: using guessed type x_DWORD getenv(x_DWORD);
// 9E187: using guessed type x_DWORD sscanf(x_DWORD, x_DWORD, char);
// E3794: using guessed type int x_DWORD_E3794_sound_buffer3_lenght;
// E3798: using guessed type char x_BYTE_E3798_sound_active2;
// E3799: using guessed type char x_BYTE_E3799;
// E379A: using guessed type char x_BYTE_E379A;
// E379B: using guessed type char x_BYTE_E379B;
// E379C: using guessed type char x_BYTE_E379C;
// E37A0: using guessed type int x_DWORD_E37A0_sound_buffer2;
// E37A4: using guessed type int x_DWORD_E37A4_sound_buffer3;
// E37A8: using guessed type int x_DWORD_E37A8_sound_buffer1;
// E37AE: using guessed type char x_BYTE_E37AE;
// E37B0: using guessed type int x_DWORD_E37B0;
// E37B4: using guessed type __int16 x_WORD_E37B4;
// E37B6: using guessed type __int16 x_WORD_E37B6_sound_number;
// E37B8: using guessed type char x_BYTE_E37B8;
// E37BC: using guessed type int x_DWORD_E37BC;
// E37FC: using guessed type char x_BYTE_E37FC;
// E37FD: using guessed type char x_BYTE_E37FD;
// E37FE: using guessed type char x_BYTE_E37FE;
// 180B30: using guessed type __int16 x_WORD_180B30;
// 180B48: using guessed type int x_DWORD_180B48;
// 180B4C: using guessed type int x_DWORD_180B4C_end_sound_buffer3;

//----- (0008D800) --------------------------------------------------------
void sub_8D800_sound_proc2()//26E800
{
	signed int v0; // [esp+4h] [ebp-4h]

	v0 = 1;
	while (v0)
	{
		v0 = sub_84300_load_sound(x_BYTE_E37AC);
		if (v0)
		{
			if (x_WORD_E37B6_sound_number < 0x336u)
			{
				if (x_WORD_E37B6_sound_number >= 0x320u)
				{
					if (x_WORD_E37B6_sound_number <= 0x320u)
					{
						x_WORD_E37B6_sound_number = 0;
						return;
					}
					if (x_WORD_E37B6_sound_number == 811)
						x_WORD_E37B6_sound_number = 800;
				}
			}
			else if (x_WORD_E37B6_sound_number <= 0x336u)
			{
				x_WORD_E37B6_sound_number = 1611;
			}
			else if (x_WORD_E37B6_sound_number < 0x656u)
			{
				if (x_WORD_E37B6_sound_number == 1611)
					x_WORD_E37B6_sound_number = 811;
			}
			else if (x_WORD_E37B6_sound_number <= 0x656u)
			{
				x_WORD_E37B6_sound_number = 822;
			}
			else if (x_WORD_E37B6_sound_number == 1644)
			{
				x_WORD_E37B6_sound_number = 1622;
			}
		}
	}
}
// E37AC: using guessed type char x_BYTE_E37AC;
// E37B6: using guessed type __int16 x_WORD_E37B6_sound_number;

//----- (0008D8F0) --------------------------------------------------------
void sub_8D8F0_sound_proc3_endsample()//26e8f0
{
	Bit32u i; // [esp+0h] [ebp-4h]
	//i fix
	if (x_BYTE_E3798_sound_active2 && x_BYTE_E3799)//ma to byt 0 a 0 2b4798
	{
		sub_8F850_sound_proc22();//270850
		for (i = 0; i < x_DWORD_180B4C_end_sound_buffer3_endindex; i++)
		{
			sub_93D00_AIL_end_sample(unk_180750_sound_buffer3[i]);//274d00
			/*//*((x_WORD *)i + 9) = 0;
			unk_180750_sound_buffer3[i]->sam_var[4] &= 0x0000ffff;
			//*(int *)((char *)i + 14) = 0;
			unk_180750_sound_buffer3[i]->sam_var[3] &= 0x0000ffff;
			unk_180750_sound_buffer3[i]->sam_var[4] &= 0xffff0000;
			//*((x_BYTE *)i + 20) = 0;
			//*((x_BYTE *)i + 21) = 0;
			unk_180750_sound_buffer3[i]->sam_var[5] &= 0xffff0000;*/
			unk_180750_sound_buffer3[i]->vol_scale_18[0][0] = 0;//18
			unk_180750_sound_buffer3[i]->flags_14 = 0;//14
			unk_180750_sound_buffer3[i]->vol_scale_18[0][2] = 0;//20
			unk_180750_sound_buffer3[i]->vol_scale_18[0][3] = 0;//21
		}
	}
	/*return */sub_9F040();
}
// E3798: using guessed type char x_BYTE_E3798_sound_active2;
// E3799: using guessed type char x_BYTE_E3799;
// 180B4C: using guessed type int x_DWORD_180B4C_end_sound_buffer3;

//----- (0008D970) --------------------------------------------------------
void /*__fastcall*/ sub_8D970_init_music(char* a1/*int a1, int a2, char* a3*/)//26e970
{
	int(*v3)(int); // eax
	//char v4; // [esp+0h] [ebp-C8h]
	IO_PARMS v5 = {}; // [esp+90h] [ebp-38h]
	char v6; // [esp+A8h] [ebp-20h]
	char* v7; // [esp+B8h] [ebp-10h]
	char v8; // [esp+C0h] [ebp-8h]

	errno_t v7x;
	//fix it
	v7 = 0;
	//fix it

	//char v8x[200];
	//IO_PARMS v9x = {};

	v8 = 0;
	if (!x_BYTE_E37FC)
		return;
	if (!x_BYTE_E37B8)
	{
		sub_90F60();
		//sub_9D3F0_set_malloc_type(sub_83CD0_malloc2); fix it
		//v3 = sub_9D420((int (*)(int))sub_83E80_sound_proc_99);
		//((void (/*__fastcall*/ *)(int (*)(int)))loc_917D0)(v3);
		x_BYTE_E37B8 = 1;
	}
	sub_91A80_AIL_set_preference(11, 120);
	sub_91A80_AIL_set_preference(12, 1);
	sub_91A80_AIL_set_preference(13, 127);
	sub_91A80_AIL_set_preference(14, 1);
	sub_91A80_AIL_set_preference(15, 0);
	sub_91A80_AIL_set_preference(16, 12);
	if (!x_BYTE_E379B)
		sub_91A80_AIL_set_preference(17, 0);
	if (!strcmp(unk_181B50, "\\"))
		sprintf_s(printbuffer, 512, "%c:%sSOUND/SAMPLE", x_DWORD_181BE0 + 64, unk_181B50);
	else
		sprintf_s(printbuffer, 512, "%c:%s/SOUND/SAMPLE", x_DWORD_181BE0 + 64, unk_181B50);
	sub_96AE0_AIL_set_GTL_filename_prefix((Bit8u*)printbuffer);
	if ((char)sub_90EE0() == -1)
	{
		x_BYTE_E37FC = 0;
		x_BYTE_E37FD = 0;
		if (x_BYTE_E3798_sound_active2 && x_BYTE_E379A)
		{
			sub_99C10_sound_proc4();
		}
		else
		{
			x_BYTE_E3798_sound_active2 = 0;
			x_BYTE_E3799 = 0;
			sub_919C0();
		}
		return;
	}
	size_t sz = 0;
	//_dupenv_s(&v7,&sz, "MDMUSIC");
	v7 = mygetenv("MDMUSIC");
	if (v7)
	{
		sscanf_s((char *const)v7, "%s %x %d %d %d", (unsigned int)&v6);
		x_DWORD_180C7C = sub_95850_AIL_install_MDI_driver_file(/*a1,*/ &v6, &v5);
		if (!x_DWORD_180C7C)
		{
			if (!x_BYTE_E3798_sound_active2)
				sub_919C0();
			sub_90F20_restore_old_directory();
			x_BYTE_E37FC = 0;
			x_BYTE_E37FD = 0;
			return;
		}
		sprintf_s(unk_180BE0, 512, "%s", &v6);
		v8 = 1;
	}
	else
	{
		if (sub_92190_AIL_read_INI(&unk_180B60, (char*)"MDI.INI"/*,v8x,v9x*/)) //driver
		{
			if (!_stricmp(unk_180B60.driver_name, "None"))
			{
				if (!x_BYTE_E3798_sound_active2)
					sub_919C0();
				sub_90F20_restore_old_directory();
				x_BYTE_E37FC = 0;
				x_BYTE_E37FD = 0;
				return;
			}
			if (!sub_95710_AIL_install_MDI_INI(/*(int)a1, (int **)*/&x_DWORD_180C7C))
				v8 = 1;
		}
		if (!v8)
		{
			if (!x_BYTE_E3798_sound_active2)
				sub_919C0();
			sub_90F20_restore_old_directory();
			x_BYTE_E37FC = 0;
			x_BYTE_E37FD = 0;
			return;
		}
		sub_90F20_restore_old_directory();
	}
	sub_90F20_restore_old_directory();
	x_DWORD_180C78 = sub_95A30_AIL_allocate_sequence_handle(x_DWORD_180C7C);//driver
	if (!_stricmp(unk_180B60.driver_name, "ADLIB.MDI"))
	{
		sprintf_s(&x_BYTE_180C84_drivertype, 512, "f");
	LABEL_69:
		if (x_BYTE_E37FC && sub_8EAD0_load_music(x_BYTE_E3814))
		{
			if (x_BYTE_E3815 == 1)
			{
				sub_9FA80();
				x_BYTE_E3815 = 0;
			}
			sub_959A0_AIL_uninstall_MDI_driver(x_DWORD_180C7C);
			if (!x_BYTE_E3798_sound_active2)
				sub_919C0();
			x_BYTE_E37FC = 0;
			x_BYTE_E37FD = 0;
			myprintf("\nError opening music files\n");
		}
		else
		{
			x_BYTE_E37FE = 1;
			sub_8E410_sound_proc16_xmidivolume(x_DWORD_E37F8_midi_volume);
		}
		return;
	}
	if (!_stricmp(unk_180B60.driver_name, "ADLIBG.MDI"))
	{
		sprintf_s(&x_BYTE_180C84_drivertype, 512, "f");
		goto LABEL_69;
	}
	if (!_stricmp(unk_180B60.driver_name, "OPL3.MDI"))
	{
		sprintf_s(&x_BYTE_180C84_drivertype, 512, "f");
		goto LABEL_69;
	}
	if (!_stricmp(unk_180B60.driver_name, "PAS.MDI"))
	{
		sprintf_s(&x_BYTE_180C84_drivertype, 512, "f");
		goto LABEL_69;
	}
	if (!_stricmp(unk_180B60.driver_name, "PASPLUS.MDI"))
	{
		sprintf_s(&x_BYTE_180C84_drivertype, 512, "f");
		goto LABEL_69;
	}
	if (!_stricmp(unk_180B60.driver_name, "SBLASTER.MDI"))
	{
		sprintf_s(&x_BYTE_180C84_drivertype, 512, "f");
		goto LABEL_69;
	}
	if (!_stricmp(unk_180B60.driver_name, "SBPRO1.MDI"))
	{
		sprintf_s(&x_BYTE_180C84_drivertype, 512, "f");
		goto LABEL_69;
	}
	if (!_stricmp(unk_180B60.driver_name, "SBPRO2.MDI"))
	{
		sprintf_s(&x_BYTE_180C84_drivertype, 512, "f");
		goto LABEL_69;
	}
	if (!_stricmp(unk_180B60.driver_name, "ESFM.MDI"))
	{
		sprintf_s(&x_BYTE_180C84_drivertype, 512, "f");
		goto LABEL_69;
	}
	if (!_stricmp(unk_180B60.driver_name, "SBAWE32.MDI"))
	{
		sprintf_s(&x_BYTE_180C84_drivertype, 512, "w");
		sub_9F740((char*)"Bullfrog");
		if (!x_BYTE_E3815)
			sprintf_s(&x_BYTE_180C84_drivertype, 512, "g");
		goto LABEL_69;
	}
	if (!_stricmp(unk_180B60.driver_name, "MPU401.MDI"))
	{
		sprintf_s(&x_BYTE_180C84_drivertype, 512, "g");
		goto LABEL_69;
	}
	if (!_stricmp(unk_180B60.driver_name, "SNDSCAPE.MDI"))
	{
		sprintf_s(&x_BYTE_180C84_drivertype, 512, "g");
		goto LABEL_69;
	}
	if (!_stricmp(unk_180B60.driver_name, "MT32MPU.MDI"))
	{
		sprintf_s(&x_BYTE_180C84_drivertype, 512, "r");
		goto LABEL_69;
	}
	if (!sub_969A0_AIL_MDI_driver_type(x_DWORD_180C7C))
	{
		sprintf_s(&x_BYTE_180C84_drivertype, 512, "g");
		goto LABEL_69;
	}
	if (sub_969A0_AIL_MDI_driver_type(x_DWORD_180C7C) == 1 || sub_969A0_AIL_MDI_driver_type(x_DWORD_180C7C) == 2)
	{
		sprintf_s(&x_BYTE_180C84_drivertype, 512, "f");
		goto LABEL_69;
	}
	sub_959A0_AIL_uninstall_MDI_driver(x_DWORD_180C7C);
	if (!x_BYTE_E3798_sound_active2)
		sub_919C0();
	x_BYTE_E37FC = 0;
	x_BYTE_E37FD = 0;
	myprintf("\nError driver not supported\n");
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// 98F5D: using guessed type x_DWORD stricmp(x_DWORD, x_DWORD);
// 99E33: using guessed type x_DWORD getenv(x_DWORD);
// 9A050: using guessed type x_DWORD strcmp(x_DWORD, x_DWORD);
// 9E187: using guessed type x_DWORD sscanf(x_DWORD, x_DWORD, char);
// E3798: using guessed type char x_BYTE_E3798_sound_active2;
// E3799: using guessed type char x_BYTE_E3799;
// E379A: using guessed type char x_BYTE_E379A;
// E379B: using guessed type char x_BYTE_E379B;
// E37B8: using guessed type char x_BYTE_E37B8;
// E37F8: using guessed type int x_DWORD_E37F8_midi_volume;
// E37FC: using guessed type char x_BYTE_E37FC;
// E37FD: using guessed type char x_BYTE_E37FD;
// E37FE: using guessed type char x_BYTE_E37FE;
// E3814: using guessed type char x_BYTE_E3814;
// E3815: using guessed type char x_BYTE_E3815;
// 180C78: using guessed type int x_DWORD_180C78;
// 180C7C: using guessed type int x_DWORD_180C7C;
// 180C84: using guessed type char x_BYTE_180C84_drivertype;
// 181BE0: using guessed type int x_DWORD_181BE0;

//----- (0008E020) --------------------------------------------------------
void sub_8E020_sound_proc14_stopsequence()//26f020
{
	if (x_BYTE_E37FC && x_BYTE_E37FD && x_WORD_E3802)
	{
		if (x_BYTE_E3818)
			sub_92DC0_AIL_release_timer_handle(x_DWORD_180C80);
		x_BYTE_E3819 = 0;
		x_BYTE_E3818 = 0;
		x_BYTE_E3817 = 1;
		x_BYTE_E3816 = 0;
		x_BYTE_E381A = -1;
		if (sub_96170_AIL_sequence_status(x_DWORD_180C78) != 2)
		{
			sub_95DE0_AIL_stop_sequence(x_DWORD_180C78);
			sub_95F00_AIL_end_sequence(x_DWORD_180C78);
		}
		x_WORD_E3802 = 0;
	}
}
// E37FC: using guessed type char x_BYTE_E37FC;
// E37FD: using guessed type char x_BYTE_E37FD;
// E3802: using guessed type __int16 x_WORD_E3802;
// E3816: using guessed type char x_BYTE_E3816;
// E3817: using guessed type char x_BYTE_E3817;
// E3818: using guessed type char x_BYTE_E3818;
// E3819: using guessed type char x_BYTE_E3819;
// E381A: using guessed type char x_BYTE_E381A;
// 180C78: using guessed type int x_DWORD_180C78;
// 180C80: using guessed type int x_DWORD_180C80;

//----- (0008E160) --------------------------------------------------------
void sub_8E160_sound_proc15_startsequence(__int16 a1, unsigned __int8 a2)//26f160
{
	unsigned __int8 i; // [esp+0h] [ebp-4h]

	if (x_BYTE_E37FC && x_BYTE_E37FD && a1 <= x_WORD_E3804 && x_WORD_E3802 != a1)
	{
		if (x_BYTE_E3818)
			sub_92DC0_AIL_release_timer_handle(x_DWORD_180C80);
		x_BYTE_E3819 = 0;
		x_BYTE_E3818 = 0;
		x_BYTE_E3817 = 1;
		x_BYTE_E3816 = 0;
		x_BYTE_E381A = -1;
		if (x_WORD_E3802)
		{
			if (sub_96170_AIL_sequence_status(x_DWORD_180C78) != 2)
			{
				sub_95DE0_AIL_stop_sequence(x_DWORD_180C78);
				sub_95F00_AIL_end_sequence(x_DWORD_180C78);
			}
			x_WORD_E3802 = 0;
		}
		sub_95C00_AIL_init_sequence(x_DWORD_180C78, (Bit8u*)*(Bit32u*)(x_DWORD_E3808_music_header + 32 * a1 + 18), 0, a1);
		sub_97670_AIL_register_trigger_callback(x_DWORD_180C78, sub_8E0D0);
		/*for ( i = 0; i < 0x10u; i++ )
		{
		  x_BYTE_180C90[i] = 0;
		  sub_98360_AIL_send_channel_voice_message(x_DWORD_180C7C, x_DWORD_180C78, i | 0xB0, 0, 0);
		  sub_98360_AIL_send_channel_voice_message(x_DWORD_180C7C, x_DWORD_180C78, i | 0xB0, 7u, 0);
		  sub_98360_AIL_send_channel_voice_message(x_DWORD_180C7C, x_DWORD_180C78, i | 0xE0, 0, 64);
		  sub_98360_AIL_send_channel_voice_message(x_DWORD_180C7C, x_DWORD_180C78, i | 0xB0, 0xBu, 127);
		  sub_98360_AIL_send_channel_voice_message(x_DWORD_180C7C, x_DWORD_180C78, i | 0xB0, 1u, 0);
		  sub_98360_AIL_send_channel_voice_message(x_DWORD_180C7C, x_DWORD_180C78, i | 0xB0, 0x5Bu, 0);
		  sub_98360_AIL_send_channel_voice_message(x_DWORD_180C7C, x_DWORD_180C78, i | 0xB0, 0x5Du, 0);
		}*/
		if (a2 < 0x7Fu)
			sub_96030_AIL_set_sequence_volume(x_DWORD_180C78, a2, 0);
		sub_95D50_AIL_start_sequence(x_DWORD_180C78, a1);
		x_WORD_E3800 = 100;
		x_WORD_E3802 = a1;
	}
}
// 8E0D0: using guessed type int sub_8E0D0();
// E37FC: using guessed type char x_BYTE_E37FC;
// E37FD: using guessed type char x_BYTE_E37FD;
// E3800: using guessed type __int16 x_WORD_E3800;
// E3802: using guessed type __int16 x_WORD_E3802;
// E3804: using guessed type __int16 x_WORD_E3804;
// E3808: using guessed type int x_DWORD_E3808_music_header;
// E3816: using guessed type char x_BYTE_E3816;
// E3817: using guessed type char x_BYTE_E3817;
// E3818: using guessed type char x_BYTE_E3818;
// E3819: using guessed type char x_BYTE_E3819;
// E381A: using guessed type char x_BYTE_E381A;
// 180C78: using guessed type int x_DWORD_180C78;
// 180C7C: using guessed type int x_DWORD_180C7C;
// 180C80: using guessed type int x_DWORD_180C80;

//----- (0008E410) --------------------------------------------------------
void sub_8E410_sound_proc16_xmidivolume(Bit32s master_volume)//26f410
{
	if (x_BYTE_E37FC)
	{
		if (x_BYTE_E37FE)
		{
			if (master_volume != x_DWORD_E37F8_midi_volume && master_volume <= 127 && master_volume >= 0)
			{
				sub_96670_AIL_set_XMIDI_master_volume(x_DWORD_180C7C, master_volume);
				x_DWORD_E37F8_midi_volume = master_volume;
			}
		}
	}
}
// E37F8: using guessed type int x_DWORD_E37F8_midi_volume;
// E37FC: using guessed type char x_BYTE_E37FC;
// E37FE: using guessed type char x_BYTE_E37FE;
// 180C7C: using guessed type int x_DWORD_180C7C;

//----- (0008E470) --------------------------------------------------------
int sub_8E470_sound_proc17_volume(int a1)//26f470
{
	int result = 0; // eax

	if (x_BYTE_E3798_sound_active2)
	{
		if (x_BYTE_E379A)//2b479a
		{
			result = a1;
			if (a1 != x_DWORD_E37B0 && a1 <= 127 && a1 >= 0)
			{
				sub_94650_AIL_set_digital_master_volume((x_DWORD *)x_DWORD_180B48, a1);
				result = a1;
				x_DWORD_E37B0 = a1;
			}
		}
	}
	return result;
}
// E3798: using guessed type char x_BYTE_E3798_sound_active2;
// E379A: using guessed type char x_BYTE_E379A;
// E37B0: using guessed type int x_DWORD_E37B0;
// 180B48: using guessed type int x_DWORD_180B48;

//----- (0008E673) --------------------------------------------------------
__int16 sub_8E673()
{
	__int16 result; // ax

	sub_8F023(x_DWORD_E3840, (int)&x_WORD_E3828, 2u);
	sub_8F023(x_DWORD_E3840, (int)x_DWORD_E9C38_smalltit, 8u);
	while (1)
	{
		result = x_WORD_E3828;
		if (!x_WORD_E3828)
			break;
		--x_WORD_E3828;
		sub_8F023(x_DWORD_E3840, (int)&x_DWORD_E3824, 4u);
		sub_8F023(x_DWORD_E3840, (int)&x_WORD_E381C, 2u);
		switch (x_WORD_E381C)
		{
		case 7:
			sub_8E871();
			break;
		case 12:
			sub_8E948();
			break;
		case 4:
			sub_8E7D5();
			break;
		case 15:
			sub_8E9EF();
			break;
		case 16:
			sub_8E799();
			break;
		default:
			sub_8E7B7();
			break;
		}
	}
	return result;
}
// E381C: using guessed type __int16 x_WORD_E381C;
// E3824: using guessed type int x_DWORD_E3824;
// E3828: using guessed type __int16 x_WORD_E3828;
// E3840: using guessed type int x_DWORD_E3840;
// E9C38: using guessed type int x_DWORD_E9C38_smalltit;

//----- (0008E736) --------------------------------------------------------
__int16 sub_8E736()
{
	__int16 result; // ax

	sub_8F023(x_DWORD_E3840, (int)x_DWORD_E9C38_smalltit, x_DWORD_E3824 - 6);
	x_WORD_E381E = *(x_WORD *)x_DWORD_E9C38_smalltit;
	x_WORD_E3820 = *(x_WORD *)(x_DWORD_E9C38_smalltit + 2);
	result = *(x_WORD *)(x_DWORD_E9C38_smalltit + 4);
	x_WORD_E3822 = *(x_WORD *)(x_DWORD_E9C38_smalltit + 4);
	return result;
}
// E381E: using guessed type __int16 x_WORD_E381E;
// E3820: using guessed type __int16 x_WORD_E3820;
// E3822: using guessed type __int16 x_WORD_E3822;
// E3824: using guessed type int x_DWORD_E3824;
// E3840: using guessed type int x_DWORD_E3840;
// E9C38: using guessed type int x_DWORD_E9C38_smalltit;

//----- (0008E799) --------------------------------------------------------
int sub_8E799()
{
	return sub_8F023(x_DWORD_E3840, (int)x_DWORD_180628b_screen_buffer, x_DWORD_E3824 - 6);
}
// E3824: using guessed type int x_DWORD_E3824;
// E3840: using guessed type int x_DWORD_E3840;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;

//----- (0008E7B7) --------------------------------------------------------
int sub_8E7B7()
{
	return sub_8F023(x_DWORD_E3840, (int)x_DWORD_E9C38_smalltit, x_DWORD_E3824 - 6);
}
// E3824: using guessed type int x_DWORD_E3824;
// E3840: using guessed type int x_DWORD_E3840;
// E9C38: using guessed type int x_DWORD_E9C38_smalltit;

//----- (0008E7D5) --------------------------------------------------------
int sub_8E7D5()
{
	int result; // eax

	result = sub_8F023(x_DWORD_E3840, x_DWORD_EA3C8, x_DWORD_E3824 - 6);
	x_WORD_E387A = 1;
	return result;
}
// E3824: using guessed type int x_DWORD_E3824;
// E3840: using guessed type int x_DWORD_E3840;
// E387A: using guessed type __int16 x_WORD_E387A;
// EA3C8: using guessed type int x_DWORD_EA3C8;

//----- (0008E7FC) --------------------------------------------------------
void sub_8E7FC()
{
	__int16 v0; // ax
	char *v1; // edi
	x_BYTE *v2; // esi
	int v3; // ecx
	char *v4; // edi
	char v5; // dl
	char v6; // al
	char *v7; // edi
	x_BYTE *v8; // esi
	char v9; // al
	char v10; // al
	__int16 v11; // [esp-2h] [ebp-6h]

	x_WORD_E387A = 0;
	if (x_DWORD_E383C == 1)
	{
		v0 = *(x_WORD *)x_DWORD_EA3C8;
		v1 = (char *)(x_DWORD_EA3C8 + 2);
		v2 = (x_BYTE *)x_DWORD_EA3B8;
		do
		{
			v11 = v0;
			v3 = (unsigned __int8)*v1;
			v4 = v1 + 1;
			v2 += v3 + v3 + v3;
			v5 = *v4;
			v1 = (char*)(x_WORD*)(v4 + 1);
			do
			{
				v6 = *v1;
				v7 = v1 + 1;
				*v2 = v6;
				v8 = v2 + 1;
				v9 = *v7++;
				*v8++ = v9;
				v10 = *v7;
				v1 = v7 + 1;
				*v8 = v10;
				v2 = v8 + 1;
				--v5;
			} while (v5);
			v0 = v11 - 1;
		} while (v11 != 1);
		sub_41A90_VGA_pallette_install((unsigned __int8 *)x_DWORD_EA3B8);
	}
}
// E383C: using guessed type int x_DWORD_E383C;
// E387A: using guessed type __int16 x_WORD_E387A;
// EA3B8: using guessed type int x_DWORD_EA3B8;
// EA3C8: using guessed type int x_DWORD_EA3C8;

//----- (0008E871) --------------------------------------------------------
__int16 sub_8E871()
{
	x_WORD *v0; // esi
	x_WORD *v1; // edi
	__int16 result; // ax
	unsigned __int8 v3; // bl
	x_BYTE *v4; // edi
	char v5; // dl
	__int16 v6; // bx
	__int16 v7; // bx
	x_WORD *v8; // [esp+0h] [ebp-10h]
	__int16 i; // [esp+6h] [ebp-Ah]
	__int16 v10; // [esp+8h] [ebp-8h]
	int v11; // [esp+Ch] [ebp-4h]

	v11 = (unsigned __int16)x_WORD_E3820;
	sub_8F023(x_DWORD_E3840, (int)x_DWORD_E9C38_smalltit, x_DWORD_E3824 - 6);
	v0 = (x_WORD *)x_DWORD_180628b_screen_buffer;
	v10 = *(x_WORD *)x_DWORD_E9C38_smalltit;
	v1 = (x_WORD *)(x_DWORD_E9C38_smalltit + 2);
	do
	{
		while (1)
		{
			result = *v1;
			++v1;
			v8 = v0;
			if (result >= 0)
				goto LABEL_6;
			if (!(result & 0x4000))
				break;
			v0 = (x_WORD *)((char *)v0 + v11 * -result);
		}
		*((x_BYTE *)v0 + v11 - 1) = result;
	LABEL_6:
		for (i = result; i; i--)
		{
			while (1)
			{
				v3 = *(x_BYTE *)v1;
				v4 = (char *)v1 + 1;
				v0 = (x_WORD *)((char *)v0 + v3);
				v5 = *v4;
				v1 = (x_WORD*)(v4 + 1);
				if (v5 > 0)
					break;
				v6 = *v1;
				++v1;
				do
				{
					*v0 = v6;
					++v0;
					++v5;
				} while (v5);
				if (!--i)
					goto LABEL_14;
			}
			do
			{
				v7 = *v1;
				++v1;
				*v0 = v7;
				++v0;
				--v5;
			} while (v5);
		}
	LABEL_14:
		v0 = (x_WORD *)((char *)v8 + v11);
		--v10;
	} while (v10);
	return result;
}
// E3820: using guessed type __int16 x_WORD_E3820;
// E3824: using guessed type int x_DWORD_E3824;
// E3840: using guessed type int x_DWORD_E3840;
// E9C38: using guessed type int x_DWORD_E9C38_smalltit;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;

//----- (0008E948) --------------------------------------------------------
int sub_8E948()
{
	int v0; // ST1C_4
	int v1; // eax
	char *v2; // esi
	int v3; // edi
	__int16 v4; // ax
	int v5; // eax
	x_BYTE *v6; // esi
	char *v7; // edi
	unsigned __int8 v8; // al
	char *v9; // esi
	unsigned int v10; // ecx
	char v11; // al
	int result; // eax
	int v13; // [esp+0h] [ebp-10h]
	__int16 i; // [esp+6h] [ebp-Ah]
	__int16 v15; // [esp+8h] [ebp-8h]

	v0 = (unsigned __int16)x_WORD_E3820;
	v1 = sub_8F023(x_DWORD_E3840, (int)x_DWORD_E9C38_smalltit, x_DWORD_E3824 - 6);
	LOWORD(v1) = *(x_WORD *)x_DWORD_E9C38_smalltit;
	v13 = v0 * v1 + (int)x_DWORD_180628b_screen_buffer;
	v2 = (char *)(x_DWORD_E9C38_smalltit + 4);
	v15 = *(x_WORD *)(x_DWORD_E9C38_smalltit + 2);
	do
	{
		v3 = v13;
		v4 = (unsigned __int8)*v2++;
		for (i = v4; i; i--)
		{
			v5 = (unsigned __int8)*v2;
			v6 = v2 + 1;
			v7 = (char *)(v5 + v3);
			v8 = *v6;
			v9 = v6 + 1;
			if ((v8 & 0x80u) != 0)
			{
				v10 = (unsigned __int8)-v8;
				v11 = *v9;
				v2 = v9 + 1;
				memset(v7, v11, v10);
				v3 = (int)&v7[v10];
			}
			else
			{
				qmemcpy(v7, v9, v8);
				v2 = &v9[v8];
				v3 = (int)&v7[v8];
			}
		}
		result = (unsigned __int16)x_WORD_E3820;
		v13 += (unsigned __int16)x_WORD_E3820;
		--v15;
	} while (v15);
	return result;
}
// E3820: using guessed type __int16 x_WORD_E3820;
// E3824: using guessed type int x_DWORD_E3824;
// E3840: using guessed type int x_DWORD_E3840;
// E9C38: using guessed type int x_DWORD_E9C38_smalltit;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;

//----- (0008E9EF) --------------------------------------------------------
char sub_8E9EF()
{
	__int16 v0; // ST0C_2
	x_BYTE *v1; // esi
	char *v2; // edi
	__int16 v3; // bx
	__int16 v4; // cx
	unsigned __int8 v5; // dl
	__int16 v6; // ax
	char v7; // dh
	char v8; // dh
	__int16 v10; // [esp+2h] [ebp-2h]

	v10 = x_WORD_E3820;
	v0 = x_WORD_E3822;
	sub_8F023(x_DWORD_E3840, (int)x_DWORD_E9C38_smalltit, x_DWORD_E3824 - 6);
	v1 = (x_BYTE *)x_DWORD_180628b_screen_buffer;
	v2 = (char *)x_DWORD_E9C38_smalltit;
	v3 = v0;
	do
	{
		++v2;
		v4 = v10;
		do
		{
			v5 = *v2++;
			if ((char)v5 > 0)
			{
				LOBYTE(v6) = v5;
				v4 -= v5;
			}
			else
			{
				HIBYTE(v6) = -1;
				LOBYTE(v6) = v5;
				v4 += v6;
			}
			if ((char)v5 > 0)
			{
				v8 = *v2++;
				do
				{
					*v1++ = v8;
					--v5;
				} while (v5);
			}
			else
			{
				do
				{
					v7 = *v2++;
					*v1++ = v7;
					++v5;
				} while (v5);
			}
		} while (v4);
		--v3;
	} while (v3);
	return v6;
}
// E3820: using guessed type __int16 x_WORD_E3820;
// E3822: using guessed type __int16 x_WORD_E3822;
// E3824: using guessed type int x_DWORD_E3824;
// E3840: using guessed type int x_DWORD_E3840;
// E9C38: using guessed type int x_DWORD_E9C38_smalltit;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;

//----- (0008EA7B) --------------------------------------------------------
void /*__fastcall*/ sub_8EA7B(int a1, unsigned __int16 a2)
{
	__int16 v2; // dx
	__int16 v3; // cx

	if (x_DWORD_E3844)
	{
		do
		{
			do
			{
				// fix it:__asm { int     21h; DOS - GET CURRENT TIME }
				v2 = 100 * HIBYTE(a2) + (unsigned __int8)a2;
				v3 = v2;
				a2 = v2 - x_WORD_E3834;
			} while (!a2);
			if ((signed __int16)a2 <= 0)
				a2 += 6000;
		} while (a2 < x_DWORD_E3844);
		x_WORD_E3834 = v3;
	}
}
// E3834: using guessed type __int16 x_WORD_E3834;
// E3844: using guessed type int x_DWORD_E3844;

//----- (0008EAD0) --------------------------------------------------------
signed int sub_8EAD0_load_music(int channell)//26fad0
{
	Bit16s driverarray[4]; // [esp+44h] [ebp-1Ch]
	FILE* filehandle; // [esp+50h] [ebp-10h]
	int datapos; // [esp+54h] [ebp-Ch]
	int finaldrivernumber; // [esp+58h] [ebp-8h]
	int filelenght; // [esp+5Ch] [ebp-4h]
	int channellplus; // [esp+74h] [ebp+14h]

	if (!x_BYTE_E37FC)
		return 0;
	sub_8E020_sound_proc14_stopsequence();
	filehandle = sub_98817_open((char*)"SOUND/MUSIC.DAT", 512);
	if (!filehandle)
		return 0;
	sub_9891E_seek(filehandle, 0, 2);
	filelenght = myftell(filehandle);
	sub_9891E_seek(filehandle, filelenght - 4, 0);
	sub_988A7_read(filehandle, (Bit8u*)&datapos, 4);
	sub_9891E_seek(filehandle, datapos, 0);
	sub_988A7_read(filehandle, (Bit8u*)driverarray, 8);
	channellplus = channell + 1;
	if (x_BYTE_180C84_drivertype < 'W')
	{
		if (x_BYTE_180C84_drivertype >= 'G')
		{
			if (x_BYTE_180C84_drivertype > 'G')
			{
				if (x_BYTE_180C84_drivertype == 'R')
					goto LABEL_21;
				goto LABEL_24;
			}
		LABEL_20:
			finaldrivernumber = 0;
			goto LABEL_24;
		}
		if (x_BYTE_180C84_drivertype != 'F')
			goto LABEL_24;
	LABEL_22:
		finaldrivernumber = 2;
		goto LABEL_24;
	}
	if (x_BYTE_180C84_drivertype <= 'W')
		goto LABEL_23;
	if (x_BYTE_180C84_drivertype < 'g')
	{
		if (x_BYTE_180C84_drivertype != 'f')
			goto LABEL_24;
		goto LABEL_22;
	}
	if (x_BYTE_180C84_drivertype <= 'g')
		goto LABEL_20;
	if (x_BYTE_180C84_drivertype >= 'r')
	{
		if (x_BYTE_180C84_drivertype > 'r')
		{
			if (x_BYTE_180C84_drivertype != 'w')
				goto LABEL_24;
		LABEL_23:
			finaldrivernumber = 3;
			goto LABEL_24;
		}
	LABEL_21:
		finaldrivernumber = 1;
	}
LABEL_24:
	if (channellplus <= driverarray[finaldrivernumber])
	{
		sub_9891E_seek(filehandle, (channellplus - 1) << 6, 1);
		if (!sub_8ED00_load_music_track(filehandle, finaldrivernumber))
		{
			sub_98882_close(filehandle);
			return 1;
		}
		sub_98882_close(filehandle);
		return 0;
	}
	sub_98882_close(filehandle);
	return 1;
}
// 9A510: using guessed type x_DWORD tell(x_DWORD);
// E37FC: using guessed type char x_BYTE_E37FC;
// 180C84: using guessed type char x_BYTE_180C84_drivertype;
// 8EAD0: using guessed type char var_1C[8];

//----- (0008EC90) --------------------------------------------------------
void sub_8EC90_get_music_sequence_count()//26fc90 // set index
{
	Bit8u* v1; // [esp+0h] [ebp-4h]

	if (x_DWORD_E3808_music_header && x_DWORD_E3810_music_data)
	{
		v1 = (Bit8u*)x_DWORD_E3808_music_header + 32;
		for (x_WORD_E3804 = 0;v1 < x_DWORD_E380C; x_WORD_E3804++)
		{
			*(x_DWORD *)(v1 + 18) += (int)x_DWORD_E3810_music_data;
			v1 += 32;
		}
	}
}
// E3804: using guessed type __int16 x_WORD_E3804;
// E3808: using guessed type int x_DWORD_E3808_music_header;
// E380C: using guessed type int x_DWORD_E380C;
// E3810: using guessed type int x_DWORD_E3810_music_data;

//----- (0008ED00) --------------------------------------------------------
char sub_8ED00_load_music_track(FILE* filehandle, Bit8u drivernumber)//26fd00
{
	Bit32s header[16]; // [esp+0h] [ebp-5Ch] //355024
	//Bit8u* midibuffer1; // [esp+40h] [ebp-1Ch]
	int filelenght; // [esp+44h] [ebp-18h]
	//Bit8u* midibuffer2; // [esp+4Ch] [ebp-10h]
	int rncsize; // [esp+50h] [ebp-Ch]
	unsigned __int8 i; // [esp+58h] [ebp-4h]

	filelenght = myftell(filehandle);
	sub_988A7_read(filehandle, (Bit8u*)header, 64);
	if (header[1 + 4 * drivernumber] == -1)
		return 0;
	if (x_DWORD_E3810_music_data)
	{
		sub_83E80_sound_proc_99(x_DWORD_E3810_music_data);
		x_BYTE_E37FC = 0;
	}
	if (x_DWORD_E3808_music_header)
	{
		sub_83E80_sound_proc_99((Bit8u*)x_DWORD_E3808_music_header);
		x_BYTE_E37FC = 0;
	}
	x_DWORD_E3810_music_data = (Bit8u*)sub_83CD0_malloc2(header[3 + 4 * drivernumber]);
	if (!x_DWORD_E3810_music_data)
		return 0;
	x_DWORD_E3808_music_header = (Bit8u*)sub_83CD0_malloc2(header[2 + 4 * drivernumber]);
	if (!x_DWORD_E3808_music_header)
	{
		sub_83E80_sound_proc_99(x_DWORD_E3810_music_data);
		return 0;
	}
	//midibuffer1 = x_DWORD_E3810_music_data;
	//midibuffer2 = x_DWORD_E3808_music_header;
	x_DWORD_E380C = (Bit8u*)&x_DWORD_E3808_music_header[header[2 + 4 * drivernumber]];//?
	sub_9891E_seek(filehandle, header[1 + 4 * drivernumber], 0);
	sub_988A7_read(filehandle, x_DWORD_E3810_music_data, 8);
	if (x_DWORD_E3810_music_data[0] == 'R' && x_DWORD_E3810_music_data[1] == 'N' && x_DWORD_E3810_music_data[2] == 'C')//RNC
	{
		rncsize = x_DWORD_E3810_music_data[4];
		rncsize <<= 8;
		rncsize += x_DWORD_E3810_music_data[5];
		rncsize <<= 8;
		rncsize += x_DWORD_E3810_music_data[6];
		rncsize <<= 8;
		rncsize += x_DWORD_E3810_music_data[7];
		sub_988A7_read(filehandle, (x_DWORD_E3810_music_data + 8), rncsize - 8);
		sub_9894C_decompress(x_DWORD_E3810_music_data, x_DWORD_E3810_music_data);
	}
	else
	{
		sub_988A7_read(filehandle, (x_DWORD_E3810_music_data + 8), header[3 + 4 * drivernumber] - 8);
	}
	sub_9891E_seek(filehandle, header[4 * drivernumber], 0);
	sub_988A7_read(filehandle, (Bit8u*)x_DWORD_E3808_music_header, 8);
	if (x_DWORD_E3808_music_header[0] == 'R' && x_DWORD_E3808_music_header[1] == 'N' && x_DWORD_E3808_music_header[2] == 'C')//RNC
	{
		rncsize = x_DWORD_E3808_music_header[4];
		rncsize <<= 8;
		rncsize += x_DWORD_E3808_music_header[5];
		rncsize <<= 8;
		rncsize += x_DWORD_E3808_music_header[6];
		rncsize <<= 8;
		rncsize += x_DWORD_E3808_music_header[7];
		sub_988A7_read(filehandle, (Bit8u*)(x_DWORD_E3808_music_header + 8), rncsize - 8);
		sub_9894C_decompress((Bit8u*)x_DWORD_E3808_music_header, (Bit8u*)x_DWORD_E3808_music_header);
	}
	else
	{
		sub_988A7_read(filehandle, (Bit8u*)(x_DWORD_E3808_music_header + 8), header[2 + 4 * drivernumber] - 8);
	}
	sub_8EC90_get_music_sequence_count();

	for (i = 1; i <= x_WORD_E3804; i++)//2b4804 - 6
		sub_95C00_AIL_init_sequence(x_DWORD_180C78, (Bit8u*)*(x_DWORD *)(x_DWORD_E3808_music_header + 32 * i + 18), 0, i);
	x_BYTE_E37FC = 1;
	return 1;
}
// 9A510: using guessed type x_DWORD tell(x_DWORD);
// E37FC: using guessed type char x_BYTE_E37FC;
// E3804: using guessed type __int16 x_WORD_E3804;
// E3808: using guessed type int x_DWORD_E3808_music_header;
// E380C: using guessed type int x_DWORD_E380C;
// E3810: using guessed type int x_DWORD_E3810_music_data;
// 180C78: using guessed type int x_DWORD_180C78;
// 8ED00: using guessed type char var_5C[64];

//----- (0008F023) --------------------------------------------------------
int sub_8F023(int a1, int a2, unsigned int a3)
{
	x_BYTE *v3; // eax
	x_BYTE *v4; // edx
	unsigned int i; // [esp+4h] [ebp-4h]

	if (!x_DWORD_E387C)
		return sub_988A7_read((FILE*)a1, (Bit8u*)a2, a3);
	for (i = 0; i < a3 && x_DWORD_E3888 + i < x_DWORD_E3884; i++)
	{
		v3 = (x_BYTE *)x_DWORD_E3880++;
		v4 = (x_BYTE *)a2++;
		*v4 = *v3;
	}
	x_DWORD_E3888 += a3;
	return i;
}
// E387C: using guessed type int x_DWORD_E387C;
// E3880: using guessed type int x_DWORD_E3880;
// E3884: using guessed type int x_DWORD_E3884;
// E3888: using guessed type int x_DWORD_E3888;

//----- (0008F0AB) --------------------------------------------------------
int sub_8F0AB(FILE* a1, int a2, int a3)
{
	int result; // eax

	result = x_read(a1, (Bit8u*)x_DWORD_E387C, a3);
	x_DWORD_E3880 = x_DWORD_E387C;
	x_DWORD_E3884 = result;
	x_DWORD_E3888 = 0;
	return result;
}
// A0863: using guessed type x_DWORD read(x_DWORD, x_DWORD, x_DWORD);
// E387C: using guessed type int x_DWORD_E387C;
// E3880: using guessed type int x_DWORD_E3880;
// E3884: using guessed type int x_DWORD_E3884;
// E3888: using guessed type int x_DWORD_E3888;

//----- (0008F100) --------------------------------------------------------
HSAMPLE* sub_8F100_sound_proc19(Bit32u a1, __int16 a2, int a3, int a4, unsigned __int16 a5, char a6, unsigned __int8 a7)//270100
{
	char v8; // [esp+0h] [ebp-18h]
	Bit32u i; // [esp+8h] [ebp-10h]
	Bit32u j; // [esp+8h] [ebp-10h]
	Bit32u k; // [esp+8h] [ebp-10h]
	Bit32u l; // [esp+8h] [ebp-10h]
	Bit32u m; // [esp+8h] [ebp-10h]
	//int **v14; // [esp+Ch] [ebp-Ch]
	HSAMPLE* v14;
	HSAMPLE* v15; // [esp+10h] [ebp-8h]

	//fix it
	v14 = 0;
	v15 = 0;
	//fix it

	if (!x_BYTE_E3798_sound_active2
		|| !x_BYTE_E3799
		|| a2 > (signed int)x_WORD_180B50
		|| !_stricmp((const char *)(32 * a2 + x_DWORD_E37A0_sound_buffer2), "null.wav"))
	{
		return 0;
	}
	v8 = 0;
	if (a7 == 1)
	{
		v14 = 0;
		for (i = 0; i < x_DWORD_180B4C_end_sound_buffer3_endindex; i++)
		{
			if (sub_94010_AIL_sample_status(unk_180750_sound_buffer3[i]) == 2)
			{
				v14 = &unk_180750_sound_buffer3[i];
				v15 = 0;
				break;
			}
		}
	}
	else if (a7 == 2u)
	{
		v15 = 0;
		for (j = 0; j < x_DWORD_180B4C_end_sound_buffer3_endindex; j++)
		{
			if (unk_180750_sound_buffer3[j]->flags_14 == a1 && unk_180750_sound_buffer3[j]->vol_scale_18[0][0] == a2 && sub_94010_AIL_sample_status(unk_180750_sound_buffer3[j]) != 2)
			{
				v15 = &unk_180750_sound_buffer3[j];
				break;
			}
		}
		if (!v15)
		{
			v14 = 0;
			for (k = 0; k < x_DWORD_180B4C_end_sound_buffer3_endindex; k++)
			{
				if (sub_94010_AIL_sample_status(unk_180750_sound_buffer3[k]) == 2)
				{
					v14 = &unk_180750_sound_buffer3[k];
					break;
				}
			}
		}
	}
	else if (a7 == 3)
	{
		v8 = 0;
		for (l = 0; l < x_DWORD_180B4C_end_sound_buffer3_endindex; l++)
		{
			if (unk_180750_sound_buffer3[l]->flags_14 == a1 && unk_180750_sound_buffer3[l]->vol_scale_18[0][0] == a2)
			{
				v14 = &unk_180750_sound_buffer3[l];
				v15 = 0;
				v8 = 1;
				break;
			}
		}
		if (!v8)
		{
			v14 = 0;
			for (m = 0; m < x_DWORD_180B4C_end_sound_buffer3_endindex; m++)
			{
				if (sub_94010_AIL_sample_status(unk_180750_sound_buffer3[m]) == 2)
				{
					v14 = &unk_180750_sound_buffer3[m];
					v15 = 0;
					break;
				}
			}
		}
	}
	if (!v14 || v15)
		return 0;
	if (!v8)
	{
		sub_93830_AIL_init_sample(*v14);
		//4-when
		//5-see you
		//6-i am
		//a2 = 6;//debug
		sub_938C0_AIL_set_sample_file(*v14, (Bit8u*)*(x_DWORD *)(x_DWORD_E37A0_sound_buffer2 + 32 * a2 + 18), 1);
		//last_sample = v14[0];
	}
	sub_93E30_AIL_set_sample_volume(*v14, a3);
	sub_93ED0_AIL_set_sample_volume_pan(*v14, a4);
	sub_93D90_AIL_set_sample_playback_rate(*v14, x_DWORD_E37BC * a5 / 0x64);
	sub_93F70_AIL_set_sample_loop_count(*v14, a6 + 1);
	sub_93B50_AIL_start_sample(*v14);
	v14[0]->flags_14 = a1;
	v14[0]->vol_scale_18[0][0] = a2;
	v14[0]->status_1 = a3;
	v14[0]->len_4_5[1] = a4;
	//v14[0]->len_4_5[0] = a5;
	v14[0]->vol_scale_18[0][2] = 0;
	v14[0]->vol_scale_18[0][3] = 0; //fixed
	return v14;
}
// 98F5D: using guessed type x_DWORD stricmp(x_DWORD, x_DWORD);
// E3798: using guessed type char x_BYTE_E3798_sound_active2;
// E3799: using guessed type char x_BYTE_E3799;
// E37A0: using guessed type int x_DWORD_E37A0_sound_buffer2;
// E37BC: using guessed type int x_DWORD_E37BC;
// 180B4C: using guessed type int x_DWORD_180B4C_end_sound_buffer3;
// 180B50: using guessed type __int16 x_WORD_180B50;

//----- (0008F420) --------------------------------------------------------
void sub_8F420_sound_proc20(int a1, __int16 a2)
{
	Bit32u i; // [esp+0h] [ebp-4h]

	if (x_BYTE_E3798_sound_active2 && x_BYTE_E3799)
	{
		for (i = 0; i < x_DWORD_180B4C_end_sound_buffer3_endindex; i++)
		{
			if (unk_180750_sound_buffer3[i]->flags_14 == a1 && unk_180750_sound_buffer3[i]->vol_scale_18[0][0] == a2 && sub_94010_AIL_sample_status(unk_180750_sound_buffer3[i]) != 2)
			{
				sub_93D00_AIL_end_sample(unk_180750_sound_buffer3[i]);
				return;
			}
		}
	}
}
// E3798: using guessed type char x_BYTE_E3798_sound_active2;
// E3799: using guessed type char x_BYTE_E3799;
// 180B4C: using guessed type int x_DWORD_180B4C_end_sound_buffer3;

//----- (0008F710) --------------------------------------------------------
void sub_8F710_sound_proc21(int a1, __int16 a2, signed int a3, unsigned __int8 a4, char a5)
{
	Bit32u i; // [esp+0h] [ebp-4h]

	if (x_BYTE_E3798_sound_active2 && x_BYTE_E3799 && a2 <= x_WORD_180B50)
	{
		for (i = 0; i < x_DWORD_180B4C_end_sound_buffer3_endindex; i++)
		{
			if (unk_180750_sound_buffer3[i]->flags_14 == a1 && unk_180750_sound_buffer3[i]->vol_scale_18[0][0] == a2 && sub_94010_AIL_sample_status(unk_180750_sound_buffer3[i]) != 2)
			{
				if (a3 > 0x7Fu)
					a3 = 127;
				if (a3 != unk_180750_sound_buffer3[i]->status_1)
				{
					unk_180750_sound_buffer3[i]->vol_scale_18[0][2] = 0;
					unk_180750_sound_buffer3[i]->loop_count_12 = a3;
					unk_180750_sound_buffer3[i]->vol_scale_18[0][3] = a5;
					if (a3 > unk_180750_sound_buffer3[i]->status_1)
						unk_180750_sound_buffer3[i]->vol_scale_18[0][2] = 1;
					else
						unk_180750_sound_buffer3[i]->vol_scale_18[0][2] = 2;
					if (!x_BYTE_E388D)
					{
						x_BYTE_E388D = 1;
						if (a4 <= 4u)
						{
							x_DWORD_180CA0[0] = sub_92600_AIL_register_timer(sub_8F4B0);
							sub_92930_AIL_set_timer_frequency(x_DWORD_180CA0[0], 30 * a4);
							sub_92BA0_AIL_start_timer(x_DWORD_180CA0[0]);
						}
					}
				}
				return;
			}
		}
	}
}
// 8F4B0: using guessed type int sub_8F4B0();
// E3798: using guessed type char x_BYTE_E3798_sound_active2;
// E3799: using guessed type char x_BYTE_E3799;
// E388D: using guessed type char x_BYTE_E388D;
// 180B4C: using guessed type int x_DWORD_180B4C_end_sound_buffer3;
// 180B50: using guessed type __int16 x_WORD_180B50;
// 180CA0: using guessed type int x_DWORD_180CA0[];

//----- (0008F850) --------------------------------------------------------
void sub_8F850_sound_proc22()//270850
{
	if (x_BYTE_E388D)
	{
		sub_92DC0_AIL_release_timer_handle(x_DWORD_180CA0[0]);
		x_BYTE_E388D = 0;
		for (Bit32u i = 0;i < x_DWORD_180B4C_end_sound_buffer3_endindex; i++)
		{
			unk_180750_sound_buffer3[i]->vol_scale_18[0][2] = 0;
			unk_180750_sound_buffer3[i]->vol_scale_18[0][3] = 0;
		}
	}
}
// E388D: using guessed type char x_BYTE_E388D;
// 180B4C: using guessed type int x_DWORD_180B4C_end_sound_buffer3;
// 180CA0: using guessed type int x_DWORD_180CA0[];

//----- (0008F8B0) --------------------------------------------------------
//void sub_8F8B0_draw_bitmap320(__int16 a1, __int16 a2, Pathstruct a3)//2708B0
void sub_8F8B0_draw_bitmap320(Bit16s posx, Bit16s posy, posistruct temppstr)//2708B0
{
	//int v4; // [esp+4h] [ebp-4h]

	//fix it
	//v4 = 0;
	//fix it

	sub_8F935_bitmap_draw_final(temppstr.sizex, temppstr.sizey, posy, posx, temppstr.pointer, 0, 0);//270935 // a2 je 86
	//return v4;
}
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;

//----- (0008F8E8) --------------------------------------------------------
//void sub_8F8E8_draw_bitmap640(__int16 a1, __int16 a2, Bit8u* a3)//2708e8
void sub_8F8E8_draw_bitmap640(Bit16s posx, Bit16s posy, posistruct temppstr)//2708e8
{
	//int v4; // [esp+4h] [ebp-4h]

	//fix it
	//v4 = 0;
	//fix it

	  //esi=48c995 //buffer
	  //ebx=182
	  //ecx=121
	  //edi=3aa0a4
	  //dx=09 0b
	  //esi48913e
	  //0
	  //0

	  //123 cd 48c80f 
	  //2708e8 354f68
	  /*
	  esi=[ebp+10]//48c80f
	  ebx=[ebp+8]//123 - nic
	  ecx=[ebp+c]//cd - a2?
	  edi=[351628]//3aa0a4
	  dl=[esi+4]//26
	  dh=[esi+5]//33
	  esi=[esi]//47ae48
	  */
	  //x_DWORD_180628b
	  //xasearchd.var28_begin_buffer
	  //sub_8F935_bitmap_draw_final(doublebyte_conv(xasearchd.var28_begin_buffer, a2, a1, a3, 0, 0);//270935
	sub_8F935_bitmap_draw_final(temppstr.sizex, temppstr.sizey, posy, posx, temppstr.pointer, 0, 0);//270935
  //return v4;
}
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;

//----- (0008F920) --------------------------------------------------------
void sub_8F920(Bit8u a1byte1, Bit8u a1byte2, Bit16s posx, Bit16s posy, Bit8u* a4, unsigned __int8 a5, char a6)
{
	sub_8F935_bitmap_draw_final(a1byte1, a1byte2, posx, posy, a4, a5, a6);//270935
}
/*
bool Sprite::loadSprite(uint8 * tabData, uint8 * spriteData, uint32 offset,
	bool rle)
{
	assert(tabData);
	assert(spriteData);

	uint8 *tabEntry = tabData + offset * TABENTRY_SIZE;

	uint32 spriteOffset = READ_LE_UINT32(tabEntry);

	tabEntry += 4;
	width_ = *tabEntry;
	tabEntry += 1;
	height_ = *tabEntry;

	if (width_ == 0 || height_ == 0)
		return true;

	stride_ = ceil8(width_);
	uint8 *spriteBlocks = spriteData + spriteOffset;

	sprite_data_ = new uint8[stride_ * height_];
	memset(sprite_data_, 255, stride_ * height_);

	uint8 *currentPixel;

	if (rle) {
		for (int i = 0; i < height_; ++i) {
			int spriteWidth = width_;
			currentPixel = sprite_data_ + i * stride_;

			uint8 b = *spriteBlocks++;
			int runLength = b < 128 ? b : -(256 - b);
			while (runLength != 0) {
				spriteWidth -= runLength;

				if (runLength > 0) {
					if (currentPixel < sprite_data_)
						currentPixel = sprite_data_;
					if (currentPixel + runLength >
						sprite_data_ + height_ * stride_)
						runLength =
						sprite_data_ + height_ * stride_ -
						currentPixel;
					// pixel run
					for (int j = 0; j < runLength; ++j)
						*currentPixel++ = *spriteBlocks++;

				}
				else if (runLength < 0) {
					// transparent run
					runLength *= -1;
					if (currentPixel < sprite_data_)
						currentPixel = sprite_data_;
					if (currentPixel + runLength >
						sprite_data_ + height_ * stride_)
						runLength =
						sprite_data_ + height_ * stride_ -
						currentPixel;
					memset(currentPixel, 255, runLength);
					currentPixel += runLength;

				}
				else if (runLength == 0) {
					// end of the row
					spriteWidth = 0;
				}

				b = *spriteBlocks++;
				runLength = b < 128 ? b : -(256 - b);
			}
		}
	}
	else {
		for (int j = 0; j < height_; ++j) {
			currentPixel = sprite_data_ + j * stride_;

			for (int i = 0; i < width_; i += PIXELS_PER_BLOCK) {
				unpackBlocks1(spriteBlocks, currentPixel);

				spriteBlocks += BLOCK_LENGTH;
				currentPixel += PIXELS_PER_BLOCK;
			}
		}
	}

	return true;
}
*/
//----- (0008F935) --------------------------------------------------------
void sub_8F935_bitmap_draw_final(Bit8u a1byte1, Bit8u a1byte2, Bit16u tiley, int tilex, Bit8u* texture, Bit8u setbyte, char a6)//270935
{
	Bit8u* pixel_buffer_index; // edi
	x_BYTE *v7; // edi
	int v8; // ecx
	signed int v9; // eax
	x_BYTE *v10; // ebx
	char v11; // al
	char v12; // al
	char v13; // al
	x_BYTE *v14; // edi
	int v15; // ecx
	signed int v16; // eax
	x_BYTE *v17; // ebx
	char v18; // al
	char v19; // al
	char v20; // al
	Bit8u* v21_buffer_temp_index1; // edi
	//unsigned int v22; // ecx
	//signed int v23; // eax
	//Bit8u* v24_buffer_temp_index2; // ebx
	//Bit8u* v25_buffer_temp_index3; // edi
	//char v26; // al
	//Bit8u* v27; // esi
	char *v28; // edi
	unsigned int v29; // ecx
	signed int v30; // eax
	char *v31; // ebx
	char *v32; // edi
	char v33; // al
	char *v34; // esi
	int v35; // ebp
	x_BYTE *v36; // edi
	int v37; // ecx
	x_BYTE *v38; // ebx
	unsigned __int8 v39; // al
	int v40; // eax
	x_BYTE *v41; // edi
	int v42; // ecx
	unsigned __int8 i; // dl
	char v44; // al
	char v45; // al
	unsigned __int8 v46; // of
	char v47; // dl
	unsigned __int8 v48; // al
	char *v49; // edi
	char v50; // al
	char v51; // dl
	char v52; // al
	char v53; // dl
	unsigned int v54; // ebx
	const void *v55; // esi
	//char *v56; // edi
	//unsigned int v57; // ecx
	//signed int v58; // eax
	//char *v59; // ebx
	//char *v60; // edi
	char *v61; // edi
	unsigned int v62; // ecx
	signed int v63; // eax
	char *v64; // ebx
	char *v65; // edi
	char v66; // al
	char *v67; // esi
	//Bit8u* v68; // edi
	//int v69; // ebx
	Bit8u v69l;
	Bit8u v69h;
	Bit8s* v70; // edi
	Bit8s* v71; // edx
	Bit8s v72l; // ecx
	char v73; // al
	char v74; // al
	bool v75; // zf
	bool v76; // sf
	char v77; // al
	char v78; // al
	int v79; // ebx
	x_BYTE *v80; // edi
	int v81; // ecx
	signed int v82; // eax
	x_BYTE *v83; // ebx
	char v84; // al
	int v85; // ebx
	x_BYTE *v86; // edi
	int v87; // ecx
	signed int v88; // eax
	x_BYTE *v89; // ebx
	char v90; // al
	x_BYTE *v91; // edi
	int v92; // ecx
	int v93; // ebx
	signed int v94; // eax
	x_BYTE *v95; // ebx
	char v96; // al
	unsigned int v97; // ebx
	x_BYTE *v98; // edi
	x_BYTE *v99; // edx
	int v100; // ecx
	char v101; // al
	char v102; // al
	char v103; // al
	char v104; // al
	x_BYTE *v105; // edi
	int v106; // ecx
	int v107; // ebx
	x_BYTE *v108; // ebx
	signed int v109; // eax
	char v110; // al
	x_BYTE *v111; // edi
	int v112; // ecx
	int v113; // ebx
	x_BYTE *v114; // ebx
	signed int v115; // eax
	char v116; // al
	unsigned int v117; // ebx
	x_BYTE *v118; // edi
	x_BYTE *v119; // edx
	int v120; // ecx
	char v121; // al
	char v122; // al
	char v123; // al
	char v124; // al
	int v125; // eax
	int v126; // edi
	int v127; // eax
	int v128; // eax
	int v129; // eax
	int v130; // eax
	char *v131; // [esp-4h] [ebp-Ch]
	Bit8u v132; // [esp+2h] [ebp-6h]
	unsigned __int8 v133; // [esp+2h] [ebp-6h]
	unsigned __int8 v134; // [esp+2h] [ebp-6h]
	unsigned __int8 v135; // [esp+2h] [ebp-6h]
	unsigned __int8 v136; // [esp+2h] [ebp-6h]
	unsigned __int8 v137; // [esp+2h] [ebp-6h]
	unsigned __int8 v138; // [esp+2h] [ebp-6h]
	unsigned __int8 v139; // [esp+2h] [ebp-6h]
	char v140; // [esp+3h] [ebp-5h]
	char v141; // [esp+3h] [ebp-5h]
	x_BYTE *v142; // [esp+4h] [ebp-4h]
	x_BYTE *v143; // [esp+4h] [ebp-4h]
	//debug
	/*loadfromsnapshot((char*)"0160-00270935-2",texture,0x47be3a,0x400);

	//a1 = 0x1513;
	x_DWORD_180650_positiony = 0;//351650
	x_DWORD_18062C_resolution_x = 0x40;//35162c
	x_DWORD_18063C_sprite_sizex = 0;//35163c
	//x_DWORD_180628b_screen_buffer=82c714
	x_WORD_180660_VGA_type_resolution = 0x30008;
	tiley = 0;
	a1.byte1 = 0x13;

	a1.byte2 = 0x15;
	//a1.byte2 = 0;

	tilex = 0;
	x_DWORD_180644_map_resolution2_y = 0x40;

	//a4 = 03;*/
	//debug

	//x_DWORD_180650_positiony - 0 35162c
	//x_DWORD_18062C_resolution_x - 40 35162c
	//47ae48+1
	//0x47be3a - 03191919
	if (!(a1byte2))//453558
		return;
	pixel_buffer_index = x_DWORD_180628b_screen_buffer + x_DWORD_18063C_sprite_sizex + x_DWORD_18062C_resolution_x * x_DWORD_180650_positiony;
	if (x_WORD_180660_VGA_type_resolution & 1)//pokud je rozliseno 320x200 zmensi hodnoty na polovic
	{
		a1byte1 /= 2;
		a1byte2 /= 2;
		tilex /= 2;
		tiley /= 2;
	}
	if (tiley < 0)
	{
		if (x_WORD_E36D4 & 2)
		{
			v128 = tiley + a1byte2;
			v46 = __OFADD__(1, v128);
			v129 = v128 + 1;
			if (((v129 < 0) ^ v46) | (v129 == 0))
				return;
			tiley = -1;
			a1byte2 = v129;
		}
		else
		{
			v130 = tiley + a1byte2;
			if (((tiley + a1byte2 < 0) ^ __OFADD__(tiley, a1byte2)) | (tiley + a1byte2 == 0))
				return;
			a1byte2 += tiley;
			v130 = 0;
			do
			{
				while (1)
				{
					v130 = *texture++;
					if (!v130)
						break;
					if ((v130 & 0x80u) == 0)
						texture += v130;
				}
				tiley++;
			} while (tiley);
		}
	}
	else if (tiley + a1byte2 >= x_DWORD_180644_map_resolution2_y)
	{
		if (x_WORD_E36D4 & 2)
		{
			if (tiley + 1 >= x_DWORD_180644_map_resolution2_y)
				return;
			v125 = a1byte2 + tiley + 1 - x_DWORD_180644_map_resolution2_y;
			a1byte2 = x_DWORD_180644_map_resolution2_y - (tiley + 1);
			v126 = v125;
			v127 = 0;
			do
			{
				while (1)
				{
					v127 = *texture++;
					if (!v127)
						break;
					if ((v127 & 0x80u) == 0)
						texture += v127;
				}
				--v126;
			} while (v126);
			pixel_buffer_index = x_DWORD_180628b_screen_buffer;
		}
		else
		{
			if (x_DWORD_180644_map_resolution2_y <= tiley)
				return;
			a1byte2 = x_DWORD_180644_map_resolution2_y - tiley;
		}
	}
	if (tilex >= 0)
	{
		if (tilex + a1byte1 >= x_DWORD_180648_map_resolution2_x)
		{
			if (x_WORD_E36D4)
			{
				if (x_WORD_E36D4 & 1)
				{
					if (x_WORD_E36D4 & 2)
					{
						if (x_DWORD_180634_screen_width - tilex >= 0)
						{
							v79 = a1byte1 + tilex;
							v80 = (x_BYTE *)(x_DWORD_18062C_resolution_x * (a1byte2 + tiley) + v79 + pixel_buffer_index);
							v81 = 0;
							v79 = x_DWORD_180634_screen_width - v79 - 2;
							a1byte1 = v79;
							v133 = v79;
							v82 = -1;
							v83 = v80;
							do
							{
								while (1)
								{
									while (1)
									{
										v82 = *texture++;
										if ((v82 & 0x80u) == 0)
											break;
										v80 += v82;
										a1byte1 = a1byte1 - v82;
									}
									if (!v82)
										break;
									v81 = v82;
									do
									{
										v84 = *texture++;
										a1byte1 = a1byte1 + 1;
										if ((a1byte1 & 0x80u) == 0)
											*v80 = v84;
										--v80;
										--v81;
									} while (v81);
								}
								v83 -= x_DWORD_18062C_resolution_x;
								v80 = v83;
								a1byte1 = __PAIR__(a1byte2, v133) - 256;
							} while (a1byte2);
						}
					}
					else if (x_DWORD_180634_screen_width - tilex >= 0)
					{
						v85 = a1byte1 + tilex;
						v86 = (x_BYTE *)(x_DWORD_18062C_resolution_x * tiley + v85 + pixel_buffer_index);
						v87 = 0;
						v85 = x_DWORD_180634_screen_width - v85 - 2;
						a1byte1 = v85;
						v134 = v85;
						v88 = -1;
						v89 = v86;
						do
						{
							while (1)
							{
								while (1)
								{
									v88 = *texture++;
									if ((v88 & 0x80u) == 0)
										break;
									v86 += v88;
									a1byte1 = a1byte1 - v88;
								}
								if (!v88)
									break;
								v87 = v88;
								do
								{
									v90 = *texture++;
									a1byte1 = a1byte1 + 1;
									if ((a1byte1 & 0x80u) == 0)
										*v86 = v90;
									--v86;
									--v87;
								} while (v87);
							}
							v89 += x_DWORD_18062C_resolution_x;
							v86 = v89;
							a1byte1 = __PAIR__(a1byte2, v134) - 256;
						} while (a1byte2);
					}
				}
				else if (x_WORD_E36D4 & 2)
				{
					v91 = (x_BYTE *)(x_DWORD_18062C_resolution_x * (a1byte2 + tiley) + tilex + pixel_buffer_index);
					v92 = 0;
					v93 = x_DWORD_180634_screen_width - tilex;
					if (v93 >= 0)
					{
						a1byte1 = v93;
						v135 = v93;
						v94 = -1;
						v95 = v91;
						do
						{
							while (1)
							{
								while (1)
								{
									v94 = *texture++;
									if ((v94 & 0x80u) == 0)
										break;
									v91 -= v94;
									a1byte1 = v94 + a1byte1;
								}
								if (!v94)
									break;
								v92 = v94;
								do
								{
									v96 = *texture++;
									a1byte1 = a1byte1 - 1;
									if ((a1byte1 & 0x80u) == 0)
										*v91++ = v96;
									--v92;
								} while (v92);
							}
							v95 -= x_DWORD_18062C_resolution_x;
							v91 = v95;
							a1byte1 = __PAIR__(a1byte2, v135) - 256;
						} while (a1byte1);
					}
				}
			}
			else
			{
				/*for (int ii = 0;ii < a1byte1;ii++)//debug
					for (int jj = 0;jj < a1byte2;jj++)
						pixel_buffer_index[x_DWORD_18062C_resolution_x * (tiley + ii) + (tilex + jj)] = 128;
				*/
				//edi - 3c28b7

				  //v68 = tilex + pixel_buffer_index;
				  //v69 = x_DWORD_180634_screen_width - tilex;
				if (x_DWORD_180634_screen_width - tilex >= 0)
				{
					v70 = (Bit8s*)(x_DWORD_18062C_resolution_x * tiley + tilex + pixel_buffer_index);
					v69l = x_DWORD_180634_screen_width - tilex;
					v69h = a1byte2;//ebx
					v132 = v69l;//ebp-6
					v71 = v70;//edx edi
					v72l = 0;//ecx
					do
					{
						while (1)
						{
							while (1)
							{
								v73 = *texture++;
								if (v73 >= 0)
									break;
								v46 = __OFADD__(v73, v69l);//fix
								v75 = v73 + v69l == 0;//fix
								v76 = (char)(v73 + v69l) < 0;//fix
								v69l = v73 + v69l;//fix
								if (!((v76 ^ v46) | v75))
								{
									v70 -= v73;
									v77 = *texture++;
									v72l = v77;
									do
									{
										v78 = *texture++;
										v69l--;
										if ((v69l & 0x80u) == 0)//fix
											*v70++ = v78;
										v72l--;
									} while (v72l);
								}
							}
							if (!v73)
								break;
							v72l = v73;
							do
							{
								v74 = *texture++;
								v69l--;
								if ((v69l & 0x80u) == 0)//fix
									*v70++ = v74;
								v72l--;
							} while (v72l);
						}
						v71 += x_DWORD_18062C_resolution_x;
						v70 = v71;

						v69l = /*(v69l&0xff00)+*/v132;//fix
						v69h--;
					} while (v69h);//fix

				}
			}
		}
		else if (x_WORD_E36D4 & 1)
		{
			if (x_WORD_E36D4 & 2)
			{
				v7 = (x_BYTE *)(x_DWORD_18062C_resolution_x * (a1byte2 + tiley) + a1byte1 + tilex + pixel_buffer_index);
				v8 = 0;
				v9 = -1;
				v10 = v7;
				do
				{
					while (1)
					{
						while (1)
						{
							v9 = *texture++;
							if ((v9 & 0x80u) == 0)
								break;
							v7 += v9;
							v12 = *texture++;
							v8 = v12;
							do
							{
								v13 = *texture++;
								*v7-- = v13;
								--v8;
							} while (v8);
						}
						if (!v9)
							break;
						v8 = v9;
						do
						{
							v11 = *texture++;
							*v7-- = v11;
							--v8;
						} while (v8);
					}
					v10 -= x_DWORD_18062C_resolution_x;
					v7 = v10;
					--a1byte2;
				} while (a1byte2);
			}
			else
			{
				v14 = (x_BYTE *)(x_DWORD_18062C_resolution_x * tiley + a1byte1 + tilex + pixel_buffer_index);
				v15 = 0;
				v16 = -1;
				v17 = v14;
				do
				{
					while (1)
					{
						while (1)
						{
							v16 = *texture++;
							if ((v16 & 0x80u) == 0)
								break;
							v14 += v16;
							v19 = *texture++;
							v15 = v19;
							do
							{
								v20 = *texture++;
								*v14-- = v20;
								--v15;
							} while (v15);
						}
						if (!v16)
							break;
						v15 = v16;
						do
						{
							v18 = *texture++;
							*v14-- = v18;
							--v15;
						} while (v15);
					}
					v17 += x_DWORD_18062C_resolution_x;
					v14 = v17;
					--a1byte2;
				} while (a1byte2);
			}
		}
		else if (x_WORD_E36D4)
		{
			if (x_WORD_E36D4 & 2)
			{
				v28 = (char *)(x_DWORD_18062C_resolution_x * (a1byte2 + tiley) + tilex + pixel_buffer_index);
				v29 = 0;
				v30 = -1;
				v31 = v28;
				do
				{
					while (1)
					{
						while (1)
						{
							v30 = *texture++;
							if ((v30 & 0x80u) == 0)
								break;
							v32 = &v28[-v30];
							v33 = *texture;
							v34 = (char*)(texture + 1);
							v29 = v33;
							qmemcpy(v32, v34, v29);
							texture = (Bit8u*)&v34[v29];
							v28 = &v32[v29];
							v29 = 0;
						}
						if (!v30)
							break;
						v29 = v30;
						qmemcpy(v28, texture, v29);
						texture += v29;
						v28 += v29;
						v29 = 0;
					}
					v31 -= x_DWORD_18062C_resolution_x;
					v28 = v31;
					--a1byte2;
				} while (a1byte2);
			}
			else if (x_WORD_E36D4 & 4)
			{
				v35 = x_DWORD_E3890;
				v36 = (x_BYTE *)(x_DWORD_18062C_resolution_x * tiley + tilex + pixel_buffer_index);
				v37 = 0;
				v38 = v36;
				do
				{
					while (1)
					{
						while (1)
						{
							v39 = *texture++;
							if ((v39 & 0x80u) == 0)
								break;
							v36 -= (char)v39;
						}
						if (!v39)
							break;
						v37 = v39;
						v40 = v39;
						do
						{
							v40 = *texture++;
							v40 = *v36;
							*v36++ = *(x_BYTE *)(v40 + v35);
							--v37;
						} while (v37);
					}
					v38 += x_DWORD_18062C_resolution_x;
					v36 = v38;
					--a1byte2;
				} while (a1byte2);
			}
			else if (x_WORD_E36D4 & 8)
			{
				v41 = (x_BYTE *)(x_DWORD_18062C_resolution_x * tiley + tilex + pixel_buffer_index);
				v42 = 0;
				v142 = v41;
				v140 = a1byte2;
				for (i = setbyte; ; i = setbyte)
				{
					while (1)
					{
						while (1)
						{
							v44 = *texture++;
							if (v44 >= 0)
								break;
							v42 = (unsigned __int8)-v44;
							do
							{
								v46 = __OFSUB__(i--, 1);
								if (((i & 0x80u) != 0) ^ v46)
								{
									i = setbyte;
									++v41;
								}
								--v42;
							} while (v42);
						}
						if (!v44)
							break;
						LOBYTE(v42) = v44;
						do
						{
							v45 = *texture++;
							v46 = __OFSUB__(i--, 1);
							if (((i & 0x80u) != 0) ^ v46)
							{
								i = setbyte;
								*v41++ = v45;
							}
							--v42;
						} while (v42);
					}
					if (!--v140)
						break;
					v47 = a6;
					while (--v47 >= 0)
					{
						while (1)
						{
							do
								v48 = *texture++;
							while ((v48 & 0x80u) != 0);
							if (!v48)
								break;
							texture += v48;
						}
					}
					v142 += x_DWORD_18062C_resolution_x;
					v41 = v142;
				}
			}
			else if (x_WORD_E36D4 & 0x20)
			{
				v49 = (char *)(x_DWORD_18062C_resolution_x * tiley + tilex + pixel_buffer_index);
				v143 = v49;
				v141 = a1byte2;
				do
				{
					while (1)
					{
						while (1)
						{
							v50 = *texture++;
							if (v50 >= 0)
								break;
							v49 += (setbyte * -v50);
						}
						if (!v50)
							break;
						v51 = v50;
						do
						{
							v52 = *texture++;
							memset(v49, v52, setbyte);
							v49 += setbyte;
							v46 = __OFSUB__(v51--, 1);
						} while (!(((v51 < 0) ^ v46) | (v51 == 0)));
					}
					v53 = a6 - 1;
					if (a6 > 1)
					{
						v131 = (char*)texture;
						v54 = v49 - v143;
						do
						{
							v55 = v143;
							v143 += x_DWORD_18062C_resolution_x;
							qmemcpy(v143, (void*)v55, v54);
							v46 = __OFSUB__(v53--, 1);
						} while (!(((v53 < 0) ^ v46) | (v53 == 0)));
						texture = (Bit8u*)v131;
					}
					v143 += x_DWORD_18062C_resolution_x;
					v49 = v143;
					--v141;
				} while (v141);
			}
			else if (x_WORD_E36D4 & 0x40)
			{


				//v56 = (char *)(dword_18062C * a2 + a3 + v6);
				v21_buffer_temp_index1 = (x_DWORD_18062C_resolution_x * tiley + tilex + pixel_buffer_index);
				Bit8s v57_loc = 0;
				Bit8s v58_loc = -1;
				Bit8s* v59_loc = (Bit8s*)v21_buffer_temp_index1;
				Bit8s* v60loc = 0;
				do
				{
					while (1)
					{
						while (1)
						{
							v58_loc = texture[0];
							texture++;
							if ((v58_loc & 0x80u) == 0)
								break;
							v60loc = (Bit8s*)&v21_buffer_temp_index1[-v58_loc];
							v57_loc = texture[0];
							texture += v57_loc + 1;
							memset(v60loc, setbyte, v57_loc);
							v21_buffer_temp_index1 = (Bit8u*)&v60loc[v57_loc];
							v57_loc = 0;
						}
						if (!v58_loc)
							break;
						v57_loc = v58_loc;
						texture += v57_loc;
						memset(v21_buffer_temp_index1, setbyte, v57_loc);
						v21_buffer_temp_index1 += v57_loc;
						v57_loc = 0;
					}
					v59_loc += x_DWORD_18062C_resolution_x;
					v21_buffer_temp_index1 = (Bit8u*)v59_loc;
					--a1byte2;
				} while (a1byte2);
				/*
					v21_buffer_temp_index1 = (x_DWORD_18062C_resolution_x * tiley + tilex + pixel_buffer_index);
					Bit32u inindex = 0;
					Bit32u outindex = 0;
					Bit8s shift = 0;
					Bit8s end = 0;
					Bit8s count = texture[inindex++];
					memset(&v21_buffer_temp_index1[outindex], setbyte, count);
					//qmemcpy(&v21_buffer_temp_index1[outindex], &texture[inindex], count);
					for (Bit32u y = 1;count != 0x7f;y++)
					{
						memset(&v21_buffer_temp_index1[outindex + shift], setbyte, count);
						//qmemcpy(&v21_buffer_temp_index1[outindex + shift], &texture[inindex], count);
						inindex += count;
						end = texture[inindex++];
						if (end == 0)
						{
							count = texture[inindex++];
							if (count < 0) {
								shift = -count;
								count = texture[inindex++];
							}
							outindex += x_DWORD_18062C_resolution_x;
						}
						else {
							shift += count;
							count = end;
							if (count < 0) {
								shift -= count;
								count = texture[inindex++];
							}
						}
					}
					*/
					/*v56 = (char *)(x_DWORD_18062C_resolution_x * tiley + tilex + pixel_buffer_index);
					v57 = 0;
					v58 = -1;
					v59 = v56;
					do
					{
					  while ( 1 )
					  {
						while ( 1 )
						{
						  v58 = *texture++;
						  if ( (v58 & 0x80u) == 0 )
							break;
						  v60 = &v56[-v58];
						  v57 = *texture;
						  texture += v57 + 1;
						  memset(v60, a5, v57);
						  v56 = &v60[v57];
						  v57 = 0;
						}
						if ( !v58 )
						  break;
						v57 = v58;
						texture += v57;
						memset(v56, a5, v57);
						v56 += v57;
						v57 = 0;
					  }
					  v59 += x_DWORD_18062C_resolution_x;
					  v56 = v59;
					  --a1.byte2;
					}
					while ( a1.byte2 );*/
			}
			else
			{
				v61 = (char *)(x_DWORD_18062C_resolution_x * tiley + tilex + pixel_buffer_index);
				v62 = 0;
				v63 = -1;
				v64 = v61;
				do
				{
					while (1)
					{
						while (1)
						{
							v63 = *texture++;
							if ((v63 & 0x80u) == 0)
								break;
							v65 = &v61[-v63];
							v66 = *texture;
							v67 = (char*)(texture + 1);
							v62 = v66;
							qmemcpy(v65, v67, v62);
							texture = (Bit8u*)&v67[v62];
							v61 = &v65[v62];
							v62 = 0;
						}
						if (!v63)
							break;
						v62 = v63;
						qmemcpy(v61, texture, v62);
						texture += v62;
						v61 += v62;
						v62 = 0;
					}
					v64 += x_DWORD_18062C_resolution_x;
					v61 = v64;
					--a1byte2;
				} while (a1byte2);
			}
		}
		else
		{
			v21_buffer_temp_index1 = (x_DWORD_18062C_resolution_x * tiley + tilex + pixel_buffer_index);

			//v21 = (char *)(dword_18062C * a2 + a3 + v6);
			Bit8s v22_loc = 0;
			Bit8s v23_loc = -1;
			Bit8s* v25_loc = 0;
			Bit8s v26_loc = 0;
			Bit8s* v27_loc = 0;
			Bit8s* v24_loc = (Bit8s*)v21_buffer_temp_index1;
			do
			{
				while (1)
				{
					while (1)
					{
						v23_loc = texture[0];
						texture++;
						if ((v23_loc & 0x80u) == 0)
							break;
						v25_loc = (Bit8s*)&v21_buffer_temp_index1[-v23_loc];
						v26_loc = texture[0];
						v27_loc = (Bit8s*)(texture + 1);
						v22_loc = v26_loc;
						qmemcpy(v25_loc, v27_loc, v22_loc);
						texture = (Bit8u*)&v27_loc[v22_loc];
						v21_buffer_temp_index1 = (Bit8u*)&v25_loc[v22_loc];
						v22_loc = 0;
					}
					if (!v23_loc)
						break;
					v22_loc = v23_loc;
					qmemcpy(v21_buffer_temp_index1, texture, v22_loc);
					texture += v22_loc;
					v21_buffer_temp_index1 += v22_loc;
					v22_loc = 0;
				}
				v24_loc += x_DWORD_18062C_resolution_x;
				v21_buffer_temp_index1 = (Bit8u*)v24_loc;
				a1byte2--;
			} while (a1byte2);
			/*

			  v21_buffer_temp_index1 = (x_DWORD_18062C_resolution_x * tiley + tilex + pixel_buffer_index);

			  Bit32u inindex = 0;
			  Bit32u outindex = 0;
			  Bit8s shift = 0;
			  Bit8s end = 0;
			  Bit8s count = 0;
			  end = texture[inindex++];
			  if (end == 0)
			  {
				  count = texture[inindex++];
				  outindex ++;
				  while (count == 0) {
					  outindex += x_DWORD_18062C_resolution_x+1;
					  count = texture[inindex++];
				  }
				  if (count < 0) {
					  shift = -count;
					  count = texture[inindex++];
				  }
				  outindex += x_DWORD_18062C_resolution_x;
			  }
			  else {
				  shift += count;
				  count = end;
				  if (count < 0) {
					  shift -= count;
					  count = texture[inindex++];
				  }
			  }
			  qmemcpy(&v21_buffer_temp_index1[outindex], &texture[inindex], count);
			  for(Bit32u y=1;count!=0x7f;y++)
				  {
					qmemcpy(&v21_buffer_temp_index1[outindex + shift], &texture[inindex], count);
					inindex += count;
					end = texture[inindex++];
					if (end == 0)
					{
						count = texture[inindex++];
						while (count == 0) {
							outindex += x_DWORD_18062C_resolution_x+1;
							count = texture[inindex++];
						}
						if (count < 0) {
							shift = -count;
							count = texture[inindex++];
						}
						outindex += x_DWORD_18062C_resolution_x;
					}
					else {
						shift += count;
						count = end;
						if (count < 0) {
							shift -= count;
							count = texture[inindex++];
						}
					}
				  }
				  */
				  //v24_buffer_temp_index2 = v21_buffer_temp_index1;
				  /*
				  do
				  {
					while ( 1 )
					{
					  Bit32u index_tab=0;
					  Bit32u index_tab_v23 = 0;
					  Bit32u index_tab_v22 = 0;
					  //v23 = texture[index_tab++];
					  for (Bit32u index_tab = 0;texture[index_tab] != 0; index_tab++)
					  {
						  // 3 19 19
						  v25_buffer_temp_index3 = &v21_buffer_temp_index1[-v23];
						  //v27 = texture + 1;
						  texture[index_tab_v22] = texture[index_tab];
						  qmemcpy(v25_buffer_temp_index3, (void*)texture[index_tab+1], (int)texture[index_tab_v22]);
						  //texture = (Bit8u*)&(texture + 1 + 3);
						  v21_buffer_temp_index1 = &v25_buffer_temp_index3[texture[index_tab_v22]];
						  texture[index_tab_v22] = 0;
					  }
					  if (!v23)
						  break;
					  texture[index_tab_v22] = texture[index_tab_v23];
					  qmemcpy(v21_buffer_temp_index1, texture, texture[index_tab_v22]);
					  texture += texture[index_tab_v22];
					  v21_buffer_temp_index1 += texture[index_tab_v22];
					  texture[index_tab_v22] = 0;


					  v23 = *texture++;
					  for ( ;v23!=0;v23 = *texture++)
					  {
						// 3 19 19
						v25_buffer_temp_index3 = &v21_buffer_temp_index1[-v23];
						//v27 = texture + 1;
						v22 = *texture;
						qmemcpy(v25_buffer_temp_index3, texture + 1, v22);
						texture = (Bit8u*)&(*texture + 1+*v22);
						v21_buffer_temp_index1 = &v25_buffer_temp_index3[v22];
						v22 = 0;
					  }
					  if ( !v23 )
						break;
					  v22 = v23;
					  qmemcpy(v21_buffer_temp_index1, texture, v22);
					  texture += v22;
					  v21_buffer_temp_index1 += v22;
					  v22 = 0;
					}
					v24_buffer_temp_index2 += x_DWORD_18062C_resolution_x;
					v21_buffer_temp_index1 = v24_buffer_temp_index2;
					--a1.byte2;
				  }
				  while ( a1.byte2 );*/
		}
		return;
	}
	/*if ( !x_WORD_E36D4 )
	{
	  v97 = -tilex;
	  if (a1byte1 <= v97 )
		return;
	  v98 = (x_BYTE *)(x_DWORD_18062C_resolution_x * tiley + pixel_buffer_index);
	  v97 = a1byte2;
	  v99 = v98;
	  v136 = v97;
	  v100 = 0;
	  while ( 1 )
	  {
		while ( 1 )
		{
		  while ( 1 )
		  {
			v101 = *texture++;
			if ( v101 < 0 )
			  break;
			if ( v101 )
			{
			  v100 = v101;
			  do
			  {
				v102 = *texture++;
				v97 = v97 - 1;
				if ( (v97 & 0x80u) != 0 )
				  *v98++ = v102;
				--v100;
			  }
			  while ( v100 );
			}
			else
			{
			  v99 += x_DWORD_18062C_resolution_x;
			  v98 = v99;
			  v97 = __PAIR__(v97, v136) - 256;
			  if ( !v97 )
				return;
			}
		  }
		  if ( (char)v97 > 0 )
			break;
  LABEL_179:
		  v98 -= v101;
		  v103 = *texture++;
		  v100 = v103;
		  do
		  {
			v104 = *texture++;
			v97 = v97 - 1;
			if ( (v97 & 0x80u) != 0 )
			  *v98++ = v104;
			--v100;
		  }
		  while ( v100 );
		}
		v97 = v101 + v97;
		if ( (v97 & 0x80u) != 0 )
		{
		  v101 = v97;
		  goto LABEL_179;
		}
	  }
	}*/
	if (!(x_WORD_E36D4 & 1))
	{
		if (!(x_WORD_E36D4 & 2))
			return;
		v117 = -tilex;
		if (a1byte1 <= v117)
			return;
		v118 = (x_BYTE *)(x_DWORD_18062C_resolution_x * (a1byte2 + tiley) + pixel_buffer_index);
		v117 = a1byte2;
		v119 = v118;
		v139 = v117;
		v120 = 0;
		while (1)
		{
			while (1)
			{
				while (1)
				{
					v121 = *texture++;
					if (v121 < 0)
						break;
					if (v121)
					{
						v120 = v121;
						do
						{
							v122 = *texture++;
							v117 = v117 - 1;
							if ((v117 & 0x80u) != 0)
								*v118++ = v122;
							v120--;
						} while (v120);
					}
					else
					{
						v119 -= x_DWORD_18062C_resolution_x;
						v118 = v119;
						v117 = __PAIR__(v117, v139) - 256;
						if (!v117)
							return;
					}
				}
				if ((char)v117 > 0)
					break;
			LABEL_225:
				v118 -= v121;
				v123 = *texture++;
				v120 = v123;
				do
				{
					v124 = *texture++;
					v117 = v117 - 1;
					if ((v117 & 0x80u) != 0)
						*v118++ = v124;
					v120--;
				} while (v120);
			}
			v117 = v121 + v117;
			if ((v117 & 0x80u) != 0)
			{
				v121 = v117;
				goto LABEL_225;
			}
		}
	}
	if (x_WORD_E36D4 & 2)
	{
		v105 = (x_BYTE *)(x_DWORD_18062C_resolution_x * (a1byte2 + tiley) + a1byte1 + tilex + pixel_buffer_index);
		v106 = 0;
		v107 = a1byte1 + tilex + 1;
		if (v107 >= 0)
		{
			a1byte1 = v107;
			v137 = v107;
			v108 = v105;
			v109 = -1;
			do
			{
				while (1)
				{
					while (1)
					{
						v109 = *texture++;
						if ((v109 & 0x80u) == 0)
							break;
						v105 += v109;
						a1byte1 = v109 + a1byte1;
					}
					if (!v109)
						break;
					v106 = v109;
					do
					{
						v110 = *texture++;
						a1byte1 = a1byte1 - 1;
						if ((a1byte1 & 0x80u) == 0)
							*v105 = v110;
						v105--;
						v106--;
					} while (v106);
				}
				v108 -= x_DWORD_18062C_resolution_x;
				v105 = v108;
				a1byte1 = __PAIR__(a1byte2, v137) - 256;
			} while (a1byte2);
		}
	}
	else
	{
		v111 = (x_BYTE *)(x_DWORD_18062C_resolution_x * tiley + a1byte1 + tilex + pixel_buffer_index);
		v112 = 0;
		v113 = a1byte1 + tilex + 1;
		if (v113 >= 0)
		{
			a1byte1 = v113;
			v138 = v113;
			v114 = v111;
			v115 = -1;
			do
			{
				while (1)
				{
					while (1)
					{
						v115 = *texture++;
						if ((v115 & 0x80u) == 0)
							break;
						v111 += v115;
						a1byte1 = v115 + a1byte1;
					}
					if (!v115)
						break;
					v112 = v115;
					do
					{
						v116 = *texture++;
						a1byte1 = a1byte1 - 1;
						if ((a1byte1 & 0x80u) == 0)
							*v111 = v116;
						v111--;
						v112--;
					} while (v112);
				}
				v114 += x_DWORD_18062C_resolution_x;
				v111 = v114;
				a1byte1 = __PAIR__(a1byte1, v138) - 256;
			} while (a1byte2);
		}
	}
}
// E36D4: using guessed type __int16 x_WORD_E36D4;
// E3890: using guessed type int x_DWORD_E3890;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 18062C: using guessed type int x_DWORD_18062C_resolution_x;
// 180634: using guessed type int x_DWORD_180634_screen_width;
// 18063C: using guessed type int x_DWORD_18063C_sprite_sizex;
// 180644: using guessed type int x_DWORD_180644_map_resolution2_y;
// 180648: using guessed type int x_DWORD_180648_map_resolution2_x;
// 180650: using guessed type int x_DWORD_180650_positiony;
// 180660: using guessed type __int16 x_WORD_180660_VGA_type_resolution;

//----- (00090164) --------------------------------------------------------
void sub_90164(Bit16u x1, Bit16u y1, Bit16u x2, Bit16u y2, Bit8u a5)
{
	Bit8u* pixel; // edi
	Bit16u v6; // dx
	Bit8u v7; // ebx
	int v8; // esi
	int v9; // ecx
	Bit16u v10; // [esp+0h] [ebp-4h]
	Bit16u v11; // [esp+14h] [ebp+10h]

	pixel = &x_DWORD_180628b_screen_buffer[320 * (y1 >> 1) + (x1 >> 1)];
	v6 = y2 >> 1;
	v11 = x2 >> 1;
	v10 = (320 - v11);
	if (x_WORD_E36D4 & 4)
	{
		v7 = a5;
		v8 = x_DWORD_E3890;
		do
		{
			v9 = v11;
			do
			{
				v7 = pixel[0];
				*pixel++ = *(Bit8u*)(v8 + v7);
				--v9;
			} while (v9);
			pixel += v10;
			--v6;
		} while (v6);
	}
	else
	{
		do
		{
			memset(pixel, a5, v11);
			pixel += v10 + v11;
			--v6;
		} while (v6);
	}
}
// E36D4: using guessed type __int16 x_WORD_E36D4;
// E3890: using guessed type int x_DWORD_E3890;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;

//----- (000901E4) --------------------------------------------------------
void sub_901E4(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, unsigned __int16 a5)
{
	x_BYTE *v5; // edi
	__int16 v6; // dx
	int v7; // ebx
	int v8; // esi
	int v9; // ecx
	int v10; // [esp+0h] [ebp-4h]

	v5 = (x_BYTE *)(640 * a2 + x_DWORD_180628b_screen_buffer + a1);
	v6 = a4;
	v10 = (unsigned __int16)(640 - a3);
	if (x_WORD_E36D4 & 4)
	{
		v7 = a5;
		v8 = x_DWORD_E3890;
		do
		{
			v9 = a3;
			do
			{
				BYTE1(v7) = *v5;
				*v5++ = *(x_BYTE *)(v7 + v8);
				v9--;
			} while (v9);
			v5 += v10;
			v6--;
		} while (v6);
	}
	else
	{
		do
		{
			memset(v5, a5, a3);
			v5 += v10 + a3;
			v6--;
		} while (v6);
	}
}
// E36D4: using guessed type __int16 x_WORD_E36D4;
// E3890: using guessed type int x_DWORD_E3890;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;

//----- (0009025C) --------------------------------------------------------
int sub_9025C(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int16 a5, __int16 a6)
{
	__int16 v6; // bx
	__int16 v7; // cx
	__int16 v8; // dx
	x_BYTE *v10; // edi
	int v11; // eax
	unsigned int v12; // ecx
	int v13; // ecx
	int v14; // esi
	int v15; // esi
	int v16; // [esp+4h] [ebp-4h]

	//fix it
	v16 = 0;
	//fix it

	v6 = 2 * x_DWORD_180634_screen_width;
	v7 = 2 * x_DWORD_180650_positiony;
	v8 = 2 * x_DWORD_180630_screen_height;
	if (a1 < (signed __int16)(2 * x_DWORD_18063C_sprite_sizex))
		a1 = 2 * x_DWORD_18063C_sprite_sizex;
	if (a3 < (signed __int16)(2 * x_DWORD_18063C_sprite_sizex))
		return v16;
	if (a1 >= v6)
		return v16;
	if (a3 >= v6)
		a3 = 2 * x_DWORD_180634_screen_width;
	if (a2 < v7)
		a2 = 2 * x_DWORD_180650_positiony;
	if (a4 < v7)
		return v16;
	if (a2 >= v8)
		return v16;
	if (a4 >= v8)
		a4 = 2 * x_DWORD_180630_screen_height;
	v10 = (x_BYTE *)(320 * ((unsigned int)(unsigned __int16)a2 >> 1)
		+ (int)x_DWORD_180628b_screen_buffer
		+ ((unsigned int)(unsigned __int16)a1 >> 1));
	v11 = a5;
	v12 = (unsigned __int16)a3;
	if (a3 == a1)
	{
		v13 = (unsigned __int16)a4;
		LOWORD(v13) = (unsigned __int16)(a4 - a2) >> 1;
		if (a6 & 4)
		{
			v14 = x_DWORD_E3890;
			do
			{
				BYTE1(v11) = *v10;
				*v10 = *(x_BYTE *)(v11 + v14);
				v10 += 320;
				--v13;
			} while (v13);
		}
		else
		{
			do
			{
				*v10 = a5;
				v10 += 320;
				--v13;
			} while (v13);
		}
	}
	else
	{
		LOWORD(v12) = (unsigned __int16)(a3 - a1) >> 1;
		if (a6 & 4)
		{
			v15 = x_DWORD_E3890;
			do
			{
				BYTE1(v11) = *v10;
				*v10++ = *(x_BYTE *)(v11 + v15);
				--v12;
			} while (v12);
		}
		else
		{
			memset(v10, a5, v12);
		}
	}
	return v16;
}
// E3890: using guessed type int x_DWORD_E3890;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 180630: using guessed type int x_DWORD_180630_screen_height;
// 180634: using guessed type int x_DWORD_180634_screen_width;
// 18063C: using guessed type int x_DWORD_18063C_sprite_sizex;
// 180650: using guessed type int x_DWORD_180650_positiony;

//----- (00090374) --------------------------------------------------------
int sub_90374(__int16 a1, __int16 a2, __int16 a3, __int16 a4, unsigned __int16 a5, __int16 a6)
{
	x_BYTE *v7; // edi
	int v8; // eax
	unsigned int v9; // ecx
	int v10; // ecx
	int v11; // esi
	int v12; // esi
	int v13; // [esp+4h] [ebp-4h]

	//fix it
	v13 = 0;
	//fix it

	if (a1 < (signed __int16)x_DWORD_18063C_sprite_sizex)
		a1 = x_DWORD_18063C_sprite_sizex;
	if (a3 < (signed __int16)x_DWORD_18063C_sprite_sizex)
		return v13;
	if (a1 >= (signed __int16)x_DWORD_180634_screen_width)
		return v13;
	if (a3 >= (signed __int16)x_DWORD_180634_screen_width)
		a3 = x_DWORD_180634_screen_width;
	if (a2 < (signed __int16)x_DWORD_180650_positiony)
		a2 = x_DWORD_180650_positiony;
	if (a4 < (signed __int16)x_DWORD_180650_positiony)
		return v13;
	if (a2 >= (signed __int16)x_DWORD_180630_screen_height)
		return v13;
	if (a4 >= (signed __int16)x_DWORD_180630_screen_height)
		a4 = x_DWORD_180630_screen_height;
	v7 = (x_BYTE *)(640 * (unsigned __int16)a2 + x_DWORD_180628b_screen_buffer + (unsigned __int16)a1);
	v8 = a5;
	v9 = (unsigned __int16)a3;
	LOWORD(v9) = a3 - a1;
	if (a3 == a1)
	{
		v10 = (unsigned __int16)a4;
		LOWORD(v10) = a4 - a2;
		if (a6 & 4)
		{
			v11 = x_DWORD_E3890;
			do
			{
				BYTE1(v8) = *v7;
				*v7 = *(x_BYTE *)(v8 + v11);
				v7 += 640;
				--v10;
			} while (v10);
		}
		else
		{
			do
			{
				*v7 = a5;
				v7 += 640;
				--v10;
			} while (v10);
		}
	}
	else if (a6 & 4)
	{
		v12 = x_DWORD_E3890;
		do
		{
			BYTE1(v8) = *v7;
			*v7++ = *(x_BYTE *)(v8 + v12);
			--v9;
		} while (v9);
	}
	else
	{
		memset(v7, a5, v9);
	}
	return v13;
}
// E3890: using guessed type int x_DWORD_E3890;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 180630: using guessed type int x_DWORD_180630_screen_height;
// 180634: using guessed type int x_DWORD_180634_screen_width;
// 18063C: using guessed type int x_DWORD_18063C_sprite_sizex;
// 180650: using guessed type int x_DWORD_180650_positiony;

//----- (00090478) --------------------------------------------------------
void sub_90478_VGA_Blit320()
{
	if (!x_BYTE_E3766)
		sub_8CACD_draw_cursor2();
#ifndef debug_hide_graphics
	VGA_Blit(320, 200, x_DWORD_180628b_screen_buffer);
#endif  
	mydelay(25);//set speed
	/*
	qmemcpy(&loc_A0000_vga_buffer, (void *)x_DWORD_180628b_screen_buffer, 0xFA00u);
	if ( !x_BYTE_E3766 )
	  sub_8CB1F();*/
}
// E3766: using guessed type char x_BYTE_E3766;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;

//----- (000904C0) --------------------------------------------------------
char sub_904C0(float a1)
{
	double v1; // st7
	int v2; // eax
	char result; // al
	int v4; // edx
	signed int v5; // ecx

	//fix it
	v2 = 0;
	v4 = 0;
	v5 = 0;
	//fix it

	if (a1 < dbl_D220C)
		a1 = 0.0099999998;
	v1 = a1;
	do
	{
		IF_DPOW(v1, 1.0 / v1);
		v1 = v1 * dbl_D2218 + dbl_D2220;
		result = (signed int)_CHP(v2);
		x_BYTE_181504[v4] = result;
	} while (v5 < 64);
	return result;
}
// 9B4F6: using guessed type double /*__fastcall*/ _CHP(x_DWORD);
// A097C: using guessed type double IF_DPOW(double, double);
// D220C: using guessed type double dbl_D220C;
// D2218: using guessed type double dbl_D2218;
// D2220: using guessed type double dbl_D2220;

//----- (00090530) --------------------------------------------------------
unsigned __int8 sub_90530(int a1, int a2, float a3)//fix
{
	int v3; // esi
	unsigned __int8 result; // al
	int v5; // ecx
	x_DWORD *v6; // ebx
	int v7; // eax

	v3 = a2;
	sub_904C0(a3);
	if (a2 > 256)
		v3 = 256;
	result = 0;
	//__outx_BYTE(0x3C8u, 0);
	v5 = 0;
	if (v3 > 0)
	{
		v6 = (x_DWORD *)a1;
		do
		{
			// __outx_BYTE(0x3C9u, x_BYTE_181504[*(unsigned __int8 *)v6]);
			// __outx_BYTE(0x3C9u, x_BYTE_181504[(*v6 >> 8) & 0xFF]);
			v7 = (*v6 >> 16) & 0xFF;
			++v6;
			result = x_BYTE_181504[v7];
			++v5;
			//__outx_BYTE(0x3C9u, result);
		} while (v5 < v3);
	}
	return result;
}

//----- (000905EC) --------------------------------------------------------
int sub_905EC_any_graphics_command2(char a1)
{
	char v2; // [esp+0h] [ebp-1Ch]
	char v3; // [esp+1h] [ebp-1Bh]

	x_WORD_E3908 = MEMORY[0x449];
	v2 = a1;
	v3 = 0;
	return int386(0x10, (REGS*)&v2, (REGS*)&v2);//graphics command
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// E3908: using guessed type __int16 x_WORD_E3908;

//----- (00090668) --------------------------------------------------------
signed int sub_90668(int a1)
{
	int v1; // edx
	signed int result; // eax
	int v3; // edx
	int v4; // ebx
	int v5; // ebx

	v1 = a1;
	if (a1)
	{
		result = 0;
		v3 = 0;
		v4 = 0;
		do
		{
			++result;
			x_WORD_1811E4[v3] = v4;
			++v3;
			v4 += 160;
		} while (result < 400);
	}
	else
	{
		result = 0;
		v5 = 80 * a1;
		do
		{
			++result;
			*(__int16 *)((char *)x_WORD_1811E4 + v1) = v5;
			v1 += 2;
			v5 += 80;
		} while (result < 400);
	}
	return result;
}
// 1811E4: using guessed type __int16 x_WORD_1811E4[];

//----- (000906B4) --------------------------------------------------------
int sub_906B4()//fix bios graphics
{
	char *v0; // edx
	signed int v1; // ebx
	char v2; // cl
	signed int v3; // ebx
	int v4; // ecx
	int v5; // eax
	unsigned __int8 v6; // al
	int result; // eax
	char v8; // [esp+0h] [ebp-30h]
	char v9; // [esp+1h] [ebp-2Fh]
	int v10; // [esp+1Ch] [ebp-14h]

	v8 = 0x13;
	v9 = 0;
	x_WORD_E3908 = MEMORY[0x449];
	int386(0x10, (REGS*)&v8, (REGS*)&v8);//Write string (BIOS after 1/10/86) (graphics)
	sub_A0BB0((int *)&unk_E3894, 25);
	/*__outx_WORD(0x3C4u, 0x604u);
	__outx_WORD(0x3D4u, 0x14u);
	__outx_WORD(0x3D4u, 0xE317u);
	__outx_WORD(0x3CEu, 0xFF08u);
	__outx_WORD(0x3C4u, 0xF02u);*/
	v0 = (char *)&loc_A0000_vga_buffer;
	do
	{
		*(x_DWORD *)v0 = 0;
		v0 += 4;
	} while (v0 != (char *)&loc_AFFFE + 2);
	v1 = 0;
	do
	{
		v2 = v1++ & 3;
		x_BYTE_1810A3[v1] = 1 << v2;
	} while (v1 < 320);
	sub_90668(0);
	v3 = 0;
	v4 = 0;
	do
	{
		v10 = 3;
		++v4;
		v5 = 63 * (v3 & 7) / 7 | (63 * (v3 >> 6) / 3 << 16) | (63 * ((v3 >> 3) & 7) / 7 << 8);
		++v3;
		x_DWORD_180CA0[v4] = v5;
	} while (v3 < 256);
	sub_90530((int)&unk_180CA4, 256, 1.2);
	v6 = __inx_BYTE(0x3DAu);
	//__outx_BYTE(0x3C0u, 0x11u);
	//__outx_BYTE(0x3C0u, 0);
	result = 0;
	//LOBYTE(result) = __inx_BYTE(0x3DAu);
	LOBYTE(result) = 32;
	//__outx_BYTE(0x3C0u, 0x20u);
	return result;
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// E3908: using guessed type __int16 x_WORD_E3908;
// 180CA0: using guessed type int x_DWORD_180CA0[];

//----- (00090810) --------------------------------------------------------
int sub_90810()
{
	int result; // eax

	if (x_WORD_E3908)
	{
		result = sub_905EC_any_graphics_command2(x_WORD_E3908);
		x_WORD_E3908 = 0;
	}
	return result;
}
// E3908: using guessed type __int16 x_WORD_E3908;
void sub_90B27_VGA_pal_fadein_fadeout(Bit8u *newpalbuffer, Bit8u shadow_levels, bool singlestep)//271B27 init and nightfall
{
	//Bit8u *v3; // eax
	//Bit16u v4; // edx
	//Bit8u* v5; // eax
	//Bit16u v6; // edx
	Bit8u outbuffer[768]; // [esp+0h] [ebp-30Ch]
	Bit16u i; // [esp+300h] [ebp-Ch]
	Bit8u j = 0;
	//Bit8u* v10; // [esp+308h] [ebp-4h]

	Bit8u zero_buffer[768];

	VGA_Init();

	if (singlestep)
	{
		if (x_BYTE_E390C_VGA_pal_not_begin)
		{
			j++;
			if (shadow_levels == j)
				x_BYTE_E390C_VGA_pal_not_begin = 0;
		}
		else
		{
			j = 0;
			x_BYTE_E390C_VGA_pal_not_begin = 1;
			sub_A0D2C_VGA_get_pallette(x_BYTE_181544_oldpalbuffer);
			if (!newpalbuffer)
				memset(zero_buffer, 0, 768);
		}
		if (!newpalbuffer)
			newpalbuffer = zero_buffer;
		for (i = 0; i < 768; i++)
		{
			//v5 = &buffer[i];
			//LOWORD(v5) = *v5;
			//v6 = i;
			//LOWORD(v6) = x_BYTE_181544_oldpalbuffer[i];
			//v10 = &v5[-v6];
			//outbuffer[i] = x_BYTE_181544_oldpalbuffer[i] + ((unk_181B42 >> 16)* (newpalbuffer[i] - x_BYTE_181544_oldpalbuffer[i])/ shadow_levels);
			outbuffer[i] = x_BYTE_181544_oldpalbuffer[i] + (j* (newpalbuffer[i] - x_BYTE_181544_oldpalbuffer[i]) / shadow_levels);
		}
		sub_9A0FC_wait_to_screen_beam();
		sub_41A90_VGA_pallette_install(outbuffer);
	}
	else
	{
		sub_A0D2C_VGA_get_pallette(x_BYTE_181544_oldpalbuffer);
		if (!newpalbuffer)//ebp+14 - 355204
		{
			newpalbuffer = zero_buffer;
			memset(zero_buffer, 0, 768);
		}
		for (j = 0; shadow_levels >= j; j++)
		{
			for (i = 0; i < 768; i++)
			{
				/*al=352544[i];
				dl = 352544[i];
				edx=al-dl
				eax=[352b42]>>16
				edx=edx*eax
				bl= shadow_levels
				sar edx,1f//!
				idiv ebx
				edx=352544[i]&0xff
				eax+=edx
				v8[i]=al*/


				//v3 = buffer[i];
				//LOWORD(v3) = *v3;
				//v4 = i;
				//v4 = x_BYTE_181544_oldpalbuffer[i];
				//v10 = &v3[-v4];
				//outbuffer[i] = x_BYTE_181544_oldpalbuffer[i] + ((unk_181B42 >> 16) * (newpalbuffer[i] - x_BYTE_181544_oldpalbuffer[i]) / shadow_levels);//352b42 352544
				outbuffer[i] = x_BYTE_181544_oldpalbuffer[i] + (j * (newpalbuffer[i] - x_BYTE_181544_oldpalbuffer[i]) / shadow_levels);//352b42 352544
			}
			sub_9A0FC_wait_to_screen_beam();
			sub_41A90_VGA_pallette_install(outbuffer);
			mydelay(10);
		}
		x_BYTE_E390C_VGA_pal_not_begin = 0;
	}

	/*if ((a1 == NULL) && (a2 == 0x10) && (a3 == 0)) {//fix it - a1 not changed
		VGA_Init();
	}*/
	//return 0;
}
//----- (00090B27) --------------------------------------------------------
__int16 sub_90B27_VGA_pal_fadein_fadeout_orig(char *a1, unsigned __int8 a2, char a3)
{
	/*
  char *v3; // eax
  int v4; // edx
  char *v5; // eax
  int v6; // edx
  char v8[768]; // [esp+0h] [ebp-30Ch]
  int i; // [esp+300h] [ebp-Ch]
  unsigned __int8 *v10; // [esp+308h] [ebp-4h]

  if ( a3 )
  {
	if ( x_BYTE_E390C_VGA_pal_not_begin )
	{
	  if ( a2 == ++x_WORD_181B44 )
		x_BYTE_E390C_VGA_pal_not_begin = 0;
	}
	else
	{
	  x_WORD_181B44 = 0;
	  x_BYTE_E390C_VGA_pal_not_begin = 1;
	  sub_A0D2C_VGA_get_pallette(x_BYTE_181544_oldpalbuffer);
	  if ( !a1 )
		memset(&unk_181844, 0, 768);
	}
	if ( !a1 )
	  a1 = (char *)&unk_181844;
	for ( i = 0; (signed __int16)i < 768; i++ )
	{
	  v5 = &a1[(signed __int16)i];
	  LOWORD(v5) = (unsigned __int8)*v5;
	  v6 = (signed __int16)i;
	  LOWORD(v6) = x_BYTE_181544_oldpalbuffer[(signed __int16)i];
	  v10 = (unsigned __int8 *)&v5[-v6];
	  v8[(signed __int16)i] = x_BYTE_181544_oldpalbuffer[(signed __int16)i]
							+ (unsigned int)((unk_181B42 >> 16)
										   * (signed int)(signed __int16)((unsigned __int8)v5 - (unsigned __int8)v6)
										   / a2);
	}
	sub_9A0FC_wait_to_screen_beam();
	sub_41A90_VGA_pallette_install((unsigned __int8 *)v8);
  }
  else
  {
	sub_A0D2C_VGA_get_pallette(x_BYTE_181544_oldpalbuffer);
	if ( !a1 )
	{
	  a1 = (char *)&unk_181844;
	  memset(&unk_181844, 0, 768);
	}
	for ( x_WORD_181B44 = 0; a2 >= x_WORD_181B44; ++x_WORD_181B44 )
	{
	  for ( i = 0; (signed __int16)i < 768; i++ )
	  {
		v3 = &a1[(signed __int16)i];
		LOWORD(v3) = (unsigned __int8)*v3;
		v4 = (signed __int16)i;
		LOWORD(v4) = x_BYTE_181544_oldpalbuffer[(signed __int16)i];
		v10 = (unsigned __int8 *)&v3[-v4];
		v8[(signed __int16)i] = x_BYTE_181544_oldpalbuffer[(signed __int16)i]
							  + (unsigned int)((unk_181B42 >> 16)
											 * (signed int)(signed __int16)((unsigned __int8)v3 - (unsigned __int8)v4)
											 / a2);
	  }
	  sub_9A0FC_wait_to_screen_beam();
	  sub_41A90_VGA_pallette_install((unsigned __int8 *)v8);
	}
	x_BYTE_E390C_VGA_pal_not_begin = 0;
  }
  return x_WORD_181B44;*/
	return 0;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// E390C: using guessed type char x_BYTE_E390C_VGA_pal_not_begin;
// 181B44: using guessed type __int16 x_WORD_181B44;
// 90B27: using guessed type char var_30C[768];

//----- (00090D27) --------------------------------------------------------
void sub_90D27()
{
	x_BYTE_E390C_VGA_pal_not_begin = 0;
}
// E390C: using guessed type char x_BYTE_E390C_VGA_pal_not_begin;

//----- (00090D3F) --------------------------------------------------------
char* sub_90D3F_unload_file_array(int psindex)
{
	char* result; // eax

	while (1)
	{
		result = pstr[psindex].path;
		if (!pstr[psindex].var28_begin_buffer)
			break;
		sub_9A2F5(pstr[psindex]);
		pstr[++psindex];
	}
	return result;
}

void sub_90D6E_VGA_set_video_mode_320x200_and_pallette(Bit8u* pallette)
{
	//find 351662 - 3;//fix it
	//unsigned __int8 v2=3; // [esp+0h] [ebp-38h]
	//int v3; // [esp+1Ch] [ebp-1Ch]
			//input1 355200(180200) - 3
			//input2 35521c 00 0f 00 00 00
	//v3 = 0xf00;
	//int386(0x10, (REGS*)&v3, (REGS*)&v2);//Set video mode
	VGA_Resize(320, 200);
	if (!x_WORD_180662_graphics_handle)
		x_WORD_180662_graphics_handle = 0x13;
	//v3 = 0x13;
	x_DWORD_18062C_resolution_x = 320;
	x_DWORD_180624_resolution_y = 200;
	//int386(0x10, (REGS*)&v3, (REGS*)&v2);//Write string (BIOS after 1/10/86)

	//a1 - 3aa0a4
	sub_41A90_VGA_pallette_install(pallette);
	sub_8D12F_set_mouse_viewport();
	sub_A0D50_set_viewport(0, 0, 320, 200);
}

//----- (00090D6E) --------------------------------------------------------
void sub_90D6E_VGA_set_video_mode_320x200_and_pallette_orig(unsigned __int8 *a1)
{
	unsigned __int8 v2; // [esp+0h] [ebp-38h]
	int v3; // [esp+1Ch] [ebp-1Ch]

	//v3 = 0xf00;
	int386(0x10, (REGS*)&v3, (REGS*)&v2);//Set video mode
	if (!x_WORD_180662_graphics_handle)
		x_WORD_180662_graphics_handle = v2;
	//v3 = 0x13;
	x_DWORD_18062C_resolution_x = 320;
	x_DWORD_180624_resolution_y = 200;
	//int386(0x10, (REGS*)&v3, (REGS*)&v2);//Write string (BIOS after 1/10/86)
	sub_41A90_VGA_pallette_install(a1);
	sub_8D12F_set_mouse_viewport();
	sub_A0D50_set_viewport(0, 0, 320, 200);
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// 180624: using guessed type int x_DWORD_180624_resolution_y;
// 18062C: using guessed type int x_DWORD_18062C_resolution_x;
// 180662: using guessed type __int16 x_WORD_180662_graphics_handle;

//----- (00090E07) --------------------------------------------------------
void sub_90E07_VGA_set_video_mode_640x480_and_pallette(Bit8u* pallette)
{
	//unsigned __int8 v2; // [esp+0h] [ebp-38h]
	//int v3; // [esp+1Ch] [ebp-1Ch]

	//v3 = 0xf00;//
	//int386(0x10, (REGS*)&v3, (REGS*)&v2);//Set video mode
	VGA_Resize(640, 480);
	if (!x_WORD_180662_graphics_handle)
		x_WORD_180662_graphics_handle = 0x13;
	x_DWORD_18062C_resolution_x = 640;
	x_DWORD_180624_resolution_y = 480;
	sub_994BA_cursor_move(0x101);
	sub_41A90_VGA_pallette_install(pallette);
	sub_8D12F_set_mouse_viewport();
	sub_A0D50_set_viewport(0, 0, 640, 480);
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// 180624: using guessed type int x_DWORD_180624_resolution_y;
// 18062C: using guessed type int x_DWORD_18062C_resolution_x;
// 180662: using guessed type __int16 x_WORD_180662_graphics_handle;

//----- (00090EA0) --------------------------------------------------------
int sub_90EA0(int a1, char* a2)
{
	int result; // eax

	x_DWORD_181BE4_number_of_disc = a1;
	result = sprintf_s(aSound_2, 512, (const char *)"%s", a2);//2a3228
	x_BYTE_E39A0 = 1;
	return result;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// E39A0: using guessed type char x_BYTE_E39A0;
// 181BE4: using guessed type int x_DWORD_181BE4_number_of_disc;

//----- (00090EE0) --------------------------------------------------------
int sub_90EE0()//271ee0
{
	Bit32s v1; // [esp+0h] [ebp-8h]

	x_dos_setdrive(x_DWORD_181BE4_number_of_disc, &v1);
	return x_chdir("SOUND");
}
// 8C1CA: using guessed type x_DWORD dos_setdrive(x_DWORD, x_DWORD);
// A0DA5: using guessed type x_DWORD chdir(x_DWORD);
// 181BE4: using guessed type int x_DWORD_181BE4_number_of_disc;

//----- (00090F20) --------------------------------------------------------
int sub_90F20_restore_old_directory()
{
	Bit32s v1; // [esp+0h] [ebp-4h]

	x_dos_setdrive(x_DWORD_181BE0, &v1);
	return x_chdir(unk_181B50);
}
// 8C1CA: using guessed type x_DWORD dos_setdrive(x_DWORD, x_DWORD);
// A0DA5: using guessed type x_DWORD chdir(x_DWORD);
// 181BE0: using guessed type int x_DWORD_181BE0;

//----- (00090F60) --------------------------------------------------------
int sub_90F60()//271f60
{
	char* v0; // ST0C_4
	int result; // eax

	v0 = x_getcwd(0, 0);
	sprintf_s(unk_181B50, 512, (const char *)"%s", v0 + 2);
	free((void*)v0);
	result = dos_getdrive(&x_DWORD_181BE0);//352be0
	if (!x_BYTE_E39A0)
	{
		result = x_DWORD_181BE0;
		x_DWORD_181BE4_number_of_disc = x_DWORD_181BE0;
	}
	return result;
}
// 8C1B2: using guessed type x_DWORD dos_getdrive(x_DWORD);
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// A0DC7: using guessed type x_DWORD getcwd(x_DWORD, x_DWORD);
// A0E6B: using guessed type x_DWORD free(x_DWORD);
// E39A0: using guessed type char x_BYTE_E39A0;
// 181BE0: using guessed type int x_DWORD_181BE0;
// 181BE4: using guessed type int x_DWORD_181BE4_number_of_disc;

//----- (00090FD0) --------------------------------------------------------
__int16 /*__fastcall*/ sub_90FD0(char* a1/*, int a2, char* a3*/)//271fd0
{
	//int v3; // eax
	//int v4; // edx
	int result; // eax

	//fix it
	//v3 = 0;
	//v4 = 0;
	//fix it

	sub_8D290_init_sound(a1/*, a2, (int)a3*/);
	sub_8D970_init_music(a1/*v3, v4, a3*/);
	result = _stricmp(unk_180A30.driver_name, "SB16.DIG");
	if (!result)
		result = sub_91010();
	return result;
}
// 98F5D: using guessed type x_DWORD stricmp(x_DWORD, x_DWORD);

//----- (00091010) --------------------------------------------------------
__int16 sub_91010()
{
	__int16 result; // ax
	__int16 v1; // [esp+0h] [ebp-4h]

	result = x_WORD_180B30;
	v1 = x_WORD_180B30;
	if (x_WORD_180B30 == 544)
	{
		x_outp(x_WORD_180B30 + 4, 48);
		x_WORD_E39A4 = x_inp(v1 + 5) >> 3;
		x_outp(v1 + 4, 49);
		x_WORD_E39A6 = x_inp(v1 + 5) >> 3;
		x_outp(v1 + 4, 50);
		x_WORD_E39AC = x_inp(v1 + 5);
		x_outp(v1 + 5, 8 * x_WORD_E39A4 - 32);
		x_outp(v1 + 4, 51);
		x_WORD_E39AE = x_inp(v1 + 5);
		x_outp(v1 + 5, 8 * x_WORD_E39A6 - 32);
		x_outp(v1 + 4, 68);
		x_WORD_E39B0 = x_inp(v1 + 5);
		x_outp(v1 + 5, 96);
		x_outp(v1 + 4, 69);
		x_WORD_E39B2 = x_inp(v1 + 5);
		x_outp(v1 + 5, 96);
		x_outp(v1 + 4, 70);
		x_WORD_E39B4 = x_inp(v1 + 5);
		x_outp(v1 + 5, 120);
		x_outp(v1 + 4, 71);
		x_WORD_E39B6 = x_inp(v1 + 5);
		x_outp(v1 + 5, 120);
		if (!_stricmp(unk_180BE0, "SBAWE32.MDI"))
		{
			x_outp(v1 + 4, 52);
			x_WORD_E39A8 = x_inp(v1 + 5);
			x_outp(v1 + 5, 8 * x_WORD_E39A4 - 24);
			x_outp(v1 + 4, 53);
			x_WORD_E39AA = x_inp(v1 + 5);
			result = x_outp(v1 + 5, 8 * x_WORD_E39A6 - 24);
		}
		else if (!_stricmp(unk_180BE0, "MPU401.MDI"))
		{
			x_outp(v1 + 4, 52);
			x_WORD_E39A8 = x_inp(v1 + 5);
			x_outp(v1 + 5, 8 * x_WORD_E39A4 - 24);
			x_outp(v1 + 4, 53);
			x_WORD_E39AA = x_inp(v1 + 5);
			result = x_outp(v1 + 5, 8 * x_WORD_E39A6 - 24);
		}
		else
		{
			x_outp(v1 + 4, 52);
			x_WORD_E39A8 = x_inp(v1 + 5);
			x_outp(v1 + 5, 8 * x_WORD_E39A4 - 8);
			x_outp(v1 + 4, 53);
			x_WORD_E39AA = x_inp(v1 + 5);
			result = x_outp(v1 + 5, 8 * x_WORD_E39A6 - 8);
		}
		x_BYTE_E39B8 = 1;
	}
	return result;
}
// 98F5D: using guessed type x_DWORD stricmp(x_DWORD, x_DWORD);
// A0ED7: using guessed type x_DWORD outp(x_DWORD, char);
// A0EE1: using guessed type x_DWORD inp(x_DWORD);
// E39A4: using guessed type __int16 x_WORD_E39A4;
// E39A6: using guessed type __int16 x_WORD_E39A6;
// E39A8: using guessed type __int16 x_WORD_E39A8;
// E39AA: using guessed type __int16 x_WORD_E39AA;
// E39AC: using guessed type __int16 x_WORD_E39AC;
// E39AE: using guessed type __int16 x_WORD_E39AE;
// E39B0: using guessed type __int16 x_WORD_E39B0;
// E39B2: using guessed type __int16 x_WORD_E39B2;
// E39B4: using guessed type __int16 x_WORD_E39B4;
// E39B6: using guessed type __int16 x_WORD_E39B6;
// E39B8: using guessed type char x_BYTE_E39B8;
// 180B30: using guessed type __int16 x_WORD_180B30;

//----- (00091420) --------------------------------------------------------
int sub_91420()
{
	__int16 v0; // ST08_2

	v0 = x_WORD_180B30;
	x_outp(x_WORD_180B30 + 4, 50);
	x_outp(549, x_WORD_E39AC);
	x_outp(v0 + 4, 51);
	x_outp(v0 + 5, x_WORD_E39AE);
	x_outp(v0 + 4, 52);
	x_outp(v0 + 5, x_WORD_E39A8);
	x_outp(v0 + 4, 53);
	x_outp(v0 + 5, x_WORD_E39AA);
	x_outp(v0 + 4, 68);
	x_outp(v0 + 5, x_WORD_E39B0);
	x_outp(v0 + 4, 69);
	x_outp(v0 + 5, x_WORD_E39B2);
	x_outp(v0 + 4, 70);
	x_outp(v0 + 5, x_WORD_E39B4);
	x_outp(v0 + 4, 71);
	return x_outp(v0 + 5, x_WORD_E39B6);
}
// A0ED7: using guessed type x_DWORD outp(x_DWORD, char);
// E39A8: using guessed type __int16 x_WORD_E39A8;
// E39AA: using guessed type __int16 x_WORD_E39AA;
// E39AC: using guessed type __int16 x_WORD_E39AC;
// E39AE: using guessed type __int16 x_WORD_E39AE;
// E39B0: using guessed type __int16 x_WORD_E39B0;
// E39B2: using guessed type __int16 x_WORD_E39B2;
// E39B4: using guessed type __int16 x_WORD_E39B4;
// E39B6: using guessed type __int16 x_WORD_E39B6;
// 180B30: using guessed type __int16 x_WORD_180B30;

//----- (000915A0) --------------------------------------------------------
void sub_915A0_sound_proc23()
{
	//bool result; // eax

	if (!x_DWORD_E39BC)
	{
		sub_9D590_lock_linear_region((Bit8u*)sub_915A0_sound_proc23, (unsigned int)sub_986A0_unlock_linear_region);
		sub_9D710((Bit8u*)&x_DWORD_181BF4, 4);
		sub_9D710((Bit8u*)&x_DWORD_181BF8, 4);
		sub_9D710((Bit8u*)&x_DWORD_181BF0_AIL_debugfile, 4);
		sub_9D710((Bit8u*)&x_DWORD_181BFC, 4);
		sub_9D710((Bit8u*)&x_DWORD_181C0C, 4);
		sub_9D710((Bit8u*)&x_DWORD_181C08, 4);
		sub_9D710((Bit8u*)&x_DWORD_181C10, 4);
		sub_9D710((Bit8u*)&x_DWORD_181C00, 4);
		x_DWORD_E39BC = 1;
	}
	//return result;
}
// E39BC: using guessed type int x_DWORD_E39BC;
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181BFC: using guessed type int x_DWORD_181BFC;
// 181C00: using guessed type int x_DWORD_181C00;
// 181C08: using guessed type int x_DWORD_181C08;
// 181C0C: using guessed type int x_DWORD_181C0C;
// 181C10: using guessed type int x_DWORD_181C10;

void sub_91660(HMDIDRIVER user)
{
	if ((x_DWORD_181BFC != 99 || x_DWORD_181C0C != 59 || x_DWORD_181C08 != 59 || x_DWORD_181C10 != 99) && ++x_DWORD_181C10 == 100)
	{
		x_DWORD_181C10 = 0;
		if (++x_DWORD_181C08 == 60)
		{
			x_DWORD_181C08 = 0;
			if (++x_DWORD_181C0C == 60)
			{
				x_DWORD_181C0C = 0;
				++x_DWORD_181BFC;
			}
		}
	}
}

//----- (000916F0) --------------------------------------------------------
/*signed int sub_916F0_sound_proc24()
{
  int i; // [esp+4h] [ebp-14h]
  int j; // [esp+4h] [ebp-14h]
  int v3; // [esp+8h] [ebp-10h]
  int v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  sub_A0EEC_s_plus2();
  v6 = x_DWORD_181BFC;
  v5 = x_DWORD_181C0C;
  v4 = x_DWORD_181C08;
  v3 = x_DWORD_181C10;
  sub_A0EF9_s_minus2();
  if ( x_DWORD_181C04 == 1 )
  {
	dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "[%.02u:%.02u:%.02u.%.02u] ", v6, v5, v4, v3);
  }
  else
  {
	for ( i = 0; i < 0xE; i++ )
	  dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
  }
  for ( j = 1; j < x_DWORD_181C04; j++ )
	dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
  return 1;
}*/
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BFC: using guessed type int x_DWORD_181BFC;
// 181C04: using guessed type int x_DWORD_181C04;
// 181C08: using guessed type int x_DWORD_181C08;
// 181C0C: using guessed type int x_DWORD_181C0C;
// 181C10: using guessed type int x_DWORD_181C10;

//----- (000919C0) --------------------------------------------------------
signed int sub_919C0()
{
	signed int result; // eax
	bool v1; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v1 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v1)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_shutdown()\n");
	result = sub_9ED70();
	if (x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8))
	{
		result = sub_A16A2();
		if (!result)
			result = fclose(x_DWORD_181BF0_AIL_debugfile);
	}
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// A1E05: using guessed type x_DWORD fclose(x_DWORD);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00091A80) --------------------------------------------------------
int sub_91A80_AIL_set_preference(Bit32u number, Bit32s value)//int (__stdcall *mss32_AIL_set_preference)(unsigned int, int) = 0;
{
	int i; // [esp+0h] [ebp-10h]
	int j; // [esp+0h] [ebp-10h]
	bool v5; // [esp+4h] [ebp-Ch]
	int result; // [esp+Ch] [ebp-4h]

	x_DWORD_181C04++;
	v5 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v5)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_set_preference(%d,%d)\n", number, value);
	result = sub_9E6E0_set_preference(number, value);
	if (x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2())
	{
		for (i = 0; i < 0xE; i++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
		for (j = 1; j < x_DWORD_181C04; j++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Result = %d\n", result);
	}
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00091BD0) --------------------------------------------------------
void sub_91BD0_s_plus()//fix it - remove
{
	sub_A0EEC_s_plus2();
}

//----- (00091BF0) --------------------------------------------------------
void sub_91BF0_s_minus()//fix it - remove
{
	sub_A0EF9_s_minus2();
}

//----- (00091C10) --------------------------------------------------------
Bit16u sub_91C10_AIL_get_real_vect(/*VDI_HDR* a1, int a2, int a3,*/ Bit32u vectnum/*U32       vectnum*/)//AIL_get_real_vect
{
	int v4; // eax
	int i; // [esp+0h] [ebp-10h]
	int j; // [esp+0h] [ebp-10h]
	bool v8; // [esp+4h] [ebp-Ch]
	Bit16u result; // [esp+Ch] [ebp-4h]

	x_DWORD_181C04++;
	v8 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && (v4 = sub_A16A2(), !v4 && sub_916F0_sound_proc24());
	if (v8)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_get_real_vect(0x%X)\n", vectnum);
	result = sub_A121D_AIL_API_get_real_vect(vectnum/*, a1, a3, a2*/);
	if (x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2())
	{
		for (i = 0; i < 0xE; i++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
		for (j = 1; j < x_DWORD_181C04; j++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Result = 0x%X\n", result);
	}
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00091D50) --------------------------------------------------------
void sub_91D50_AIL_set_real_vect(Bit32u vectnum, Bit16u real_ptr)//AIL_set_real_vect
{
	//signed int result; // eax
	bool v3; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v3 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v3)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_set_real_vect(0x%X,0x%X)\n", vectnum, real_ptr);
	sub_A1249_AIL_API_set_real_vect(vectnum, real_ptr);
	x_DWORD_181C04--;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00091E90) --------------------------------------------------------
void sub_91E90_AIL_restore_USE16_ISR(Bit32s a1)//AIL_restore_USE16_ISR
{
	bool v2; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v2 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v2)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_restore_USE16_ISR(%d)\n", a1);
	sub_A14DB_AIL_API_restore_USE16_ISR(a1);
	x_DWORD_181C04--;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00091F20) --------------------------------------------------------
unsigned int sub_91F20()
{
	return sub_A1520();
}

//----- (00091F50) --------------------------------------------------------
void sub_91F50(unsigned int a1)
{
	sub_A1524(a1);
}

//----- (00091F70) --------------------------------------------------------
Bit32s sub_91F70_AIL_call_driver(AIL_DRIVER* drvr, Bit32s fn, VDI_CALL* in, VDI_CALL* out)//AIL_call_driver //272f70
{
	int i; // [esp+0h] [ebp-10h]
	int j; // [esp+0h] [ebp-10h]
	bool v7; // [esp+4h] [ebp-Ch]
	int result; // [esp+Ch] [ebp-4h]

	x_DWORD_181C04++;
	v7 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v7)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_call_driver(0x%X,0x%X,0x%X,0x%X)\n", drvr, fn, in, out);
	result = sub_A158B_AIL_API_call_driver(drvr, fn, in, out);
	if (x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2())
	{
		for (i = 0; i < 0xE; i++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
		for (j = 1; j < x_DWORD_181C04; j++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Result = %d\n", result);
	}
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (000920D0) --------------------------------------------------------
void sub_920D0_AIL_delay(int a1)//AIL_delay
{
	unsigned __int8 result; // al
	bool v2; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v2 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v2)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_delay(%d)\n", a1);
	/*result = */sub_A1665_AIL_API_delay(a1);
	x_DWORD_181C04--;
	//return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00092160) --------------------------------------------------------
int sub_92160()
{
	return sub_A16A2();
}

//----- (00092190) --------------------------------------------------------
int sub_92190_AIL_read_INI(AIL_INI* INI, char* filename/*, char* a8, IO_PARMS IO*/)//AIL_read_INI // 273190
{
	int i1; // [esp+0h] [ebp-28h]
	int i2; // [esp+0h] [ebp-28h]
	int mm; // [esp+4h] [ebp-24h]
	int nn; // [esp+4h] [ebp-24h]
	int kk; // [esp+8h] [ebp-20h]
	int ll; // [esp+8h] [ebp-20h]
	int ii; // [esp+Ch] [ebp-1Ch]
	int jj; // [esp+Ch] [ebp-1Ch]
	int m; // [esp+10h] [ebp-18h]
	int n; // [esp+10h] [ebp-18h]
	int k; // [esp+14h] [ebp-14h]
	int l; // [esp+14h] [ebp-14h]
	int i; // [esp+18h] [ebp-10h]
	int j; // [esp+18h] [ebp-10h]
	bool v17; // [esp+1Ch] [ebp-Ch]
	int result; // [esp+24h] [ebp-4h]

	x_DWORD_181C04++;
	v17 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v17)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_API_read_INI(0x%X,%s)\n", INI, filename);
	result = sub_9E3A0_AIL_API_read_INI(INI, filename/*/*a8, &IO*/);
	if (result)
	{
		if (x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2())
		{
			for (i = 0; i < 0xE; i++)
				dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
			for (j = 1; j < x_DWORD_181C04; j++)
				dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Driver = %s\n", INI->driver_name);
			for (k = 0; k < 0xE; k++)
				dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
			for (l = 1; l < x_DWORD_181C04; l++)
				dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Device = %s\n", INI->device_name);
			for (m = 0; m < 0xE; m++)
				dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
			for (n = 1; n < x_DWORD_181C04; n++)
				dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "IO     = %X\n", INI->IO.IO);//*(signed __int16 *)(a1 + 256)
			for (ii = 0; ii < 0xE; ii++)
				dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
			for (jj = 1; jj < x_DWORD_181C04; jj++)
				dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "IRQ    = %d\n", INI->IO.IRQ);//*(signed __int16 *)(a1 + 258)
			for (kk = 0; kk < 0xE; kk++)
				dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
			for (ll = 1; ll < x_DWORD_181C04; ll++)
				dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "DMA_8  = %d\n", INI->IO.DMA_8_bit);//*(signed __int16 *)(a1 + 260)
			for (mm = 0; mm < 0xE; mm++)
				dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
			for (nn = 1; nn < x_DWORD_181C04; nn++)
				dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "DMA_16 = %d\n", INI->IO.DMA_16_bit);//*(signed __int16 *)(a1 + 262)
		}
	}
	else if (x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2())
	{
		for (i1 = 0; i1 < 0xE; i1++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
		for (i2 = 1; i2 < x_DWORD_181C04; i2++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Result = %u\n", 0);
	}
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00092600) --------------------------------------------------------
HTIMER sub_92600_AIL_register_timer(AILTIMERCB callback_fn/*AILTIMERCB    callback_fn*/)//AIL_register_timer
{
	int i; // [esp+0h] [ebp-10h]
	int j; // [esp+0h] [ebp-10h]
	bool v4; // [esp+4h] [ebp-Ch]
	HTIMER result; // [esp+Ch] [ebp-4h]

	x_DWORD_181C04++;
	v4 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v4)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_register_timer(0x%X)\n", callback_fn);
	result = sub_A16AE_register_timer(callback_fn);
	if (x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2())
	{
		for (i = 0; i < 0xE; i++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
		for (j = 1; j < x_DWORD_181C04; j++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Result = %u\n", result);
	}
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00092740) --------------------------------------------------------
signed __int32 sub_92740_AIL_set_timer_user(int timer/*HTIMER      timer*/, signed __int32 user/*UINTa       user*/)//AIL_set_timer_user
{
	int i; // [esp+0h] [ebp-10h]
	int j; // [esp+0h] [ebp-10h]
	bool v5; // [esp+4h] [ebp-Ch]
	signed __int32 v6; // [esp+Ch] [ebp-4h]

	x_DWORD_181C04++;
	v5 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v5)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_set_timer_user(%u,%u)\n", timer, user);
	v6 = sub_A16F5_AIL_API_set_timer_user(timer, user);
	if (x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2())
	{
		for (i = 0; i < 0xE; i++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
		for (j = 1; j < x_DWORD_181C04; j++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Result = %u\n", v6);
	}
	x_DWORD_181C04--;
	return v6;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00092890) --------------------------------------------------------
void sub_92890_AIL_set_timer_period(HTIMER timer, Bit32u microseconds)//AIL_set_timer_period
{
	bool v2; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v2 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v2)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_set_timer_period(%u,%u)\n", timer, microseconds);
	sub_A1810_set_timer_period(timer, microseconds);
	x_DWORD_181C04--;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00092930) --------------------------------------------------------
void sub_92930_AIL_set_timer_frequency(HTIMER timer/*HTIMER timer*/, Bit32u hertz/*U32 hertz*/)//AIL_set_timer_frequency
{
	bool v2; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v2 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v2)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_set_timer_frequency(%u,%u)\n", timer, hertz);
	sub_A1840_AIL_API_set_timer_frequency(timer, hertz);
	x_DWORD_181C04--;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00092BA0) --------------------------------------------------------
void sub_92BA0_AIL_start_timer(HTIMER timer/*HTIMER      timer*/)//AIL_start_timer
{
	bool v1; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v1 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v1)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_start_timer(%u)\n", timer);
	sub_A1768_start_timer(timer);
	x_DWORD_181C04--;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00092CB0) --------------------------------------------------------
void sub_92CB0_AIL_stop_timer(HTIMER timer/*HTIMER      timer*/)//AIL_stop_timer
{
	bool v1; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v1 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v1)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_stop_timer(%u)\n", timer);
	sub_A17BC_stop_timer(timer);
	x_DWORD_181C04--;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00092DC0) --------------------------------------------------------
void sub_92DC0_AIL_release_timer_handle(Bit32s timer/*HTIMER      timer*/)//AIL_release_timer_handle
{
	bool v1; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v1 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v1)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_release_timer_handle(%u)\n", timer);
	sub_A171D_release_timer_handle(timer);
	x_DWORD_181C04--;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00092E50) --------------------------------------------------------
void sub_92E50_AIL_release_all_timers()//AIL_release_all_timers
{
	bool v0; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v0 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v0)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_release_all_timers()\n");
	sub_A1744_AIL_API_release_all_timers();
	x_DWORD_181C04--;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00092ED0) --------------------------------------------------------
IO_PARMS* sub_92ED0_AIL_get_IO_environment(AIL_DRIVER* drvr/*AIL_DRIVER *drvr  */)//AIL_get_IO_environment  
{
	int i; // [esp+0h] [ebp-10h]
	int j; // [esp+0h] [ebp-10h]
	bool v4; // [esp+4h] [ebp-Ch]
	IO_PARMS* result; // [esp+Ch] [ebp-4h]

	x_DWORD_181C04++;
	v4 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v4)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_get_IO_environment(0x%X)\n", drvr);
	result = sub_9EB60_AIL_API_get_IO_environment(drvr);
	if (x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2())
	{
		for (i = 0; i < 0xE; i++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
		for (j = 1; j < x_DWORD_181C04; j++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Result = 0x%X\n", result);
	}
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00093010) --------------------------------------------------------
AIL_DRIVER* sub_93010_AIL_install_driver(/*int a1, */Bit8u* driver_image, Bit32s n_bytes)//AIL_install_driver //274010
{
	int i; // [esp+0h] [ebp-10h]
	int j; // [esp+0h] [ebp-10h]
	bool v6; // [esp+4h] [ebp-Ch]
	AIL_DRIVER *v7; // [esp+Ch] [ebp-4h]

	x_DWORD_181C04++;
	v6 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v6)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_install_driver(0x%X,%u)\n", driver_image, n_bytes);
	v7 = sub_9E720_AIL_API_install_driver(/*a1, */driver_image, n_bytes);
	if (x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2())
	{
		for (i = 0; i < 0xE; i++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
		for (j = 1; j < x_DWORD_181C04; j++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Result = 0x%X\n", v7);
	}
	x_DWORD_181C04--;
	return v7;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00093160) --------------------------------------------------------
int sub_93160_AIL_uninstall_driver(AIL_DRIVER* drvr/*AIL_DRIVER *drvr  */)//AIL_uninstall_driver  
{
	int result; // eax
	bool v2; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v2 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v2)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_uninstall_driver(0x%X)\n", drvr);
	result = sub_9EA60_AIL_API_uninstall_driver(drvr);
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (000931F0) --------------------------------------------------------
int sub_931F0_AIL_install_DIG_INI(/*int a1,*/ HDIGDRIVER* dig/*HDIGDRIVER *dig*/)//AIL_install_DIG_INI //2741f0
{
	int i; // [esp+0h] [ebp-10h]
	int j; // [esp+0h] [ebp-10h]
	bool v5; // [esp+4h] [ebp-Ch]
	int result; // [esp+Ch] [ebp-4h]

	x_DWORD_181C04++;
	v5 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v5)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_install_DIG_INI(0x%X)\n", dig);
	result = sub_A3720_AIL_API_install_DIG_INI(/*a1,*/ dig);
	if (x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2())
	{
		for (i = 0; i < 0xE; i++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
		for (j = 1; j < x_DWORD_181C04; j++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Result = %d\n", result);
	}
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00093330) --------------------------------------------------------
HDIGDRIVER sub_93330_AIL_install_DIG_driver_file(/*int a1, */char* filename, IO_PARMS* IO)//AIL_install_DIG_driver_file // 274330
{
	int i; // [esp+0h] [ebp-10h]
	int j; // [esp+0h] [ebp-10h]
	bool v6; // [esp+4h] [ebp-Ch]
	HDIGDRIVER result; // [esp+Ch] [ebp-4h]

	x_DWORD_181C04++;
	v6 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v6)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_install_DIG_driver_file(%s,0x%X)\n", filename, IO);
	result = sub_A3600_AIL_API_install_DIG_driver_file(/*a1, */filename, IO);
	if (x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2())
	{
		for (i = 0; i < 0xE; i++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
		for (j = 1; j < x_DWORD_181C04; j++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Result = 0x%X\n", result);
	}
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00093480) --------------------------------------------------------
int sub_93480_AIL_uninstall_DIG_driver(unsigned int *dig/*HDIGDRIVER dig*/)//AIL_uninstall_DIG_driver //274480
{
	int result; // eax
	bool v2; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v2 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v2)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_uninstall_DIG_driver(0x%X)\n", dig);
	result = sub_A37A0(dig);
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00093510) --------------------------------------------------------
HSAMPLE sub_93510_AIL_allocate_sample_handle(HDIGDRIVER dig/*HDIGDRIVER dig*/)//AIL_allocate_sample_handle //00274510
{
	int i; // [esp+0h] [ebp-10h]
	int j; // [esp+0h] [ebp-10h]
	bool v4; // [esp+4h] [ebp-Ch]
	HSAMPLE result; // [esp+Ch] [ebp-4h]

	x_DWORD_181C04++;
	v4 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v4)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_allocate_sample_handle(0x%X)\n", dig);
	result = sub_A3820_allocate_sample_handle(dig);
	if (x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2())
	{
		for (i = 0; i < 0xE; i++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
		for (j = 1; j < x_DWORD_181C04; j++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Result = 0x%X\n", result);
	}
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (000937A0) --------------------------------------------------------
int sub_937A0_AIL_release_sample_handle(int S/*HSAMPLE S*/)//AIL_release_sample_handle //2747a0
{
	int result; // eax
	bool v2; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v2 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v2)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_release_sample_handle(0x%X)\n", S);
	result = sub_A38C0_AIL_API_release_sample_handle(S);
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00093830) --------------------------------------------------------
void sub_93830_AIL_init_sample(HSAMPLE S/*HSAMPLE S*/)//AIL_init_sample //274830
{
	//int result; // eax
	bool v2; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v2 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v2)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_init_sample(0x%X)\n", (char)S);
	/*result = */sub_A38E0_init_sample(S);
	x_DWORD_181C04--;
	//return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (000938C0) --------------------------------------------------------
Bit32s sub_938C0_AIL_set_sample_file(HSAMPLE S/*HSAMPLE S*/, Bit8u* file_image/*void const FAR *file_image*/, Bit32s block/*S32 block*/)//AIL_set_sample_file //2748c0
{
	int i; // [esp+0h] [ebp-10h]
	int j; // [esp+0h] [ebp-10h]
	bool v6; // [esp+4h] [ebp-Ch]
	signed int result; // [esp+Ch] [ebp-4h]

	x_DWORD_181C04--;
	v6 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v6)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_set_sample_file(0x%X,0x%X,%d)\n", S, file_image, block);
	result = sub_A4B20_set_sample_file(S, file_image, block);
	if (x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2())
	{
		for (i = 0; i < 0xE; i++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
		for (j = 1; j < x_DWORD_181C04; j++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Result = %d\n", result);
	}
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00093A10) --------------------------------------------------------
void sub_93A10_AIL_set_sample_address(HSAMPLE S, Bit8u* start, Bit32u len)//AIL_set_sample_address //274a10
{
	//x_DWORD *result; // eax
	bool v4; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v4 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v4)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_set_sample_address(0x%X,0x%X,%u)\n", S, start, len);
	/*result = */sub_A3A30_set_sample_address(S, start, len);
	x_DWORD_181C04--;
	//return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00093AB0) --------------------------------------------------------
void sub_93AB0_AIL_set_sample_type(HSAMPLE S, Bit32s a2, Bit32u a3)//AIL_set_sample_type //274ab0
{
	//int result; // eax
	bool v4; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v4 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v4)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_set_sample_type(0x%X,%d,%u)\n", S, a2, a3);
	/*result = */sub_A3A70_set_sample_type(S, a2, a3);
	x_DWORD_181C04--;
	//return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00093B50) --------------------------------------------------------
void sub_93B50_AIL_start_sample(HSAMPLE S/*HSAMPLE S*/)//AIL_start_sample //274b50
{
	bool v2; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v2 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v2)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_start_sample(0x%X)\n", S);
	sub_A3CB0_API_AIL_start_sample(S);
	x_DWORD_181C04--;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00093D00) --------------------------------------------------------
void sub_93D00_AIL_end_sample(HSAMPLE S/*HSAMPLE S*/)//274d00 AIL_end_sample //274d00
{
	bool v2; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v2 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v2)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_end_sample(0x%X)\n", S);
	sub_A3DA0__API_AIL_end_sample(S);
	x_DWORD_181C04--;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00093D90) --------------------------------------------------------
void sub_93D90_AIL_set_sample_playback_rate(HSAMPLE S, Bit32s playback_rate)//AIL_set_sample_playback_rate //274d90
{
	bool v3; // [esp+0h] [ebp-4h]

	x_DWORD_181C04--;
	v3 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v3)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_set_sample_playback_rate(0x%X,%d)\n", S, playback_rate);
	sub_A3AF0_set_sample_playback_rate(S, playback_rate);
	x_DWORD_181C04--;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00093E30) --------------------------------------------------------
void sub_93E30_AIL_set_sample_volume(HSAMPLE S, Bit32s volume)//AIL_set_sample_volume //274e30
{
	bool v3; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v3 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v3)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_set_sample_volume(0x%X,%d)\n", S, volume);
	sub_A3B40_set_sample_volume(S, volume);
	x_DWORD_181C04--;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00093ED0) --------------------------------------------------------
void sub_93ED0_AIL_set_sample_volume_pan(HSAMPLE S, Bit32s volume)//AIL_set_sample_volume_pan //274ed0
{
	bool v3; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v3 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v3)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_set_sample_pan(0x%X,%d)\n", S, volume);
	sub_A3BB0_set_sample_volume_pan(S, volume);
	x_DWORD_181C04++;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00093F70) --------------------------------------------------------
void sub_93F70_AIL_set_sample_loop_count(HSAMPLE S/*HSAMPLE S*/, int loop_count/*S32 loop_count*/)//AIL_set_sample_loop_count //274f70
{
	bool v3; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v3 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v3)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_set_sample_loop_count(0x%X,%d)\n", S, loop_count);
	sub_A3C90_set_sample_loop_count(S, loop_count);
	x_DWORD_181C04--;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00094010) --------------------------------------------------------
Bit32u sub_94010_AIL_sample_status(HSAMPLE S)//AIL_sample_status
{
	int i; // [esp+0h] [ebp-10h]
	int j; // [esp+0h] [ebp-10h]
	bool v4; // [esp+4h] [ebp-Ch]
	Bit32u result; // [esp+Ch] [ebp-4h]

	x_DWORD_181C04++;
	v4 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v4)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_sample_status(0x%X)\n", S);
	result = sub_A3A00_sample_status(S);
	if (x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2())
	{
		for (i = 0; i < 0xE; i++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
		for (j = 1; j < x_DWORD_181C04; j++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Result = %u\n", result);
	}
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00094650) --------------------------------------------------------
void sub_94650_AIL_set_digital_master_volume(x_DWORD *a1, Bit32s master_volume)//AIL_set_digital_master_volume
{
	bool v3; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v3 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v3)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_set_digital_master_volume(0x%X,%d)\n", a1, master_volume);
	sub_A3F70_set_digital_master_volume(a1, master_volume);
	x_DWORD_181C04--;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00095140) --------------------------------------------------------
EOS_callback_type sub_95140_AIL_register_EOS_callback(HSAMPLE S/*HSAMPLE S*/, EOS_callback_type EOS/*AILSAMPLECB EOS*/)//AIL_register_EOS_callback
{
	int i; // [esp+0h] [ebp-10h]
	int j; // [esp+0h] [ebp-10h]
	bool v5; // [esp+4h] [ebp-Ch]
	EOS_callback_type result; // [esp+Ch] [ebp-4h]

	x_DWORD_181C04++;
	v5 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v5)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_register_EOS_callback(0x%X,0x%X)\n", S, EOS);
	result = sub_A3EB0_register_EOS_callback(S, EOS);
	if (x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2())
	{
		for (i = 0; i < 0xE; i++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
		for (j = 1; j < x_DWORD_181C04; j++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Result = 0x%X\n", result);
	}
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (000953E0) --------------------------------------------------------
void sub_953E0_AIL_set_sample_user_data(HSAMPLE S/*HSAMPLE S*/, int index/*U32     index*/, int value/* SINTa   value*/)//AIL_set_sample_user_data
{
	//int result; // eax
	bool v4; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v4 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v4)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_set_sample_user_data(0x%X,%u,%d)\n", S, index, value);
	/*result = */sub_A3F00_set_sample_user_data(S, index, value);
	x_DWORD_181C04--;
	//return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00095480) --------------------------------------------------------
int sub_95480_AIL_sample_user_data(HSAMPLE S/*HSAMPLE S*/, int index/*U32     index*/)//AIL_sample_user_data
{
	int i; // [esp+0h] [ebp-10h]
	int j; // [esp+0h] [ebp-10h]
	bool v5; // [esp+4h] [ebp-Ch]
	int result; // [esp+Ch] [ebp-4h]

	x_DWORD_181C04++;
	v5 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v5)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_sample_user_data(0x%X,%u)\n", S, index);
	result = sub_A3F30_sample_user_data(S, index);
	if (x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2())
	{
		for (i = 0; i < 0xE; i++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
		for (j = 1; j < x_DWORD_181C04; j++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Result = %d\n", result);
	}
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00095710) --------------------------------------------------------
Bit32s sub_95710_AIL_install_MDI_INI(/*int a1,*/ HMDIDRIVER *mdi)//HMDIDRIVER *mdi AIL_install_MDI_INI //276710
{
	int i; // [esp+0h] [ebp-10h]
	int j; // [esp+0h] [ebp-10h]
	bool v5; // [esp+4h] [ebp-Ch]
	int result; // [esp+Ch] [ebp-4h]

	x_DWORD_181C04++;
	v5 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v5)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_install_MDI_INI(0x%X)\n", mdi);
	result = sub_A78F0_AIL_API_install_MDI_INI(/*a1,*/ mdi);
	if (x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2())
	{
		for (i = 0; i < 0xE; i++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
		for (j = 1; j < x_DWORD_181C04; j++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Result = %d\n", result);
	}
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00095850) --------------------------------------------------------
HMDIDRIVER sub_95850_AIL_install_MDI_driver_file(char* filename, IO_PARMS *IO)//HMDIDRIVER *mdi AIL_install_MDI_driver_file //276850
{
	int i; // [esp+0h] [ebp-10h]
	int j; // [esp+0h] [ebp-10h]
	bool v6; // [esp+4h] [ebp-Ch]
	HMDIDRIVER result; // [esp+Ch] [ebp-4h]

	x_DWORD_181C04++;
	v6 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v6)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_install_MDI_driver_file(%s,0x%X)\n", filename, IO);
	result = sub_A77D0_AIL_API_install_MDI_INI(filename, IO);
	if (x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2())
	{
		for (i = 0; i < 0xE; i++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
		for (j = 1; j < x_DWORD_181C04; j++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Result = 0x%X\n", result);
	}
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (000959A0) --------------------------------------------------------
int sub_959A0_AIL_uninstall_MDI_driver(HMDIDRIVER mdi/*HMDIDRIVER  mdi*/)//AIL_uninstall_MDI_driver
{
	int result; // eax
	bool v2; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v2 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v2)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_uninstall_MDI_driver(0x%X)\n", mdi);
	result = sub_A7970_AIL_API_uninstall_MDI_driver(mdi);
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00095A30) --------------------------------------------------------
HSEQUENCE sub_95A30_AIL_allocate_sequence_handle(HMDIDRIVER mdi)//AIL_allocate_sequence_handle
{
	int i; // [esp+0h] [ebp-10h]
	int j; // [esp+0h] [ebp-10h]
	bool v4; // [esp+4h] [ebp-Ch]
	HSEQUENCE result; // [esp+Ch] [ebp-4h]

	x_DWORD_181C04++;
	v4 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v4)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_allocate_sequence_handle(0x%X)\n", mdi);
	result = sub_A7B30_AIL_API_allocate_sequence_handle(mdi);
	if (x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2())
	{
		for (i = 0; i < 0xE; i++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
		for (j = 1; j < x_DWORD_181C04; j++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Result = 0x%X\n", result);
	}
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00095C00) --------------------------------------------------------
Bit32s sub_95C00_AIL_init_sequence(HSEQUENCE S, Bit8u* start, Bit32s sequence_num, Bit32u track)//AIL_init_sequence
{
	int i; // [esp+0h] [ebp-10h]
	int j; // [esp+0h] [ebp-10h]
	bool v6; // [esp+4h] [ebp-Ch]
	int result; // [esp+Ch] [ebp-4h]

	x_DWORD_181C04++;
	v6 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v6)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_init_sequence(0x%X,0x%X,%d)\n", S, start, sequence_num);
	result = sub_A7C20_AIL_API_init_sequence(S, start, sequence_num, track);
	if (x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2())
	{
		for (i = 0; i < 0xE; i++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
		for (j = 1; j < x_DWORD_181C04; j++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Result = %d\n", result);
	}
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00095D50) --------------------------------------------------------
void sub_95D50_AIL_start_sequence(HSEQUENCE S/*HSEQUENCE S*/, Bit32u track)//AIL_start_sequence
{
	//int *result; // eax
	bool v2; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v2 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v2)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_start_sequence(0x%X)\n", S);
	/*result = */sub_A8010_AIL_API_start_sequence(S, track);
	x_DWORD_181C04--;
	//return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00095DE0) --------------------------------------------------------
void sub_95DE0_AIL_stop_sequence(HSEQUENCE S/*HSEQUENCE S*/)//AIL_stop_sequence
{
	//int result; // eax
	bool v2; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v2 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v2)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_stop_sequence(0x%X)\n", S);
	/*result = */sub_A8050_AIL_API_stop_sequence(S);
	x_DWORD_181C04--;
	//return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00095E70) --------------------------------------------------------
void sub_95E70_AIL_resume_sequence(HSEQUENCE S)//AIL_resume_sequence
{
	bool v1; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v1 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v1)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_resume_sequence(0x%X)\n", S);
	sub_A8180_AIL_API_resume_sequence(S);
	x_DWORD_181C04--;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00095F00) --------------------------------------------------------
void sub_95F00_AIL_end_sequence(HSEQUENCE S/*HSEQUENCE S*/)//AIL_end_sequence
{
	//int result; // eax
	bool v2; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v2 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v2)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_end_sequence(0x%X)\n", S);
	/*result = */sub_A8250_AIL_API_end_sequence(S);
	x_DWORD_181C04--;
	//return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00096030) --------------------------------------------------------
void sub_96030_AIL_set_sequence_volume(HSEQUENCE S, Bit32s volume, Bit32s milliseconds)//AIL_set_sequence_volume
{
	bool v3; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v3 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v3)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_set_sequence_volume(0x%X,%d,%d)\n", S, volume, milliseconds);
	sub_A8360_AIL_API_set_sequence_volume(S, volume, milliseconds);
	x_DWORD_181C04--;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00096170) --------------------------------------------------------
int sub_96170_AIL_sequence_status(HSEQUENCE S/*HSEQUENCE S*/)//AIL_sequence_status
{
	int i; // [esp+0h] [ebp-10h]
	int j; // [esp+0h] [ebp-10h]
	bool v4; // [esp+4h] [ebp-Ch]
	int result; // [esp+Ch] [ebp-4h]

	x_DWORD_181C04++;
	v4 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v4)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_sequence_status(0x%X)\n", S);
	result = sub_A8410_AIL_API_sequence_status(S);
	if (x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2())
	{
		for (i = 0; i < 0xE; i++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
		for (j = 1; j < x_DWORD_181C04; j++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Result = %u\n", result);
	}
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00096670) --------------------------------------------------------
void sub_96670_AIL_set_XMIDI_master_volume(HMDIDRIVER mdi, Bit32s master_volume)//AIL_set_XMIDI_master_volume
{
	x_DWORD_181C04++;
	if (x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24())
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_set_XMIDI_master_volume(0x%X,%d)\n", mdi, master_volume);
	sub_A84D0_AIL_API_set_XMIDI_master_volume(mdi, master_volume);
	x_DWORD_181C04--;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (000969A0) --------------------------------------------------------
Bit32s sub_969A0_AIL_MDI_driver_type(HMDIDRIVER mdi)//AIL_MDI_driver_type
{
	int i; // [esp+0h] [ebp-10h]
	int j; // [esp+0h] [ebp-10h]
	bool v4; // [esp+4h] [ebp-Ch]
	signed int result; // [esp+Ch] [ebp-4h]

	x_DWORD_181C04++;
	v4 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v4)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_MDI_driver_type(0x%X)\n", mdi);
	result = sub_A7990_AIL_API_MDI_driver_type(mdi);
	if (x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2())
	{
		for (i = 0; i < 0xE; i++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
		for (j = 1; j < x_DWORD_181C04; j++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Result = %d\n", result);
	}
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00096AE0) --------------------------------------------------------
void sub_96AE0_AIL_set_GTL_filename_prefix(Bit8u* prefix/*char const *prefix*/)//AIL_set_GTL_filename_prefix
{
	//int result; // eax
	bool v2; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v2 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v2)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_set_GTL_filename_prefix(%s)\n", prefix);
	sub_A7AA0_AIL_API_set_GTL_filename_prefix(prefix);
	x_DWORD_181C04--;
	//return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00097330) --------------------------------------------------------
int sub_97330_AIL_sequence_position(x_DWORD *S/*HSEQUENCE S*/, x_DWORD *beat/*FAR *beat*/, x_DWORD *measure/*FAR *measure*/)//AIL_sequence_position
{
	int result; // eax
	int i; // [esp+0h] [ebp-8h]
	int j; // [esp+0h] [ebp-8h]
	bool v6; // [esp+4h] [ebp-4h]

	x_DWORD_181C04++;
	v6 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v6)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_sequence_position(0x%X,0x%X,0x%X)\n", S, beat, measure);
	result = sub_A8830(S, beat, measure);
	if (x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8))
	{
		result = sub_A16A2();
		if (!result)
		{
			for (i = 0; i < 0xE; i++)
				dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
			for (j = 1; j < x_DWORD_181C04; j++)
				dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
			/*result = */dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Result = %d:%d\n", *measure + 1, *beat + 1);
		}
	}
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00097480) --------------------------------------------------------
x_DWORD *sub_97480_AIL_branch_index(HSEQUENCE S/*HSEQUENCE S*/, int marker/*U32 marker*/)//AIL_branch_index
{
	x_DWORD *result; // eax
	bool v3; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v3 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v3)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_branch_index(0x%X,%u)\n", S, marker);
	result = sub_A8900(S, marker);
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00097670) --------------------------------------------------------
xCALLBACK sub_97670_AIL_register_trigger_callback(HSEQUENCE S/*HSEQUENCE S*/, xCALLBACK callback/*AILTRIGGERCB   callback*/)//AIL_register_trigger_callback
{
	int i; // [esp+0h] [ebp-10h]
	int j; // [esp+0h] [ebp-10h]
	bool v5; // [esp+4h] [ebp-Ch]
	xCALLBACK result; // [esp+Ch] [ebp-4h]

	x_DWORD_181C04++;
	v5 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v5)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_register_trigger_callback(0x%X,0x%X)\n", S, callback);
	result = sub_A8A20_AIL_API_trigger_callback(S, callback);
	if (x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2())
	{
		for (i = 0; i < 0xE; i++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
		for (j = 1; j < x_DWORD_181C04; j++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Result = 0x%X\n", result);
	}
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00097A60) --------------------------------------------------------
int sub_97A60_AIL_register_event_callback(int mdi/*HMDIDRIVER mdi*/, int callback/*AILEVENTCB callback*/)//AIL_register_event_callback
{
	int i; // [esp+0h] [ebp-10h]
	int j; // [esp+0h] [ebp-10h]
	bool v5; // [esp+4h] [ebp-Ch]
	int v6; // [esp+Ch] [ebp-4h]

	x_DWORD_181C04++;
	v5 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v5)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_register_event_callback(0x%X,0x%X)\n", mdi, callback);
	v6 = sub_A8AE0(mdi, callback);
	if (x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2())
	{
		for (i = 0; i < 0xE; i++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
		for (j = 1; j < x_DWORD_181C04; j++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Result = 0x%X\n", v6);
	}
	x_DWORD_181C04--;
	return v6;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00097BB0) --------------------------------------------------------
int sub_97BB0_AIL_register_timbre_callback(int mdi/*HMDIDRIVER mdi*/, int callback/*AILTIMBRECB callback*/)//AIL_register_timbre_callback
{
	int i; // [esp+0h] [ebp-10h]
	int j; // [esp+0h] [ebp-10h]
	bool v5; // [esp+4h] [ebp-Ch]
	int result; // [esp+Ch] [ebp-4h]

	x_DWORD_181C04++;
	v5 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v5)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_register_timbre_callback(0x%X,0x%X)\n", mdi, callback);
	result = sub_A8B20(mdi, callback);
	if (x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2())
	{
		for (i = 0; i < 0xE; i++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
		for (j = 1; j < x_DWORD_181C04; j++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Result = 0x%X\n", result);
	}
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00097F90) --------------------------------------------------------
int sub_97F90_AIL_lock_channel(x_DWORD *mdi/*HMDIDRIVER mdi*/)//AIL_lock_channel
{
	int i; // [esp+0h] [ebp-10h]
	int j; // [esp+0h] [ebp-10h]
	bool v4; // [esp+4h] [ebp-Ch]
	int result; // [esp+Ch] [ebp-4h]

	x_DWORD_181C04--;
	v4 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v4)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_lock_channel(0x%X)\n", mdi);
	result = sub_A8BF0(mdi);
	if (x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2())
	{
		for (i = 0; i < 0xE; i++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D226C);
		for (j = 1; j < x_DWORD_181C04; j++)
			dbgfprintf(x_DWORD_181BF0_AIL_debugfile, (const char *)&unk_D2270);
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "Result = %d\n", result);
	}
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (000980D0) --------------------------------------------------------
int sub_980D0_AIL_release_channel(x_DWORD *mdi/*HMDIDRIVER mdi*/, int channel/*S32 channel*/)//AIL_release_channel
{
	int result; // eax
	bool v3; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v3 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v3)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_release_channel(0x%X,%d)\n", mdi, channel);
	result = sub_A8EA0(mdi, channel);
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00098170) --------------------------------------------------------
int sub_98170_AIL_map_sequence_channel(x_DWORD *S/*HSEQUENCE S*/, int seq_channel/*S32 seq_channel*/, int new_channel/*S32 new_channel*/)//AIL_map_sequence_channel
{
	int result; // eax
	bool v4; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v4 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v4)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_map_sequence_channel(0x%X,%d,%d)\n", S, seq_channel, new_channel);
	result = sub_A9080(S, seq_channel, new_channel);
	x_DWORD_181C04--;
	return result;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (00098360) --------------------------------------------------------
void sub_98360_AIL_send_channel_voice_message(HMDIDRIVER mdi, HSEQUENCE S, Bit32s status, Bit32s data_1, Bit32s data_2)//AIL_send_channel_voice_message // 279360
{
	bool v6; // [esp+0h] [ebp-4h]

	x_DWORD_181C04++;
	v6 = x_DWORD_181BF4 && (x_DWORD_181C04 == 1 || x_DWORD_181BF8) && !sub_A16A2() && sub_916F0_sound_proc24();
	if (v6)
		dbgfprintf(x_DWORD_181BF0_AIL_debugfile, "AIL_send_channel_voice_message(0x%X,0x%X,0x%X,0x%X,0x%X)\n", mdi, S, status, data_1, data_2);
	sub_A9140_AIL_API_send_channel_voice_message(mdi, S, status, data_1, data_2);
	x_DWORD_181C04--;
}
// A18E3: using guessed type x_DWORD fprintf(x_DWORD, const char *, ...);
// 181BF0: using guessed type int x_DWORD_181BF0_AIL_debugfile;
// 181BF4: using guessed type int x_DWORD_181BF4;
// 181BF8: using guessed type int x_DWORD_181BF8;
// 181C04: using guessed type int x_DWORD_181C04;

//----- (000986A0) --------------------------------------------------------
bool sub_986A0_unlock_linear_region()
{
	bool result; // eax

	if (x_DWORD_E39BC)
	{
		result = sub_9D650((unsigned int)sub_915A0_sound_proc23, (unsigned int)sub_986A0_unlock_linear_region);
		x_DWORD_E39BC = 0;
	}
	return result;
}
// E39BC: using guessed type int x_DWORD_E39BC;

//----- (000986E0) --------------------------------------------------------
void sub_986E0()
{
	sub_99C90();
	sub_99C10_sound_proc4();
	if (x_BYTE_E39B8)
		sub_91420();
}
// E39B8: using guessed type char x_BYTE_E39B8;

//----- (00098709) --------------------------------------------------------
void sub_98709_create_index_dattab_power(Bit8u* tabbuffer, Bit8u* tabbufferend, Bit8u* datbuffer, posistruct* dattabindex)
{
	Bit32u testadr = *(Bit32u*)tabbuffer;
	if (testadr == 0x9999)
	{
		for (Bit32u i = 0;i < (tabbufferend - tabbuffer) / 6;i++)
		{
			dattabindex[i].pointer += (Bit32s)datbuffer;
			dattabindex[i].sizex *= 2;
			dattabindex[i].sizey *= 2;
		}
	}
	else
	{
		for (Bit32u i = 0;i < (tabbufferend - tabbuffer) / 6;i++)
		{
			dattabindex[i].pointer = (Bit8u*)(*(Bit32u*)(tabbuffer + 6 * i)) + (Bit32s)datbuffer;
			dattabindex[i].sizex = tabbuffer[6 * i + 4] * 2;
			dattabindex[i].sizey = tabbuffer[6 * i + 5] * 2;
		}
		testadr = 0x9999;
		memcpy(tabbuffer, &testadr, 4);
	}
}

//----- (0009874D) --------------------------------------------------------
void sub_9874D_create_index_dattab(Bit8u* tabbuffer, Bit8u* tabbufferend, Bit8u* datbuffer, posistruct* dattabindex)//27974d
{
	Bit32u testadr = *(Bit32u*)tabbuffer;
	if (testadr == 0x9999)
	{
		for (Bit32u i = 0;i < (tabbufferend - tabbuffer) / 6;i++)
		{
			dattabindex[i].pointer += (Bit32s)datbuffer;
		}
	}
	else
	{
		for (Bit32u i = 0;i < (tabbufferend - tabbuffer) / 6;i++)
		{
			dattabindex[i].pointer = (Bit8u*)(*(Bit32u*)(tabbuffer + 6 * i)) + (Bit32s)datbuffer;
			dattabindex[i].sizex = tabbuffer[6 * i + 4];
			dattabindex[i].sizey = tabbuffer[6 * i + 5];
		}
		testadr = 0x9999;
		memcpy(tabbuffer, &testadr, 4);
	}
}

//----- (00099A77) --------------------------------------------------------
void sub_99A77_create_index_dattab_div(Bit8u* tabbuffer, Bit8u* tabbufferend, Bit8u* datbuffer, posistruct* dattabindex)//280a77
{
	Bit32u testadr = *(Bit32u*)tabbuffer;
	if (testadr == 0x9999)
	{
		for (Bit32u i = 0;i < (tabbufferend - tabbuffer) / 6;i++)
		{
			dattabindex[i].pointer -= (Bit32s)datbuffer;
			dattabindex[i].sizex /= 2;
			dattabindex[i].sizey /= 2;
		}
	}
	else
	{
		for (Bit32u i = 0;i < (tabbufferend - tabbuffer) / 6;i++)
		{
			dattabindex[i].pointer = (Bit8u*)(*(Bit32u*)(tabbuffer + 6 * i)) - (Bit32s)datbuffer;
			dattabindex[i].sizex = tabbuffer[6 * i + 4] / 2;
			dattabindex[i].sizey = tabbuffer[6 * i + 5] / 2;
		}
		testadr = 0x9999;
		memcpy(tabbuffer, &testadr, 4);
	}
}

//----- (00099AEB) --------------------------------------------------------
void sub_99AEB_create_index_dattab_minus(Bit8u* tabbuffer, Bit8u* tabbufferend, Bit8u* datbuffer, posistruct* dattabindex)//280aeb
{
	Bit32u testadr = *(Bit32u*)tabbuffer;
	if (testadr == 0x9999)
	{
		for (Bit32u i = 0;i < (tabbufferend - tabbuffer) / 6;i++)
		{
			dattabindex[i].pointer -= (Bit32s)datbuffer;
		}
	}
	else
	{
		for (Bit32u i = 0;i < (tabbufferend - tabbuffer) / 6;i++)
		{
			dattabindex[i].pointer = (Bit8u*)(*(Bit32u*)(tabbuffer + 6 * i)) - (Bit32s)datbuffer;
			dattabindex[i].sizex = tabbuffer[6 * i + 4];
			dattabindex[i].sizey = tabbuffer[6 * i + 5];
		}
		testadr = 0x9999;
		memcpy(tabbuffer, &testadr, 4);
	}
}



//----- (00098790) --------------------------------------------------------
void sub_98790(unsigned __int16 a1, unsigned __int8 a2)//279790
{
	if (x_BYTE_E37FC && x_BYTE_E37FD && x_WORD_E3802 && a2 <= 0x7Fu && sub_96170_AIL_sequence_status(x_DWORD_180C78) != 2)
		sub_96030_AIL_set_sequence_volume(x_DWORD_180C78, a2, a1);
}
// E37FC: using guessed type char x_BYTE_E37FC;
// E37FD: using guessed type char x_BYTE_E37FD;
// E3802: using guessed type __int16 x_WORD_E3802;
// 180C78: using guessed type int x_DWORD_180C78;

//----- (00098817) --------------------------------------------------------
FILE* sub_98817_open(char* pathname, int __pmode)//279817
{
	FILE* v2; // ST10_4


	if (__pmode == 0x222)
	{
		v2 = x_creat(pathname, 0x1c0);
		x_setmode(v2, 0x200);
		x_close(v2);
	}
	return x_sopen(pathname, __pmode, 0x40);
}
// A0855: using guessed type x_DWORD close(x_DWORD);
// AA6DD: using guessed type x_DWORD creat(x_DWORD, x_DWORD);
// AA6F4: using guessed type x_DWORD setmode(x_DWORD, x_DWORD);

//----- (00098882) --------------------------------------------------------
int sub_98882_close(FILE* a1)//279882
{
	return x_close(a1);
}
// A0855: using guessed type x_DWORD close(x_DWORD);

//----- (000988A7) --------------------------------------------------------
size_t sub_988A7_read(FILE* a1, Bit8u* a2, int a3)//2798a7
{

	return x_read(a1, (Bit8u*)a2, a3);
}
// A0863: using guessed type x_DWORD read(x_DWORD, x_DWORD, x_DWORD);

//----- (0009891E) --------------------------------------------------------
int sub_9891E_seek(FILE* filedecs, int position, char type)//27991e
{
	return x_lseek(filedecs, position, type);
}
// AA7C0: using guessed type x_DWORD lseek(x_DWORD, x_DWORD, char);





//----- (00098AE9) --------------------------------------------------------
__int16 sub_98AE9(__int16 *a1, int a2)//279ae9
{
	int v2; // edx
	__int16 *v3; // esi
	__int16 *v4; // et0
	__int16 v5; // ax
	__int16 *v6; // esi
	__int16 v7; // bx
	__int16 v8; // ax
	__int16 v9; // cx
	int v10; // esi
	__int16 result; // ax
	unsigned __int8 v12; // cl
	__int16 v13; // ax
	char v14; // cl

	//fix it
	v12 = 0;
	v14 = 0;
	//fix it

	v4 = a1;
	v2 = a2;
	v3 = v4;
	do
	{
		v5 = *v3;
		v6 = v3 + 1;
		v7 = x_WORD_E3B4C & v5;
		v8 = *v6;
		v3 = v6 + 1;
	} while (v8 != v7);
	v9 = v3[30];
	v10 = v2;
	result = sub_98B2C(HIBYTE(v9), v2);
	if (v12 >= 2u)
	{
		v13 = sub_98B2C(v12 - 1, v10);
		result = (1 << v14) | v13;
	}
	return result;
}
// E3B4C: using guessed type __int16 x_WORD_E3B4C;

//----- (00098B2C) --------------------------------------------------------
__int16 sub_98B2C(unsigned __int8 a1, int a2)//180804 279b2c
{
	unsigned __int8 v2; // cl
	unsigned __int16 v3; // ax
	unsigned __int16 v4; // bx
	char v5; // ch
	__int16 v7; // [esp-4h] [ebp-4h]

	v2 = a1;//mov cl,al
	v3 = x_WORD_E3B4E;//ma byt 02, ale je 0//ax
	v4 = x_WORD_E3B4C;//ma byt 10bc, ale je 0//bx //push
	v7 = v4 & ((1 << v2) - 1);
	v5 = x_BYTE_E3B51 - v2;//je nula//ch-cl
	if (x_BYTE_E3B51 < v2)
	{
		v4 = __ROR2__(x_WORD_E3B4E & ((1 << x_BYTE_E3B51) - 1), x_BYTE_E3B51) |
			((unsigned __int16)x_WORD_E3B4C >> x_BYTE_E3B51);
		v3 = *(x_WORD *)(a2 + 2);
		v2 -= x_BYTE_E3B51;
		v5 = 16 - v2;
	}
	x_WORD_E3B4E = v3 >> v2;
	x_WORD_E3B4C = __ROR2__(v3 & ((1 << v2) - 1), v2) | (v4 >> v2);
	x_BYTE_E3B51 = v5;
	return v7;
}
// E3B4C: using guessed type __int16 x_WORD_E3B4C;
// E3B4E: using guessed type __int16 x_WORD_E3B4E;
// E3B51: using guessed type char x_BYTE_E3B51;

//----- (00098BAF) --------------------------------------------------------
char sub_98BAF_read_huftable(int a1)
{
	int *v1; // edi
	Bit16u v2; // ax
	int v3; // ecx
	int v4; // ecx
	int *v5; // esi
	x_WORD *v6; // edi
	unsigned __int16 v7; // bx
	unsigned __int16 v8; // dx
	x_WORD *v9; // edi
	__int16 v10; // bx
	unsigned __int8 v11; // cf
	__int16 v12; // ax
	unsigned __int8 v13; // tt
	unsigned __int8 v14; // tt
	__int16 v15; // ax
	__int16 v17; // [esp-24h] [ebp-28h]
	unsigned __int16 v18; // [esp-22h] [ebp-26h]
	unsigned __int16 v19; // [esp-20h] [ebp-24h]
	int *v20; // [esp-1Eh] [ebp-22h]
	__int16 v21; // [esp-1Ah] [ebp-1Eh]
	int v22; // [esp-18h] [ebp-1Ch]
	int v23; // [esp-14h] [ebp-18h]
	x_WORD *v24; // [esp-4h] [ebp-8h]

	//fix it
	v3 = 0;
	v24 = 0;

	//Bit16u ssedi[100];
	Bit32u ssedi = 0;
	//fix it

	v1 = &v23;
	v2 = sub_98B2C(5u, a1);
	if (v2)
	{
		v22 = v2;
		do
		{
			v2 = sub_98B2C(4u, a1);
			v1[ssedi++] = v2;
			/*
			*(x_BYTE *)v1 = v2;
			v1 = (int *)((char *)v1 + 1);*/
		} while (v3 != 1);
		v4 = v22;
		v22 = a1;
		v5 = &v23;
		v6 = v24;
		LOBYTE(v2) = 1;
		v7 = 0;
		v8 = -32768;
		do
		{
			v21 = v4;
			v20 = v5;
			do
			{
				if ((x_BYTE)v2 == *(x_BYTE *)v5)
				{
					v19 = v2;
					v18 = v7;
					v17 = v4;
					*v6 = (1 << v2) - 1;
					v9 = v6 + 1;
					v10 = v7 >> (16 - v2);
					LOBYTE(v4) = v2;
					v12 = 0;
					v11 = 0;
					do
					{
						v13 = __CFRCR__(v10, v11);
						v10 = __RCR__(v10, v11);
						v11 = v13;
						v14 = __CFRCL__(v12, v13);
						v12 = __RCL__(v12, v11);
						v11 = v14;
						--v4;
					} while (v4);
					*v9 = v12;
					v6 = v9 + 1;
					LOBYTE(v15) = (char *)v5 - (char *)&v17 - 16;
					HIBYTE(v15) = *(x_BYTE *)v5;
					v6[30] = v15;
					LOWORD(v4) = v17;
					v2 = v19;
					v7 = v8 + v18;
				}
				v5 = (int *)((char *)v5 + 1);
				--v4;
			} while (v4);
			v5 = v20;
			LOWORD(v4) = v21;
			v8 >>= 1;
			LOBYTE(v2) = v2 + 1;
		} while ((x_BYTE)v2 != 17);
	}
	return v2;
}

//----- (00098C48) --------------------------------------------------------
signed int sub_98C48_open_nwrite_close(char* filename, Bit8u* buffer, Bit32u count)
{
	int result; // ST14_4
	FILE* file; // [esp+4h] [ebp-8h]

	file = sub_98817_open(filename, 546);
	if (file == NULL)
		return -1;//mozna null
	result = sub_98CAA_write(file, buffer, count);
	sub_98882_close(file);
	return result;
}

//----- (00098CAA) --------------------------------------------------------
size_t sub_98CAA_write(FILE* a1, Bit8u* a2, Bit32u a3)
{
	return x_write(a1, a2, a3);
}
// AA80B: using guessed type x_DWORD write(x_DWORD, x_DWORD, x_DWORD);

//----- (00098FF5) --------------------------------------------------------
/*int sub_98FF5_atoi(char *a1)
{
  char *i; // eax
  char v2; // cl
  int v3; // ebx
  int v4; // ebx

  for ( i = a1; IsTable[(unsigned __int8)(*i + 1)] & 2; i++ )
	;
  v2 = i[0];
  if ( i[0] == 43 || v2 == 45 )
	++i;
  v3 = 0;
  while ( IsTable[(unsigned __int8)(*i + 1)] & 0x20 )
  {
	v4 = (unsigned __int8)*i++ + 10 * v3;
	v3 = v4 - 48;
  }
  if ( v2 == 45 )
	v3 = -v3;
  return v3;
}*/

//----- (00099080) --------------------------------------------------------
/*void sub_99080(char a1)
{
  x_BYTE_E379B = a1 != 0;
}*/
// E379B: using guessed type char x_BYTE_E379B;

//----- (0009937E) --------------------------------------------------------
int sub_9937E_set_video_mode(__int16 a1)
{
	/*int result; // eax
	int v2; // [esp+0h] [ebp-78h]
	int v3; // [esp+18h] [ebp-60h]
	int v4; // [esp+1Ch] [ebp-5Ch]
	__int16 v5; // [esp+22h] [ebp-56h]
	__int16 v6; // [esp+24h] [ebp-54h]
	char v7; // [esp+34h] [ebp-44h]
	int v8; // [esp+50h] [ebp-28h]
	int v9; // [esp+54h] [ebp-24h]
	int *v10; // [esp+64h] [ebp-14h]
	char v11; // [esp+6Ch] [ebp-Ch]

	memset(&v2, 0, 50);
	v5 = (unsigned int)x_DWORD_181C40_vga_init_buffer >> 4;
	v6 = (unsigned int)x_DWORD_181C40_vga_init_buffer >> 4;
	v2 = 0;
	v4 = 20225;
	v3 = a1;
	memset(&v8, 0, 28);
	memset(&v7, 0, 28);
	memset(&v11, 0, 12);
	segread((SREGS*)&v11);
	v8 = 0x300;
	v9 = 0x10;
	v10 = &v2;
	int386x(0x31, (REGS*)&v8, (REGS*)&v7, (SREGS*)&v11);//Set video mode
	x_WORD_181C44 = *(unsigned __int8 *)(x_DWORD_181C40_vga_init_buffer + 4) + (*(unsigned __int8 *)(x_DWORD_181C40_vga_init_buffer + 5) << 8);
	x_WORD_E3BA6 = *(unsigned __int8 *)(x_DWORD_181C40_vga_init_buffer + 16) + (*(unsigned __int8 *)(x_DWORD_181C40_vga_init_buffer + 17) << 8);
	x_WORD_E3BA8 = *(unsigned __int8 *)(x_DWORD_181C40_vga_init_buffer + 18) + (*(unsigned __int8 *)(x_DWORD_181C40_vga_init_buffer + 19) << 8);
	HIWORD(result) = HIWORD(x_DWORD_181C40_vga_init_buffer);
	LOWORD(result) = *(unsigned __int8 *)(x_DWORD_181C40_vga_init_buffer + 20);
	x_WORD_E3BAA = (unsigned __int8)result + (*(unsigned __int8 *)(x_DWORD_181C40_vga_init_buffer + 21) << 8);
	return result;*/
	return 0;//fix it
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 99DE6: using guessed type x_DWORD segread(x_DWORD);
// 99E10: using guessed type x_DWORD int386x(x_DWORD, x_DWORD, x_DWORD, x_DWORD);
// E3BA6: using guessed type __int16 x_WORD_E3BA6;
// E3BA8: using guessed type __int16 x_WORD_E3BA8;
// E3BAA: using guessed type __int16 x_WORD_E3BAA;
// 181C40: using guessed type int x_DWORD_181C40_vga_init_buffer;
// 181C44: using guessed type __int16 x_WORD_181C44;

//----- (000994BA) --------------------------------------------------------
int sub_994BA_cursor_move(__int16 a1)
{
	/*char v2; // [esp+0h] [ebp-38h]
	char v3; // [esp+1Ch] [ebp-1Ch]
	char v4; // [esp+1Dh] [ebp-1Bh]
	__int16 v5; // [esp+20h] [ebp-18h]

	memset(&v3, 0, 28);
	memset(&v2, 0, 28);
	v4 = 0x4f;
	v3 = 2;
	v5 = a1;
	int386(0x10, (REGS*)&v3, (REGS*)&v2);//Set cursor position
	return sub_9937E_set_video_mode(a1);
	*/
	return 0;//fix it
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);

//----- (0009951B) --------------------------------------------------------
signed int sub_9951B(__int16 a1)//fix graphics
{
	signed int result; // eax

	x_WORD_E3BA4 = a1;
	if (a1 > 5 || a1 < 0)
	{
		/*__outx_BYTE(0x3C8u, 0);
		__outx_BYTE(0x3C9u, 0x3Fu);
		__outx_BYTE(0x3C9u, 0);
		__outx_BYTE(0x3C9u, 0);*/
	}
	//fix it:__asm { int     10h; - VIDEO - VESA SuperVGA BIOS -  VESA SuperVGA BIOS - CPU VIDEO MEMORY CONTROL }
	result = 20229;
	//fix it:__asm { int     10h; - VIDEO - VESA SuperVGA BIOS -  VESA SuperVGA BIOS - CPU VIDEO MEMORY CONTROL }
	return result;
}
// E3BA4: using guessed type __int16 x_WORD_E3BA4;
// 181C40: using guessed type int x_DWORD_181C40_vga_init_buffer;

//----- (000995B0) --------------------------------------------------------
int sub_995B0_test_vga_driver() //27A5B0
{

	//int v1; // [esp+0h] [ebp-7Ch]
	//int v2; // [esp+10h] [ebp-6Ch]
	//int v3; // [esp+1Ch] [ebp-60h]
	/*__int16 v4; // [esp+22h] [ebp-5Ah]
	__int16 v5; // [esp+24h] [ebp-58h]
	int v6; // [esp+34h] [ebp-48h]
	int v7; // [esp+38h] [ebp-44h]
	int *v8; // [esp+48h] [ebp-34h]
	char v9; // [esp+50h] [ebp-2Ch]
	char v10; // [esp+6Ch] [ebp-10h]

	memset(&v1, 0, 50);//3551A8
	v4 = (unsigned int)x_DWORD_181C40_vga_init_buffer >> 4;//2C03
	v5 = (unsigned int)x_DWORD_181C40_vga_init_buffer >> 4;//2C03

	//ebp-7c=0 //dword
	//ebp-60=4f//dword
	//ebp-6c=1//dword
	//v1 = 0;
	//v3 = 20224;
	//v2 = 257;
	memset(&v6, 0, 28);//3551dc
	memset(&v9, 0, 28);//3551f8
	memset(&v10, 0, 12);//355214
	segread((SREGS*)&v10);
	v6 = 0x300;
	v7 = 0x10;
	v8 = &v1;
	int386x(0x31, (REGS*)&v6, (REGS*)&v9, (SREGS*)&v10);//?video*/
	//fix! initialize video

	for (int i = 0;i < 20;i++)x_DWORD_181C40_vga_init_buffer[i] = 0x0;//fixed
	memcpy((char*)x_DWORD_181C40_vga_init_buffer, "VESA\0", 5);//fixed
	x_DWORD_181C40_vga_init_buffer[5] = 0x02;//fixed
	x_DWORD_181C40_vga_init_buffer[6] = 0x67;//fixed
	x_DWORD_181C40_vga_init_buffer[7] = 0x2f;//fixed
	x_DWORD_181C40_vga_init_buffer[9] = 0xc0;//fixed
	x_DWORD_181C40_vga_init_buffer[14] = 0xab;//fixed
	x_DWORD_181C40_vga_init_buffer[15] = 0x2e;//fixed
	x_DWORD_181C40_vga_init_buffer[17] = 0xc0;//fixed
	x_DWORD_181C40_vga_init_buffer[18] = 0x20;//fixed

	return strncmp((char*)x_DWORD_181C40_vga_init_buffer, "VESA", 4);
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 99682: using guessed type x_DWORD strncmp(x_DWORD, x_DWORD, x_DWORD);
// 99DE6: using guessed type x_DWORD segread(x_DWORD);
// 99E10: using guessed type x_DWORD int386x(x_DWORD, x_DWORD, x_DWORD, x_DWORD);
// 181C40: using guessed type int x_DWORD_181C40_vga_init_buffer;

//----- (00099970) --------------------------------------------------------
void sub_99970(char a1, unsigned __int8 a2)
{
	if (x_BYTE_E3819 && x_BYTE_E37FC && x_BYTE_E37FD && x_WORD_E3802 && sub_96170_AIL_sequence_status(x_DWORD_180C78) != 2 && x_BYTE_E3817 != a1)
	{
		if (x_BYTE_E3818)
			sub_92DC0_AIL_release_timer_handle(x_DWORD_180C80);
		x_BYTE_E3817 = a1;
		x_BYTE_E381A = -x_BYTE_E381A;
		x_BYTE_E3818 = 1;
		if (a2 <= 4u && a2 >= 1u)
		{
			x_DWORD_180C80 = sub_92600_AIL_register_timer(sub_99830);
			sub_92930_AIL_set_timer_frequency(x_DWORD_180C80, 30 * a2);
			sub_92BA0_AIL_start_timer(x_DWORD_180C80);
		}
		else
		{
			x_DWORD_180C80 = sub_92600_AIL_register_timer(sub_99830);
			sub_92930_AIL_set_timer_frequency(x_DWORD_180C80, 0x1Eu);
			sub_92BA0_AIL_start_timer(x_DWORD_180C80);
		}
	}
}
// 99830: using guessed type int sub_99830();
// E37FC: using guessed type char x_BYTE_E37FC;
// E37FD: using guessed type char x_BYTE_E37FD;
// E3802: using guessed type __int16 x_WORD_E3802;
// E3817: using guessed type char x_BYTE_E3817;
// E3818: using guessed type char x_BYTE_E3818;
// E3819: using guessed type char x_BYTE_E3819;
// E381A: using guessed type char x_BYTE_E381A;
// 180C78: using guessed type int x_DWORD_180C78;
// 180C80: using guessed type int x_DWORD_180C80;



//----- (00099C10) --------------------------------------------------------
void sub_99C10_sound_proc4()
{
	if (x_BYTE_E379A)
	{
		sub_8D8F0_sound_proc3_endsample();
		if (!x_BYTE_E37FE)
			sub_919C0();
		if (x_DWORD_E37A0_sound_buffer2)
		{
			sub_83E80_sound_proc_99(x_DWORD_E37A0_sound_buffer2);
			x_DWORD_E37A4_sound_buffer3 = 0;
		}
		if (x_DWORD_E37A8_sound_buffer1)
			sub_83E80_sound_proc_99(x_DWORD_E37A8_sound_buffer1);
		x_BYTE_E3798_sound_active2 = 0;
		x_BYTE_E3799 = 0;
		x_BYTE_E379A = 0;
	}
}
// E3798: using guessed type char x_BYTE_E3798_sound_active2;
// E3799: using guessed type char x_BYTE_E3799;
// E379A: using guessed type char x_BYTE_E379A;
// E37A0: using guessed type int x_DWORD_E37A0_sound_buffer2;
// E37A4: using guessed type int x_DWORD_E37A4_sound_buffer3;
// E37A8: using guessed type int x_DWORD_E37A8_sound_buffer1;
// E37FE: using guessed type char x_BYTE_E37FE;

//----- (00099C90) --------------------------------------------------------
void sub_99C90()
{
	if (x_BYTE_E37FE)
	{
		if (x_WORD_E3802)
		{
			sub_95DE0_AIL_stop_sequence((HSEQUENCE)x_DWORD_180C78);
			sub_95F00_AIL_end_sequence(x_DWORD_180C78);
			x_WORD_E3802 = 0;
		}
		if (x_BYTE_E3815 == 1)
			sub_9FA80();
		if (!x_BYTE_E379A)
			sub_919C0();
		if (x_DWORD_E3808_music_header)
		{
			sub_83E80_sound_proc_99((Bit8u*)x_DWORD_E3808_music_header);
			x_DWORD_E380C = 0;
		}
		if (x_DWORD_E3810_music_data)
			sub_83E80_sound_proc_99(x_DWORD_E3810_music_data);
		x_BYTE_E37FC = 0;
		x_BYTE_E37FD = 0;
		x_BYTE_E37FE = 0;
	}
}
// E379A: using guessed type char x_BYTE_E379A;
// E37FC: using guessed type char x_BYTE_E37FC;
// E37FD: using guessed type char x_BYTE_E37FD;
// E37FE: using guessed type char x_BYTE_E37FE;
// E3802: using guessed type __int16 x_WORD_E3802;
// E3808: using guessed type int x_DWORD_E3808_music_header;
// E380C: using guessed type int x_DWORD_E380C;
// E3810: using guessed type int x_DWORD_E3810_music_data;
// E3815: using guessed type char x_BYTE_E3815;
// 180C78: using guessed type int x_DWORD_180C78;

//----- (00099E8E) --------------------------------------------------------
signed int sub_99E8E(unsigned __int8 *a1, unsigned __int8 **a2, signed int a3, int a4)
{
	signed int v4; // edi
	unsigned __int8 *i; // ebx
	unsigned __int8 v6; // al
	signed int result; // eax
	unsigned __int8 v8; // cl
	unsigned int v9; // esi
	int v10; // eax
	unsigned int v11; // edx
	unsigned __int8 *v12; // [esp+0h] [ebp-1Ch]
	char v13; // [esp+4h] [ebp-18h]
	unsigned __int8 v14; // [esp+8h] [ebp-14h]

	v4 = a3;
	if (a2)
		*a2 = a1;
	for (i = a1; IsTable[(unsigned __int8)(*i + 1)] & 2; i++)
		;
	v14 = *i;
	if (*i == 43 || *i == 45)
		++i;
	if (!a3)
	{
		if (*i != 48 || (v6 = i[1], v6 != 120) && v6 != 88)
		{
			if (*i == 48)
				v4 = 8;
			else
				v4 = 10;
		}
		else
		{
			v4 = 16;
		}
	}
	if (v4 >= 2 && v4 <= 36)
	{
		if (v4 == 16 && *i == 48)
		{
			v8 = i[1];
			if (v8 == 120 || v8 == 88)
				i += 2;
		}
		v12 = i;
		v9 = 0;
		v13 = 0;
		while (1)
		{
			v10 = sub_99FF5(*i);
			if (v10 >= v4)
				break;
			v11 = v9;
			v9 = v10 + v4 * v9;
			if (v9 < v11)
				v13 = 1;
			++i;
		}
		if (i == v12)
			i = a1;
		if (a2)
			*a2 = i;
		if (a4 == 1 && v9 >= 0x80000000 && (v9 != 0x80000000 || v14 != 45))
			v13 = 1;
		if (v13)
		{
			_set_errno(14);
			if (a4)
			{
				if (v14 == 45)
					result = 2147483648;
				else
					result = 0x7FFFFFFF;
			}
			else
			{
				result = -1;
			}
		}
		else
		{
			if (v14 == 45)
				v9 = 0 - v9;
			result = v9;
		}
	}
	else
	{
		_set_errno(13);
		result = 0;
	}
	return result;
}
// 9D195: using guessed type x_DWORD _set_errno(x_DWORD);

//----- (00099FF0) --------------------------------------------------------
signed int sub_99FF0(char* a1, unsigned __int8 **a2, signed int a3)
{
	return sub_99E8E((Bit8u*)a1, a2, a3, 1);
}

//----- (00099FF5) --------------------------------------------------------
int sub_99FF5(unsigned __int8 a1)
{
	unsigned __int8 v2; // al

	if (a1 >= 0x30u && a1 <= 0x39u)
		return a1 - 48;
	v2 = x_tolower(a1);
	if (v2 >= 0x61u && v2 <= 0x69u)
		return v2 - 87;
	if (v2 >= 0x6Au && v2 <= 0x72u || v2 >= 0x73u && v2 <= 0x7Au)
		return v2 - 87;
	return 37;
}
// AB952: using guessed type x_DWORD x_tolower(x_DWORD);

//----- (0009A0FC) --------------------------------------------------------
void sub_9A0FC_wait_to_screen_beam()
{
	/*unsigned __int8 result; // al

	do
	  result = __inx_BYTE(0x3DAu);
	while ( !(result & 8) );
	return result;*/
	mydelay(10);
}

//----- (0009A10A) --------------------------------------------------------
signed int /*__fastcall*/ sub_9A10A_check_keyboard(/*signed int result*/)
{
	if (x_DWORD_E4CA4)
		return 1;
	return VGA_check_standart_input_status();
	//fix it:__asm { int     21h; DOS - CHECK STANDARD INPUT STATUS }
	/*
	on return:
	  AL = 00 if no character available
		 = FF if character available


	  - checks STDIN for available characters
	  - character is not returned
	  - if Ctrl-Break is detected INT 23 is executed
	*/
	return 0;//fix it
}
// E4CA4: using guessed type int x_DWORD_E4CA4;

//----- (0009A128) --------------------------------------------------------
void sub_9A128_copy_screen_320(void* source, void* desc, Bit16u countlines)
{
	qmemcpy(desc, source, 320 * countlines);
}

//----- (0009A144) --------------------------------------------------------
void sub_9A144_copy_screen_640(void* source, void* desc, Bit16u countlines)
{
	qmemcpy(desc, source, 640 * countlines);
}

//----- (0009A230) --------------------------------------------------------
int sub_9A230_set_x_WORD_E37B4(int a1)
{
	int result; // eax

	result = a1;
	if ((unsigned __int16)a1 < 0x336u)
	{
		if ((unsigned __int16)a1 < 0x320u)
		{
			if (!(x_WORD)a1)
				x_WORD_E37B4 = 0;
		}
		else if ((unsigned __int16)a1 <= 0x320u)
		{
			x_WORD_E37B4 = 800;
		}
		else if ((x_WORD)a1 == 811)
		{
			x_WORD_E37B4 = 811;
		}
	}
	else if ((unsigned __int16)a1 <= 0x336u)
	{
		x_WORD_E37B4 = 822;
	}
	else if ((unsigned __int16)a1 < 0x656u)
	{
		if ((x_WORD)a1 == 1611)
			x_WORD_E37B4 = 1611;
	}
	else if ((unsigned __int16)a1 <= 0x656u)
	{
		x_WORD_E37B4 = 1622;
	}
	else if ((x_WORD)a1 == 1644)
	{
		x_WORD_E37B4 = 1644;
	}
	return result;
}
// E37B4: using guessed type __int16 x_WORD_E37B4;

//----- (0009A2F5) --------------------------------------------------------
Bit8u* sub_9A2F5(Pathstruct path)
{
	Bit8u* result; // eax
	//2bac30
	result = *path.var28_begin_buffer;//fix it 2bac30
	//result = 0;//fix it
	if (result)
	{
		sub_83E80_sound_proc_99(*path.var28_begin_buffer);
		result = *path.var28_begin_buffer;
		*result = 0;
	}
	return result;
}

//----- (0009A32D) --------------------------------------------------------
signed int sub_9A32D_malloc_open_unpack(Pathstruct path)//27B32d
{
	//int v1; // edx
	//int *v2; // eax
	//void* v3; // edx
	//int *v4; // eax
	//void* (*v6)(int); // [esp+0h] [ebp-8h]

	//sub_85070();
	/*if (path.var40_alloc_type & 1 )
	  v6 = sub_83D70_malloc1;
	else
	  v6 = sub_83CD0_malloc2;*/
	sub_9A2F5(path);
	if (path.path[0] == 0x2A)//fix
	{
		if (path.var40_alloc_type & 1)
			*(path.var28_begin_buffer) = (Bit8u*)sub_83D70_malloc1(path.var36_size_buffer);
		else
			*(path.var28_begin_buffer) = (Bit8u*)sub_83CD0_malloc2(path.var36_size_buffer);

		//v2 = *(int *)(path.var28_begin_buffer);
		//*v2 = v1;
		if (!(*(path.var28_begin_buffer)))
			return 0;
	}
	else
	{
		path.var36_size_buffer = (int)sub_AB9E1_get_file_unpack_size(path.path);
		if (path.var36_size_buffer <= 0)
			return 0;
		if (path.var40_alloc_type & 1)
			*(path.var28_begin_buffer) = (Bit8u*)sub_83D70_malloc1(path.var36_size_buffer);//asi init a malloc bufferu
		else
			*(path.var28_begin_buffer) = (Bit8u*)sub_83CD0_malloc2(path.var36_size_buffer);//asi init a malloc bufferu

		//v4 = *(int **)path.var28_begin_buffer;
		//*v4 = v3;
		if (!(*(path.var28_begin_buffer)))
			return -1;
		if (sub_53E60_readfile_and_decompress(path.path, path.var28_begin_buffer) != path.var36_size_buffer)
		{
			path.var28_begin_buffer = 0;
			path.var32_end_buffer = 0;
			path.var36_size_buffer = 0;
			return 0;
		}
	}
	if (path.var32_end_buffer)
		(*path.var32_end_buffer) = (*path.var28_begin_buffer) + path.var36_size_buffer;//fix ma byt 1
	return 1;
}

//----- (0009AD16) --------------------------------------------------------
int sub_9AD16_free_mem_pool(void* a1)
{
	/* fix it
	  int result; // eax
	char v2; // [esp+0h] [ebp-38h]
	int v3; // [esp+1Ch] [ebp-1Ch]
	int v4; // [esp+28h] [ebp-10h]

	if ( a1 )
	{
	  v3 = 257;
	  v4 = a1;
	  result = int386(49, (REGS*)&v3, (REGS*)&v2);
	}
	return result;
	*/
	free(a1);
	return 1;
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);

//----- (0009AD9C) --------------------------------------------------------
int sub_9AD9C(int a1)
{
	return 100 * a1;
}

//----- (0009ADB4) --------------------------------------------------------
int sub_9ADB4(int a1)
{
	return 100 * a1 / 10;
}

//----- (0009AE04) --------------------------------------------------------
bool sub_9AE04(int eax0, int edx0, int a3, int a1, int a2)
{
	return j___clock() - a1 >= a2;
}
// 98786: using guessed type int /*__fastcall*/ j___clock(x_DWORD, x_DWORD, x_DWORD);

//----- (0009AE90) --------------------------------------------------------
char sub_9AE90(int eax0, int edx0, int ebx0, int *a1, x_BYTE *a2, int a3, int a4)
{
	x_BYTE *v7; // esi
	int v8; // ebp
	int v9; // ebx
	int v10; // eax

	v7 = a2;
	v8 = j_j___clock(eax0, edx0, ebx0);
	v9 = 0;
	do
	{
		v10 = sub_9C9D0(*a1);
		if (!v10)
		{
			++v9;
			*v7 = sub_9C938((x_DWORD *)*a1);
			v10 = a3;
			++v7;
			if (v9 == a3)
				return 0;
		}
	} while (!sub_9AE04(v10, a4, v9, v8, a4));
	return 3;
}
// 9ADFC: using guessed type int /*__fastcall*/ j_j___clock(x_DWORD, x_DWORD, x_DWORD);

//----- (0009AEEC) --------------------------------------------------------
void sub_9AEEC(x_DWORD **a1, char *a2)
{
	char *v2; // ebx
	char v3; // ST04_1

	v2 = a2;
	if (x_DWORD_E3DE8)
		myprintf("Writing %s\n");
	while (1)
	{
		JUMPOUT((x_WORD)*v2, 0, (int*)&loc_9AEE8);
		v3 = *v2++;
		sub_9C810(*a1, v3);
	}
}
// E3DE8: using guessed type int x_DWORD_E3DE8;

//----- (0009AFC4) --------------------------------------------------------
char sub_9AFC4(int a1, int a2, int a3, int *a4, int a5)
{
	int v5; // edi
	int v6; // eax
	int v7; // edx

	//fix it
	v7 = 0;
	//fix it

	v5 = j_j___clock(a1, a2, (x_DWORD)a3);
	do
	{
		v6 = sub_9C9D0(*a4);
		if (!v6)
		{
			v6 = sub_9C938((x_DWORD *)*a4);
			a3 = v6;
			if (x_DWORD_E3DE8)
				v6 = myprintf("Response: %c\n");
			if (a3 == 79)
				return 0;
			if (a3 == 69)
				return 8;
		}
	} while (!sub_9AE04(v6, v7, a3, v5, a5));
	return 3;
}
// 9ADFC: using guessed type int /*__fastcall*/ j_j___clock(x_DWORD, x_DWORD, x_DWORD);
// E3DE8: using guessed type int x_DWORD_E3DE8;

//----- (0009B038) --------------------------------------------------------
char sub_9B038(int *a1, char *a2, int a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v3 = 0;
	v4 = 0;
	//fix it

	sub_9AEEC((x_DWORD **)a1, a2);
	return sub_9AFC4(v3, v4, (int)a1, a1, a3);
}

//----- (0009B234) --------------------------------------------------------
int sub_9B234(int *a1)
{
	int result; // eax

	if (*a1)
	{
		sub_9C58C(*a1);
		result = x_free((void*)*a1);
		*a1 = 0;
	}
	return result;
}
// A0E6B: using guessed type x_DWORD free(x_DWORD);

//----- (0009B260) --------------------------------------------------------
signed int sub_9B260(x_DWORD **a1)
{
	return sub_9C810(*a1, 83);
}

//----- (0009B274) --------------------------------------------------------
char sub_9B274(int *a1, int a2)
{
	char result; // al
	int v3; // ebp
	int v4; // esi
	char v5; // dl
	int v6; // edi
	signed int v7; // eax
	char v8; // dh
	char v9; // [esp+0h] [ebp-44h]
	unsigned __int8 v10; // [esp+1h] [ebp-43h]
	unsigned __int8 v11; // [esp+2h] [ebp-42h]
	unsigned __int8 v12; // [esp+3h] [ebp-41h]
	unsigned __int8 v13; // [esp+4h] [ebp-40h]
	unsigned __int8 v14; // [esp+5h] [ebp-3Fh]
	unsigned __int8 v15; // [esp+6h] [ebp-3Eh]
	unsigned __int8 v16; // [esp+7h] [ebp-3Dh]
	unsigned __int8 v17; // [esp+8h] [ebp-3Ch]
	unsigned __int8 v18; // [esp+9h] [ebp-3Bh]
	unsigned __int8 v19; // [esp+Ah] [ebp-3Ah]
	char v20; // [esp+Bh] [ebp-39h]
	int v21; // [esp+20h] [ebp-24h]
	int v22; // [esp+24h] [ebp-20h]
	int v23; // [esp+28h] [ebp-1Ch]
	int v24; // [esp+2Ch] [ebp-18h]
	int v25; // [esp+30h] [ebp-14h]

	//fix it
	v10 = 0;
	v11 = 0;
	v12 = 0;
	v13 = 0;
	v14 = 0;
	v15 = 0;
	v16 = 0;
	v17 = 0;
	v18 = 0;
	v19 = 0;
	v20 = 0;
	//fix it

	if (sub_9AE90((int)&v9, a2, (int)a1, a1, &v9, 12, a2))
	{
		sub_9CBBC((x_DWORD *)*a1);
		result = 3;
	}
	else
	{
		v3 = (signed __int16)(v10 << 8) | v11;
		v24 = v13 | (signed __int16)(v12 << 8);
		v25 = v15 | (signed __int16)(v14 << 8);
		v4 = v17 | (signed __int16)(v16 << 8);
		v5 = 0;
		v6 = (signed __int16)(v18 << 8) | v19;
		v7 = 0;
		do
		{
			v8 = *(&v9 + v7++);
			v5 += v8;
		} while (v7 < 11);
		if (v5 == v20)
		{
			sub_AC250(
				(signed __int16)(v10 << 8) | v11,
				v24,
				v25,
				v17 | (signed __int16)(v16 << 8),
				(signed __int16)(v18 << 8) | v19,
				&v23,
				&v22,
				&v21);
			a1[1] = v3;
			a1[4] = v4;
			a1[5] = v6;
			a1[2] = v24;
			a1[3] = v25;
			a1[6] = v22;
			a1[7] = v23;
			a1[8] = v21;
			result = 0;
		}
		else
		{
			sub_9CBBC((x_DWORD *)*a1);
			result = 4;
		}
	}
	return result;
}

//----- (0009B498) --------------------------------------------------------
char *sub_9B498(char a1)
{
	char *result; // eax

	switch (a1)
	{
	case 0:
		result = (char*)"Tracker initialized ok";
		break;
	case 1:
		result = (char*)"No serial port";
		break;
	case 2:
		result = (char*)"Tracker not present";
		break;
	case 3:
		result = (char*)"Tracker is not responding";
		break;
	case 4:
		result = (char*)"Tracker data is invalid";
		break;
	case 5:
		result = (char*)"Tracker header data is invalid";
		break;
	case 6:
		result = (char*)"A verified write to tracker memory failed";
		break;
	case 7:
		result = (char*)"Invalid parameter";
		break;
	case 8:
		result = (char*)"Tracker command returned an error";
		break;
	case 9:
		result = (char*)"A memory allocation failed";
		break;
	case 10:
		result = (char*)"Tracker version string is invalid";
		break;
	default:
		result = (char*)"Undefined";
		break;
	}
	return result;
}

//----- (0009B540) --------------------------------------------------------
bool sub_9B540_lock_linear_mem_region(unsigned int a1, unsigned int a2)
{
	int v3; // [esp+4h] [ebp-20h]
	unsigned int v4; // [esp+8h] [ebp-1Ch]
	int v5; // [esp+Ch] [ebp-18h]
	unsigned int v6; // [esp+14h] [ebp-10h]
	int v7; // [esp+18h] [ebp-Ch]
	int v8; // [esp+1Ch] [ebp-8h]

	//fix it
	v8 = 0;
	//fix it

	v3 = 0x600;
	v4 = a1 >> 16;
	v5 = (unsigned __int16)a1;
	v6 = a2 >> 16;
	v7 = (unsigned __int16)a2;
	int386(0x31, (REGS*)&v3, (REGS*)&v3);//Lock Linear Region
	return v8 == 0;
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);

//----- (0009B5B4) --------------------------------------------------------
bool sub_9B5B4_unlock_mem_region(unsigned int a1, unsigned int a2)
{
	int v3; // [esp+4h] [ebp-20h]
	unsigned int v4; // [esp+8h] [ebp-1Ch]
	int v5; // [esp+Ch] [ebp-18h]
	unsigned int v6; // [esp+14h] [ebp-10h]
	int v7; // [esp+18h] [ebp-Ch]
	int v8; // [esp+1Ch] [ebp-8h]

	//fix it
	v8 = 0;
	//fix it

	v3 = 0x601;
	v4 = a1 >> 16;
	v5 = (unsigned __int16)a1;
	v6 = a2 >> 16;
	v7 = (unsigned __int16)a2;
	int386(0x31, (REGS*)&v3, (REGS*)&v3);//Unlock Linear Region
	return v8 == 0;
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);

//----- (0009B628) --------------------------------------------------------
void sub_9B628()
{
	;
}

//----- (0009B63C) --------------------------------------------------------
int sub_9B63C(int a1)
{
	return x_inp(a1);
}
// A0EE1: using guessed type x_DWORD inp(x_DWORD);

//----- (0009B688) --------------------------------------------------------
x_WORD *sub_9B688(int a1)
{
	x_WORD *result; // eax
	__int16 v2; // dx
	__int16 v3; // t1
	signed int v4; // [esp+10h] [ebp-34h]
	x_WORD *v5; // [esp+30h] [ebp-14h]
	x_WORD *v6; // [esp+34h] [ebp-10h]
	unsigned __int8 i; // [esp+38h] [ebp-Ch]
	char v8; // [esp+40h] [ebp-4h]

	result = (x_WORD *)a1;
	if (*(x_DWORD *)(a1 + 28))
	{
		if (*(x_DWORD *)(a1 + 20))
		{
			v6 = *(x_WORD **)(a1 + 44);
			if (!(x_inp(*(x_DWORD *)(a1 + 28) + 6) & 0x10))
			{
				result = v6;
				result[2] |= 2u;
				return result;
			}
			v6[2] &= 0xFFFDu;
		}
		result = (x_WORD *)x_inp(*(x_DWORD *)(a1 + 28) + 5);
		if ((unsigned __int8)result & 0x20)
		{
			if (*(x_DWORD *)(a1 + 24))
				v4 = 16;
			else
				v4 = 1;
			v5 = *(x_WORD **)a1;
			for (i = 0; ; i++)
			{
				result = v5;
				if (v5[2] <= 0)
					break;
				result = (x_WORD *)i;
				if (i >= v4)
					break;
				v2 = (*v5)++;
				v8 = *(x_BYTE *)(v2 + *(x_DWORD *)(a1 + 4));
				if (*v5 == v5[3])
					*v5 = 0;
				v3 = v5[2]--;
				x_outp(*(x_DWORD *)(a1 + 28), v8);
			}
		}
	}
	return result;
}
// A0ED7: using guessed type x_DWORD outp(x_DWORD, char);
// A0EE1: using guessed type x_DWORD inp(x_DWORD);

//----- (0009B7E8) --------------------------------------------------------
int sub_9B7E8(int a1)
{
	char v4; // [esp+44h] [ebp-1Ch]

	if (*(x_DWORD *)(a1 + 28))
	{
		*(x_WORD *)(*(x_DWORD *)(a1 + 44) + 4) |= 0x10u;
		while (1)
		{
			v4 = x_inp(*(x_DWORD *)(a1 + 28) + 2);
			if (v4 & 1)
				break;
			if ((v4 & 7u) <= 6)
				JUMPOUT(__CS__, (int*) *(&off_9B844 + (v4 & 7)));
		}
	}
	return x_outp(32, 32);
}
// 9B844: using guessed type void *off_9B844;
// A0ED7: using guessed type x_DWORD outp(x_DWORD, char);
// A0EE1: using guessed type x_DWORD inp(x_DWORD);

//----- (0009BA00) --------------------------------------------------------
void /*__noreturn*/ sub_9BA00(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
	int _0; // [esp+0h] [ebp+0h]

	((void(*)(x_DWORD, x_DWORD, x_DWORD, x_DWORD, int, int, int, int, int *, int, int, int))_GETDS)(
		(unsigned __int16)__GS__,
		(unsigned __int16)__FS__,
		(unsigned __int16)__ES__,
		(unsigned __int16)__DS__,
		a1,
		a2,
		a3,
		a4,
		&_0,
		a5,
		a6,
		a7);
}

//----- (0009BA2C) --------------------------------------------------------
void /*__noreturn*/ sub_9BA2C(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
	int _0; // [esp+0h] [ebp+0h]

	((void(*)(x_DWORD, x_DWORD, x_DWORD, x_DWORD, int, int, int, int, int *, int, int, int))_GETDS)(
		(unsigned __int16)__GS__,
		(unsigned __int16)__FS__,
		(unsigned __int16)__ES__,
		(unsigned __int16)__DS__,
		a1,
		a2,
		a3,
		a4,
		&_0,
		a5,
		a6,
		a7);
}

//----- (0009BA58) --------------------------------------------------------
void /*__noreturn*/ sub_9BA58(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
	int _0; // [esp+0h] [ebp+0h]

	((void(*)(x_DWORD, x_DWORD, x_DWORD, x_DWORD, int, int, int, int, int *, int, int, int))_GETDS)(
		(unsigned __int16)__GS__,
		(unsigned __int16)__FS__,
		(unsigned __int16)__ES__,
		(unsigned __int16)__DS__,
		a1,
		a2,
		a3,
		a4,
		&_0,
		a5,
		a6,
		a7);
}

//----- (0009BA84) --------------------------------------------------------
void /*__noreturn*/ sub_9BA84(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
	int _0; // [esp+0h] [ebp+0h]

	((void(*)(x_DWORD, x_DWORD, x_DWORD, x_DWORD, int, int, int, int, int *, int, int, int))_GETDS)(
		(unsigned __int16)__GS__,
		(unsigned __int16)__FS__,
		(unsigned __int16)__ES__,
		(unsigned __int16)__DS__,
		a1,
		a2,
		a3,
		a4,
		&_0,
		a5,
		a6,
		a7);
}

//----- (0009BAB0) --------------------------------------------------------
void sub_9BAB0()
{
	;
}

//----- (0009BAC4) --------------------------------------------------------
int sub_9BAC4(int a1, signed int a2)
{
	int v2; // ST50_4

	if (!*(x_DWORD *)(a1 + 28))
		return 0;
	if (a2 >= 300)
	{
		if (a2 > 115200)
			a2 = 115200;
	}
	else
	{
		a2 = 300;
	}
	v2 = 115200 / a2;
	sub_AC449();
	x_outp(*(x_DWORD *)(a1 + 28) + 3, 131);
	x_outp(*(x_DWORD *)(a1 + 28) + 1, SBYTE1(v2));
	x_outp(*(x_DWORD *)(a1 + 28), 115200 / a2);
	x_outp(*(x_DWORD *)(a1 + 28) + 3, 3);
	sub_AC44B();
	return 115200 / (115200 / a2);
}
// A0ED7: using guessed type x_DWORD outp(x_DWORD, char);

//----- (0009BBFC) --------------------------------------------------------
int sub_9BBFC_unlock_and_free_memory(int a1)
{
	int v2; // [esp+0h] [ebp-1Ch]
	__int16 v3; // [esp+Ch] [ebp-10h]

	if (*(x_DWORD *)(a1 + 4))
	{
		v2 = 0x101;
		v3 = *(x_WORD *)(a1 + 8);
		int386(0x31, (REGS*)&v2, (REGS*)&v2);//Free DOS Memory Block
		sub_9B5B4_unlock_mem_region(*(x_DWORD *)(a1 + 4), *(x_DWORD *)(*(x_DWORD *)a1 + 4) >> 16);
	}
	return (int)memset((void*)a1, 0, 10);
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);

//----- (0009BC68) --------------------------------------------------------
signed int sub_9BC68_allocate_and_lock_memory(x_WORD *a1, int a2, unsigned int a3)
{
	int v4; // [esp+0h] [ebp-20h]
	int v5; // [esp+4h] [ebp-1Ch]
	int v6; // [esp+Ch] [ebp-14h]
	int v7; // [esp+18h] [ebp-8h]

	//fix it
	v6 = 0;
	v7 = 0;
	//fix it

	*(x_DWORD *)a2 = (x_DWORD)a1;
	if (*(x_DWORD *)(a2 + 4))
		goto LABEL_5;
	v4 = 0x100;
	v5 = (signed int)(a3 + 15) >> 4;
	int386(0x31, (REGS*)&v4, (REGS*)&v4);//Allocate DOS Memory Block
	if (!v7)
	{
		*(x_DWORD *)(a2 + 4) = 16 * (unsigned __int16)v4;
		*(x_WORD *)(a2 + 8) = v6;
		a1[4] = v4;
		sub_9B540_lock_linear_mem_region(*(x_DWORD *)(a2 + 4), a3);
	LABEL_5:
		*a1 = 0;
		a1[1] = 0;
		a1[2] = 0;
		a1[3] = a3;
		return 1;
	}
	return 0;
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);

//----- (0009BD28) --------------------------------------------------------
signed int sub_9BD28_allocate_and_lock_memory2(int a1)
{
	int v2; // [esp+0h] [ebp-28h]
	unsigned int v3; // [esp+4h] [ebp-24h]
	int v4; // [esp+Ch] [ebp-1Ch]
	int v5; // [esp+18h] [ebp-10h]
	unsigned int v7; // [esp+20h] [ebp-8h]
	unsigned int v8; // [esp+24h] [ebp-4h]

	//fix it
	v4 = 0;
	v5 = 0;
	//fix it

	v8 = x_BYTE_C0134 - (char *)sub_C0000;
	v2 = 0x100;
	v3 = (unsigned int)(x_BYTE_C0134 - (char *)sub_C0000 + 15) >> 4;
	int386(0x31, (REGS*)&v2, (REGS*)&v2);//allocate dos memory
	if (v5)
		return 0;
	*(x_DWORD *)(a1 + 44) = 16 * (unsigned __int16)v2;
	v7 = *(x_DWORD *)(a1 + 44);
	*(x_WORD *)(a1 + 48) = v4;
	memcpy((void*)v7, sub_C0000, v8);
	sub_9B540_lock_linear_mem_region(v7, v8);
	*(x_WORD *)(v7 + 2) = *(x_WORD *)(a1 + 28);
	*(x_WORD *)(v7 + 4) = 0;
	memset((void*)(v7 + 6), 0, 10);
	memset((void*)(v7 + 16), 0, 10);
	return 1;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// 99DBD: using guessed type x_DWORD memcpy(x_DWORD, x_DWORD, x_DWORD);
// C0000: using guessed type int /*__far*/ sub_C0000();

//----- (0009BE18) --------------------------------------------------------
int sub_9BE18(int a1, int a2, char a3, unsigned int a4, unsigned int a5)
{
	char v5; // STFC_1
	int v6; // eax
	__int16 v7; // dx
	char v8; // ST4C_1
	int v10; // [esp+114h] [ebp-30h]
	int v11; // [esp+118h] [ebp-2Ch]
	int v12; // [esp+11Ch] [ebp-28h]
	int v13; // [esp+120h] [ebp-24h]
	int v14; // [esp+130h] [ebp-14h]
	__int64 v15; // [esp+134h] [ebp-10h]
	int v16; // [esp+13Ch] [ebp-8h]
	int v17; // [esp+140h] [ebp-4h]

	//fix it
	v7 = 0;
	v12 = 0;
	v13 = 0;
	//fix it

	sub_9C58C(a1);
	if (a2 && a2 != 2)
	{
		if (a2 != 1 && a2 != 3)
		{
			*(x_DWORD *)(a1 + 28) = 0;
		}
		else
		{
			*(x_DWORD *)(a1 + 36) = 11;
			*(x_DWORD *)(a1 + 40) = 8;
			*(x_DWORD *)(a1 + 28) = *(unsigned __int16 *)(2 * a2 + x_DWORD_E3DF8);
		}
	}
	else
	{
		*(x_DWORD *)(a1 + 36) = 12;
		*(x_DWORD *)(a1 + 40) = 16;
		*(x_DWORD *)(a1 + 28) = *(unsigned __int16 *)(2 * a2 + x_DWORD_E3DF8);
	}
	if (*(x_DWORD *)(a1 + 28) && !x_DWORD_E3DFC[a2])
	{
		*(x_DWORD *)(a1 + 32) = a2;
		x_DWORD_E3DFC[a2] = a1;
		if (sub_9BD28_allocate_and_lock_memory2(a1)
			&& sub_9BC68_allocate_and_lock_memory((x_WORD *)(*(x_DWORD *)(a1 + 44) + 16), a1, a4)
			&& sub_9BC68_allocate_and_lock_memory((x_WORD *)(*(x_DWORD *)(a1 + 44) + 6), a1 + 10, a5))
		{
			sub_AC449();
			v16 = x_inp(*(x_DWORD *)(a1 + 28) + 3);
			*(x_DWORD *)(a1 + 66) = v16;
			v16 |= 0x80u;
			x_outp(*(x_DWORD *)(a1 + 28) + 3, v16);
			LODWORD(v15) = x_inp(*(x_DWORD *)(a1 + 28) + 1);
			HIDWORD(v15) = x_inp(*(x_DWORD *)(a1 + 28));
			if (v15)
				*(x_DWORD *)(a1 + 86) = 115200 / (((x_DWORD)v15 << 8) | HIDWORD(v15));
			else
				*(x_DWORD *)(a1 + 86) = 1200;
			v16 &= 0xFFFFFF7F;
			x_outp(*(x_DWORD *)(a1 + 28) + 3, v16);
			*(x_DWORD *)(a1 + 70) = x_inp(*(x_DWORD *)(a1 + 28) + 4);
			*(x_DWORD *)(a1 + 74) = x_inp(33);
			*(x_DWORD *)(a1 + 78) = x_inp(*(x_DWORD *)(a1 + 28) + 1);
			*(x_DWORD *)(a1 + 82) = x_inp(*(x_DWORD *)(a1 + 28) + 2);
			v5 = x_inp(33);
			x_outp(33, *(x_BYTE *)(a1 + 40) | v5);
			x_outp(*(x_DWORD *)(a1 + 28) + 4, 0);
			x_outp(*(x_DWORD *)(a1 + 28) + 1, 0);
			x_outp(*(x_DWORD *)(a1 + 28) + 2, 0);
			v10 = 0x200;
			v11 = *(x_DWORD *)(a1 + 36);
			int386(0x31, (REGS*)&v10, (REGS*)&v10);//Get Real Mode Interrupt Vector
			*(x_WORD *)(a1 + 50) = v12;
			*(x_WORD *)(a1 + 52) = v13;
			v6 = dos_getvect(*(x_DWORD *)(a1 + 36));
			*(x_WORD *)(a1 + 64) = v7;
			*(x_DWORD *)(a1 + 60) = v6;
			dos_setvect(
				*(x_DWORD *)(a1 + 36),
				(x_DWORD)*(void(/*__noreturn*/ **)())((char *)&off_E3E10 + 6 * a2),
				(unsigned __int16)seg_E3E14[3 * a2]);
			v10 = 0x201;
			v11 = *(x_DWORD *)(a1 + 36);
			v12 = (*(x_DWORD *)(a1 + 44) >> 4) & 0xFFFF;
			v13 = *(x_DWORD *)(a1 + 44) & 0xF;
			int386(0x31, (REGS*)&v10, (REGS*)&v10);//Set Real Mode Interrupt Vector
			sub_9B540_lock_linear_mem_region((unsigned int)sub_9B628, (char *)sub_9BAB0 - (char *)sub_9B628);
			if (a3 & 1)
			{
				x_outp(*(x_DWORD *)(a1 + 28) + 2, 193);
				v17 = x_inp(*(x_DWORD *)(a1 + 28) + 2);
				if ((v17 & 0xF8) == 192)
				{
					*(x_DWORD *)(a1 + 24) = 1;
					*(x_WORD *)(*(x_DWORD *)(a1 + 44) + 4) |= 8u;
					x_outp(*(x_DWORD *)(a1 + 28) + 2, 65);
				}
				else
				{
					x_outp(*(x_DWORD *)(a1 + 28) + 2, 0);
				}
			}
			x_outp(*(x_DWORD *)(a1 + 28) + 1, 11);
			x_outp(*(x_DWORD *)(a1 + 28) + 4, 11);
			v8 = x_inp(33);
			x_outp(33, ~*(x_BYTE *)(a1 + 40) & v8);
			x_inp(*(x_DWORD *)(a1 + 28) + 2);
			x_inp(*(x_DWORD *)(a1 + 28));
			x_inp(*(x_DWORD *)(a1 + 28) + 5);
			x_inp(*(x_DWORD *)(a1 + 28) + 6);
			sub_AC44B();
			sub_9CD9C(a1, 1);
			sub_9CCF8(a1, 1);
			v14 = 0;
		}
		else
		{
			sub_9C58C(a1);
			v14 = -2;
		}
	}
	else
	{
		sub_9C58C(a1);
		v14 = -1;
	}
	return v14;
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// 99BA7: using guessed type x_DWORD dos_getvect(x_DWORD);
// 99BDB: using guessed type x_DWORD dos_setvect(x_DWORD, x_DWORD, x_DWORD);
// A0ED7: using guessed type x_DWORD outp(x_DWORD, char);
// A0EE1: using guessed type x_DWORD inp(x_DWORD);
// E3DF8: using guessed type int x_DWORD_E3DF8;
// E3DFC: using guessed type int x_DWORD_E3DFC[];
// E3E10: using guessed type void (/*__noreturn*/ *off_E3E10)();
// E3E14: using guessed type __int16 seg_E3E14[];

//----- (0009C58C) --------------------------------------------------------
int sub_9C58C(int a1)
{
	int result; // eax
	char v2; // ST4C_1
	int v3; // [esp+5Ch] [ebp-1Ch]
	char v4; // [esp+60h] [ebp-18h]
	int v5; // [esp+64h] [ebp-14h]
	int v6; // [esp+68h] [ebp-10h]

	result = a1;
	if (*(x_DWORD *)(a1 + 28))
	{
		sub_AC449();
		if (*(x_DWORD *)(a1 + 60) || *(x_WORD *)(a1 + 64))
			dos_setvect(*(x_DWORD *)(a1 + 36), *(x_DWORD *)(a1 + 60), *(unsigned __int16 *)(a1 + 64));
		sub_9B5B4_unlock_mem_region((unsigned int)sub_9B628, (char *)sub_9BAB0 - (char *)sub_9B628);
		if (*(x_DWORD *)(a1 + 44))
		{
			v3 = 0x201;
			v4 = *(x_BYTE *)(a1 + 36);
			v5 = *(unsigned __int16 *)(a1 + 50);
			v6 = *(unsigned __int16 *)(a1 + 52);
			int386(0x31, (REGS*)&v3, (REGS*)&v3);//Set Real Mode Interrupt Vector
		}
		if (*(x_WORD *)(a1 + 48))
		{
			v3 = 0x101;
			LOWORD(v6) = *(x_WORD *)(a1 + 48);
			int386(0x31, (REGS*)&v3, (REGS*)&v3);//Free DOS Memory Block
			sub_9B5B4_unlock_mem_region(*(x_DWORD *)(a1 + 44), x_BYTE_C0134 - (char *)sub_C0000);
		}
		x_outp(*(x_DWORD *)(a1 + 28) + 4, *(x_DWORD *)(a1 + 70));
		if (*(x_DWORD *)(a1 + 74) & *(x_DWORD *)(a1 + 40))
		{
			v2 = x_inp(33);
			x_outp(33, *(x_BYTE *)(a1 + 40) | v2);
		}
		x_outp(*(x_DWORD *)(a1 + 28) + 1, *(x_DWORD *)(a1 + 78));
		if ((*(x_DWORD *)(a1 + 82) & 0xF8) != 192)
		{
			if (*(x_DWORD *)(a1 + 24))
				x_outp(*(x_DWORD *)(a1 + 28) + 2, 0);
		}
		sub_9BAC4(a1, *(x_DWORD *)(a1 + 86));
		x_outp(*(x_DWORD *)(a1 + 28) + 3, *(x_DWORD *)(a1 + 66));
		sub_AC44B();
		sub_9BBFC_unlock_and_free_memory(a1);
		sub_9BBFC_unlock_and_free_memory(a1 + 10);
		x_DWORD_E3DFC[*(x_DWORD *)(a1 + 32)] = 0;
		result = (int)memset((void*)a1, 0, 90);
	}
	return result;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);
// 99BDB: using guessed type x_DWORD dos_setvect(x_DWORD, x_DWORD, x_DWORD);
// A0ED7: using guessed type x_DWORD outp(x_DWORD, char);
// A0EE1: using guessed type x_DWORD inp(x_DWORD);
// C0000: using guessed type int /*__far*/ sub_C0000();
// E3DFC: using guessed type int x_DWORD_E3DFC[];

//----- (0009C810) --------------------------------------------------------
signed int sub_9C810(x_DWORD *a1, char a2)
{
	__int16 v2; // dx
	__int16 v3; // t1
	x_WORD *v5; // [esp+0h] [ebp-8h]

	if (!a1[7])
		return 1;
	v5 = (x_WORD *)*a1;
	if (*(x_WORD *)(*a1 + 4) != *(x_WORD *)(*a1 + 6))
	{
		sub_AC449();
		v2 = v5[1]++;
		*(x_BYTE *)(a1[1] + v2) = a2;
		if (v5[1] == v5[3])
			v5[1] = 0;
		v3 = v5[2]++;
		sub_9B688((int)a1);
		sub_AC44B();
		return 1;
	}
	return 0;
}

//----- (0009C938) --------------------------------------------------------
signed int sub_9C938(x_DWORD *a1)
{
	__int16 v1; // dx
	__int16 v2; // t1
	x_WORD *v5; // [esp+4h] [ebp-8h]
	int v6; // [esp+8h] [ebp-4h]

	if (!a1[7])
		return -1;
	v5 = *(x_WORD **)((char *)a1 + 10);
	if (v5[2] <= 0)
		return -1;
	sub_AC449();
	v1 = (*v5)++;
	v6 = *(unsigned __int8 *)(*(x_DWORD *)((char *)a1 + 14) + v1);
	if (*v5 == v5[3])
		*v5 = 0;
	v2 = v5[2]--;
	sub_AC44B();
	return v6;
}

//----- (0009C9D0) --------------------------------------------------------
bool sub_9C9D0(int a1)
{
	bool v2; // [esp+4h] [ebp-4h]

	if (*(x_DWORD *)(a1 + 28))
		v2 = *(x_WORD *)(*(x_DWORD *)(a1 + 10) + 4) == 0;
	else
		v2 = 1;
	return v2;
}

//----- (0009CBBC) --------------------------------------------------------
void sub_9CBBC(x_DWORD *a1)
{
	if (a1[7])
	{
		sub_AC449();
		*(x_WORD *)(*a1 + 4) = 0;
		*(x_WORD *)*a1 = 0;
		*(x_WORD *)(*a1 + 2) = 0;
		*(x_WORD *)(*(x_DWORD *)((char *)a1 + 10) + 4) = 0;
		**(x_WORD **)((char *)a1 + 10) = 0;
		*(x_WORD *)(*(x_DWORD *)((char *)a1 + 10) + 2) = 0;
		*(x_WORD *)(a1[11] + 4) &= 0xFFFDu;
		x_inp(a1[7] + 5);
		x_inp(a1[7] + 6);
		x_inp(a1[7] + 2);
		x_inp(a1[7]);
		sub_AC44B();
	}
}
// A0EE1: using guessed type x_DWORD inp(x_DWORD);

//----- (0009CCB4) --------------------------------------------------------
int sub_9CCB4(int a1, int a2)
{
	int result; // eax

	if (a2)
	{
		*(x_DWORD *)(a1 + 20) = 1;
		result = *(x_DWORD *)(a1 + 44);
		*(x_WORD *)(result + 4) |= 1u;
	}
	else
	{
		*(x_DWORD *)(a1 + 20) = 0;
		result = *(x_DWORD *)(a1 + 44);
		*(x_WORD *)(result + 4) &= 0xFFFEu;
	}
	return result;
}

//----- (0009CCF8) --------------------------------------------------------
int sub_9CCF8(int a1, int a2)
{
	int result; // eax
	int v3; // ST18_4
	char v4; // al
	int v5; // ST08_4
	char v6; // al

	result = a1;
	if (*(x_DWORD *)(a1 + 28))
	{
		if (a2)
		{
			v3 = *(x_DWORD *)(a1 + 28) + 4;
			v4 = sub_9B63C(v3) | 1;
			result = x_outp(v3, v4);
		}
		else
		{
			v5 = *(x_DWORD *)(a1 + 28) + 4;
			v6 = sub_9B63C(v5) & 0xFE;
			result = x_outp(v5, v6);
		}
	}
	return result;
}
// A0ED7: using guessed type x_DWORD outp(x_DWORD, char);

//----- (0009CD9C) --------------------------------------------------------
int sub_9CD9C(int a1, int a2)
{
	int result; // eax
	int v3; // ST18_4
	char v4; // al
	int v5; // ST08_4
	char v6; // al

	result = a1;
	if (*(x_DWORD *)(a1 + 28))
	{
		if (a2)
		{
			v3 = *(x_DWORD *)(a1 + 28) + 4;
			v4 = sub_9B63C(v3) | 2;
			result = x_outp(v3, v4);
		}
		else
		{
			v5 = *(x_DWORD *)(a1 + 28) + 4;
			v6 = sub_9B63C(v5) & 0xFD;
			result = x_outp(v5, v6);
		}
	}
	return result;
}
// A0ED7: using guessed type x_DWORD outp(x_DWORD, char);

//----- (0009D31C) --------------------------------------------------------
__int16 /*__fastcall*/ sub_9D31C(__int16 result)
{
	bool v1; // zf

	//fix it:__asm { int     16h; KEYBOARD - GET ENHANCED SHIFT FLAGS (AT model 339,XT2,XT286,PS) }
	x_BYTE_1806E5 = 0;
	if (result & 3)
		x_BYTE_1806E5 = 1;
	if (result & 4)
		x_BYTE_1806E5 |= 2u;
	v1 = (result & 8) == 0;
	if (result & 8)
	{
		v1 = ((unsigned __int8)x_BYTE_1806E5 | 4) == 0;
		x_BYTE_1806E5 |= 4u;
	}
	x_BYTE_1806E4 = 0;
	//fix it:__asm { int     16h; KEYBOARD - CHECK ENHANCED KEYSTROKE (AT model 339,XT2,XT286,PS) }
	if (!v1)
	{
		//fix it:__asm { int     16h; KEYBOARD - GET ENHANCED KEYSTROKE (AT model 339,XT2,XT286,PS) }
		x_BYTE_1806E4 = 16;
	}
	return result;
}
// 1806E4: using guessed type char x_BYTE_1806E4;
// 1806E5: using guessed type char x_BYTE_1806E5;

//----- (0009D380) --------------------------------------------------------
int sub_9D380(FILE* a1, int a2, char a3, int a4, int a5)
{
	if (a3 & 1)
	{
		memcpy((void*)a4, (const void*)(a2 + a1), a5);
	}
	else
	{
		x_lseek(a1, a2, 0);
		x_read(a1, (Bit8u*)a4, a5);
	}
	return a5 + a2;
}
// 99DBD: using guessed type x_DWORD memcpy(x_DWORD, x_DWORD, x_DWORD);
// A0863: using guessed type x_DWORD read(x_DWORD, x_DWORD, x_DWORD);
// AA7C0: using guessed type x_DWORD lseek(x_DWORD, x_DWORD, char);

//----- (0009D3F0) --------------------------------------------------------
/*void* (*sub_9D3F0_set_malloc_type(void* (*a1)(size_t size)))(size_t)
{
	//void* sub_83CD0_malloc2(int a1)
  void* ( *v1)(size_t size); // ST04_4
  v1 = off_E3E30_mallocx;
  off_E3E30_mallocx = a1;
  return v1;
}*/
// E3E30: using guessed type int (*off_E3E30_mallocx)(x_DWORD);

//----- (0009D420) --------------------------------------------------------
/*int (*sub_9D420(int (*a1)(void*)))(void*)
{
  int ( *v1)(void*); // ST04_4

  v1 = off_E3E34_freex;
  off_E3E34_freex = a1;
  return v1;
}*/
// E3E34: using guessed type int (*off_E3E34_freex)(int);

//----- (0009D450) --------------------------------------------------------
Bit8u* sub_9D450_malloc4(int a1)
{
	Bit8u* v2; // [esp+4h] [ebp-4h]

	v2 = (Bit8u*)malloc(a1);//off_E3E30_mallocx(a1);
	if (v2)
		sub_9D710(v2, a1);
	return v2;
}
// E3E30: invalid function type has been ignored
// E3E30: using guessed type int (*off_E3E30_mallocx)(x_DWORD);

//----- (0009D490) --------------------------------------------------------
int sub_9D490_free4(void* a1, int a2)
{
	int result; // eax

	if (a1)
	{
		//sub_9D740(a1, a2);
		//result = off_E3E34_freex(a1);
		result = x_free(a1);
	}
	return result;
	//fix it
	//return 0;
}
// E3E34: using guessed type int (*off_E3E34_freex)(int);

//----- (0009D4D0) --------------------------------------------------------
signed int sub_9D4D0(int a1, Bit8u** a2, Bit32u* a3, Bit32u* a4)//27e4d0
{
	Bit8u* v6; // [esp+Ch] [ebp-4h]

	v6 = (Bit8u*)sub_83D70_malloc1(16 * a1);
	if (v6 == NULL)
		return 0;
	*a3 = 0;//(int)v6 >> 4 << 16;//fixed - remove segment
	*a2 = v6;
	*a4 = 1232;
	//sub_9D590_lock_linear_region((Bit8u*)(*a3 >> 12), (*a3 >> 12) + 16 * a1 - 1);
	return 1;
}

//----- (0009D560) --------------------------------------------------------
void sub_9D560(Bit8u* a1)
{
	sub_83E80_sound_proc_99(a1);
}

//----- (0009D590) --------------------------------------------------------
void sub_9D590_lock_linear_region(Bit8u* a1, unsigned int a2)
{
	//unsigned int v3; // [esp+0h] [ebp-54h]
	//unsigned int v4; // [esp+4h] [ebp-50h]
	//int v5; // [esp+Ch] [ebp-48h]
	//unsigned int v6; // [esp+10h] [ebp-44h]
	//int v7; // [esp+14h] [ebp-40h]
	//unsigned int v8; // [esp+1Ch] [ebp-38h]
	int v9; // [esp+20h] [ebp-34h]
	char v10; // [esp+28h] [ebp-2Ch]
	int v11; // [esp+40h] [ebp-14h]
	//unsigned int v12; // [esp+48h] [ebp-Ch]
	//unsigned int v13; // [esp+4Ch] [ebp-8h]
	//int v14; // [esp+50h] [ebp-4h]

	//fix it
	v11 = 0;
	v9 = 0;
	v10 = 0;
	//fix it

	/*v14 = 0;
	if ( a1 >= a2 )
	  v3 = a2;
	else
	  v3 = a1;
	v13 = v3;
	if ( a1 < a2 )
	  v4 = a2;
	else
	  v4 = a1;
	v12 = v4 - v13 + 1;
	v5 = 0x600;
	v6 = v13 >> 16;
	v7 = (unsigned __int16)v13;
	v8 = v12 >> 16;
	v9 = (unsigned __int16)(v4 - v13 + 1);
	int386(0x31, (REGS*)&v5, (REGS*)&v10);//Lock Linear Region*/ // fix it
	//return v11 == 0; //fix it
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);

//----- (0009D650) --------------------------------------------------------
bool sub_9D650(unsigned int a1, unsigned int a2)
{
	unsigned int v3; // [esp+0h] [ebp-54h]
	unsigned int v4; // [esp+4h] [ebp-50h]
	int v5; // [esp+Ch] [ebp-48h]
	unsigned int v6; // [esp+10h] [ebp-44h]
	int v7; // [esp+14h] [ebp-40h]
	unsigned int v8; // [esp+1Ch] [ebp-38h]
	int v9; // [esp+20h] [ebp-34h]
	char v10; // [esp+28h] [ebp-2Ch]
	int v11; // [esp+40h] [ebp-14h]
	unsigned int v12; // [esp+48h] [ebp-Ch]
	unsigned int v13; // [esp+4Ch] [ebp-8h]
	int v14; // [esp+50h] [ebp-4h]

	//fix it
	v11 = 0;
	//fix it

	v14 = 0;
	if (a1 >= a2)
		v3 = a2;
	else
		v3 = a1;
	v13 = v3;
	if (a1 < a2)
		v4 = a2;
	else
		v4 = a1;
	v12 = v4 - v13 + 1;
	v5 = 1537;
	v6 = v13 >> 16;
	v7 = (unsigned __int16)v13;
	v8 = v12 >> 16;
	v9 = (unsigned __int16)(v4 - v13 + 1);
	//int386(49, (REGS*)&v5, (REGS*)&v10); // unlock linear region
	return v11 == 0;
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);

//----- (0009D710) --------------------------------------------------------
void sub_9D710(Bit8u* a1, int a2)
{
	sub_9D590_lock_linear_region(a1, a1[a2]);
}

//----- (0009D740) --------------------------------------------------------
bool sub_9D740(unsigned int a1, int a2)
{
	return sub_9D650(a1, a2 + a1);
}

//----- (0009D770) --------------------------------------------------------
int sub_9D770(char* a1, char a2)
{
	char v3; // [esp+0h] [ebp-E0h]
	int v4; // [esp+40h] [ebp-A0h]
	unsigned int v5; // [esp+44h] [ebp-9Ch]
	int v6; // [esp+ACh] [ebp-34h]
	int v7; // [esp+C4h] [ebp-1Ch]
	int v8; // [esp+C8h] [ebp-18h]
	unsigned int i; // [esp+CCh] [ebp-14h]
	FILE* v10; // [esp+D0h] [ebp-10h]
	int v11; // [esp+D4h] [ebp-Ch]
	int v12; // [esp+D8h] [ebp-8h]
	int v13; // [esp+DCh] [ebp-4h]

	//fix it
	v4 = 0;
	v5 = 0;
	//fix it

	v13 = 8224;
	v7 = 0;
	if (a2 & 1)
	{
		v10 = (FILE*)a1;
	}
	else
	{
		v10 = x_open(a1, 512);
		if (v10 == NULL)
			return 0;
	}
	v12 = sub_9D380(v10, 60, a2, (int)&v8, 4);
	v12 = sub_9D380(v10, v8, a2, (int)&v13, 2);
	if (!strcmp((const char*)&v13, "LX"))
	{
		sub_9D380(v10, v8, a2, (int)&v3, 172);
		v12 = v4 + v8;
		for (i = 0; i < v5; i++)
		{
			v12 = sub_9D380(v10, v12, a2, (int)&v6, 24);
			v7 += v6;
		}
		if (!(a2 & 1))
			x_close((FILE*)v10);
		v7 += 15 * v5;
		v11 = v7;
	}
	else
	{
		x_close((FILE*)v10);
		v11 = 0;
	}
	return v11;
}
// 9A050: using guessed type x_DWORD strcmp(x_DWORD, x_DWORD);
// A0855: using guessed type x_DWORD close(x_DWORD);

//----- (0009DE20) --------------------------------------------------------
signed int sub_9DE20_get_file_lenght(char* a1)
{
	signed int v2; // [esp+0h] [ebp-Ch]
	signed int v3; // [esp+4h] [ebp-8h]
	FILE* v4; // [esp+8h] [ebp-4h]

	x_DWORD_E3E2C = 0;
	v4 = x_open(a1, 512);
	if (v4 == NULL)
	{
		x_DWORD_E3E2C = 3;
		v2 = -1;
	}
	else
	{
		v3 = x_filelength(v4);
		if (v3 == -1)
			x_DWORD_E3E2C = 5;
		x_close(v4);
		v2 = v3;
	}
	return v2;
}
// 988DA: using guessed type x_DWORD filelength(x_DWORD);
// A0855: using guessed type x_DWORD close(x_DWORD);
// E3E2C: using guessed type int x_DWORD_E3E2C;

//----- (0009DEA0) --------------------------------------------------------
Bit8u* sub_9DEA0_read_file(char* a1, Bit8u* a2)//27eea0
{
	Bit8u* v3; // [esp+0h] [ebp-1Ch]
	Bit8u* result; // [esp+4h] [ebp-18h]
	signed int v5; // [esp+10h] [ebp-Ch]
	FILE* v6; // [esp+14h] [ebp-8h]

	x_DWORD_E3E2C = 0;
	v5 = sub_9DE20_get_file_lenght(a1);
	if (v5 == -1)
	{
		x_DWORD_E3E2C = 3;
		result = 0;
	}
	else
	{
		if (a2)
			v3 = a2;
		else
		{
			v3 = (Bit8u*)malloc(v5);
		}
		if (v3)
		{
			v6 = x_open(a1, 512);
			if (v6 == NULL)
			{
				x_free((void*)v3);
				x_DWORD_E3E2C = 3;
				result = 0;
			}
			else if (x_read(v6, v3, v5) == v5)
			{
				x_close(v6);
				result = v3;
			}
			else
			{
				x_free((void*)v3);
				x_DWORD_E3E2C = 5;
				result = 0;
			}
		}
		else
		{
			x_DWORD_E3E2C = 2;
			result = 0;
		}
	}
	return result;
}
// A0855: using guessed type x_DWORD close(x_DWORD);
// A0863: using guessed type x_DWORD read(x_DWORD, x_DWORD, x_DWORD);
// E3E2C: using guessed type int x_DWORD_E3E2C;
// E3E30: using guessed type int (*off_E3E30_mallocx)(x_DWORD);
// E3E34: using guessed type int (*off_E3E34_freex)(int);

//----- (0009E1B0) --------------------------------------------------------
void sub_9E1B0()
{
	//bool result; // eax

	if (!x_DWORD_E3E3C)
	{
		sub_9D590_lock_linear_region((Bit8u*)sub_9E1B0, (unsigned int)sub_9EDD0);
		sub_9D710((Bit8u*)x_DWORD_181C50, 64);
		sub_9D710((Bit8u*)x_DWORD_181DAC, 76);
		sub_9D710((Bit8u*)&x_BYTE_181C90, 256);
		sub_9D710((Bit8u*)&unk_181D90, 24);
		sub_9D710((Bit8u*)&x_DWORD_E3E38, 4);
		sub_9D710((Bit8u*)&x_DWORD_181DA8, 4);
		x_DWORD_E3E3C = 1;
	}
	//return result;
}
// E3E38: using guessed type int x_DWORD_E3E38;
// E3E3C: using guessed type int x_DWORD_E3E3C;
// 181C90: using guessed type char x_BYTE_181C90;
// 181DA8: using guessed type int x_DWORD_181DA8;
// 181DAC: using guessed type int x_DWORD_181DAC[];

//----- (0009E2B0) --------------------------------------------------------
int sub_9E2B0(char* a1, int a2, x_DWORD *a3)
{
	int v3; // ebx
	int v5; // [esp+4h] [ebp-10h]
	int v6; // [esp+8h] [ebp-Ch]
	int j; // [esp+Ch] [ebp-8h]
	unsigned int i; // [esp+10h] [ebp-4h]

	v6 = 0;
	v5 = 1;
	for (i = 0; strlen(a1) > i; i++)
	{
		if (a1[i] == 45)
		{
			v5 = -v5;
		}
		else if (!(IsTable[a1[i] + 1] & 2))
		{
			for (j = 0; j < a2; j++)
			{
				v3 = x_BYTE_D3450[j];
				if (x_toupper(a1[i]) == v3)
				{
					v6 = a2 * v6 + j;
					break;
				}
			}
			if (j == a2)
				break;
		}
	}
	if (a3)
		*a3 = i + (int)a1;
	return v5 * v6;
}
// 98805: using guessed type x_DWORD x_toupper(x_DWORD);
// 99D6B: using guessed type x_DWORD strlen(x_DWORD);

//----- (0009E3A0) --------------------------------------------------------
int sub_9E3A0_AIL_API_read_INI(AIL_INI* INI, char* filename/*,char* a8*/)//27f3a0
{
	unsigned int v2; // eax
	unsigned int v3; // eax
	unsigned int v4; // eax
	unsigned int v5; // eax
	//char v7[300]; // [esp+0h] [ebp-180h]
	//char v8[200]; // [esp+80h] [ebp-100h]
	//Bit16s v9[12]; // [esp+100h] [ebp-80h]
	FILE* v9x;
	//errno_t v9y;
	//__int16 v10; // [esp+102h] [ebp-7Eh]
	//__int16 v11; // [esp+104h] [ebp-7Ch]
	//__int16 v12; // [esp+106h] [ebp-7Ah]
	char v13[80]; // [esp+118h] [ebp-68h]
	char *v14; // [esp+168h] [ebp-18h]
	char *v15; // [esp+16Ch] [ebp-14h]
	char *v16; // [esp+170h] [ebp-10h]
	unsigned int i; // [esp+174h] [ebp-Ch]
	int v18; // [esp+178h] [ebp-8h]
	char v19[80]; // [esp+17Ch] [ebp-4h]

	memset(INI->device_name, 0, 280);
	memset(&INI->IO, -1, 24);
	//v9y = myfopen_s(&v9x,a2,(const char*) "rt");
	v9x = myopent(filename, (char*)"rt");
	if (!v9x)
		return 0;
	while (fgets(v13, 80, v9x) /*&& !(v9x[12] & 0x10)*/)//355140
	{
		for (i = strlen(v13) - 1; (i & 0x80000000) == 0 && IsTable[(v13[i] + 1)] & 2; i--)
			v13[i] = 0;
		for (i = 0; ; i++)
		{
			v2 = strlen(v13);
			if (v2 <= i || !(IsTable[(v13[i] + 1)] & 2))
				break;
		}
		v15 = &v13[i];
		while (1)
		{
			v3 = strlen(v13);
			if (v3 <= i || IsTable[(v13[i] + 1)] & 2)
				break;
			i++;
		}
		v14 = &v13[i];
		while (1)
		{
			v4 = strlen(v13);
			if (v4 <= i || !(IsTable[(v13[i] + 1)] & 2))
				break;
			i++;
		}
		v16 = &v13[i];
		v5 = strlen(v13);
		if (v5 > i)
		{
			*v14 = 0;
			if (*v15 != 59)
			{
				if (!_strnicmp(v15, "DRIVER", 7))
				{
					strcpy_s(INI->driver_name, strlen(v16) + 1, v16);
				}
				else if (!_strnicmp(v15, "DEVICE", 7))
				{
					strcpy_s(INI->device_name, strlen(v16) + 1, v16);
				}
				else if (!_strnicmp(v15, "IO_ADDR", 8))
				{
					INI->IO.IO = sub_9E2B0(v16, 16, 0);
				}
				else if (!_strnicmp(v15, "IRQ", 4))
				{
					INI->IO.IRQ = sub_9E2B0(v16, 10, 0);
				}
				else if (!_strnicmp(v15, "DMA_8_bit", 10))
				{
					INI->IO.DMA_8_bit = sub_9E2B0(v16, 10, 0);
				}
				else if (!_strnicmp(v15, "DMA_16_bit", 11))
				{
					INI->IO.DMA_16_bit = sub_9E2B0(v16, 10, 0);
				}
			}
		}
	}
	fclose(v9x);
	if (strlen(INI->device_name) && strlen(INI->device_name))
	{
		//qmemcpy(filename, INI->device_name, 0x118u);//fix it
		v18 = 1;
	}
	else
	{
		qmemcpy(&x_BYTE_181C90, (void*)"Corrupted .INI file\n", 0x15u);
		v18 = 0;
	}
	return v18;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 99B23: using guessed type x_DWORD strnicmp(x_DWORD, x_DWORD, x_DWORD);
// 99D46: using guessed type x_DWORD strcpy(x_DWORD, x_DWORD);
// 99D6B: using guessed type x_DWORD strlen(x_DWORD);
// A1AF0: using guessed type x_DWORD fopen(x_DWORD, x_DWORD);
// A1E05: using guessed type x_DWORD fclose(x_DWORD);
// AD7AA: using guessed type x_DWORD fgets(x_DWORD, x_DWORD, x_DWORD);
// 181C90: using guessed type char x_BYTE_181C90;
// 9E3A0: using guessed type char var_68[80];

//----- (0009E6E0) --------------------------------------------------------
int sub_9E6E0_set_preference(Bit32u number, Bit32s value)
{
	int oldvalue;
	oldvalue = x_DWORD_181DAC[number];
	x_DWORD_181DAC[number] = value;
	return oldvalue;
}
// 181DAC: using guessed type int x_DWORD_181DAC[];

//----- (0009E720) --------------------------------------------------------
AIL_DRIVER* sub_9E720_AIL_API_install_driver(/*int a1, */Bit8u* driver_image, Bit32s n_bytes)//27f720
{
	//VDI_HDR* v3; // edx
	int v4; // ecx
	int v5; // ST0C_4
	int v6; // ST08_4
	int v7; // ST0C_4
	int v8; // ST08_4
	int v9; // ST0C_4
	int v10; // ST08_4
	AIL_DRIVER* result; // [esp+0h] [ebp-Ch]
	unsigned int i; // [esp+4h] [ebp-8h]
	AIL_DRIVER* v14; // [esp+8h] [ebp-4h]

	//fix it
	//v3 = new VDI_HDR();
	v4 = 0;
	//fix it

	v14 = (AIL_DRIVER*)sub_9D450_malloc4(sizeof(AIL_DRIVER));
	if (v14)
	{
		v14->size_3 = n_bytes;
		if (sub_9D4D0((n_bytes + 15) >> 4, (Bit8u**)&v14->buf_2, &v14->seg_0, &v14->sel_1))
		{
			memmove((void*)v14->buf_2, (const void*)driver_image, n_bytes);
			//fix it - make buf reader
			v14->VHDR_4 = (VDI_HDR*)v14->buf_2;
			if (!_strnicmp((const char*)v14->VHDR_4->ID_8, "AIL3DIG", 7))
			{
				v14->type_5 = 0;
			}
			else
			{
				if (_strnicmp((char*)v14->VHDR_4->ID_8, "AIL3MDI", 7))
				{
					qmemcpy(&x_BYTE_181C90, (void*)"Invalid driver type\n", 0x15u);
					v5 = v14->sel_1;
					v6 = v14->seg_0;
					sub_9D560((Bit8u*)v14->buf_2);
					sub_9D490_free4(v14, 44);
					return 0;
				}
				v14->type_5 = 1;
			}
			for (i = 0; i < 0x10; i++)
			{
				if (!x_DWORD_181C50[i])
				{
					x_DWORD_181C50[i] = v14;
					v14->VHDR_4->VDI_HDR_var50 = i;
					break;
				}
			}
			if (i != 16)
			{
				v14->VHDR_4->VDI_HDR_var48 = 0;
				v14->initialized_6 = 0;
				v14->PM_ISR_7 = -1;
				v14->VHDR_4->VDI_HDR_var54_prev_ISR = sub_91C10_AIL_get_real_vect(/*v3, v4, a1,*/ 102);//save old vector
				sub_91D50_AIL_set_real_vect(102, /*v14->AIL_DRIVER_var0_seg + */v14->VHDR_4->VDI_HDR_var52_this_ISR);//set new vector
				v14->destructor_9 = 0;
				v14->descriptor_10 = 0;
				sub_91F70_AIL_call_driver(v14, 768, 0, 0);
				if (v14->VHDR_4->VDI_HDR_var46 > 0)
				{
					v14->server_8 = sub_92600_AIL_register_timer(sub_9E250);
					if (v14->server_8 == -1)
					{
						qmemcpy(&x_BYTE_181C90, (void*)"Out of timer handles\n", 0x16u);
						sub_91D50_AIL_set_real_vect(102, v14->VHDR_4->VDI_HDR_var54_prev_ISR);
						v9 = v14->sel_1;
						v10 = (int)v14->seg_0;
						sub_9D560((Bit8u*)v14->buf_2);
						sub_9D490_free4(v14, 44);
						return 0;
					}
					sub_92740_AIL_set_timer_user(v14->server_8, (signed __int32)v14);
					sub_92930_AIL_set_timer_frequency(v14->server_8, v14->VHDR_4->VDI_HDR_var46);
					sub_92BA0_AIL_start_timer(v14->server_8);
				}
				else
				{
					v14->server_8 = -1;
				}
				return v14;
			}
			qmemcpy(x_BYTE_181C90, (void*)"Out of driver handles\n", 0x17u);
			v7 = v14->sel_1;
			v8 = (int)v14->seg_0;
			sub_9D560((Bit8u*)v14->buf_2);
			sub_9D490_free4(v14, 44);
			result = 0;
		}
		else
		{
			qmemcpy(x_BYTE_181C90, (void*)"Insufficient low memory\n", 0x19u);
			sub_9D490_free4(v14, 44);
			result = 0;
		}
	}
	else
	{
		strcpy_s(x_BYTE_181C90, strlen("Insufficient memory for driver descriptor\n") + 1, "Insufficient memory for driver descriptor\n");
		result = 0;
	}
	return result;
}
// 99B23: using guessed type x_DWORD strnicmp(x_DWORD, x_DWORD, x_DWORD);
// 9E250: using guessed type int sub_9E250();
// AD81F: using guessed type x_DWORD memmove(x_DWORD, x_DWORD, x_DWORD);
// 181C90: using guessed type char x_BYTE_181C90;

//----- (0009EA60) --------------------------------------------------------
int sub_9EA60_AIL_API_uninstall_driver(AIL_DRIVER* a1)
{
	int v1; // ST0C_4
	int v2; // ST08_4
	int result; // eax
	signed int i; // [esp+0h] [ebp-4h]

	if (a1->destructor_9)
		//(*(void (**)(x_DWORD))(a1 + 36))(*(x_DWORD *)(a1 + 40));
	{
		(a1->destructor_9)((HDIGDRIVER)a1->descriptor_10);
	}
	if (a1->server_8 != -1)
		sub_92DC0_AIL_release_timer_handle(a1->server_8);
	if (a1->initialized_6)
	{
		if (a1->PM_ISR_7 != -1)
			sub_91E90_AIL_restore_USE16_ISR(a1->PM_ISR_7);
		sub_91F70_AIL_call_driver(a1, 774, 0, 0);
	}
	sub_91D50_AIL_set_real_vect(102, 0/*(Bit8u*)*(x_DWORD *)(*(x_DWORD *)(a1 + 16) + 54)*/);//fix
	v1 = a1->sel_1;
	v2 = a1->seg_0;
	sub_9D560((Bit8u*)a1->buf_2);
	result = sub_9D490_free4(a1, 44);
	for (i = 0; i < 16; i++)
	{
		if (x_DWORD_181C50[i] == a1)
			x_DWORD_181C50[i] = 0;
		result = i;
	}
	return result;
}

//----- (0009EB60) --------------------------------------------------------
IO_PARMS* sub_9EB60_AIL_API_get_IO_environment(AIL_DRIVER *drvr)
{
	//ac_sound_get_io_environment
	char* v3; // [esp+4h] [ebp-8h]
	char* v4; // [esp+8h] [ebp-4h]

	//fix it
	v3 = 0;
	//fix it

	v4 = (char*)(*(x_DWORD *)(*(x_DWORD *)(drvr + 16) + 18) & 0xFFFF) + 16 * (*(x_DWORD *)(*(x_DWORD *)(drvr + 16) + 18) >> 16);
	if (!v4)
		return 0;
	//_dupenv_s((char**)v3,(size_t*)sizeof(v3),(char*)v4);
	v3 = mygetenv(v4);
	if (!v3)
		return 0;
	strncpy_s((char*)*(x_DWORD *)(drvr + 16) + 58, sizeof((drvr + 16) + 58), (const char*)v3, 128);
	if (sub_91F70_AIL_call_driver(drvr, 771, 0, 0) == -1)
		return 0;
	qmemcpy(&unk_181DF8, (void *)(*(x_DWORD *)(drvr + 16) + 22), 0x18u);
	return &unk_181DF8;
}
// 99E33: using guessed type x_DWORD getenv(x_DWORD);
// AD871: using guessed type x_DWORD strncpy(x_DWORD, x_DWORD, x_DWORD);

//----- (0009EC30) --------------------------------------------------------
void sub_9EC30()
{
	signed int i; // [esp+0h] [ebp-4h]

	sub_9E1B0();
	sub_91A80_AIL_set_preference(0, 200);
	sub_91A80_AIL_set_preference(1, 1);
	sub_91A80_AIL_set_preference(2, 0x8000);
	sub_91A80_AIL_set_preference(3, 100);
	sub_91A80_AIL_set_preference(4, 16);
	sub_91A80_AIL_set_preference(5, 100);
	sub_91A80_AIL_set_preference(6, 655);
	sub_91A80_AIL_set_preference(7, 0);
	sub_91A80_AIL_set_preference(8, 0);
	sub_91A80_AIL_set_preference(9, 1);
	sub_91A80_AIL_set_preference(10, 0);
	sub_91A80_AIL_set_preference(11, 120);
	sub_91A80_AIL_set_preference(12, 8);
	sub_91A80_AIL_set_preference(13, 127);
	sub_91A80_AIL_set_preference(14, 1);
	sub_91A80_AIL_set_preference(15, 0);
	sub_91A80_AIL_set_preference(16, 2);
	sub_91A80_AIL_set_preference(17, 1);
	sub_91A80_AIL_set_preference(18, 1);
	for (i = 0; i < 16; i++)
		x_DWORD_181C50[i] = 0;
	x_BYTE_181C90[0] = 0;
	sub_A10F4_sound_proc_irq();
}
// 181C90: using guessed type char x_BYTE_181C90;

//----- (0009ED70) --------------------------------------------------------
signed int sub_9ED70()
{
	signed int i; // [esp+0h] [ebp-8h]
	AIL_DRIVER* v2; // [esp+4h] [ebp-4h]

	for (i = 15; i >= 0; i--)
	{
		v2 = x_DWORD_181C50[i];
		if (v2)
			sub_93160_AIL_uninstall_driver(v2);
	}
	sub_92E50_AIL_release_all_timers();
	return sub_A11E2();
}

//----- (0009EDD0) --------------------------------------------------------
bool sub_9EDD0()
{
	bool result; // eax

	if (x_DWORD_E3E3C)
	{
		sub_9D650((unsigned int)sub_9E1B0, (unsigned int)sub_9EDD0);
		sub_9D740((unsigned int)x_DWORD_181C50, 64);
		sub_9D740((unsigned int)x_DWORD_181DAC, 76);
		sub_9D740((unsigned int)&x_BYTE_181C90, 256);
		sub_9D740((unsigned int)&unk_181D90, 24);
		sub_9D740((unsigned int)&x_DWORD_E3E38, 4);
		result = sub_9D740((unsigned int)&x_DWORD_181DA8, 4);
		x_DWORD_E3E3C = 0;
	}
	return result;
}
// E3E38: using guessed type int x_DWORD_E3E38;
// E3E3C: using guessed type int x_DWORD_E3E3C;
// 181C90: using guessed type char x_BYTE_181C90;
// 181DA8: using guessed type int x_DWORD_181DA8;
// 181DAC: using guessed type int x_DWORD_181DAC[];

//----- (0009EE70) --------------------------------------------------------
int sub_9EE70()
{
	int v0; // eax

	if (!x_BYTE_E3E45 && sub_95480_AIL_sample_user_data(x_DWORD_181E10, x_DWORD_E3E40) && (unsigned int)x_DWORD_E3E40 < 8)
	{
		sub_93830_AIL_init_sample(x_DWORD_181E10);
		sub_95140_AIL_register_EOS_callback(x_DWORD_181E10, sub_9EE70);
		v0 = sub_95480_AIL_sample_user_data(x_DWORD_181E10, x_DWORD_E3E40);
		sub_938C0_AIL_set_sample_file(x_DWORD_181E10, (Bit8u*)*(x_DWORD *)(x_DWORD_E37A0_sound_buffer2 + 32 * v0 + 18), 1);
		++x_DWORD_E3E40;
		sub_93B50_AIL_start_sample(x_DWORD_181E10);
	}
	return 0;
}
// 9EE70: using guessed type int sub_9EE70();
// E37A0: using guessed type int x_DWORD_E37A0_sound_buffer2;
// E3E40: using guessed type int x_DWORD_E3E40;
// E3E45: using guessed type char x_BYTE_E3E45;
// 181E10: using guessed type int x_DWORD_181E10;

//----- (0009F040) --------------------------------------------------------
void sub_9F040()
{
	//int result; // eax

	if (x_BYTE_E3E44)
	{
		x_BYTE_E3E45 = 1;
		sub_93D00_AIL_end_sample(x_DWORD_181E10);
		sub_953E0_AIL_set_sample_user_data(x_DWORD_181E10, 0, 0);
		sub_953E0_AIL_set_sample_user_data(x_DWORD_181E10, 1, 0);
		sub_953E0_AIL_set_sample_user_data(x_DWORD_181E10, 2, 0);
		sub_953E0_AIL_set_sample_user_data(x_DWORD_181E10, 3, 0);
		sub_953E0_AIL_set_sample_user_data(x_DWORD_181E10, 4, 0);
		sub_953E0_AIL_set_sample_user_data(x_DWORD_181E10, 5, 0);
		sub_953E0_AIL_set_sample_user_data(x_DWORD_181E10, 6, 0);
		sub_953E0_AIL_set_sample_user_data(x_DWORD_181E10, 7, 0);
	}
	//return result;
}
// E3E44: using guessed type char x_BYTE_E3E44;
// E3E45: using guessed type char x_BYTE_E3E45;
// 181E10: using guessed type int x_DWORD_181E10;

//----- (0009F110) --------------------------------------------------------
signed __int64 sub_9F110(int a1)
{
	int v2; // [esp+0h] [ebp-24h]
	int v3; // [esp+4h] [ebp-20h]
	int v4; // [esp+Ch] [ebp-18h]
	int v5; // [esp+18h] [ebp-Ch]
	unsigned int v6; // [esp+20h] [ebp-4h]

	//fix it
	v4 = 0;
	v5 = 0;
	//fix it

	v2 = 256;
	v3 = (a1 + 15) >> 4;
	int386(49, (REGS*)&v2, (REGS*)&v2);
	if (v5)
		LOWORD(v6) = 0;
	else
		LOWORD(v6) = v4;
	return __PAIR__(v6, 0);
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);

//----- (0009F170) --------------------------------------------------------
int sub_9F170(int a1, unsigned __int16 a2)
{
	int v3; // [esp+0h] [ebp-20h]
	int v4; // [esp+Ch] [ebp-14h]
	int v5; // [esp+18h] [ebp-8h]
	int v6; // [esp+1Ch] [ebp-4h]

	//fix it
	v5 = 0;
	//fix it

	v3 = 257;
	v4 = a2;
	int386(49, (REGS*)&v3, (REGS*)&v3);
	if (v5)
		v6 = -1;
	else
		v6 = 0;
	return v6;
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);

//----- (0009F1D0) --------------------------------------------------------
int sub_9F1D0(int a1)
{
	int v2; // [esp+0h] [ebp-20h]
	int v3; // [esp+4h] [ebp-1Ch]
	int v4; // [esp+18h] [ebp-8h]
	int v5; // [esp+1Ch] [ebp-4h]

	//fix it
	v4 = 0;
	//fix it

	v2 = 2;
	v3 = a1;
	int386(49, (REGS*)&v2, (REGS*)&v2);
	if (v4)
		v5 = -1;
	else
		v5 = (unsigned __int16)v2;
	return v5;
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);

//----- (0009F220) --------------------------------------------------------
int sub_9F220(int a1)
{
	int v2; // [esp+0h] [ebp-20h]
	int v3; // [esp+4h] [ebp-1Ch]
	unsigned __int16 v4; // [esp+8h] [ebp-18h]
	unsigned __int16 v5; // [esp+Ch] [ebp-14h]
	int v6; // [esp+18h] [ebp-8h]
	int v7; // [esp+1Ch] [ebp-4h]

	//fix it
	v4 = 0;
	//fix it

	//fix it
	v5 = 0;
	v6 = 0;
	//fix it

	v2 = 6;
	v3 = a1;
	int386(49, (REGS*)&v2, (REGS*)&v2);
	if (v6)
		v7 = -1;
	else
		v7 = ((signed int)v5 >> 4) + (v4 << 12);
	return v7;
}
// 98D52: using guessed type x_DWORD int386(x_DWORD, x_DWORD, x_DWORD);

//----- (0009F280) --------------------------------------------------------
int sub_9F280(int *a1)//a1 bude nejaky driver
{
	VDI_CALL v2; // [esp+0h] [ebp-10h]
	__int16 v3; // [esp+4h] [ebp-Ch]
	__int16 v4; // [esp+6h] [ebp-Ah]
	__int16 v5; // [esp+8h] [ebp-8h]
	int v6; // [esp+Ch] [ebp-4h]

	//fix it
	v4 = 0;
	v5 = 0;
	//fix it

	v3 = 16;
	sub_91F70_AIL_call_driver((AIL_DRIVER*)*a1, 1286, &v2, &v2);
	if (v2.AX == 0)//fix
		v6 = -1;
	else
		v6 = v4 << (v5 + 16);
	return v6;
}

//----- (0009F2E0) --------------------------------------------------------
VDI_CALL sub_9F2E0(int *a1, int a2, unsigned __int16 a3, unsigned __int16 a4)
{
	signed __int64 v4; // rax
	unsigned __int16 v5; // ax
	VDI_CALL v7; // [esp+0h] [ebp-10h]
	__int16 v8; // [esp+4h] [ebp-Ch]
	__int16 v9; // [esp+6h] [ebp-Ah]
	__int16 v10; // [esp+8h] [ebp-8h]

	if (!*(x_DWORD *)x_BYTE_E3E54 && !*(x_WORD *)&x_BYTE_E3E54[4])
	{
		v4 = sub_9F110(4);
		*(x_WORD *)&x_BYTE_E3E54[4] = WORD2(v4);
		*(x_DWORD *)x_BYTE_E3E54 = v4;
		if (!(x_DWORD)v4 && !*(x_WORD *)&x_BYTE_E3E54[4])
		{
			v7.AX = -1;
			return v7;
		}
	}
	__GS__ = *(x_WORD *)&x_BYTE_E3E54[4];
	__writegsx_WORD(*(unsigned int *)x_BYTE_E3E54, a4);
	v5 = sub_9F220(a3);
	__GS__ = *(x_WORD *)&x_BYTE_E3E54[4];
	__writegsx_WORD(*(x_DWORD *)x_BYTE_E3E54 + 2, v5);
	v8 = 17;
	v9 = sub_9F220(*(unsigned __int16 *)&x_BYTE_E3E54[4]);
	v10 = 0;
	sub_91F70_AIL_call_driver((AIL_DRIVER*)*a1, 1286, &v7, &v7);
	return v7;
}

//----- (0009F3D0) --------------------------------------------------------
__int64 sub_9F3D0(int *a1, int a2, unsigned __int16 a3, unsigned __int16 a4)
{
	signed __int64 v4; // rax
	unsigned __int16 v5; // ax
	int v6; // ebx
	VDI_CALL v8; // [esp+0h] [ebp-14h]
	__int16 v9; // [esp+4h] [ebp-10h]
	__int16 v10; // [esp+6h] [ebp-Eh]
	__int16 v11; // [esp+8h] [ebp-Ch]
	__int64 v12; // [esp+Ch] [ebp-8h]

	if (*(x_DWORD *)x_BYTE_E3E54
		|| *(x_WORD *)&x_BYTE_E3E54[4]
		|| (v4 = sub_9F110(4), *(x_WORD *)&x_BYTE_E3E54[4] = WORD2(v4), (*(x_DWORD *)x_BYTE_E3E54 = v4) != 0)
		|| *(x_WORD *)&x_BYTE_E3E54[4])
	{
		__GS__ = *(x_WORD *)&x_BYTE_E3E54[4];
		__writegsx_WORD(*(unsigned int *)x_BYTE_E3E54, a4);
		v5 = sub_9F220(a3);
		__GS__ = *(x_WORD *)&x_BYTE_E3E54[4];
		__writegsx_WORD(*(x_DWORD *)x_BYTE_E3E54 + 2, v5);
		v9 = 23;
		v10 = sub_9F220(*(unsigned __int16 *)&x_BYTE_E3E54[4]);
		v11 = 0;
		sub_91F70_AIL_call_driver((AIL_DRIVER*)*a1, 1286, &v8, &v8);
		if (v8.AX != NULL)
		{
			WORD2(v12) = 0;
			LODWORD(v12) = 0;
		}
		else
		{
			v6 = v11;
			WORD2(v12) = sub_9F1D0(v10);
			LODWORD(v12) = v6;
		}
	}
	else
	{
		WORD2(v12) = 0;
		LODWORD(v12) = 0;
	}
	return v12;
}

//----- (0009F4F0) --------------------------------------------------------
VDI_CALL sub_9F4F0(int *a1, int a2, unsigned __int16 a3, unsigned __int16 a4)
{
	signed __int64 v4; // rax
	unsigned __int16 v5; // ax
	VDI_CALL result; // [esp+0h] [ebp-10h]
	__int16 v8; // [esp+4h] [ebp-Ch]
	__int16 v9; // [esp+6h] [ebp-Ah]
	__int16 v10; // [esp+8h] [ebp-8h]

	if (!*(x_DWORD *)x_BYTE_E3E54 && !*(x_WORD *)&x_BYTE_E3E54[4])
	{
		v4 = sub_9F110(4);
		*(x_WORD *)&x_BYTE_E3E54[4] = WORD2(v4);
		*(x_DWORD *)x_BYTE_E3E54 = v4;
		if (!(x_DWORD)v4 && !*(x_WORD *)&x_BYTE_E3E54[4])
		{
			result.AX = -1;
			return result;
		}
	}
	__GS__ = *(x_WORD *)&x_BYTE_E3E54[4];
	__writegsx_WORD(*(unsigned int *)x_BYTE_E3E54, a4);
	v5 = sub_9F220(a3);
	__GS__ = *(x_WORD *)&x_BYTE_E3E54[4];
	__writegsx_WORD(*(x_DWORD *)x_BYTE_E3E54 + 2, v5);
	v8 = 24;
	v9 = sub_9F220(*(unsigned __int16 *)&x_BYTE_E3E54[4]);
	v10 = 0;
	sub_91F70_AIL_call_driver((AIL_DRIVER*)*a1, 1286, &result, &result);
	return result;
}

//----- (0009F5E0) --------------------------------------------------------
VDI_CALL sub_9F5E0(int *a1, int a2, unsigned __int16 a3, unsigned __int16 a4)
{
	signed __int64 v4; // rax
	unsigned __int16 v5; // ax
	VDI_CALL result; // [esp+0h] [ebp-10h]
	__int16 v8; // [esp+4h] [ebp-Ch]
	__int16 v9; // [esp+6h] [ebp-Ah]
	__int16 v10; // [esp+8h] [ebp-8h]

	if (!*(x_DWORD *)x_BYTE_E3E54 && !*(x_WORD *)&x_BYTE_E3E54[4])
	{
		v4 = sub_9F110(4);
		*(x_WORD *)&x_BYTE_E3E54[4] = WORD2(v4);
		*(x_DWORD *)x_BYTE_E3E54 = v4;
		if (!(x_DWORD)v4 && !*(x_WORD *)&x_BYTE_E3E54[4])
		{
			result.AX = -1;
			return result;
		}
	}
	__GS__ = *(x_WORD *)&x_BYTE_E3E54[4];
	__writegsx_WORD(*(unsigned int *)x_BYTE_E3E54, a4);
	v5 = sub_9F220(a3);
	__GS__ = *(x_WORD *)&x_BYTE_E3E54[4];
	__writegsx_WORD(*(x_DWORD *)x_BYTE_E3E54 + 2, v5);
	v8 = 25;
	v9 = sub_9F220(*(unsigned __int16 *)&x_BYTE_E3E54[4]);
	v10 = 0;
	sub_91F70_AIL_call_driver((AIL_DRIVER*)*a1, 1286, &result, &result);
	return result;
}

//----- (0009F6D0) --------------------------------------------------------
VDI_CALL sub_9F6D0(int *a1, __int16 a2)
{
	VDI_CALL result; // [esp+0h] [ebp-10h]
	__int16 v4; // [esp+4h] [ebp-Ch]
	__int16 v5; // [esp+6h] [ebp-Ah]

	sub_9F170(*(int *)x_BYTE_E3E54, *(unsigned __int16 *)&x_BYTE_E3E54[4]);
	*(x_WORD *)&x_BYTE_E3E54[4] = 0;
	*(x_DWORD *)x_BYTE_E3E54 = 0;
	v4 = 18;
	v5 = a2;
	sub_91F70_AIL_call_driver((AIL_DRIVER*)*a1, 1286, &result, &result);
	return result;
}

//----- (0009F740) --------------------------------------------------------
void sub_9F740(char* a1)
{
	signed __int64 v1; // rax
	__int64 v2; // rax
	signed __int64 v3; // rax
	//char v4; // [esp+0h] [ebp-34h]
	char v5[6]; // [esp+14h] [ebp-20h]
	char v6[6]; // [esp+1Ch] [ebp-18h]
	unsigned int v7; // [esp+24h] [ebp-10h]
	char v8; // [esp+28h] [ebp-Ch]
	int v9; // [esp+2Ch] [ebp-8h]
	int i; // [esp+30h] [ebp-4h]

	if (x_BYTE_E37FC && !_stricmp(unk_180BE0, "SBAWE32.MDI") && !_stricmp(&x_BYTE_180C84_drivertype, "w"))
	{
		if (x_BYTE_E3815 == 1)
		{
			sub_9FA80();
			x_BYTE_E3815 = 0;
		}
		char bulltemp[512] = "Bullfrog";//fix it
		strcpy_s(bulltemp, 512, (const char*)a1);
		sprintf_s(printbuffer, 512, "sound//%s.sbk", bulltemp);
		x_DWORD_181E20 = sub_98817_open(printbuffer, 512);
		if (x_DWORD_181E20 != NULL)
		{
			v7 = x_filelength(x_DWORD_181E20);
			v1 = sub_9F110(512);
			x_WORD_181E30 = WORD2(v1);
			x_DWORD_181E2C = v1;
			if ((x_DWORD)v1 || x_WORD_181E30)
			{
				v9 = sub_9F280((int *)x_DWORD_180C7C);
				if (v9 != -1)
				{
					*(x_WORD *)&v5[4] = x_WORD_181E30;
					*(x_DWORD *)v5 = x_DWORD_181E2C;
					__writegsx_DWORD(x_DWORD_181E2C, 0);
					__writegsx_DWORD(*(x_DWORD *)v5 + 4, v7);
					if (sub_9F2E0((int *)x_DWORD_180C7C, *(int *)v5, *(unsigned __int16 *)&v5[4], 2u).AX == -1//fix
						&& !dos_read(x_DWORD_181E20, x_DWORD_181E2C, (unsigned __int16)x_WORD_181E30, 512, (x_DWORD)&v8))
					{
						v2 = sub_9F3D0((int *)x_DWORD_180C7C, x_DWORD_181E2C, x_WORD_181E30, 1u);
						*(x_WORD *)&v6[4] = WORD2(v2);
						*(x_DWORD *)v6 = v2;
						if ((x_DWORD)v2 || *(x_WORD *)&v6[4])
						{
							x_lseek(x_DWORD_181E20, __readgsx_DWORD(*(x_DWORD *)v6 + 2), 0);
							for (i = 0; (signed __int16)__readgsx_WORD(*(unsigned int *)v6) > i; i++)
							{
								if (dos_read(x_DWORD_181E20, x_DWORD_181E2C, (unsigned __int16)x_WORD_181E30, 512, (x_DWORD)&v8)
									|| sub_9F4F0((int *)x_DWORD_180C7C, x_DWORD_181E2C, x_WORD_181E30, 1u).AX != -1)//fix
								{
									return;
								}
							}
							v3 = sub_9F110(__readgsx_DWORD(*(x_DWORD *)v6 + 10));
							x_WORD_181E2A = WORD2(v3);
							x_DWORD_181E26 = v3;
							if ((x_DWORD)v3 || x_WORD_181E2A)
							{
								x_lseek((FILE*)x_DWORD_181E20, __readgsx_DWORD(*(x_DWORD *)v6 + 6), 0);
								if (!dos_read(
									x_DWORD_181E20,
									x_DWORD_181E26,
									(unsigned __int16)x_WORD_181E2A,
									__readgsx_DWORD(*(x_DWORD *)v6 + 10),
									(x_DWORD)&v8)
									&& sub_9F5E0((int *)x_DWORD_180C7C, x_DWORD_181E26, x_WORD_181E2A, 1u).AX == -1)//fix
								{
									x_BYTE_E3815 = 1;
									sub_98882_close((FILE*)x_DWORD_181E20);
								}
							}
						}
					}
				}
			}
		}
	}
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// 988DA: using guessed type x_DWORD filelength(x_DWORD);
// 98F5D: using guessed type x_DWORD stricmp(x_DWORD, x_DWORD);
// 99D46: using guessed type x_DWORD strcpy(x_DWORD, x_DWORD);
// AA7C0: using guessed type x_DWORD lseek(x_DWORD, x_DWORD, char);
// AD8A2: using guessed type x_DWORD dos_read(x_DWORD, char, x_DWORD, x_DWORD, x_DWORD);
// E37FC: using guessed type char x_BYTE_E37FC;
// E3815: using guessed type char x_BYTE_E3815;
// 180C7C: using guessed type int x_DWORD_180C7C;
// 180C84: using guessed type char x_BYTE_180C84_drivertype;
// 181E20: using guessed type int x_DWORD_181E20;
// 181E26: using guessed type int x_DWORD_181E26;
// 181E2A: using guessed type __int16 x_WORD_181E2A;
// 181E2C: using guessed type int x_DWORD_181E2C;
// 181E30: using guessed type __int16 x_WORD_181E30;

//----- (0009FA80) --------------------------------------------------------
void sub_9FA80()
{
	if (x_BYTE_E37FC && !_stricmp(unk_180BE0, "SBAWE32.MDI") && !_stricmp(&x_BYTE_180C84_drivertype, "w"))
	{
		sub_9F6D0((int *)x_DWORD_180C7C, 1);
		sub_9F170(x_DWORD_181E2C, x_WORD_181E30);
		sub_9F170(x_DWORD_181E26, x_WORD_181E2A);
		x_BYTE_E3815 = 0;
	}
}
// 98F5D: using guessed type x_DWORD stricmp(x_DWORD, x_DWORD);
// E37FC: using guessed type char x_BYTE_E37FC;
// E3815: using guessed type char x_BYTE_E3815;
// 180C7C: using guessed type int x_DWORD_180C7C;
// 180C84: using guessed type char x_BYTE_180C84_drivertype;
// 181E26: using guessed type int x_DWORD_181E26;
// 181E2A: using guessed type __int16 x_WORD_181E2A;
// 181E2C: using guessed type int x_DWORD_181E2C;
// 181E30: using guessed type __int16 x_WORD_181E30;

//----- (000A0B24) --------------------------------------------------------
int sub_A0B24(int a1)
{
	if ((unsigned __int16)a1 < 0x3C4u && (unsigned __int16)a1 >= 0x3C0u)
	{
		if ((unsigned __int16)a1 <= 0x3C0u)
		{
			x_inp(986);
			x_outp(960, BYTE2(a1) | 0x20);
			return x_outp(960, SHIBYTE(a1));
		}
		if ((unsigned __int16)a1 >= 0x3C2u)
			return x_outp((unsigned __int16)a1, SHIBYTE(a1));
	}
	x_outp((unsigned __int16)a1, SBYTE2(a1));
	return x_outp((unsigned __int16)a1 + 1, SHIBYTE(a1));
}
// A0ED7: using guessed type x_DWORD outp(x_DWORD, char);
// A0EE1: using guessed type x_DWORD inp(x_DWORD);

//----- (000A0BB0) --------------------------------------------------------
int sub_A0BB0(int *a1, int a2)
{
	int *v2; // ebx
	int v3; // esi
	char v4; // di
	int result; // eax
	int v6; // ST04_4

	v2 = a1;
	v3 = a2;
	x_outp(980, 17);
	v4 = x_inp(981);
	x_outp(980, 17);
	for (result = x_outp(981, v4 & 0x7F); --v3 != -1; result = sub_A0B24(v6))
	{
		v6 = *v2;
		++v2;
	}
	return result;
}
// A0ED7: using guessed type x_DWORD outp(x_DWORD, char);
// A0EE1: using guessed type x_DWORD inp(x_DWORD);

//----- (000A0D2C) --------------------------------------------------------
void sub_A0D2C_VGA_get_pallette(Bit8u* buffer)
{
	Bit8u* tempbuffer = VGA_Get_pallette();
	memcpy(buffer, tempbuffer, 768);
	/*int v2; // [esp+4h] [ebp-4h]

	//fix it
	v2 = 0;
	//fix it

	__outx_BYTE(0x3C7u, 0);
	__inx_BYTEstring(0x3C9u, a1, 0x300u);
	return v2;*/
}

//----- (000A0D50) --------------------------------------------------------
void sub_A0D50_set_viewport(__int16 a1, __int16 a2, __int16 a3, __int16 a4)
{
	int result; // eax

	x_DWORD_18063C_sprite_sizex = a1;
	x_DWORD_180650_positiony = a2;
	x_DWORD_180648_map_resolution2_x = a3;
	x_DWORD_180644_map_resolution2_y = a4;
	x_DWORD_180634_screen_width = a3 + a1;
	//result = a4;
	x_DWORD_180630_screen_height = a4 + a2;
	//return result;
}
// 180630: using guessed type int x_DWORD_180630_screen_height;
// 180634: using guessed type int x_DWORD_180634_screen_width;
// 18063C: using guessed type int x_DWORD_18063C_sprite_sizex;
// 180644: using guessed type int x_DWORD_180644_map_resolution2_y;
// 180648: using guessed type int x_DWORD_180648_map_resolution2_x;
// 180650: using guessed type int x_DWORD_180650_positiony;

//----- (000A0EEC) --------------------------------------------------------
void sub_A0EEC_s_plus2()
{
	x_DWORD_E3FF2++;
}
// E3FF2: using guessed type int x_DWORD_E3FF2;

//----- (000A0EF9) --------------------------------------------------------
void sub_A0EF9_s_minus2()
{
	x_DWORD_E3FF2--;
}
// E3FF2: using guessed type int x_DWORD_E3FF2;

//----- (000A0F06) --------------------------------------------------------
int sub_A0F06(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
	int v7; // edx
	unsigned int v8; // edi
	unsigned int v9; // eax
	unsigned int v10; // edi
	signed __int32 v11; // eax
	signed __int32 v12; // ecx
	signed __int32 v13; // eax
	int v15; // eax
	int v16; // [esp-30h] [ebp-30h]
	int v17; // [esp-2Ch] [ebp-2Ch]
	int v18; // [esp-28h] [ebp-28h]
	int v19; // [esp-24h] [ebp-24h]
	int v20; // [esp-20h] [ebp-20h]
	int v21; // [esp-1Ch] [ebp-1Ch]
	int v22; // [esp-18h] [ebp-18h]
	int v23; // [esp-14h] [ebp-14h]
	void **v24; // [esp-10h] [ebp-10h]
	int v25; // [esp-Ch] [ebp-Ch]
	int v26; // [esp-8h] [ebp-8h]
	int v27; // [esp-4h] [ebp-4h]
	void *retaddr[2]; // [esp+0h] [ebp+0h]

	if (x_DWORD_E3FEE)
	{
		v27 = a1;
		//__outx_BYTE(0x20u, 0x20u);
		//__asm { iret }
	}
	v27 = a7;
	v26 = a6;
	v25 = a5;
	v24 = retaddr;
	v23 = a4;
	v22 = a3;
	v21 = a2;
	v20 = a1;
	v19 = (unsigned __int16)__DS__;
	v18 = (unsigned __int16)__ES__;
	v17 = (unsigned __int16)__FS__;
	v16 = (unsigned __int16)__GS__;
	__DS__ = x_WORD_E3FF6;
	++x_DWORD_E3FEE;
	x_WORD_E4A04 = __SS__;
	x_DWORD_E4A08 = (int)&v16;
	v7 = x_DWORD_E3FEA;
	v8 = 0;
	do
	{
		if (x_DWORD_E3E9C[v8] == 2)
		{
			v9 = v7 + x_DWORD_E3EDC[v8];
			if (v9 >= x_DWORD_E3F1C[v8])
			{
				v9 -= x_DWORD_E3F1C[v8];
				++x_DWORD_E3F5C[v8];
			}
			x_DWORD_E3EDC[v8] = v9;
		}
		++v8;
	} while (v8 < 16);
	//__outx_BYTE(0x20u, 0x20u);
	_enable();
	if (x_DWORD_E3FF2 <= 0)
	{
		v10 = 0;
		do
		{
			while (x_DWORD_E3F5C[v10])
			{
				--x_DWORD_E3F5C[v10];
				x_DWORD_E3E5C_timer[v10]((HMDIDRIVER)x_DWORD_E3F9C[v10]/*, v7, a4*/);//fix maybe
			}
			++v10;
		} while (v10 < 15);
	}
	if (!x_DWORD_E3F98)
	{
		--x_DWORD_E3FEE;
		v15 = *MK_FP(x_WORD_E4A04, (unsigned int)&v20);
		//__asm { iret }
	}
	--x_DWORD_E3F98;
	--x_DWORD_E3FEE;
	v11 = (unsigned __int16)x_WORD_E3FE0;
	v12 = x_InterlockedExchange((long*)&v26, x_DWORD_E3FDC);
	v13 = x_InterlockedExchange((long*)&v27, v11);
	return 0;//fix it: return MK_FP((unsigned int)retaddr[0], (unsigned int)retaddr[0])(v13, v27, v26, v12);
}
// A0F06: could not find valid save-restore pair for ebp
// A0F06: could not find valid save-restore pair for edi
// A0F06: could not find valid save-restore pair for esi
// E3E5C: using guessed type int x_DWORD_E3E5C[];
// E3E9C: using guessed type int x_DWORD_E3E9C[];
// E3EDC: using guessed type int x_DWORD_E3EDC[];
// E3F1C: using guessed type int x_DWORD_E3F1C[];
// E3F5C: using guessed type int x_DWORD_E3F5C[];
// E3F98: using guessed type int x_DWORD_E3F98;
// E3F9C: using guessed type int x_DWORD_E3F9C[];
// E3FDC: using guessed type int x_DWORD_E3FDC;
// E3FE0: using guessed type __int16 x_WORD_E3FE0;
// E3FEA: using guessed type int x_DWORD_E3FEA;
// E3FEE: using guessed type int x_DWORD_E3FEE;
// E3FF2: using guessed type int x_DWORD_E3FF2;
// E3FF6: using guessed type __int16 x_WORD_E3FF6;
// E4A04: using guessed type __int16 x_WORD_E4A04;
// E4A08: using guessed type int x_DWORD_E4A08;

//----- (000A102C) --------------------------------------------------------
char sub_A102C(int a1)//fix
{
	unsigned int v1; // et0
	char result; // al
	unsigned int v3; // [esp-4h] [ebp-10h]
	void *retaddr; // [esp+10h] [ebp+4h]

	//fix it
	retaddr = 0;
	//fix it

	v1 = x__readeflags();
	v3 = v1;
	_disable();
	//__outx_BYTE(0x43u, 0x36u);
	x_DWORD_E3FE6 = a1;
	//__outx_BYTE(0x40u, a1);
	result = BYTE1(a1);
	//__outx_BYTE(0x40u, BYTE1(a1));
	_disable();
	if (BYTE1(retaddr) & 2)
		_enable();
	x__writeeflags(v3);
	return result;
}
// E3FE6: using guessed type int x_DWORD_E3FE6;

//----- (000A105C) --------------------------------------------------------
char sub_A105C(unsigned int a1)
{
	int v1; // eax

	v1 = 0;
	if (a1 < 0xD68D)
		v1 = 10000 * (unsigned __int64)a1 / 0x20BC;
	return sub_A102C(v1);
}

//----- (000A108F) --------------------------------------------------------
void sub_A108F()
{
	unsigned int v0; // ecx
	unsigned int v1; // edi

	sub_91BD0_s_plus();
	v0 = -1;
	v1 = 0;
	do
	{
		if (x_DWORD_E3E9C[v1] && x_DWORD_E3F1C[v1] < v0)
			v0 = x_DWORD_E3F1C[v1];
		++v1;
	} while (v1 < 16);
	if (v0 != x_DWORD_E3FEA)
	{
		x_DWORD_E3FEA = v0;
		sub_A105C(v0);
		memset(x_DWORD_E3EDC, 0, 0x40u);
	}
	sub_91BF0_s_minus();
}
// E3E9C: using guessed type int x_DWORD_E3E9C[];
// E3EDC: using guessed type int x_DWORD_E3EDC[];
// E3F1C: using guessed type int x_DWORD_E3F1C[];
// E3FEA: using guessed type int x_DWORD_E3FEA;

//----- (000A10F4) --------------------------------------------------------
void sub_A10F4_sound_proc_irq()
{
	unsigned int v0; // et0
	unsigned __int16 v1; // dx
	unsigned int v2; // [esp-8h] [ebp-14h]

	//fix
	v1 = 0;
	//fix

	v0 = x__readeflags();
	v2 = v0;
	_disable();
	x_WORD_E3FF6 = __DS__;
	sub_A18BE();
	x_DWORD_E3FEE = 0;
	x_DWORD_E3FF2 = 0;
	x_DWORD_E3FEA = -1;
	x_DWORD_E3FF8 = -1;
	memset(x_DWORD_E3E9C, 0, 0x40u);
	memset(x_DWORD_E3EDC, 0, 0x40u);
	memset(x_DWORD_E3F1C, 0, 0x40u);
	memset(x_DWORD_E3F5C, 0, 0x40u);
	/*__asm
	{
	  int     31h; DPMI Services   ax=func xxxxh //eax=200,ebx=8 - system timer?
	  int     21h; DOS - 2+ - GET INTERRUPT VECTOR
	}*/
	x_DWORD_E3FDC = 8;
	x_WORD_E3FE0 = __DS__;
	x_DWORD_E3FE2 = v1;
	// fix it:__asm { int     21h; DOS - SET INTERRUPT VECTOR }
	x_DWORD_E3ED8 = 2;
	sub_92890_AIL_set_timer_period(60, 54925);
	_disable();
	if (v2 & 0x200)
		_enable();
	x__writeeflags(v2);
}
// E3E9C: using guessed type int x_DWORD_E3E9C[];
// E3ED8: using guessed type int x_DWORD_E3ED8;
// E3EDC: using guessed type int x_DWORD_E3EDC[];
// E3F1C: using guessed type int x_DWORD_E3F1C[];
// E3F5C: using guessed type int x_DWORD_E3F5C[];
// E3FDC: using guessed type int x_DWORD_E3FDC;
// E3FE0: using guessed type __int16 x_WORD_E3FE0;
// E3FE2: using guessed type int x_DWORD_E3FE2;
// E3FEA: using guessed type int x_DWORD_E3FEA;
// E3FEE: using guessed type int x_DWORD_E3FEE;
// E3FF2: using guessed type int x_DWORD_E3FF2;
// E3FF6: using guessed type __int16 x_WORD_E3FF6;
// E3FF8: using guessed type int x_DWORD_E3FF8;

//----- (000A11E2) --------------------------------------------------------
signed int sub_A11E2()
{
	unsigned int v0; // et0
	signed int result; // eax
	unsigned int v2; // [esp-4h] [ebp-10h]

	v0 = x__readeflags();
	v2 = v0;
	_disable();
	sub_A102C(0);
	result = 9480;
	// fix it:__asm { int     21h; DOS - SET INTERRUPT VECTOR }
	_disable();
	if (v2 & 0x200)
		_enable();
	x__writeeflags(v2);
	return result;
}
// E3FDC: using guessed type int x_DWORD_E3FDC;
// E3FE0: using guessed type __int16 x_WORD_E3FE0;

//----- (000A121D) --------------------------------------------------------
Bit16u sub_A121D_AIL_API_get_real_vect(Bit32u vectnum/*int a1, __int16 a2, int a3, int a4*/)
{
	//Bit8u* v4; // ecx
	//v4 = 0;
	//fix it:__asm { int     31h; DPMI Services   ax=func xxxxh }
	/*v4 = a4 << 16;
	LOWORD(v4) = a2;*/
	//fix it:__asm { int     21h; DOS - 2+ - GET INTERRUPT VECTOR }
	return ac_get_real_vect(vectnum);
}

//----- (000A1249) --------------------------------------------------------
void sub_A1249_AIL_API_set_real_vect(Bit32u vectnum, Bit16u real_ptr)
{
	ac_set_real_vect(vectnum, real_ptr);
	//signed int result; // eax

	//result = 513;
	//fix it:__asm { int     31h; DPMI Services   ax=func xxxxh }
	//return result;
}

//----- (000A12C5) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed int sub_A12C5_sound_proc_irq(int a1, int a2, __int16 a3)
{
	signed int result; // eax

	if (x_DWORD_E3FF8 == -1)
	{
		/*__asm
		{
		  int     31h; DPMI Services   ax=func xxxxh
		  int     31h; DPMI Services   ax=func xxxxh
		  int     31h; DPMI Services   ax=func xxxxh
		  lar     ecx, edx
		  int     31h; DPMI Services   ax=func xxxxh
		  int     31h; DPMI Services   ax=func xxxxh
		  int     31h; DPMI Services   ax=func xxxxh
		  int     31h; DPMI Services   ax=func xxxxh
		  lar     ecx, edx
		  int     31h; DPMI Services   ax=func xxxxh
		  int     31h; DPMI Services   ax=func xxxxh
		  int     31h; DPMI Services   ax=func xxxxh
		  int     31h; DPMI Services   ax=func xxxxh
		  lar     ecx, edx
		  int     31h; DPMI Services   ax=func xxxxh
		  int     31h; DPMI Services   ax=func xxxxh
		  int     31h; DPMI Services   ax=func xxxxh
		  int     31h; DPMI Services   ax=func xxxxh
		  lar     ecx, edx
		  int     31h; DPMI Services   ax=func xxxxh
		}*/
		x_DWORD_A128C = (int)((char *)&unk_E4004 - ((unsigned int)&unk_E4004 & 0xFFFFFFF0) + 512);
		x_WORD_A1286 = 0;
		x_WORD_A1277 = 0;
		x_WORD_A12AC = 0;
		x_WORD_A12B3 = a3;
		x_WORD_A12A2 = (__int16)((char *)&x_DWORD_A1270 - ((unsigned int)&x_DWORD_A1270 & 0xFFFFFFF0) + 74);
		x_DWORD_E3FF8 = a1;
		//fix it:__asm { int     31h; DPMI Services   ax=func xxxxh }
		x_DWORD_E3FFC = 49407;
		x_DWORD_E4000 = __DS__;
		result = 517;
		//fix it:__asm { int     31h; DPMI Services   ax=func xxxxh }
	}
	return result;
}
// A1462: write access to const memory at A128C has been detected
// A146A: write access to const memory at A1286 has been detected
// A1473: write access to const memory at A1277 has been detected
// A147C: write access to const memory at A12AC has been detected
// A1485: write access to const memory at A12B3 has been detected
// A1493: write access to const memory at A12A2 has been detected
// A1270: using guessed type int x_DWORD_A1270;
// A1277: using guessed type __int16 x_WORD_A1277;
// A1286: using guessed type __int16 x_WORD_A1286;
// A128C: using guessed type int x_DWORD_A128C;
// A12A2: using guessed type __int16 x_WORD_A12A2;
// A12AC: using guessed type __int16 x_WORD_A12AC;
// A12B3: using guessed type __int16 x_WORD_A12B3;
// E3FF8: using guessed type int x_DWORD_E3FF8;
// E3FFC: using guessed type int x_DWORD_E3FFC;
// E4000: using guessed type int x_DWORD_E4000;

//----- (000A14DB) --------------------------------------------------------
void sub_A14DB_AIL_API_restore_USE16_ISR(int a1)
{
	//signed int result; // eax

	if (a1 != -1 && a1 == x_DWORD_E3FF8)
	{
		//result = 517;
		//fix it:__asm { int     31h; DPMI Services   ax=func xxxxh }
		x_DWORD_E3FF8 = -1;
	}
	//return result;
}
// E3FF8: using guessed type int x_DWORD_E3FF8;
// E3FFC: using guessed type int x_DWORD_E3FFC;
// E4000: using guessed type int x_DWORD_E4000;

//----- (000A1520) --------------------------------------------------------
unsigned int sub_A1520()
{
	unsigned int v0; // et0
	unsigned int result; // eax

	v0 = x__getcallerseflags();
	result = v0;
	_disable();
	return result;
}

//----- (000A1524) --------------------------------------------------------
void sub_A1524(unsigned int a1)
{
	void *retaddr; // [esp+4h] [ebp+4h]

	//fix it
	retaddr = 0;
	//fix it

	_disable();
	if (BYTE1(retaddr) & 2)
		_enable();
	x__writeeflags(a1);
}

//----- (000A158B) --------------------------------------------------------
Bit32s sub_A158B_AIL_API_call_driver(AIL_DRIVER* drvr, Bit32s fn, VDI_CALL* in, VDI_CALL* out)//28258b
//int sub_A158B_AIL_API_call_driver(Bit32s* drvr, __int16 a2, x_WORD *a3, x_WORD *a4)
{
	return ac_sound_call_driver(drvr, fn, in, out);
	/*__int16 v8; // dx
	__int16 v9; // si
	__int16 v10; // di
	__int16 v11; // cx
	__int16 v12; // dx
	__int16 v13; // si
	__int16 v14; // di
	int v15; // ST00_4
	__int16 v17; // [esp+Eh] [ebp-3Ah]
	Bit8u v18[0x30]; // [esp+10h] [ebp-38h]
	__int16 v19; // [esp+1Eh] [ebp-2Ah]
	__int16 v20; // [esp+22h] [ebp-26h]
	__int16 v21; // [esp+26h] [ebp-22h]
	__int16 v22; // [esp+2Ah] [ebp-1Eh]
	__int16 v23; // [esp+2Eh] [ebp-1Ah]
	__int16 v24; // [esp+30h] [ebp-18h]
	__int16 v25; // [esp+32h] [ebp-16h]

	//fix
	v20 = 0;
	v21 = 0;
	//fix

	sub_91BD0_s_plus();
	memset(&v17, 0, sizeof(v17));
	_CF =0;//fix it:_CF = __CFSHR__(50, 2);
	_ZF = 0;
	_SF = 0;
	memset(v18, 0, 0x30u);
	v25 = 0;
	v24 = 0;
	// fix this - __asm { pushfw }
	v23 = 0;
	v22 = fn;
	if ( in )
	{
	  v8 = in->DI;
	  v9 = in->DX;
	  v10 = in->SI;
	  v21 = in->CX;
	  v20 = v8;
	  HIWORD(v18) = v9;
	  v17 = v10;
	}
	v19 = *(x_WORD *)(*(x_DWORD *)(drvr + 8) + 50);
	//fix it:__asm { int     31h; DPMI Services   ax=func xxxxh }
	if (out)
	{
	  v11 = v21;
	  v12 = v20;
	  v13 = HIWORD(v18);
	  v14 = v17;
	  out->AX = v22;
	  out->CX = v11;
	  out->DI = v12;
	  out->DX = v13;
	  out->SI = v14;
	  out->BX = v19;
	}
	v15 = v22;
	sub_91BF0_s_minus();
	return v15;*/
}

//----- (000A1665) --------------------------------------------------------
void sub_A1665_AIL_API_delay(int a1)
{
	mydelay(a1);
	/*unsigned __int8 result; // al
	unsigned __int16 v2; // dx
	int i; // ecx
	unsigned __int8 v4; // al

	result = MEMORY[0x463];
	v2 = MEMORY[0x463] + 6;
	for ( i = a1; i; i-- )
	{
	  do
		v4 = __inx_BYTE(v2);
	  while ( !(v4 & 8) );
	  do
		result = __inx_BYTE(v2);
	  while ( result & 8 );
	}
	return result;*/
}

//----- (000A16A2) --------------------------------------------------------
int sub_A16A2()
{
	return x_DWORD_E3FEE;
}
// E3FEE: using guessed type int x_DWORD_E3FEE;

//----- (000A16AE) --------------------------------------------------------
HTIMER sub_A16AE_register_timer(AILTIMERCB callback_fn)
{
	unsigned int v1; // eax
	unsigned int v2; // ST00_4

	sub_91BD0_s_plus();
	v1 = 0;
	while (*(int *)((char *)x_DWORD_E3E9C + v1))
	{
		v1 += 4;
		if (v1 >= 0x3C)
		{
			v1 = -1;
			goto LABEL_6;
		}
	}
	x_DWORD_E3E9C[v1] = 1;
	x_DWORD_E3E5C_timer[v1] = callback_fn;
LABEL_6:
	v2 = v1;
	sub_91BF0_s_minus();
	return v2;
}
// E3E5C: using guessed type int x_DWORD_E3E5C[];
// E3E9C: using guessed type int x_DWORD_E3E9C[];

//----- (000A16F5) --------------------------------------------------------
signed __int32 sub_A16F5_AIL_API_set_timer_user(int a1, signed __int32 a2)
{
	signed __int32 v2; // eax
	signed __int32 v3; // ST00_4

	sub_91BD0_s_plus();
	if (a1 != -1)
		v2 = x_InterlockedExchange((long*)(int *)((char *)x_DWORD_E3F9C + a1), a2);
	v3 = v2;
	sub_91BF0_s_minus();
	return v3;
}
// E3F9C: using guessed type int x_DWORD_E3F9C[];

//----- (000A171D) --------------------------------------------------------
void sub_A171D_release_timer_handle(Bit32s a1)
{
	sub_91BD0_s_plus();
	if (a1 != -1)
		*(int *)((char *)x_DWORD_E3E9C + a1) = 0;
	sub_91BF0_s_minus();
}
// E3E9C: using guessed type int x_DWORD_E3E9C[];

//----- (000A1744) --------------------------------------------------------
void sub_A1744_AIL_API_release_all_timers()
{
	int v0; // esi
	unsigned __int8 v1; // of

	sub_91BD0_s_plus();
	v0 = 56;
	do
	{
		sub_92DC0_AIL_release_timer_handle(v0);
		v1 = __OFSUB__(v0, 4);
		v0 -= 4;
	} while (!((v0 < 0) ^ v1));
	sub_91BF0_s_minus();
}

//----- (000A1768) --------------------------------------------------------
void sub_A1768_start_timer(HTIMER timer)
{
	sub_91BD0_s_plus();
	if (timer != -1 && *(int *)((char *)x_DWORD_E3E9C + timer) == 1)
		*(int *)((char *)x_DWORD_E3E9C + timer) = 2;
	sub_91BF0_s_minus();
}
// E3E9C: using guessed type int x_DWORD_E3E9C[];

//----- (000A1798) --------------------------------------------------------
void sub_A1798()
{
	int v0; // esi
	unsigned __int8 v1; // of

	sub_91BD0_s_plus();
	v0 = 56;
	do
	{
		sub_92BA0_AIL_start_timer(v0);
		v1 = __OFSUB__(v0, 4);
		v0 -= 4;
	} while (!((v0 < 0) ^ v1));
	sub_91BF0_s_minus();
}

//----- (000A17BC) --------------------------------------------------------
void sub_A17BC_stop_timer(HTIMER timer)
{
	sub_91BD0_s_plus();
	if (timer != -1 && *(int *)((char *)x_DWORD_E3E9C + timer) == 2)
		*(int *)((char *)x_DWORD_E3E9C + timer) = 1;
	sub_91BF0_s_minus();
}
// E3E9C: using guessed type int x_DWORD_E3E9C[];

//----- (000A17EC) --------------------------------------------------------
void sub_A17EC()
{
	int v0; // esi
	unsigned __int8 v1; // of

	sub_91BD0_s_plus();
	v0 = 56;
	do
	{
		sub_92CB0_AIL_stop_timer(v0);
		v1 = __OFSUB__(v0, 4);
		v0 -= 4;
	} while (!((v0 < 0) ^ v1));
	sub_91BF0_s_minus();
}

//----- (000A1810) --------------------------------------------------------
void sub_A1810_set_timer_period(HTIMER timer, Bit32u microseconds)
{
	sub_91BD0_s_plus();
	*(int *)((char *)x_DWORD_E3F1C + timer) = microseconds;
	*(int *)((char *)x_DWORD_E3EDC + timer) = 0;
	sub_A108F();
	sub_91BF0_s_minus();
}
// E3EDC: using guessed type int x_DWORD_E3EDC[];
// E3F1C: using guessed type int x_DWORD_E3F1C[];

//----- (000A1840) --------------------------------------------------------
void sub_A1840_AIL_API_set_timer_frequency(HTIMER timer, Bit32u hertz)
{
	sub_91BD0_s_plus();
	sub_92890_AIL_set_timer_period(timer, (unsigned int)&unk_F4240 / hertz);
	sub_91BF0_s_minus();
}

//----- (000A1870) --------------------------------------------------------
void sub_A1870(int a1, unsigned int a2)
{
	int v2; // eax

	sub_91BD0_s_plus();
	if (a2)
		v2 = 10000 * (unsigned __int64)a2 / 0x2E9C;
	else
		v2 = 54925;
	sub_92890_AIL_set_timer_period(a1, v2);
	sub_91BF0_s_minus();
}

//----- (000A18B2) --------------------------------------------------------
int sub_A18B2()
{
	return x_DWORD_E3FE6;
}
// E3FE6: using guessed type int x_DWORD_E3FE6;

//----- (000A18BE) --------------------------------------------------------
void sub_A18BE()
{
	//sub_9D590_lock_linear_region((Bit8u*)x_DWORD_E3E5C, (unsigned int)x_BYTE_E4A0C);
	//sub_9D590_lock_linear_region((Bit8u*)sub_A0EEC_s_plus2, (unsigned int)sub_A18BE);
}
// E3E5C: using guessed type int x_DWORD_E3E5C[];

//----- (000A1F90) --------------------------------------------------------
void sub_A1F90()
{
	//bool result; // eax

	if (!x_DWORD_E4A90)
	{
		sub_9D590_lock_linear_region((Bit8u*)sub_A1F90, (unsigned int)sub_A4260);
		sub_9D710((Bit8u*)x_BYTE_E4A0C, 128);
		sub_9D710((Bit8u*)&x_DWORD_E4A8C, 4);
		sub_9D710((Bit8u*)&x_DWORD_181E94, 4);
		sub_9D710((Bit8u*)&unk_181E80, 12);
		sub_9D710((Bit8u*)&x_DWORD_181E9C, 4);
		sub_9D710((Bit8u*)&x_DWORD_181EA0, 4);
		sub_9D710((Bit8u*)&x_DWORD_181E90, 4);
		sub_9D710((Bit8u*)&x_DWORD_181E98, 4);
		sub_9D710((Bit8u*)&x_DWORD_181E8C, 4);
		sub_B0C46();
		x_DWORD_E4A90 = 1;
	}
	//return result;
}
// E4A8C: using guessed type int x_DWORD_E4A8C;
// E4A90: using guessed type int x_DWORD_E4A90;
// 181E8C: using guessed type int x_DWORD_181E8C;
// 181E90: using guessed type int x_DWORD_181E90;
// 181E94: using guessed type int x_DWORD_181E94;
// 181E98: using guessed type int x_DWORD_181E98;
// 181E9C: using guessed type int x_DWORD_181E9C;
// 181EA0: using guessed type int x_DWORD_181EA0;

//----- (000A2070) --------------------------------------------------------
void sub_A2070(HDIGDRIVER a1)//283070
{
	VDI_CALL v2; // [esp+0h] [ebp-Ch]
	__int16 v3; // [esp+4h] [ebp-8h]
	__int16 v4; // [esp+6h] [ebp-6h]

	/*
	cx=5622
	dx=a20002
	si=2b6f44
	di=35001a
	*/

	if (!a1->playing_21)
	{
		v4 = a1->hw_format_6;
		v3 = a1->DMA_rate_5;
		sub_91F70_AIL_call_driver(a1->drvr_0, 1025, &v2, 0);
		a1->playing_21 = 1;
	}
}

//----- (000A20D0) --------------------------------------------------------
void sub_A20D0(HDIGDRIVER a1)//2830d0
{
	if (a1->playing_21)
	{
		sub_91F70_AIL_call_driver(a1->drvr_0, 1026, 0, 0);
		a1->playing_21 = 0;
	}
}

//----- (000A2110) --------------------------------------------------------
void sub_A2110(HSAMPLE S)//283110
{
	//int result; // eax
	//int *v2; // edx
	//int *v3; // edx
	//int *v4; // edx
	//int *v5; // edx
	//int *v6; // edx
	//int *v7; // edx
	//int *v8; // edx
	//int *v9; // edx
	//int *v10; // edx
	int v11; // [esp+0h] [ebp-24h]
	int v12; // [esp+4h] [ebp-20h]
	int v13; // [esp+8h] [ebp-1Ch]
	//int v14; // [esp+Ch] [ebp-18h]
	int v15; // [esp+14h] [ebp-10h]
	int v16; // [esp+18h] [ebp-Ch]
	int v17; // [esp+1Ch] [ebp-8h]
	signed int l; // [esp+20h] [ebp-4h]
	signed int m; // [esp+20h] [ebp-4h]
	signed int n; // [esp+20h] [ebp-4h]
	signed int i; // [esp+20h] [ebp-4h]
	signed int j; // [esp+20h] [ebp-4h]
	signed int k; // [esp+20h] [ebp-4h]

	if (S->volume_16 <= 127)
	{
		if (S->volume_16 < 0)
			S->volume_16 = 0;
	}
	else
	{
		S->volume_16 = 127;
	}
	if (S->pan_17 <= 127)
	{
		if (S->pan_17 < 0)
			S->pan_17 = 0;
	}
	else
	{
		S->pan_17 = 127;
	}
	//v14 = S->sam_var17_volume_pan;
	v17 = S->sam_var[26] * S->pan_17 / 127;
	if (v17 < 0)
		v17 = 0;
	if (v17 > 127)
		v17 = 127;
	if (S->format_13 != 1 && S->format_13 != 3)
	{//set volume table
		if (v17)
			v17++;
		if (S->sam_var[6] != 2
			&& S->sam_var[6] != 3
			&& (S->sam_var[6] && S->sam_var[6] != 1 || S->format_13 != 2 && S->format_13 != 3))
		{
			//v11 = (int)&S->sam_varw18;
			v11 = 0;
			//result = (int)S;
			if (S->flags_14 & 1)
			{
				for (i = 0; i < 32768; i += 256)
				{
					//result = v17 * i >> 7;
					/*v8 = */S->vol_scale_18[0][v11] = v17 * i >> 7;
					v11++;
					//*v8 = v17 * i >> 7;
				}
				for (j = -32768; j < 0; j += 256)
				{
					//result = v17 * i >> 7;
					/*v8 = */S->vol_scale_18[0][v11] = v17 * j >> 7;
					v11++;
					//*v8 = v17 * i >> 7;
				}
			}
			else
			{
				for (k = -32768; k < 32768; k += 256)
				{
					//result = v17 * i >> 7;
					/*v8 = */S->vol_scale_18[0][v11] = v17 * k >> 7;
					v11++;
					//*v8 = v17 * i >> 7;
				}
			}
		}
		else
		{
			//v13 = (int)&S->sam_varw18;
			//v12 = (int)&S->sam_var[274];
			v13 = 0;
			v12 = 0;
			v16 = x_BYTE_E4A0C[127 - S->pan_17];
			v15 = x_BYTE_E4A0C[S->pan_17];
			//result = (int)&S;
			if (S->flags_14 & 1)
			{
				for (l = 0; l < 32768; l += 256)
				{
					S->vol_scale_18[0][v13] = v16 * (v17 * l >> 7) >> 7;
					v13++;
					/*
								  v2 = (int *)v13;
								  v13 += 4;
								  *v2 = v16 * (v17 * l >> 7) >> 7;*/
								  //result = v15 * (v17 * l >> 7) >> 7;
					S->vol_scale_18[0][v12] = v15 * (v17 * l >> 7) >> 7;
					v12++;
					/* v3 = (int *)v12;
					 v12 += 4;
					 *v3 = v15 * (v17 * l >> 7) >> 7;*/
				}
				for (m = -32768; m < 0; m += 256)
				{
					S->vol_scale_18[0][v13] = v16 * (v17 * m >> 7) >> 7;
					v13++;
					/*v4 = (int *)v13;
					v13 += 4;
					*v4 = v16 * (v17 * m >> 7) >> 7;*/
					//result = v15 * (v17 * m >> 7) >> 7;
					S->vol_scale_18[0][v12] = v15 * (v17 * m >> 7) >> 7;
					v12++;
					/*v5 = (int *)v12;
					v12 += 4;
					*v5 = v15 * (v17 * m >> 7) >> 7;*/
				}
			}
			else
			{
				for (n = -32768; n < 32768; n += 256)
				{
					S->vol_scale_18[0][v13] = v15 * (v17 * n >> 7) >> 7;
					v13++;
					/*
				  v6 = (int *)v13;
				  v13 += 4;
				  *v6 = v16 * (v17 * n >> 7) >> 7;*/
				  //result = v15 * (v17 * n >> 7) >> 7;
					S->vol_scale_18[0][v12] = v15 * (v17 * n >> 7) >> 7;;
					v12++;
					/*
				  v7 = (int *)v12;
				  v12 += 4;
				  *v7 = v15 * (v17 * n >> 7) >> 7;*/
				}
			}
		}
	}
	else
	{//set fix volume
		S->vol_scale_18[0][0] = v17 * x_BYTE_E4A0C[127 - S->pan_17] / 127;
		//result = v17 * (unsigned __int8)x_BYTE_E4A0C[v14] / 127;
		S->sam_var[274] = v17 * x_BYTE_E4A0C[S->pan_17] / 127;
	}
	//return result;
}

//----- (000A2650) --------------------------------------------------------
int sub_A2650(HDIGDRIVER a1)//283650
{
	int v1; // eax
	Bit32s v2; // eax
	unsigned int v4; // [esp+0h] [ebp-44h]
	unsigned int v5; // [esp+8h] [ebp-3Ch]
	int v6[4]; // [esp+Ch] [ebp-38h]
	//int v7; // [esp+10h] [ebp-34h]//1
	//int v8; // [esp+14h] [ebp-30h]//2
	//int v9; // [esp+18h] [ebp-2Ch]//3
	int v10; // [esp+1Ch] [ebp-28h]
	int v11; // [esp+20h] [ebp-24h]
	unsigned int v12; // [esp+24h] [ebp-20h]
	int v13; // [esp+28h] [ebp-1Ch]
	int v14; // [esp+2Ch] [ebp-18h]
	Bit32s j; // [esp+30h] [ebp-14h]
	int v16; // [esp+34h] [ebp-10h]
	int v17; // [esp+38h] [ebp-Ch]
	int v18; // [esp+3Ch] [ebp-8h]
	Bit32s i; // [esp+40h] [ebp-4h]

	//fix
	v14 = 0;
	//fix
	v11 = a1->playing_21;
	if (v11)
	{
		for (i = 0; i < a1->n_samples_24; i++)
		{
			a1->samples_23[i].sam_var[548] = a1->samples_23[i].status_1;
			if (a1->samples_23[i].status_1 == 4)
				a1->samples_23[i].status_1 = 8;
		}
		sub_A20D0(a1);
		sub_B0C1A(a1);
		//dma - sub_B0B87(a1, 0);//fix
		//dma - sub_B0B87(a1, 1);//fix
	}
	v5 = 2 * x_DWORD_181DAC[7] | x_DWORD_181DAC[8];
	if (v5 <= 3)
	{
		switch (v5)
		{
		case 0u:
			v6[0] = 0;
			v6[1] = 1;
			v6[2] = 2;
			v6[3] = 3;
			break;
		case 1u:
			v6[0] = 1;
			v6[1] = 0;
			v6[2] = 3;
			v6[3] = 2;
			break;
		case 2u:
			v6[0] = 2;
			v6[1] = 3;
			v6[2] = 0;
			v6[3] = 1;
			break;
		case 3u:
			v6[0] = 3;
			v6[1] = 2;
			v6[2] = 1;
			v6[3] = 0;
			break;
		}
	}
	for (i = 0; i < 4; i++)
	{
		if (*(x_BYTE *)(v6[i] + (Bit8u*)&a1->DDT_1))
		{
			a1->hw_format_6 = v6[i];
			break;
		}
	}
	a1->hw_mode_flags_7 = *(x_DWORD *)(14 * a1->hw_mode_flags_7 + (Bit8u*)&a1->DDT_1 + 26);
	if (x_DWORD_181DAC[1] < 1)
	{
		if (!x_DWORD_181DAC[1])
		{
			a1->DMA_rate_5 = *(unsigned __int16 *)(14 * a1->hw_format_6 + (Bit8u*)&a1->DDT_1 + 16);
			goto LABEL_33;
		}
	}
	else
	{
		if (x_DWORD_181DAC[1] == 0)
		{
			a1->DMA_rate_5 = *(unsigned __int16 *)(14 * a1->hw_format_6 + (Bit8u*)&a1->DDT_1 + 18);
			goto LABEL_33;
		}
		if (x_DWORD_181DAC[1] == 2)
		{
			a1->DMA_rate_5 = *(unsigned __int16 *)(14 * a1->hw_format_6 + (Bit8u*)&a1->DDT_1 + 20);
			goto LABEL_33;
		}
	}
	j = x_DWORD_181DAC[1];
	v6[0] = *(unsigned __int16 *)(14 * a1->hw_format_6 + (Bit8u*)&a1->DDT_1 + 16);
	v6[1] = *(unsigned __int16 *)(14 * a1->hw_format_6 + (Bit8u*)&a1->DDT_1 + 18);
	v6[2] = *(unsigned __int16 *)(14 * a1->hw_format_6 + (Bit8u*)&a1->DDT_1 + 20);
	v13 = 0x7FFFFFFF;
	for (i = 0; i < 3; i++)
	{
		v1 = abs(j - v6[i]);
		if (v1 <= v13)
		{
			v13 = abs(j - v6[i]);
			v14 = i;
		}
	}
	a1->DMA_rate_5 = v6[v14];
LABEL_33:
	v4 = a1->hw_format_6;
	if (v4 <= 3)
	{
		switch (v4)
		{
		case 0u:
			a1->channels_per_sample_15 = 1;
			a1->bytes_per_channel_16 = 1;
			break;
		case 1u:
			a1->channels_per_sample_15 = 1;
			a1->bytes_per_channel_16 = 2;
			break;
		case 2u:
			a1->channels_per_sample_15 = 2;
			a1->bytes_per_channel_16 = 1;
			break;
		case 3u:
			a1->channels_per_sample_15 = 2;
			a1->bytes_per_channel_16 = 2;
			break;
		}
	}
	v16 = x_DWORD_181DAC[3] * a1->DMA_rate_5 / 1000;
	a1->half_buffer_size_4 = a1->channels_per_sample_15 * a1->bytes_per_channel_16 * v16;
	v18 = *(unsigned __int16 *)(14 * a1->hw_format_6 + (Bit8u*)&a1->DDT_1 + 22);
	v17 = *(unsigned __int16 *)(14 * a1->hw_format_6 + (Bit8u*)&a1->DDT_1 + 24);
	if (!x_DWORD_181DAC[18])
		goto LABEL_64;
	if (v17 > 2048)
		v17 = 2048;
	/*if (v18 > 2048)
	{
		strcpy_s(x_BYTE_181C90, strlen("Minimum DMA buffer size too large for VDM\n") + 1, "Minimum DMA buffer size too large for VDM\n");
		v10 = 0;
	}
	else*/
	{
	LABEL_64:
		v13 = 0x7FFFFFFF;
		for (j = 8; x_DWORD_181DAC[2] / 2 >= j; j *= 2)//00352DB4
		{
			v2 = abs(j - a1->half_buffer_size_4);
			if (v2 <= v13)
			{
				v13 = abs(j - a1->half_buffer_size_4);
				v14 = j;
			}
		}
		//adress 283b19
		a1->half_buffer_size_4 = v14;//354f64->0000800
		if (a1->half_buffer_size_4 < v18)
			a1->half_buffer_size_4 = v18;
		if (a1->half_buffer_size_4 > v17)
			a1->half_buffer_size_4 = v17;
		v12 = (int)a1->DMA_seg_8;
		if (x_DWORD_181DAC[18])
		{
			v12 >>= 12;
			v12 += 4095;
			v12 &= (unsigned int)&unk_FF000;
			v12 <<= 12;
		}
		a1->DST_2->DMA_buffer_A = (void*)v12;
		a1->DST_2->DMA_buffer_B = (void*)(a1->half_buffer_size_4 + v12);
		//fix get from sound buffer
		//fix a1->DMA_11_12[0] = (void*)((int)a1->DST_2.DMA_buffer_A & 0xFFFF) + 16 * ((int)a1->DST_2.DMA_buffer_A >> 16);
		//fix a1->DMA_11_12[1] = (void*)((int)a1->DST_2.DMA_buffer_B & 0xFFFF) + 16 * ((int)a1->DST_2.DMA_buffer_B >> 16);
		if (v11)
		{
			for (i = 0; i < a1->n_samples_24; i++)
				a1->samples_23[i].status_1 = a1->samples_23[i].sam_var[548];
			sub_B0C1A(a1);
			//dma sub_B0B87(a1, 0);//fix
			//dma sub_B0B87(a1, 1);//fix
			sub_A2070(a1);
		}
		v10 = 1;
	}
	return v10;
}
// A0D1F: using guessed type x_DWORD abs(x_DWORD);
// 181C90: using guessed type char x_BYTE_181C90;
// 181DB0: using guessed type int x_DWORD_181DB0;
// 181DB4: using guessed type int x_DWORD_181DB4;
// 181DB8: using guessed type int x_DWORD_181DB8;
// 181DC8: using guessed type int x_DWORD_181DC8;
// 181DCC: using guessed type int x_DWORD_181DCC;
// 181DF4: using guessed type int x_DWORD_181DF4;

Bit16s envstring[0x18] = {
	220,7,01,05,-1,-1,-1,-1,
	-1,-1,-1,-1,220,05,01,05,
	-1,-1,-1,-1,-1,-1,-1,-1
};

//----- (000A2C80) --------------------------------------------------------
int sub_A2C80(HDIGDRIVER a1, IO_PARMS* a2)//283c80
{
	Bit16s v3[0x18]; // [esp+0h] [ebp-30h]
	//__int16 v4; // [esp+2h] [ebp-2Eh]
	//__int16 v5; // [esp+4h] [ebp-2Ch]
	//__int16 v6; // [esp+6h] [ebp-2Ah]
	Bit16s v7[4]; // [esp+8h] [ebp-28h]
	VDI_CALL v8; // [esp+18h] [ebp-18h]
	Bit16s v9; // [esp+1Eh] [ebp-12h]
	unsigned int i; // [esp+24h] [ebp-Ch]
	Bit16s *v11; // [esp+28h] [ebp-8h]

	//fix it
	//v4 = 0;
	//v5 = 0;
	//v6 = 0;
	//fix it

	//qmemcpy(v3, (void*)a2, 0x18u); // fix it
	if (a1->drvr_0->VHDR_4->environment_string_16)
	{
		/*
		eax = [ebp+10]//1a7884
		eax=[eax]//1a7758
		eax=[eax+10]//2c380

		eax = [ebp+10]//1a7884
		eax=[eax]//1a7758
		eax=[eax+10]//2c380
		eax=[eax+0c]>>16<<4//2c38

		eax = [ebp+10]//1a7884
		eax=[eax]//1a7758
		eax=[eax+10]//2c380//[eax+0c] je 2c38050e
		eax=[eax+0c]&&ffff//50e
		+ = 2c88e - final adress
		*/
		/*v11 = (__int16 *)((a1->var0_aildrv->AIL_DRIVER_var4_VHDR->environment_string & 0xFFFF)
						+ 16 * (a1->var0_aildrv->AIL_DRIVER_var4_VHDR->environment_string >> 16));*/
						//fixed
		v11 = envstring;//fixed
		if (v3[0] < 0)
			v3[0] = v11[0];
		if (v3[1] < 0)
			v3[1] = v11[1];
		if (v3[2] < 0)
			v3[2] = v11[2];
		if (v3[3] < 0)
			v3[3] = v11[3];
		for (i = 0; i < 4; i++)
		{
			if (v7[i] < 0)
				v7[i] = v11[2 * i + 4];
		}
	}
	qmemcpy((void *)&(a1->drvr_0->VHDR_4->IO), v3, 0x18u);
	if (x_DWORD_181DAC[9])
		v9 = 3;
	else
		v9 = 1;
	return sub_91F70_AIL_call_driver(a1->drvr_0, 772, &v8, 0);
}
// 181DD0: using guessed type int x_DWORD_181DD0;

//----- (000A2EA0) --------------------------------------------------------
HDIGDRIVER sub_A2EA0(AIL_DRIVER* a1, IO_PARMS IO)//283ea0
{
	int v2; // ST0C_4
	int v3; // ST08_4
	int v4; // ST0C_4
	int v5; // ST08_4
	Bit8u* v6; // eax
	int v7; // ST0C_4
	int v8; // ST08_4
	int v9; // ST0C_4
	int v10; // ST08_4
	unsigned int v11; // eax
	int v12; // ST0C_4
	int v13; // ST08_4
	Bit8u v15[0x18 * 4]; // [esp+0h] [ebp-50h]
	VDI_CALL v16/*[100]*/; // [esp+18h] [ebp-38h]
	//Bit16s v17; // [esp+1Ah] [ebp-36h]
	//unsigned __int16 v18; // [esp+1Ch] [ebp-34h]
	//unsigned __int16 v19; // [esp+1Eh] [ebp-32h]
	HDIGDRIVER result; // [esp+24h] [ebp-2Ch]
	int v21; // [esp+28h] [ebp-28h]
	unsigned int v22; // [esp+2Ch] [ebp-24h]
	unsigned int v23; // [esp+30h] [ebp-20h]
	unsigned int v24; // [esp+34h] [ebp-1Ch]
	int v25; // [esp+38h] [ebp-18h]
	HDIGDRIVER v26 = NULL; // [esp+3Ch] [ebp-14h]
	unsigned int v27; // [esp+40h] [ebp-10h]
	int v28; // [esp+44h] [ebp-Ch]
	int i; // [esp+48h] [ebp-8h]
	int v30; // [esp+4Ch] [ebp-4h]
	IO_PARMS* v31; // [esp+64h] [ebp+14h]
	IO_PARMS* v32; // [esp+64h] [ebp+14h]

	//fix it
	//v17 = 0;
	//v18 = 0;
	//v19 = 0;
	v28 = 0;
	v31 = 0;
	//result = 0;
	//fix it

	sub_A1F90();//lock linear
	v26 = (_DIG_DRIVER*)sub_9D450_malloc4(sizeof(_DIG_DRIVER));
	//fixed
	v26->hw_format_6 = 0;
	v26->hw_mode_flags_7 = 0;
	//fixed
	if (v26)
	{
		v26->drvr_0 = a1;//fix it
		if (v26->drvr_0->type_5)
		{
			qmemcpy(&x_BYTE_181C90, (void*)".DIG driver required\n", 0x16u);
			sub_9D490_free4(v26, 140);
			result = 0;
		}
		else
		{
			sub_91F70_AIL_call_driver(v26->drvr_0, 769, 0, &v16);//354fa8
			//fix it! write read DDT function for next two lines
			v26->DDT_1 = (DIG_DDT*)sound_buffer[0/*v16.AX*/];//(Bit8u*)v16.AX +16 * v16.DX;//fix
			v26->DST_2 = (DIG_DST*)sound_buffer[1/*v16.BX*/];//(Bit8u*)v16.BX + 16 * v16.CX;//fix
			v26->buffer_flag_13 = (Bit16s*)v26->DST_2->active_buffer;
			v26->last_buffer_14 = -1;
			v26->playing_21 = 0;
			v26->quiet_22 = 0;
			v26->n_active_samples_25 = 0;
			v26->master_volume_26 = 127;
			memset(&unk_181D90, -1, 24);
			v28 = 0;
			if (&IO)
			{
				qmemcpy(&unk_181D90, (void*)&IO, 0x18u);
				if (sub_A2C80(v26, &IO))
				{
					v28 = 1;
					qmemcpy(v15, (void*)&IO, 0x18u);
				}
			}
			if (!v28)
			{
				v31 = sub_92ED0_AIL_get_IO_environment(v26->drvr_0);
				if (v31)
				{
					qmemcpy(&unk_181D90, v31, 0x18u);
					if (sub_A2C80(v26, v31))
					{
						v28 = 1;
						qmemcpy(v15, v31, 0x18u);
					}
				}
			}
			if (!v28 && x_DWORD_181DAC[17] == 1)
			{
				for (i = 0; (int)v26->drvr_0->VHDR_4->environment_string_16 > i; i++)//fix
				{
					v32 = (IO_PARMS*)(24 * i
						+ (v26->drvr_0->VHDR_4->environment_string_16 & 0xFFFF)//fix - 12
						+ 16 * (v26->drvr_0->VHDR_4->environment_string_16 >> 16));//fix - 12
					if (!i)
						qmemcpy(&unk_181D90, (void*)v32, 0x18u);
					if (sub_A2C80(v26, v32))
					{
						v28 = 1;
						qmemcpy(v15, (void*)v32, 0x18u);
						break;
					}
				}
			}
			if (v28)
			{
				qmemcpy(&unk_181D90, v15, 0x18u);
				if (x_DWORD_181DAC[18])
					v25 = 0x2000;
				else
					v25 = x_DWORD_181DAC[2];
				v26->DMA_buf_10 = 0;
				//do //fixed
				{
					if (!sub_9D4D0(1,//fixed - find true size DMA buffer
							//(v25 + 15 - (__CFSHL__((v25 + 15) >> 31, 4) + 16 * ((v25 + 15) >> 31))) >> 4,
						(Bit8u**)&v30, (Bit32u*)&v22, (Bit32u*)&v21))
					{
						qmemcpy(&x_BYTE_181C90, (void*)"Could not allocate DMA buffers\n", 0x20u);
						sub_9D490_free4(v26, 140);
						return 0;
					}
					if (v26->DMA_buf_10)
					{
						v2 = v26->DMA_sel_9;
						v3 = (int)v26->DMA_seg_8;
						sub_9D560((Bit8u*)v26->DMA_buf_10);
					}
					v26->DMA_buf_10 = (void*)v30;
					v26->DMA_sel_9 = v22;
					v26->DMA_seg_8 = (void*)v21;
					v27 = v22 >> 12;
					v24 = 0xF0000 & (v22 >> 12);
					v23 = 0xF0000 & (v25 + (v22 >> 12) - 1);
				}
				//while ( (0xF0000 & (v22 >> 12)) != v23 );*/ // fix allocate dma buffers
				if (sub_A2650(v26))
				{
					sub_91F70_AIL_call_driver(v26->drvr_0, 773, 0, 0);
					v26->drvr_0->initialized_6 = 1;
					v26->samples_per_buffer_18 = v26->half_buffer_size_4 / (v26->bytes_per_channel_16 * v26->channels_per_sample_15);
					v26->channels_per_buffer_17 = v26->half_buffer_size_4 / v26->bytes_per_channel_16;
					v26->build_size_19 = 4 * v26->channels_per_buffer_17;
					v6 = sub_9D450_malloc4(v26->build_size_19);
					v26->build_buffer_20 = (Bit32s*)v6;
					if (v26->build_buffer_20)
					{
						v26->n_samples_24 = x_DWORD_181DAC[4];
						v26->samples_23 = (_SAMPLE*)sub_9D450_malloc4(sizeof(_SAMPLE) * v26->n_samples_24);
						if (v26->samples_23)
						{
							for (i = 0; i < v26->n_samples_24; i++)
							{
								v26->samples_23[i].status_1 = 1;
								v26->samples_23[i].driver_0 = v26;
								v26->samples_23[i].index_sample = i;//fixed
							}
							v11 = sub_92600_AIL_register_timer(sub_A2450);
							v26->timer_3 = v11;
							if (v26->timer_3 == -1)
							{
								qmemcpy(&x_BYTE_181C90, (void*)"Out of timer handles\n", 0x16u);
								if (a1->PM_ISR_7 != -1)
									sub_91E90_AIL_restore_USE16_ISR(a1->PM_ISR_7);
								sub_91F70_AIL_call_driver(v26->drvr_0, 774, 0, 0);
								v26->n_samples_24 = 0;
								v12 = v26->DMA_sel_9;
								v13 = (int)v26->DMA_seg_8;
								sub_9D560((Bit8u*)v26->DMA_buf_10);
								sub_9D490_free4(v26->samples_23, sizeof(_SAMPLE) * v26->n_samples_24);
								sub_9D490_free4(v26->build_buffer_20, v26->build_size_19);
								sub_9D490_free4(v26, 140);
								result = 0;
							}
							else
							{
								sub_92740_AIL_set_timer_user(v26->timer_3, (signed __int32)v26);
								sub_92930_AIL_set_timer_frequency(v26->timer_3, x_DWORD_181DAC[0]);//00352DAC not zero!
								sub_92BA0_AIL_start_timer(v26->timer_3);
								v26->var36_aildrv = (x_DWORD)sub_A2DE0;
								v26->var40_aildrv = (x_DWORD)v26;
								sub_B0C1A(v26);
								//dma sub_B0B87(v26, 0);//fix
								//dma sub_B0B87(v26, 1);//fix
								result = v26;
							}
						}
						else
						{
							qmemcpy(&x_BYTE_181C90, (void*)"Could not allocate SAMPLE structures\n", 0x26u);
							if (a1->PM_ISR_7 != -1)
								sub_91E90_AIL_restore_USE16_ISR(a1->PM_ISR_7);
							sub_91F70_AIL_call_driver(v26->drvr_0, 774, 0, 0);
							v26->n_samples_24 = 0;
							v9 = v26->DMA_sel_9;
							v10 = (int)v26->DMA_seg_8;
							sub_9D560((Bit8u*)v26->DMA_buf_10);
							sub_9D490_free4(v26->samples_23, v26->build_size_19);
							sub_9D490_free4(v26, 140);
							result = 0;
						}
					}
					else
					{
						qmemcpy(&x_BYTE_181C90, (void*)"Could not allocate build buffer\n", 0x21u);
						if (a1->PM_ISR_7 != -1)
							sub_91E90_AIL_restore_USE16_ISR(a1->PM_ISR_7);
						sub_91F70_AIL_call_driver(v26->drvr_0, 774, 0, 0);
						v26->n_samples_24 = 0;
						v7 = v26->DMA_sel_9;
						v8 = (int)v26->DMA_seg_8;
						sub_9D560((Bit8u*)v26->DMA_buf_10);
						sub_9D490_free4(v26, 140);
						result = 0;
					}
				}
				else
				{
					v4 = v26->DMA_sel_9;
					v5 = (int)v26->DMA_seg_8;
					sub_9D560((Bit8u*)v26->DMA_buf_10);
					sub_9D490_free4(v26, 140);
					result = 0;
				}
			}
			else
			{
				qmemcpy(&x_BYTE_181C90, (void*)"Digital sound hardware not found\n", 0x22u);
				sub_9D490_free4(v26, 140);
				result = 0;
			}
		}
	}
	else
	{
		qmemcpy(&x_BYTE_181C90, (void*)"Could not allocate memory for driver\n", 0x26u);
		result = 0;
	}
	return result;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// A2450: using guessed type int sub_A2450();
// A2DE0: using guessed type int sub_A2DE0();
// 181C90: using guessed type char x_BYTE_181C90;
// 181DAC: using guessed type int x_DWORD_181DAC[];
// 181DB4: using guessed type int x_DWORD_181DB4;
// 181DBC: using guessed type int x_DWORD_181DBC;
// 181DF0: using guessed type int x_DWORD_181DF0;
// 181DF4: using guessed type int x_DWORD_181DF4;

//----- (000A3600) --------------------------------------------------------
HDIGDRIVER sub_A3600_AIL_API_install_DIG_driver_file(/*int a1,*/ char* filename, IO_PARMS* IO)//284600
{
	//ac_sound_install_dig_driver_file
	int v3; // eax
	HDIGDRIVER result; // [esp+0h] [ebp-10h]
	Bit8u* v6; // [esp+4h] [ebp-Ch]
	HDIGDRIVER v7; // [esp+8h] [ebp-8h]
	AIL_DRIVER *v8; // [esp+Ch] [ebp-4h]

	v6 = sub_9DEA0_read_file(filename, 0);
	if (v6)
	{
		v3 = sub_9DE20_get_file_lenght(filename);
		v8 = sub_93010_AIL_install_driver(/*a1, */v6, v3);
		/*
		chyby
		2 a 3 c095 versus 382c

		*/
		x_free((void*)v6);
		if (v8)
		{
			//   IO
			v7 = sub_A2EA0(v8, *IO);
			if (!v7)
				sub_93160_AIL_uninstall_driver(v8);
			result = v7;
		}
		else
		{
			result = 0;
		}
	}
	else
	{
		strcpy_s(x_BYTE_181C90, strlen("Driver file not found\n") + 1, "Driver file not found\n");
		result = 0;
	}
	return result;
}
// E3E34: using guessed type int (*off_E3E34_freex)(int);
// 181C90: using guessed type char x_BYTE_181C90;

//----- (000A36B0) --------------------------------------------------------
HDIGDRIVER sub_A36B0(int a1, Bit8u* a2, int a3, IO_PARMS a4)
{
	HDIGDRIVER result; // [esp+4h] [ebp-8h]
	AIL_DRIVER *v7; // [esp+8h] [ebp-4h]

	v7 = sub_93010_AIL_install_driver(/*a1, */a2, a3);
	if (!v7)
		return 0;
	result = sub_A2EA0(v7, a4);
	if (!result)
		sub_93160_AIL_uninstall_driver(v7);
	return result;
}

//----- (000A3720) --------------------------------------------------------
int sub_A3720_AIL_API_install_DIG_INI(/*int a1, */HDIGDRIVER* dig)//284720
{
	//ac_sound_install_dig_ini
	//Bit8u v3[4096]; // [esp+0h] [ebp-11Ch]
	char v4; // [esp+80h] [ebp-9Ch]
	char v5; // [esp+100h] [ebp-1Ch]
	int result; // [esp+118h] [ebp-4h]

	//char filename[200];
	//IO_PARMS IO = {};
	AIL_INI a2;//fix
	//a2 = jmeno souboru
	if (sub_92190_AIL_read_INI(/*(Bit8u*)a1, */&a2, (char*)"DIG.INI"/*, filename, IO*/))
	{//3550c8 - SB16.DIG  //355148 - 220
		*dig = sub_93330_AIL_install_DIG_driver_file(/*a1, */a2.driver_name, &a2.IO);
		if (*dig)
			result = 0;
		else
			result = 2;
	}
	else
	{
		qmemcpy(&x_BYTE_181C90, (void*)"Unable to open file DIG.INI\n", 0x1Du);
		result = 1;
	}
	return result;
}
// 181C90: using guessed type char x_BYTE_181C90;

//----- (000A37A0) --------------------------------------------------------
int sub_A37A0(unsigned int *a1)
{
	return sub_93160_AIL_uninstall_driver((AIL_DRIVER*)*a1);
}

//----- (000A37C0) --------------------------------------------------------
int sub_A37C0(int a1)
{
	int v2; // [esp+4h] [ebp-8h]
	int i; // [esp+8h] [ebp-4h]

	v2 = 0;
	for (i = 0; i < *(x_DWORD *)(a1 + 96); i++)
	{
		if (*(x_DWORD *)(2196 * i + *(x_DWORD *)(a1 + 92) + 4) == 4)
			++v2;
	}
	return v2;
}

//----- (000A3820) --------------------------------------------------------
HSAMPLE sub_A3820_allocate_sample_handle(HDIGDRIVER dig)//284820
{
	HSAMPLE v1; // ST08_4
	HSAMPLE v3; // [esp+0h] [ebp-Ch]
	int i; // [esp+8h] [ebp-4h]

	sub_91BD0_s_plus();
	for (i = 0; i < dig->n_samples_24 && dig->samples_23[i].status_1 != 1; i++)
		;
	if (i == dig->n_samples_24)
	{
		qmemcpy(&x_BYTE_181C90, (void*)"Out of sample handles\n", 0x17u);
		sub_91BF0_s_minus();
		v3 = 0;
	}
	else
	{
		v1 = &dig->samples_23[i];
		sub_93830_AIL_init_sample(v1);
		sub_91BF0_s_minus();
		v3 = v1;
	}
	return v3;
}
// 181C90: using guessed type char x_BYTE_181C90;

//----- (000A38C0) --------------------------------------------------------
int sub_A38C0_AIL_API_release_sample_handle(int a1)
{
	int result; // eax

	if (a1)
	{
		result = a1;
		*(x_DWORD *)(a1 + 4) = 1;
	}
	return result;
}

//----- (000A38E0) --------------------------------------------------------
void sub_A38E0_init_sample(HSAMPLE S/*S32     format,U32     flags*/)//2848e0
{
	if (S)//fix S
	{
		S->status_1 = 2;
		S->start_2_3[0] = 0;
		S->start_2_3[1] = 0;
		S->start_44mhz = 0;
		S->len_4_5[0] = 0;
		S->len_4_5[1] = 0;
		S->pos_6_7[0] = 0;
		S->pos_6_7[1] = 0;
		S->done_8_9[0] = 0;
		S->done_8_9[1] = 1;
		S->current_buffer_10 = 0;
		S->last_buffer_11 = -2;
		S->loop_count_12 = 1;
		S->format_13 = 0;
		S->flags_14 = 0;
		S->playback_rate_15 = 11025;
		S->volume_16 = x_DWORD_181DAC[5];
		if (S->pos_6_7[0] && S->pos_6_7[0] != 1)
			S->pan_17 = 64;
		else
			S->pan_17 = 0;
		S->sam_var[530] = 0;
		S->sam_var[531] = 0;
		S->sam_var532_EOS_ptr = 0;
		sub_A2110(S);
	}
}
// 181DC0: using guessed type int x_DWORD_181DC0;

//----- (000A3A00) --------------------------------------------------------
Bit32u sub_A3A00_sample_status(HSAMPLE S)
{
	int result; // [esp+0h] [ebp-4h]

	if (S)
		result = S->status_1;
	else
		result = 0;
	return result;
}

void init_hqsound(HSAMPLE S) {
	if (S->start_44mhz)
		free(S->start_44mhz);
	S->start_44mhz = malloc(S->len_4_5[0] * 2 * 4);

	/*SDL_AudioCVT cvt;
	SDL_BuildAudioCVT(&cvt, AUDIO_U8, 1, 11025, AUDIO_S16, 1, 44100);
	//SDL_assert(cvt.needed); // obviously, this one is always needed.
	cvt.len = S->len_4_5[0];  // 1024 stereo float32 sample frames.
	//cvt.len_mult = 2 * 4 * 2;
	cvt.buf = (Uint8 *)SDL_malloc(cvt.len * cvt.len_mult);
	memcpy(cvt.buf, S->start_2_3[0], S->len_4_5[0]);
	// read your float32 data into cvt.buf here.
	SDL_ConvertAudio(&cvt);
	memcpy(S->start_44mhz, cvt.buf, cvt.len * 2*4*2);*/
	//free(cvt.buf);
	//ffe8 ffe8 b1ec b1ec 5bf5 5bf5 b000 b000
	//69 8c a6 b4 c0 c4


	Bit16u lastval = ((Bit8u*)S->start_2_3[0])[0] * 256;
	Bit16u actval;
	Bit16s val1, val2, val3, val4;
	for (int i = 0;i < S->len_4_5[0];i++)
	{
		actval = ((Bit8u*)S->start_2_3[0])[i] * 256;
		val1 = lastval - 0x8000;
		val2 = (lastval*0.85 + actval * 0.15) - 0x8000;
		val3 = (lastval * 0.5 + actval * 0.5) - 0x8000;
		val4 = (lastval * 0.15 + actval * 0.85) - 0x8000;
		(*(Bit16s*)&((Bit8u*)S->start_44mhz)[0 + i * 8]) = val1;
		(*(Bit16s*)&((Bit8u*)S->start_44mhz)[2 + i * 8]) = val2;
		(*(Bit16s*)&((Bit8u*)S->start_44mhz)[4 + i * 8]) = val3;
		(*(Bit16s*)&((Bit8u*)S->start_44mhz)[6 + i * 8]) = val4;
		/*(*(Bit16s*)&((Bit8u*)S->start_44mhz)[8 + i * 16]) = val3;
		(*(Bit16s*)&((Bit8u*)S->start_44mhz)[10 + i * 16]) = val3;
		(*(Bit16s*)&((Bit8u*)S->start_44mhz)[12 + i * 16]) = val4;
		(*(Bit16s*)&((Bit8u*)S->start_44mhz)[14 + i * 16]) = val4;*/
		if (i < S->len_4_5[0] + 1)lastval = actval;
	}
	lastval = actval;
};

//----- (000A3A30) --------------------------------------------------------
void sub_A3A30_set_sample_address(HSAMPLE S, Bit8u* start, Bit32u len)
{
	if (S)
	{
		S->start_2_3[0] = start;
		S->start_2_3[1] = 0;
		S->len_4_5[0] = len;
		S->len_4_5[1] = 0;
		if (hqsound)
			init_hqsound(S);
	}
}

//----- (000A3A70) --------------------------------------------------------
void sub_A3A70_set_sample_type(HSAMPLE S, Bit32s a2, Bit32u a3)//284a70
{
	if (S)
	{
		if (a2 != S->format_13 || (a3 != S->flags_14))
		{
			S->format_13 = a2;
			S->flags_14 = a3;
			sub_A2110(S);
		}
	}
}

//----- (000A3AC0) --------------------------------------------------------
Bit32s sub_A3AC0_get_sample_playback_rate(HSAMPLE S)
{
	Bit32s result; // [esp+0h] [ebp-4h]
	if (S)
		result = S->playback_rate_15;
	else
		result = 0;
	return result;
}

//----- (000A3AF0) --------------------------------------------------------
void sub_A3AF0_set_sample_playback_rate(HSAMPLE S, Bit32s playback_rate)//284af0
{
	if (S)
	{
		S->playback_rate_15 = playback_rate;
	}
}

//----- (000A3B10) --------------------------------------------------------
Bit32s sub_A3B10_get_sample_volume(HSAMPLE S)
{
	Bit32s result; // [esp+0h] [ebp-4h]

	if (S)
		result = S->volume_16;
	else
		result = 0;
	return result;
}

//----- (000A3B40) --------------------------------------------------------
void sub_A3B40_set_sample_volume(HSAMPLE S, Bit32s volume) //284b40
{
	if (S)
	{
		//result = a2;
		if (volume != S->volume_16)
		{
			S->volume_16 = volume;
			sub_A2110(S);
		}
	}
}

//----- (000A3B80) --------------------------------------------------------
Bit32s sub_A3B80_get_sample_volume_pan(HSAMPLE S)//284b80
{
	Bit32s result; // [esp+0h] [ebp-4h]

	if (S)
		result = S->pan_17;
	else
		result = 0;
	return result;
}

//----- (000A3BB0) --------------------------------------------------------
void sub_A3BB0_set_sample_volume_pan(HSAMPLE S, Bit32s volume)//284bb0
{
	if (S)
	{
		if (volume != S->pan_17)
		{
			S->pan_17 = volume;
			sub_A2110(S);
		}
	}
}

//----- (000A3BF0) --------------------------------------------------------
int sub_A3BF0(int a1)
{
	int v2; // [esp+0h] [ebp-4h]

	if (a1)
		v2 = *(x_DWORD *)(a1 + 4 * *(x_DWORD *)(a1 + 40) + 24);
	else
		v2 = 0;
	return v2;
}

//----- (000A3C30) --------------------------------------------------------
int sub_A3C30(int a1, int a2)
{
	int result; // eax

	if (a1)
	{
		result = a2;
		*(x_DWORD *)(4 * *(x_DWORD *)(a1 + 40) + a1 + 24) = a2;
	}
	return result;
}

//----- (000A3C60) --------------------------------------------------------
signed int sub_A3C60(int a1)
{
	signed int v2; // [esp+0h] [ebp-4h]

	if (a1)
		v2 = *(x_DWORD *)(a1 + 48);
	else
		v2 = -1;
	return v2;
}

//----- (000A3C90) --------------------------------------------------------
void sub_A3C90_set_sample_loop_count(HSAMPLE S, int loop_count)
{
	if (S)
	{
		S->loop_count_12 = loop_count;
	}
}

void sub_A3CB0_API_AIL_start_sample(HSAMPLE S)//284cb0
{
	if (S)
	{
		if (S->status_1 != 1)
		{
			S->status_1 = 4;
			SOUND_start_sample(S);
		}
	}
}
/*
//----- (000A3CB0) --------------------------------------------------------
void sub_A3CB0_API_AIL_start_sample_orig(HSAMPLE S)//284cb0
{
	if (S)
	{
		if (S->status_1 != 1)
		{
			//if ( *(x_DWORD *)((int)&S->sam_var[S->sam_var[10]] + 16) )
			if (S->sam_var[S->EOS_10 + 4])
			{
				//if ( *(x_DWORD *)((int)&S->sam_var[S->sam_var[10]] + 8) )
				if (S->sam_var[S->EOS_10 + 2])
				{
					S->sam_var[S->EOS_10 + 6] = 0;
					S->status_1 = 4;
					sub_A2070(S->driver_0);
				}
			}
		}
	}
}
*/
//----- (000A3D30) --------------------------------------------------------
void sub_A3D30(HSAMPLE S)
{
	if (S)
	{
		if (S->status_1 == 4)
		{
			S->status_1 = 8;
		}
	}
}

//----- (000A3D60) --------------------------------------------------------
void sub_A3D60(HSAMPLE S)
{
	if (S)
	{
		if (S->status_1 == 8)
		{
			S->status_1 = 4;
			sub_A2070(S->driver_0);
		}
	}
}

void sub_A3DA0__API_AIL_end_sample(HSAMPLE S)//284da0
{
	if (S)
	{
		if (S->status_1 != 1)
		{
			if (S->status_1 != 2)
			{
				S->status_1 = 2;
				SOUND_end_sample(S);
			}
		}
	}
}

//----- (000A3DA0) --------------------------------------------------------
void sub_A3DA0__API_AIL_end_sample_orig(HSAMPLE S)//284da0
{
	if (S)
	{
		//result = a1;
		if (S->status_1 != 1)
		{
			//result = a1;
			if (S->status_1 != 2)
			{
				S->status_1 = 2;
				if (S->sam_var[531])
					switch (S->sam_var[531]) {
					case 0: {
						//call(S);
						break;
					}
							//(*(void(**)(int))(S + 2124))(S);
					}
				if (S->sam_var532_EOS_ptr)
					S->sam_var532_EOS_ptr();
				/*switch (S->sam_var532_EOS_ptr) {
				case 0: {
					//call(S);
					break;
				}
						//(*(void(**)(int))(S + 2124))(S);
				}*/

				//result = a1;
				//if ( *(x_DWORD *)(a1 + 2128) )
				//  result = (*(int (**)(int))(a1 + 2128))(a1);
			}
		}
	}
}

//----- (000A3E10) --------------------------------------------------------
int sub_A3E10(HSAMPLE S, int a2)
{
	int v2; // ST04_4

	if (!S)
		return 0;
	v2 = S->sam_var[530];
	S->sam_var[530] = a2;
	return v2;
}

//----- (000A3E60) --------------------------------------------------------
int sub_A3E60(HSAMPLE S, int a2)
{
	int v2; // ST04_4

	if (!S)
		return 0;
	v2 = S->sam_var[531];
	S->sam_var[531] = a2;
	return v2;
}

//----- (000A3EB0) --------------------------------------------------------
EOS_callback_type sub_A3EB0_register_EOS_callback(HSAMPLE S, EOS_callback_type EOS)//284eb0
{
	EOS_callback_type result; // ST04_4
	if (!S)
		return 0;
	result = S->sam_var532_EOS_ptr;
	S->sam_var532_EOS_ptr = EOS;
	return result;
}

//----- (000A3F00) --------------------------------------------------------
void sub_A3F00_set_sample_user_data(HSAMPLE S, int index, int a3)//284f00
{
	//int result; // eax

	if (S)
	{
		//result = a3;
		//*(x_DWORD *)(4 * a2 + S + 2132) = a3;
		S->sam_var[533 + index];
	}
	//return result;
}

//----- (000A3F30) --------------------------------------------------------
int sub_A3F30_sample_user_data(HSAMPLE S, int index)//284f30
{
	int v3; // [esp+0h] [ebp-4h]

	if (S)
		v3 = S->sam_var[533 + index];
	else
		v3 = 0;
	return v3;
}

//----- (000A3F70) --------------------------------------------------------
void sub_A3F70_set_digital_master_volume(x_DWORD *a1, int a2)
{
	int i; // [esp+0h] [ebp-4h]

	a1[26] = a2;
	for (i = 0; ; i++)
	{
		if (i >= a1[24])
			break;
		if (*(x_DWORD *)(2196 * i + a1[23] + 4) != 1)
			sub_A2110((HSAMPLE)(x_DWORD *)(2196 * i + a1[23]));
	}
}

//----- (000A3FE0) --------------------------------------------------------
int sub_A3FE0(int a1)
{
	return *(x_DWORD *)(a1 + 104);
}

//----- (000A4000) --------------------------------------------------------
char sub_A4000(x_DWORD *a1, int a2, unsigned int a3)
{
	int v3; // ST04_4
	signed int v5; // [esp+Ch] [ebp-4h]

	if (a3 <= 3)
	{
		switch (a3)
		{
		case 0u:
			v5 = 1;
			break;
		case 1u:
			v5 = 2;
			break;
		case 2u:
			v5 = 2;
			break;
		case 3u:
			v5 = 4;
			break;
		}
	}
	v3 = a2 * (v5 * a1[4] / (a1[16] * a1[15])) / a1[5];
	if (a1[5] != a2 && 2 * a2 != a1[5])
		a1[5];
	return 0;
}

//----- (000A4100) --------------------------------------------------------
void sub_A4100(int *a1, int a2, int a3, int a4)
{
	if (a1)
	{
		a1[a2 + 8] = a4 == 0;
		a1[a2 + 2] = a3;
		a1[a2 + 4] = a4;
		*(x_DWORD *)(&a1[a2] + 24) = 0;
		if (a4)
		{
			if (a1[1] != 4)
			{
				a1[1] = 4;
				sub_A2070((HDIGDRIVER)*a1);
			}
		}
	}
}

//----- (000A41B0) --------------------------------------------------------
signed int sub_A41B0(x_DWORD *a1)
{
	int v1; // eax
	unsigned int v3; // [esp+0h] [ebp-8h]

	if (!a1)
		return -1;
	v3 = a1[11];
	if (v3 >= 0xFFFFFFFE)
	{
		if (v3 <= 0xFFFFFFFE)
		{
			a1[9] = 0;
			a1[11] = -1;
			return 0;
		}
		if (v3 == -1)
		{
			a1[11] = a1[10];
			return 1;
		}
	}
	if (a1[11] == a1[10])
		return -1;
	a1[11] = a1[10];
	v1 = a1[10];
	LOBYTE(v1) = v1 ^ 1;
	return v1;
}

//----- (000A4260) --------------------------------------------------------
bool sub_A4260()
{
	bool result; // eax

	if (x_DWORD_E4A90)
	{
		sub_9D650((unsigned int)sub_A1F90, (unsigned int)sub_A4260);
		sub_9D740((unsigned int)x_BYTE_E4A0C, 128);
		sub_9D740((unsigned int)&x_DWORD_E4A8C, 4);
		sub_9D740((unsigned int)&x_DWORD_181E94, 4);
		sub_9D740((unsigned int)&unk_181E80, 12);
		sub_9D740((unsigned int)&x_DWORD_181E9C, 4);
		sub_9D740((unsigned int)&x_DWORD_181EA0, 4);
		sub_9D740((unsigned int)&x_DWORD_181E90, 4);
		sub_9D740((unsigned int)&x_DWORD_181E98, 4);
		result = sub_9D740((unsigned int)&x_DWORD_181E8C, 4);
		x_DWORD_E4A90 = 0;
	}
	return result;
}
// E4A8C: using guessed type int x_DWORD_E4A8C;
// E4A90: using guessed type int x_DWORD_E4A90;
// 181E8C: using guessed type int x_DWORD_181E8C;
// 181E90: using guessed type int x_DWORD_181E90;
// 181E94: using guessed type int x_DWORD_181E94;
// 181E98: using guessed type int x_DWORD_181E98;
// 181E9C: using guessed type int x_DWORD_181E9C;
// 181EA0: using guessed type int x_DWORD_181EA0;

//----- (000A4330) --------------------------------------------------------
void sub_A4330()
{
	//bool result; // eax

	if (!x_DWORD_E4A94)
	{
		sub_9D590_lock_linear_region((Bit8u*)sub_A4330, (unsigned int)sub_A4CB0);
		x_DWORD_E4A94 = 1;
	}
	//return result;
}
// E4A94: using guessed type int x_DWORD_E4A94;

//----- (000A4370) --------------------------------------------------------
int sub_A4370(x_DWORD *a1)
{
	return *a1 >> 8;
}

//----- (000A4390) --------------------------------------------------------
int sub_A4390(int a1)
{
	int result; // eax

	if (*(x_DWORD *)(a1 + 2164))
		(*(void(**)(int))(a1 + 2164))(a1);
	if (*(x_DWORD *)(a1 + 2188) > 0)
		sub_937A0_AIL_release_sample_handle(a1);
	result = a1;
	*(x_DWORD *)(a1 + 2188) = -1;
	return result;
}

//----- (000A43E0) --------------------------------------------------------
void sub_A43E0(HSAMPLE S)//2853e0
{
	x_DWORD *v1; // [esp+4h] [ebp-8h]

	while (1)
	{
		v1 = *(x_DWORD **)(S + 2168);
		if (*(x_BYTE *)v1 <= 9u)
			break;
		*(x_DWORD *)(S + 2168) = (x_DWORD)(char *)v1 + sub_A4370(v1) + 4;
	}
	JUMPOUT(__CS__, (int*) *(&off_A4400 + *(unsigned __int8 *)v1));
}
// A4400: using guessed type void *off_A4400;

//----- (000A47C0) --------------------------------------------------------
void sub_A47C0_sub_set_sample_file(Bit8u* file_image, HSAMPLE S)//2857c0
{
	int i; // eax
	int j; // eax
	Bit8u* v5; // [esp+0h] [ebp-8h]
	Bit8u* v6; // [esp+4h] [ebp-4h]

	v6 = file_image + 12;
	for (i = _strnicmp((const char*)(file_image + 12), "fmt ", 4); i; i = _strnicmp((const char*)v6, "fmt ", 4))
		v6 += (*(x_DWORD *)(v6 + 4) & 1) + *(x_DWORD *)(v6 + 4) + 8;
	if (*(x_WORD *)(v6 + 10) == 1 && *(x_WORD *)(v6 + 22) == 8)
	{
		sub_93AB0_AIL_set_sample_type(S, 0, 0);
	}
	else if (*(x_WORD *)(v6 + 10) == 2 && *(x_WORD *)(v6 + 22) == 8)
	{
		sub_93AB0_AIL_set_sample_type(S, 2, 0);
	}
	else if (*(x_WORD *)(v6 + 10) == 1 && *(x_WORD *)(v6 + 22) == 16)
	{
		sub_93AB0_AIL_set_sample_type(S, 1, 1);
	}
	else if (*(x_WORD *)(v6 + 10) == 2 && *(x_WORD *)(v6 + 22) == 16)
	{
		sub_93AB0_AIL_set_sample_type(S, 3, 1);
	}
	sub_93D90_AIL_set_sample_playback_rate(S, *(x_DWORD *)(v6 + 12));
	v5 = file_image + 12;
	for (j = _strnicmp((const char*)(file_image + 12), "data", 4); j; j = _strnicmp((const char*)v5, "data", 4))
		v5 += (*(x_DWORD *)(v5 + 4) & 1) + *(x_DWORD *)(v5 + 4) + 8;
	sub_93A10_AIL_set_sample_address(S, v5 + 8, *(x_DWORD *)(v5 + 4));
}
// 99B23: using guessed type x_DWORD strnicmp(x_DWORD, x_DWORD, x_DWORD);

//----- (000A4970) --------------------------------------------------------
HSAMPLE sub_A4970(int a1, Bit8u* a2, int a3)//285970
{
	signed int v5; // [esp+8h] [ebp-8h]
	HSAMPLE v6; // [esp+Ch] [ebp-4h]

	sub_A4330();
	if (!_strnicmp((const char*)a2, "Creative", 8))
	{
		v5 = 0;
	}
	else
	{
		if (_strnicmp((const char*)(a2 + 8), "WAVE", 4))
		{
			qmemcpy(&x_BYTE_181C90, (void*)"Unrecognized digital audio file type\n", 0x26u);
			return 0;
		}
		v5 = 1;
	}
	v6 = sub_93510_AIL_allocate_sample_handle((HDIGDRIVER)a1);
	if (!v6)
		return 0;
	sub_93830_AIL_init_sample(v6);
	v6->sam_var[541] = 0;
	if (v5)
	{
		if (v5 == 1)
		{
			v6->sam_var[547] = 1;
			sub_95140_AIL_register_EOS_callback(v6, sub_A4920);
			sub_A47C0_sub_set_sample_file(a2, v6);
		}
	}
	else
	{
		v6->sam_var[542] = *(unsigned __int16 *)(a2 + 20) + (int)a2;
		v6->sam_var[545] = a3;
		v6->sam_var[546] = a3 == -1;
		v6->sam_var[547] = 1;
		sub_95140_AIL_register_EOS_callback(v6, sub_A47A0);
		sub_A43E0(v6);
	}
	if (v6->sam_var[547] != -1)
		return v6;
	strcpy_s(x_BYTE_181C90, strlen("Invalid or missing data block\n") + 1, "Invalid or missing data block\n");

	return 0;
}
// 99B23: using guessed type x_DWORD strnicmp(x_DWORD, x_DWORD, x_DWORD);
// A47A0: using guessed type int sub_A47A0();
// A4920: using guessed type int sub_A4920();
// 181C90: using guessed type char x_BYTE_181C90;

//----- (000A4B20) --------------------------------------------------------
Bit32s sub_A4B20_set_sample_file(HSAMPLE S, Bit8u* file_image, Bit32s block)//285b20
{
	signed int v5; // [esp+8h] [ebp-4h]
	if (!_strnicmp((const char*)file_image, "Creative", 8))
	{
		v5 = 0;
	}
	else
	{
		if (_strnicmp((const char*)(file_image + 8), "WAVE", 4))
		{
			qmemcpy(&x_BYTE_181C90, (void*)"Unrecognized digital audio file type\n", 0x26u);
			return 0;
		}
		v5 = 1;
	}
	if (v5)
	{
		if (v5 == 1)
		{
			S->sam_var[547] = 0;
			sub_A47C0_sub_set_sample_file(file_image, S);
		}
	}
	else
	{
		S->sam_var542 = (Bit8u*)(*(unsigned __int16 *)(file_image + 20) + file_image);
		S->sam_var[545] = block;
		S->sam_var[546] = block == -1;
		S->sam_var[547] = 0;
		sub_A43E0(S);
	}
	if (S->sam_var[547] != -1)
		return 1;
	strcpy_s(x_BYTE_181C90, strlen("Invalid or missing data block\n") + 1, "Invalid or missing data block\n");
	return 0;
}
// 99B23: using guessed type x_DWORD strnicmp(x_DWORD, x_DWORD, x_DWORD);
// 181C90: using guessed type char x_BYTE_181C90;

//----- (000A4C60) --------------------------------------------------------
int sub_A4C60(int a1, int a2)
{
	int v2; // ST04_4

	if (!a1)
		return 0;
	v2 = *(x_DWORD *)(a1 + 2164);
	*(x_DWORD *)(a1 + 2164) = a2;
	return v2;
}

//----- (000A4CB0) --------------------------------------------------------
bool sub_A4CB0()
{
	bool result; // eax

	if (x_DWORD_E4A94)
	{
		result = sub_9D650((unsigned int)sub_A4330, (unsigned int)sub_A4CB0);
		x_DWORD_E4A94 = 0;
	}
	return result;
}
// E4A94: using guessed type int x_DWORD_E4A94;

//----- (000A4CF0) --------------------------------------------------------
void sub_A4CF0()
{
	//bool result; // eax

	if (!x_DWORD_E4B1C)
	{
		sub_9D590_lock_linear_region((Bit8u*)sub_A4CF0, (unsigned int)sub_A9280);
		sub_9D710((Bit8u*)aSample, 128);
		sub_9D710((Bit8u*)&x_DWORD_E4B18, 4);
		sub_9D710((Bit8u*)&x_DWORD_181EB8, 4);
		sub_9D710((Bit8u*)&x_DWORD_181EBC, 4);
		sub_9D710((Bit8u*)&x_DWORD_181EC0, 4);
		sub_9D710((Bit8u*)&x_DWORD_181EC4, 4);
		sub_9D710((Bit8u*)&x_DWORD_181ED4, 4);
		sub_9D710((Bit8u*)&x_DWORD_181EC8, 4);
		sub_9D710((Bit8u*)&x_DWORD_181ECC, 4);
		sub_9D710((Bit8u*)&x_DWORD_181EB4, 4);
		sub_9D710((Bit8u*)&x_DWORD_181ED0, 4);
		sub_9D710((Bit8u*)&x_DWORD_181EDC, 4);
		sub_9D710((Bit8u*)&x_DWORD_181ED8, 4);
		sub_9D710((Bit8u*)&x_DWORD_181EB0, 4);
		x_DWORD_E4B1C = 1;
	}
	//return result;
}
// E4B18: using guessed type int x_DWORD_E4B18;
// E4B1C: using guessed type int x_DWORD_E4B1C;
// 181EB0: using guessed type int x_DWORD_181EB0;
// 181EB4: using guessed type int x_DWORD_181EB4;
// 181EB8: using guessed type int x_DWORD_181EB8;
// 181EBC: using guessed type int x_DWORD_181EBC;
// 181EC0: using guessed type int x_DWORD_181EC0;
// 181EC4: using guessed type int x_DWORD_181EC4;
// 181EC8: using guessed type int x_DWORD_181EC8;
// 181ECC: using guessed type int x_DWORD_181ECC;
// 181ED0: using guessed type int x_DWORD_181ED0;
// 181ED4: using guessed type int x_DWORD_181ED4;
// 181ED8: using guessed type int x_DWORD_181ED8;
// 181EDC: using guessed type int x_DWORD_181EDC;

//----- (000A4E10) --------------------------------------------------------
signed int sub_A4E10(char a1)
{
	unsigned int v2; // [esp+0h] [ebp-8h]

	v2 = a1 & 0xF0;
	if (v2 < 0xB0)
	{
		if (v2 < 0x90)
		{
			if (v2 != 128)
				return 0;
		}
		else if (v2 > 0x90 && v2 != 160)
		{
			return 0;
		}
		return 3;
	}
	if (v2 > 0xB0)
	{
		if (v2 < 0xD0)
		{
			if (v2 != 192)
				return 0;
		}
		else if (v2 > 0xD0)
		{
			if (v2 != 224)
				return 0;
			return 3;
		}
		return 2;
	}
	return 3;
}

//----- (000A4EB0) --------------------------------------------------------
void sub_A4EB0(HMDIDRIVER a1)
{
	//HMDIDRIVER result; // eax
	VDI_CALL v2; // [esp+0h] [ebp-Ch]
	__int16 v3; // [esp+4h] [ebp-8h]

	//result = a1;
	if (a1->var106_aildrv > 0)
	{
		v3 = a1->var106_aildrv;
		sub_91F70_AIL_call_driver(a1->drvr_0, 1282, &v2, 0);
		a1->var106_aildrv = 0;
		//result = a1;
		a1->var107_aildrv = 0;
	}
	//return result;
}

//----- (000A4F10) --------------------------------------------------------
void sub_A4F10(HMDIDRIVER a1, char a2, char a3, char a4)
{
	Bit8u* v4; // ebx
	int v5; // edx
	Bit8u* v6; // ebx
	int v7; // edx
	Bit8u* v8; // ebx
	int v9; // edx
	//HMDIDRIVER result; // eax
	signed int v11; // [esp+0h] [ebp-4h]

	v11 = sub_A4E10(a2);
	if (v11 + a1->var107_aildrv > 0x200)
		sub_A4EB0(a1);
	v4 = (Bit8u*)a1->DST_2;
	v5 = a1->var107_aildrv++;
	v4[v5 + 256] = a2;
	v6 = (Bit8u*)a1->DST_2;
	v7 = a1->var107_aildrv++;
	v6[v7 + 256] = a3;
	if (v11 == 3)
	{
		v8 = (Bit8u*)a1->DST_2;
		v9 = a1->var107_aildrv++;
		v8[v9 + 256] = a4;
	}
	//result = a1;
	a1->var106_aildrv++;
	//return result;
}

//----- (000A4FD0) --------------------------------------------------------
void sub_A4FD0(int a1, int a2, unsigned int a3)
{
	sub_A4EB0((HMDIDRIVER)a1);
	if (a3 <= 0x200)
		;//fix it:memmove(*(x_DWORD *)(a1 + 8) + 256, a2, a3);
	else
		//fix it:memmove(*(x_DWORD *)(a1 + 8) + 256, a2, 512);
		++*(x_DWORD *)(a1 + 424);
	sub_A4EB0((HMDIDRIVER)a1);
}
// AD81F: using guessed type x_DWORD memmove(x_DWORD, x_DWORD, x_DWORD);

//----- (000A5040) --------------------------------------------------------
int sub_A5040(x_DWORD *a1)
{
	char v1; // ST08_1
	signed int v3; // [esp+4h] [ebp-Ch]
	int v4; // [esp+Ch] [ebp-4h]

	v4 = 0;
	v3 = 4;
	do
	{
		v1 = *(x_BYTE *)(*a1)++;
		v4 = v1 & 0x7F | (v4 << 7);
		if (!(v1 & 0x80))
			break;
		--v3;
	} while (v3);
	return v4;
}

//----- (000A50A0) --------------------------------------------------------
unsigned int sub_A50A0(int a1)
{
	return ((a1 & 0xFF000000) >> 24)
		+ ((a1 & 0xFF0000u) >> 8)
		+ ((unsigned __int16)(a1 & 0xFF00) << 8)
		+ ((unsigned __int8)a1 << 24);
}

//----- (000A50F0) --------------------------------------------------------
Bit8u* sub_A50F0(Bit8u* a1, int a2)
{
	Bit8u* v3; // [esp+0h] [ebp-Ch]
	Bit8u* v4; // [esp+4h] [ebp-8h]
	unsigned int v5; // [esp+8h] [ebp-4h]
	Bit8u* i; // [esp+1Ch] [ebp+10h]

	v5 = 0;
	do
	{
		a1 += v5;
		if (strncmp((const char*)a1, "FORM", 4) && strncmp((const char*)a1, "CAT ", 4))
			return 0;
		v5 = sub_A50A0(*(x_DWORD *)(a1 + 4)) + 8;
	} while (strncmp((const char*)(a1 + 8), "XMID", 4));
	if (!strncmp((const char*)a1, "FORM", 4))
	{
		if (a2)
			v3 = 0;
		else
			v3 = a1;
	}
	else
	{
		v4 = v5 + a1;
		for (i = a1 + 12; i < v4; i += sub_A50A0(*(x_DWORD *)(i + 4)) + 8)
		{
			if (!strncmp((const char*)(i + 8), "XMID", 4) && --a2 == -1)
				return i;
		}
		v3 = 0;
	}
	return v3;
}
// 99682: using guessed type x_DWORD strncmp(x_DWORD, x_DWORD, x_DWORD);

//----- (000A5210) --------------------------------------------------------
int sub_A5210(int a1, char a2, unsigned int a3)
{
	int v4; // [esp+0h] [ebp-Ch]
	int v5; // [esp+4h] [ebp-8h]
	unsigned int v6; // [esp+8h] [ebp-4h]

	v6 = a2 & 0xF0;
	v5 = a2 & 0xF;
	if (v6 < 0xC0)
	{
		if (v6 != 176)
			return -1;
		if (a3 < 0x5D)
		{
			if (a3 < 0xA)
			{
				if (a3 < 6)
				{
					if (a3 == 1)
						return *(x_DWORD *)(a1 + 4 * v5 + 640);
				}
				else
				{
					if (a3 <= 6)
						return *(x_DWORD *)(a1 + 4 * v5 + 1088);
					if (a3 == 7)
						return *(x_DWORD *)(a1 + 4 * v5 + 704);
				}
			}
			else
			{
				if (a3 <= 0xA)
					return *(x_DWORD *)(a1 + 4 * v5 + 768);
				if (a3 < 0x40)
				{
					if (a3 == 11)
						return *(x_DWORD *)(a1 + 4 * v5 + 832);
				}
				else
				{
					if (a3 <= 0x40)
						return *(x_DWORD *)(a1 + 4 * v5 + 896);
					if (a3 == 91)
						return *(x_DWORD *)(a1 + 4 * v5 + 960);
				}
			}
		}
		else
		{
			if (a3 <= 0x5D)
				return *(x_DWORD *)(a1 + 4 * v5 + 1024);
			if (a3 < 0x70)
			{
				if (a3 >= 0x6E)
				{
					if (a3 <= 0x6E)
						v4 = *(x_DWORD *)(a1 + 4 * v5 + 192);
					else
						v4 = *(x_DWORD *)(a1 + 4 * v5 + 256);
					return v4;
				}
				if (a3 == 107)
					return *(x_DWORD *)(a1 + 4 * v5 + 320);
			}
			else
			{
				if (a3 <= 0x70)
					return *(x_DWORD *)(a1 + 4 * v5 + 384);
				if (a3 < 0x73)
				{
					if (a3 == 114)
						return *(x_DWORD *)(a1 + 4 * v5 + 448);
				}
				else
				{
					if (a3 <= 0x73)
						return *(x_DWORD *)(a1 + 4 * v5 + 512);
					if (a3 == 119)
						return *(x_DWORD *)(a1 + 4 * v5 + 576);
				}
			}
		}
		return -1;
	}
	if (v6 <= 0xC0)
		return *(x_DWORD *)(a1 + 4 * v5);
	if (v6 != 224)
		return -1;
	return (*(x_DWORD *)(a1 + 4 * v5 + 128) << 7) | *(x_DWORD *)(a1 + 4 * v5 + 64);
}

//----- (000A5530) --------------------------------------------------------
x_DWORD *sub_A5530(int a1, char a2, unsigned int a3, unsigned __int8 a4)
{
	x_DWORD *result; // eax
	int v5; // [esp+0h] [ebp-8h]
	unsigned int v6; // [esp+4h] [ebp-4h]

	v6 = a2 & 0xF0;
	result = (x_DWORD *)(a2 & 0xF);
	v5 = a2 & 0xF;
	if (v6 < 0xC0)
	{
		if (v6 == 176)
		{
			if (a3 < 0x5D)
			{
				if (a3 < 0xA)
				{
					if (a3 < 6)
					{
						if (a3 == 1)
						{
							result = (x_DWORD *)(a1 + 4 * v5);
							result[160] = a4;
						}
					}
					else if (a3 <= 6)
					{
						result = (x_DWORD *)(a1 + 4 * v5);
						result[272] = a4;
					}
					else if (a3 == 7)
					{
						result = (x_DWORD *)(a1 + 4 * v5);
						result[176] = a4;
					}
				}
				else if (a3 <= 0xA)
				{
					result = (x_DWORD *)(a1 + 4 * v5);
					result[192] = a4;
				}
				else if (a3 < 0x40)
				{
					if (a3 == 11)
					{
						result = (x_DWORD *)(a1 + 4 * v5);
						result[208] = a4;
					}
				}
				else if (a3 <= 0x40)
				{
					result = (x_DWORD *)(a1 + 4 * v5);
					result[224] = a4;
				}
				else if (a3 == 91)
				{
					result = (x_DWORD *)(a1 + 4 * v5);
					result[240] = a4;
				}
			}
			else if (a3 <= 0x5D)
			{
				result = (x_DWORD *)(a1 + 4 * v5);
				result[256] = a4;
			}
			else if (a3 < 0x70)
			{
				if (a3 < 0x6E)
				{
					if (a3 == 107)
					{
						result = (x_DWORD *)(a1 + 4 * v5);
						result[80] = a4;
					}
				}
				else if (a3 <= 0x6E)
				{
					result = (x_DWORD *)(a1 + 4 * v5);
					result[48] = a4;
				}
				else
				{
					result = (x_DWORD *)(a1 + 4 * v5);
					result[64] = a4;
				}
			}
			else if (a3 <= 0x70)
			{
				result = (x_DWORD *)(a1 + 4 * v5);
				result[96] = a4;
			}
			else if (a3 < 0x73)
			{
				if (a3 == 114)
				{
					result = (x_DWORD *)(a1 + 4 * v5);
					result[112] = a4;
				}
			}
			else if (a3 <= 0x73)
			{
				result = (x_DWORD *)(a1 + 4 * v5);
				result[128] = a4;
			}
			else if (a3 == 119)
			{
				result = (x_DWORD *)(a1 + 4 * v5);
				result[144] = a4;
			}
		}
	}
	else if (v6 <= 0xC0)
	{
		result = (x_DWORD *)(a1 + 4 * v5);
		*result = (unsigned __int8)a3;
	}
	else if (v6 == 224)
	{
		*(x_DWORD *)(a1 + 4 * v5 + 64) = (unsigned __int8)a3;
		result = (x_DWORD *)(a1 + 4 * v5);
		result[32] = a4;
	}
	return result;
}

//----- (000A5850) --------------------------------------------------------
void sub_A5850(HSEQUENCE S, char a2, unsigned int a3, signed int a4, int a5)//286850
{
	HMDIDRIVER result; // eax
	int v6; // eax
	HMDIDRIVER v7; // [esp+0h] [ebp-14h]
	int v8; // [esp+4h] [ebp-10h]
	int v9; // [esp+8h] [ebp-Ch]
	signed int i; // [esp+Ch] [ebp-8h]
	signed int j; // [esp+Ch] [ebp-8h]
	x_DWORD *v12; // [esp+Ch] [ebp-8h]
	int v13; // [esp+10h] [ebp-4h]

	v7 = S->driver_0;
	v13 = a2 & 0xF0;
	v8 = a2 & 0xF;
	//result = S->chan_map_37[4 * v8];
	v9 = S->chan_map_37[4 * v8];
	if (v13 == 176 || v13 == 192 || v13 == 224)
		result = (HMDIDRIVER)sub_A5530((int)&S->shadow_53, v8 | v13, a3, a4);
	if (v13 != 176)
		goto LABEL_79;
	if (a5)
	{
		//result = (x_DWORD *)(S + 4 * v8);
		if (S->shadow_53.indirect[4 * v8] != -1)
		{
			a4 = S->shadow_53.indirect[4 * v8];
			//result = (x_DWORD *)(S + 4 * v8);
			S->shadow_53.indirect[4 * v8] = -1;
		}
	}
	if (a3 < 0x6F)
	{
		if (a3 < 0x6C)
		{
			if (a3 >= 6)
			{
				if (a3 <= 6)
				{
					sub_A5850(S, v8 | 0xB0, 0x64u, 0, 0);
					sub_A5850(S, v8 | 0xB0, 0x65u, 0, 0);
					sub_A5850(S, v8 | 0xB0, 0x26u, 0, 0);
				}
				else if (a3 == 7)
				{
					a4 = S->volume_14 * a4 * v7->var108_aildrv / 16129;
					if (a4 > 127)
						a4 = 127;
					if (a4 < 0)
						a4 = 0;
				}
			}
			goto LABEL_79;
		}
		if (a3 <= 0x6C)
		{
			if (S->prefix_callback_7)
				S->shadow_53.indirect[4 * v8] = (*(int(**)(HSEQUENCE, int, signed int))(S->prefix_callback_7))(S, v8, a4);
			goto LABEL_79;
		}
		if (a3 <= 0x6D)
		{
			/*result = */sub_97480_AIL_branch_index(S, a4);
		}
		else if (a4 < 64)
		{
			//result = &v7[v9];
			if (v7->lock[v9] == 1)
			{
				sub_A5F30((int*)S, v8);
				sub_980D0_AIL_release_channel((int32*)v7, v9 + 1);
				/*result = (x_DWORD *)*/sub_98170_AIL_map_sequence_channel((int32*)S, v8 + 1, v8 + 1);
			}
		}
		else
		{
			//result = &v7[v9];
			if (v7->lock[v9] != 1)
			{
				result = (HMDIDRIVER)(x_DWORD *)sub_97F90_AIL_lock_channel((int32*)v7);
				v12 = (int32*)result;
				if (result)
				{
					sub_98170_AIL_map_sequence_channel((int32*)S, v8 + 1, (int)result);
					result = (HMDIDRIVER)(x_DWORD *)S;
					v7->var23_aildrvx[(int)v12] = S;
				}
			}
		}
	}
	else if (a3 <= 0x6F)
	{
		//result = &v7[v9];
		if (v7->lock[v9] != 1)
		{
			if (a4 >= 64)
			{
				//result = &v7[v9];
				v7->lock[v9] = 2;
			}
			else
			{
				//result = &v7[v9];
				v7->lock[v9] = 0;
			}
		}
	}
	else if (a3 < 0x75)
	{
		if (a3 < 0x73)
			goto LABEL_79;
		if (a3 <= 0x73)
		{
			*(x_DWORD *)(S + 4 * v8 + 724) = *(unsigned __int8 *)(a4 + *(x_DWORD *)(S + 24));
		LABEL_79:
			if (v7->lock[v9] != 1 || v7->locker[v9] == S)
			{
				if (v13 == 144)
				{
					v7->notes[v9]++;
				}
				else if (v13 == 128)
				{
					v7->notes[v9]--;
				}
				v7->user[v9] = S;
				if (v13 != 144 || S->shadow_53.c_mute[4 * v8] < 64)
				{
					if (!v7->event_trap
						|| (result = (HMDIDRIVER)(x_DWORD *)((int(*)(HMDIDRIVER, HSEQUENCE, int, unsigned int, signed int))v7->event_trap)(
							v7,
							S,
							v9 | v13,
							a3,
							(int)a4)) == 0)
					{
						/*result = (x_DWORD *)*/sub_A4F10(v7, v9 | v13, a3, a4);
					}
				}
			}
			return;
		}
		for (i = 0; i < 4; i++)
		{
			//result = (x_DWORD *)(S + 4 * i);
			if (S->FOR_loop_count_33[4 * i] == -1)
				break;
			//result = (HMDIDRIVER)(x_DWORD *)i;
		}
		if (i != 4)
		{
			S->FOR_loop_count_33[4 * i] = a4;
			//result = *(x_DWORD **)(S + 20);
			S->FOR_ptrs[4 * i] = S->EVNT_ptr_5;
		}
	}
	else if (a3 <= 0x75)
	{
		if (a4 >= 64)
		{
			for (j = 3; j >= 0; j--)
			{
				//result = (x_DWORD *)(S + 4 * j);
				if (S->FOR_loop_count_33[4 * j] != -1)
					break;
				//result = (x_DWORD *)j;
			}
			if (j != -1)
			{
				if (S->FOR_loop_count_33[4 * j])
				{
					//v6 = a1 + 4 * j;
					if (--S->FOR_loop_count_33[4 * j])
					{
						//result = (x_DWORD *)S;
						S->EVNT_ptr_5 = (Bit8u*)S->FOR_ptrs[4 * j];
					}
					else
					{
						//result = (x_DWORD *)(S + 4 * j);
						S->FOR_loop_count_33[4 * j] = -1;
					}
				}
				else
				{
					//result = (x_DWORD *)S;
					S->EVNT_ptr_5 = (Bit8u*)S->FOR_loop_count_33[4 * j];
				}
			}
		}
	}
	else if (a3 <= 0x76)
	{
		*(x_DWORD *)(S + 92) = 0;
		*(x_DWORD *)(S + 96) = 0;
		*(x_DWORD *)(S + 108) = 0;
		*(x_DWORD *)(S + 108) -= *(x_DWORD *)(S + 104);
		//result = (x_DWORD *)S;
		if (S->beat_callback_9)
			/*result = (x_DWORD *)*/(*(int(**)(HMDIDRIVER, HSEQUENCE, x_DWORD, x_DWORD))(S->beat_callback_9))(v7, S, 0, 0);
	}
	else
	{
		if (a3 != 119)
			goto LABEL_79;
		//result = (x_DWORD *)S;
		if (S->trigger_callback_8_32)
			/*result = (x_DWORD *)*/(*(int(**)(HSEQUENCE, int, signed int))(S->trigger_callback_8_32))(S, v8, a4);
	}
}

//----- (000A5E50) --------------------------------------------------------
void sub_A5E50(HSEQUENCE S)
{
	int v1; // eax
	int v3; // [esp+0h] [ebp-8h]
	signed int i; // [esp+4h] [ebp-4h]

	v3 = 0;
	for (i = 0; i < 32; i++)
	{
		if (S->seq_342[i] != -1)
		{
			sub_A5850(S, S->seq_342[i] | 0x80, S->seq_374[i], 0, 0);
			S->seq_342[i] = -1;
			v3++;
		}
	}
	S->seq_341 = 0;
	/*LOBYTE(v1) = */sub_A4EB0((HMDIDRIVER)S->driver_0);
	if (v3)
	{
		v1 = sub_92160();
		if (!v1)
			/*LOBYTE(v1) = */sub_920D0_AIL_delay(3);
	}
	//return v1;
}

//----- (000A5F30) --------------------------------------------------------
void sub_A5F30(int *a1, int a2)
{
	signed int i; // [esp+0h] [ebp-4h]

	for (i = 0; i < 32; i++)
	{
		if (a1[i + 342] == a2)
		{
			sub_A5850((HSEQUENCE)a1, a1[i + 342] | 0x80, a1[i + 374], 0, 0);
			a1[i + 342] = -1;
		}
	}
	return sub_A4EB0((HMDIDRIVER)*a1);
}

//----- (000A5FD0) --------------------------------------------------------
void sub_A5FD0(int a1, int a2)
{
	x_DWORD *result; // eax

	if (*(x_DWORD *)(a1 + 4 * a2 + 660) != -1)
		sub_A5850((HSEQUENCE)a1, a2 | 0xB0, 0x72u, *(x_DWORD *)(a1 + 4 * a2 + 660), 0);
	if (*(x_DWORD *)(a1 + 4 * a2 + 212) != -1)
		sub_A5850((HSEQUENCE)a1, a2 | 0xC0, *(x_DWORD *)(a1 + 4 * a2 + 212), 0, 0);
	if (*(x_DWORD *)(a1 + 4 * a2 + 340) != -1)
		sub_A5850((HSEQUENCE)a1, a2 | 0xE0, *(x_DWORD *)(a1 + 4 * a2 + 276), *(x_DWORD *)(a1 + 4 * a2 + 340), 0);
	if (*(x_DWORD *)(a1 + 4 * a2 + 532) != -1)
		sub_A5850((HSEQUENCE)a1, a2 | 0xB0, 0x6Bu, *(x_DWORD *)(a1 + 4 * a2 + 532), 0);
	if (*(x_DWORD *)(a1 + 4 * a2 + 468) != -1)
		sub_A5850((HSEQUENCE)a1, a2 | 0xB0, 0x6Fu, *(x_DWORD *)(a1 + 4 * a2 + 468), 0);
	if (*(x_DWORD *)(a1 + 4 * a2 + 596) != -1)
		sub_A5850((HSEQUENCE)a1, a2 | 0xB0, 0x70u, *(x_DWORD *)(a1 + 4 * a2 + 596), 0);
	if (*(x_DWORD *)(a1 + 4 * a2 + 852) != -1)
		sub_A5850((HSEQUENCE)a1, a2 | 0xB0, 1u, *(x_DWORD *)(a1 + 4 * a2 + 852), 0);
	if (*(x_DWORD *)(a1 + 4 * a2 + 916) != -1)
		sub_A5850((HSEQUENCE)a1, a2 | 0xB0, 7u, *(x_DWORD *)(a1 + 4 * a2 + 916), 0);
	if (*(x_DWORD *)(a1 + 4 * a2 + 980) != -1)
		sub_A5850((HSEQUENCE)a1, a2 | 0xB0, 0xAu, *(x_DWORD *)(a1 + 4 * a2 + 980), 0);
	if (*(x_DWORD *)(a1 + 4 * a2 + 1044) != -1)
		sub_A5850((HSEQUENCE)a1, a2 | 0xB0, 0xBu, *(x_DWORD *)(a1 + 4 * a2 + 1044), 0);
	if (*(x_DWORD *)(a1 + 4 * a2 + 1108) != -1)
		sub_A5850((HSEQUENCE)a1, a2 | 0xB0, 0x40u, *(x_DWORD *)(a1 + 4 * a2 + 1108), 0);
	if (*(x_DWORD *)(a1 + 4 * a2 + 1172) != -1)
		sub_A5850((HSEQUENCE)a1, a2 | 0xB0, 0x5Bu, *(x_DWORD *)(a1 + 4 * a2 + 1172), 0);
	if (*(x_DWORD *)(a1 + 4 * a2 + 1236) != -1)
		sub_A5850((HSEQUENCE)a1, a2 | 0xB0, 0x5Du, *(x_DWORD *)(a1 + 4 * a2 + 1236), 0);
	result = (x_DWORD *)(a1 + 4 * a2);
	if (result[325] != -1)
		/*result = (int32*)*/sub_A5850((HSEQUENCE)a1, a2 | 0xB0, 6u, *(x_DWORD *)(a1 + 4 * a2 + 1300), 0);
}

//----- (000A6370) --------------------------------------------------------
void sub_A6370(HSEQUENCE a1)//287370
{
	//x_DWORD *result; // eax
	signed int i; // [esp+0h] [ebp-4h]
	signed int j; // [esp+0h] [ebp-4h]
	signed int k; // [esp+0h] [ebp-4h]

	for (i = 0; i < 16; i++)
		a1->chan_map_37[i] = i;
	memset((void*)&a1->shadow_53, -1, sizeof(CTRL_LOG));
	for (j = 0; j < 4; j++)
		a1->FOR_loop_count_33[j] = -1;
	for (k = 0; k < 32; k++)
		a1->seq_342[k] = -1;
	a1->seq_341 = 0;
	a1->interval_count_12 = 0;
	a1->beat_count_23 = 0;
	a1->measure_count_24 = -1;
	a1->beat_fraction_27 = 0;
	a1->time_fraction_26 = 0;
	a1->time_numerator_25 = 4;
	a1->time_per_beat_28 = 8000000;
	//result = a1;
	a1->interval_num_13 = 0;
	//return result;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);

//----- (000A6490) --------------------------------------------------------
void sub_A6490(HSEQUENCE S)
{
	//x_DWORD *result; // eax

	sub_A6370(S);
	//result = a1;
	S->EVNT_ptr_5 = (Bit8u*)S->EVNT_4 + 8;
	//return result;
}

//----- (000A64C0) --------------------------------------------------------
void sub_A64C0(HSEQUENCE S)
{
	for (Bit32s i = 0; i < 16; i++)
	{
		if (S->shadow_53.pan[i] != -1)
			sub_A5850(S, i | 0xB0, 7u, S->shadow_53.pan[i], 0);
	}
}

void sub_A6530(HMDIDRIVER a1)//287530
{
	int result; // eax
	//SEQUENCE v2; // eax
	int v3; // eax
	HSEQUENCE v4; // eax
	HSEQUENCE v5; // eax
	HSEQUENCE v6; // eax
	HSEQUENCE v7; // esi
	unsigned __int8 *v8; // edx

	//result = (int)a1;
	if (!a1->disable_5 && !x_DWORD_E4B18)
	{
		x_DWORD_E4B18 = 1;
		x_DWORD_181EC4 = a1->n_sequences_7;
		for (x_DWORD_181EB8 = a1->sequences_6; ; x_DWORD_181EB8 += 1816)
		{
			if (!x_DWORD_181EC4)
			{
				/*result = */sub_A4EB0(a1);
				x_DWORD_E4B18 = 0;
				//return result;
				return;
			}
			if (*(_DWORD *)(x_DWORD_181EB8 + 4) == 4)
			{
				x_DWORD_181ED4 = 0;
				++*(_DWORD *)(x_DWORD_181EB8 + 52);
				*(_DWORD *)(x_DWORD_181EB8 + 88) += *(_DWORD *)(x_DWORD_181EB8 + 72);
				while (*(_DWORD *)(x_DWORD_181EB8 + 88) >= 100)
				{
					*(_DWORD *)(x_DWORD_181EB8 + 88) -= 100;
					if (*(_DWORD *)(x_DWORD_181EB8 + 1364) > 0)
					{
						for (x_DWORD_181EBC = 0; x_DWORD_181EBC < 32; x_DWORD_181EBC++)
						{
							if (*(_DWORD *)(x_DWORD_181EB8 + 4 * x_DWORD_181EBC + 1368) != -1)
							{
								//v2 = x_DWORD_181EB8[4 * x_DWORD_181EBC];
								if (--x_DWORD_181EB8->note_time[x_DWORD_181EBC] <= 0)
								{
									v3 = *(_DWORD *)(x_DWORD_181EB8 + 4 * x_DWORD_181EBC + 1368);
									LOBYTE(v3) = v3 | 0x80;
									sub_A5850(x_DWORD_181EB8, v3, *(_DWORD *)(4 * x_DWORD_181EBC + x_DWORD_181EB8 + 1496), 0, 0);
									*(_DWORD *)(x_DWORD_181EB8 + 4 * x_DWORD_181EBC + 1368) = -1;
									v4 = x_DWORD_181EB8;
									if (!--*(_DWORD *)(v4 + 1364))
										break;
								}
							}
						}
					}
					v5 = x_DWORD_181EB8;
					if (--*(_DWORD *)(v5 + 48) <= 0)
					{
						while (1)
						{
							while (1)
							{
								x_DWORD_181ED0 = **(unsigned __int8 **)(x_DWORD_181EB8 + 20);
								if ((unsigned int)x_DWORD_181ED0 < 0x80 || x_DWORD_181ED4)
								{
									if (!x_DWORD_181ED4)
									{
										v8 = (unsigned __int8 *)(*(_DWORD *)(x_DWORD_181EB8 + 20))++;
										*(_DWORD *)(x_DWORD_181EB8 + 48) = *v8;
									}
									goto LABEL_62;
								}
								if ((unsigned int)x_DWORD_181ED0 >= 0xF7)
									break;
								if (x_DWORD_181ED0 != 240)
									goto LABEL_49;
							LABEL_48:
								x_DWORD_181EB0 = *(_DWORD *)(x_DWORD_181EB8 + 20) + 1;
								x_DWORD_181ED8 = sub_A5040(&x_DWORD_181EB0);
								x_DWORD_181ED8 += x_DWORD_181EB0 - *(_DWORD *)(x_DWORD_181EB8 + 20);
								sub_A4FD0((int)a1, *(_DWORD *)(x_DWORD_181EB8 + 20), x_DWORD_181ED8);
								*(_DWORD *)(x_DWORD_181EB8 + 20) += x_DWORD_181ED8;
							}
							if ((unsigned int)x_DWORD_181ED0 <= 0xF7)
								goto LABEL_48;
							if (x_DWORD_181ED0 == 255)
							{
								x_DWORD_181EDC = *(unsigned __int8 *)(*(_DWORD *)(x_DWORD_181EB8 + 20) + 1);
								*(_DWORD *)(x_DWORD_181EB8 + 20) += 2;
								x_DWORD_181ED8 = sub_A5040((int32*)x_DWORD_181EB8 + 20);
								if ((unsigned int)x_DWORD_181EDC < 0x51)
								{
									if (x_DWORD_181EDC == 47)
									{
										x_DWORD_181ED4 = 1;
										if (*(_DWORD *)(x_DWORD_181EB8 + 44)
											&& (v6 = x_DWORD_181EB8, --*(_DWORD *)(v6 + 44), !*(_DWORD *)(v6 + 44)))
										{
											sub_95DE0_AIL_stop_sequence(x_DWORD_181EB8);
											*(_DWORD *)(x_DWORD_181EB8 + 4) = 2;
											if (*(_DWORD *)(x_DWORD_181EB8 + 40))
												(*(void(__cdecl **)(HSEQUENCE))(x_DWORD_181EB8 + 40))(x_DWORD_181EB8);
										}
										else
										{
											*(_DWORD *)(x_DWORD_181EB8 + 20) = *(_DWORD *)(x_DWORD_181EB8 + 16) + 8;
											*(_DWORD *)(x_DWORD_181EB8 + 92) = 0;
											*(_DWORD *)(x_DWORD_181EB8 + 96) = -1;
											*(_DWORD *)(x_DWORD_181EB8 + 108) = 0;
											if (*(_DWORD *)(x_DWORD_181EB8 + 36))
												(*(void(__cdecl **)(_DWORD, HSEQUENCE, _DWORD, _DWORD))(x_DWORD_181EB8 + 36))(
													*(_DWORD *)x_DWORD_181EB8,
													x_DWORD_181EB8,
													0,
													0);
										}
									}
								}
								else if ((unsigned int)x_DWORD_181EDC <= 0x51)
								{
									x_DWORD_181ECC = *(unsigned __int8 *)(*(_DWORD *)(x_DWORD_181EB8 + 20) + 2)
										+ (**(unsigned __int8 **)(x_DWORD_181EB8 + 20) << 16)
										+ (*(unsigned __int8 *)(*(_DWORD *)(x_DWORD_181EB8 + 20) + 1) << 8);
									*(_DWORD *)(x_DWORD_181EB8 + 112) = 16 * x_DWORD_181ECC;
								}
								else if (x_DWORD_181EDC == 88)
								{
									*(_DWORD *)(x_DWORD_181EB8 + 100) = **(unsigned __int8 **)(x_DWORD_181EB8 + 20);
									x_DWORD_181ECC = *(unsigned __int8 *)(*(_DWORD *)(x_DWORD_181EB8 + 20) + 1) - 2;
									x_DWORD_181EC8 = 16000000 / x_DWORD_181DAC[11];
									if (x_DWORD_181ECC >= 0)
									{
										*(_DWORD *)(x_DWORD_181EB8 + 104) = x_DWORD_181EC8 << x_DWORD_181ECC;
									}
									else
									{
										x_DWORD_181ECC = -x_DWORD_181ECC;
										*(_DWORD *)(x_DWORD_181EB8 + 104) = x_DWORD_181EC8 >> x_DWORD_181ECC;
									}
									*(_DWORD *)(x_DWORD_181EB8 + 108) = 0;
									*(_DWORD *)(x_DWORD_181EB8 + 108) -= *(_DWORD *)(x_DWORD_181EB8 + 104);
									*(_DWORD *)(x_DWORD_181EB8 + 92) = 0;
									++*(_DWORD *)(x_DWORD_181EB8 + 96);
									if (*(_DWORD *)(x_DWORD_181EB8 + 36))
										(*(void(__cdecl **)(_DWORD, HSEQUENCE, _DWORD, _DWORD))(x_DWORD_181EB8 + 36))(
											*(_DWORD *)x_DWORD_181EB8,
											x_DWORD_181EB8,
											*(_DWORD *)(x_DWORD_181EB8 + 92),
											*(_DWORD *)(x_DWORD_181EB8 + 96));
								}
								*(_DWORD *)(x_DWORD_181EB8 + 20) += x_DWORD_181ED8;
							}
							else
							{
							LABEL_49:
								x_DWORD_181EB4 = x_DWORD_181ED0 & 0xF;
								x_DWORD_181ED0 &= 0xF0u;
								sub_A5850(
									x_DWORD_181EB8,
									**(unsigned __int8 **)(x_DWORD_181EB8 + 20),
									*(unsigned __int8 *)(*(_DWORD *)(x_DWORD_181EB8 + 20) + 1),
									*(unsigned __int8 *)(*(_DWORD *)(x_DWORD_181EB8 + 20) + 2),
									1);
								if (x_DWORD_181ED0 == 144)
								{
									for (x_DWORD_181EBC = 0;
										x_DWORD_181EBC < 32 && *(_DWORD *)(x_DWORD_181EB8 + 4 * x_DWORD_181EBC + 1368) != -1;
										++x_DWORD_181EBC)
									{
										;
									}
									if (x_DWORD_181EBC == 32)
									{
										qmemcpy(x_BYTE_181C90, (void*)"Internal note queue overflow\n\0", 0x1Eu);
										sub_95DE0_AIL_stop_sequence(x_DWORD_181EB8);
										//result = x_DWORD_181EB8;
										*(_DWORD *)(x_DWORD_181EB8 + 4) = 2;
										x_DWORD_E4B18 = 0;
										//return result;
										return;
									}
									++*(_DWORD *)(x_DWORD_181EB8 + 1364);
									*(_DWORD *)(4 * x_DWORD_181EBC + x_DWORD_181EB8 + 1368) = x_DWORD_181EB4;
									*(_DWORD *)(4 * x_DWORD_181EBC + x_DWORD_181EB8 + 1496) = *(unsigned __int8 *)(*(_DWORD *)(x_DWORD_181EB8 + 20)
										+ 1);
									*(_DWORD *)(x_DWORD_181EB8 + 20) += 3;
									*(_DWORD *)(x_DWORD_181EB8 + 4 * x_DWORD_181EBC + 1624) = sub_A5040((int32*)x_DWORD_181EB8 + 20);
								}
								else
								{
									v7 = x_DWORD_181EB8;
									*(_DWORD *)(v7 + 20) += sub_A4E10(**(unsigned __int8 **)(x_DWORD_181EB8 + 20));
								}
							}
						}
					}
				LABEL_62:
					if (!x_DWORD_181ED4)
					{
						*(_DWORD *)(x_DWORD_181EB8 + 108) += *(_DWORD *)(x_DWORD_181EB8 + 104);
						if (*(_DWORD *)(x_DWORD_181EB8 + 108) >= *(_DWORD *)(x_DWORD_181EB8 + 112))
						{
							*(_DWORD *)(x_DWORD_181EB8 + 108) -= *(_DWORD *)(x_DWORD_181EB8 + 112);
							if (++*(_DWORD *)(x_DWORD_181EB8 + 92) >= *(_DWORD *)(x_DWORD_181EB8 + 100))
							{
								*(_DWORD *)(x_DWORD_181EB8 + 92) = 0;
								++*(_DWORD *)(x_DWORD_181EB8 + 96);
							}
							if (*(_DWORD *)(x_DWORD_181EB8 + 36))
							{
								sub_97330_AIL_sequence_position((int32*)x_DWORD_181EB8, &x_DWORD_181EBC, &x_DWORD_181EC0);
								(*(void(__cdecl **)(_DWORD, HSEQUENCE, int, int))(x_DWORD_181EB8 + 36))(
									*(_DWORD *)x_DWORD_181EB8,
									x_DWORD_181EB8,
									x_DWORD_181EBC,
									x_DWORD_181EC0);
							}
						}
					}
				}
				if (!x_DWORD_181ED4)
				{
					if (*(_DWORD *)(x_DWORD_181EB8 + 56) != *(_DWORD *)(x_DWORD_181EB8 + 60))
					{
						*(_DWORD *)(x_DWORD_181EB8 + 64) += *(_DWORD *)(*(_DWORD *)x_DWORD_181EB8 + 16);
						do
						{
							if (*(_DWORD *)(x_DWORD_181EB8 + 64) < *(_DWORD *)(x_DWORD_181EB8 + 68))
								break;
							*(_DWORD *)(x_DWORD_181EB8 + 64) -= *(_DWORD *)(x_DWORD_181EB8 + 68);
							if (*(_DWORD *)(x_DWORD_181EB8 + 60) <= *(_DWORD *)(x_DWORD_181EB8 + 56))
								--*(_DWORD *)(x_DWORD_181EB8 + 56);
							else
								++*(_DWORD *)(x_DWORD_181EB8 + 56);
						} while (*(_DWORD *)(x_DWORD_181EB8 + 56) != *(_DWORD *)(x_DWORD_181EB8 + 60));
						if (!(*(_BYTE *)(x_DWORD_181EB8 + 52) & 7))
							sub_A64C0(x_DWORD_181EB8);
					}
					if (*(_DWORD *)(x_DWORD_181EB8 + 72) != *(_DWORD *)(x_DWORD_181EB8 + 76))
					{
						*(_DWORD *)(x_DWORD_181EB8 + 80) += *(_DWORD *)(*(_DWORD *)x_DWORD_181EB8 + 16);
						do
						{
							if (*(_DWORD *)(x_DWORD_181EB8 + 80) < *(_DWORD *)(x_DWORD_181EB8 + 84))
								break;
							*(_DWORD *)(x_DWORD_181EB8 + 80) -= *(_DWORD *)(x_DWORD_181EB8 + 84);
							if (*(_DWORD *)(x_DWORD_181EB8 + 76) <= *(_DWORD *)(x_DWORD_181EB8 + 72))
								--*(_DWORD *)(x_DWORD_181EB8 + 72);
							else
								++*(_DWORD *)(x_DWORD_181EB8 + 72);
						} while (*(_DWORD *)(x_DWORD_181EB8 + 72) != *(_DWORD *)(x_DWORD_181EB8 + 76));
					}
				}
			}
			--x_DWORD_181EC4;
		}
	}
	//return result;
	return;
}

//----- (000A6E00) --------------------------------------------------------
int sub_A6E00_sound_proc25(HMDIDRIVER a1, IO_PARMS* a2)//287e00
{
	IO_PARMS v3; // [esp+0h] [ebp-24h]
	/*__int16 v4; // [esp+2h] [ebp-22h]
	__int16 v5; // [esp+4h] [ebp-20h]
	__int16 v6; // [esp+6h] [ebp-1Eh]*/
	//int v7; // [esp+8h] [ebp-1Ch]
	unsigned int i; // [esp+1Ch] [ebp-8h]
	IO_PARMS v9; // [esp+20h] [ebp-4h]


	qmemcpy(&v3, (void*)a2, 0x18u);
	if (1/*a1->var0_aildrv->AIL_DRIVER_var4_VHDR->environment_string*//**(x_WORD *)(*(x_DWORD *)(*a1 + 16) + 16)*/)//fixed
	{
		/*v9 = (__int16 *)((a1->var0_aildrv->AIL_DRIVER_var4_VHDR->VDI_HDR_var12) & 0xFFFF
					   + 16 * a1->var0_aildrv->AIL_DRIVER_var4_VHDR->VDI_HDR_var12 >> 16);
		*/
		v9.IO = 0x220;
		v9.IRQ = -1;
		v9.DMA_8_bit = -1;
		v9.DMA_16_bit = -1;
		v9.IO_reserved[0] = -1;
		v9.IO_reserved[1] = -1;
		v9.IO_reserved[2] = -1;
		v9.IO_reserved[3] = -1;//fixed
		if (v3.IO < 1)
			v3.IO = v9.IO;
		if (v3.IRQ < 1)
			v3.IRQ = v9.IRQ;
		if (v3.DMA_8_bit < 1)
			v3.DMA_8_bit = v9.DMA_8_bit;
		if (v3.DMA_16_bit < 1)
			v3.DMA_16_bit = v9.DMA_16_bit;
		for (i = 0; i < 4; i++)
		{
			if (v3.IO_reserved[i] < 1)
				v3.IO_reserved[i] = v9.IO_reserved[i];
		}
	}
	qmemcpy((void *)&a1->drvr_0->VHDR_4->IO, &v3, 0x18u);
	return sub_91F70_AIL_call_driver(a1->drvr_0, 772, 0, 0);
}

//----- (000A6FB0) --------------------------------------------------------
HMDIDRIVER sub_A6FB0_sound_proc26(AIL_DRIVER* a1, IO_PARMS *a2)//287fb0
{
	__int64 v2; // rtt
	unsigned int v3; // eax
	IO_PARMS v5; // [esp+0h] [ebp-3Ch]
	VDI_CALL v6; // [esp+18h] [ebp-24h]
	//unsigned __int16 v7; // [esp+1Ah] [ebp-22h]
	//unsigned __int16 v8; // [esp+1Ch] [ebp-20h]
	//unsigned __int16 v9; // [esp+1Eh] [ebp-1Eh]
	HMDIDRIVER v10; // [esp+24h] [ebp-18h]
	Bit8u* v11; // [esp+28h] [ebp-14h]
	const char* v11x = ".OPL\0";
	HMDIDRIVER v12; // [esp+2Ch] [ebp-10h]
	int v13; // [esp+30h] [ebp-Ch]
	int i; // [esp+34h] [ebp-8h]
	x_BYTE *v15; // [esp+38h] [ebp-4h]
	void *v16; // [esp+50h] [ebp+14h]
	const void *v17; // [esp+50h] [ebp+14h]

	//fix it
	v15 = 0;
	v16 = 0;
	v10 = 0;
	//fix it

	sub_A4CF0();
	v12 = (HMDIDRIVER)sub_9D450_malloc4(sizeof(_MDI_DRIVER));
	if (v12)
	{
		v12->drvr_0 = a1;
		if (v12->drvr_0->type_5 == 1)
		{
			sub_91F70_AIL_call_driver(v12->drvr_0, 769, 0, &v6);
			//v12->var1_aildrv = sound_buffer[v6.AX];//v6.AX + 16 * v6.DX;
			v12->DST_2 = (MDI_DST*)sound_buffer[0/*v6.BX*/];//v6.BX + 16 * v6.CX;
			//v11 = sound_buffer[*v12->var1_aildrv];//(x_BYTE *)((*(x_DWORD *)v12[1] & 0xFFFF) + 16 * (*(x_DWORD *)v12[1] >> 16));

			v11 = 0;
			if (v11)
			{
				if (*v11)
				{
					//_dupenv_s((char**)v15,(size_t*)sizeof(v11),(char*)v11);
					v15 = mygetenv((const char*)v11);
					if (v15)
					{
						if (*v15)
							strncpy_s((char*)v12->DST_2, strlen((const char*)v12->DST_2) + 1, v15, 128);
					}
				}
			}
			//v11 = (Bit8u*)v12->var0_aildrv->AIL_DRIVER_var4_VHDR->mdiapplendix;//(x_BYTE *)((*(x_DWORD *)(v12[1] + 4) & 0xFFFF) + 16 * (*(x_DWORD *)(v12[1] + 4) >> 16));

			if (v11x && *v11x)
			{
				strcpy_s((char*)v12->DST_2->GTL_filename, strlen((const char*)aSample) + 1, aSample);
				strcpy_s((char*)v12->DST_2->GTL_filename + strlen((const char*)aSample), strlen((const char*)v11x) + 1, (const char*)v11x);
			}
			else
			{
				*(x_BYTE *)(v12->DST_2 + 128) = 0;
			}
			memset(&unk_181D90, -1, 24);
			v13 = 0;
			if (a2)
			{
				qmemcpy(&unk_181D90, (void*)a2, 0x18u);
				if (sub_A6E00_sound_proc25(v12, a2))
				{
					v13 = 1;
					qmemcpy(&v5, (void*)a2, 0x18u);
				}
			}
			if (!v13)
			{
				v16 = sub_92ED0_AIL_get_IO_environment(v12->drvr_0);
				if (v16)
				{
					qmemcpy(&unk_181D90, v16, 0x18u);
					if (sub_A6E00_sound_proc25(v12, (IO_PARMS*)v16))
					{
						v13 = 1;
						qmemcpy(&v5, v16, 0x18u);
					}
				}
			}
			if (!v13 && x_DWORD_181DAC[17] == 1)
			{
				for (i = 0; *(unsigned __int16 *)v12->drvr_0->VHDR_4->environment_string_16 > i; i++)
				{
					v17 = (const void *)(24 * i
						+ (v12->drvr_0->VHDR_4->VDI_HDR_var12 & 0xFFFF)
						+ 16 * v12->drvr_0->VHDR_4->VDI_HDR_var12);
					if (!i)
						qmemcpy(&unk_181D90, (void*)v17, 0x18u);
					if (sub_A6E00_sound_proc25(v12, (IO_PARMS*)v17))
					{
						v13 = 1;
						qmemcpy(&v5, (void*)v17, 0x18u);
						break;
					}
				}
			}
			if (v13)
			{
				qmemcpy(&unk_181D90, &v5, 0x18u);
				sub_91F70_AIL_call_driver(v12->drvr_0, 773, 0, 0);
				v12->drvr_0->initialized_6 = 1;
				sub_91F70_AIL_call_driver(v12->drvr_0, 1281, 0, &v6);
				if (v6.AX)
				{
					v12->n_sequences_7 = x_DWORD_181DAC[12];
					v12->sequences_6 = (HSEQUENCE)sub_9D450_malloc4(sizeof(SEQUENCE) * v12->n_sequences_7);
					if (v12->sequences_6)
					{
						for (i = 0; i < v12->n_sequences_7; i++)
						{
							v12->sequences_6[i].status_1 = 1;
							v12->sequences_6[i].driver_0 = v12;
						}
						v12->var104_aildrv = 0;
						v12->var105_aildrv = 0;
						v12->var106_aildrv = 0;
						v12->var107_aildrv = 0;
						LODWORD(v2) = (x_DWORD)&unk_F4240;
						HIDWORD(v2) = (signed int)&unk_F4240 >> 31;
						v12->interval_time_4 = v2 / x_DWORD_181DAC[11];
						v12->disable_5 = 0;
						v12->var108_aildrv = 127;
						/*for ( i = 0; i < 16; i++ )
						{
						  v12[i + 8] = 0;
						  v12[i + 24] = 0;
						  v12[i + 40] = 0;
						  v12[i + 56] = 0;
						  v12[i + 72] = 0;
						  v12[i + 88] = 0;
						}*/
						v3 = sub_92600_AIL_register_timer(sub_A6530);
						v12->timer_3 = v3;
						if (v12->timer_3 == -1)
						{
							qmemcpy(&x_BYTE_181C90, (void*)"Out of timer handles\n", 0x16u);
							sub_91F70_AIL_call_driver(v12->drvr_0, 774, 0, 0);
							v12->drvr_0->initialized_6 = 0;
							sub_9D490_free4((void*)v12->sequences_6, 1816 * v12->n_sequences_7);
							sub_9D490_free4(v12, 468);
							v10 = 0;
						}
						else
						{
							sub_92740_AIL_set_timer_user(v12->timer_3, (signed __int32)v12);
							v12->drvr_0->destructor_9 = sub_A6F30;
							v12->drvr_0->descriptor_10 = v12;
							for (i = 0; i < 16; i++)
							{
								sub_A4F10(v12, i | 0xB0, 114, 0);
								sub_A4F10(v12, i | 0xC0, 0, 0);
								sub_A4F10(v12, i | 0xE0, 0, 64);
								sub_A4F10(v12, i | 0xB0, 112, 0);
								sub_A4F10(v12, i | 0xB0, 1, 0);
								sub_A4F10(v12, i | 0xB0, 7, x_DWORD_181DAC[13]);
								sub_A4F10(v12, i | 0xB0, 10, 64);
								sub_A4F10(v12, i | 0xB0, 11, 127);
								sub_A4F10(v12, i | 0xB0, 64, 0);
								sub_A4F10(v12, i | 0xB0, 91, 40);
								sub_A4F10(v12, i | 0xB0, 93, 0);
								sub_A4F10(v12, i | 0xB0, 100, 0);
								sub_A4F10(v12, i | 0xB0, 101, 0);
								sub_A4F10(v12, i | 0xB0, 38, 0);
								sub_A4F10(v12, i | 0xB0, 6, x_DWORD_181DAC[16]);
								sub_A4EB0(v12);
								if (!(i & 3))
									sub_920D0_AIL_delay(3);
							}
							sub_92930_AIL_set_timer_frequency(v12->timer_3, x_DWORD_181DAC[11]);
							sub_92BA0_AIL_start_timer(v12->timer_3);
							v10 = v12;
						}
					}
					else
					{
						qmemcpy(&x_BYTE_181C90, (void*)"Could not allocate SEQUENCE structures\n", 0x28u);
						sub_91F70_AIL_call_driver(v12->drvr_0, 774, 0, 0);
						v12->drvr_0->initialized_6 = 0;
						sub_9D490_free4(v12, 468);
						v10 = 0;
					}
				}
				else
				{
					qmemcpy(&x_BYTE_181C90, (void*)"Could not initialize instrument manager\n", 0x29u);
					sub_91F70_AIL_call_driver(v12->drvr_0, 774, 0, 0);
					v12->drvr_0->initialized_6 = 0;
					sub_9D490_free4(v12, 468);
					v10 = 0;
				}
			}
			else
			{
				qmemcpy(&x_BYTE_181C90, (void*)"XMIDI sound hardware not found\n", 0x20u);
				sub_9D490_free4(v12, 468);
				v10 = 0;
			}
		}
		else
		{
			qmemcpy(&x_BYTE_181C90, (void*)".MDI driver required\n", 0x16u);
			sub_9D490_free4(v12, 468);
			v10 = 0;
		}
	}
	else
	{
		qmemcpy(&x_BYTE_181C90, (void*)"Could not allocate memory for driver\n", 0x26u);
		v10 = 0;
	}

	return v10;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);
// 99D46: using guessed type x_DWORD strcpy(x_DWORD, x_DWORD);
// 99D84: using guessed type x_DWORD strcat(x_DWORD, x_DWORD);
// 99E33: using guessed type x_DWORD getenv(x_DWORD);
// A6530: using guessed type int sub_A6530();
// A6F30: using guessed type int sub_A6F30();
// AD871: using guessed type x_DWORD strncpy(x_DWORD, x_DWORD, x_DWORD);
// 181C90: using guessed type char x_BYTE_181C90;
// 181DD8: using guessed type int x_DWORD_181DD8;
// 181DDC: using guessed type int x_DWORD_181DDC;
// 181DE0: using guessed type int x_DWORD_181DE0;
// 181DEC: using guessed type int x_DWORD_181DEC;
// 181DF0: using guessed type int x_DWORD_181DF0;

//----- (000A77D0) --------------------------------------------------------
HMDIDRIVER sub_A77D0_AIL_API_install_MDI_INI(char* filename, IO_PARMS *IO)//2887d0
{
	int v3; // eax
	HMDIDRIVER v5; // [esp+0h] [ebp-10h]
	Bit8u* v6; // [esp+4h] [ebp-Ch]
	HMDIDRIVER v7; // [esp+8h] [ebp-8h]
	AIL_DRIVER *v8; // [esp+Ch] [ebp-4h]

	v6 = sub_9DEA0_read_file(filename, 0);
	if (v6)
	{
		v3 = sub_9DE20_get_file_lenght(filename);
		v8 = sub_93010_AIL_install_driver(/*(int)a1,*/ v6, v3);
		x_free((void*)v6);
		if (v8)
		{
			v7 = sub_A6FB0_sound_proc26(v8, IO);
			if (!v7)
				sub_93160_AIL_uninstall_driver((AIL_DRIVER*)v8);
			v5 = v7;
		}
		else
		{
			v5 = 0;
		}
	}
	else
	{
		strcpy_s(x_BYTE_181C90, strlen("Driver file not found\n") + 1, "Driver file not found\n");
		v5 = 0;
	}
	return v5;
}
// E3E34: using guessed type int (*off_E3E34_freex)(int);
// 181C90: using guessed type char x_BYTE_181C90;

//----- (000A7880) --------------------------------------------------------
HMDIDRIVER sub_A7880_sound_proc27(int a1, Bit8u* a2, int a3, IO_PARMS* a4)
{
	HMDIDRIVER v6; // [esp+4h] [ebp-8h]
	AIL_DRIVER *v7; // [esp+8h] [ebp-4h]

	v7 = sub_93010_AIL_install_driver(/*a1, */a2, a3);
	if (!v7)
		return 0;
	v6 = sub_A6FB0_sound_proc26(v7, a4);
	if (!v6)
		sub_93160_AIL_uninstall_driver((AIL_DRIVER*)v7);
	return v6;
}

//----- (000A78F0) --------------------------------------------------------
Bit32s sub_A78F0_AIL_API_install_MDI_INI(/*int a1, */HMDIDRIVER *mdi) //2888f0
{
	AIL_INI v3; // [esp+0h] [ebp-11Ch]
	//char v4; // [esp+80h] [ebp-9Ch]
	//char v5; // [esp+100h] [ebp-1Ch]
	int result; // [esp+118h] [ebp-4h]

	/*char v8x[200];
	IO_PARMS v9x = {};*/

	if (sub_92190_AIL_read_INI(&v3, (char*)"MDI.INI"/*,v8x,v9x*/))
	{
		*mdi = sub_95850_AIL_install_MDI_driver_file(v3.driver_name, &v3.IO);
		if (*mdi)
			result = 0;
		else
			result = 2;
	}
	else
	{
		qmemcpy(&x_BYTE_181C90, (void*)"Unable to open file MDI.INI\n", 0x1Du);
		result = 1;
	}
	return result;
}
// 181C90: using guessed type char x_BYTE_181C90;

//----- (000A7970) --------------------------------------------------------
int sub_A7970_AIL_API_uninstall_MDI_driver(HMDIDRIVER mdi)
{
	return sub_93160_AIL_uninstall_driver(mdi->drvr_0);
	return 0;
}

//----- (000A7990) --------------------------------------------------------
Bit32s sub_A7990_AIL_API_MDI_driver_type(HMDIDRIVER mdi)
{
	int v3; // [esp+4h] [ebp-4h]
	char *v4; // [esp+4h] [ebp-4h]

	const char* v4help = ".OPL";//fix;

	if (mdi->drvr_0->VHDR_4->driver_version_8 >= 0x112u)
	{
		v3 = mdi->drvr_0->VHDR_4->VDI_HDR_var46;
		if (!_stricmp((const char*)v3, "Tandy 3-voice music"))
			return 3;
		if (!_stricmp((const char*)v3, "IBM internal speaker music"))
			return 3;
	}
	/*v4 = (x_BYTE *)((*(x_DWORD *)(mdi[1] + 4) & 0xFFFF) + 16 * (*(x_DWORD *)(mdi[1] + 4) >> 16));
	if ( !v4 || !*v4 )
	  return 0;*/ // fix
	v4 = (char*)v4help;
	if (!_stricmp(v4, ".AD"))
		return mdi->drvr_0->size_3 <= 0x5000u;
	if (!_stricmp(v4, ".OPL"))
		return 2;
	return 0;
}
// 98F5D: using guessed type x_DWORD stricmp(x_DWORD, x_DWORD);

//----- (000A7AA0) --------------------------------------------------------
void sub_A7AA0_AIL_API_set_GTL_filename_prefix(Bit8u* a1)
{
	int samplesize; // eax
	int i; // [esp+0h] [ebp-4h]

	strcpy_s(aSample, 512, (const char*)a1);
	samplesize = strlen(aSample) - 1;
	for (i = samplesize; i; i--)
	{
		if (aSample[i] == 92)
		{
			samplesize = strlen(aSample) - 1;
			if (samplesize == i)
			{
				samplesize = i;
				aSample[i] = 0;
			}
			return;
		}
		if (aSample[i] == 46)
		{
			samplesize = i;
			aSample[i] = 0;
			return;
		}
		samplesize = i;
	}
	return;
}
// 99D46: using guessed type x_DWORD strcpy(x_DWORD, x_DWORD);
// 99D6B: using guessed type x_DWORD strlen(x_DWORD);
/*
sub_91BD0_s_plus();
	for (i = 0; i < dig->var24_aildrv && dig->var23_aildrvx[i].status_1 != 1; i++)
		;
	if (i == dig->var24_aildrv)
	{
		qmemcpy(&x_BYTE_181C90, (void*)"Out of sample handles\n", 0x17u);
		sub_91BF0_s_minus();
		v3 = 0;
	}
	else
	{
		v1 = &dig->var23_aildrvx[i];
		sub_93830_AIL_init_sample(v1);
		sub_91BF0_s_minus();
		v3 = v1;
	}
	return v3;
*/
//----- (000A7B30) --------------------------------------------------------
HSEQUENCE sub_A7B30_AIL_API_allocate_sequence_handle(HMDIDRIVER mdi)
{
	HSEQUENCE v1; // ST08_4
	HSEQUENCE v3; // [esp+0h] [ebp-Ch]
	int i; // [esp+8h] [ebp-4h]

	//fix it
	v3 = 0;
	//fix it

	sub_91BD0_s_plus();
	for (i = 0; i < mdi->n_sequences_7 && mdi->sequences_6[i].status_1 != 1; i++)
		;
	if (i == mdi->n_sequences_7)
	{
		qmemcpy(&x_BYTE_181C90, (void*)"Out of sequence handles\n", 0x19u);
		sub_91BF0_s_minus();
		v3 = 0;
	}
	else
	{
		v1 = &mdi->sequences_6[i];
		v1->status_1 = 2;
		sub_A6370(v1);
		v1->EOS_10 = 0;
		sub_91BF0_s_minus();
		v3 = v1;
	}
	return v3;
}
// 181C90: using guessed type char x_BYTE_181C90;

//----- (000A7BF0) --------------------------------------------------------
void sub_A7BF0_sound_proc33(HSEQUENCE S)
{
	//int *result; // eax

	//fix it
	//result = 0;
	//fix itsub_95C00_AIL_init_sequence

	if (S)
	{
		sub_95DE0_AIL_stop_sequence(S);
		//result = S;
		S->status_1 = 1;
	}
	//return result;
}

Bit32s sub_A7C20_AIL_API_init_sequence(HSEQUENCE S, void* start, Bit32s sequence_num, Bit32u track) {
	//S->ICA_6 = 0;
	//S->prefix_callback_7 = 0;
	//S->trigger_callback_8_32 = 0;
	//S->beat_callback_9 = 0;
	//S->EOS_10 = 0;
	S->loop_count_11 = 1;
	S->volume_14 = x_DWORD_181DAC[13];
	S->volume_target_15 = x_DWORD_181DAC[13];
	S->volume_period_17 = 0;
	S->volume_accum_16 = 0;
	/*S->tempo_percent_18 = 100;
	S->tempo_target_19 = 100;
	S->tempo_period_21 = 0;
	S->tempo_accum_20 = 0;
	S->tempo_error_22 = 0;*/
	S->sequence_num = sequence_num;
	SOUND_init_MIDI_sequence(x_DWORD_E3810_music_data, x_DWORD_E3808_music_header, track - 1);
	return 1;
}

//----- (000A7C20) --------------------------------------------------------
Bit32s sub_A7C20_AIL_API_init_sequence_orig(HSEQUENCE S, void* start, Bit32s sequence_num)
{
	VDI_CALL v4; // [esp+0h] [ebp-30h]
	Bit32u v5; // [esp+2h] [ebp-2Eh]
	int v6; // [esp+Ch] [ebp-24h]
	int v7; // [esp+10h] [ebp-20h]
	unsigned int v8; // [esp+14h] [ebp-1Ch]
	x_WORD *v9; // [esp+18h] [ebp-18h]
	unsigned int v10; // [esp+1Ch] [ebp-14h]
	unsigned int i; // [esp+20h] [ebp-10h]
	unsigned int v12; // [esp+24h] [ebp-Ch]
	Bit8u* v13; // [esp+28h] [ebp-8h]
	Bit8u* v14; // [esp+2Ch] [ebp-4h]
	//int v14i;//delete

	//fix it
	v5 = 0;
	v14 = 0;
	//fix it

	if (!S)
		return 0;
	S->status_1 = 2;
	v14 = sub_A50F0((Bit8u*)start, sequence_num);
	if (v14)
	{
		v10 = sub_A50A0(*(x_DWORD *)(v14 + 4)) + 8;
		v13 = v10 + v14;
		v14 += 12;
		S->TIMB_2 = 0;
		S->RBRN_3 = 0;
		S->EVNT_4 = 0;
		while (v14 < v13)
		{
			if (!strncmp((const char*)v14, "TIMB", 4))
				S->TIMB_2 = v14;
			if (!strncmp((const char*)v14, "RBRN", 4))
				S->RBRN_3 = (Bit8u*)v14;
			if (!strncmp((const char*)v14, "EVNT", 4))
				S->EVNT_4 = v14;
			v14 += sub_A50A0(*(x_DWORD *)(v14 + 4)) + 8;
		}
		if (S->EVNT_4)
		{
			S->ICA_6 = 0;
			S->prefix_callback_7 = 0;
			S->trigger_callback_8_32 = 0;
			S->beat_callback_9 = 0;
			S->EOS_10 = 0;
			S->loop_count_11 = 1;
			sub_A6490(S);
			S->volume_14 = x_DWORD_181DAC[13];
			S->volume_target_15 = x_DWORD_181DAC[13];
			S->volume_period_17 = 0;
			S->volume_accum_16 = 0;
			S->tempo_percent_18 = 100;
			S->tempo_target_19 = 100;
			S->tempo_period_21 = 0;
			S->tempo_accum_20 = 0;
			S->tempo_error_22 = 0;
			if (S->TIMB_2)
			{
				memmove(&unk_181EE0, (void*)S->TIMB_2, 512);
				v9 = (x_WORD*)&unk_181EE0;
				if (S->driver_0->var105_aildrv)
				{
					v12 = 0;
					while ((unsigned __int16)v9[4] > v12)
					{
						v7 = v9[v12 + 5] & 0xFF;
						v8 = (v9[v12 + 5] & 0xFF00u) >> 8;
						if ((*(int(**)(_MDI_DRIVER*, unsigned int, int))(S->driver_0->var105_aildrv))(S->driver_0, v8, v7))
						{
							for (i = v12 + 1; (unsigned __int16)v9[4] > i; i++)
								v9[i + 4] = v9[i + 5];
							--v9[4];
							if (*((x_BYTE *)v9 + 5) >= 2u)
							{
								*((x_BYTE *)v9 + 5) -= 2;
							}
							else
							{
								*((x_BYTE *)v9 + 5) -= 2;
								--*((x_BYTE *)v9 + 4);
							}
						}
						else
						{
							v12++;
						}
					}
				}
				if (v9[4])
				{
					if (sub_92160())
					{
						strcpy_s(x_BYTE_181C90, strlen("No timbres loaded\n") + 1, "No timbres loaded\n");
						v6 = -1;
					}
					else
					{
						S->driver_0->disable_5++;
						sub_A4EB0(S->driver_0);
						memmove((void*)(&S->driver_0->DST_2->MIDI_data), v9, 512);
						sub_91F70_AIL_call_driver(S->driver_0->drvr_0, 1283, 0, &v4);
						S->driver_0->disable_5--;
						if (v4.AX != -1)
						{
							v6 = 1;
						}
						else
						{
							sprintf_s(x_BYTE_181C90, 512, "Driver could not install timbre bank %u, patch %u\n", v5 >> 8, v5);
							v6 = -1;
						}
					}
				}
				else
				{
					v6 = 1;
				}
			}
			else
			{
				v6 = 1;
			}
		}
		else
		{
			qmemcpy(&x_BYTE_181C90, (void*)"Invalid XMIDI sequence\n", 0x18u);
			v6 = 0;
		}
	}
	else
	{
		qmemcpy(&x_BYTE_181C90, (void*)"Invalid XMIDI sequence\n", 0x18u);
		v6 = 0;
	}
	return v6;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// 99682: using guessed type x_DWORD strncmp(x_DWORD, x_DWORD, x_DWORD);
// AD81F: using guessed type x_DWORD memmove(x_DWORD, x_DWORD, x_DWORD);
// 181C90: using guessed type char x_BYTE_181C90;
// 181DE0: using guessed type int x_DWORD_181DE0;


void sub_A8010_AIL_API_start_sequence(HSEQUENCE S, Bit32u track)
{
	if (S)
	{
		if (S->status_1 != 1)
		{
			sub_95DE0_AIL_stop_sequence(S);
			SOUND_start_sequence(track - 1);
			S->status_1 = 4;
		}
	}

}

//----- (000A8010) --------------------------------------------------------
void sub_A8010_AIL_API_start_sequence_orig(HSEQUENCE S)
{
	//int *result; // eax

	//fix it
	//result = 0;
	//fix it

	if (S)
	{
		//result = S;
		if (S->status_1 != 1)
		{
			sub_95DE0_AIL_stop_sequence(S);
			sub_A6490(S);
			//result = a1;
			S->status_1 = 4;
		}
	}
	//return result;
}

void sub_A8050_AIL_API_stop_sequence(HSEQUENCE S)
{
	int v2; // [esp+0h] [ebp-Ch]
	signed int i; // [esp+4h] [ebp-8h]
	HMDIDRIVER v4; // [esp+8h] [ebp-4h]

	if (S)
	{
		if (S->status_1 == 4)
		{
			S->status_1 = 8;
			SOUND_pause_sequence(S->sequence_num);
		}
	}
}

//----- (000A8050) --------------------------------------------------------
void sub_A8050_AIL_API_stop_sequence_orig(HSEQUENCE S)
{
	//int result; // eax
	int v2; // [esp+0h] [ebp-Ch]
	signed int i; // [esp+4h] [ebp-8h]
	HMDIDRIVER v4; // [esp+8h] [ebp-4h]

	if (S)
	{
		//result = (int)S;
		if (S->status_1 == 4)
		{
			S->status_1 = 8;
			sub_A5E50(S);
			//result = *a1;
			v4 = (HMDIDRIVER)S->driver_0;
			for (i = 0; i < 16; i++)
			{
				v2 = S->chan_map_37[i];
				if (S->seq_277[i] >= 64)
					sub_A4F10((HMDIDRIVER)v4, v2 | 0xB0, 64, 0);
				if (S->seq_117[i] >= 64)
					v4->DST_2->MIDI_data[v2] = 0;//v4[v2 + 8]
				if (S->seq_149[i] >= 64)
					sub_A4F10((HMDIDRIVER)v4, v2 | 0xB0, 112, 0);
				if (S->seq_101[i] >= 64)
					sub_980D0_AIL_release_channel((int32*)v4, v2 + 1);
				//result = i;
			}
		}
	}
	//return result;
}

void sub_A8180_AIL_API_resume_sequence(HSEQUENCE S)
{
	if (S && S->status_1 == 8)
	{
		S->status_1 = 4;
		SOUND_resume_sequence(S->sequence_num);
	}
}

//----- (000A8180) --------------------------------------------------------
void sub_A8180_AIL_API_resume_sequence_orig(x_DWORD *a1)
{
	signed int v1; // [esp+0h] [ebp-10h]
	int v2; // [esp+4h] [ebp-Ch]
	signed int i; // [esp+8h] [ebp-8h]
	int j; // [esp+8h] [ebp-8h]
	x_DWORD *v5; // [esp+Ch] [ebp-4h]

	if (a1 && a1[1] == 8)
	{
		v5 = (x_DWORD *)*a1;
		for (i = 0; i < 16; i++)
		{
			if (a1[i + 101] >= 64)
			{
				v2 = sub_97F90_AIL_lock_channel(v5) - 1;
				if (v2 == -1)
					v1 = i;
				else
					v1 = v2;
				a1[i + 37] = v1;
			}
		}
		for (j = 0; j < 16; j++)
			sub_A5FD0((int)a1, j);
		a1[1] = 4;
	}
}

void sub_A8250_AIL_API_end_sequence(HSEQUENCE S)
{
	if (S)
	{
		if (S->status_1 != 1)
		{
			sub_95DE0_AIL_stop_sequence(S);
			S->status_1 = 2;
			SOUND_stop_sequence(S->sequence_num);
		}
	}
}

//----- (000A8250) --------------------------------------------------------
void sub_A8250_AIL_API_end_sequence_orig(HSEQUENCE S)
{
	//int result; // eax

	if (S)
	{
		//result = a1;
		if ((int)S->status_1 != 1)
		{
			sub_95DE0_AIL_stop_sequence(S);
			S->status_1 = 2;
			//result = a1;
			if (S->EOS_10)
				/*result =*/ (*(int(**)(HSEQUENCE))(S->EOS_10))(S);
		}
	}
	//return result;
}

//----- (000A82A0) --------------------------------------------------------
int sub_A82A0(int a1, int a2)
{
	int result; // eax

	if (a1)
	{
		result = a2;
		*(x_DWORD *)(a1 + 44) = a2;
	}
	return result;
}

//----- (000A82C0) --------------------------------------------------------
void sub_A82C0(x_DWORD *a1, int a2, int a3)
{
	if (a1)
	{
		++*(x_DWORD *)(*a1 + 20);
		a1[19] = a2;
		if (a1[18] == a1[19])
		{
			--*(x_DWORD *)(*a1 + 20);
		}
		else
		{
			if (a3)
			{
				a1[21] = 1000 * a3 / abs(a1[18] - a1[19]);
				a1[20] = 0;
			}
			else
			{
				a1[18] = a1[19];
			}
			--*(x_DWORD *)(*a1 + 20);
		}
	}
}
// A0D1F: using guessed type x_DWORD abs(x_DWORD);

//----- (000A8360) --------------------------------------------------------
void sub_A8360_AIL_API_set_sequence_volume(HSEQUENCE S, Bit32s volume, Bit32s milliseconds)
{
	if (S)
	{
		S->driver_0->disable_5++;
		S->volume_target_15 = volume;
		if (S->volume_14 == S->volume_target_15)
		{
			S->driver_0->disable_5--;
		}
		else
		{
			if (milliseconds)
			{
				S->volume_period_17 = 1000 * milliseconds / abs(S->volume_14 - S->volume_target_15);
				S->volume_accum_16 = 0;
			}
			else
			{
				S->volume_14 = S->volume_target_15;
			}
			sub_A64C0(S);
			S->driver_0->disable_5--;
		}
	}
}
// A0D1F: using guessed type x_DWORD abs(x_DWORD);

//----- (000A8410) --------------------------------------------------------
int sub_A8410_AIL_API_sequence_status(HSEQUENCE S)
{
	int v2; // [esp+0h] [ebp-4h]

	if (S)
		v2 = S->status_1;
	else
		v2 = 0;
	return v2;
}

//----- (000A8440) --------------------------------------------------------
signed int sub_A8440(int a1)
{
	signed int v2; // [esp+0h] [ebp-4h]

	if (a1)
		v2 = *(x_DWORD *)(a1 + 44);
	else
		v2 = -1;
	return v2;
}

//----- (000A8470) --------------------------------------------------------
int sub_A8470(int a1)
{
	int v2; // [esp+0h] [ebp-4h]

	if (a1)
		v2 = *(x_DWORD *)(a1 + 72);
	else
		v2 = 0;
	return v2;
}

//----- (000A84A0) --------------------------------------------------------
int sub_A84A0(int a1)
{
	int v2; // [esp+0h] [ebp-4h]

	if (a1)
		v2 = *(x_DWORD *)(a1 + 56);
	else
		v2 = 0;
	return v2;
}

//----- (000A84D0) --------------------------------------------------------
void sub_A84D0_AIL_API_set_XMIDI_master_volume(HMDIDRIVER mdi, Bit32s master_volume)
{
	Bit32s result; // eax
	int v3; // [esp+0h] [ebp-8h]
	HSEQUENCE v4; // [esp+4h] [ebp-4h]

	result = mdi->master_volume;
	if (result != master_volume)
	{
		mdi->master_volume = master_volume;
		mdi->disable_5++;
		v3 = mdi->n_sequences_7;
		v4 = mdi->sequences_6;
		while (v3)
		{
			if (*(x_DWORD *)(v4 + 4) == 4)
				sub_A64C0(v4);
			v3--;
			v4 += 1816;
		}
		mdi->disable_5--;
	}
}

//----- (000A8550) --------------------------------------------------------
int sub_A8550(int a1)
{
	return *(x_DWORD *)(a1 + 432);
}

//----- (000A8570) --------------------------------------------------------
int sub_A8570_sound_proc39(int *a1, __int16 a2, __int16 a3)
{
	VDI_CALL v4; // [esp+0h] [ebp-10h]
	__int16 v5; // [esp+4h] [ebp-Ch]

	v5 = (a2 << 8) | a3;
	return sub_91F70_AIL_call_driver((AIL_DRIVER*)*a1, 1284, &v4, 0);
}

//----- (000A85B0) --------------------------------------------------------
VDI_CALL sub_A85B0_sound_proc40(int *a1, int a2, int a3)
{
	VDI_CALL result; // [esp+0h] [ebp-10h]
	Bit32u v5; // [esp+2h] [ebp-Eh]

	//fix it
	v5 = 0;
	//fix it

	if (a1[105] && ((int(*)(int *, int, int))a1[105])(a1, a2, a3))
	{
		result.AX = 1;
		return result;
	}
	x_BYTE_E4B2A = a3;
	x_BYTE_E4B2B = a2;
	++a1[5];
	sub_A4EB0((HMDIDRIVER)a1);
	memmove((void*)(a1[2] + 256), aTimb_0, 12);
	sub_91F70_AIL_call_driver((AIL_DRIVER*)*a1, 1283, 0, &result);
	--a1[5];
	if (!result.AX)
		sprintf_s(x_BYTE_181C90, 512, "Driver could not install timbre bank %u, patch %u\n", v5 >> 8, v5);
	return result;
}
// 8E3D5: using guessed type x_DWORD sprintf_s(x_DWORD, const char *, ...);
// AD81F: using guessed type x_DWORD memmove(x_DWORD, x_DWORD, x_DWORD);
// E4B2A: using guessed type char x_BYTE_E4B2A;
// E4B2B: using guessed type char x_BYTE_E4B2B;
// 181C90: using guessed type char x_BYTE_181C90;

//----- (000A8690) --------------------------------------------------------
int sub_A8690_sound_proc41(int *a1, __int16 a2, __int16 a3)
{
	VDI_CALL v4; // [esp+0h] [ebp-Ch]
	__int16 v5; // [esp+4h] [ebp-8h]
	__int16 v6; // [esp+6h] [ebp-6h]

	v5 = (a2 << 8) | a3;
	v6 = 1;
	return sub_91F70_AIL_call_driver((AIL_DRIVER*)*a1, 1285, &v4, 0);
}

//----- (000A86D0) --------------------------------------------------------
int sub_A86D0_sound_proc42(int *a1, __int16 a2, __int16 a3)
{
	VDI_CALL v4; // [esp+0h] [ebp-Ch]
	__int16 v5; // [esp+4h] [ebp-8h]
	__int16 v6; // [esp+6h] [ebp-6h]

	v5 = (a2 << 8) | a3;
	v6 = 0;
	return sub_91F70_AIL_call_driver((AIL_DRIVER*)*a1, 1285, &v4, 0);
}

//----- (000A8710) --------------------------------------------------------
int sub_A8710(int a1)
{
	int v2; // [esp+4h] [ebp-8h]
	int i; // [esp+8h] [ebp-4h]

	v2 = 0;
	for (i = 0; i < *(x_DWORD *)(a1 + 28); i++)
	{
		if (*(x_DWORD *)(1816 * i + *(x_DWORD *)(a1 + 24) + 4) == 4)
			++v2;
	}
	return v2;
}

//----- (000A8770) --------------------------------------------------------
int sub_A8770(int a1, char a2, unsigned int a3)
{
	int v4; // [esp+0h] [ebp-4h]

	if (a1)
		v4 = sub_A5210(a1 + 212, (a2 - 1) | 0xB0, a3);
	else
		v4 = -1;
	return v4;
}

//----- (000A87C0) --------------------------------------------------------
int sub_A87C0(int a1, int a2)
{
	int v4; // [esp+4h] [ebp-8h]
	signed int i; // [esp+8h] [ebp-4h]

	if (!a1)
		return 0;
	v4 = 0;
	for (i = 0; i < 16; i++)
	{
		if (a2 - 1 == *(x_DWORD *)(4 * i + a1 + 1368))
			++v4;
	}
	return v4;
}

//----- (000A8830) --------------------------------------------------------
int sub_A8830(x_DWORD *a1, x_DWORD *a2, x_DWORD *a3)
{
	int result; // eax
	int v4; // [esp+0h] [ebp-10h]
	int i; // [esp+4h] [ebp-Ch]
	int v6; // [esp+8h] [ebp-8h]
	int v7; // [esp+Ch] [ebp-4h]

	if (a1)
	{
		++*(x_DWORD *)(*a1 + 20);
		v7 = a1[23];
		v6 = a1[24];
		v4 = a1[27];
		for (i = 0; i < x_DWORD_181DAC[14]; i++)
		{
			v4 += a1[26];
			if (v4 >= a1[28])
			{
				v4 -= a1[28];
				if (++v7 >= a1[25])
				{
					v7 = 0;
					++v6;
				}
			}
		}
		if (v6 < 0)
			v6 = 0;
		if (a3)
			*a3 = v6;
		if (a2)
			*a2 = v7;
		result = *a1;
		--*(x_DWORD *)(result + 20);
	}
	return result;
}
// 181DE4: using guessed type int x_DWORD_181DE4;

//----- (000A8900) --------------------------------------------------------
x_DWORD *sub_A8900(HSEQUENCE S, int a2)
{
	x_DWORD *result; // eax
	int v3; // [esp+0h] [ebp-Ch]
	signed int i; // [esp+4h] [ebp-8h]
	signed int v5; // [esp+8h] [ebp-4h]
	signed int j; // [esp+8h] [ebp-4h]

	//fix it
	result = 0;
	//fix it

	if (S)
	{
		result = (x_DWORD*)S;
		if (S->RBRN_3)
		{
			v5 = *(signed __int16 *)(&S->RBRN_3[8]);
			v3 = S->RBRN_3[10];
			for (i = 0; i < v5 && *(unsigned __int16 *)(v3 + 6 * i) != a2; i++)
				;
			result = (x_DWORD *)i;
			if (i != v5)
			{
				//S->EVNT_ptr_5 = (int)*(x_DWORD *)(6 * i + v3 + 2) + /*(Bit8u*)&*/S->EVNT_4+8; // fix it
			  //result = S;
				S->interval_count_12 = 0;
				if (!x_DWORD_181DAC[15])
				{
					for (j = 0; j < 4; j++)
					{
						S->FOR_loop_count_33[j] = -1;
						//result = (x_DWORD *)j;
					}
				}
			}
		}
	}
	return result;
}
// 181DE8: using guessed type int x_DWORD_181DE8;

//----- (000A89E0) --------------------------------------------------------
int sub_A89E0(int a1, int a2)
{
	int v2; // ST04_4

	if (!a1)
		return 0;
	v2 = *(x_DWORD *)(a1 + 28);
	*(x_DWORD *)(a1 + 28) = a2;
	return v2;
}

//----- (000A8A20) --------------------------------------------------------
xCALLBACK sub_A8A20_AIL_API_trigger_callback(HSEQUENCE S, xCALLBACK a2)
{
	xCALLBACK v2; // ST04_4

	if (!S)
		return 0;
	v2 = S->trigger_callback_8_32;
	S->trigger_callback_8_32 = a2;
	return v2;
}

//----- (000A8A60) --------------------------------------------------------
int sub_A8A60(int a1, int a2)
{
	int v2; // ST04_4

	if (!a1)
		return 0;
	v2 = *(x_DWORD *)(a1 + 40);
	*(x_DWORD *)(a1 + 40) = a2;
	return v2;
}

//----- (000A8AA0) --------------------------------------------------------
int sub_A8AA0(int a1, int a2)
{
	int v2; // ST04_4

	if (!a1)
		return 0;
	v2 = *(x_DWORD *)(a1 + 36);
	*(x_DWORD *)(a1 + 36) = a2;
	return v2;
}

//----- (000A8AE0) --------------------------------------------------------
int sub_A8AE0(int a1, int a2)
{
	int v2; // ST04_4

	v2 = *(x_DWORD *)(a1 + 416);
	*(x_DWORD *)(a1 + 416) = a2;
	return v2;
}

//----- (000A8B20) --------------------------------------------------------
int sub_A8B20(int a1, int a2)
{
	int v2; // ST04_4

	v2 = *(x_DWORD *)(a1 + 420);
	*(x_DWORD *)(a1 + 420) = a2;
	return v2;
}

//----- (000A8B60) --------------------------------------------------------
int sub_A8B60(int a1, int a2, int a3)
{
	int result; // eax

	if (a1)
	{
		result = a3;
		*(x_DWORD *)(4 * a2 + a1 + 1752) = a3;
	}
	return result;
}

//----- (000A8B90) --------------------------------------------------------
int sub_A8B90(int a1, int a2)
{
	int v3; // [esp+0h] [ebp-4h]

	if (a1)
		v3 = *(x_DWORD *)(a1 + 4 * a2 + 1752);
	else
		v3 = 0;
	return v3;
}

//----- (000A8BD0) --------------------------------------------------------
int sub_A8BD0(int a1, int a2)
{
	int result; // eax

	if (a1)
	{
		result = a2;
		*(x_DWORD *)(a1 + 24) = a2;
	}
	return result;
}

//----- (000A8BF0) --------------------------------------------------------
int sub_A8BF0(x_DWORD *a1)
{
	int v2; // [esp+0h] [ebp-18h]
	int v3; // [esp+4h] [ebp-14h]
	signed int v4; // [esp+8h] [ebp-10h]
	signed int v5; // [esp+Ch] [ebp-Ch]
	signed int k; // [esp+10h] [ebp-8h]
	signed int i; // [esp+14h] [ebp-4h]
	signed int j; // [esp+14h] [ebp-4h]
	int v9; // [esp+14h] [ebp-4h]

	++a1[5];
	v5 = -1;
	v4 = 0x7FFFFFFF;
	for (i = 8; i >= 1; i--)
	{
		if (i != 9 && a1[i + 8] != 1 && a1[i + 8] != 2 && a1[i + 88] < v4)
		{
			v4 = a1[i + 88];
			v5 = i;
		}
	}
	if (v5 == -1)
	{
		for (j = 8; j >= 1; j--)
		{
			if (j != 9 && a1[j + 8] != 1 && a1[j + 88] < v4)
			{
				v4 = a1[j + 88];
				v5 = j;
			}
		}
	}
	if (v5 == -1)
	{
		--a1[5];
		v2 = 0;
	}
	else
	{
		sub_A4F10((HMDIDRIVER)a1, v5 | 0xB0, 64, 0);
		v9 = a1[7];
		v3 = a1[6];
		while (v9)
		{
			if (*(x_DWORD *)(v3 + 4) != 1)
			{
				for (k = 0; k < 32; k++)
				{
					if (*(x_DWORD *)(v3 + 4 * k + 1368) != -1 && *(x_DWORD *)(v3 + 4 * *(x_DWORD *)(v3 + 4 * k + 1368) + 148) == v5)
					{
						sub_A5850((HSEQUENCE)v3, *(unsigned int *)(v3 + 4 * k + 1368) | 0x80, *(x_DWORD *)(v3 + 4 * k + 1496), 0, 0);
						*(x_DWORD *)(v3 + 4 * k + 1368) = -1;
					}
				}
			}
			--v9;
			v3 += 1816;
		}
		a1[v5 + 72] = a1[v5 + 8];
		a1[v5 + 8] = 1;
		a1[v5 + 24] = 0;
		a1[v5 + 40] = a1[v5 + 56];
		--a1[5];
		v2 = v5 + 1;
	}
	return v2;
}

//----- (000A8EA0) --------------------------------------------------------
int sub_A8EA0(x_DWORD *a1, int a2)
{
	int result; // eax
	int v3; // [esp+0h] [ebp-10h]
	int v4; // [esp+4h] [ebp-Ch]
	signed int i; // [esp+8h] [ebp-8h]
	int v6; // [esp+Ch] [ebp-4h]

	v4 = a2 - 1;
	result = (int)&a1[a2 - 1];
	if (*(x_DWORD *)(result + 32) == 1)
	{
		++a1[5];
		a1[v4 + 8] = a1[v4 + 72];
		a1[v4 + 56] = a1[v4 + 40];
		sub_A4F10((HMDIDRIVER)a1, v4 | 0xB0, 64, 0);
		v6 = a1[7];
		v3 = a1[6];
		while (v6)
		{
			if (*(x_DWORD *)(v3 + 4) != 1)
			{
				for (i = 0; i < 32; i++)
				{
					if (*(x_DWORD *)(v3 + 4 * i + 1368) != -1 && *(x_DWORD *)(v3 + 4 * *(x_DWORD *)(v3 + 4 * i + 1368) + 148) == v4)
					{
						sub_A5850((HSEQUENCE)v3, *(unsigned int *)(v3 + 4 * i + 1368) | 0x80, *(x_DWORD *)(v3 + 4 * i + 1496), 0, 0);
						*(x_DWORD *)(v3 + 4 * i + 1368) = -1;
					}
				}
			}
			--v6;
			v3 += 1816;
		}
		if (a1[v4 + 40])
		{
			if (*(x_DWORD *)(a1[v4 + 40] + 4) != 1)
				sub_A5FD0(a1[v4 + 40], v4);
		}
		result = (int)a1;
		--*(x_DWORD *)(result + 20);
	}
	return result;
}

//----- (000A9080) --------------------------------------------------------
int sub_A9080(x_DWORD *a1, int a2, int a3)
{
	int result; // eax

	if (a1)
	{
		a1[a2 + 36] = a3 - 1;
		result = 4 * a3 + *a1;
		if (*(x_DWORD *)(result + 28) == 1)
		{
			result = *(x_DWORD *)(4 * a3 + *a1 + 92);
			if ((x_DWORD *)result != a1)
			{
				result = (int)a1;
				*(x_DWORD *)(*a1 + 4 * a3 + 92) = (x_DWORD)a1;
			}
		}
	}
	return result;
}

//----- (000A9100) --------------------------------------------------------
int sub_A9100(int a1, int a2)
{
	int v3; // [esp+0h] [ebp-4h]

	if (a1)
		v3 = *(x_DWORD *)(a1 + 4 * a2 + 144) + 1;
	else
		v3 = 0;
	return v3;
}

void sub_A9140_AIL_API_send_channel_voice_message(HMDIDRIVER mdi, HSEQUENCE S, Bit32s status, Bit32s data_1, Bit32s data_2)//28a140
{
	//test_midi_play((Bit8u*)mdi->DST_2->MIDI_data);
}

//----- (000A9140) --------------------------------------------------------
void sub_A9140_AIL_API_send_channel_voice_message_orig(HMDIDRIVER mdi, HSEQUENCE S, Bit32s status, Bit32s data_1, Bit32s data_2)//28a140
{
	x_DWORD *result; // eax

	mdi->disable_5++;
	if (S)
	{
		sub_A5850(S, status, data_1, data_2, 0);
	}
	else
	{
		if ((status & 0xF0) == 176 && data_1 == 7)
		{
			data_2 = mdi->master_volume * data_2 / 127;
			if (data_2 > 127)
				data_2 = 127;
			if (data_2 < 0)
				data_2 = 0;
		}
		if (!mdi->event_trap || !((int(*)(HMDIDRIVER, x_DWORD, int, unsigned int, int))mdi->event_trap)(mdi, 0, status, data_1, data_2))
			sub_A4F10(mdi, status, data_1, data_2);
	}
	sub_A4EB0(mdi);
	mdi->disable_5--;
}

//----- (000A9230) --------------------------------------------------------
int sub_A9230(int a1, int a2)
{
	int v2; // eax
	int result; // eax
	int v4; // [esp+4h] [ebp-4h]

	++*(x_DWORD *)(a1 + 20);
	v4 = a2 + 1;
	v2 = sub_A5040(&v4);
	sub_A4FD0(a1, a2, v4 - a2 + v2);
	result = a1;
	--*(x_DWORD *)(result + 20);
	return result;
}

//----- (000A9280) --------------------------------------------------------
bool sub_A9280()
{
	bool result; // eax

	if (x_DWORD_E4B1C)
	{
		sub_9D650((unsigned int)sub_A4CF0, (unsigned int)sub_A9280);
		sub_9D740((unsigned int)aSample, 128);
		sub_9D740((unsigned int)&x_DWORD_E4B18, 4);
		sub_9D740((unsigned int)&x_DWORD_181EB8, 4);
		sub_9D740((unsigned int)&x_DWORD_181EBC, 4);
		sub_9D740((unsigned int)&x_DWORD_181EC4, 4);
		sub_9D740((unsigned int)&x_DWORD_181ED4, 4);
		sub_9D740((unsigned int)&x_DWORD_181EC8, 4);
		sub_9D740((unsigned int)&x_DWORD_181ECC, 4);
		sub_9D740((unsigned int)&x_DWORD_181EB4, 4);
		sub_9D740((unsigned int)&x_DWORD_181ED0, 4);
		sub_9D740((unsigned int)&x_DWORD_181EDC, 4);
		sub_9D740((unsigned int)&x_DWORD_181ED8, 4);
		result = sub_9D740((unsigned int)&x_DWORD_181EB0, 4);
		x_DWORD_E4B1C = 0;
	}
	return result;
}
// E4B18: using guessed type int x_DWORD_E4B18;
// E4B1C: using guessed type int x_DWORD_E4B1C;
// 181EB0: using guessed type int x_DWORD_181EB0;
// 181EB4: using guessed type int x_DWORD_181EB4;
// 181EB8: using guessed type int x_DWORD_181EB8;
// 181EBC: using guessed type int x_DWORD_181EBC;
// 181EC4: using guessed type int x_DWORD_181EC4;
// 181EC8: using guessed type int x_DWORD_181EC8;
// 181ECC: using guessed type int x_DWORD_181ECC;
// 181ED0: using guessed type int x_DWORD_181ED0;
// 181ED4: using guessed type int x_DWORD_181ED4;
// 181ED8: using guessed type int x_DWORD_181ED8;
// 181EDC: using guessed type int x_DWORD_181EDC;

//----- (000A9590) --------------------------------------------------------
void sub_A9590()
{
	//bool result; // eax

	if (!x_DWORD_E4B2C)
	{
		sub_9D590_lock_linear_region((Bit8u*)sub_A9590, (unsigned int)sub_AA620);
		x_DWORD_E4B2C = 1;
	}
	//return result;
}
// E4B2C: using guessed type int x_DWORD_E4B2C;

//----- (000A95D0) --------------------------------------------------------
x_DWORD *sub_A95D0(int a1, char a2, unsigned int a3, unsigned __int8 a4)
{
	x_DWORD *result; // eax
	int v5; // [esp+0h] [ebp-8h]
	unsigned int v6; // [esp+4h] [ebp-4h]

	v6 = a2 & 0xF0;
	result = (x_DWORD *)(a2 & 0xF);
	v5 = a2 & 0xF;
	if (v6 < 0xC0)
	{
		if (v6 == 176)
		{
			if (a3 < 0x5B)
			{
				if (a3 < 7)
				{
					if (a3 >= 1)
					{
						if (a3 <= 1)
						{
							result = (x_DWORD *)(a1 + 4 * v5);
							result[160] = a4;
						}
						else if (a3 == 6)
						{
							result = (x_DWORD *)(a1 + 4 * v5);
							result[272] = a4;
						}
					}
				}
				else if (a3 <= 7)
				{
					result = (x_DWORD *)(a1 + 4 * v5);
					result[176] = a4;
				}
				else if (a3 < 0xB)
				{
					if (a3 == 10)
					{
						result = (x_DWORD *)(a1 + 4 * v5);
						result[192] = a4;
					}
				}
				else if (a3 <= 0xB)
				{
					result = (x_DWORD *)(a1 + 4 * v5);
					result[208] = a4;
				}
				else if (a3 == 64)
				{
					result = (x_DWORD *)(a1 + 4 * v5);
					result[224] = a4;
				}
			}
			else if (a3 <= 0x5B)
			{
				result = (x_DWORD *)(a1 + 4 * v5);
				result[240] = a4;
			}
			else if (a3 < 0x70)
			{
				if (a3 < 0x6E)
				{
					if (a3 == 93)
					{
						result = (x_DWORD *)(a1 + 4 * v5);
						result[256] = a4;
					}
				}
				else if (a3 <= 0x6E)
				{
					result = (x_DWORD *)(a1 + 4 * v5);
					result[48] = a4;
				}
				else
				{
					result = (x_DWORD *)(a1 + 4 * v5);
					result[64] = a4;
				}
			}
			else if (a3 <= 0x70)
			{
				result = (x_DWORD *)(a1 + 4 * v5);
				result[96] = a4;
			}
			else if (a3 < 0x73)
			{
				if (a3 == 114)
				{
					result = (x_DWORD *)(a1 + 4 * v5);
					result[112] = a4;
				}
			}
			else if (a3 <= 0x73)
			{
				result = (x_DWORD *)(a1 + 4 * v5);
				result[128] = a4;
			}
			else if (a3 == 119)
			{
				result = (x_DWORD *)(a1 + 4 * v5);
				result[144] = a4;
			}
		}
	}
	else if (v6 <= 0xC0)
	{
		result = (x_DWORD *)(a1 + 4 * v5);
		*result = (unsigned __int8)a3;
	}
	else if (v6 == 224)
	{
		*(x_DWORD *)(a1 + 4 * v5 + 64) = (unsigned __int8)a3;
		result = (x_DWORD *)(a1 + 4 * v5);
		result[32] = a4;
	}
	return result;
}

//----- (000A98D0) --------------------------------------------------------
x_DWORD *sub_A98D0(x_DWORD *a1, int a2, int a3)
{
	signed int v5; // [esp+4h] [ebp-8h]
	x_DWORD *v6; // [esp+8h] [ebp-4h]

	v6 = a1;
	v5 = 0;
	while (1)
	{
		if (v5 >= 512)
			return 0;
		if (*v6 == -1)
			return 0;
		if (*v6 == a2 && v6[1] == a3)
			break;
		++v5;
		v6 += 8;
	}
	return v6;
}

//----- (000A9950) --------------------------------------------------------
void sub_A9950(int a1, int a2)//28a950
{
	int v2; // ST0C_4

	v2 = *(x_DWORD *)(a1 + 4 * a2 + 1304);
	sub_93E30_AIL_set_sample_volume(
		(HSAMPLE)*(x_DWORD **)(a1 + 4 * a2 + 1236),
		*(x_DWORD *)(a1 + 4 * a2 + 1560) * (*(x_DWORD *)(a1 + 4 * v2 + 852) * *(x_DWORD *)(4 * v2 + a1 + 724) / 127) / 127);
	return sub_93ED0_AIL_set_sample_volume_pan((HSAMPLE)*(x_DWORD **)(a1 + 4 * a2 + 1236), *(x_DWORD *)(a1 + 4 * v2 + 788));
}

//----- (000A9A30) --------------------------------------------------------
void sub_A9A30(int a1, int a2)
{
	int v3; // [esp+0h] [ebp-2Ch]
	int v4; // [esp+0h] [ebp-2Ch]
	signed int v5; // [esp+4h] [ebp-28h]
	int v6; // [esp+10h] [ebp-1Ch]
	int v7; // [esp+14h] [ebp-18h]
	int v8; // [esp+18h] [ebp-14h]
	int v9; // [esp+18h] [ebp-14h]
	int v10; // [esp+1Ch] [ebp-10h]
	int v11; // [esp+20h] [ebp-Ch]
	int v12; // [esp+28h] [ebp-4h]

	v12 = *(x_DWORD *)(a1 + 4 * a2 + 1304);
	v8 = *(x_DWORD *)(a1 + 4 * a2 + 1496);
	v11 = *(x_DWORD *)(a1 + 4 * a2 + 1368);
	v3 = (*(x_DWORD *)(a1 + 4 * v12 + 148) << 7) | *(x_DWORD *)(a1 + 4 * v12 + 84);
	if (v3 <= 0x2000)
	{
		if (v3 >= 0x2000)
		{
			v4 = 0;
			v5 = 0;
		}
		else
		{
			v4 = 0x2000 - v3;
			v5 = -1;
		}
	}
	else
	{
		v4 = v3 - 0x1FFF;
		v5 = 1;
	}
	v10 = v5 * *(x_DWORD *)(a1 + 4 * v12 + 1108) + v11;
	if (v10 < 0)
		v10 = 0;
	if (v10 > 127)
		v10 = 127;
	v7 = x_DWORD_A9390[v11];
	v6 = ((v4 * (x_DWORD_A9390[v10] - v7)
		- (__CFSHL__(v4 * (x_DWORD_A9390[v10] - v7) >> 31, 13)
			+ (v4 * (x_DWORD_A9390[v10] - v7) >> 31 << 13))) >> 13)
		+ v7;
	if (v12 == 9)
		v9 = v6 * v8 / v7;
	else
		v9 = v6 * (v7 * v8 / x_DWORD_A9390[*(x_DWORD *)(a1 + 4 * a2 + 1432)]) / v7;
	sub_93D90_AIL_set_sample_playback_rate((HSAMPLE)*(x_DWORD *)(a1 + 4 * a2 + 1236), v9);
}
// A9390: using guessed type int x_DWORD_A9390[];

//----- (000AA310) --------------------------------------------------------
x_DWORD *sub_AA310(int a1, int a2, int a3, signed int a4)
{
	signed int v5; // [esp+0h] [ebp-10h]
	x_DWORD *v6; // [esp+4h] [ebp-Ch]
	signed int i; // [esp+8h] [ebp-8h]
	signed int j; // [esp+8h] [ebp-8h]
	int k; // [esp+8h] [ebp-8h]
	x_DWORD *v10; // [esp+Ch] [ebp-4h]

	sub_A9590();
	v10 = (x_DWORD *)sub_9D450_malloc4(1692);
	if (v10)
	{
		v10[1] = a1;
		*v10 = a2;
		v10[2] = a3;
		v10[3] = sub_97A60_AIL_register_event_callback(a2, (int)sub_A9C50);
		v10[4] = sub_97BB0_AIL_register_timbre_callback(a2, (int)sub_A9C00);
		*(x_DWORD *)(a2 + 436) = (x_DWORD)v10;
		for (i = 0; i < 16; i++)
		{
			v10[i + 5] = 0;
			v10[i + 21] = 0;
			v10[i + 37] = 64;
			v10[i + 117] = 0;
			v10[i + 181] = 127;
			v10[i + 197] = 64;
			v10[i + 213] = 127;
			v10[i + 277] = x_DWORD_181DAC[16];
		}
		for (v10[325] = 0; ; ++v10[325])
		{
			v5 = a4 <= 16 ? a4 : 16;
			if (v10[325] >= v5)
				break;
			v10[v10[325] + 309] = (x_DWORD)sub_93510_AIL_allocate_sample_handle((HDIGDRIVER)v10[1]);
			if (!v10[v10[325] + 309])
				break;
		}
		for (j = 0; j < 16; j++)
			v10[j + 293] = 0;
		for (k = 0; k < v10[325]; k++)
			v10[k + 326] = -1;
		v10[422] = 0;
		v6 = v10;
	}
	else
	{
		qmemcpy(&x_BYTE_181C90, (void*)"Insufficient memory for HWAVE descriptor\n", 0x2Au);
		v6 = 0;
	}
	return v6;
}
// A9C00: using guessed type int sub_A9C00();
// A9C50: using guessed type int sub_A9C50();
// 181C90: using guessed type char x_BYTE_181C90;
// 181DEC: using guessed type int x_DWORD_181DEC;

//----- (000AA590) --------------------------------------------------------
int sub_AA590(int *a1)
{
	int i; // [esp+0h] [ebp-4h]

	for (i = 0; i < a1[325]; i++)
		sub_937A0_AIL_release_sample_handle(a1[i + 309]);
	sub_97A60_AIL_register_event_callback(*a1, a1[3]);
	sub_97BB0_AIL_register_timbre_callback(*a1, a1[4]);
	return sub_9D490_free4(a1, 1692);
}

//----- (000AA620) --------------------------------------------------------
bool sub_AA620()
{
	bool result; // eax

	if (x_DWORD_E4B2C)
	{
		result = sub_9D650((unsigned int)sub_A9590, (unsigned int)sub_AA620);
		x_DWORD_E4B2C = 0;
	}
	return result;
}
// E4B2C: using guessed type int x_DWORD_E4B2C;

//----- (000AB610) --------------------------------------------------------
int /*__fastcall*/ sub_AB610(int a1, x_DWORD *a2)
{
	x_DWORD *v2; // ebx
	int v3; // ST00_4
	int result; // eax
	int v5; // ecx
	int v6; // edx
	int v7; // esi
	int v8; // edi
	int v9; // ebp
	int v10; // ebx

	v2 = a2;
	v3 = a2[7];
	result = *a2;
	v5 = a2[2];
	v6 = a2[3];
	v7 = v2[5];
	v8 = v2[6];
	v9 = v2[4];
	__ES__ = *((x_WORD *)v2 + 15);
	__FS__ = *((x_WORD *)v2 + 16);
	__GS__ = *((x_WORD *)v2 + 17);
	v10 = v2[1];
	return result;
}

//----- (000AB9E1) --------------------------------------------------------
signed int sub_AB9E1_get_file_unpack_size(char* a1)
{
	Bit8u v2[10]; // [esp+0h] [ebp-1Ch]
	unsigned __int8 v3; // [esp+4h] [ebp-18h]
	unsigned __int8 v4; // [esp+5h] [ebp-17h]
	unsigned __int8 v5; // [esp+6h] [ebp-16h]
	unsigned __int8 v6; // [esp+7h] [ebp-15h]
	//char v7; // [esp+8h] [ebp-14h]
	//char v8; // [esp+9h] [ebp-13h]
	char v9; // [esp+Ah] [ebp-12h]
	char v10; // [esp+Bh] [ebp-11h]
	//char v11; // [esp+Ch] [ebp-10h]
	int v13; // [esp+14h] [ebp-8h]
	int v14; // [esp+18h] [ebp-4h]

	//fix it
	v3 = 0;
	v4 = 0;
	v5 = 0;
	v6 = 0;
	v9 = 0;
	v10 = 0;
	//fix it

	v13 = -1;
	//v7 = 'R';
	//v8 = 'N';
	//v9 = 'C';
	//v10 = 1;
	//v11 = 0;
	v14 = (int)sub_98817_open(a1, 512);
	if (v14 <= 0)
		return -1;
	sub_988A7_read((FILE*)v14, v2, 8);
	if (!strncmp((const char*)v2, (const char*)"RNC\1", 4))
	{
		v13 = v2[4] << 8;//toto je vlozeno push, nutno zjistit, kde se to bere
		v13 += v2[5];
		v13 <<= 8;
		v13 += v2[6];
		v13 <<= 8;
		v13 += v2[7];
	}
	else
	{
		v13 = x_filelength((FILE*)v14);
	}
	sub_98882_close((FILE*)v14);
	return v13;
}
// 988DA: using guessed type x_DWORD filelength(x_DWORD);
// 99682: using guessed type x_DWORD strncmp(x_DWORD, x_DWORD, x_DWORD);

//----- (000AC24B) --------------------------------------------------------
int sub_AC24B()
{
	return 0;
}

//----- (000AC250) --------------------------------------------------------
signed int sub_AC250(int a1, int a2, int a3, int a4, int a5, x_DWORD *a6, x_DWORD *a7, signed int *a8)
{
	signed int result; // eax
	int v9; // ebx
	int v10; // esi
	int v11; // ebp
	int v12; // edi
	int v13; // ecx
	int v14; // eax
	int v15; // [esp+Ch] [ebp-24h]
	int v16; // [esp+10h] [ebp-20h]
	int v17; // [esp+14h] [ebp-1Ch]
	int v18; // [esp+18h] [ebp-18h]
	int v19; // [esp+1Ch] [ebp-14h]

	//fix it
	v16 = 0;
	v18 = 0;
	//fix it

	if (x_DWORD_E4CCC)
		goto LABEL_8;
	result = sub_B1138(x_DWORD_182188, 3);
	if (result)
	{
		result = sub_B1138(x_DWORD_1821A0, 3);
		if (result)
		{
			result = sub_B1138(x_DWORD_1821B8, 3);
			if (result)
			{
				result = sub_B1138(x_DWORD_1821D0, 6);
				if (result)
				{
					result = sub_B1138(x_DWORD_1821E8, 6);
					if (result)
					{
						x_DWORD_E4CCC = 1;
					LABEL_8:
						v19 = sub_B11E8(x_DWORD_182188, a1);
						v9 = sub_B11E8(x_DWORD_1821A0, a2);
						v10 = sub_B11E8(x_DWORD_1821B8, a3);
						v11 = sub_B11E8(
							x_DWORD_1821D0,
							((unsigned __int64)(51471i64 * a4) >> 32 != 0) + ((unsigned __int64)(51471i64 * a4) >> 14));
						v12 = sub_B11E8(
							x_DWORD_1821E8,
							((unsigned __int64)(51471i64 * a5) >> 32 != 0) + ((unsigned __int64)(51471i64 * a5) >> 14));
						sub_B14F8(&v17, v11);
						sub_B14F8(&v15, v12);
						v13 = ((unsigned __int64)(v9 * (signed __int64)v18) >> 32 != 0)
							+ ((unsigned __int64)(v9 * (signed __int64)v18) >> 14)
							- (((unsigned __int64)(v10 * (signed __int64)v17) >> 32 != 0)
								+ ((unsigned __int64)(v10 * (signed __int64)v17) >> 14));
						v14 = sub_B1304(
							((unsigned __int64)(v10 * (signed __int64)v18) >> 32 != 0)
							+ ((unsigned __int64)(v10 * (signed __int64)v18) >> 14)
							+ ((unsigned __int64)(v9 * (signed __int64)v17) >> 32 != 0)
							+ ((unsigned __int64)(v9 * (signed __int64)v17) >> 14),
							((unsigned __int64)(v19 * (signed __int64)v16) >> 32 != 0)
							+ ((unsigned __int64)(v19 * (signed __int64)v16) >> 14)
							- (((unsigned __int64)(v13 * (signed __int64)v15) >> 32 != 0)
								+ ((unsigned __int64)(v13 * (signed __int64)v15) >> 14)));
						*a6 = ((unsigned __int64)((signed int)&unk_E52EE * (signed __int64)v14) >> 32 != 0)
							+ ((unsigned __int64)((signed int)&unk_E52EE * (signed __int64)v14) >> 14);
						*a7 = ((unsigned __int64)((signed int)&unk_E52EE * (signed __int64)v11) >> 32 != 0)
							+ ((unsigned __int64)((signed int)&unk_E52EE * (signed __int64)v11) >> 14);
						result = ((unsigned __int64)((signed int)&unk_E52EE * (signed __int64)v12) >> 32 != 0)
							+ ((unsigned __int64)((signed int)&unk_E52EE * (signed __int64)v12) >> 14);
						*a8 = result;
						return result;
					}
				}
			}
		}
	}
	return result;
}
// E4CCC: using guessed type int x_DWORD_E4CCC;

//----- (000AC449) --------------------------------------------------------
void sub_AC449()
{
	_disable();
}

//----- (000AC44B) --------------------------------------------------------
void sub_AC44B()
{
	_enable();
}

//----- (000AC70E) --------------------------------------------------------
__int16 sub_AC70E()
{
	x_DWORD *v0; // ebx
	int v1; // edx
	int v2; // ecx
	int v3; // eax
	int v4; // edx
	int v5; // ecx
	int v6; // edx
	x_DWORD v8[2]; // [esp+0h] [ebp-8h]

	//fix
	v1 = 0;
	v2 = 0;
	v4 = 0;
	v5 = 0;
	v6 = 0;
	//fix

	x_BYTE_E3E28 = 3;
	x_BYTE_E4D18 = 1;
	//__asm { smsw    x_WORD_E4D16 }
	x_WORD_E4D16 &= 6u;
	x__sidt(v8);
	v0 = (x_DWORD *)(*(x_DWORD *)((char *)v8 + 2) + 56);
	if (x_BYTE_E4CB4)
	{
		sub_AC7D9();
		__ES__ = x_WORD_E3B9A;
		*MK_FP(x_WORD_E3B9A, (unsigned int)v0) = v1;
		v0[1] = v2;
		LOWORD(v3) = sub_AC843();
	}
	else if (x_BYTE_E4CB2)
	{
		if (x_BYTE_E4CB2 == 9)
		{
			sub_AC7D9();
			*v0 = v4;
			v0[1] = v5;
			LOWORD(v3) = (*(int(/*__fastcall*/ **)(signed int, int, signed int))(x_DWORD_E3B94 + 48))(3586, v4, 4);
		}
		else if (x_BYTE_E4CB2 == 1)
		{
			LOWORD(v3) = _hook387(0, x_WORD_E3B98, (x_DWORD)v0);
		}
		else
		{
			v3 = _hook387(0, 0, (x_DWORD)v0);
			if ((x_BYTE)v3 != 1)
				LOWORD(v3) = sub_AC7F6(v3, v6, (int)v0);
		}
	}
	else
	{
		v8[1] = (unsigned __int16)__DS__;
		// fix it:__asm { int     21h; DOS - SET INTERRUPT VECTOR }
		LOWORD(v3) = -3324;
		//fix it: __asm { int     21h; DOS - Novell Advanced NetWare 2.0+ - FILE SERVER FILE COPY }
	}
	return v3;
}
// B4A72: using guessed type int /*__fastcall*/ _hook387(x_DWORD, x_DWORD, x_DWORD);
// E3B94: using guessed type int x_DWORD_E3B94;
// E3B98: using guessed type __int16 x_WORD_E3B98;
// E3B9A: using guessed type __int16 x_WORD_E3B9A;
// E3E28: using guessed type char x_BYTE_E3E28;
// E4CB2: using guessed type char x_BYTE_E4CB2;
// E4CB4: using guessed type char x_BYTE_E4CB4;
// E4D16: using guessed type __int16 x_WORD_E4D16;
// E4D18: using guessed type char x_BYTE_E4D18;

//----- (000AC7D9) --------------------------------------------------------
void sub_AC7D9()
{
	;
}

//----- (000AC7F6) --------------------------------------------------------
signed __int16 /*__fastcall*/ sub_AC7F6(int a1, int a2, int a3)
{
	signed __int16 result; // ax
	unsigned __int32 v4; // ecx

	// fix it:__asm { int     21h; DOS - SET INTERRUPT VECTOR }
	x_DWORD_E4D10 = a3;
	x_WORD_E4D14 = __ES__;
	result = 9476;
	if (x_BYTE_E4CB2 < 3)
	{
		//fix it:__asm { int     21h; DOS - }
		v4 = x__readcr0();
		x__writecr0((v4 | 4) & 0xFFFFFFFD);
	}
	else
	{
		// fix it:__asm { int     21h; DOS - SET INTERRUPT VECTOR }
		result = sub_AC843();
	}
	return result;
}
// E4CB2: using guessed type char x_BYTE_E4CB2;
// E4D10: using guessed type int x_DWORD_E4D10;
// E4D14: using guessed type __int16 x_WORD_E4D14;

//----- (000AC843) --------------------------------------------------------
signed __int16 sub_AC843()
{
	signed __int16 result; // ax

	result = 9525;
	// fix it:__asm { int     21h; DOS - SET INTERRUPT VECTOR }
	x_DWORD_E4CD0 |= 4u;
	x_DWORD_E4CD0 &= 0xFFFFFFFD;
	//fix it:__asm { int     21h; DOS - }
	return result;
}
// E4CD0: using guessed type int x_DWORD_E4CD0;

//----- (000AC8DD) --------------------------------------------------------
signed __int16 sub_AC8DD()
{
	signed __int16 result; // ax
	unsigned __int32 v1; // ecx

	result = 9476;
	// fix it:__asm { int     21h; DOS - SET INTERRUPT VECTOR }
	if (x_BYTE_E4CB2 >= 3)
		return sub_AC918();
	v1 = x__readcr0();
	v1 &= 0xFFFFFFF9;
	LOWORD(v1) = x_WORD_E4D16 | v1;
	x__writecr0(v1);
	return result;
}
// E4CB2: using guessed type char x_BYTE_E4CB2;
// E4D10: using guessed type int x_DWORD_E4D10;
// E4D14: using guessed type __int16 x_WORD_E4D14;
// E4D16: using guessed type __int16 x_WORD_E4D16;

//----- (000AC918) --------------------------------------------------------
signed __int16 sub_AC918()
{
	signed __int16 result; // ax

	result = 9525;
	// fix it:__asm { int     21h; DOS - SET INTERRUPT VECTOR }
	x_DWORD_E4CD0 = (unsigned __int16)x_WORD_E4D16;
	//fix it:__asm { int     21h; DOS - }
	return result;
}
// E4CD0: using guessed type int x_DWORD_E4CD0;
// E4D16: using guessed type __int16 x_WORD_E4D16;

//----- (000AC9C3) --------------------------------------------------------
void *sub_AC9C3()
{
	return &unk_182204;
}

//----- (000AC9C9) --------------------------------------------------------
void *sub_AC9C9()
{
	return &unk_182200;
}

//----- (000ACB61) --------------------------------------------------------
signed int sub_ACB61(int a1, unsigned __int8 *a2, int *a3)
{
	int *v3; // edi
	int v4; // ebp
	unsigned __int8 *v5; // ebx
	unsigned __int8 *v6; // ecx
	int v7; // ebx
	int v8; // eax
	unsigned __int8 *v9; // eax
	unsigned int v10; // ebx
	int v11; // eax
	signed int result; // eax
	int v13; // [esp-4h] [ebp-18h]
	signed int v14; // [esp+0h] [ebp-14h]

	v3 = a3;
	v4 = 0;
	v14 = 0;
	*(x_BYTE *)(a1 + 16) &= 0xFDu;
	while (1)
	{
		v5 = a2;
		v6 = a2++ + 1;
		v7 = *v5;
		if (!v7)
			break;
		if (IsTable[(unsigned __int8)(v7 + 1)] & 2)
		{
			v4 += sub_ACE56(a1);
		}
		else if (v7 == 37)
		{
			v9 = sub_ACD79(v6, a1);
			a2 = v9;
			v10 = *v9;
			if (*v9)
				a2 = v9 + 1;
			if (v10 < 0x65)
			{
				if (v10 < 0x58)
				{
					if (v10 < 0x45)
					{
						if (v10 == 37)
						{
							v8 = (*(int(**)(int))a1)(a1);
							if (v8 != 37)
							{
							LABEL_7:
								if (!(*(x_BYTE *)(a1 + 16) & 2))
									(*(void(**)(int, int))(a1 + 4))(v8, a1);
								break;
							}
						}
					}
					else if (v10 <= 0x45 || v10 == 71)
					{
					LABEL_45:
						sub_AD1E8(a1, v3);
						goto LABEL_50;
					}
				}
				else
				{
					if (v10 <= 0x58)
					{
					LABEL_44:
						sub_AD52B(a1, v3, 16, 1);
						goto LABEL_50;
					}
					if (v10 >= 0x63)
					{
						if (v10 > 0x63)
						{
							v13 = 1;
							goto LABEL_40;
						}
						v11 = sub_ACE8D((x_WORD *)a1, a1, v3);
					LABEL_50:
						if (v11 <= 0)
							break;
						v4 += v11;
						if (*(x_BYTE *)(a1 + 16) & 1)
							++v14;
						goto LABEL_55;
					}
					if (v10 == 91)
					{
						sub_AD0E2((x_BYTE *)a1, a1, v3, (x_BYTE**)&a2);
						goto LABEL_50;
					}
				}
			}
			else
			{
				if (v10 <= 0x67)
					goto LABEL_45;
				if (v10 < 0x70)
				{
					if (v10 < 0x6E)
					{
						if (v10 == 105)
						{
							sub_AD52B(a1, v3, 0, 1);
							goto LABEL_50;
						}
					}
					else
					{
						if (v10 > 0x6E)
						{
							sub_AD52B(a1, v3, 8, 1);
							goto LABEL_50;
						}
						sub_AD033(a1, v3, v4);
					}
				}
				else
				{
					if (v10 <= 0x70)
						goto LABEL_44;
					if (v10 < 0x75)
					{
						if (v10 == 115)
						{
							sub_ACF1A((x_BYTE *)a1, a1, v3);
							goto LABEL_50;
						}
					}
					else
					{
						if (v10 <= 0x75)
						{
							v13 = 0;
						LABEL_40:
							sub_AD52B(a1, v3, 10, v13);
							goto LABEL_50;
						}
						if (v10 == 120)
							goto LABEL_44;
					}
				}
			}
		}
		else
		{
			v8 = (*(int(**)(int))a1)(a1);
			if (v8 != v7)
				goto LABEL_7;
			++v4;
		}
	LABEL_55:
		if (*(x_BYTE *)(a1 + 16) & 2)
		{
			if (*a2 == 37)
			{
				++a2;
				a2 = sub_ACD79(a2, a1);
				if (*a2 == 110)
					sub_AD033(a1, v3, v4);
			}
			break;
		}
	}
	if (v14 || !(*(x_BYTE *)(a1 + 16) & 2))
		result = v14;
	else
		result = -1;
	return result;
}

//----- (000ACD79) --------------------------------------------------------
unsigned __int8 *sub_ACD79(unsigned __int8 *a1, int a2)
{
	unsigned __int8 *result; // eax
	char v3; // dl
	int v4; // edx
	unsigned __int8 v5; // cl
	int v6; // [esp+0h] [ebp-Ch]

	result = a1;
	v3 = *(x_BYTE *)(a2 + 16) | 1;
	*(x_DWORD *)(a2 + 12) = -1;
	*(x_BYTE *)(a2 + 16) = v3;
	*(x_BYTE *)(a2 + 16) = v3 & 3;
	if (*a1 == 42)
	{
		result = a1 + 1;
		*(x_BYTE *)(a2 + 16) &= 0xFEu;
	}
	v6 = *result;
	if (IsTable[(unsigned __int8)(v6 + 1)] & 0x20)
	{
		v4 = 0;
		do
		{
			++result;
			v4 = v6 - 48 + 10 * v4;
			v6 = *result;
		} while (IsTable[(unsigned __int8)(v6 + 1)] & 0x20);
		*(x_DWORD *)(a2 + 12) = v4;
	}
	if (*result == 78)
	{
		*(x_BYTE *)(a2 + 16) |= 8u;
	}
	else
	{
		if (*result != 70)
			goto LABEL_12;
		*(x_BYTE *)(a2 + 16) |= 4u;
	}
	++result;
LABEL_12:
	v5 = *result;
	if (*result < 0x68u)
	{
		if (v5 == 76)
		{
			++result;
			*(x_BYTE *)(a2 + 16) |= 0x40u;
		}
	}
	else if (*result <= 0x68u)
	{
		++result;
		*(x_BYTE *)(a2 + 16) |= 0x10u;
	}
	else if (v5 >= 0x6Cu && (v5 <= 0x6Cu || v5 == 119))
	{
		++result;
		*(x_BYTE *)(a2 + 16) |= 0x20u;
	}
	return result;
}

//----- (000ACE56) --------------------------------------------------------
int sub_ACE56(int a1)
{
	int i; // esi
	int v2; // eax

	for (i = 0; ; i++)
	{
		v2 = (*(int(**)(int))a1)(a1);
		if (!(IsTable[(unsigned __int8)(v2 + 1)] & 2))
			break;
	}
	if (!(*(x_BYTE *)(a1 + 16) & 2))
		(*(void(**)(int, int))(a1 + 4))(v2, a1);
	return i;
}

//----- (000ACE8D) --------------------------------------------------------
int sub_ACE8D(x_WORD *a1, int a2, int *a3)
{
	char v3; // dl
	int v4; // esi
	int v5; // eoff
	int v6; // ecx
	int v7; // edx
	signed int v8; // edi
	int v9; // ebp
	__int16 v10; // ax
	char v11; // ch

	v3 = *(x_BYTE *)(a2 + 16);
	if (v3 & 1)
	{
		if (v3 & 4)
		{
			v4 = *a3 + 8;
			*a3 = v4;
			v5 = v4 - 8;
			a1 = *(x_WORD **)(v4 - 8);
			__ES__ = *(x_WORD *)(v5 + 4);
		}
		else if (v3 & 8)
		{
			v6 = *a3 + 4;
			*a3 = v6;
			__ES__ = __DS__;
			a1 = *(x_WORD **)(v6 - 4);
		}
		else
		{
			v7 = *a3 + 4;
			*a3 = v7;
			__ES__ = __DS__;
			a1 = *(x_WORD **)(v7 - 4);
		}
	}
	v8 = *(x_DWORD *)(a2 + 12);
	v9 = 0;
	if (v8 == -1)
		v8 = 1;
	while (v8 > 0)
	{
		v10 = (*(int(**)(int))a2)(a2);
		v11 = *(x_BYTE *)(a2 + 16);
		if (v11 & 2)
			break;
		++v9;
		--v8;
		if (v11 & 1)
		{
			if (v11 & 0x20)
			{
				*a1 = v10;
				++a1;
			}
			else
			{
				*(x_BYTE *)a1 = v10;
				a1 = (x_WORD *)((char *)a1 + 1);
			}
		}
	}
	return v9;
}

//----- (000ACF1A) --------------------------------------------------------
void sub_ACF1A(x_BYTE *a1, int a2, int *a3)
{
	char v3; // dh
	int v4; // esi
	int v5; // eoff
	int v6; // ecx
	int v7; // edx
	int i; // edi
	int v9; // eax
	int v10; // [esp+0h] [ebp-1Ch]
	unsigned __int8 v11; // [esp+4h] [ebp-18h]

	if (*(x_BYTE *)(a2 + 16) & 0x20)
		v11 = 2;
	else
		v11 = 1;
	v3 = *(x_BYTE *)(a2 + 16);
	if (v3 & 1)
	{
		if (v3 & 4)
		{
			v4 = *a3 + 8;
			*a3 = v4;
			v5 = v4 - 8;
			a1 = *(x_BYTE **)(v4 - 8);
			__ES__ = *(x_WORD *)(v5 + 4);
		}
		else if (v3 & 8)
		{
			v6 = *a3 + 4;
			*a3 = v6;
			__ES__ = __DS__;
			a1 = *(x_BYTE **)(v6 - 4);
		}
		else
		{
			v7 = *a3 + 4;
			*a3 = v7;
			__ES__ = __DS__;
			a1 = *(x_BYTE **)(v7 - 4);
		}
	}
	for (i = 0; ; i++)
	{
		v10 = (*(int(**)(int))a2)(a2);
		if (!(IsTable[(unsigned __int8)(v10 + 1)] & 2))
			break;
	}
	if (*(x_BYTE *)(a2 + 16) & 2)
	{
		i = 0;
	}
	else
	{
		v9 = *(x_DWORD *)(a2 + 12);
		*(x_DWORD *)(a2 + 12) = v9 - 1;
		if (v9)
		{
			while (1)
			{
				++i;
				if (*(x_BYTE *)(a2 + 16) & 1)
				{
					if (v11 == 1)
						*a1 = v10;
					else
						*(x_WORD *)a1 = v10;
					a1 += v11;
				}
				v10 = sub_AD783(a2);
				if (v10 == -1)
					break;
				if (IsTable[(unsigned __int8)(v10 + 1)] & 2)
					goto LABEL_23;
			}
		}
		else
		{
		LABEL_23:
			(*(void(**)(int, int))(a2 + 4))(v10, a2);
		}
	}
	if (*(x_BYTE *)(a2 + 16) & 1 && i > 0)
	{
		if (v11 == 1)
			*a1 = 0;
		else
			*(x_WORD *)a1 = 0;
	}
	JUMPOUT((int*)&loc_ACF14);
}

//----- (000AD033) --------------------------------------------------------
int *sub_AD033(int a1, int *a2, int a3)
{
	int *result; // eax
	char v4; // bl
	int v5; // esi
	int v6; // ecx
	int v7; // ebx

	result = a2;
	v4 = *(x_BYTE *)(a1 + 16);
	if (v4 & 1)
	{
		if (v4 & 4)
		{
			v5 = *a2 + 8;
			*a2 = v5;
			result = *(int **)(v5 - 8);
			__ES__ = *(x_WORD *)(v5 - 8 + 4);
		}
		else if (v4 & 8)
		{
			v6 = *a2 + 4;
			*a2 = v6;
			__ES__ = __DS__;
			result = *(int **)(v6 - 4);
		}
		else
		{
			v7 = *a2 + 4;
			*a2 = v7;
			__ES__ = __DS__;
			result = *(int **)(v7 - 4);
		}
		if (*(x_BYTE *)(a1 + 16) & 0x10)
			*(x_WORD *)result = a3;
		else
			*result = a3;
	}
	return result;
}

//----- (000AD09E) --------------------------------------------------------
x_BYTE *sub_AD09E(x_BYTE *a1, int a2)
{
	int v2; // eax
	x_BYTE *v3; // ebx

	memset((void*)a2, 0, 32);
	v2 = (unsigned __int8)*a1;
	v3 = a1 + 1;
	if (*a1)
	{
		do
		{
			*(x_BYTE *)((v2 >> 3) + a2) |= x_BYTE_D3EA0[v2 & 7];
			v2 = (unsigned __int8)*v3;
			if (!*v3)
				break;
			++v3;
		} while (v2 != 93);
	}
	return v3;
}
// 8C250: using guessed type x_DWORD memset(x_DWORD, x_DWORD, x_DWORD);

//----- (000AD0E2) --------------------------------------------------------
void sub_AD0E2(x_BYTE *a1, int a2, int *a3, x_BYTE **a4)
{
	x_BYTE *v4; // eax
	bool v5; // zf
	char v6; // cl
	int v7; // ebp
	int v8; // esi
	int v9; // ecx
	int v10; // edi
	int v11; // ebp
	int v12; // eax
	char v13; // dl
	char v14[32]; // [esp+0h] [ebp-40h]
	int v15; // [esp+20h] [ebp-20h]
	bool v16; // [esp+24h] [ebp-1Ch]
	int v17; // [esp+28h] [ebp-18h]

	v4 = *a4;
	v5 = **a4 != 94;
	v16 = **a4 == 94;
	if (!v5)
		*a4 = v4 + 1;
	*a4 = sub_AD09E(*a4, (int)v14);
	v6 = *(x_BYTE *)(a2 + 16);
	if (v6 & 1)
	{
		if (v6 & 4)
		{
			v7 = *a3 + 8;
			*a3 = v7;
			a1 = *(x_BYTE **)(v7 - 8);
			__ES__ = *(x_WORD *)(v7 - 8 + 4);
		}
		else if (v6 & 8)
		{
			v8 = *a3 + 4;
			*a3 = v8;
			__ES__ = __DS__;
			a1 = *(x_BYTE **)(v8 - 4);
		}
		else
		{
			v9 = *a3 + 4;
			*a3 = v9;
			__ES__ = __DS__;
			a1 = *(x_BYTE **)(v9 - 4);
		}
	}
	v10 = *(x_DWORD *)(a2 + 12);
	v11 = 0;
	while (1)
	{
		if (!v10)
			goto LABEL_16;
		v12 = (*(int(**)(int))a2)(a2);
		v13 = *(x_BYTE *)(a2 + 16);
		v17 = v12;
		if (v13 & 2)
			goto LABEL_16;
		v15 = (unsigned __int8)v14[v12 >> 3];
		if (((unsigned __int8)(v15 & x_BYTE_D3EA0[v12 & 7]) == 0) != v16)
			break;
		++v11;
		--v10;
		if (*(x_BYTE *)(a2 + 16) & 1)
			*a1++ = v17;
	}
	(*(void(**)(int, int))(a2 + 4))(v12, a2);
LABEL_16:
	if (*(x_BYTE *)(a2 + 16) & 1)
	{
		if (v11 > 0)
			*a1 = 0;
	}
	JUMPOUT((int*)&loc_ACF14);
}
// AD0E2: using guessed type char var_40[32];

//----- (000AD1E8) --------------------------------------------------------
void sub_AD1E8(int a1, int *a2)
{
	char *v2; // ebx
	int v3; // edi
	int i; // ebp
	int v5; // eax
	int v6; // ecx
	char *v7; // ecx
	char v8; // al
	int v9; // eax
	char v10; // ah
	int v11; // ecx
	int *v12; // ebx
	int v13; // ebx
	int v14; // edx
	char v15; // dh
	int v16; // eax
	char v17; // [esp+0h] [ebp-80h]
	x_BYTE v18[3]; // [esp+1h] [ebp-7Fh]
	int v19; // [esp+50h] [ebp-30h]
	int v20; // [esp+54h] [ebp-2Ch]
	int v21; // [esp+58h] [ebp-28h]
	unsigned int j; // [esp+5Ch] [ebp-24h]
	int v23; // [esp+60h] [ebp-20h]
	int v24; // [esp+64h] [ebp-1Ch]
	int v25; // [esp+68h] [ebp-18h]

	//fix it
	v20 = 0;
	//fix it

	v2 = &v17;
	v3 = 0;
	for (i = 0; ; i++)
	{
		v5 = (*(int(**)(int))a1)(a1);
		v23 = v5;
		if (!(IsTable[(unsigned __int8)(v5 + 1)] & 2))
			break;
	}
	if (*(x_BYTE *)(a1 + 16) & 2)
		goto LABEL_42;
	v6 = *(x_DWORD *)(a1 + 12);
	*(x_DWORD *)(a1 + 12) = v6 - 1;
	if (v6)
	{
		if (v5 == 43 || v5 == 45)
		{
			v17 = v23;
			v2 = v18;
			v23 = sub_AD783(a1);
			if (v23 == -1)
				goto LABEL_42;
		}
		if (IsTable[(unsigned __int8)(v23 + 1)] & 0x20 || v23 == 46)
		{
			v21 = 0;
			v24 = 0;
			if (IsTable[(unsigned __int8)(v23 + 1)] & 0x20)
			{
				v24 = 1;
				while (1)
				{
					*v2++ = v23;
					if (*(x_BYTE *)(a1 + 16) & 0x10)
						HIWORD(v21) = v23 + 10 * HIWORD(v21) - 48;
					++v3;
					v23 = sub_AD783(a1);
					if (v23 == -1)
						break;
					if (!(IsTable[(unsigned __int8)(v23 + 1)] & 0x20))
						goto LABEL_17;
				}
			LABEL_42:
				if (v3 > 0 && *(x_BYTE *)(a1 + 16) & 1)
				{
					*v2 = 0;
					if (*(x_BYTE *)(a1 + 16) & 0x10)
					{
						if (v17 == 45)
							v21 = -v21;
					}
					else
					{
						off_E4D20((x_DWORD)&v17, (x_DWORD)&v19);
					}
					v10 = *(x_BYTE *)(a1 + 16);
					if (v10 & 4)
					{
						v11 = *a2 + 8;
						*a2 = v11;
						v12 = *(int **)(v11 - 8);
						__ES__ = *(x_WORD *)(v11 - 8 + 4);
					}
					else if (v10 & 8)
					{
						v13 = *a2 + 4;
						*a2 = v13;
						__ES__ = __DS__;
						v12 = *(int **)(v13 - 4);
					}
					else
					{
						v14 = *a2 + 4;
						*a2 = v14;
						__ES__ = __DS__;
						v12 = *(int **)(v14 - 4);
					}
					v15 = *(x_BYTE *)(a1 + 16);
					if (v15 & 0x10)
					{
						v16 = v21;
					}
					else
					{
						if (v15 & 0x20 || v15 & 0x40)
						{
							*v12 = v19;
							v12[1] = v20;
							goto LABEL_60;
						}
						v16 = _FDFS();
					}
					*v12 = v16;
				}
			LABEL_60:
				JUMPOUT((int*)&loc_ACF14);
			}
		LABEL_17:
			if (v23 == 46)
			{
				*v2++ = 46;
				v23 = sub_AD783(a1);
				if (v23 == -1)
					goto LABEL_42;
				if (!v24 && !(IsTable[(unsigned __int8)(v23 + 1)] & 0x20))
					goto LABEL_41;
				++v3;
				do
				{
					if (!(IsTable[(unsigned __int8)(v23 + 1)] & 0x20))
						break;
					++v3;
					*v2++ = v23;
					v23 = sub_AD783(a1);
				} while (v23 != -1);
				if (*(x_BYTE *)(a1 + 16) & 0x10)
				{
					v7 = v2;
					for (j = 0; ; j /= 0xAu)
					{
						v8 = *--v7;
						if (*v7 == 46)
							break;
						v25 = 10;
						BYTE2(j) = v8 - 48;
					}
					LOWORD(v21) = j;
				}
				if (v23 == -1)
					goto LABEL_42;
			}
			if (!(*(x_BYTE *)(a1 + 16) & 0x10) && (v23 == 101 || v23 == 69))
			{
				++v3;
				*v2 = v23;
				v9 = sub_AD783(a1);
				++v2;
				v23 = v9;
				if (v9 == -1)
					goto LABEL_42;
				if (v9 == 43 || v9 == 45)
				{
					++v3;
					*v2++ = v23;
					v23 = sub_AD783(a1);
					if (v23 == -1)
						goto LABEL_42;
				}
				if (IsTable[(unsigned __int8)(v23 + 1)] & 0x20)
				{
					while (1)
					{
						++v3;
						*v2++ = v23;
						v23 = sub_AD783(a1);
						if (v23 == -1)
							goto LABEL_42;
						if (!(IsTable[(unsigned __int8)(v23 + 1)] & 0x20))
							goto LABEL_41;
					}
				}
				v3 = 0;
			}
		}
	}
LABEL_41:
	(*(void(**)(int, int))(a1 + 4))(v23, a1);
	goto LABEL_42;
}
// B4C3A: using guessed type int _FDFS(void);
// E4D20: using guessed type int (*off_E4D20)(x_DWORD, x_DWORD);

//----- (000AD52B) --------------------------------------------------------
void sub_AD52B(int a1, int *a2, signed int a3, int a4)
{
	signed int v4; // ebp
	int v5; // edi
	signed int v6; // esi
	int v7; // eax
	int v8; // edx
	int v9; // eax
	int v10; // eax
	int v11; // eax
	int v12; // eax
	int v13; // eax
	int v14; // eax
	char v15; // ah
	int v16; // edx
	x_WORD *v17; // eax
	int v18; // ebp
	int v19; // ecx
	signed int v20; // [esp+0h] [ebp-20h]
	int v21; // [esp+4h] [ebp-1Ch]
	int i; // [esp+8h] [ebp-18h]

	v4 = a3;
	v5 = 0;
	v6 = 0;
	for (i = 0; ; i++)
	{
		v7 = (*(int(**)(int))a1)(a1);
		v21 = v7;
		if (!(IsTable[(unsigned __int8)(v7 + 1)] & 2))
			break;
	}
	if (*(x_BYTE *)(a1 + 16) & 2)
		goto LABEL_34;
	v8 = *(x_DWORD *)(a1 + 12);
	*(x_DWORD *)(a1 + 12) = v8 - 1;
	if (v8)
	{
		v20 = 43;
		if (a4 && (v7 == 43 || v7 == 45))
		{
			v20 = v7;
			v21 = sub_AD783(a1);
			if (v21 == -1)
				goto LABEL_34;
		}
		if (!a3)
		{
			if (v21 != 48)
			{
				v4 = 10;
				goto LABEL_26;
			}
			v9 = sub_AD783(a1);
			v6 = 1;
			v21 = v9;
			if (v9 != -1)
			{
				if (v9 != 120 && v9 != 88)
				{
					v4 = 8;
					goto LABEL_26;
				}
				v6 = 0;
				v21 = sub_AD783(a1);
				if (v21 != -1)
				{
					v4 = 16;
					goto LABEL_26;
				}
			}
			goto LABEL_34;
		}
		if (a3 != 16 || v21 != 48)
			goto LABEL_26;
		v10 = sub_AD783(a1);
		v6 = 1;
		v21 = v10;
		if (v10 == -1)
		{
		LABEL_34:
			if (v20 == 45)
				v5 = -v5;
			if (v6 > 0)
			{
				v15 = *(x_BYTE *)(a1 + 16);
				if (v15 & 1)
				{
					if (v15 & 4)
					{
						v16 = *a2 + 8;
						*a2 = v16;
						v17 = *(x_WORD **)(v16 - 8);
						__ES__ = *(x_WORD *)(v16 - 8 + 4);
					}
					else if (v15 & 8)
					{
						v18 = *a2 + 4;
						*a2 = v18;
						__ES__ = __DS__;
						v17 = *(x_WORD **)(v18 - 4);
					}
					else
					{
						v19 = *a2 + 4;
						*a2 = v19;
						__ES__ = __DS__;
						v17 = *(x_WORD **)(v19 - 4);
					}
					if (*(x_BYTE *)(a1 + 16) & 0x10)
						*v17 = v5;
					else
						*(x_DWORD *)v17 = v5;
				}
			}
			JUMPOUT((int*)&loc_ACF14);
		}
		if (v10 == 120 || v10 == 88)
		{
			v11 = sub_AD783(a1);
			v6 = 0;
			goto LABEL_25;
		}
	LABEL_26:
		while (1)
		{
			v12 = sub_AD754(v21);
			if (v12 >= v4)
				break;
			v5 = v12 + v4 * v5;
			v11 = sub_AD783(a1);
			++v6;
		LABEL_25:
			v21 = v11;
			if (v11 == -1)
				goto LABEL_34;
		}
		if (v21 == 58 && *(x_BYTE *)(a1 + 16) < 0)
		{
			while (1)
			{
				v13 = sub_AD783(a1);
				++v6;
				v21 = v13;
				if (v13 == -1)
					goto LABEL_34;
				v14 = sub_AD754(v13);
				if (v14 >= v4)
					break;
				v5 = v14 + v4 * v5;
			}
		}
	}
	(*(void(**)(int, int))(a1 + 4))(v21, a1);
	goto LABEL_34;
}

//----- (000AD754) --------------------------------------------------------
int sub_AD754(signed int a1)
{
	int result; // eax
	signed int v2; // eax

	if (a1 >= 48 && a1 <= 57)
		return a1 - 48;
	v2 = x_tolower(a1);
	if (v2 < 97 || v2 > 102)
		result = 16;
	else
		result = v2 - 87;
	return result;
}
// AB952: using guessed type x_DWORD x_tolower(x_DWORD);

//----- (000AD783) --------------------------------------------------------
int sub_AD783(int a1)
{
	int v1; // eax
	int result; // eax

	v1 = *(x_DWORD *)(a1 + 12);
	*(x_DWORD *)(a1 + 12) = v1 - 1;
	if (!v1 || (result = (*(int(**)(int))a1)(a1), *(x_BYTE *)(a1 + 16) & 2))
		result = -1;
	return result;
}

//----- (000ADC52) --------------------------------------------------------
int sub_ADC52(x_BYTE *a1)
{
	x_DWORD *v1; // eax
	int v2; // eax

	//fix it
	v2 = 0;
	//fix it

	if (a1 && *a1)
	{
		fputs(a1, (FILE*)&unk_E3BE0);
		fputs(": ", (FILE*)&unk_E3BE0);
	}
	v1 = (x_DWORD*)sub_AC9C3();
	strerror_s((char *)v2, (rsize_t)sizeof(v2), (errno_t)*v1);
	fputs((const char*)v2, (FILE*)&unk_E3BE0);
	return fputc(10, (FILE*)&unk_E3BE0);
}
// AC9CF: using guessed type x_DWORD fputc(x_DWORD, x_DWORD);
// B4E49: using guessed type x_DWORD fputs(x_DWORD, x_DWORD);
// B4EDE: using guessed type x_DWORD strerror(x_DWORD);

//----- (000AEAF5) --------------------------------------------------------
int sub_AEAF5()
{
	return x_DWORD_E4C90;
}
// E4C90: using guessed type int x_DWORD_E4C90;

//----- (000AEF40) --------------------------------------------------------
int sub_AEF40(int a1, x_BYTE *a2, int *a3)
{
	int v3; // eax
	int result; // eax

	do
	{
		v3 = *a3;
		++a3;
		result = v3 ^ 0x8000;
		*a2++ = BYTE1(result);
		--a1;
	} while (a1);
	return result;
}

//----- (000AEF51) --------------------------------------------------------
int sub_AEF51(int a1, x_BYTE *a2, int *a3)
{
	int result; // eax

	do
	{
		result = *a3;
		++a3;
		*a2++ = BYTE1(result);
		--a1;
	} while (a1);
	return result;
}

//----- (000AEF5D) --------------------------------------------------------
int sub_AEF5D(int a1, x_WORD *a2, int *a3)
{
	int v3; // eax
	int v4; // edx
	int result; // eax

	do
	{
		v3 = *a3;
		v4 = a3[1];
		a3 += 2;
		result = v3 ^ 0x8000;
		BYTE1(v4) ^= 0x80u;
		LOBYTE(v4) = BYTE1(result);
		*a2 = v4;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AEF7C) --------------------------------------------------------
int sub_AEF7C(int a1, x_WORD *a2, int *a3)
{
	int result; // eax
	int v4; // edx

	do
	{
		result = *a3;
		v4 = a3[1];
		a3 += 2;
		LOBYTE(v4) = BYTE1(result);
		*a2 = v4;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AEF90) --------------------------------------------------------
char sub_AEF90(int a1, x_WORD *a2, int *a3)
{
	int v3; // eax
	int v4; // edx
	__int16 v5; // ax

	do
	{
		v3 = *a3;
		v4 = a3[1];
		a3 += 2;
		HIBYTE(v5) = BYTE1(v3) ^ 0x80;
		LOBYTE(v5) = BYTE1(v4) ^ 0x80;
		*a2 = v5;
		++a2;
		--a1;
	} while (a1);
	return v5;
}

//----- (000AEFAF) --------------------------------------------------------
char sub_AEFAF(int a1, x_WORD *a2, int *a3)
{
	int v3; // edx
	int v4; // eax

	do
	{
		v4 = *a3;
		v3 = a3[1];
		a3 += 2;
		LOBYTE(v4) = BYTE1(v3);
		*a2 = v4;
		++a2;
		--a1;
	} while (a1);
	return v4;
}

//----- (000AEFC3) --------------------------------------------------------
int sub_AEFC3(int a1, x_BYTE *a2, x_BYTE *a3, int *a4)
{
	int v4; // eax
	int v5; // edx
	int result; // eax

	do
	{
		v4 = *a4;
		v5 = a4[1];
		a4 += 2;
		result = v4 ^ 0x8000;
		*a3 = BYTE1(result);
		*a2 = BYTE1(v5) ^ 0x80;
		++a3;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AEFE0) --------------------------------------------------------
int sub_AEFE0(int a1, x_BYTE *a2, x_BYTE *a3, int *a4)
{
	int result; // eax
	int v5; // edx

	do
	{
		result = *a4;
		v5 = a4[1];
		a4 += 2;
		*a3 = BYTE1(result);
		*a2 = BYTE1(v5);
		++a3;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AEFF2) --------------------------------------------------------
int sub_AEFF2(int a1, x_BYTE *a2, x_BYTE *a3, int *a4)
{
	int v4; // eax
	int v5; // edx
	int result; // eax

	do
	{
		v4 = *a4;
		v5 = a4[1];
		a4 += 2;
		result = v4 ^ 0x8000;
		*a3 = BYTE1(v5) ^ 0x80;
		*a2 = BYTE1(result);
		++a3;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF00F) --------------------------------------------------------
int sub_AF00F(int a1, x_BYTE *a2, x_BYTE *a3, int *a4)
{
	int result; // eax
	int v5; // edx

	do
	{
		result = *a4;
		v5 = a4[1];
		a4 += 2;
		*a3 = BYTE1(v5);
		*a2 = BYTE1(result);
		++a3;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF021) --------------------------------------------------------
int sub_AF021(int a1, x_WORD *a2, int *a3)
{
	int v3; // eax
	int result; // eax

	do
	{
		v3 = *a3;
		++a3;
		result = v3 ^ 0x8000;
		*a2 = result;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF035) --------------------------------------------------------
int sub_AF035(int a1, x_WORD *a2, int *a3)
{
	int result; // eax

	do
	{
		result = *a3;
		++a3;
		*a2 = result;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF044) --------------------------------------------------------
__int16 sub_AF044(int a1, x_WORD *a2, int *a3)
{
	int v3; // eax
	__int16 result; // ax
	char v5; // t0

	do
	{
		v3 = *a3;
		++a3;
		LOWORD(v3) = v3 ^ 0x8000;
		v5 = v3;
		LOBYTE(result) = BYTE1(v3);
		HIBYTE(result) = v5;
		*a2 = result;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF05A) --------------------------------------------------------
__int16 sub_AF05A(int a1, x_WORD *a2, int *a3)
{
	int v3; // eax
	__int16 result; // ax
	char v5; // t0

	do
	{
		v3 = *a3;
		++a3;
		v5 = v3;
		LOBYTE(result) = BYTE1(v3);
		HIBYTE(result) = v5;
		*a2 = result;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF06B) --------------------------------------------------------
int sub_AF06B(int a1, x_WORD *a2, int *a3)
{
	int v3; // eax
	int v4; // edx
	int result; // eax

	do
	{
		v3 = *a3;
		v4 = a3[1];
		a3 += 2;
		result = v3 ^ 0x8000;
		*a2 = result;
		a2[1] = v4 ^ 0x8000;
		a2 += 2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF08C) --------------------------------------------------------
int sub_AF08C(int a1, x_WORD *a2, int *a3)
{
	int result; // eax
	int v4; // edx

	do
	{
		result = *a3;
		v4 = a3[1];
		a3 += 2;
		*a2 = result;
		a2[1] = v4;
		a2 += 2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF0A2) --------------------------------------------------------
int sub_AF0A2(int a1, x_WORD *a2, int *a3)
{
	int v3; // eax
	int v4; // edx
	int result; // eax

	do
	{
		v3 = *a3;
		v4 = a3[1];
		a3 += 2;
		result = v3 ^ 0x8000;
		*a2 = v4 ^ 0x8000;
		a2[1] = result;
		a2 += 2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF0C3) --------------------------------------------------------
int sub_AF0C3(int a1, x_WORD *a2, int *a3)
{
	int result; // eax
	int v4; // edx

	do
	{
		result = *a3;
		v4 = a3[1];
		a3 += 2;
		*a2 = v4;
		a2[1] = result;
		a2 += 2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF0D9) --------------------------------------------------------
int sub_AF0D9(int a1, x_WORD *a2, int *a3)
{
	int v3; // eax
	int v4; // edx
	int result; // eax
	char v6; // t0
	char v7; // t1

	do
	{
		v3 = *a3;
		v4 = a3[1];
		a3 += 2;
		result = v3 ^ 0x8000;
		LOWORD(v4) = v4 ^ 0x8000;
		v6 = result;
		LOBYTE(result) = BYTE1(result);
		BYTE1(result) = v6;
		v7 = v4;
		LOBYTE(v4) = BYTE1(v4);
		BYTE1(v4) = v7;
		*a2 = result;
		a2[1] = v4;
		a2 += 2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF0FE) --------------------------------------------------------
int sub_AF0FE(int a1, x_WORD *a2, int *a3)
{
	int v3; // edx
	int result; // eax
	char v5; // t0
	char v6; // t1

	do
	{
		result = *a3;
		v3 = a3[1];
		a3 += 2;
		v5 = result;
		LOBYTE(result) = BYTE1(result);
		BYTE1(result) = v5;
		v6 = v3;
		LOBYTE(v3) = BYTE1(v3);
		BYTE1(v3) = v6;
		*a2 = result;
		a2[1] = v3;
		a2 += 2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF118) --------------------------------------------------------
int sub_AF118(int a1, x_WORD *a2, int *a3)
{
	int v3; // eax
	int v4; // edx
	int result; // eax
	char v6; // t0
	char v7; // t1

	do
	{
		v3 = *a3;
		v4 = a3[1];
		a3 += 2;
		result = v3 ^ 0x8000;
		LOWORD(v4) = v4 ^ 0x8000;
		v6 = result;
		LOBYTE(result) = BYTE1(result);
		BYTE1(result) = v6;
		v7 = v4;
		LOBYTE(v4) = BYTE1(v4);
		BYTE1(v4) = v7;
		*a2 = v4;
		a2[1] = result;
		a2 += 2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF13D) --------------------------------------------------------
int sub_AF13D(int a1, x_WORD *a2, int *a3)
{
	int v3; // edx
	int result; // eax
	char v5; // t0
	char v6; // t1

	do
	{
		result = *a3;
		v3 = a3[1];
		a3 += 2;
		v5 = result;
		LOBYTE(result) = BYTE1(result);
		BYTE1(result) = v5;
		v6 = v3;
		LOBYTE(v3) = BYTE1(v3);
		BYTE1(v3) = v6;
		*a2 = v3;
		a2[1] = result;
		a2 += 2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF157) --------------------------------------------------------
int sub_AF157(int a1, x_WORD *a2, x_WORD *a3, int *a4)
{
	int v4; // eax
	int v5; // edx
	int result; // eax

	do
	{
		v4 = *a4;
		v5 = a4[1];
		a4 += 2;
		result = v4 ^ 0x8000;
		*a3 = result;
		*a2 = v5 ^ 0x8000;
		++a3;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF17A) --------------------------------------------------------
int sub_AF17A(int a1, x_WORD *a2, x_WORD *a3, int *a4)
{
	int result; // eax
	int v5; // edx

	do
	{
		result = *a4;
		v5 = a4[1];
		a4 += 2;
		*a3 = result;
		*a2 = v5;
		++a3;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF192) --------------------------------------------------------
int sub_AF192(int a1, x_WORD *a2, x_WORD *a3, int *a4)
{
	int v4; // eax
	int v5; // edx
	int result; // eax

	do
	{
		v4 = *a4;
		v5 = a4[1];
		a4 += 2;
		result = v4 ^ 0x8000;
		*a3 = v5 ^ 0x8000;
		*a2 = result;
		++a3;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF1B5) --------------------------------------------------------
int sub_AF1B5(int a1, x_WORD *a2, x_WORD *a3, int *a4)
{
	int result; // eax
	int v5; // edx

	do
	{
		result = *a4;
		v5 = a4[1];
		a4 += 2;
		*a3 = v5;
		*a2 = result;
		++a3;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF1CD) --------------------------------------------------------
int sub_AF1CD(int a1, x_WORD *a2, x_WORD *a3, int *a4)
{
	int v4; // eax
	int v5; // edx
	int result; // eax
	char v7; // t0
	char v8; // t1

	do
	{
		v4 = *a4;
		v5 = a4[1];
		a4 += 2;
		result = v4 ^ 0x8000;
		LOWORD(v5) = v5 ^ 0x8000;
		v7 = result;
		LOBYTE(result) = BYTE1(result);
		BYTE1(result) = v7;
		v8 = v5;
		LOBYTE(v5) = BYTE1(v5);
		BYTE1(v5) = v8;
		*a3 = result;
		*a2 = v5;
		++a3;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF1F4) --------------------------------------------------------
int sub_AF1F4(int a1, x_WORD *a2, x_WORD *a3, int *a4)
{
	int v4; // edx
	int result; // eax
	char v6; // t0
	char v7; // t1

	do
	{
		result = *a4;
		v4 = a4[1];
		a4 += 2;
		v6 = result;
		LOBYTE(result) = BYTE1(result);
		BYTE1(result) = v6;
		v7 = v4;
		LOBYTE(v4) = BYTE1(v4);
		BYTE1(v4) = v7;
		*a3 = result;
		*a2 = v4;
		++a3;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF210) --------------------------------------------------------
int sub_AF210(int a1, x_WORD *a2, x_WORD *a3, int *a4)
{
	int v4; // eax
	int v5; // edx
	int result; // eax
	char v7; // t0
	char v8; // t1

	do
	{
		v4 = *a4;
		v5 = a4[1];
		a4 += 2;
		result = v4 ^ 0x8000;
		LOWORD(v5) = v5 ^ 0x8000;
		v7 = result;
		LOBYTE(result) = BYTE1(result);
		BYTE1(result) = v7;
		v8 = v5;
		LOBYTE(v5) = BYTE1(v5);
		BYTE1(v5) = v8;
		*a3 = v5;
		*a2 = result;
		++a3;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF237) --------------------------------------------------------
int sub_AF237(int a1, x_WORD *a2, x_WORD *a3, int *a4)
{
	int v4; // edx
	int result; // eax
	char v6; // t0
	char v7; // t1

	do
	{
		result = *a4;
		v4 = a4[1];
		a4 += 2;
		v6 = result;
		LOBYTE(result) = BYTE1(result);
		BYTE1(result) = v6;
		v7 = v4;
		LOBYTE(v4) = BYTE1(v4);
		BYTE1(v4) = v7;
		*a3 = v4;
		*a2 = result;
		++a3;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF253) --------------------------------------------------------
int sub_AF253(int a1, x_BYTE *a2, signed int *a3)
{
	signed int v3; // eax
	int result; // eax

	do
	{
		v3 = *a3;
		++a3;
		if (v3 > 0x7FFF)
		{
			v3 = 0x7FFF;
		}
		else if (v3 < -32768)
		{
			v3 = -32768;
		}
		result = v3 ^ 0x8000;
		*a2++ = BYTE1(result);
		--a1;
	} while (a1);
	return result;
}

//----- (000AF280) --------------------------------------------------------
signed int sub_AF280(int a1, x_BYTE *a2, signed int *a3)
{
	signed int result; // eax

	do
	{
		result = *a3;
		++a3;
		if (result > 0x7FFF)
		{
			result = 0x7FFF;
		}
		else if (result < -32768)
		{
			result = -32768;
		}
		*a2++ = BYTE1(result);
		--a1;
	} while (a1);
	return result;
}

//----- (000AF2A8) --------------------------------------------------------
int sub_AF2A8(int a1, x_WORD *a2, signed int *a3)
{
	signed int v3; // eax
	signed int v4; // edx
	int result; // eax
	__int16 v6; // dx

	do
	{
		v3 = *a3;
		v4 = a3[1];
		a3 += 2;
		if (v3 > 0x7FFF)
		{
			v3 = 0x7FFF;
		}
		else if (v3 < -32768)
		{
			v3 = -32768;
		}
		if (v4 > 0x7FFF)
		{
			BYTE1(v4) = 127;
		}
		else if (v4 < -32768)
		{
			BYTE1(v4) = -128;
		}
		result = v3 ^ 0x8000;
		HIBYTE(v6) = BYTE1(v4) ^ 0x80;
		LOBYTE(v6) = BYTE1(result);
		*a2 = v6;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF301) --------------------------------------------------------
signed int sub_AF301(int a1, x_WORD *a2, signed int *a3)
{
	signed int result; // eax
	signed int v4; // edx

	do
	{
		result = *a3;
		v4 = a3[1];
		a3 += 2;
		if (result > 0x7FFF)
		{
			result = 0x7FFF;
		}
		else if (result < -32768)
		{
			result = -32768;
		}
		if (v4 > 0x7FFF)
		{
			BYTE1(v4) = 127;
		}
		else if (v4 < -32768)
		{
			BYTE1(v4) = -128;
		}
		LOBYTE(v4) = BYTE1(result);
		*a2 = v4;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF34F) --------------------------------------------------------
char sub_AF34F(int a1, x_WORD *a2, signed int *a3)
{
	signed int v3; // eax
	signed int v4; // edx
	__int16 v5; // ax

	do
	{
		v3 = *a3;
		v4 = a3[1];
		a3 += 2;
		if (v3 > 0x7FFF)
		{
			BYTE1(v3) = 127;
		}
		else if (v3 < -32768)
		{
			BYTE1(v3) = -128;
		}
		if (v4 > 0x7FFF)
		{
			BYTE1(v4) = 127;
		}
		else if (v4 < -32768)
		{
			BYTE1(v4) = -128;
		}
		HIBYTE(v5) = BYTE1(v3) ^ 0x80;
		LOBYTE(v5) = BYTE1(v4) ^ 0x80;
		*a2 = v5;
		++a2;
		--a1;
	} while (a1);
	return v5;
}

//----- (000AF3A8) --------------------------------------------------------
char sub_AF3A8(int a1, x_WORD *a2, signed int *a3)
{
	signed int v3; // eax
	signed int v4; // edx

	do
	{
		v3 = *a3;
		v4 = a3[1];
		a3 += 2;
		if (v3 > 0x7FFF)
		{
			BYTE1(v3) = 127;
		}
		else if (v3 < -32768)
		{
			BYTE1(v3) = -128;
		}
		if (v4 > 0x7FFF)
		{
			BYTE1(v4) = 127;
		}
		else if (v4 < -32768)
		{
			BYTE1(v4) = -128;
		}
		LOBYTE(v3) = BYTE1(v4);
		*a2 = v3;
		++a2;
		--a1;
	} while (a1);
	return v3;
}

//----- (000AF3F6) --------------------------------------------------------
int sub_AF3F6(int a1, x_BYTE *a2, x_BYTE *a3, signed int *a4)
{
	signed int v4; // eax
	signed int v5; // edx
	int result; // eax

	do
	{
		v4 = *a4;
		v5 = a4[1];
		a4 += 2;
		if (v4 > 0x7FFF)
		{
			v4 = 0x7FFF;
		}
		else if (v4 < -32768)
		{
			v4 = -32768;
		}
		if (v5 > 0x7FFF)
		{
			BYTE1(v5) = 127;
		}
		else if (v5 < -32768)
		{
			BYTE1(v5) = -128;
		}
		result = v4 ^ 0x8000;
		*a3 = BYTE1(result);
		*a2 = BYTE1(v5) ^ 0x80;
		++a3;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF44D) --------------------------------------------------------
signed int sub_AF44D(int a1, x_BYTE *a2, x_BYTE *a3, signed int *a4)
{
	signed int result; // eax
	signed int v5; // edx

	do
	{
		result = *a4;
		v5 = a4[1];
		a4 += 2;
		if (result > 0x7FFF)
		{
			result = 0x7FFF;
		}
		else if (result < -32768)
		{
			result = -32768;
		}
		if (v5 > 0x7FFF)
		{
			BYTE1(v5) = 127;
		}
		else if (v5 < -32768)
		{
			BYTE1(v5) = -128;
		}
		*a3 = BYTE1(result);
		*a2 = BYTE1(v5);
		++a3;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF499) --------------------------------------------------------
int sub_AF499(int a1, x_BYTE *a2, x_BYTE *a3, signed int *a4)
{
	signed int v4; // eax
	signed int v5; // edx
	int result; // eax

	do
	{
		v4 = *a4;
		v5 = a4[1];
		a4 += 2;
		if (v4 > 0x7FFF)
		{
			v4 = 0x7FFF;
		}
		else if (v4 < -32768)
		{
			v4 = -32768;
		}
		if (v5 > 0x7FFF)
		{
			BYTE1(v5) = 127;
		}
		else if (v5 < -32768)
		{
			BYTE1(v5) = -128;
		}
		result = v4 ^ 0x8000;
		*a3 = BYTE1(v5) ^ 0x80;
		*a2 = BYTE1(result);
		++a3;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF4F0) --------------------------------------------------------
signed int sub_AF4F0(int a1, x_BYTE *a2, x_BYTE *a3, signed int *a4)
{
	signed int result; // eax
	signed int v5; // edx

	do
	{
		result = *a4;
		v5 = a4[1];
		a4 += 2;
		if (result > 0x7FFF)
		{
			result = 0x7FFF;
		}
		else if (result < -32768)
		{
			result = -32768;
		}
		if (v5 > 0x7FFF)
		{
			BYTE1(v5) = 127;
		}
		else if (v5 < -32768)
		{
			BYTE1(v5) = -128;
		}
		*a3 = BYTE1(v5);
		*a2 = BYTE1(result);
		++a3;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF53C) --------------------------------------------------------
int sub_AF53C(int a1, x_WORD *a2, signed int *a3)
{
	signed int v3; // eax
	int result; // eax

	do
	{
		v3 = *a3;
		++a3;
		if (v3 > 0x7FFF)
		{
			v3 = 0x7FFF;
		}
		else if (v3 < -32768)
		{
			v3 = -32768;
		}
		result = v3 ^ 0x8000;
		*a2 = result;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF56C) --------------------------------------------------------
signed int sub_AF56C(int a1, x_WORD *a2, signed int *a3)
{
	signed int result; // eax

	do
	{
		result = *a3;
		++a3;
		if (result > 0x7FFF)
		{
			result = 0x7FFF;
		}
		else if (result < -32768)
		{
			result = -32768;
		}
		*a2 = result;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF597) --------------------------------------------------------
__int16 sub_AF597(int a1, x_WORD *a2, signed int *a3)
{
	signed int v3; // eax
	__int16 v4; // ax
	__int16 result; // ax
	char v6; // t0

	do
	{
		v3 = *a3;
		++a3;
		if (v3 > 0x7FFF)
		{
			LOWORD(v3) = 0x7FFF;
		}
		else if (v3 < -32768)
		{
			LOWORD(v3) = -32768;
		}
		v4 = v3 ^ 0x8000;
		v6 = v4;
		LOBYTE(result) = HIBYTE(v4);
		HIBYTE(result) = v6;
		*a2 = result;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF5C9) --------------------------------------------------------
__int16 sub_AF5C9(int a1, x_WORD *a2, signed int *a3)
{
	signed int v3; // eax
	__int16 result; // ax
	char v5; // t0

	do
	{
		v3 = *a3;
		++a3;
		if (v3 > 0x7FFF)
		{
			LOWORD(v3) = 0x7FFF;
		}
		else if (v3 < -32768)
		{
			LOWORD(v3) = -32768;
		}
		v5 = v3;
		LOBYTE(result) = BYTE1(v3);
		HIBYTE(result) = v5;
		*a2 = result;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF5F6) --------------------------------------------------------
int sub_AF5F6(int a1, x_WORD *a2, signed int *a3)
{
	signed int v3; // eax
	signed int v4; // edx
	int result; // eax

	do
	{
		v3 = *a3;
		v4 = a3[1];
		a3 += 2;
		if (v3 > 0x7FFF)
		{
			v3 = 0x7FFF;
		}
		else if (v3 < -32768)
		{
			v3 = -32768;
		}
		if (v4 > 0x7FFF)
		{
			LOWORD(v4) = 0x7FFF;
		}
		else if (v4 < -32768)
		{
			LOWORD(v4) = -32768;
		}
		result = v3 ^ 0x8000;
		*a2 = result;
		a2[1] = v4 ^ 0x8000;
		a2 += 2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF651) --------------------------------------------------------
signed int sub_AF651(int a1, x_WORD *a2, signed int *a3)
{
	signed int result; // eax
	signed int v4; // edx

	do
	{
		result = *a3;
		v4 = a3[1];
		a3 += 2;
		if (result > 0x7FFF)
		{
			result = 0x7FFF;
		}
		else if (result < -32768)
		{
			result = -32768;
		}
		if (v4 > 0x7FFF)
		{
			LOWORD(v4) = 0x7FFF;
		}
		else if (v4 < -32768)
		{
			LOWORD(v4) = -32768;
		}
		*a2 = result;
		a2[1] = v4;
		a2 += 2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF6A1) --------------------------------------------------------
int sub_AF6A1(int a1, x_WORD *a2, signed int *a3)
{
	signed int v3; // eax
	signed int v4; // edx
	int result; // eax

	do
	{
		v3 = *a3;
		v4 = a3[1];
		a3 += 2;
		if (v3 > 0x7FFF)
		{
			v3 = 0x7FFF;
		}
		else if (v3 < -32768)
		{
			v3 = -32768;
		}
		if (v4 > 0x7FFF)
		{
			LOWORD(v4) = 0x7FFF;
		}
		else if (v4 < -32768)
		{
			LOWORD(v4) = -32768;
		}
		result = v3 ^ 0x8000;
		*a2 = v4 ^ 0x8000;
		a2[1] = result;
		a2 += 2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF6FC) --------------------------------------------------------
signed int sub_AF6FC(int a1, x_WORD *a2, signed int *a3)
{
	signed int result; // eax
	signed int v4; // edx

	do
	{
		result = *a3;
		v4 = a3[1];
		a3 += 2;
		if (result > 0x7FFF)
		{
			result = 0x7FFF;
		}
		else if (result < -32768)
		{
			result = -32768;
		}
		if (v4 > 0x7FFF)
		{
			LOWORD(v4) = 0x7FFF;
		}
		else if (v4 < -32768)
		{
			LOWORD(v4) = -32768;
		}
		*a2 = v4;
		a2[1] = result;
		a2 += 2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF74C) --------------------------------------------------------
int sub_AF74C(int a1, x_WORD *a2, signed int *a3)
{
	signed int v3; // eax
	signed int v4; // edx
	__int16 v5; // dx
	int result; // eax
	char v7; // t0
	char v8; // t1

	do
	{
		v3 = *a3;
		v4 = a3[1];
		a3 += 2;
		if (v3 > 0x7FFF)
		{
			v3 = 0x7FFF;
		}
		else if (v3 < -32768)
		{
			v3 = -32768;
		}
		if (v4 > 0x7FFF)
		{
			LOWORD(v4) = 0x7FFF;
		}
		else if (v4 < -32768)
		{
			LOWORD(v4) = -32768;
		}
		result = v3 ^ 0x8000;
		v5 = v4 ^ 0x8000;
		v7 = result;
		LOBYTE(result) = BYTE1(result);
		BYTE1(result) = v7;
		v8 = v5;
		LOBYTE(v5) = HIBYTE(v5);
		HIBYTE(v5) = v8;
		*a2 = result;
		a2[1] = v5;
		a2 += 2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF7AB) --------------------------------------------------------
__int16 sub_AF7AB(int a1, x_WORD *a2, signed int *a3)
{
	signed int v3; // eax
	signed int v4; // edx
	__int16 result; // ax
	char v6; // t0
	__int16 v7; // dx
	char v8; // t1

	do
	{
		v3 = *a3;
		v4 = a3[1];
		a3 += 2;
		if (v3 > 0x7FFF)
		{
			LOWORD(v3) = 0x7FFF;
		}
		else if (v3 < -32768)
		{
			LOWORD(v3) = -32768;
		}
		if (v4 > 0x7FFF)
		{
			LOWORD(v4) = 0x7FFF;
		}
		else if (v4 < -32768)
		{
			LOWORD(v4) = -32768;
		}
		v6 = v3;
		LOBYTE(result) = BYTE1(v3);
		HIBYTE(result) = v6;
		v8 = v4;
		LOBYTE(v7) = BYTE1(v4);
		HIBYTE(v7) = v8;
		*a2 = result;
		a2[1] = v7;
		a2 += 2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF7FF) --------------------------------------------------------
int sub_AF7FF(int a1, x_WORD *a2, signed int *a3)
{
	signed int v3; // eax
	signed int v4; // edx
	__int16 v5; // dx
	int result; // eax
	char v7; // t0
	char v8; // t1

	do
	{
		v3 = *a3;
		v4 = a3[1];
		a3 += 2;
		if (v3 > 0x7FFF)
		{
			v3 = 0x7FFF;
		}
		else if (v3 < -32768)
		{
			v3 = -32768;
		}
		if (v4 > 0x7FFF)
		{
			LOWORD(v4) = 0x7FFF;
		}
		else if (v4 < -32768)
		{
			LOWORD(v4) = -32768;
		}
		result = v3 ^ 0x8000;
		v5 = v4 ^ 0x8000;
		v7 = result;
		LOBYTE(result) = BYTE1(result);
		BYTE1(result) = v7;
		v8 = v5;
		LOBYTE(v5) = HIBYTE(v5);
		HIBYTE(v5) = v8;
		*a2 = v5;
		a2[1] = result;
		a2 += 2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF85E) --------------------------------------------------------
__int16 sub_AF85E(int a1, x_WORD *a2, signed int *a3)
{
	signed int v3; // eax
	signed int v4; // edx
	__int16 result; // ax
	char v6; // t0
	__int16 v7; // dx
	char v8; // t1

	do
	{
		v3 = *a3;
		v4 = a3[1];
		a3 += 2;
		if (v3 > 0x7FFF)
		{
			LOWORD(v3) = 0x7FFF;
		}
		else if (v3 < -32768)
		{
			LOWORD(v3) = -32768;
		}
		if (v4 > 0x7FFF)
		{
			LOWORD(v4) = 0x7FFF;
		}
		else if (v4 < -32768)
		{
			LOWORD(v4) = -32768;
		}
		v6 = v3;
		LOBYTE(result) = BYTE1(v3);
		HIBYTE(result) = v6;
		v8 = v4;
		LOBYTE(v7) = BYTE1(v4);
		HIBYTE(v7) = v8;
		*a2 = v7;
		a2[1] = result;
		a2 += 2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF8B2) --------------------------------------------------------
int sub_AF8B2(int a1, x_WORD *a2, x_WORD *a3, signed int *a4)
{
	signed int v4; // eax
	signed int v5; // edx
	int result; // eax

	do
	{
		v4 = *a4;
		v5 = a4[1];
		a4 += 2;
		if (v4 > 0x7FFF)
		{
			v4 = 0x7FFF;
		}
		else if (v4 < -32768)
		{
			v4 = -32768;
		}
		if (v5 > 0x7FFF)
		{
			LOWORD(v5) = 0x7FFF;
		}
		else if (v5 < -32768)
		{
			LOWORD(v5) = -32768;
		}
		result = v4 ^ 0x8000;
		*a3 = result;
		*a2 = v5 ^ 0x8000;
		++a3;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF90F) --------------------------------------------------------
signed int sub_AF90F(int a1, x_WORD *a2, x_WORD *a3, signed int *a4)
{
	signed int result; // eax
	signed int v5; // edx

	do
	{
		result = *a4;
		v5 = a4[1];
		a4 += 2;
		if (result > 0x7FFF)
		{
			result = 0x7FFF;
		}
		else if (result < -32768)
		{
			result = -32768;
		}
		if (v5 > 0x7FFF)
		{
			LOWORD(v5) = 0x7FFF;
		}
		else if (v5 < -32768)
		{
			LOWORD(v5) = -32768;
		}
		*a3 = result;
		*a2 = v5;
		++a3;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF961) --------------------------------------------------------
int sub_AF961(int a1, x_WORD *a2, x_WORD *a3, signed int *a4)
{
	signed int v4; // eax
	signed int v5; // edx
	int result; // eax

	do
	{
		v4 = *a4;
		v5 = a4[1];
		a4 += 2;
		if (v4 > 0x7FFF)
		{
			v4 = 0x7FFF;
		}
		else if (v4 < -32768)
		{
			v4 = -32768;
		}
		if (v5 > 0x7FFF)
		{
			LOWORD(v5) = 0x7FFF;
		}
		else if (v5 < -32768)
		{
			LOWORD(v5) = -32768;
		}
		result = v4 ^ 0x8000;
		*a3 = v5 ^ 0x8000;
		*a2 = result;
		++a3;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AF9BE) --------------------------------------------------------
signed int sub_AF9BE(int a1, x_WORD *a2, x_WORD *a3, signed int *a4)
{
	signed int result; // eax
	signed int v5; // edx

	do
	{
		result = *a4;
		v5 = a4[1];
		a4 += 2;
		if (result > 0x7FFF)
		{
			result = 0x7FFF;
		}
		else if (result < -32768)
		{
			result = -32768;
		}
		if (v5 > 0x7FFF)
		{
			LOWORD(v5) = 0x7FFF;
		}
		else if (v5 < -32768)
		{
			LOWORD(v5) = -32768;
		}
		*a3 = v5;
		*a2 = result;
		++a3;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AFA10) --------------------------------------------------------
int sub_AFA10(int a1, x_WORD *a2, x_WORD *a3, signed int *a4)
{
	signed int v4; // eax
	signed int v5; // edx
	__int16 v6; // dx
	int result; // eax
	char v8; // t0
	char v9; // t1

	do
	{
		v4 = *a4;
		v5 = a4[1];
		a4 += 2;
		if (v4 > 0x7FFF)
		{
			v4 = 0x7FFF;
		}
		else if (v4 < -32768)
		{
			v4 = -32768;
		}
		if (v5 > 0x7FFF)
		{
			LOWORD(v5) = 0x7FFF;
		}
		else if (v5 < -32768)
		{
			LOWORD(v5) = -32768;
		}
		result = v4 ^ 0x8000;
		v6 = v5 ^ 0x8000;
		v8 = result;
		LOBYTE(result) = BYTE1(result);
		BYTE1(result) = v8;
		v9 = v6;
		LOBYTE(v6) = HIBYTE(v6);
		HIBYTE(v6) = v9;
		*a3 = result;
		*a2 = v6;
		++a3;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AFA71) --------------------------------------------------------
__int16 sub_AFA71(int a1, x_WORD *a2, x_WORD *a3, signed int *a4)
{
	signed int v4; // eax
	signed int v5; // edx
	__int16 result; // ax
	char v7; // t0
	__int16 v8; // dx
	char v9; // t1

	do
	{
		v4 = *a4;
		v5 = a4[1];
		a4 += 2;
		if (v4 > 0x7FFF)
		{
			LOWORD(v4) = 0x7FFF;
		}
		else if (v4 < -32768)
		{
			LOWORD(v4) = -32768;
		}
		if (v5 > 0x7FFF)
		{
			LOWORD(v5) = 0x7FFF;
		}
		else if (v5 < -32768)
		{
			LOWORD(v5) = -32768;
		}
		v7 = v4;
		LOBYTE(result) = BYTE1(v4);
		HIBYTE(result) = v7;
		v9 = v5;
		LOBYTE(v8) = BYTE1(v5);
		HIBYTE(v8) = v9;
		*a3 = result;
		*a2 = v8;
		++a3;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AFAC7) --------------------------------------------------------
int sub_AFAC7(int a1, x_WORD *a2, x_WORD *a3, signed int *a4)
{
	signed int v4; // eax
	signed int v5; // edx
	__int16 v6; // dx
	int result; // eax
	char v8; // t0
	char v9; // t1

	do
	{
		v4 = *a4;
		v5 = a4[1];
		a4 += 2;
		if (v4 > 0x7FFF)
		{
			v4 = 0x7FFF;
		}
		else if (v4 < -32768)
		{
			v4 = -32768;
		}
		if (v5 > 0x7FFF)
		{
			LOWORD(v5) = 0x7FFF;
		}
		else if (v5 < -32768)
		{
			LOWORD(v5) = -32768;
		}
		result = v4 ^ 0x8000;
		v6 = v5 ^ 0x8000;
		v8 = result;
		LOBYTE(result) = BYTE1(result);
		BYTE1(result) = v8;
		v9 = v6;
		LOBYTE(v6) = HIBYTE(v6);
		HIBYTE(v6) = v9;
		*a3 = v6;
		*a2 = result;
		++a3;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AFB28) --------------------------------------------------------
__int16 sub_AFB28(int a1, x_WORD *a2, x_WORD *a3, signed int *a4)
{
	signed int v4; // eax
	signed int v5; // edx
	__int16 result; // ax
	char v7; // t0
	__int16 v8; // dx
	char v9; // t1

	do
	{
		v4 = *a4;
		v5 = a4[1];
		a4 += 2;
		if (v4 > 0x7FFF)
		{
			LOWORD(v4) = 0x7FFF;
		}
		else if (v4 < -32768)
		{
			LOWORD(v4) = -32768;
		}
		if (v5 > 0x7FFF)
		{
			LOWORD(v5) = 0x7FFF;
		}
		else if (v5 < -32768)
		{
			LOWORD(v5) = -32768;
		}
		v7 = v4;
		LOBYTE(result) = BYTE1(v4);
		HIBYTE(result) = v7;
		v9 = v5;
		LOBYTE(v8) = BYTE1(v5);
		HIBYTE(v8) = v9;
		*a3 = v8;
		*a2 = result;
		++a3;
		++a2;
		--a1;
	} while (a1);
	return result;
}

//----- (000AFB7E) --------------------------------------------------------
int sub_AFB7E(int result, x_DWORD *a2, x_BYTE *a3)
{
	do
	{
		if ((unsigned int)a3 >= x_DWORD_E4E24)
			break;
		BYTE1(result) = *a3;
		result ^= 0x8000u;
		++a3;
		*a2 += (signed __int16)result;
		++a2;
	} while ((unsigned int)a2 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000AFB9F) --------------------------------------------------------
int sub_AFB9F(int result, x_DWORD *a2, x_BYTE *a3)
{
	do
	{
		if ((unsigned int)a3 >= x_DWORD_E4E24)
			break;
		BYTE1(result) = *a3;
		result ^= 0x8000u;
		++a3;
		*a2 += (signed __int16)result;
		a2[1] += (signed __int16)result;
		a2 += 2;
	} while ((unsigned int)a2 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000AFBC3) --------------------------------------------------------
int sub_AFBC3(int result, __int16 a2, x_DWORD *a3, x_BYTE *a4)
{
	do
	{
		if ((unsigned int)a4 >= x_DWORD_E4E24)
			break;
		BYTE1(result) = *a4;
		HIBYTE(a2) = a4[1];
		result ^= 0x8000u;
		a2 ^= 0x8000u;
		a4 += 2;
		*a3 += (signed __int16)result;
		a3[1] += a2;
		a3 += 2;
	} while ((unsigned int)a3 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000AFBF5) --------------------------------------------------------
int sub_AFBF5(int result, __int16 a2, x_DWORD *a3, x_BYTE *a4)
{
	do
	{
		if ((unsigned int)a4 >= x_DWORD_E4E24)
			break;
		HIBYTE(a2) = *a4;
		BYTE1(result) = a4[1];
		result ^= 0x8000u;
		a2 ^= 0x8000u;
		a4 += 2;
		*a3 += (signed __int16)result;
		a3[1] += a2;
		a3 += 2;
	} while ((unsigned int)a3 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000AFC27) --------------------------------------------------------
__int16 sub_AFC27(x_DWORD *a1, x_WORD *a2)
{
	__int16 result; // ax

	do
	{
		if ((unsigned int)a2 >= x_DWORD_E4E24)
			break;
		result = *a2 ^ 0x8000;
		++a2;
		*a1 += result;
		++a1;
	} while ((unsigned int)a1 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000AFC4B) --------------------------------------------------------
__int16 sub_AFC4B(x_DWORD *a1, x_WORD *a2)
{
	__int16 result; // ax

	do
	{
		if ((unsigned int)a2 >= x_DWORD_E4E24)
			break;
		result = *a2 ^ 0x8000;
		++a2;
		*a1 += result;
		a1[1] += result;
		a1 += 2;
	} while ((unsigned int)a1 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000AFC72) --------------------------------------------------------
__int16 sub_AFC72(x_DWORD *a1, x_WORD *a2)
{
	__int16 result; // ax
	__int16 v3; // bx

	do
	{
		if ((unsigned int)a2 >= x_DWORD_E4E24)
			break;
		result = *a2 ^ 0x8000;
		v3 = a2[1] ^ 0x8000;
		a2 += 2;
		*a1 += result;
		a1[1] += v3;
		a1 += 2;
	} while ((unsigned int)a1 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000AFCA6) --------------------------------------------------------
__int16 sub_AFCA6(x_DWORD *a1, x_WORD *a2)
{
	__int16 result; // ax
	__int16 v3; // bx

	do
	{
		if ((unsigned int)a2 >= x_DWORD_E4E24)
			break;
		result = a2[1] ^ 0x8000;
		v3 = *a2 ^ 0x8000;
		a2 += 2;
		*a1 += result;
		a1[1] += v3;
		a1 += 2;
	} while ((unsigned int)a1 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000AFCDA) --------------------------------------------------------
__int16 sub_AFCDA(__int16 result, x_DWORD *a2, x_BYTE *a3)
{
	do
	{
		if ((unsigned int)a3 >= x_DWORD_E4E24)
			break;
		HIBYTE(result) = *a3++;
		*a2 += result;
		++a2;
	} while ((unsigned int)a2 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000AFCF6) --------------------------------------------------------
__int16 sub_AFCF6(__int16 result, x_DWORD *a2, x_BYTE *a3)
{
	do
	{
		if ((unsigned int)a3 >= x_DWORD_E4E24)
			break;
		HIBYTE(result) = *a3++;
		*a2 += result;
		a2[1] += result;
		a2 += 2;
	} while ((unsigned int)a2 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000AFD15) --------------------------------------------------------
__int16 sub_AFD15(__int16 result, __int16 a2, x_DWORD *a3, x_BYTE *a4)
{
	do
	{
		if ((unsigned int)a4 >= x_DWORD_E4E24)
			break;
		HIBYTE(result) = *a4;
		HIBYTE(a2) = a4[1];
		a4 += 2;
		*a3 += result;
		a3[1] += a2;
		a3 += 2;
	} while ((unsigned int)a3 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000AFD3C) --------------------------------------------------------
__int16 sub_AFD3C(__int16 result, __int16 a2, x_DWORD *a3, x_BYTE *a4)
{
	do
	{
		if ((unsigned int)a4 >= x_DWORD_E4E24)
			break;
		HIBYTE(a2) = *a4;
		HIBYTE(result) = a4[1];
		a4 += 2;
		*a3 += result;
		a3[1] += a2;
		a3 += 2;
	} while ((unsigned int)a3 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000AFD63) --------------------------------------------------------
__int16 sub_AFD63(x_DWORD *a1, __int16 *a2)
{
	__int16 result; // ax

	do
	{
		if ((unsigned int)a2 >= x_DWORD_E4E24)
			break;
		result = *a2;
		++a2;
		*a1 += result;
		++a1;
	} while ((unsigned int)a1 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000AFD82) --------------------------------------------------------
__int16 sub_AFD82(x_DWORD *a1, __int16 *a2)
{
	__int16 result; // ax

	do
	{
		if ((unsigned int)a2 >= x_DWORD_E4E24)
			break;
		result = *a2;
		++a2;
		*a1 += result;
		a1[1] += result;
		a1 += 2;
	} while ((unsigned int)a1 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000AFDA4) --------------------------------------------------------
__int16 sub_AFDA4(x_DWORD *a1, __int16 *a2)
{
	__int16 result; // ax
	__int16 v3; // bx

	do
	{
		if ((unsigned int)a2 >= x_DWORD_E4E24)
			break;
		result = *a2;
		v3 = a2[1];
		a2 += 2;
		*a1 += result;
		a1[1] += v3;
		a1 += 2;
	} while ((unsigned int)a1 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000AFDCD) --------------------------------------------------------
__int16 sub_AFDCD(x_DWORD *a1, __int16 *a2)
{
	__int16 v2; // bx
	__int16 result; // ax

	do
	{
		if ((unsigned int)a2 >= x_DWORD_E4E24)
			break;
		v2 = *a2;
		result = a2[1];
		a2 += 2;
		*a1 += result;
		a1[1] += v2;
		a1 += 2;
	} while ((unsigned int)a1 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000AFDF6) --------------------------------------------------------
int sub_AFDF6(int result, unsigned int a2, x_DWORD *a3, x_BYTE *a4)
{
	do
	{
		if ((unsigned int)a4 >= x_DWORD_E4E24)
			break;
		BYTE1(result) = *a4;
		result ^= 0x8000u;
		a4 = (x_BYTE *)((qx_WORD_E4E30 + __PAIR__((unsigned int)a4, a2)) >> 32);
		a2 += qx_WORD_E4E30;
		*a3 += (signed __int16)result;
		++a3;
	} while ((unsigned int)a3 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000AFE22) --------------------------------------------------------
int sub_AFE22(int result, unsigned int a2, x_DWORD *a3, x_BYTE *a4)
{
	do
	{
		if ((unsigned int)a4 >= x_DWORD_E4E24)
			break;
		BYTE1(result) = *a4;
		result ^= 0x8000u;
		a4 = (x_BYTE *)((qx_WORD_E4E30 + __PAIR__((unsigned int)a4, a2)) >> 32);
		a2 += qx_WORD_E4E30;
		*a3 += (signed __int16)result;
		a3[1] += (signed __int16)result;
		a3 += 2;
	} while ((unsigned int)a3 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000AFE51) --------------------------------------------------------
int sub_AFE51(int result, unsigned int a2, __int16 a3, x_DWORD *a4, x_BYTE *a5)
{
	int v5; // ebp

	do
	{
		if ((unsigned int)a5 >= x_DWORD_E4E24)
			break;
		BYTE1(result) = *a5;
		HIBYTE(a3) = a5[1];
		result ^= 0x8000u;
		a3 ^= 0x8000u;
		v5 = ((unsigned int)qx_WORD_E4E30 + (unsigned __int64)a2) >> 32;
		a2 += qx_WORD_E4E30;
		a5 += *((x_DWORD *)&qx_WORD_E4E30 + v5 + 1);
		*a4 += (signed __int16)result;
		a4[1] += a3;
		a4 += 2;
	} while ((unsigned int)a4 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000AFE91) --------------------------------------------------------
int sub_AFE91(int result, unsigned int a2, __int16 a3, x_DWORD *a4, x_BYTE *a5)
{
	int v5; // ebp

	do
	{
		if ((unsigned int)a5 >= x_DWORD_E4E24)
			break;
		HIBYTE(a3) = *a5;
		BYTE1(result) = a5[1];
		result ^= 0x8000u;
		a3 ^= 0x8000u;
		v5 = ((unsigned int)qx_WORD_E4E30 + (unsigned __int64)a2) >> 32;
		a2 += qx_WORD_E4E30;
		a5 += *((x_DWORD *)&qx_WORD_E4E30 + v5 + 1);
		*a4 += (signed __int16)result;
		a4[1] += a3;
		a4 += 2;
	} while ((unsigned int)a4 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000AFED1) --------------------------------------------------------
__int16 sub_AFED1(unsigned int a1, x_DWORD *a2, x_WORD *a3)
{
	__int16 result; // ax
	int v4; // ebp

	do
	{
		if ((unsigned int)a3 >= x_DWORD_E4E24)
			break;
		result = *a3 ^ 0x8000;
		v4 = ((unsigned int)qx_WORD_E4E30 + (unsigned __int64)a1) >> 32;
		a1 += qx_WORD_E4E30;
		a3 = (x_WORD *)((char *)a3 + *((x_DWORD *)&qx_WORD_E4E30 + v4 + 1));
		*a2 += result;
		++a2;
	} while ((unsigned int)a2 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000AFF03) --------------------------------------------------------
__int16 sub_AFF03(unsigned int a1, x_DWORD *a2, x_WORD *a3)
{
	__int16 result; // ax
	int v4; // ebp

	do
	{
		if ((unsigned int)a3 >= x_DWORD_E4E24)
			break;
		result = *a3 ^ 0x8000;
		v4 = ((unsigned int)qx_WORD_E4E30 + (unsigned __int64)a1) >> 32;
		a1 += qx_WORD_E4E30;
		a3 = (x_WORD *)((char *)a3 + *((x_DWORD *)&qx_WORD_E4E30 + v4 + 1));
		*a2 += result;
		a2[1] += result;
		a2 += 2;
	} while ((unsigned int)a2 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000AFF38) --------------------------------------------------------
__int16 sub_AFF38(unsigned int a1, x_DWORD *a2, x_WORD *a3)
{
	__int16 result; // ax
	__int16 v4; // bx
	int v5; // ebp

	do
	{
		if ((unsigned int)a3 >= x_DWORD_E4E24)
			break;
		result = *a3 ^ 0x8000;
		v4 = a3[1] ^ 0x8000;
		v5 = ((unsigned int)qx_WORD_E4E30 + (unsigned __int64)a1) >> 32;
		a1 += qx_WORD_E4E30;
		a3 = (x_WORD *)((char *)a3 + *((x_DWORD *)&qx_WORD_E4E30 + v5 + 1));
		*a2 += result;
		a2[1] += v4;
		a2 += 2;
	} while ((unsigned int)a2 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000AFF7A) --------------------------------------------------------
__int16 sub_AFF7A(unsigned int a1, x_DWORD *a2, x_WORD *a3)
{
	__int16 result; // ax
	__int16 v4; // bx
	int v5; // ebp

	do
	{
		if ((unsigned int)a3 >= x_DWORD_E4E24)
			break;
		result = a3[1] ^ 0x8000;
		v4 = *a3 ^ 0x8000;
		v5 = ((unsigned int)qx_WORD_E4E30 + (unsigned __int64)a1) >> 32;
		a1 += qx_WORD_E4E30;
		a3 = (x_WORD *)((char *)a3 + *((x_DWORD *)&qx_WORD_E4E30 + v5 + 1));
		*a2 += result;
		a2[1] += v4;
		a2 += 2;
	} while ((unsigned int)a2 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000AFFBC) --------------------------------------------------------
__int16 sub_AFFBC(__int16 result, unsigned int a2, x_DWORD *a3, x_BYTE *a4)
{
	do
	{
		if ((unsigned int)a4 >= x_DWORD_E4E24)
			break;
		HIBYTE(result) = *a4;
		a4 = (x_BYTE *)((qx_WORD_E4E30 + __PAIR__((unsigned int)a4, a2)) >> 32);
		a2 += qx_WORD_E4E30;
		*a3 += result;
		++a3;
	} while ((unsigned int)a3 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000AFFE3) --------------------------------------------------------
__int16 sub_AFFE3(__int16 result, unsigned int a2, x_DWORD *a3, x_BYTE *a4)
{
	do
	{
		if ((unsigned int)a4 >= x_DWORD_E4E24)
			break;
		HIBYTE(result) = *a4;
		a4 = (x_BYTE *)((qx_WORD_E4E30 + __PAIR__((unsigned int)a4, a2)) >> 32);
		a2 += qx_WORD_E4E30;
		*a3 += result;
		a3[1] += result;
		a3 += 2;
	} while ((unsigned int)a3 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000B000D) --------------------------------------------------------
__int16 sub_B000D(__int16 result, unsigned int a2, __int16 a3, x_DWORD *a4, x_BYTE *a5)
{
	int v5; // ebp

	do
	{
		if ((unsigned int)a5 >= x_DWORD_E4E24)
			break;
		HIBYTE(result) = *a5;
		HIBYTE(a3) = a5[1];
		v5 = ((unsigned int)qx_WORD_E4E30 + (unsigned __int64)a2) >> 32;
		a2 += qx_WORD_E4E30;
		a5 += *((x_DWORD *)&qx_WORD_E4E30 + v5 + 1);
		*a4 += result;
		a4[1] += a3;
		a4 += 2;
	} while ((unsigned int)a4 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000B0042) --------------------------------------------------------
__int16 sub_B0042(__int16 result, unsigned int a2, __int16 a3, x_DWORD *a4, x_BYTE *a5)
{
	int v5; // ebp

	do
	{
		if ((unsigned int)a5 >= x_DWORD_E4E24)
			break;
		HIBYTE(a3) = *a5;
		HIBYTE(result) = a5[1];
		v5 = ((unsigned int)qx_WORD_E4E30 + (unsigned __int64)a2) >> 32;
		a2 += qx_WORD_E4E30;
		a5 += *((x_DWORD *)&qx_WORD_E4E30 + v5 + 1);
		*a4 += result;
		a4[1] += a3;
		a4 += 2;
	} while ((unsigned int)a4 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000B0077) --------------------------------------------------------
__int16 sub_B0077(unsigned int a1, x_DWORD *a2, __int16 *a3)
{
	__int16 result; // ax
	int v4; // ebp

	do
	{
		if ((unsigned int)a3 >= x_DWORD_E4E24)
			break;
		result = *a3;
		v4 = ((unsigned int)qx_WORD_E4E30 + (unsigned __int64)a1) >> 32;
		a1 += qx_WORD_E4E30;
		a3 = (__int16 *)((char *)a3 + *((x_DWORD *)&qx_WORD_E4E30 + v4 + 1));
		*a2 += result;
		++a2;
	} while ((unsigned int)a2 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000B00A4) --------------------------------------------------------
__int16 sub_B00A4(unsigned int a1, x_DWORD *a2, __int16 *a3)
{
	__int16 result; // ax
	int v4; // ebp

	do
	{
		if ((unsigned int)a3 >= x_DWORD_E4E24)
			break;
		result = *a3;
		v4 = ((unsigned int)qx_WORD_E4E30 + (unsigned __int64)a1) >> 32;
		a1 += qx_WORD_E4E30;
		a3 = (__int16 *)((char *)a3 + *((x_DWORD *)&qx_WORD_E4E30 + v4 + 1));
		*a2 += result;
		a2[1] += result;
		a2 += 2;
	} while ((unsigned int)a2 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000B00D4) --------------------------------------------------------
__int16 sub_B00D4(unsigned int a1, x_DWORD *a2, __int16 *a3)
{
	__int16 result; // ax
	__int16 v4; // bx
	int v5; // ebp

	do
	{
		if ((unsigned int)a3 >= x_DWORD_E4E24)
			break;
		result = *a3;
		v4 = a3[1];
		v5 = ((unsigned int)qx_WORD_E4E30 + (unsigned __int64)a1) >> 32;
		a1 += qx_WORD_E4E30;
		a3 = (__int16 *)((char *)a3 + *((x_DWORD *)&qx_WORD_E4E30 + v5 + 1));
		*a2 += result;
		a2[1] += v4;
		a2 += 2;
	} while ((unsigned int)a2 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000B010B) --------------------------------------------------------
__int16 sub_B010B(unsigned int a1, x_DWORD *a2, __int16 *a3)
{
	__int16 v3; // bx
	__int16 result; // ax
	int v5; // ebp

	do
	{
		if ((unsigned int)a3 >= x_DWORD_E4E24)
			break;
		v3 = *a3;
		result = a3[1];
		v5 = ((unsigned int)qx_WORD_E4E30 + (unsigned __int64)a1) >> 32;
		a1 += qx_WORD_E4E30;
		a3 = (__int16 *)((char *)a3 + *((x_DWORD *)&qx_WORD_E4E30 + v5 + 1));
		*a2 += result;
		a2[1] += v3;
		a2 += 2;
	} while ((unsigned int)a2 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000B0142) --------------------------------------------------------
char sub_B0142(int a1, int a2, x_DWORD *a3, x_BYTE *a4)
{
	do
	{
		if ((unsigned int)a4 >= x_DWORD_E4E24)
			break;
		LOBYTE(a1) = *a4++;
		*a3 += *(x_DWORD *)(a2 + 4 * a1);
		++a3;
	} while ((unsigned int)a3 < x_DWORD_E4E2C);
	return a1;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000B015E) --------------------------------------------------------
char sub_B015E(int a1, int a2, x_DWORD *a3, x_BYTE *a4)
{
	do
	{
		if ((unsigned int)a4 >= x_DWORD_E4E24)
			break;
		LOBYTE(a1) = *a4++;
		*a3 += *(x_DWORD *)(a2 + 4 * a1);
		a3[1] += *(x_DWORD *)(a2 + 4 * a1 + 1024);
		a3 += 2;
	} while ((unsigned int)a3 < x_DWORD_E4E2C);
	return a1;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000B0184) --------------------------------------------------------
char sub_B0184(int a1, int a2, int a3, x_DWORD *a4, x_BYTE *a5)
{
	do
	{
		if ((unsigned int)a5 >= x_DWORD_E4E24)
			break;
		LOBYTE(a1) = *a5;
		LOBYTE(a3) = a5[1];
		a5 += 2;
		*a4 += *(x_DWORD *)(a2 + 4 * a1);
		*a4 += *(x_DWORD *)(a2 + 4 * a3 + 1024);
		++a4;
	} while ((unsigned int)a4 < x_DWORD_E4E2C);
	return a1;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000B01AE) --------------------------------------------------------
char sub_B01AE(int a1, int a2, int a3, x_DWORD *a4, x_BYTE *a5)
{
	do
	{
		if ((unsigned int)a5 >= x_DWORD_E4E24)
			break;
		LOBYTE(a1) = *a5;
		LOBYTE(a3) = a5[1];
		a5 += 2;
		*a4 += *(x_DWORD *)(a2 + 4 * a1);
		a4[1] += *(x_DWORD *)(a2 + 4 * a3 + 1024);
		a4 += 2;
	} while ((unsigned int)a4 < x_DWORD_E4E2C);
	return a1;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000B01D9) --------------------------------------------------------
char sub_B01D9(int a1, int a2, int a3, x_DWORD *a4, x_BYTE *a5)
{
	do
	{
		if ((unsigned int)a5 >= x_DWORD_E4E24)
			break;
		LOBYTE(a3) = *a5;
		LOBYTE(a1) = a5[1];
		a5 += 2;
		*a4 += *(x_DWORD *)(a2 + 4 * a1);
		*a4 += *(x_DWORD *)(a2 + 4 * a3 + 1024);
		++a4;
	} while ((unsigned int)a4 < x_DWORD_E4E2C);
	return a1;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000B0203) --------------------------------------------------------
char sub_B0203(int a1, int a2, int a3, x_DWORD *a4, x_BYTE *a5)
{
	do
	{
		if ((unsigned int)a5 >= x_DWORD_E4E24)
			break;
		LOBYTE(a3) = *a5;
		LOBYTE(a1) = a5[1];
		a5 += 2;
		*a4 += *(x_DWORD *)(a2 + 4 * a1);
		a4[1] += *(x_DWORD *)(a2 + 4 * a3 + 1024);
		a4 += 2;
	} while ((unsigned int)a4 < x_DWORD_E4E2C);
	return a1;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000B022E) --------------------------------------------------------
int sub_B022E(int result, x_DWORD *a2, x_DWORD *a3, x_WORD *a4)
{
	do
	{
		if ((unsigned int)a4 >= x_DWORD_E4E24)
			break;
		LOWORD(result) = *a4;
		result ^= 0x8000u;
		++a4;
		*a3 += *a2 * (signed int)(signed __int16)result >> 7;
		++a3;
	} while ((unsigned int)a3 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000B0258) --------------------------------------------------------
int sub_B0258(int result, x_DWORD *a2, x_DWORD *a3, x_WORD *a4)
{
	do
	{
		if ((unsigned int)a4 >= x_DWORD_E4E24)
			break;
		LOWORD(result) = *a4;
		result ^= 0x8000u;
		++a4;
		*a3 += *a2 * (signed int)(signed __int16)result >> 7;
		a3[1] += a2[256] * (signed int)(signed __int16)result >> 7;
		a3 += 2;
	} while ((unsigned int)a3 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000B0292) --------------------------------------------------------
int sub_B0292(int result, x_DWORD *a2, x_DWORD *a3, x_WORD *a4)
{
	__int16 v4; // bx

	do
	{
		if ((unsigned int)a4 >= x_DWORD_E4E24)
			break;
		LOWORD(result) = *a4;
		result ^= 0x8000u;
		v4 = a4[1] ^ 0x8000;
		a4 += 2;
		*a3 += *a2 * (signed int)(signed __int16)result >> 7;
		*a3 += a2[256] * (signed int)v4 >> 7;
		++a3;
	} while ((unsigned int)a3 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000B02D5) --------------------------------------------------------
int sub_B02D5(int result, x_DWORD *a2, x_DWORD *a3, x_WORD *a4)
{
	__int16 v4; // bx

	do
	{
		if ((unsigned int)a4 >= x_DWORD_E4E24)
			break;
		LOWORD(result) = *a4;
		result ^= 0x8000u;
		v4 = a4[1] ^ 0x8000;
		a4 += 2;
		*a3 += *a2 * (signed int)(signed __int16)result >> 7;
		a3[1] += a2[256] * (signed int)v4 >> 7;
		a3 += 2;
	} while ((unsigned int)a3 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000B0319) --------------------------------------------------------
int sub_B0319(int result, x_DWORD *a2, x_DWORD *a3, x_WORD *a4)
{
	__int16 v4; // bx

	do
	{
		if ((unsigned int)a4 >= x_DWORD_E4E24)
			break;
		LOWORD(result) = a4[1];
		result ^= 0x8000u;
		v4 = *a4 ^ 0x8000;
		a4 += 2;
		*a3 += *a2 * (signed int)(signed __int16)result >> 7;
		*a3 += a2[256] * (signed int)v4 >> 7;
		++a3;
	} while ((unsigned int)a3 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000B035C) --------------------------------------------------------
int sub_B035C(int result, x_DWORD *a2, x_DWORD *a3, x_WORD *a4)
{
	__int16 v4; // bx

	do
	{
		if ((unsigned int)a4 >= x_DWORD_E4E24)
			break;
		LOWORD(result) = a4[1];
		result ^= 0x8000u;
		v4 = *a4 ^ 0x8000;
		a4 += 2;
		*a3 += *a2 * (signed int)(signed __int16)result >> 7;
		a3[1] += a2[256] * (signed int)v4 >> 7;
		a3 += 2;
	} while ((unsigned int)a3 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000B03A0) --------------------------------------------------------
__int16 sub_B03A0(x_DWORD *a1, x_DWORD *a2, __int16 *a3)
{
	__int16 result; // ax

	do
	{
		if ((unsigned int)a3 >= x_DWORD_E4E24)
			break;
		result = *a3;
		++a3;
		*a2 += *a1 * (signed int)result >> 7;
		++a2;
	} while ((unsigned int)a2 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000B03C5) --------------------------------------------------------
__int16 sub_B03C5(x_DWORD *a1, x_DWORD *a2, __int16 *a3)
{
	__int16 result; // ax

	do
	{
		if ((unsigned int)a3 >= x_DWORD_E4E24)
			break;
		result = *a3;
		++a3;
		*a2 += *a1 * (signed int)result >> 7;
		a2[1] += a1[256] * (signed int)result >> 7;
		a2 += 2;
	} while ((unsigned int)a2 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000B03FA) --------------------------------------------------------
__int16 sub_B03FA(x_DWORD *a1, x_DWORD *a2, __int16 *a3)
{
	__int16 result; // ax
	__int16 v4; // bx

	do
	{
		if ((unsigned int)a3 >= x_DWORD_E4E24)
			break;
		result = *a3;
		v4 = a3[1];
		a3 += 2;
		*a2 += *a1 * (signed int)result >> 7;
		*a2 += a1[256] * (signed int)v4 >> 7;
		++a2;
	} while ((unsigned int)a2 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000B0432) --------------------------------------------------------
__int16 sub_B0432(x_DWORD *a1, x_DWORD *a2, __int16 *a3)
{
	__int16 result; // ax
	__int16 v4; // bx

	do
	{
		if ((unsigned int)a3 >= x_DWORD_E4E24)
			break;
		result = *a3;
		v4 = a3[1];
		a3 += 2;
		*a2 += *a1 * (signed int)result >> 7;
		a2[1] += a1[256] * (signed int)v4 >> 7;
		a2 += 2;
	} while ((unsigned int)a2 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000B046B) --------------------------------------------------------
__int16 sub_B046B(x_DWORD *a1, x_DWORD *a2, __int16 *a3)
{
	__int16 v3; // bx
	__int16 result; // ax

	do
	{
		if ((unsigned int)a3 >= x_DWORD_E4E24)
			break;
		v3 = *a3;
		result = a3[1];
		a3 += 2;
		*a2 += *a1 * (signed int)result >> 7;
		*a2 += a1[256] * (signed int)v3 >> 7;
		++a2;
	} while ((unsigned int)a2 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000B04A3) --------------------------------------------------------
__int16 sub_B04A3(x_DWORD *a1, x_DWORD *a2, __int16 *a3)
{
	__int16 v3; // bx
	__int16 result; // ax

	do
	{
		if ((unsigned int)a3 >= x_DWORD_E4E24)
			break;
		v3 = *a3;
		result = a3[1];
		a3 += 2;
		*a2 += *a1 * (signed int)result >> 7;
		a2[1] += a1[256] * (signed int)v3 >> 7;
		a2 += 2;
	} while ((unsigned int)a2 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;

//----- (000B04DC) --------------------------------------------------------
char sub_B04DC(int a1, int a2, unsigned int a3, x_DWORD *a4, x_BYTE *a5)
{
	do
	{
		if ((unsigned int)a5 >= x_DWORD_E4E24)
			break;
		LOBYTE(a1) = *a5;
		a5 = (x_BYTE *)((qx_WORD_E4E30 + __PAIR__((unsigned int)a5, a3)) >> 32);
		a3 += qx_WORD_E4E30;
		*a4 += *(x_DWORD *)(a2 + 4 * a1);
		++a4;
	} while ((unsigned int)a4 < x_DWORD_E4E2C);
	return a1;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000B0503) --------------------------------------------------------
char sub_B0503(int a1, int a2, unsigned int a3, x_DWORD *a4, x_BYTE *a5)
{
	do
	{
		if ((unsigned int)a5 >= x_DWORD_E4E24)
			break;
		LOBYTE(a1) = *a5;
		a5 = (x_BYTE *)((qx_WORD_E4E30 + __PAIR__((unsigned int)a5, a3)) >> 32);
		a3 += qx_WORD_E4E30;
		*a4 += *(x_DWORD *)(a2 + 4 * a1);
		a4[1] += *(x_DWORD *)(a2 + 4 * a1 + 1024);
		a4 += 2;
	} while ((unsigned int)a4 < x_DWORD_E4E2C);
	return a1;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000B0534) --------------------------------------------------------
char sub_B0534(int a1, int a2, unsigned int a3, int a4, x_DWORD *a5, x_BYTE *a6)
{
	int v6; // ebp

	do
	{
		if ((unsigned int)a6 >= x_DWORD_E4E24)
			break;
		LOBYTE(a1) = *a6;
		LOBYTE(a4) = a6[1];
		v6 = ((unsigned int)qx_WORD_E4E30 + (unsigned __int64)a3) >> 32;
		a3 += qx_WORD_E4E30;
		a6 += *((x_DWORD *)&qx_WORD_E4E30 + v6 + 1);
		*a5 += *(x_DWORD *)(a2 + 4 * a1);
		*a5 += *(x_DWORD *)(a2 + 4 * a4 + 1024);
		++a5;
	} while ((unsigned int)a5 < x_DWORD_E4E2C);
	return a1;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000B056C) --------------------------------------------------------
char sub_B056C(int a1, int a2, unsigned int a3, int a4, x_DWORD *a5, x_BYTE *a6)
{
	int v6; // ebp

	do
	{
		if ((unsigned int)a6 >= x_DWORD_E4E24)
			break;
		LOBYTE(a1) = *a6;
		LOBYTE(a4) = a6[1];
		v6 = ((unsigned int)qx_WORD_E4E30 + (unsigned __int64)a3) >> 32;
		a3 += qx_WORD_E4E30;
		a6 += *((x_DWORD *)&qx_WORD_E4E30 + v6 + 1);
		*a5 += *(x_DWORD *)(a2 + 4 * a1);
		a5[1] += *(x_DWORD *)(a2 + 4 * a4 + 1024);
		a5 += 2;
	} while ((unsigned int)a5 < x_DWORD_E4E2C);
	return a1;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000B05A5) --------------------------------------------------------
char sub_B05A5(int a1, int a2, unsigned int a3, int a4, x_DWORD *a5, x_BYTE *a6)
{
	int v6; // ebp

	do
	{
		if ((unsigned int)a6 >= x_DWORD_E4E24)
			break;
		LOBYTE(a4) = *a6;
		LOBYTE(a1) = a6[1];
		v6 = ((unsigned int)qx_WORD_E4E30 + (unsigned __int64)a3) >> 32;
		a3 += qx_WORD_E4E30;
		a6 += *((x_DWORD *)&qx_WORD_E4E30 + v6 + 1);
		*a5 += *(x_DWORD *)(a2 + 4 * a1);
		*a5 += *(x_DWORD *)(a2 + 4 * a4 + 1024);
		++a5;
	} while ((unsigned int)a5 < x_DWORD_E4E2C);
	return a1;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000B05DD) --------------------------------------------------------
char sub_B05DD(int a1, int a2, unsigned int a3, int a4, x_DWORD *a5, x_BYTE *a6)
{
	int v6; // ebp

	do
	{
		if ((unsigned int)a6 >= x_DWORD_E4E24)
			break;
		LOBYTE(a4) = *a6;
		LOBYTE(a1) = a6[1];
		v6 = ((unsigned int)qx_WORD_E4E30 + (unsigned __int64)a3) >> 32;
		a3 += qx_WORD_E4E30;
		a6 += *((x_DWORD *)&qx_WORD_E4E30 + v6 + 1);
		*a5 += *(x_DWORD *)(a2 + 4 * a1);
		a5[1] += *(x_DWORD *)(a2 + 4 * a4 + 1024);
		a5 += 2;
	} while ((unsigned int)a5 < x_DWORD_E4E2C);
	return a1;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000B0616) --------------------------------------------------------
int sub_B0616(int result, x_DWORD *a2, unsigned int a3, x_DWORD *a4, x_WORD *a5)
{
	int v5; // ebp

	do
	{
		if ((unsigned int)a5 >= x_DWORD_E4E24)
			break;
		LOWORD(result) = *a5;
		result ^= 0x8000u;
		v5 = ((unsigned int)qx_WORD_E4E30 + (unsigned __int64)a3) >> 32;
		a3 += qx_WORD_E4E30;
		a5 = (x_WORD *)((char *)a5 + *((x_DWORD *)&qx_WORD_E4E30 + v5 + 1));
		*a4 += *a2 * (signed int)(signed __int16)result >> 7;
		++a4;
	} while ((unsigned int)a4 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000B064E) --------------------------------------------------------
int sub_B064E(int result, x_DWORD *a2, unsigned int a3, x_DWORD *a4, x_WORD *a5)
{
	int v5; // ebp

	do
	{
		if ((unsigned int)a5 >= x_DWORD_E4E24)
			break;
		LOWORD(result) = *a5;
		result ^= 0x8000u;
		v5 = ((unsigned int)qx_WORD_E4E30 + (unsigned __int64)a3) >> 32;
		a3 += qx_WORD_E4E30;
		a5 = (x_WORD *)((char *)a5 + *((x_DWORD *)&qx_WORD_E4E30 + v5 + 1));
		*a4 += *a2 * (signed int)(signed __int16)result >> 7;
		a4[1] += a2[256] * (signed int)(signed __int16)result >> 7;
		a4 += 2;
	} while ((unsigned int)a4 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000B0696) --------------------------------------------------------
int sub_B0696(int result, x_DWORD *a2, unsigned int a3, x_DWORD *a4, x_WORD *a5)
{
	__int16 v5; // bx
	int v6; // ebp

	do
	{
		if ((unsigned int)a5 >= x_DWORD_E4E24)
			break;
		LOWORD(result) = *a5;
		result ^= 0x8000u;
		v5 = a5[1] ^ 0x8000;
		v6 = ((unsigned int)qx_WORD_E4E30 + (unsigned __int64)a3) >> 32;
		a3 += qx_WORD_E4E30;
		a5 = (x_WORD *)((char *)a5 + *((x_DWORD *)&qx_WORD_E4E30 + v6 + 1));
		*a4 += *a2 * (signed int)(signed __int16)result >> 7;
		*a4 += a2[256] * (signed int)v5 >> 7;
		++a4;
	} while ((unsigned int)a4 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000B06E7) --------------------------------------------------------
int sub_B06E7(int result, x_DWORD *a2, unsigned int a3, x_DWORD *a4, x_WORD *a5)
{
	__int16 v5; // bx
	int v6; // ebp

	do
	{
		if ((unsigned int)a5 >= x_DWORD_E4E24)
			break;
		LOWORD(result) = *a5;
		result ^= 0x8000u;
		v5 = a5[1] ^ 0x8000;
		v6 = ((unsigned int)qx_WORD_E4E30 + (unsigned __int64)a3) >> 32;
		a3 += qx_WORD_E4E30;
		a5 = (x_WORD *)((char *)a5 + *((x_DWORD *)&qx_WORD_E4E30 + v6 + 1));
		*a4 += *a2 * (signed int)(signed __int16)result >> 7;
		a4[1] += a2[256] * (signed int)v5 >> 7;
		a4 += 2;
	} while ((unsigned int)a4 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000B0739) --------------------------------------------------------
int sub_B0739(int result, x_DWORD *a2, unsigned int a3, x_DWORD *a4, x_WORD *a5)
{
	__int16 v5; // bx
	int v6; // ebp

	do
	{
		if ((unsigned int)a5 >= x_DWORD_E4E24)
			break;
		LOWORD(result) = a5[1];
		result ^= 0x8000u;
		v5 = *a5 ^ 0x8000;
		v6 = ((unsigned int)qx_WORD_E4E30 + (unsigned __int64)a3) >> 32;
		a3 += qx_WORD_E4E30;
		a5 = (x_WORD *)((char *)a5 + *((x_DWORD *)&qx_WORD_E4E30 + v6 + 1));
		*a4 += *a2 * (signed int)(signed __int16)result >> 7;
		*a4 += a2[256] * (signed int)v5 >> 7;
		++a4;
	} while ((unsigned int)a4 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000B078A) --------------------------------------------------------
int sub_B078A(int result, x_DWORD *a2, unsigned int a3, x_DWORD *a4, x_WORD *a5)
{
	__int16 v5; // bx
	int v6; // ebp

	do
	{
		if ((unsigned int)a5 >= x_DWORD_E4E24)
			break;
		LOWORD(result) = a5[1];
		result ^= 0x8000u;
		v5 = *a5 ^ 0x8000;
		v6 = ((unsigned int)qx_WORD_E4E30 + (unsigned __int64)a3) >> 32;
		a3 += qx_WORD_E4E30;
		a5 = (x_WORD *)((char *)a5 + *((x_DWORD *)&qx_WORD_E4E30 + v6 + 1));
		*a4 += *a2 * (signed int)(signed __int16)result >> 7;
		a4[1] += a2[256] * (signed int)v5 >> 7;
		a4 += 2;
	} while ((unsigned int)a4 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000B07DC) --------------------------------------------------------
__int16 sub_B07DC(x_DWORD *a1, unsigned int a2, x_DWORD *a3, __int16 *a4)
{
	__int16 result; // ax
	int v5; // ebp

	do
	{
		if ((unsigned int)a4 >= x_DWORD_E4E24)
			break;
		result = *a4;
		v5 = ((unsigned int)qx_WORD_E4E30 + (unsigned __int64)a2) >> 32;
		a2 += qx_WORD_E4E30;
		a4 = (__int16 *)((char *)a4 + *((x_DWORD *)&qx_WORD_E4E30 + v5 + 1));
		*a3 += *a1 * (signed int)result >> 7;
		++a3;
	} while ((unsigned int)a3 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000B080F) --------------------------------------------------------
__int16 sub_B080F(x_DWORD *a1, unsigned int a2, x_DWORD *a3, __int16 *a4)
{
	__int16 result; // ax
	int v5; // ebp

	do
	{
		if ((unsigned int)a4 >= x_DWORD_E4E24)
			break;
		result = *a4;
		v5 = ((unsigned int)qx_WORD_E4E30 + (unsigned __int64)a2) >> 32;
		a2 += qx_WORD_E4E30;
		a4 = (__int16 *)((char *)a4 + *((x_DWORD *)&qx_WORD_E4E30 + v5 + 1));
		*a3 += *a1 * (signed int)result >> 7;
		a3[1] += a1[256] * (signed int)result >> 7;
		a3 += 2;
	} while ((unsigned int)a3 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000B0852) --------------------------------------------------------
__int16 sub_B0852(x_DWORD *a1, unsigned int a2, x_DWORD *a3, __int16 *a4)
{
	__int16 result; // ax
	__int16 v5; // bx
	int v6; // ebp

	do
	{
		if ((unsigned int)a4 >= x_DWORD_E4E24)
			break;
		result = *a4;
		v5 = a4[1];
		v6 = ((unsigned int)qx_WORD_E4E30 + (unsigned __int64)a2) >> 32;
		a2 += qx_WORD_E4E30;
		a4 = (__int16 *)((char *)a4 + *((x_DWORD *)&qx_WORD_E4E30 + v6 + 1));
		*a3 += *a1 * (signed int)result >> 7;
		*a3 += a1[256] * (signed int)v5 >> 7;
		++a3;
	} while ((unsigned int)a3 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000B0898) --------------------------------------------------------
__int16 sub_B0898(x_DWORD *a1, unsigned int a2, x_DWORD *a3, __int16 *a4)
{
	__int16 result; // ax
	__int16 v5; // bx
	int v6; // ebp

	do
	{
		if ((unsigned int)a4 >= x_DWORD_E4E24)
			break;
		result = *a4;
		v5 = a4[1];
		v6 = ((unsigned int)qx_WORD_E4E30 + (unsigned __int64)a2) >> 32;
		a2 += qx_WORD_E4E30;
		a4 = (__int16 *)((char *)a4 + *((x_DWORD *)&qx_WORD_E4E30 + v6 + 1));
		*a3 += *a1 * (signed int)result >> 7;
		a3[1] += a1[256] * (signed int)v5 >> 7;
		a3 += 2;
	} while ((unsigned int)a3 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000B08DF) --------------------------------------------------------
__int16 sub_B08DF(x_DWORD *a1, unsigned int a2, x_DWORD *a3, __int16 *a4)
{
	__int16 v4; // bx
	__int16 result; // ax
	int v6; // ebp

	do
	{
		if ((unsigned int)a4 >= x_DWORD_E4E24)
			break;
		v4 = *a4;
		result = a4[1];
		v6 = ((unsigned int)qx_WORD_E4E30 + (unsigned __int64)a2) >> 32;
		a2 += qx_WORD_E4E30;
		a4 = (__int16 *)((char *)a4 + *((x_DWORD *)&qx_WORD_E4E30 + v6 + 1));
		*a3 += *a1 * (signed int)result >> 7;
		*a3 += a1[256] * (signed int)v4 >> 7;
		++a3;
	} while ((unsigned int)a3 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000B0925) --------------------------------------------------------
__int16 sub_B0925(x_DWORD *a1, unsigned int a2, x_DWORD *a3, __int16 *a4)
{
	__int16 v4; // bx
	__int16 result; // ax
	int v6; // ebp

	do
	{
		if ((unsigned int)a4 >= x_DWORD_E4E24)
			break;
		v4 = *a4;
		result = a4[1];
		v6 = ((unsigned int)qx_WORD_E4E30 + (unsigned __int64)a2) >> 32;
		a2 += qx_WORD_E4E30;
		a4 = (__int16 *)((char *)a4 + *((x_DWORD *)&qx_WORD_E4E30 + v6 + 1));
		*a3 += *a1 * (signed int)result >> 7;
		a3[1] += a1[256] * (signed int)v4 >> 7;
		a3 += 2;
	} while ((unsigned int)a3 < x_DWORD_E4E2C);
	return result;
}
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;

//----- (000B096C) --------------------------------------------------------
int sub_B096C(int *a1)
{
	int *v1; // ebp
	int *v2; // ecx
	x_DWORD *v3; // edi
	signed int v4; // eax
	unsigned __int64 v5; // rax
	signed int v6; // eax
	char *v7; // edx
	unsigned int v8; // eax
	int v9; // ebx
	x_DWORD *v10; // edi
	int v11; // ebx
	unsigned int v12; // esi
	int v13; // ebx
	int result; // eax
	int v15; // ebx
	int *v16; // [esp-Ch] [ebp-18h]
	int v17; // [esp-8h] [ebp-14h]
	int v18; // [esp-4h] [ebp-10h]
	int savedregs; // [esp+Ch] [ebp+0h]

	v1 = &savedregs;
	v18 = (unsigned __int16)__DS__;
	v17 = (unsigned __int16)__ES__;
	v2 = a1;
	v3 = (x_DWORD *)*a1;
	v4 = 0;
	if (*(x_DWORD *)(*a1 + 24) == 2 || v3[6] == 3)
		v4 = 1;
	if (a1[13] == 2 || a1[13] == 3)
	{
		v4 |= 2u;
		if (a1[14] & 2)
			v4 |= 4u;
	}
	if (a1[13] == 1 || a1[13] == 3)
		v4 |= 8u;
	if ((!(v4 & 2) || v4 & 1) && a1[16] == 127 && v3[26] == 127 && a1[17] == 64 || (v4 |= 0x40u, v4 & 8))
	{
		if (a1[14] & 1)
			v4 |= 0x10u;
	}
	x_DWORD_E4E1C = v4;
	LODWORD(v5) = 0;
	HIDWORD(v5) = a1[15];
	if (SHIDWORD(v5) <= 0)
		HIDWORD(v5) = 1;
	v6 = v5 / (v3[5] << 16);
	v7 = (char *)(v6 - 0x10000);
	if (v6 <= 0x10000)
		v7 = (char*)0x10000 - v6;
	if ((int)v7 > x_DWORD_181DAC[6])
	{
		LODWORD(qx_WORD_E4E30) = v6 << 16;
		v8 = (unsigned int)v6 >> 16;
		v9 = v8 + 1;
		if (x_DWORD_E4E1C & 2)
		{
			v8 *= 2;
			v9 *= 2;
		}
		if (x_DWORD_E4E1C & 8)
		{
			v8 *= 2;
			v9 *= 2;
		}
		HIDWORD(qx_WORD_E4E30) = v8;
		x_DWORD_E4E38 = v9;
		x_DWORD_E4E1C |= 0x20u;
	}
	x_DWORD_E4E28 = v3[20];
	x_DWORD_E4E2C = v3[19] + x_DWORD_E4E28;
	v10 = (x_DWORD *)x_DWORD_E4E28;
	do
	{
		v11 = v2[10];
		x_DWORD_E4E20 = v2[v11 + 6] + v2[v11 + 2];
		x_DWORD_E4E24 = v2[v11 + 4] + v2[v11 + 2];
		if (v2[530])
		{
			v16 = v2;
			((void(__stdcall *)(int *))v2[530])(v2);
		}
		v12 = x_DWORD_E4E20;
		v16 = v1;
		((void(*)(int, x_DWORD *, x_BYTE *))off_AED40[x_DWORD_E4E1C])(
			0,
			v10,
			(x_BYTE *)x_DWORD_E4E20);
		v1 = v16;
		v2 = (int *)v16[2];
		v13 = v2[10];
		result = v12 - v2[v13 + 2];
		v2[v13 + 6] = result;
		if (v12 < x_DWORD_E4E24)
			break;
		if (v2[531])
		{
			v16 = v2;
			result = ((int(__stdcall *)(int *))v2[531])(v2);
			v2 = v16;
		}
		if (v2[12])
		{
			if (v2[12] == 1)
			{
				v15 = v2[10] ^ 1;
				if (v2[v15 + 8])
				{
					v2[1] = 2;
					if (v2[532])
					{
						v16 = v2;
						result = ((int(__stdcall *)(int *))v2[532])(v2);
					}
					return result;
				}
				if (!v2[v15 + 4] || v2[v15 + 6])
					return result;
				v2[10] = v15;
			}
			else
			{
				--v2[12];
			}
		}
		v2[v2[10] + 6] = 0;
	} while ((unsigned int)v10 < x_DWORD_E4E2C);
	return result;
}
// 10000: using guessed type void /*__noreturn*/ sub_10000();
// AED40: using guessed type int (*off_AED40[2])();
// E4E1C: using guessed type int x_DWORD_E4E1C;
// E4E20: using guessed type int x_DWORD_E4E20;
// E4E24: using guessed type int x_DWORD_E4E24;
// E4E28: using guessed type int x_DWORD_E4E28;
// E4E2C: using guessed type int x_DWORD_E4E2C;
// E4E30: using guessed type __int64 qx_WORD_E4E30;
// E4E38: using guessed type int x_DWORD_E4E38;
// 181DC4: using guessed type int x_DWORD_181DC4;

//----- (000B0B87) --------------------------------------------------------
int sub_B0B87(HDIGDRIVER a1, int a2)
{
	int v2; // eax
	int *v3; // esi
	int v4; // ecx
	Bit8u* v5; // edi
	int v6; // eax

	//fix
	v5 = 0;
	//fix

	v2 = a1->hw_mode_flags_7 & 0xF;
	if (a1->hw_format_6 == 2 || a1->hw_format_6 == 3)
		v2 |= 0x10u;
	if (a1->hw_format_6 == 1 || a1->hw_format_6 == 3)
		v2 |= 0x20u;
	if (a1->n_active_samples_25 > 1u)
		v2 |= 0x40u;
	x_DWORD_E4E1C = v2;
	v3 = (int *)a1->build_buffer_20;
	v4 = a1->samples_per_buffer_18;
	if (a1->hw_mode_flags_7 & 0x20)
	{
		x_DWORD_E4E1C |= 8u;
		v5 = (Bit8u*)(a2 * (a1->half_buffer_size_4 >> 1) + (int)a1->DMA_11_12[0]);//fix
	}
	else
	{
		//v5 = (x_BYTE *)a1[a2 + 11];//fix it!
		v5 = (Bit8u*)a1->DMA_11_12[a2];//fix it

		if (a1->hw_mode_flags_7 & 8)
			v6 = a1->half_buffer_size_4;
	}
	return ((int(*)(int, x_BYTE *, int *))off_AEB40[x_DWORD_E4E1C])(v4, (int8*)v5, v3);
}
// AEB40: using guessed type int (*off_AEB40[2])();
// E4E1C: using guessed type int x_DWORD_E4E1C;

//----- (000B0C1A) --------------------------------------------------------
void sub_B0C1A(HDIGDRIVER a1)
{
	/*Bit8u* v1; // edi
	unsigned int v3; // ST00_4

	v1 = (Bit8u*)a1->build_buffer_20;
	v3 = a1->build_size_19;
	memset(v1, 0, a1->build_size_19 & 3);
	memset(&v1[v3 & 3], 0, 4 * (v3 >> 2));*/
	//fix it
}

//----- (000B0C46) --------------------------------------------------------
void sub_B0C46()
{
	sub_9D590_lock_linear_region((Bit8u*)&x_DWORD_E4E1C, (unsigned int)&x_WORD_E4E3C);
	return sub_9D590_lock_linear_region((Bit8u*)off_AEB40, (unsigned int)sub_B0C46);
}
// AEB40: using guessed type int (*off_AEB40[2])();
// E4E1C: using guessed type int x_DWORD_E4E1C;
// E4E3C: using guessed type __int16 x_WORD_E4E3C;

//----- (000B0CC8) --------------------------------------------------------
char *sub_B0CC8()
{
	void *retaddr; // [esp+0h] [ebp+0h]

	return (char *)&retaddr - x_DWORD_E4C94;
}
// E4C94: using guessed type int x_DWORD_E4C94;

//----- (000B0CD2) --------------------------------------------------------
void sub_B0CD2()
{
	x_WORD_E4E3C = __SS__;
}
// E4E3C: using guessed type __int16 x_WORD_E4E3C;

//----- (000B0D52) --------------------------------------------------------
void sub_B0D52()
{
	JUMPOUT((x_WORD)off_E3B90, (int)sub_B4FA3, (int*)sub_B5000);
	off_E4CBD = (int(/*__fastcall*/ *)(x_DWORD))_sigfpe_handler;
	sub_B4F46();
	off_E3B90 = (int(*)())sub_B4FA3;
	sub_B5000();
}
// 98D8B: using guessed type int _sigfpe_handler();
// E3B90: using guessed type int (*off_E3B90)();
// E4CBD: using guessed type int (/*__fastcall*/ *off_E4CBD)(x_DWORD);

//----- (000B0D80) --------------------------------------------------------
void sub_B0D80()
{
	x_DWORD_E731C = 0x8000;
}
// E731C: using guessed type int x_DWORD_E731C;

//----- (000B1138) --------------------------------------------------------
signed int sub_B1138(signed int *a1, signed int a2)
{
	signed int result; // eax
	signed int v3; // eax
	int v4; // edx
	signed int v5; // eax

	result = (int)calloc(a2, 4);
	*a1 = result;
	if (result)
	{
		result = (int)calloc(a2, 4);
		a1[1] = result;
		if (result)
		{
			a1[2] = a2;
			v3 = 0;
			if (a1[2] > 0)
			{
				v4 = 0;
				do
				{
					*(x_DWORD *)(*a1 + v4) = 0x4000;
					++v3;
					v4 += 4;
				} while (v3 < a1[2]);
			}
			a1[3] = *a1;
			v5 = *a1;
			a1[4] = 4 * (a1[2] - 1) + *a1;
			a1[5] = v5 - 4;
			result = 1;
		}
	}
	return result;
}
// 9B513: using guessed type x_DWORD calloc(x_DWORD, x_DWORD);

//----- (000B11E8) --------------------------------------------------------
int sub_B11E8(x_DWORD *a1, int a2)
{
	x_DWORD *v2; // eax
	x_DWORD *v3; // esi
	int v4; // edx
	x_DWORD *v5; // ecx

	v2 = (x_DWORD *)a1[3];
	v3 = v2;
	a1[3] = (x_DWORD)(v2 + 1);
	*v2 = a2;
	if (*a1 + 4 * a1[2] == a1[3])
		a1[3] = *a1;
	v4 = 0;
	do
	{
		v5 = v2;
		--v2;
		v4 += *v5;
		if (v2 == (x_DWORD *)a1[5])
			v2 = (x_DWORD *)a1[4];
	} while (v2 != v3);
	return v4 / a1[2];
}

//----- (000B12A4) --------------------------------------------------------
int sub_B12A4(int a1)
{
	int v1; // edx
	int v2; // eax
	int v3; // eax
	int v4; // ecx
	unsigned __int64 v5; // rax
	int result; // eax

	if (a1 >= 0)
		v1 = a1;
	else
		v1 = -a1;
	v2 = v1 >> 6;
	if (v1 >> 6 < 256)
	{
		v4 = x_DWORD_E7724[v2];
		v5 = (v1 & 0x3F) * (signed __int64)((char *)off_E7728[v2] - v4);
		v3 = v4 + (HIDWORD(v5) != 0) + (v5 >> 6);
	}
	else
	{
		v3 = x_DWORD_E7B24;
	}
	result = v3 >> 14;
	if (a1 < 0)
		result = -result;
	return result;
}
// E7724: using guessed type int x_DWORD_E7724[];
// E7B24: using guessed type int x_DWORD_E7B24;

//----- (000B1304) --------------------------------------------------------
int sub_B1304(int a1, int a2)
{
	int result; // eax
	unsigned int v3; // edx
	int v4; // ecx
	int v5; // esi

	result = a1;
	if (a1 || a2)
	{
		if (a1 >= 0)
		{
			v4 = a1;
			v3 = 0;
		}
		else
		{
			v3 = 1;
			v4 = -a1;
		}
		if (a2 >= 0)
		{
			v5 = a2;
		}
		else
		{
			LOBYTE(v3) = v3 | 2;
			v5 = -a2;
		}
		if (v4 >= v5)
		{
			switch (v3)
			{
			case 0u:
			case 2u:
				result = 25735 - sub_B12A4(((signed __int64)a2 << 14) / a1);
				break;
			case 1u:
			case 3u:
				result = -25735 - sub_B12A4(((signed __int64)a2 << 14) / a1);
				break;
			default:
				result = 0;
				break;
			}
		}
		else if (v3 < 2)
		{
			result = sub_B12A4(((signed __int64)a1 << 14) / a2);
		}
		else if (v3 <= 2)
		{
			result = sub_B12A4(((signed __int64)a1 << 14) / a2) + 51471;
		}
		else if (v3 == 3)
		{
			result = sub_B12A4(((signed __int64)a1 << 14) / a2) - 51471;
		}
		else
		{
			result = 0;
		}
	}
	return result;
}

//----- (000B1414) --------------------------------------------------------
int sub_B1414(int a1)
{
	int v1; // edx
	int v2; // eax
	int v3; // eax
	int v4; // ecx
	unsigned __int64 v5; // rax
	int result; // eax

	if (a1 >= 0)
		v1 = ((signed __int64)a1 << 14) / 25735;
	else
		v1 = -(signed int)(((signed __int64)a1 << 14) / 25735);
	v2 = v1 >> 6;
	if (v1 >> 6 < 256)
	{
		v4 = x_DWORD_E7320[v2];
		v5 = (v1 & 0x3F) * (signed __int64)(x_DWORD_E7324[v2] - v4);
		v3 = v4 + (HIDWORD(v5) != 0) + (v5 >> 6);
	}
	else
	{
		v3 = x_DWORD_E7720;
	}
	result = v3 >> 14;
	if (a1 < 0)
		result = -result;
	return result;
}
// E7320: using guessed type int x_DWORD_E7320[];
// E7720: using guessed type int x_DWORD_E7720;

//----- (000B148C) --------------------------------------------------------
int sub_B148C(int a1)
{
	signed int v1; // edx
	int v3; // eax

	v1 = a1 % 102943;
	if (a1 % 102943 < 0)
		v1 += 102943;
	if (v1 <= 25735)
		return sub_B1414(v1);
	if (v1 <= 51471)
		return sub_B1414(51471 - v1);
	if (v1 > 77207)
		v3 = sub_B1414(102943 - v1);
	else
		v3 = sub_B1414(v1 - 51471);
	return -v3;
}

//----- (000B14F8) --------------------------------------------------------
int sub_B14F8(int *a1, int a2)
{
	int result; // eax

	*a1 = sub_B148C(a2);
	result = sub_B148C(a2 + 25735);
	a1[1] = result;
	return result;
}

//----- (000B1C58) --------------------------------------------------------
char sub_B1C58(__int16 a1, int a2, __int16 a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, __int16 a16)
{
	int v16; // esi
	__int16 v17; // dx
	__int16 v18; // cx
	char result; // al
	bool i; // zf
	__int16 v21; // ax
	__int16 v22; // bx
	int v23; // ebx
	int v24; // eax
	int v25; // edx
	void *retaddr; // [esp+0h] [ebp+0h]

	//fix it
	v24 = 0;
	v25 = 0;
	//fix it

	v16 = a15;
	v17 = HIWORD(a2);
	v18 = a2;
	result = *MK_FP(a16, a15);
	for (i = *MK_FP(a16, a15) == -101; *MK_FP(a16, v16) <= 0x9Bu; i = *MK_FP(a16, v16) == -101)
	{
		if (!i)
		{
			switch (result)
			{
			case 38:
				v18 = a3;
				v17 = a3;
				++v16;
				goto LABEL_6;
			case 46:
				v18 = a16;
				v17 = a16;
				++v16;
				goto LABEL_6;
			case 54:
				v18 = HIWORD(a2);
				v17 = HIWORD(a2);
				++v16;
				goto LABEL_6;
			case 62:
				v18 = a2;
				v17 = a2;
				++v16;
				goto LABEL_6;
			case 100:
				v18 = __FS__;
				v17 = __FS__;
				++v16;
				goto LABEL_6;
			case 101:
				v18 = __GS__;
				v17 = __GS__;
				++v16;
				goto LABEL_6;
			}
			if (result != 102 && result != 103)
				break;
		}
		++v16;
	LABEL_6:
		result = *MK_FP(a16, v16);
	}
	LOBYTE(a1) = result & 0xF8;
	if ((result & 0xF8) == -40)
	{
		HIBYTE(v21) = *MK_FP(a16, v16 + 1);
		LOBYTE(v21) = result & 7;
		if (HIBYTE(v21) < 0xC0u)
		{
			LOBYTE(v22) = *MK_FP(a16, v16 + 1);
			HIBYTE(v22) = HIBYTE(v21) >> 3;
			v23 = v22 & 0x1807;
			LOWORD(v23) = (unsigned __int8)(BYTE1(v23) | v23);
			((void(*)(int))off_B1904[v23])((int)&retaddr);
			((void(/*__fastcall*/ *)(int, int, int))_GETDS)(v24, v25, (unsigned __int8)v24 | BYTE1(v24) & 0x38);
		}
		((void(/*__fastcall*/ *)(__int16, __int16, __int16, __int16))_GETDS)(v21, v17, a1, v18);
	}
	return result;
}
// B1904: using guessed type int (*off_B1904[57])();

//----- (000B1D8C) --------------------------------------------------------
char sub_B1D8C(int a1, int a2, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
	x_DWORD *v17; // ebx
	signed int v18; // edx
	int v19; // eax
	unsigned __int8 v20; // cf
	int v21; // eax

	v17 = (x_DWORD *)(a2 + a1 + 28);
	v18 = -256;
	v19 = *(x_DWORD *)(a2 + a1 + 32);
	v20 = __CFSHL__(v19, 25);
	v21 = v19 << 25;
	if (v20)
	{
		if (!v21 && !*v17)
			v18 = -512;
		v20 = __CFADD__(*(x_DWORD *)(a2 + a1 + 32), 256);
		*(x_DWORD *)(a2 + a1 + 32) += 256;
		if (v20)
		{
			*(x_DWORD *)(a2 + a1 + 32) = 2147483648;
			++*(x_WORD *)(a2 + a1 + 36);
		}
	}
	*(x_DWORD *)(a2 + a1 + 32) &= v18;
	*v17 = 0;
	return sub_B1C58((__int16)v17, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}

//----- (000B1E11) --------------------------------------------------------
char sub_B1E11(int a1, int a2, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
	__int16 v17; // bx

	*(x_WORD *)(a1 + 8) &= *(x_WORD *)((char *)&x_DWORD_B1860[17] + a2 + 2);
	*(x_WORD *)(a1 + 8) |= *(x_WORD *)((char *)&x_DWORD_B1860[19] + a2 + 2);
	v17 = *(x_WORD *)((char *)x_DWORD_B1858 + *(unsigned __int16 *)((char *)&off_B1854 + a2 + 2) + 2);
	*(x_WORD *)(a1 + 4) &= 0xC7FFu;
	*(x_WORD *)(a1 + 4) |= v17;
	return sub_B1C58(v17, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int x_DWORD_B1858[2];
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B1E68) --------------------------------------------------------
int sub_B1E68(int result, int a2, x_BYTE *a3)
{
	int v3; // [esp-80h] [ebp-80h]
	int v4; // [esp-14h] [ebp-14h]
	int v5; // [esp-10h] [ebp-10h]
	int v6; // [esp-Ch] [ebp-Ch]

	a3[4] |= result;
	if (!((unsigned __int8)result & *a3))
	{
		v6 = a2;
		v5 = (unsigned __int16)__ES__;
		v4 = (unsigned __int16)__DS__;
		qmemcpy(&v3, a3, 0x6Cu);
		result = off_E4CBD(BYTE1(result));
		qmemcpy(a3, &v3, 0x6Cu);
	}
	return result;
}
// E4CBD: using guessed type int (/*__fastcall*/ *off_E4CBD)(x_DWORD);

//----- (000B1EB6) --------------------------------------------------------
void sub_B1EB6(int a1)
{
	int v1; // ebx

	v1 = *(x_DWORD *)(a1 + 40);
}

//----- (000B1EBC) --------------------------------------------------------
void sub_B1EBC(int a1)
{
	int v1; // ebx

	v1 = *(x_DWORD *)(a1 + 36);
}

//----- (000B1EC2) --------------------------------------------------------
void sub_B1EC2(int a1)
{
	int v1; // ebx

	v1 = *(x_DWORD *)(a1 + 32);
}

//----- (000B1EC8) --------------------------------------------------------
void sub_B1EC8(int a1)
{
	int v1; // ebx

	v1 = *(x_DWORD *)(a1 + 28);
}

//----- (000B1ECE) --------------------------------------------------------
void sub_B1ECE(int a1)
{
	int v1; // ebx

	v1 = *(x_DWORD *)(a1 + 24);
}

//----- (000B1ED6) --------------------------------------------------------
void sub_B1ED6(int *a1)
{
	int v1; // ebx

	v1 = *a1;
}

//----- (000B1EDC) --------------------------------------------------------
void sub_B1EDC(int a1)
{
	int v1; // ebx

	v1 = *(x_DWORD *)(a1 + 16);
}

//----- (000B1EE2) --------------------------------------------------------
void sub_B1EE2(int a1)
{
	int v1; // ebx

	v1 = *(x_DWORD *)(a1 + 12);
}

//----- (000B1EE8) --------------------------------------------------------
void sub_B1EE8(int a1, char *a2)
{
	int v2; // ebx

	v2 = *(x_DWORD *)(a1 + 40) + *a2;
}

//----- (000B1EF0) --------------------------------------------------------
void sub_B1EF0(int a1, char *a2)
{
	int v2; // ebx

	v2 = *(x_DWORD *)(a1 + 36) + *a2;
}

//----- (000B1EF8) --------------------------------------------------------
void sub_B1EF8(int a1, char *a2)
{
	int v2; // ebx

	v2 = *(x_DWORD *)(a1 + 32) + *a2;
}

//----- (000B1F00) --------------------------------------------------------
void sub_B1F00(int a1, char *a2)
{
	int v2; // ebx

	v2 = *(x_DWORD *)(a1 + 28) + *a2;
}

//----- (000B1F08) --------------------------------------------------------
void sub_B1F08(int a1, char *a2)
{
	int v2; // ebx

	v2 = *(x_DWORD *)(a1 + 24) + *a2;
}

//----- (000B1F12) --------------------------------------------------------
void sub_B1F12(int a1, char *a2)
{
	int v2; // ebx

	v2 = *(x_DWORD *)(a1 + 20) + *a2;
}

//----- (000B1F1C) --------------------------------------------------------
void sub_B1F1C(int a1, char *a2)
{
	int v2; // ebx

	v2 = *(x_DWORD *)(a1 + 16) + *a2;
}

//----- (000B1F24) --------------------------------------------------------
void sub_B1F24(int a1, char *a2)
{
	int v2; // ebx

	v2 = *(x_DWORD *)(a1 + 12) + *a2;
}

//----- (000B1F2C) --------------------------------------------------------
void sub_B1F2C(int a1, x_DWORD *a2)
{
	int v2; // ebx

	v2 = *(x_DWORD *)(a1 + 40) + *a2;
}

//----- (000B1F35) --------------------------------------------------------
void sub_B1F35(int a1, x_DWORD *a2)
{
	int v2; // ebx

	v2 = *(x_DWORD *)(a1 + 36) + *a2;
}

//----- (000B1F3E) --------------------------------------------------------
void sub_B1F3E(int a1, x_DWORD *a2)
{
	int v2; // ebx

	v2 = *(x_DWORD *)(a1 + 32) + *a2;
}

//----- (000B1F47) --------------------------------------------------------
void sub_B1F47(int a1, x_DWORD *a2)
{
	int v2; // ebx

	v2 = *(x_DWORD *)(a1 + 28) + *a2;
}

//----- (000B1F50) --------------------------------------------------------
void sub_B1F50(int a1, x_DWORD *a2)
{
	int v2; // ebx

	v2 = *(x_DWORD *)(a1 + 24) + *a2;
}

//----- (000B1F5B) --------------------------------------------------------
void sub_B1F5B(int a1, x_DWORD *a2)
{
	int v2; // ebx

	v2 = *(x_DWORD *)(a1 + 20) + *a2;
}

//----- (000B1F66) --------------------------------------------------------
void sub_B1F66(int a1, x_DWORD *a2)
{
	int v2; // ebx

	v2 = *(x_DWORD *)(a1 + 16) + *a2;
}

//----- (000B1F6F) --------------------------------------------------------
void sub_B1F6F(int a1, x_DWORD *a2)
{
	int v2; // ebx

	v2 = *(x_DWORD *)(a1 + 12) + *a2;
}

//----- (000B1F78) --------------------------------------------------------
int sub_B1F78(unsigned __int8 a1, unsigned int a2, int a3, x_BYTE *a4)
{
	int result; // eax
	unsigned int v5; // edx
	int v6; // ebx
	unsigned int v7; // [esp-4h] [ebp-4h]

	//fix it
	result = 0;
	//fix it

	LOBYTE(a2) = *a4;
	v7 = a2;
	LOWORD(a2) = (a1 >> 3) & 0x18 | *a4 & 7;
	((void(*)(int))off_B1964[a2])(a3);
	v5 = v7;
	if ((v7 & 0x38) != 32)
	{
		LOBYTE(v5) = v7 & 0x38;
		v6 = (*(x_DWORD *)(a3 - (v5 >> 1) + 40) << ((unsigned __int8)v7 >> 6)) + a2;
	}
	return result;
}
// B1964: using guessed type int (*off_B1964[33])();

//----- (000B1FB5) --------------------------------------------------------
int sub_B1FB5(int a1, int a2, signed int *a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v4 = 0;
	//fix it

	sub_B3BA6(*a3, a1 + 108);
	v3 = sub_B337C(a2 + a1 + 28, a1 + 108, (int)a3);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B1FD4) --------------------------------------------------------
int sub_B1FD4(int a1, int a2, signed int *a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v4 = 0;
	//fix it

	sub_B3BA6(*a3, a1 + 108);
	v3 = sub_B37B0(a2 + a1 + 28, a1 + 108, (int)a3);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B1FF3) --------------------------------------------------------
char sub_B1FF3(int a1, int a2, signed int *a3, __int16 bx0, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
	__int16 v19; // dx
	int v21; // eax

	sub_B3BA6(*a3, a1 + 108);
	v21 = sub_B3542(a2 + a1 + 28, a1 + 108);
	v19 = *(x_WORD *)(a1 + 4) & 0xB8FF;
	HIBYTE(v19) |= *((x_BYTE *)&x_DWORD_B1860[37] + v21 + 3);
	*(x_WORD *)(a1 + 4) = v19;
	return sub_B1C58(bx0, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B200F) --------------------------------------------------------
char sub_B200F(int a1, int a2, signed int *a3, int _4, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
	__int16 v18; // dx
	int v20; // eax

	sub_B3BA6(*a3, a1 + 108);
	v20 = sub_B3542(a2 + a1 + 28, a1 + 108);
	v18 = *(x_WORD *)(a1 + 4) & 0xB8FF;
	HIBYTE(v18) |= *((x_BYTE *)&x_DWORD_B1860[37] + v20 + 3);
	*(x_WORD *)(a1 + 4) = v18;
	return sub_B1E11(a1, a2, _4, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B202B) --------------------------------------------------------
int sub_B202B(int a1, int a2, signed int *a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v3 = 0;
	v4 = 0;
	//fix it

	sub_B3BA6(*a3, a1 + 108);
	sub_B336E(a2 + a1 + 28, a1 + 108);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B204A) --------------------------------------------------------
int sub_B204A(int a1, int a2, signed int *a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v3 = 0;
	v4 = 0;
	//fix it

	sub_B3BA6(*a3, a1 + 108);
	sub_B336E(a1 + 108, a2 + a1 + 28);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B2069) --------------------------------------------------------
int sub_B2069(int a1, int a2, signed int *a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v4 = 0;
	//fix it

	sub_B3BA6(*a3, a1 + 108);
	v3 = sub_B35DB(a2 + a1 + 28, a1 + 108, (x_BYTE *)a1, (int)a3);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B2088) --------------------------------------------------------
int sub_B2088(int a1, int a2, signed int *a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v4 = 0;
	//fix it

	sub_B3BA6(*a3, a1 + 108);
	v3 = sub_B35DB(a1 + 108, a2 + a1 + 28, (x_BYTE *)a1, (int)a3);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B20A7) --------------------------------------------------------
char sub_B20A7(int a1, int a2, signed int *a3, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
	int v18; // edi
	__int16 v19; // bx
	__int16 v20; // bx

	v18 = *(unsigned __int16 *)((char *)x_DWORD_B1858 + a2);
	v19 = *(x_WORD *)((char *)x_DWORD_B1858 + v18 + 2);
	*(x_WORD *)(a1 + 4) &= 0xC7FFu;
	*(x_WORD *)(a1 + 4) |= v19;
	v20 = *(x_WORD *)((char *)&x_DWORD_B1860[17] + v18 + 2);
	*(x_WORD *)(a1 + 8) &= v20;
	sub_B3BA6(*a3, v18 + a1 + 28);
	return sub_B1C58(v20, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// B1858: using guessed type int x_DWORD_B1858[2];
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B20E1) --------------------------------------------------------
char sub_B20E1(int a1, int a2, int *a3, __int16 bx0, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
	*a3 = sub_B3A60(a2 + a1 + 28);
	return sub_B1C58(bx0, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}

//----- (000B20F2) --------------------------------------------------------
char sub_B20F2(int a1, int a2, int *esi0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
	*esi0 = sub_B3A60(a2 + a1 + 28);
	return sub_B1E11(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}

//----- (000B2103) --------------------------------------------------------
char sub_B2103(void *a1, const void *a2, __int16 bx0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
	qmemcpy(a1, (void*)a2, 0x1Cu);
	return sub_B1C58(bx0, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}

//----- (000B2121) --------------------------------------------------------
char sub_B2121(int a1, __int16 *a2, __int16 bx0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
	__int16 v18; // ax
	__int16 v19; // ax

	v18 = *a2;
	*(x_WORD *)a1 = *a2;
	v19 = v18 & 0x300;
	if (v19 == 768)
	{
		*(x_DWORD *)(a1 + 118) = (x_DWORD)sub_B1C58;
	}
	else if (v19 == 512)
	{
		*(x_DWORD *)(a1 + 118) = (x_DWORD)sub_B1DC8;
	}
	else
	{
		*(x_DWORD *)(a1 + 118) = (x_DWORD)sub_B1D8C;
	}
	return sub_B1C58(bx0, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// B1DC8: using guessed type int sub_B1DC8();

//----- (000B2161) --------------------------------------------------------
char sub_B2161(const void *a1, void *a2, __int16 di0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
	qmemcpy(a2, (void*)a1, 0x1Cu);
	return sub_B1C58(di0, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}

//----- (000B2175) --------------------------------------------------------
char sub_B2175(x_WORD *a1, x_WORD *a2, __int16 bx0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
	*a2 = *a1;
	return sub_B1C58(bx0, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}

//----- (000B2183) --------------------------------------------------------
int sub_B2183(int a1, int a2, int *a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v4 = 0;
	//fix it

	sub_B399A(*a3, a1 + 108);
	v3 = sub_B337C(a2 + a1 + 28, a1 + 108, (int)a3);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B21A2) --------------------------------------------------------
int sub_B21A2(int a1, int a2, int *a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v4 = 0;
	//fix it

	sub_B399A(*a3, a1 + 108);
	v3 = sub_B37B0(a2 + a1 + 28, a1 + 108, (int)a3);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B21C1) --------------------------------------------------------
char sub_B21C1(int a1, int a2, int *a3, __int16 bx0, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
	__int16 v19; // dx
	int v21; // eax

	sub_B399A(*a3, a1 + 108);
	v21 = sub_B3542(a2 + a1 + 28, a1 + 108);
	v19 = *(x_WORD *)(a1 + 4) & 0xB8FF;
	HIBYTE(v19) |= *((x_BYTE *)&x_DWORD_B1860[37] + v21 + 3);
	*(x_WORD *)(a1 + 4) = v19;
	return sub_B1C58(bx0, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B21DD) --------------------------------------------------------
char sub_B21DD(int a1, int a2, int *esi0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
	__int16 v18; // dx
	int v20; // eax

	sub_B399A(*esi0, a1 + 108);
	v20 = sub_B3542(a2 + a1 + 28, a1 + 108);
	v18 = *(x_WORD *)(a1 + 4) & 0xB8FF;
	HIBYTE(v18) |= *((x_BYTE *)&x_DWORD_B1860[37] + v20 + 3);
	*(x_WORD *)(a1 + 4) = v18;
	return sub_B1E11(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B21F9) --------------------------------------------------------
int sub_B21F9(int a1, int a2, int *a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v3 = 0;
	v4 = 0;
	//fix it

	sub_B399A(*a3, a1 + 108);
	sub_B336E(a2 + a1 + 28, a1 + 108);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B2218) --------------------------------------------------------
int sub_B2218(int a1, int a2, int *a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v3 = 0;
	v4 = 0;
	//fix it

	sub_B399A(*a3, a1 + 108);
	sub_B336E(a1 + 108, a2 + a1 + 28);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B2237) --------------------------------------------------------
int sub_B2237(int a1, int a2, int *a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v4 = 0;
	//fix it

	sub_B399A(*a3, a1 + 108);
	v3 = sub_B35DB(a2 + a1 + 28, a1 + 108, (x_BYTE *)a1, (int)a3);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B2256) --------------------------------------------------------
int sub_B2256(int a1, int a2, int *a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v4 = 0;
	//fix it

	sub_B399A(*a3, a1 + 108);
	v3 = sub_B35DB(a1 + 108, a2 + a1 + 28, (x_BYTE *)a1, (int)a3);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B2275) --------------------------------------------------------
char sub_B2275(int a1, int a2, int *a3, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
	int v18; // edi
	__int16 v19; // bx
	__int16 v20; // bx

	v18 = *(unsigned __int16 *)((char *)x_DWORD_B1858 + a2);
	v19 = *(x_WORD *)((char *)x_DWORD_B1858 + v18 + 2);
	*(x_WORD *)(a1 + 4) &= 0xC7FFu;
	*(x_WORD *)(a1 + 4) |= v19;
	v20 = *(x_WORD *)((char *)&x_DWORD_B1860[17] + v18 + 2);
	*(x_WORD *)(a1 + 8) &= v20;
	sub_B399A(*a3, v18 + a1 + 28);
	return sub_B1C58(v20, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// B1858: using guessed type int x_DWORD_B1858[2];
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B22AF) --------------------------------------------------------
char sub_B22AF(x_WORD *a1, int a2, x_DWORD *a3, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
	int v18; // ST08_4
	int v19; // ST04_4
	int v20; // ST00_4
	int v21; // eax
	x_DWORD *v22; // ebx

	//fix it
	v21 = 0;
	//fix it

	v18 = *(x_DWORD *)((char *)a1 + a2 + 28);
	v19 = *(x_DWORD *)((char *)a1 + a2 + 32);
	v20 = *(x_DWORD *)((char *)a1 + a2 + 34);
	sub_B3C6B((unsigned int)a1 + a2 + 28, *a1 & 0xC00);
	sub_B392B();
	*a3 = v21;
	v22 = (x_DWORD *)((char *)a1 + a2 + 28);
	*(x_DWORD *)((char *)v22 + 6) = v20;
	v22[1] = v19;
	*v22 = v18;
	return sub_B1C58((__int16)v22, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}

//----- (000B22EB) --------------------------------------------------------
char sub_B22EB(int a1, int a2, x_DWORD *esi0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
	int v18; // eax

	//fix it
	v18 = 0;
	//fix it

	sub_B3C6B(a2 + a1 + 28, *(x_WORD *)a1 & 0xC00);
	sub_B392B();
	*esi0 = v18;
	return sub_B1E11(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}

//----- (000B230F) --------------------------------------------------------
int sub_B230F(int a1, int a2, __int64 *a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v4 = 0;
	//fix it

	sub_B39E0(*a3, a1 + 108, (x_BYTE *)a1);
	v3 = sub_B337C(a2 + a1 + 28, a1 + 108, (int)a3);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B2332) --------------------------------------------------------
int sub_B2332(int a1, int a2, __int64 *a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v4 = 0;
	//fix it

	sub_B39E0(*a3, a1 + 108, (x_BYTE *)a1);
	v3 = sub_B37B0(a2 + a1 + 28, a1 + 108, (int)a3);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B2355) --------------------------------------------------------
char sub_B2355(int a1, int a2, __int64 *a3, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
	__int16 v18; // dx
	int v20; // eax

	sub_B39E0(*a3, a1 + 108, (x_BYTE *)a1);
	v20 = sub_B3542(a2 + a1 + 28, a1 + 108);
	v18 = *(x_WORD *)(a1 + 4) & 0xB8FF;
	HIBYTE(v18) |= *((x_BYTE *)&x_DWORD_B1860[37] + v20 + 3);
	*(x_WORD *)(a1 + 4) = v18;
	return sub_B1C58(a1 + 108, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B2375) --------------------------------------------------------
char sub_B2375(int a1, int a2, __int64 *esi0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
	__int16 v18; // dx
	int v20; // eax

	sub_B39E0(*esi0, a1 + 108, (x_BYTE *)a1);
	v20 = sub_B3542(a2 + a1 + 28, a1 + 108);
	v18 = *(x_WORD *)(a1 + 4) & 0xB8FF;
	HIBYTE(v18) |= *((x_BYTE *)&x_DWORD_B1860[37] + v20 + 3);
	*(x_WORD *)(a1 + 4) = v18;
	return sub_B1E11(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B2395) --------------------------------------------------------
int sub_B2395(int a1, int a2, __int64 *a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v3 = 0;
	v4 = 0;
	//fix it

	sub_B39E0(*a3, a1 + 108, (x_BYTE *)a1);
	sub_B336E(a2 + a1 + 28, a1 + 108);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B23B8) --------------------------------------------------------
int sub_B23B8(int a1, int a2, __int64 *a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v3 = 0;
	v4 = 0;
	//fix it

	sub_B39E0(*a3, a1 + 108, (x_BYTE *)a1);
	sub_B336E(a1 + 108, a2 + a1 + 28);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B23DB) --------------------------------------------------------
int sub_B23DB(int a1, int a2, __int64 *a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v4 = 0;
	//fix it

	sub_B39E0(*a3, a1 + 108, (x_BYTE *)a1);
	v3 = sub_B35DB(a2 + a1 + 28, a1 + 108, (x_BYTE *)a1, (int)a3);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B23FE) --------------------------------------------------------
int sub_B23FE(int a1, int a2, __int64 *a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v4 = 0;
	//fix it

	sub_B39E0(*a3, a1 + 108, (x_BYTE *)a1);
	v3 = sub_B35DB(a1 + 108, a2 + a1 + 28, (x_BYTE *)a1, (int)a3);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B2421) --------------------------------------------------------
char sub_B2421(int a1, int a2, int a3, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
	int v18; // edi
	__int16 v19; // bx
	__int16 v20; // bx

	v18 = *(unsigned __int16 *)((char *)x_DWORD_B1858 + a2);
	v19 = *(x_WORD *)((char *)x_DWORD_B1858 + v18 + 2);
	*(x_WORD *)(a1 + 4) &= 0xC7FFu;
	*(x_WORD *)(a1 + 4) |= v19;
	v20 = *(x_WORD *)((char *)&x_DWORD_B1860[17] + v18 + 2);
	*(x_WORD *)(a1 + 8) &= v20;
	*(x_DWORD *)(v18 + a1 + 28) = *(x_DWORD *)a3;
	*(x_DWORD *)(v18 + a1 + 32) = *(x_DWORD *)(a3 + 4);
	*(x_WORD *)(v18 + a1 + 36) = *(x_WORD *)(a3 + 8);
	return sub_B1C58(v20, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// B1858: using guessed type int x_DWORD_B1858[2];
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B2468) --------------------------------------------------------
char sub_B2468(int a1, int a2, __int64 *a3, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
	int v18; // edi
	__int16 v19; // bx
	int v20; // ebx

	v18 = *(unsigned __int16 *)((char *)x_DWORD_B1858 + a2);
	v19 = *(x_WORD *)((char *)x_DWORD_B1858 + v18 + 2);
	*(x_WORD *)(a1 + 4) &= 0xC7FFu;
	*(x_WORD *)(a1 + 4) |= v19;
	*(x_WORD *)(a1 + 8) &= *(x_WORD *)((char *)&x_DWORD_B1860[17] + v18 + 2);
	v20 = v18 + a1 + 28;
	sub_B39E0(*a3, v20, (x_BYTE *)a1);
	return sub_B1C58(v20, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// B1858: using guessed type int x_DWORD_B1858[2];
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B24A6) --------------------------------------------------------
char sub_B24A6(x_BYTE *a1, int a2, int *a3, __int16 bx0, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
	int v19; // edx

	//fix it
	v19 = 0;
	//fix it

	*a3 = sub_B3ADF((__int64 *)&a1[a2 + 28], a1);
	a3[1] = v19;
	return sub_B1C58(bx0, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}

//----- (000B24BB) --------------------------------------------------------
char sub_B24BB(int a1, int a2, int esi0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
	*(x_DWORD *)esi0 = *(x_DWORD *)(a2 + a1 + 28);
	*(x_DWORD *)(esi0 + 4) = *(x_DWORD *)(a2 + a1 + 32);
	*(x_WORD *)(esi0 + 8) = *(x_WORD *)(a2 + a1 + 36);
	return sub_B1E11(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}

//----- (000B24D9) --------------------------------------------------------
char sub_B24D9(int a1, int a2, int *esi0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
	int v18; // edx

	//fix it
	v18 = 0;
	//fix it

	*esi0 = sub_B3ADF((__int64 *)(a2 + a1 + 28), (x_BYTE *)a1);
	esi0[1] = v18;
	return sub_B1E11(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}

//----- (000B24EE) --------------------------------------------------------
char sub_B24EE(x_DWORD *a1, x_DWORD *a2, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
	x_DWORD *v17; // esi
	unsigned int v18; // ebx
	signed int v19; // ecx
	x_DWORD *v20; // esi

	qmemcpy(a1, (void*)a2, 0x1Cu);
	v17 = a2 + 7;
	v18 = 10 * ((a1[1] & 0x3800u) >> 11);
	v19 = 8;
	do
	{
		*(x_DWORD *)((char *)a1 + v18 + 28) = *v17;
		v20 = v17 + 1;
		*(x_DWORD *)((char *)a1 + v18 + 32) = *v20;
		++v20;
		*(x_WORD *)((char *)a1 + v18 + 36) = *(x_WORD *)v20;
		v17 = (x_DWORD *)((char *)v20 + 2);
		v18 = *(unsigned __int16 *)((char *)&off_B1854 + v18 + 2);
		--v19;
	} while (v19);
	return sub_B1C58(v18, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// B1854: using guessed type void *off_B1854;

//----- (000B2535) --------------------------------------------------------
void sub_B2535(char *a1, int a2, x_DWORD *a3)
{
	int v3; // ebx
	x_DWORD *v4; // edi
	signed int v5; // ecx
	x_DWORD *v6; // edi

	v3 = a2;
	qmemcpy(a3, a1, 0x1Cu);
	v4 = a3 + 7;
	v5 = 8;
	do
	{
		*v4 = *(x_DWORD *)&a1[v3 + 28];
		v6 = v4 + 1;
		*v6 = *(x_DWORD *)&a1[v3 + 32];
		++v6;
		*(x_WORD *)v6 = *(x_WORD *)&a1[v3 + 36];
		v4 = (x_DWORD *)((char *)v6 + 2);
		v3 = *(unsigned __int16 *)((char *)&off_B1854 + v3 + 2);
		--v5;
	} while (v5);
	JUMPOUT((int*)&loc_B2E4B);
}
// B1854: using guessed type void *off_B1854;

//----- (000B2560) --------------------------------------------------------
char sub_B2560(int a1, x_WORD *a2, __int16 bx0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
	*a2 = *(x_WORD *)(a1 + 4);
	return sub_B1C58(bx0, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}

//----- (000B256E) --------------------------------------------------------
int sub_B256E(int a1, int a2, signed __int16 *a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v4 = 0;
	//fix it

	sub_B399A(*a3, a1 + 108);
	v3 = sub_B337C(a2 + a1 + 28, a1 + 108, (int)a3);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B258F) --------------------------------------------------------
int sub_B258F(int a1, int a2, signed __int16 *a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v4 = 0;
	//fix it

	sub_B399A(*a3, a1 + 108);
	v3 = sub_B37B0(a2 + a1 + 28, a1 + 108, (int)a3);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B25B0) --------------------------------------------------------
char sub_B25B0(int a1, int a2, signed __int16 *a3, __int16 bx0, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
	__int16 v19; // dx
	int v21; // eax

	sub_B399A(*a3, a1 + 108);
	v21 = sub_B3542(a2 + a1 + 28, a1 + 108);
	v19 = *(x_WORD *)(a1 + 4) & 0xB8FF;
	HIBYTE(v19) |= *((x_BYTE *)&x_DWORD_B1860[37] + v21 + 3);
	*(x_WORD *)(a1 + 4) = v19;
	return sub_B1C58(bx0, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B25CE) --------------------------------------------------------
char sub_B25CE(int a1, int a2, signed __int16 *esi0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
	__int16 v18; // dx
	int v20; // eax

	sub_B399A(*esi0, a1 + 108);
	v20 = sub_B3542(a2 + a1 + 28, a1 + 108);
	v18 = *(x_WORD *)(a1 + 4) & 0xB8FF;
	HIBYTE(v18) |= *((x_BYTE *)&x_DWORD_B1860[37] + v20 + 3);
	*(x_WORD *)(a1 + 4) = v18;
	return sub_B1E11(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B25EC) --------------------------------------------------------
int sub_B25EC(int a1, int a2, signed __int16 *a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v3 = 0;
	v4 = 0;
	//fix it

	sub_B399A(*a3, a1 + 108);
	sub_B336E(a2 + a1 + 28, a1 + 108);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B260D) --------------------------------------------------------
int sub_B260D(int a1, int a2, signed __int16 *a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v3 = 0;
	v4 = 0;
	//fix it

	sub_B399A(*a3, a1 + 108);
	sub_B336E(a1 + 108, a2 + a1 + 28);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B262E) --------------------------------------------------------
int sub_B262E(int a1, int a2, signed __int16 *a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v4 = 0;
	//fix it

	sub_B399A(*a3, a1 + 108);
	v3 = sub_B35DB(a2 + a1 + 28, a1 + 108, (x_BYTE *)a1, (int)a3);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B264F) --------------------------------------------------------
int sub_B264F(int a1, int a2, signed __int16 *a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v4 = 0;
	//fix it

	sub_B399A(*a3, a1 + 108);
	v3 = sub_B35DB(a1 + 108, a2 + a1 + 28, (x_BYTE *)a1, (int)a3);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B2670) --------------------------------------------------------
char sub_B2670(int a1, int a2, signed __int16 *a3, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
	int v18; // edi
	__int16 v19; // bx
	__int16 v20; // bx

	v18 = *(unsigned __int16 *)((char *)x_DWORD_B1858 + a2);
	v19 = *(x_WORD *)((char *)x_DWORD_B1858 + v18 + 2);
	*(x_WORD *)(a1 + 4) &= 0xC7FFu;
	*(x_WORD *)(a1 + 4) |= v19;
	v20 = *(x_WORD *)((char *)&x_DWORD_B1860[17] + v18 + 2);
	*(x_WORD *)(a1 + 8) &= v20;
	sub_B399A(*a3, v18 + a1 + 28);
	return sub_B1C58(v20, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// B1858: using guessed type int x_DWORD_B1858[2];
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B26AC) --------------------------------------------------------
char sub_B26AC(x_WORD *a1, int a2, x_WORD *a3, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
	int v18; // eax
	x_DWORD *v19; // ebx
	int v21; // [esp-Ch] [ebp-Ch]
	int v22; // [esp-8h] [ebp-8h]
	int v23; // [esp-4h] [ebp-4h]

	//fix it
	v18 = 0;
	//fix it

	v23 = *(x_DWORD *)((char *)a1 + a2 + 28);
	v22 = *(x_DWORD *)((char *)a1 + a2 + 32);
	v21 = *(x_DWORD *)((char *)a1 + a2 + 34);
	sub_B3C6B((unsigned int)a1 + a2 + 28, *a1 & 0xC00);
	sub_B392B();
	if ((signed __int16)v18 != v18)
		LOWORD(v18) = -32768;
	*a3 = v18;
	v19 = (x_DWORD *)((char *)a1 + a2 + 28);
	*(x_DWORD *)((char *)v19 + 6) = v21;
	v19[1] = v22;
	*v19 = v23;
	return sub_B1C58((__int16)v19, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}

//----- (000B26F4) --------------------------------------------------------
char sub_B26F4(int a1, int a2, x_WORD *esi0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
	int v18; // eax

	//fix it
	v18 = 0;
	//fix it

	sub_B3C6B(a2 + a1 + 28, *(x_WORD *)a1 & 0xC00);
	sub_B392B();
	if ((signed __int16)v18 != v18)
		LOWORD(v18) = -32768;
	*esi0 = v18;
	return sub_B1E11(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}

//----- (000B2729) --------------------------------------------------------
char sub_B2729(int a1, int a2, unsigned int *a3, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
	int v18; // edi
	__int16 v19; // bx
	__int16 v20; // bx

	v18 = *(unsigned __int16 *)((char *)x_DWORD_B1858 + a2);
	v19 = *(x_WORD *)((char *)x_DWORD_B1858 + v18 + 2);
	*(x_WORD *)(a1 + 4) &= 0xC7FFu;
	*(x_WORD *)(a1 + 4) |= v19;
	v20 = *(x_WORD *)((char *)&x_DWORD_B1860[17] + v18 + 2);
	*(x_WORD *)(a1 + 8) &= v20;
	sub_B39AB(*a3, v18 + a1 + 28);
	return sub_B1C58(v20, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// B1858: using guessed type int x_DWORD_B1858[2];
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B2768) --------------------------------------------------------
char sub_B2768(int a1, int a2, int *esi0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
	sub_B3C6B(a2 + a1 + 28, *(x_WORD *)a1 & 0xC00);
	*esi0 = sub_B3930((int *)(a2 + a1 + 28));
	return sub_B1E11(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}

//----- (000B2791) --------------------------------------------------------
void sub_B2791()
{
	JUMPOUT((int*)&loc_B27B9);
}

//----- (000B27BE) --------------------------------------------------------
int sub_B27BE(int a1, int a2, int a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v4 = 0;
	//fix it

	v3 = sub_B337C(a2 + a1 + 28, a3 + a1 + 28, a3);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B27D3) --------------------------------------------------------
int sub_B27D3(int a1, int a2, int a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v4 = 0;
	//fix it

	v3 = sub_B37B0(a2 + a1 + 28, a3 + a1 + 28, a3);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B27E8) --------------------------------------------------------
char sub_B27E8(int a1, int a2, int a3, __int16 bx0, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
	__int16 v19; // dx
	int v21; // eax

	v21 = sub_B3542(a2 + a1 + 28, a3 + a1 + 28);
	v19 = *(x_WORD *)(a1 + 4) & 0xB8FF;
	HIBYTE(v19) |= *((x_BYTE *)&x_DWORD_B1860[37] + v21 + 3);
	*(x_WORD *)(a1 + 4) = v19;
	return sub_B1C58(bx0, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B27FA) --------------------------------------------------------
char sub_B27FA(int a1, int a2, int esi0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
	__int16 v18; // dx
	int v20; // eax

	v20 = sub_B3542(a2 + a1 + 28, esi0 + a1 + 28);
	v18 = *(x_WORD *)(a1 + 4) & 0xB8FF;
	HIBYTE(v18) |= *((x_BYTE *)&x_DWORD_B1860[37] + v20 + 3);
	*(x_WORD *)(a1 + 4) = v18;
	return sub_B1E11(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B280C) --------------------------------------------------------
int sub_B280C(int a1, int a2, int a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v3 = 0;
	v4 = 0;
	//fix it

	sub_B336E(a2 + a1 + 28, a3 + a1 + 28);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B2821) --------------------------------------------------------
int sub_B2821(int a1, int a2, int a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v3 = 0;
	v4 = 0;
	//fix it

	sub_B336E(a3 + a1 + 28, a2 + a1 + 28);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B2836) --------------------------------------------------------
int sub_B2836(int a1, int a2, int a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v4 = 0;
	//fix it

	v3 = sub_B35DB(a2 + a1 + 28, a3 + a1 + 28, (x_BYTE *)a1, a3);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B284B) --------------------------------------------------------
int sub_B284B(int a1, int a2, int a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v4 = 0;
	//fix it

	v3 = sub_B35DB(a3 + a1 + 28, a2 + a1 + 28, (x_BYTE *)a1, a3);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a2 + a1 + 28);
}

//----- (000B2860) --------------------------------------------------------
char sub_B2860(int a1, int a2, int a3, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
	int v18; // edi
	__int16 v19; // bx
	__int16 v20; // bx

	v18 = *(unsigned __int16 *)((char *)x_DWORD_B1858 + a2);
	v19 = *(x_WORD *)((char *)x_DWORD_B1858 + v18 + 2);
	*(x_WORD *)(a1 + 4) &= 0xC7FFu;
	*(x_WORD *)(a1 + 4) |= v19;
	v20 = *(x_WORD *)((char *)&x_DWORD_B1860[17] + v18 + 2);
	*(x_WORD *)(a1 + 8) &= v20;
	*(x_DWORD *)(v18 + a1 + 28) = *(x_DWORD *)(a3 + a1 + 28);
	*(x_DWORD *)(v18 + a1 + 32) = *(x_DWORD *)(a3 + a1 + 32);
	*(x_WORD *)(v18 + a1 + 36) = *(x_WORD *)(a3 + a1 + 36);
	return sub_B1C58(v20, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// B1858: using guessed type int x_DWORD_B1858[2];
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B28A8) --------------------------------------------------------
char sub_B28A8(int a1, int a2, int a3, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
	int v18; // ebx
	int v19; // esi
	__int16 v20; // ax

	v18 = a2 + a1 + 28;
	v19 = a3 + a1 + 28;
	*(x_DWORD *)v19 = x_InterlockedExchange((volatile long *)v18, *(x_DWORD *)v19);
	*(x_DWORD *)(v19 + 4) = x_InterlockedExchange((volatile long *)(a2 + a1 + 32), *(x_DWORD *)(v19 + 4));
	v20 = *(x_WORD *)(a2 + a1 + 36);
	*(x_WORD *)(v18 + 8) = *(x_WORD *)(v19 + 8);
	*(x_WORD *)(v19 + 8) = v20;
	return sub_B1C58(v18, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}

//----- (000B2912) --------------------------------------------------------
char sub_B2912(int a1, int a2, __int16 bx0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
	__int16 v18; // dx
	int v20; // eax

	*(x_DWORD *)(a1 + 108) = x_DWORD_B184C[0];
	*(x_DWORD *)(a1 + 112) = x_DWORD_B184C[1];
	*(x_WORD *)(a1 + 116) = (x_WORD)off_B1854;
	v20 = sub_B3542(a2 + a1 + 28, a1 + 108);
	v18 = *(x_WORD *)(a1 + 4) & 0xB8FF;
	HIBYTE(v18) |= *((x_BYTE *)&x_DWORD_B1860[37] + v20 + 3);
	*(x_WORD *)(a1 + 4) = v18;
	return sub_B1C58(bx0, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// B184C: using guessed type int x_DWORD_B184C[2];
// B1854: using guessed type void *off_B1854;
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B2951) --------------------------------------------------------
char sub_B2951(int a1, int a2, int a3, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
	int v18; // edi
	__int16 v19; // bx
	__int16 v20; // bx
	int v21; // esi
	char result; // al
	int v23; // edi
	__int16 v24; // bx
	__int16 v25; // bx
	int v26; // esi
	int v27; // edi
	__int16 v28; // bx
	__int16 v29; // bx
	int v30; // esi
	int v31; // edi
	__int16 v32; // bx
	__int16 v33; // bx
	int v34; // esi
	int v35; // edi
	__int16 v36; // bx
	__int16 v37; // bx
	int v38; // esi
	int v39; // edi
	__int16 v40; // bx
	__int16 v41; // bx
	int v42; // esi
	int v43; // edi
	__int16 v44; // bx
	int v45; // esi
	__int16 v46; // bx

	switch (a1)
	{
	case 0:
		v18 = *(unsigned __int16 *)((char *)x_DWORD_B1858 + a3);
		v19 = *(x_WORD *)((char *)x_DWORD_B1858 + v18 + 2);
		*(x_WORD *)(a2 + 4) &= 0xC7FFu;
		*(x_WORD *)(a2 + 4) |= v19;
		v20 = *(x_WORD *)((char *)&x_DWORD_B1860[17] + v18 + 2);
		*(x_WORD *)(a2 + 8) &= v20;
		v21 = v18 + a2 + 28;
		*(x_DWORD *)v21 = 0;
		*(x_DWORD *)(v21 + 4) = 2147483648;
		*(x_WORD *)(v21 + 8) = 0x3FFF;
		result = sub_B1C58(v20, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
		break;
	case 1:
		v23 = *(unsigned __int16 *)((char *)x_DWORD_B1858 + a3);
		v24 = *(x_WORD *)((char *)x_DWORD_B1858 + v23 + 2);
		*(x_WORD *)(a2 + 4) &= 0xC7FFu;
		*(x_WORD *)(a2 + 4) |= v24;
		v25 = *(x_WORD *)((char *)&x_DWORD_B1860[17] + v23 + 2);
		*(x_WORD *)(a2 + 8) &= v25;
		v26 = v23 + a2 + 28;
		*(x_DWORD *)v26 = -853832962;
		*(x_DWORD *)(v26 + 4) = -728074165;
		*(x_WORD *)(v26 + 8) = 0x4000;
		result = sub_B1C58(v25, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
		break;
	case 2:
		v27 = *(unsigned __int16 *)((char *)x_DWORD_B1858 + a3);
		v28 = *(x_WORD *)((char *)x_DWORD_B1858 + v27 + 2);
		*(x_WORD *)(a2 + 4) &= 0xC7FFu;
		*(x_WORD *)(a2 + 4) |= v28;
		v29 = *(x_WORD *)((char *)&x_DWORD_B1860[17] + v27 + 2);
		*(x_WORD *)(a2 + 8) &= v29;
		v30 = v27 + a2 + 28;
		*(x_DWORD *)v30 = 1545072828;
		*(x_DWORD *)(v30 + 4) = -1196803287;
		*(x_WORD *)(v30 + 8) = 0x3FFF;
		result = sub_B1C58(v29, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
		break;
	case 3:
		v31 = *(unsigned __int16 *)((char *)x_DWORD_B1858 + a3);
		v32 = *(x_WORD *)((char *)x_DWORD_B1858 + v31 + 2);
		*(x_WORD *)(a2 + 4) &= 0xC7FFu;
		*(x_WORD *)(a2 + 4) |= v32;
		v33 = *(x_WORD *)((char *)&x_DWORD_B1860[17] + v31 + 2);
		*(x_WORD *)(a2 + 8) &= v33;
		v34 = v31 + a2 + 28;
		*(x_DWORD *)v34 = 560513589;
		*(x_DWORD *)(v34 + 4) = -922690910;
		*(x_WORD *)(v34 + 8) = 0x4000;
		result = sub_B1C58(v33, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
		break;
	case 4:
		v35 = *(unsigned __int16 *)((char *)x_DWORD_B1858 + a3);
		v36 = *(x_WORD *)((char *)x_DWORD_B1858 + v35 + 2);
		*(x_WORD *)(a2 + 4) &= 0xC7FFu;
		*(x_WORD *)(a2 + 4) |= v36;
		v37 = *(x_WORD *)((char *)&x_DWORD_B1860[17] + v35 + 2);
		*(x_WORD *)(a2 + 8) &= v37;
		v38 = v35 + a2 + 28;
		*(x_DWORD *)v38 = -70256743;
		*(x_DWORD *)(v38 + 4) = -1709139324;
		*(x_WORD *)(v38 + 8) = 16381;
		result = sub_B1C58(v37, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
		break;
	case 5:
		v39 = *(unsigned __int16 *)((char *)x_DWORD_B1858 + a3);
		v40 = *(x_WORD *)((char *)x_DWORD_B1858 + v39 + 2);
		*(x_WORD *)(a2 + 4) &= 0xC7FFu;
		*(x_WORD *)(a2 + 4) |= v40;
		v41 = *(x_WORD *)((char *)&x_DWORD_B1860[17] + v39 + 2);
		*(x_WORD *)(a2 + 8) &= v41;
		v42 = v39 + a2 + 28;
		*(x_DWORD *)v42 = -774932052;
		*(x_DWORD *)(v42 + 4) = -1317922825;
		*(x_WORD *)(v42 + 8) = 16382;
		result = sub_B1C58(v41, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
		break;
	case 6:
		v43 = *(unsigned __int16 *)((char *)x_DWORD_B1858 + a3);
		v44 = *(x_WORD *)((char *)x_DWORD_B1858 + v43 + 2);
		*(x_WORD *)(a2 + 4) &= 0xC7FFu;
		*(x_WORD *)(a2 + 4) |= v44;
		*(x_WORD *)(a2 + 8) &= *(x_WORD *)((char *)&x_DWORD_B1860[17] + v43 + 2);
		v45 = v43 + a2 + 28;
		*(x_DWORD *)v45 = 0;
		*(x_DWORD *)(v45 + 4) = 0;
		*(x_WORD *)(v45 + 8) = 0;
		*(x_WORD *)(a2 + 8) &= *(x_WORD *)((char *)&x_DWORD_B1860[17] + v43 + 2);
		v46 = *(x_WORD *)((char *)&x_DWORD_B1860[18] + v43);
		*(x_WORD *)(a2 + 8) |= v46;
		result = sub_B1C58(v46, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
		break;
	}
	return result;
}
// B1858: using guessed type int x_DWORD_B1858[2];
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B2B6C) --------------------------------------------------------
char sub_B2B6C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, __int16 a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, __int16 a21)
{
	int v21; // eax
	char result; // al
	__int16 v23; // bx
	int v24; // eax
	int v25; // edi
	__int16 v26; // bx
	__int16 v27; // bx
	int v28; // esi

	switch (a3)
	{
	case 0:
		v21 = sub_B4718(a5 + a4 + 28, a1, a3, a2);
		result = (*(int(/*__fastcall*/ **)(int))(a4 + 118))(v21);
		break;
	case 1:
		*(x_WORD *)(a4 + 8) &= *(x_WORD *)((char *)&x_DWORD_B1860[17] + a5 + 2);
		*(x_WORD *)(a4 + 8) |= *(x_WORD *)((char *)&x_DWORD_B1860[19] + a5 + 2);
		v23 = *(x_WORD *)((char *)x_DWORD_B1858 + *(unsigned __int16 *)((char *)&off_B1854 + a5 + 2) + 2);
		*(x_WORD *)(a4 + 4) &= 0xC7FFu;
		*(x_WORD *)(a4 + 4) |= v23;
		v24 = sub_B41F9(a5 + a4 + 28, (x_BYTE *)a4, a6);
		result = (*(int(/*__fastcall*/ **)(int))(a4 + 118))(v24);
		break;
	case 2:
		sub_B46E2(a5 + a4 + 28);
		v25 = *(unsigned __int16 *)((char *)x_DWORD_B1858 + a5);
		v26 = *(x_WORD *)((char *)x_DWORD_B1858 + v25 + 2);
		*(x_WORD *)(a4 + 4) &= 0xC7FFu;
		*(x_WORD *)(a4 + 4) |= v26;
		v27 = *(x_WORD *)((char *)&x_DWORD_B1860[17] + v25 + 2);
		*(x_WORD *)(a4 + 8) &= v27;
		v28 = v25 + a4 + 28;
		*(x_DWORD *)v28 = 0;
		*(x_DWORD *)(v28 + 4) = 2147483648;
		*(x_WORD *)(v28 + 8) = 0x3FFF;
		result = sub_B1C58(v27, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21);
		break;
	}
	return result;
}
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int x_DWORD_B1858[2];
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B2C76) --------------------------------------------------------
//#error "B2D13: call analysis failed (funcsize=50)"

//----- (000B2D8E) --------------------------------------------------------
void /*__fastcall*/ sub_B2D8E(int a1, int a2, int a3)
{
	JUMPOUT(__CS__, (int*) *(&off_B2D96 + a3));
}
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int x_DWORD_B1858[2];
// B1860: using guessed type int x_DWORD_B1860[41];
// B2D96: using guessed type int (*off_B2D96)(__int16, __int16, int, int, int, int, int, int, int, int, int, int, int, int, __int16);

//----- (000B2E17) --------------------------------------------------------
void /*__fastcall*/ sub_B2E17(int a1, int a2, int a3)
{
	JUMPOUT(__CS__, (int*)off_B2E1F[a3]);
}
// B2E1F: using guessed type int (*off_B2E1F[2])(__int16, __int16, int, int, int, int, int, int, int, int, int, int, int, int, __int16);

//----- (000B2E71) --------------------------------------------------------
int sub_B2E71(int a1, int a2, int a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v4 = 0;
	//fix it

	v3 = sub_B337C(a3 + a1 + 28, a2 + a1 + 28, a3);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a3 + a1 + 28);
}

//----- (000B2E86) --------------------------------------------------------
int sub_B2E86(int a1, int a2, int a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v4 = 0;
	//fix it

	v3 = sub_B37B0(a3 + a1 + 28, a2 + a1 + 28, a3);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a3 + a1 + 28);
}

//----- (000B2E9B) --------------------------------------------------------
int sub_B2E9B(int a1, int a2, int a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v3 = 0;
	v4 = 0;
	//fix it

	sub_B336E(a2 + a1 + 28, a3 + a1 + 28);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a3 + a1 + 28);
}

//----- (000B2EB0) --------------------------------------------------------
int sub_B2EB0(int a1, int a2, int a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v3 = 0;
	v4 = 0;
	//fix it

	sub_B336E(a3 + a1 + 28, a2 + a1 + 28);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a3 + a1 + 28);
}

//----- (000B2EC5) --------------------------------------------------------
int sub_B2EC5(int a1, int a2, int a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v4 = 0;
	//fix it

	v3 = sub_B35DB(a2 + a1 + 28, a3 + a1 + 28, (x_BYTE *)a1, a3);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a3 + a1 + 28);
}

//----- (000B2EDA) --------------------------------------------------------
int sub_B2EDA(int a1, int a2, int a3)
{
	int v3; // eax
	int v4; // edx

	//fix it
	v4 = 0;
	//fix it

	v3 = sub_B35DB(a3 + a1 + 28, a2 + a1 + 28, (x_BYTE *)a1, a3);
	return (*(int(/*__fastcall*/ **)(int, int, int))(a1 + 118))(v3, v4, a3 + a1 + 28);
}

//----- (000B2EEF) --------------------------------------------------------
char sub_B2EEF(int a1, int a2, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
	__int16 v17; // bx

	*(x_WORD *)(a1 + 8) &= *(x_WORD *)((char *)&x_DWORD_B1860[17] + a2 + 2);
	v17 = *(x_WORD *)((char *)&x_DWORD_B1860[19] + a2 + 2);
	*(x_WORD *)(a1 + 8) |= v17;
	return sub_B1C58(v17, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B2F0E) --------------------------------------------------------
char sub_B2F0E(int a1, int a2, int a3, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
	__int16 v18; // bx

	*(x_DWORD *)(a3 + a1 + 28) = *(x_DWORD *)(a2 + a1 + 28);
	*(x_DWORD *)(a3 + a1 + 32) = *(x_DWORD *)(a2 + a1 + 32);
	*(x_WORD *)(a3 + a1 + 36) = *(x_WORD *)(a2 + a1 + 36);
	v18 = *(x_WORD *)((char *)&x_DWORD_B1860[17] + a3 + 2);
	*(x_WORD *)(a1 + 8) &= v18;
	return sub_B1C58(v18, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B2F3A) --------------------------------------------------------
char sub_B2F3A(int a1, int a2, int a3, __int16 bx0, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18)
{
	__int16 v19; // dx
	int v21; // eax

	v21 = sub_B3542(a2 + a1 + 28, a3 + a1 + 28);
	v19 = *(x_WORD *)(a1 + 4) & 0xB8FF;
	HIBYTE(v19) |= *((x_BYTE *)&x_DWORD_B1860[37] + v21 + 3);
	*(x_WORD *)(a1 + 4) = v19;
	return sub_B1C58(bx0, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B2F4C) --------------------------------------------------------
char sub_B2F4C(int a1, int a2, int esi0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
	__int16 v18; // dx
	int v20; // eax

	v20 = sub_B3542(a2 + a1 + 28, esi0 + a1 + 28);
	v18 = *(x_WORD *)(a1 + 4) & 0xB8FF;
	HIBYTE(v18) |= *((x_BYTE *)&x_DWORD_B1860[37] + v20 + 3);
	*(x_WORD *)(a1 + 4) = v18;
	return sub_B1E11(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B2F5E) --------------------------------------------------------
char sub_B2F5E(int a1, int a2, int esi0, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17)
{
	*(x_DWORD *)(esi0 + a1 + 28) = *(x_DWORD *)(a2 + a1 + 28);
	*(x_DWORD *)(esi0 + a1 + 32) = *(x_DWORD *)(a2 + a1 + 32);
	*(x_WORD *)(esi0 + a1 + 36) = *(x_WORD *)(a2 + a1 + 36);
	*(x_WORD *)(a1 + 8) &= *(x_WORD *)((char *)&x_DWORD_B1860[17] + esi0 + 2);
	return sub_B1E11(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B2F8A) --------------------------------------------------------
int sub_B2F8A(int a1, int a2, int a3)
{
	int v3; // eax
	__int16 v4; // bx

	v3 = sub_B337C(a3 + a1 + 28, a2 + a1 + 28, a3);
	*(x_WORD *)(a1 + 8) &= *(x_WORD *)((char *)&x_DWORD_B1860[17] + a2 + 2);
	*(x_WORD *)(a1 + 8) |= *(x_WORD *)((char *)&x_DWORD_B1860[19] + a2 + 2);
	v4 = *(x_WORD *)((char *)x_DWORD_B1858 + *(unsigned __int16 *)((char *)&off_B1854 + a2 + 2) + 2);
	*(x_WORD *)(a1 + 4) &= 0xC7FFu;
	*(x_WORD *)(a1 + 4) |= v4;
	return (*(int(/*__fastcall*/ **)(int))(a1 + 118))(v3);
}
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int x_DWORD_B1858[2];
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B2FD5) --------------------------------------------------------
int sub_B2FD5(int a1, int a2, int a3)
{
	int v3; // eax
	__int16 v4; // bx

	v3 = sub_B37B0(a3 + a1 + 28, a2 + a1 + 28, a3);
	*(x_WORD *)(a1 + 8) &= *(x_WORD *)((char *)&x_DWORD_B1860[17] + a2 + 2);
	*(x_WORD *)(a1 + 8) |= *(x_WORD *)((char *)&x_DWORD_B1860[19] + a2 + 2);
	v4 = *(x_WORD *)((char *)x_DWORD_B1858 + *(unsigned __int16 *)((char *)&off_B1854 + a2 + 2) + 2);
	*(x_WORD *)(a1 + 4) &= 0xC7FFu;
	*(x_WORD *)(a1 + 4) |= v4;
	return (*(int(/*__fastcall*/ **)(int))(a1 + 118))(v3);
}
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int x_DWORD_B1858[2];
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B3020) --------------------------------------------------------
void /*__fastcall*/ sub_B3020(int a1, int a2, int a3)
{
	JUMPOUT(__CS__, (int*) *(&off_B3028 + a3));
}
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int x_DWORD_B1858[2];
// B1860: using guessed type int x_DWORD_B1860[41];
// B3028: using guessed type int (*off_B3028)(__int16, __int16, int, int, int, int, int, int, int, int, int, int, int, int, __int16);

//----- (000B30A9) --------------------------------------------------------
int sub_B30A9(int a1, int a2, int a3)
{
	__int16 v3; // bx

	sub_B336E(a2 + a1 + 28, a3 + a1 + 28);
	*(x_WORD *)(a1 + 8) &= *(x_WORD *)((char *)&x_DWORD_B1860[17] + a2 + 2);
	*(x_WORD *)(a1 + 8) |= *(x_WORD *)((char *)&x_DWORD_B1860[19] + a2 + 2);
	v3 = *(x_WORD *)((char *)x_DWORD_B1858 + *(unsigned __int16 *)((char *)&off_B1854 + a2 + 2) + 2);
	*(x_WORD *)(a1 + 4) &= 0xC7FFu;
	*(x_WORD *)(a1 + 4) |= v3;
	return (*(int(**)(void))(a1 + 118))();
}
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int x_DWORD_B1858[2];
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B30F4) --------------------------------------------------------
int sub_B30F4(int a1, int a2, int a3)
{
	__int16 v3; // bx

	sub_B336E(a3 + a1 + 28, a2 + a1 + 28);
	*(x_WORD *)(a1 + 8) &= *(x_WORD *)((char *)&x_DWORD_B1860[17] + a2 + 2);
	*(x_WORD *)(a1 + 8) |= *(x_WORD *)((char *)&x_DWORD_B1860[19] + a2 + 2);
	v3 = *(x_WORD *)((char *)x_DWORD_B1858 + *(unsigned __int16 *)((char *)&off_B1854 + a2 + 2) + 2);
	*(x_WORD *)(a1 + 4) &= 0xC7FFu;
	*(x_WORD *)(a1 + 4) |= v3;
	return (*(int(**)(void))(a1 + 118))();
}
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int x_DWORD_B1858[2];
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B313F) --------------------------------------------------------
int sub_B313F(int a1, int a2, int a3)
{
	int v3; // eax
	__int16 v4; // bx

	v3 = sub_B35DB(a2 + a1 + 28, a3 + a1 + 28, (x_BYTE *)a1, a3);
	*(x_WORD *)(a1 + 8) &= *(x_WORD *)((char *)&x_DWORD_B1860[17] + a2 + 2);
	*(x_WORD *)(a1 + 8) |= *(x_WORD *)((char *)&x_DWORD_B1860[19] + a2 + 2);
	v4 = *(x_WORD *)((char *)x_DWORD_B1858 + *(unsigned __int16 *)((char *)&off_B1854 + a2 + 2) + 2);
	*(x_WORD *)(a1 + 4) &= 0xC7FFu;
	*(x_WORD *)(a1 + 4) |= v4;
	return (*(int(/*__fastcall*/ **)(int))(a1 + 118))(v3);
}
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int x_DWORD_B1858[2];
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B318A) --------------------------------------------------------
int sub_B318A(int a1, int a2, int a3)
{
	int v3; // eax
	__int16 v4; // bx

	v3 = sub_B35DB(a3 + a1 + 28, a2 + a1 + 28, (x_BYTE *)a1, a3);
	*(x_WORD *)(a1 + 8) &= *(x_WORD *)((char *)&x_DWORD_B1860[17] + a2 + 2);
	*(x_WORD *)(a1 + 8) |= *(x_WORD *)((char *)&x_DWORD_B1860[19] + a2 + 2);
	v4 = *(x_WORD *)((char *)x_DWORD_B1858 + *(unsigned __int16 *)((char *)&off_B1854 + a2 + 2) + 2);
	*(x_WORD *)(a1 + 4) &= 0xC7FFu;
	*(x_WORD *)(a1 + 4) |= v4;
	return (*(int(/*__fastcall*/ **)(int))(a1 + 118))(v3);
}
// B1854: using guessed type void *off_B1854;
// B1858: using guessed type int x_DWORD_B1858[2];
// B1860: using guessed type int x_DWORD_B1860[41];

//----- (000B31D5) --------------------------------------------------------
void sub_B31D5()
{
	JUMPOUT((int*)&loc_B335E);
}

//----- (000B336E) --------------------------------------------------------
void /*__fastcall*/ sub_B336E(int a1, int a2)
{
	__int16 v2; // si

	v2 = *(x_WORD *)(a2 + 8) ^ 0x8000;
	JUMPOUT((int*)&loc_B3383);
}

//----- (000B337C) --------------------------------------------------------
int sub_B337C(int a1, int a2, int a3)
{
	int v3; // ebx
	int v4; // esi
	int result; // eax
	int v6; // edx

	//fix it
	v6 = 0;
	//fix it

	LOWORD(a3) = *(x_WORD *)(a2 + 8);
	v3 = *(x_DWORD *)a2;
	v4 = a3 << 16;
	LOWORD(v4) = *(x_WORD *)(a1 + 8);
	result = sub_B33D6(*(_QWORD *)a1, *(x_DWORD *)(a2 + 4), *(x_DWORD *)a2, v4);
	*(x_DWORD *)v3 = result;
	*(x_DWORD *)(v3 + 4) = v6;
	*(x_WORD *)(v3 + 8) = v4;
	return result;
}

//----- (000B33A6) --------------------------------------------------------
int /*__userpurge*/ sub_B33A6(int a1, int a2, int a3, int a4, __int16 a5)
{
	int v5; // esi
	int result; // eax
	int v7; // edx

	//fix it
	v7 = 0;
	//fix it

	LOWORD(a2) = a5;
	v5 = a2 << 16;
	LOWORD(v5) = *(x_WORD *)(a1 + 8);
	result = sub_B33D6(*(_QWORD *)a1, a4, a3, v5);
	*(x_DWORD *)a3 = result;
	*(x_DWORD *)(a3 + 4) = v7;
	*(x_WORD *)(a3 + 8) = v5;
	return result;
}

//----- (000B33D6) --------------------------------------------------------
int sub_B33D6(unsigned __int64 a1, int a2, int a3, int a4)
{
	unsigned __int8 v4; // cf
	__int16 v5; // si
	int v6; // ecx
	int v7; // esi
	int v8; // et0
	int v9; // edi
	unsigned int v10; // ecx
	__int16 v11; // bp
	int v12; // edi
	int v13; // edi
	bool v14; // cf
	int v15; // ecx
	int v16; // et1
	int v17; // et2
	int v18; // edi
	int v19; // ebx
	char v20; // ch
	int v21; // ebx
	int v22; // edi
	unsigned __int8 v23; // cf
	unsigned __int8 v24; // tt
	int v25; // ett
	int v26; // ett
	__int16 v27; // bp
	unsigned __int8 v28; // tt
	unsigned __int8 v29; // tt
	unsigned __int8 v30; // cf
	int v31; // eax
	unsigned __int8 v32; // tt
	int v33; // ett
	unsigned __int8 v34; // cf
	int v35; // ett
	int v37; // [esp-Ch] [ebp-Ch]

	if (!a1)
	{
		v4 = __CFADD__((x_WORD)a4, (x_WORD)a4);
		v5 = 2 * a4;
		if (!v5)
		{
			LODWORD(a1) = a3;
			return a1;
		}
		LOWORD(a4) = __RCR__(v5, v4);
	}
	if (a2 || a3 || a4 & 0x7FFF0000)
	{
		v8 = a2;
		v6 = a4;
		v7 = v8;
		v9 = __ROL4__(v6, 16) >> 16;
		v10 = (v6 >> 16) & 0x80007FFF;
		v11 = v10;
		v12 = __ROL4__(v9 & 0x80007FFF, 16);
		v10 = __ROL4__(v10, 16);
		LOWORD(v10) = v12 + v10;
		v13 = __ROL4__(v12, 16);
		v15 = __ROL4__(v10, 16);
		v14 = (unsigned __int16)v15 < (unsigned __int16)v13;
		LOWORD(v15) = v15 - v13;
		if (!(x_WORD)v15)
			goto LABEL_42;
		if (v14)
		{
			v11 = v13;
			LOWORD(v15) = -(signed __int16)v15;
			v16 = a1;
			LODWORD(a1) = a3;
			a3 = v16;
			v17 = HIDWORD(a1);
			HIDWORD(a1) = v7;
			v7 = v17;
		}
		if ((unsigned __int16)v15 > 0x40u)
		{
			LODWORD(a1) = a3;
		}
		else
		{
		LABEL_42:
			BYTE1(v15) = 0;
			if (v15 < 0)
			{
				BYTE1(v15) = -1;
				a3 = -a3;
				v7 = -v7 - (a3 != 0);
			}
			v18 = 0;
			if ((x_BYTE)v15)
			{
				v37 = a3;
				v19 = 0;
				if ((unsigned __int8)v15 >= 0x20u)
				{
					LOBYTE(v19) = (x_DWORD)a1 != 0;
					v18 = v19;
					if ((x_BYTE)v15 == 64)
					{
						v18 = HIDWORD(a1) | v19;
						HIDWORD(a1) = 0;
					}
					a1 = HIDWORD(a1);
				}
				v18 |= __PAIR__((uint32)a1, (uint32)0) >> v15;
				LODWORD(a1) = a1 >> v15;
				HIDWORD(a1) = (unsigned __int64)HIDWORD(a1) >> v15;
				a3 = v37;
			}
			v4 = __CFADD__(__PAIR__(v7, a3), a1);
			a1 += __PAIR__(v7, a3);
			v20 = v4 + BYTE1(v15);
			if (v20 < 0)
			{
				if ((x_BYTE)v15 == 64)
					a1 += (v18 & 0x7FFFFFFF) != 0;
				LODWORD(a1) = -(signed int)a1;
				HIDWORD(a1) = 0 - HIDWORD(a1) - ((x_DWORD)a1 != 0);
				v20 = 0;
			}
			v21 = a1;
			LOBYTE(v21) = v20 | a1;
			if (HIDWORD(a1) | v21 && v11)
			{
				if (v20)
				{
				LABEL_31:
					v27 = v11 + 1;
					if (v27 == 0x7FFF)
						goto LABEL_43;
					v28 = __CFRCR__(HIDWORD(a1), 1);
					HIDWORD(a1) = __RCR__(HIDWORD(a1), 1);
					v4 = v28;
					v29 = __CFRCR__(a1, v28);
					LODWORD(a1) = __RCR__(a1, v4);
					if (v29)
					{
						v30 = __CFADD__(v18, v18);
						if (!(2 * v18))
						{
							v31 = __ROR4__(a1, 1);
							v32 = __CFSHL__(v31, 1);
							LODWORD(a1) = __ROL4__(v31, 1);
							v30 = v32;
						}
						v33 = v30;
						v4 = __CFADD__(v30, (x_DWORD)a1);
						LODWORD(a1) = v33 + a1;
						v35 = v4;
						v34 = __CFADD__(v4, HIDWORD(a1));
						HIDWORD(a1) += v35;
						if (v34)
						{
							LODWORD(a1) = __RCR__(a1, __CFRCR__(HIDWORD(a1), v34));
							if (v27 == 0x7FFE)
								LABEL_43:
							LODWORD(a1) = 0;
						}
					}
				}
				else
				{
					v22 = __ROL4__(v18, 1);
					v24 = v22 & 1;
					v18 = __ROR4__(v22, 1);
					v23 = v24;
					while (--v11)
					{
						v25 = v23 + (x_DWORD)a1;
						v4 = __CFADD__(v23, (x_DWORD)a1) | __CFADD__((x_DWORD)a1, v25);
						LODWORD(a1) = a1 + v25;
						v26 = v4 + HIDWORD(a1);
						v23 = __CFADD__(v4, HIDWORD(a1)) | __CFADD__(HIDWORD(a1), v26);
						HIDWORD(a1) += v26;
						if (v23)
							goto LABEL_31;
					}
				}
			}
		}
	}
	return a1;
}

//----- (000B3542) --------------------------------------------------------
int /*__fastcall*/ sub_B3542(int a1, int a2)
{
	int v2; // esi
	bool v3; // cf
	bool v4; // zf
	int v5; // edi
	int v6; // eax
	int result; // eax
	int v8; // edi
	int v9; // eax

	if ((*(x_WORD *)(a1 + 8) | 0x8000) == -1 && *(x_DWORD *)a1 | 2 * *(x_DWORD *)(a1 + 4)
		|| (*(x_WORD *)(a2 + 8) | 0x8000) == -1 && *(x_DWORD *)a2 | 2 * *(x_DWORD *)(a2 + 4))
	{
		return 2;
	}
	v2 = *(x_DWORD *)(a1 + 6);
	if ((v2 ^ *(x_DWORD *)(a2 + 6)) >= 0)
	{
		LOWORD(v2) = *(x_WORD *)(a1 + 8);
		v3 = (unsigned __int16)v2 < *(x_WORD *)(a2 + 8);
		v4 = (x_WORD)v2 == *(x_WORD *)(a2 + 8);
		if ((x_WORD)v2 == *(x_WORD *)(a2 + 8))
		{
			v3 = *(_QWORD *)a1 < *(_QWORD *)a2;
			v4 = *(_QWORD *)a1 == *(_QWORD *)a2;
		}
		v5 = 0;
		if (v4)
			return v5;
		v6 = __RCR__(a1, v3);
		v2 ^= v6;
		return -2 * __CFADD__(v2, v2) + 1;
	}
	v8 = *(x_DWORD *)(a2 + 4) | *(x_DWORD *)(a1 + 4) | *(x_DWORD *)a2 | *(x_DWORD *)a1;
	LOWORD(a1) = *(x_WORD *)(a1 + 8);
	v9 = a1 << 16;
	LOWORD(v9) = *(x_WORD *)(a2 + 8);
	result = v8 | v9 & 0x7FFF7FFF;
	if (result)
		return -2 * __CFADD__(v2, v2) + 1;
	return result;
}

//----- (000B35DB) --------------------------------------------------------
int sub_B35DB(int a1, int a2, x_BYTE *a3, int a4)
{
	unsigned int v4; // ebx
	int v5; // esi
	int result; // eax
	int v7; // edx

	//fix it
	v7 = 0;
	//fix it

	LOWORD(a4) = *(x_WORD *)(a2 + 8);
	v4 = *(x_DWORD *)a2;
	v5 = a4 << 16;
	LOWORD(v5) = *(x_WORD *)(a1 + 8);
	result = sub_B3605(*(_QWORD *)a1, *(x_DWORD *)(a2 + 4), *(x_DWORD *)a2, a3, v5);
	*(x_DWORD *)v4 = result;
	*(x_DWORD *)(v4 + 4) = v7;
	*(x_WORD *)(v4 + 8) = v5;
	return result;
}

//----- (000B3605) --------------------------------------------------------
int sub_B3605(unsigned __int64 a1, int a2, unsigned int a3, x_BYTE *a4, int a5)
{
	bool v5; // cf
	__int16 v6; // si
	int v7; // ecx
	signed int v8; // esi
	int v9; // et0
	int v10; // edi
	int v11; // ecx
	int v12; // edi
	int v13; // ecx
	unsigned __int16 v14; // di
	unsigned int v15; // ecx
	unsigned int v16; // edi
	unsigned int v17; // esi
	unsigned int v18; // ebx
	unsigned __int64 v19; // rax
	int v20; // ecx
	int v21; // et2
	unsigned __int64 v22; // rax
	int v23; // ecx
	int v24; // edi
	unsigned int i; // esi
	unsigned int v26; // edi
	int v27; // esi
	unsigned int v28; // eax
	unsigned __int64 v29; // rax
	int v30; // et1
	unsigned __int64 v31; // rax
	int v32; // ecx
	int v33; // edi
	unsigned int j; // esi
	unsigned __int16 v35; // di
	char v36; // cl
	x_BYTE v38[12]; // [esp-20h] [ebp-20h]
	unsigned __int64 v39; // [esp-14h] [ebp-14h]
	unsigned __int16 v40; // [esp-Ch] [ebp-Ch]

	if (a2 || a3 || a5 & 0x7FFF0000)
	{
		if (!a1)
		{
			v5 = __CFADD__((x_WORD)a5, (x_WORD)a5);
			v6 = 2 * a5;
			if (!v6)
				return a1;
			LOWORD(a5) = __RCR__(v6, v5);
		}
		v9 = a2;
		v7 = a5;
		v8 = v9;
		v10 = __ROL4__((__ROL4__(v7, 16) >> 16) & 0x80007FFF, 16);
		v11 = __ROL4__((v7 >> 16) & 0x80007FFF, 16);
		LOWORD(v10) = v11 + v10;
		v12 = __ROL4__(v10, 16);
		v13 = __ROL4__(v11, 16);
		if (!(x_WORD)v12)
		{
			do
			{
				a1 *= 2i64;
				LOWORD(v12) = v12 - 1;
			} while ((a1 & 0x8000000000000000i64) == 0i64);
		}
		if (!(x_WORD)v13)
		{
			do
			{
				v8 = __PAIR__((unsigned int)v8, a3) >> 31;
				a3 *= 2;
				LOWORD(v13) = v13 - 1;
			} while (v8 >= 0);
		}
		v14 = v12 - v13 + 0x3FFF;
		if ((v14 & 0x8000u) != 0 || v14 < 0x7FFFu)
		{
			if ((signed __int16)v14 >= -64)
			{
				v40 = v14;
				v39 = __PAIR__(v8, a3);
				v15 = v8;
				v16 = HIDWORD(a1);
				v17 = a1;
				LODWORD(a1) = 0;
				if (v15 <= HIDWORD(a1))
				{
					HIDWORD(a1) -= v15;
					LODWORD(a1) = 1;
				}
				*(x_DWORD *)&v38[8] = a1;
				*(x_DWORD *)&v38[4] = __PAIR__(HIDWORD(a1), v17) / v15;
				LODWORD(a1) = a3;
				v18 = __PAIR__(HIDWORD(a1), v17) / v15;
				v19 = v18 * (unsigned __int64)(unsigned int)a1;
				v21 = v19;
				LODWORD(v19) = v15;
				v20 = v21;
				v22 = HIDWORD(v19) + v18 * (unsigned __int64)(unsigned int)v19;
				if (v38[8] & 1)
					v22 += v39;
				v23 = -v20;
				v24 = (__PAIR__(v16, v17) - __PAIR__(HIDWORD(v22), (v23 != 0) + (unsigned int)v22)) >> 32;
				for (i = v17 - ((v23 != 0) + v22); v24; v24 += (unsigned __int8)v5)
				{
					--*(_QWORD *)&v38[4];
					v5 = __CFADD__(v39, __PAIR__(i, v23));
					i = (v39 + __PAIR__(i, v23)) >> 32;
					v23 += v39;
				}
				v26 = i;
				v27 = v23;
				if (HIDWORD(v39) <= v26)
				{
					v26 -= HIDWORD(v39);
					++*(_QWORD *)&v38[4];
				}
				v28 = __PAIR__(v26, v23) / HIDWORD(v39);
				*(x_DWORD *)v38 = v28;
				if (v28)
				{
					v29 = v28 * (unsigned __int64)(unsigned int)v39;
					v30 = v29;
					v31 = HIDWORD(v29) + (unsigned int)(__PAIR__(v26, v23) / HIDWORD(v39)) * (unsigned __int64)HIDWORD(v39);
					v32 = -v30;
					v33 = (__PAIR__(v26, v27) - __PAIR__(HIDWORD(v31), (v30 != 0) + (unsigned int)v31)) >> 32;
					for (j = v27 - ((v30 != 0) + v31); v33; v33 += (unsigned __int8)v5)
					{
						v5 = (*(_QWORD *)v38)-- < 1ui64;
						v38[8] -= v5;
						v5 = __CFADD__(v39, __PAIR__(j, v32));
						j = (v39 + __PAIR__(j, v32)) >> 32;
						v32 += v39;
					}
				}
				a1 = *(_QWORD *)v38;
				v35 = v40 - 1;
				if (v38[8] & 1)
				{
					HIDWORD(a1) = __RCR__(*(x_DWORD *)&v38[4], v38[8] & 1);
					LODWORD(a1) = __RCR__(*(x_DWORD *)v38, __CFRCR__(*(x_DWORD *)&v38[4], v38[8] & 1));
					v35 = v40;
				}
				if ((signed __int16)v35 <= 0)
				{
					if (v35)
						v36 = -(char)v35;
					else
						v36 = 1;
					LODWORD(a1) = a1 >> v36;
				}
			}
			else
			{
				LODWORD(a1) = 0;
			}
		}
		else
		{
			LODWORD(a1) = 0;
		}
	}
	else if (a1 || (WORD1(a1) = HIWORD(a5), 2 * (x_WORD)a5))
	{
		LOWORD(a1) = -31996;
		sub_B1E68(a1, 0, a4);
		LODWORD(a1) = 0;
	}
	else
	{
		LOWORD(a1) = -32511;
		sub_B1E68(a1, 0, a4);
		LODWORD(a1) = 0;
	}
	return a1;
}

//----- (000B37B0) --------------------------------------------------------
int sub_B37B0(int a1, int a2, int a3)
{
	unsigned int v3; // ebx
	int v4; // esi
	int result; // eax
	int v6; // edx

	//fix it
	v6 = 0;
	//fix it

	LOWORD(a3) = *(x_WORD *)(a2 + 8);
	v3 = *(x_DWORD *)a2;
	v4 = a3 << 16;
	LOWORD(v4) = *(x_WORD *)(a1 + 8);
	result = sub_B37DA(*(_QWORD *)a1, *(x_DWORD *)(a2 + 4), *(x_DWORD *)a2, v4);
	*(x_DWORD *)v3 = result;
	*(x_DWORD *)(v3 + 4) = v6;
	*(x_WORD *)(v3 + 8) = v4;
	return result;
}

//----- (000B37DA) --------------------------------------------------------
int sub_B37DA(unsigned __int64 a1, unsigned int a2, unsigned int a3, int a4)
{
	bool v4; // cf
	__int16 v5; // si
	int v6; // ecx
	unsigned int v7; // esi
	unsigned int v8; // et0
	unsigned int v9; // ecx
	unsigned __int16 v10; // cx
	unsigned int v11; // ST08_4
	unsigned __int64 v12; // ST00_8
	unsigned __int64 v13; // rax
	int v14; // esi
	int v15; // et1
	unsigned int v16; // ecx
	unsigned __int64 v17; // rax
	unsigned int v18; // ecx
	unsigned int v19; // edi
	unsigned __int64 v20; // rax
	unsigned __int64 v21; // kr08_8
	int v22; // ebx
	unsigned __int16 v23; // cx
	bool v24; // cf
	int v25; // ett
	unsigned __int8 v26; // cf
	int v27; // ett
	unsigned __int8 v28; // tt
	__int16 v29; // cx
	unsigned __int16 v31; // [esp-Ch] [ebp-Ch]

	if (!a1)
	{
		v4 = __CFADD__((x_WORD)a4, (x_WORD)a4);
		v5 = 2 * a4;
		if (!v5)
			return a1;
		LOWORD(a4) = __RCR__(v5, v4);
	}
	if (a2 || a3 || a4 & 0x7FFF0000)
	{
		v8 = a2;
		v6 = a4;
		v7 = v8;
		v9 = ((__ROL4__(v6, 16) >> 16) & 0x80007FFF) + ((v6 >> 16) & 0x80007FFF);
		v4 = (unsigned __int16)v9 < 0x3FFEu;
		v10 = v9 - 16382;
		if (!v4 && v10 >= 0x7FFFu)
			goto LABEL_30;
		if ((signed __int16)v10 < -64)
		{
			LODWORD(a1) = 0;
			return a1;
		}
		v31 = v10;
		v11 = v7;
		v12 = a1;
		v13 = a3 * (unsigned __int64)(unsigned int)a1;
		v15 = v13;
		LODWORD(v13) = v7;
		v14 = v15;
		v16 = HIDWORD(v13);
		v17 = (unsigned int)v12 * (unsigned __int64)(unsigned int)v13;
		v4 = __CFADD__((unsigned int)v17, __PAIR__(HIDWORD(v17), v16));
		v19 = (v17 + v16) >> 32;
		v18 = v17 + v16;
		v20 = HIDWORD(v12) * (unsigned __int64)a3;
		v21 = v20 + __PAIR__(v19, v18);
		a1 = __PAIR__(
			__CFADD__(v20, __PAIR__(v19, v18)) + (unsigned int)(unsigned __int8)v4,
			(v20 + __PAIR__(v19, v18)) >> 32)
			+ v11 * (unsigned __int64)HIDWORD(v12);
		v22 = v21;
		v23 = v31;
		if ((a1 & 0x8000000000000000i64) == 0i64)
		{
			v4 = __CFADD__(__PAIR__((uint16)a1, (uint16)v21), __PAIR__((uint16)a1, (uint16)v21));
			LODWORD(a1) = __PAIR__((uint16)a1, (uint16)v21) >> 31;
			v22 = 2 * v21;
			HIDWORD(a1) += (unsigned __int8)v4 + HIDWORD(a1);
			v23 = v31 - 1;
		}
		v24 = __CFADD__(v22, v22);
		if (__CFADD__(v22, v22))
		{
			if (!(2 * v22))
			{
				v24 = v14 != 0;
				if (!v14)
					v24 = a1 & 1;
			}
			v25 = (unsigned __int8)v24;
			v4 = __CFADD__((unsigned __int8)v24, (x_DWORD)a1);
			LODWORD(a1) = v25 + a1;
			v27 = (unsigned __int8)v4;
			v26 = __CFADD__((unsigned __int8)v4, HIDWORD(a1));
			HIDWORD(a1) += v27;
			if (v26)
			{
				v28 = __CFRCR__(HIDWORD(a1), v26);
				HIDWORD(a1) = __RCR__(HIDWORD(a1), v26);
				LODWORD(a1) = __RCR__(a1, v28);
				if (++v23 == 0x7FFF)
				{
				LABEL_30:
					LODWORD(a1) = 0;
					return a1;
				}
			}
		}
		if ((signed __int16)v23 <= 0)
		{
			if (v23)
				v29 = -v23;
			else
				LOBYTE(v29) = 1;
			LODWORD(a1) = a1 >> v29;
		}
	}
	else
	{
		LODWORD(a1) = 0;
	}
	return a1;
}

//----- (000B392B) --------------------------------------------------------
void sub_B392B()
{
	JUMPOUT((int*)&loc_B3933);
}

//----- (000B3930) --------------------------------------------------------
int /*__fastcall*/ sub_B3930(int *a1)
{
	__int16 v1; // cx
	unsigned __int8 v2; // of
	__int16 v3; // cx
	int v4; // ebx
	unsigned int v5; // eax
	unsigned __int8 v6; // cf
	char v7; // ch
	char v8; // cl
	char v9; // ch
	int result; // eax

	v1 = a1[2] & 0x7FFF;
	v2 = __OFSUB__(v1, 16382);
	v3 = v1 - 16382;
	if ((v3 < 0) ^ v2)
		return 0;
	if (v3 > 32 || (char)v3 > 32)
		return 2147483648;
	HIBYTE(v3) = (*((x_BYTE *)a1 + 9) >> 1) | 0x20;
	v4 = *a1;
	v5 = a1[1];
	HIBYTE(v3) = __RCR__(HIBYTE(v3), __CFADD__(v4, v4));
	if ((x_BYTE)v3 == 32)
	{
		v6 = __CFADD__(HIBYTE(v3), HIBYTE(v3));
		v7 = 2 * HIBYTE(v3);
	}
	else
	{
		v7 = 2 * HIBYTE(v3);
		v6 = __CFADD__(v5 << v3, v5 << v3);
		v5 = (unsigned __int64)v5 << v3 >> 32;
	}
	v8 = __RCR__(-1, v6);
	v9 = v8 & v7;
	result = __CFADD__(v9, v9) + v5;
	if (__CFADD__(2 * v9, 2 * v9))
		result = -result;
	return result;
}

//----- (000B399A) --------------------------------------------------------
int /*__fastcall*/ sub_B399A(int a1, int a2)
{
	if (a1 < 0)
		JUMPOUT((int*)&loc_B39B3);
	return sub_B39AB(a1, a2);
}

//----- (000B39AB) --------------------------------------------------------
int /*__fastcall*/ sub_B39AB(unsigned int a1, int a2)
{
	int v2; // ebx
	int v3; // ecx
	unsigned int v4; // eax
	__int16 v5; // cx
	unsigned int v6; // edx
	int result; // eax

	v2 = a2;
	if (a1)
	{
		x_BitScanReverse((unsigned long *)&v3, a1);
		v4 = a1 << (31 - v3);
		v5 = (unsigned __int8)v3 + 0x3FFF;
		v6 = v4;
	}
	else
	{
		v6 = 0;
		v5 = 0;
	}
	result = 0;
	*(x_DWORD *)v2 = 0;
	*(x_DWORD *)(v2 + 4) = v6;
	*(x_WORD *)(v2 + 8) = v5;
	return result;
}

//----- (000B39E0) --------------------------------------------------------
int sub_B39E0(__int64 a1, int a2, x_BYTE *a3)
{
	int v3; // ecx
	signed __int64 v4; // rax
	int v5; // ecx
	bool v6; // zf
	unsigned int v7; // ST00_4
	unsigned int v8; // edx
	int v9; // et0
	__int16 v10; // cx

	//fix it
	v8 = 0;
	//fix it

	v3 = HIDWORD(a1);
	v4 = a1 << 11;
	v5 = v3 >> 20;
	LOWORD(v5) = v5 & 0x7FF;
	if ((x_WORD)v5)
	{
		if ((x_WORD)v5 == 2047)
		{
			LOWORD(v5) = 0x7FFF;
			v6 = (v4 & 0x7FFFFFFF00000000i64) == 0;
			if (!(v4 & 0x7FFFFFFF00000000i64))
				v6 = (x_DWORD)v4 == 0;
			if (!v6)
			{
				v7 = v4;
				LOWORD(v4) = -32511;
				sub_B1E68(v4, v5, a3);
				v4 = __PAIR__(v8, v7) | 0x4000000000000000i64;
			}
		}
		else
		{
			LOWORD(v5) = v5 + 15360;
		}
		HIDWORD(v4) |= 0x80000000;
	}
	else if (v4)
	{
		LOWORD(v5) = 15361;
		if (!HIDWORD(v4))
		{
			v9 = v4;
			LODWORD(v4) = 0;
			HIDWORD(v4) = v9;
			LOWORD(v5) = 15329;
		}
		while (v4 >= 0)
		{
			v4 *= 2i64;
			LOWORD(v5) = v5 - 1;
		}
	}
	else
	{
		v5 = 0;
	}
	*(_QWORD *)a2 = v4;
	v10 = __RCR__(2 * v5, __CFADD__(v5, v5));
	*(x_WORD *)(a2 + 8) = v10;
	return v4;
}

//----- (000B3A60) --------------------------------------------------------
int /*__fastcall*/ sub_B3A60(int a1)
{
	int v1; // ebx
	signed int v2; // edx
	unsigned int v3; // eax
	unsigned int v4; // ecx
	unsigned __int8 v5; // cf
	int result; // eax
	__int16 v7; // bx
	__int16 v8; // cx
	unsigned __int64 v9; // rt0

	v1 = a1;
	v2 = -256;
	v3 = *(x_DWORD *)(a1 + 4);
	v4 = v3 << 25;
	LOWORD(v4) = *(x_WORD *)(v1 + 8);
	if (__CFSHL__(v3, 25))
	{
		if (!(v3 << 25) && !*(x_DWORD *)v1)
			v2 = -512;
		v5 = __CFADD__(v3, 256);
		v3 += 256;
		if (v5)
		{
			v3 = 2147483648;
			LOWORD(v4) = v4 + 1;
		}
	}
	result = v2 & v3;
	v7 = v4;
	v8 = v4 & 0x7FFF;
	if (v8)
	{
		if (v8 == 0x7FFF)
		{
			result = __RCR__(((unsigned int)(2 * result) >> 8) | 0xFF000000, __CFADD__(v7, v7));
		}
		else
		{
			LOWORD(v4) = v8 - 16256;
			if ((v4 & 0x8000u) == 0)
			{
				if ((signed __int16)v4 < 255)
				{
					LODWORD(v9) = 2 * result;
					HIDWORD(v9) = v4;
					result = __RCR__(v9 >> 8, __CFADD__(v7, v7));
				}
				else
				{
					result = __RCR__(-16777216, __CFADD__(v7, v7));
				}
			}
			else
			{
				result = 0;
			}
		}
	}
	return result;
}

//----- (000B3ADF) --------------------------------------------------------
int sub_B3ADF(__int64 *a1, x_BYTE *a2)
{
	__int16 v2; // cx
	unsigned __int64 v3; // rax
	signed int v4; // esi
	unsigned __int8 v5; // cf
	unsigned __int16 v6; // cx
	int result; // eax
	unsigned __int8 v8; // cl
	int v9; // ST00_4

	v2 = *((x_WORD *)a1 + 4);
	v3 = *a1;
	v4 = -2048;
	if (__CFSHL__(v3, 22))
	{
		if (!((x_DWORD)v3 << 22))
			v4 = -4096;
		v5 = __CFADD__(v3, 2048i64);
		v3 += 2048i64;
		if (v5)
		{
			HIDWORD(v3) = 2147483648;
			++v2;
		}
	}
	LODWORD(v3) = v4 & v3;
	v6 = (v2 & 0x7FFF) - 15360;
	if (v6 >= 0x7FFu)
	{
		if (v6 < 0xC400u)
		{
			result = v3 >> 11;
			if (v6 != 17407)
			{
				v9 = result;
				LOWORD(result) = -31736;
				sub_B1E68(result, v6, a2);
				result = v9;
			}
		}
		else if ((signed __int16)v6 < -52)
		{
			result = 0;
		}
		else
		{
			v8 = 12 - v6;
			if (v8 >= 0x20u)
			{
				v8 -= 32;
				v4 = v3;
				v3 = HIDWORD(v3);
			}
			result = ((unsigned int)(__PAIR__((uint32)v3, (uint32)v4) >> v8)
				+ __PAIR__((uint32)(v3 >> (v8 & 0x1F)), (uint32)(__PAIR__((uint32)v3, (uint32)v4) >> v8))) >> 32;
		}
	}
	else if (v6)
	{
		result = v3 >> 11;
	}
	else
	{
		result = v3 >> 12;
	}
	return result;
}

//----- (000B3BA6) --------------------------------------------------------
signed int /*__fastcall*/ sub_B3BA6(signed int result, int a2)
{
	signed int v2; // ecx
	signed int v3; // eax

	v2 = result >> 23;
	LOWORD(v2) = (unsigned __int8)(result >> 23);
	if ((unsigned __int8)(result >> 23))
	{
		v3 = result << 8;
		if ((x_BYTE)v2 == -1)
		{
			LOWORD(v2) = -1;
			v3 &= 0x7FFFFFFFu;
			if (v3)
				v3 |= 0x40000000u;
		}
		else
		{
			LOWORD(v2) = v2 + 16256;
		}
		LOWORD(v2) = __RCR__(2 * v2, __CFADD__(v2, v2));
		result = v3 | 0x80000000;
	}
	*(x_DWORD *)a2 = 0;
	*(x_DWORD *)(a2 + 4) = result;
	*(x_WORD *)(a2 + 8) = v2;
	return result;
}

//----- (000B3C6B) --------------------------------------------------------
unsigned int /*__fastcall*/ sub_B3C6B(unsigned int result, signed __int16 a2)
{
	unsigned int v2; // edi
	int v3; // ebx
	bool v4; // zf
	__int16 v5; // bx
	unsigned __int8 v6; // of
	__int16 v7; // bx
	int v8; // ecx
	bool v9; // sf
	int v10; // eax
	unsigned int v11; // ecx
	unsigned __int8 v12; // tt
	bool v13; // zf
	unsigned __int8 v14; // cf
	int v15; // et0
	int v16; // esi
	int v17; // eax
	unsigned int v18; // esi
	unsigned __int8 v19; // tt
	bool v20; // zf
	unsigned __int8 v21; // cf
	int v22; // et0

	v2 = result;
	v3 = *(unsigned __int16 *)(result + 8);
	v4 = a2 == 1024;
	if (a2 != 1024)
		v4 = a2 == 2048;
	if (v4 && (v3 & 0x8000) != 0)
		a2 ^= 0xC00u;
	if (a2 == 3072)
		a2 = 1024;
	v5 = v3 & 0x7FFF;
	v6 = __OFSUB__(v5, 16447);
	v7 = v5 - 16447;
	if ((v7 < 0) ^ v6)
	{
		v8 = *(x_DWORD *)result;
		v6 = __OFADD__(32, v7);
		v9 = (signed __int16)(v7 + 32) < 0;
		LOWORD(v3) = v7 + 32;
		if (!((unsigned __int8)v9 ^ v6))
		{
			v10 = x_DWORD_B3BEB[v3];
			v11 = v10 & v8;
			*(x_DWORD *)v2 ^= v11;
			result = v10 + 1;
			if (a2 == 1024)
				return result;
			if (!a2)
			{
				v11 *= 2;
				if (result > v11)
					return result;
				if (result == v11)
				{
					v12 = __CFSHL__(result, 1);
					result = __ROL4__(result, 1);
					if (v12)
						v13 = (result & *(x_DWORD *)(v2 + 4)) == 0;
					else
						v13 = (result & *(x_DWORD *)v2) == 0;
					if (v13)
						return result;
					result = __ROR4__(result, 1);
				}
			}
			if (v11)
			{
				v14 = __CFADD__(result, *(_QWORD *)v2);
				*(_QWORD *)v2 += result;
				if (v14)
				{
					v15 = __RCR__(*(x_DWORD *)(v2 + 4), v14);
					*(x_DWORD *)(v2 + 4) = v15;
					++*(x_WORD *)(v2 + 8);
				}
			}
			return result;
		}
		*(x_DWORD *)result = 0;
		v16 = *(x_DWORD *)(result + 4);
		v6 = __OFADD__(32, (x_WORD)v3);
		v9 = (signed __int16)(v3 + 32) < 0;
		LOWORD(v3) = v3 + 32;
		if ((unsigned __int8)v9 ^ v6)
		{
			if (a2 != 1024 && (a2 || (x_WORD)v3 == -1 && (v16 != 0x80000000 || v8)))
			{
				*(x_DWORD *)(result + 4) = 2147483648;
				*(x_WORD *)(result + 8) |= 0x3FFFu;
			}
			else
			{
				result = 0;
				*(x_DWORD *)(v2 + 4) = 0;
				*(x_WORD *)(v2 + 8) = 0;
			}
			return result;
		}
		v17 = x_DWORD_B3BEB[v3];
		v18 = v17 & v16;
		*(x_DWORD *)(v2 + 4) ^= v18;
		result = v17 + 1;
		if (a2 == 1024)
			return result;
		if (!a2)
		{
			v19 = __CFSHL__(v8, 1);
			v8 = __ROL4__(v8, 1);
			v18 += v19 + v18;
			if (result > v18)
				return result;
			if (result == v18)
			{
				if (v8)
				{
				LABEL_35:
					v21 = __CFADD__(result, *(x_DWORD *)(v2 + 4));
					*(x_DWORD *)(v2 + 4) += result;
					if (v21)
					{
						v22 = __RCR__(*(x_DWORD *)(v2 + 4), v21);
						*(x_DWORD *)(v2 + 4) = v22;
						++*(x_WORD *)(v2 + 8);
					}
					return result;
				}
				v14 = __CFADD__(result, result);
				v20 = 2 * result == 0;
				result *= 2;
				if (!v14)
					v20 = (result & *(x_DWORD *)(v2 + 4)) == 0;
				if (v20)
					return result;
				result >>= 1;
			}
		}
		if (!(v18 | v8))
			return result;
		goto LABEL_35;
	}
	return result;
}
// B3BEB: using guessed type int x_DWORD_B3BEB[];

//----- (000B3DF8) --------------------------------------------------------
__int16 sub_B3DF8(int a1, int a2, int a3, x_BYTE *a4, int a5)
{
	char v5; // ch
	char v6; // dl
	char v7; // ch

	//fix it
	v7 = 0;
	//fix it

	if (2 * *(x_WORD *)(a1 + 8))
	{
		if (2 * *(x_WORD *)(a2 + 8))
		{
			v5 = *(x_BYTE *)(a1 + 9);
			sub_B35DB(a1, a2, a4, a5);
			LOWORD(a1) = sub_B3EAE(a3, a4, a5);
			v6 = *(x_BYTE *)(a3 + 9);
			if (v7 < 0)
			{
				if (v6 > 0)
					LOWORD(a1) = sub_B33A6(a3, a5, 560513589, -921707870, 49152);
			}
			else if (v6 < 0)
			{
				LOWORD(a1) = sub_B33A6(a3, a5, 560513589, -921707870, 0x4000);
			}
		}
		else
		{
			LOWORD(a1) = *(x_WORD *)(a1 + 8) & 0x8000 | 0x3FFF;
			*(x_WORD *)(a3 + 8) = a1;
			*(x_DWORD *)(a3 + 4) = -921707870;
			*(x_DWORD *)a3 = 560513589;
		}
	}
	else if (*(x_BYTE *)(a2 + 9) >= 0)
	{
		*(x_WORD *)(a3 + 8) = 0;
		*(x_DWORD *)(a3 + 4) = 0;
		*(x_DWORD *)a3 = 0;
	}
	else
	{
		*(x_WORD *)(a3 + 8) = 0x4000;
		*(x_DWORD *)(a3 + 4) = -921707870;
		*(x_DWORD *)a3 = 560513589;
	}
	return a1;
}

//----- (000B3EAE) --------------------------------------------------------
__int16 /*__spoils<ecx>*/ sub_B3EAE(int a1, x_BYTE *a2, int a3)
{
	int v3; // edi
	char v4; // cl
	__int16 result; // ax
	int v6; // edx
	unsigned __int16 v7; // ax
	unsigned __int8 v8; // cf
	bool v9; // zf
	unsigned int v10; // eax
	int v11; // esi
	int v12; // edx
	int v13; // ST08_4
	int v14; // ST04_4
	int v15; // ST00_4
	unsigned __int64 v16; // rax
	unsigned __int64 v17; // rax
	int v18; // ebx
	int v19; // edx
	char v20; // cl
	unsigned __int8 v21; // ch
	char v22; // ch

	//fix it
	v6 = 0;
	v12 = 0;
	v19 = 0;
	v20 = 0;
	v21 = 0;
	//fix it

	v3 = a1;
	v4 = *(x_BYTE *)(a1 + 9);
	*(x_BYTE *)(v3 + 9) &= 0x7Fu;
	if (*(x_WORD *)(a1 + 8) != 0x3FFF || *(x_DWORD *)(a1 + 4) != 0x80000000 || *(x_DWORD *)a1)
	{
		if (*(x_WORD *)(a1 + 8) >= 0x3FFF)
		{
			LOWORD(a3) = *(x_WORD *)(a1 + 8);
			a3 <<= 16;
			LOWORD(a3) = 0x3FFF;
			*(x_DWORD *)a1 = sub_B3605(0x8000000000000000i64, *(x_DWORD *)(a1 + 4), *(x_DWORD *)a1, a2, a3);
			*(x_DWORD *)(v3 + 4) = v6;
			*(x_WORD *)(v3 + 8) = 0x3FFF;
		}
		v7 = *(x_WORD *)(v3 + 8);
		v8 = v7 < 0x3FFDu;
		v9 = v7 == 16381;
		if (v7 == 16381)
		{
			v10 = *(x_DWORD *)(v3 + 4);
			v8 = v10 < 0x8930A2F4;
			v9 = v10 == -1993301260;
			if (v10 == -1993301260)
			{
				v8 = *(x_DWORD *)v3 < 0xF66AB09B;
				v9 = *(x_DWORD *)v3 == -160780133;
			}
		}
		if (!(v8 | (unsigned __int8)v9))
		{
			HIWORD(v11) = 0x3FFF;
			LOWORD(v11) = *(x_WORD *)(v3 + 8);
			v13 = sub_B33D6(*(_QWORD *)v3, -575416510, -1033546850, v11);
			v14 = v12;
			v15 = v11;
			HIWORD(v11) = 0x3FFF;
			LOWORD(v11) = *(x_WORD *)(v3 + 8);
			LODWORD(v16) = sub_B37DA(*(_QWORD *)v3, 0xDDB3D742, 0xC265539E, v11);
			v11 = __ROL4__(v11, 16);
			LOWORD(v11) = -16385;
			v11 = __ROL4__(v11, 16);
			LODWORD(v17) = sub_B33D6(v16, 2147483648, 0, v11);
			v18 = v15 << 16;
			LOWORD(v18) = v11;
			a3 = v18;
			*(x_DWORD *)v3 = sub_B3605(v17, v14, v13, a2, v18);
			*(x_DWORD *)(v3 + 4) = v19;
			*(x_WORD *)(v3 + 8) = v18;
		}
		result = sub_B4A2A((int *)v3, (int)&x_WORD_B3D9E, a3);
		v8 = v21 & 1;
		v22 = v21 >> 1;
		if (v8)
			result = sub_B33A6(v3, a3, 1805331491, -2046127679, 16382);
		if (v22 & 1)
		{
			result = sub_B33A6(v3, a3, 560513589, -921707870, 49151);
			*(x_BYTE *)(v3 + 9) ^= 0x80u;
		}
		if (v20 < 0)
			*(x_BYTE *)(v3 + 9) ^= 0x80u;
	}
	else
	{
		*(x_DWORD *)a1 = 560513589;
		*(x_DWORD *)(a1 + 4) = -921707870;
		LOBYTE(result) = -2;
		HIBYTE(result) = v4 & 0x80 | 0x3F;
		*(x_WORD *)(v3 + 8) = result;
	}
	return result;
}
// B3D9E: using guessed type __int16 x_WORD_B3D9E;

//----- (000B4011) --------------------------------------------------------
int sub_B4011(int a1, int a2, int a3)
{
	int result; // eax
	int v4; // ST00_4
	__int16 v5; // si
	int v6; // edx

	//fix it
	v6 = 0;
	//fix it

	if (!*(x_WORD *)(a1 + 8) && !*(x_DWORD *)(a1 + 4) && !*(x_DWORD *)a1)
		return 0;
	if (*(x_WORD *)(a2 + 8) || *(x_DWORD *)(a2 + 4) || *(x_DWORD *)a2)
	{
		v4 = a1;
		v5 = *(x_WORD *)(a1 + 8);
		LOWORD(a3) = *(x_WORD *)(a2 + 8);
		*(x_DWORD *)a1 = sub_B4077(*(_QWORD *)a1, *(x_DWORD *)(a2 + 4), *(x_DWORD *)a2, a3, v5);
		*(x_DWORD *)(v4 + 4) = v6;
		*(x_WORD *)(v4 + 8) = v5;
		result = a3;
	}
	else
	{
		*(x_DWORD *)a1 = 0;
		*(x_DWORD *)(a1 + 4) = 0;
		*(x_WORD *)(a1 + 8) = 0;
		result = 0;
	}
	return result;
}

//----- (000B4077) --------------------------------------------------------
int sub_B4077(__int64 a1, unsigned int a2, unsigned int a3, __int16 a4, __int16 a5)
{
	int v5; // esi
	int v6; // edi
	unsigned __int8 v7; // of
	int v8; // esi
	int v9; // edi
	bool v10; // cf
	int v11; // esi
	int v12; // ett

	v5 = a5 & 0x7FFF;
	v6 = a4 & 0x7FFF;
	v7 = __OFSUB__(v5, v6);
	v8 = v5 - v6;
	if (!((v8 < 0) ^ v7))
	{
		v9 = 0;
	LABEL_3:
		v10 = a2 < HIDWORD(a1);
		if (a2 == HIDWORD(a1) && (v10 = a3 < (unsigned int)a1, a3 == (x_DWORD)a1) || v10)
		{
		LABEL_6:
			a1 -= __PAIR__(a2, a3);
			v10 = 1;
		}
		while (1)
		{
			v9 += (unsigned __int8)v10 + v9;
			v7 = __OFSUB__(v8--, 1);
			if ((v8 < 0) ^ v7)
				break;
			v10 = __CFADD__(a1, a1);
			a1 *= 2i64;
			if (v10)
				goto LABEL_6;
			v10 = 0;
			if (a1 < 0)
				goto LABEL_3;
		}
		v11 = 0;
		if (a1)
		{
			while (a1 >= 0)
			{
				v12 = (a1 + (unsigned __int64)(unsigned int)a1) >> 32;
				LODWORD(a1) = 2 * a1;
				HIDWORD(a1) += v12;
				--v11;
			}
		}
	}
	return a1;
}

//----- (000B41E0) --------------------------------------------------------
int sub_B41E0(int a1, x_BYTE *a2, int a3)
{
	int v3; // ST0C_4

	v3 = a1;
	sub_B33A6(a1, a3, 0, 2147483648, 0x3FFF);
	return sub_B41F9(v3, a2, a3);
}

//----- (000B41F9) --------------------------------------------------------
int sub_B41F9(int a1, x_BYTE *a2, int a3)
{
	int v3; // ST00_4
	int v4; // eax
	int v5; // edx
	int v6; // ST00_4
	int v7; // esi
	int result; // eax
	int v9; // edx

	//fix it
	v5 = 0;
	v9 = 0;
	//fix it

	v3 = a1;
	sub_B423C(a1, a2);
	v4 = v3;
	v6 = v5;
	sub_B37B0(v4, v5, a3);
	LOWORD(a3) = *(x_WORD *)(v6 + 8);
	v7 = a3 << 16;
	LOWORD(v7) = 0x3FFF;
	result = sub_B37DA(0xB8AA3B295C17F0BDi64, *(x_DWORD *)(v6 + 4), *(x_DWORD *)v6, v7);
	*(x_DWORD *)v6 = result;
	*(x_DWORD *)(v6 + 4) = v9;
	*(x_WORD *)(v6 + 8) = 0x3FFF;
	return result;
}

//----- (000B423C) --------------------------------------------------------
int sub_B423C(int a1, x_BYTE *a2)
{
	int v2; // edi
	unsigned __int64 v3; // rax
	unsigned __int64 v4; // rax
	bool v5; // cf
	bool v6; // zf
	unsigned __int64 v7; // kr00_8
	int v8; // esi
	int v9; // eax
	int v10; // edx
	unsigned __int64 v11; // rax
	unsigned __int64 v12; // kr08_8
	int v13; // edx
	unsigned int v14; // eax
	int v15; // edx
	unsigned int v16; // ST08_4
	int v17; // ST04_4
	int v18; // eax
	int v19; // edx
	unsigned __int64 v20; // rax
	unsigned __int64 v21; // rax
	unsigned __int64 v22; // rax
	unsigned __int64 v23; // rax
	int v24; // esi
	int result; // eax
	int v26; // edx
	int v27; // ecx
	int v28; // ST18_4
	int v29; // ST14_4
	__int16 v30; // ST10_2
	int v31; // esi
	unsigned __int64 v32; // rax
	int v33; // edx
	int v34; // ST18_4
	int v35; // ST14_4
	__int16 v36; // ST10_2
	int v37; // esi
	unsigned __int64 v38; // rax
	int v39; // [esp+Ch] [ebp-18h]

	//fix it
	v10 = 0;
	v11 = 0;
	v13 = 0;
	v14 = 0;
	v15 = 0;
	v20 = 0;
	v26 = 0;
	v33 = 0;
	//fix it

	v2 = a1;
	v39 = *(unsigned __int16 *)(a1 + 8) - 16382;
	*(x_WORD *)(a1 + 8) = 16382;
	LODWORD(v3) = *(x_DWORD *)a1;
	HIDWORD(v3) = *(x_DWORD *)(v2 + 4);
	LODWORD(v4) = sub_B33D6(v3, 2147483648, 0, -1073856514);
	v5 = *(x_WORD *)(v2 + 8) < 0x3FFEu;
	v6 = *(x_WORD *)(v2 + 8) == 16382;
	if (*(x_WORD *)(v2 + 8) == 16382)
	{
		v5 = *(x_DWORD *)(v2 + 4) < 0xB504F333;
		v6 = *(x_DWORD *)(v2 + 4) == -1257966797;
		if (*(x_DWORD *)(v2 + 4) == -1257966797)
		{
			v5 = *(x_DWORD *)v2 < 0xF9DE6484;
			v6 = *(x_DWORD *)v2 == -102865788;
		}
	}
	if ((unsigned __int8)v5 | (unsigned __int8)v6)
	{
		*(_QWORD *)v2 = v4;
		*(x_WORD *)(v2 + 8) = 16382;
		--v39;
	}
	else
	{
		LODWORD(v4) = sub_B33D6(v4, 2147483648, 0, -1073856514);
	}
	v7 = v4;
	v8 = (unsigned __int16)(*(x_WORD *)(v2 + 8) - 1) | 0x3FFE0000;
	v9 = sub_B33D6(*(_QWORD *)v2, 2147483648, 0, v8);
	v8 <<= 16;
	LOWORD(v8) = 16382;
	LODWORD(v11) = sub_B3605(v7, v10, v9, a2, v8);
	v12 = v11;
	v8 <<= 16;
	LOWORD(v8) = 16382;
	*(x_DWORD *)v2 = sub_B37DA(v11, HIDWORD(v11), v11, v8);
	*(x_DWORD *)(v2 + 4) = v13;
	*(x_WORD *)(v2 + 8) = 16382;
	sub_B49D8((int)&x_DWORD_B41B8, v8);
	v16 = v14;
	v17 = v15;
	v18 = *(x_DWORD *)v2;
	v19 = *(x_DWORD *)(v2 + 4);
	LOWORD(v8) = *(x_WORD *)(v2 + 8);
	sub_B49D8((int)&x_WORD_B419A, v8);
	v8 = __ROL4__(v8, 16);
	LOWORD(v8) = 16382;
	v8 = __ROL4__(v8, 16);
	LODWORD(v21) = sub_B3605(v20, v17, v16, a2, v8);
	v8 = __ROL4__(v8, 16);
	LOWORD(v8) = *(x_WORD *)(v2 + 8);
	v8 = __ROL4__(v8, 16);
	LODWORD(v22) = sub_B37DA(v21, *(x_DWORD *)(v2 + 4), *(x_DWORD *)v2, v8);
	v8 = __ROL4__(v8, 16);
	LOWORD(v8) = 16382;
	v8 = __ROL4__(v8, 16);
	LODWORD(v23) = sub_B37DA(v22, HIDWORD(v12), v12, v8);
	v8 = __ROL4__(v8, 16);
	LOWORD(v8) = 16382;
	v24 = __ROL4__(v8, 16);
	result = sub_B33D6(v23, SHIDWORD(v12), v12, v24);
	v27 = v39;
	if (v39)
	{
		v28 = result;
		v29 = v26;
		v30 = v24;
		sub_B399A(v27, v2);
		v31 = *(unsigned __int16 *)(v2 + 8) | 0xBFF20000;
		LODWORD(v32) = sub_B37DA(*(_QWORD *)v2, 0xDE8082E3, 0x865435Cu, v31);
		v31 = __ROL4__(v31, 16);
		LOWORD(v31) = v30;
		v31 = __ROL4__(v31, 16);
		v34 = sub_B33D6(v32, v29, v28, v31);
		v35 = v33;
		v36 = v31;
		v37 = *(unsigned __int16 *)(v2 + 8) | 0x3FFE0000;
		LODWORD(v38) = sub_B37DA(*(_QWORD *)v2, 0xB1800000, 0, v37);
		v37 = __ROL4__(v37, 16);
		LOWORD(v37) = v36;
		v24 = __ROL4__(v37, 16);
		result = sub_B33D6(v38, v35, v34, v24);
	}
	*(x_DWORD *)v2 = result;
	*(x_DWORD *)(v2 + 4) = v26;
	*(x_WORD *)(v2 + 8) = v24;
	return result;
}
// B419A: using guessed type __int16 x_WORD_B419A;
// B41B8: using guessed type int x_DWORD_B41B8;

//----- (000B44D4) --------------------------------------------------------
int sub_B44D4(int a1, int a2)
{
	int v2; // ST10_4
	__int16 v3; // si
	int v4; // edx
	char v5; // al
	int v6; // edi
	int v7; // esi
	__int16 v8; // ax
	int v9; // ecx
	__int16 v10; // ax
	__int16 v11; // ST04_2
	unsigned __int64 v12; // rax
	unsigned __int64 v13; // rax
	int v14; // esi
	char v15; // cl
	bool v16; // zf
	int v17; // ecx
	unsigned int v18; // ebx
	int v20; // [esp+0h] [ebp-18h]
	int v21; // [esp+0h] [ebp-18h]
	int v22; // [esp+4h] [ebp-14h]
	__int16 v23; // [esp+4h] [ebp-14h]
	unsigned __int64 v24; // [esp+Ch] [ebp-Ch]
	signed __int16 v25; // [esp+14h] [ebp-4h]
	x_BYTE savedregs[20]; // [esp+18h] [ebp+0h]

	//fix it
	v4 = 0;
	v12 = 0;
	//fix it

	v2 = (unsigned __int16)((*(x_WORD *)(a1 + 8) & 0x7FFF) - 16382);
	v22 = a2;
	v20 = a1;
	v3 = *(x_WORD *)(a1 + 8);
	*(x_DWORD *)a1 = sub_B4077(*(_QWORD *)a1, 0xC90FDAA2, 0x2168C235u, 16382, v3);
	*(x_DWORD *)(v20 + 4) = v4;
	*(x_WORD *)(v20 + 8) = v3;
	v5 = -2;
	v6 = v20;
	v7 = v22;
	if (*(x_BYTE *)(v20 + 9) < 0)
	{
		sub_B33A6(v20, v22, 560513589, -921707870, 16382);
		v5 = -3;
	}
	HIBYTE(v8) = v22;
	LOBYTE(v8) = ((v22 & 2) + v5) & 7;
	v23 = v8;
	if (v8 & 1)
	{
		sub_B33A6(v6, v7, 560513589, -921707870, 49150);
		*(x_BYTE *)(v6 + 9) ^= 0x80u;
	}
	v9 = (unsigned __int16)(*(x_WORD *)(v6 + 8) - 16382);
	if ((signed __int16)v9 >= -32)
	{
		if ((v9 & 0x8000u) == 0)
			LOWORD(v9) = 0;
		LOWORD(v9) = -(signed __int16)v9;
		if ((signed __int16)v9 > 8)
			LOWORD(v9) = 8;
		LOWORD(v9) = x_WORD_B44C2[v9];
		v21 = v9;
		HIBYTE(v10) = HIBYTE(v23);
		LOBYTE(v10) = (v23 + 1) & 2;
		if ((x_BYTE)v10 || HIBYTE(v23) == 1)
		{
			v11 = v10;
			LOWORD(v7) = *(x_WORD *)(v6 + 8);
			v7 <<= 16;
			LOWORD(v7) = *(x_WORD *)(v6 + 8);
			sub_B37DA(*(_QWORD *)v6, *(x_DWORD *)(v6 + 4), *(x_DWORD *)v6, v7);
			sub_B49D8((int)x_DWORD_B4468 + 10 * v21, v7);
			v24 = v12;
			v25 = v7;
			v10 = v11;
		}
		if (!(x_BYTE)v10 || HIBYTE(v10) == 1)
			sub_B4A2A((int *)v6, (int)&x_WORD_B440E[5 * v21], v7);
	}
	else
	{
		v24 = 0x8000000000000000i64;
		v25 = 0x3FFF;
	}
	if (((x_BYTE)v23 + 1) & 2)
	{
		v13 = v24;
		LOWORD(v7) = v25;
	}
	else
	{
		v13 = *(_QWORD *)v6;
		LOWORD(v7) = *(x_WORD *)(v6 + 8);
	}
	if (v23 & 4)
		LOWORD(v7) = v7 ^ 0x8000;
	if (HIBYTE(v23) == 1)
	{
		v14 = __ROL4__(v7, 16);
		v15 = v23 + 2;
		if (((x_BYTE)v23 + 3) & 2)
		{
			v16 = (v15 & 4) == 0;
			v17 = HIDWORD(v24);
			v18 = v24;
			LOWORD(v14) = v25;
		}
		else
		{
			v16 = (v15 & 4) == 0;
			v18 = *(x_DWORD *)v6;
			v17 = *(x_DWORD *)(v6 + 4);
			LOWORD(v14) = *(x_WORD *)(v6 + 8);
		}
		if (!v16)
			v14 ^= 0x8000u;
		v7 = __ROL4__(v14, 16);
		if (v18 || v17 || v7 & 0x7FFF0000)
		{
			LODWORD(v13) = sub_B3605(v13, v17, v18, savedregs, v7);
		}
		else
		{
			v13 = 0x8000000000000000i64;
			LOWORD(v7) = v7 | 0x7FFF;
		}
	}
	*(_QWORD *)v6 = v13;
	*(x_WORD *)(v6 + 8) = v7;
	return v13;
}
// B440E: using guessed type __int16 x_WORD_B440E[];
// B4468: using guessed type int x_DWORD_B4468[19];
// B44C2: using guessed type __int16 x_WORD_B44C2[];

//----- (000B46CB) --------------------------------------------------------
int /*__fastcall*/ sub_B46CB(int a1)
{
	return sub_B44D4(a1, 0);
}

//----- (000B46D5) --------------------------------------------------------
int /*__fastcall*/ sub_B46D5(int a1)
{
	return sub_B44D4(a1, 2);
}

//----- (000B46E2) --------------------------------------------------------
int /*__fastcall*/ sub_B46E2(int a1)
{
	return sub_B44D4(a1, 1);
}

//----- (000B4718) --------------------------------------------------------
int /*__fastcall*/ sub_B4718(int a1, int a2, int a3, int a4)
{
	int v4; // edi
	signed int v5; // esi
	__int16 v6; // cx
	bool v7; // zf
	unsigned __int16 v8; // bx
	int v9; // ecx
	signed __int64 v10; // rax
	unsigned __int8 v11; // cf
	__int16 v12; // bx
	int v13; // esi
	unsigned __int64 v14; // rax
	int v15; // esi
	unsigned __int64 v16; // rax
	signed __int32 v17; // edx
	int v18; // esi
	unsigned __int64 v19; // rax
	int v20; // esi
	unsigned __int64 v21; // rax
	unsigned __int64 v22; // rax
	int v23; // esi
	unsigned __int64 v24; // rax
	signed __int32 v25; // edx
	int v26; // esi
	unsigned __int64 v27; // rax
	int v28; // eax
	int v29; // edx
	unsigned int v30; // ecx
	int(*v31)(); // esi
	int v32; // eax
	unsigned __int64 v33; // rax
	int v34; // et0
	int v35; // edx
	int v36; // esi
	int v38; // [esp-2Ch] [ebp-38h]
	int v39; // [esp-28h] [ebp-34h]
	unsigned int v40; // [esp-24h] [ebp-30h]
	int v41; // [esp-20h] [ebp-2Ch]
	int v42; // [esp-1Ch] [ebp-28h]
	int v43; // [esp-18h] [ebp-24h]
	int v44; // [esp-14h] [ebp-20h]
	int v45; // [esp-10h] [ebp-1Ch]
	int v46; // [esp-8h] [ebp-14h]

	//fix it
	v14 = 0;
	v17 = 0;
	v22 = 0;
	v25 = 0;
	v29 = 0;
	v35 = 0;
	//fix it

	v46 = a4;
	v4 = a1;
	v5 = 0;
	v6 = *(x_WORD *)(a1 + 8);
	*(x_BYTE *)(v4 + 9) &= 0x7Fu;
	v7 = *(x_WORD *)(a1 + 8) == 0;
	if (!*(x_WORD *)(a1 + 8))
		v7 = *(_QWORD *)a1 == 0i64;
	if (v7)
	{
		v9 = 0;
	}
	else
	{
		if (v6 < 0)
		{
			v5 = -1;
			sub_B33A6(a1, -1, 0, 2147483648, 49151);
			*(x_BYTE *)(v4 + 9) ^= 0x80u;
		}
		v8 = *(x_WORD *)(v4 + 8) + 4;
		v9 = 0;
		v10 = *(_QWORD *)v4;
		while (v8 >= 0x3FFFu)
		{
			v11 = __CFADD__(v10, v10);
			v10 *= 2i64;
			v9 += v11 + v9;
			--v8;
		}
		if (v10)
		{
			while (v10 >= 0)
			{
				v10 *= 2i64;
				--v8;
			}
			v12 = v8 - 4;
		}
		else
		{
			v12 = 0;
		}
		*(_QWORD *)v4 = v10;
		*(x_WORD *)(v4 + 8) = v12;
	}
	v45 = v5;
	v44 = v9;
	LOWORD(v5) = *(x_WORD *)(v4 + 8);
	v13 = v5 << 16;
	LOWORD(v13) = *(x_WORD *)(v4 + 8);
	LODWORD(v14) = sub_B37DA(*(_QWORD *)v4, *(x_DWORD *)(v4 + 4), *(x_DWORD *)v4, v13);
	v42 = HIDWORD(v14);
	v43 = v14;
	v41 = v13;
	v15 = (unsigned __int16)v13 | 0x40030000;
	LODWORD(v16) = x_InterlockedExchange((volatile long*)&v43, sub_B33D6(v14, -1501390215, 468852620, v15));
	HIDWORD(v16) = x_InterlockedExchange((volatile long*)&v42, v17);
	v18 = (unsigned __int16)x_InterlockedExchange((volatile long*)&v41, v15) | 0x3FFA0000;
	LODWORD(v19) = sub_B37DA(v16, 0xEC96F0D6, 0x9D7BFDBu, v18);
	v20 = (unsigned __int16)v18 | 0x40010000;
	LODWORD(v21) = sub_B33D6(v19, -422247142, -449388153, v20);
	v20 = __ROL4__(v20, 16);
	LOWORD(v20) = *(x_WORD *)(v4 + 8);
	v20 = __ROL4__(v20, 16);
	LODWORD(v22) = sub_B37DA(v21, *(x_DWORD *)(v4 + 4), *(x_DWORD *)v4, v20);
	v39 = HIDWORD(v22);
	v40 = v22;
	v38 = v20;
	v23 = __ROL4__(v20 ^ 0x8000, 16);
	LOWORD(v23) = v41;
	v23 = __ROL4__(v23, 16);
	LODWORD(v24) = x_InterlockedExchange((volatile long*)&v40, sub_B33D6(v22, v42, v43, v23));
	HIDWORD(v24) = x_InterlockedExchange((volatile long*)&v39, v25);
	//fix it:v26 = __ROL4__(x_InterlockedExchange(&v38, v23), 16);
	LOWORD(v26) = v41;
	v26 = __ROL4__(v26, 16);
	LODWORD(v27) = sub_B33D6(v24, v42, v43, v26);
	v26 = __ROL4__(v26, 16);
	LOWORD(v26) = v38;
	v26 = __ROL4__(v26, 16);
	v28 = sub_B3605(v27, v39, v40, (x_BYTE*)&v41, v26);
	*(x_DWORD *)v4 = v28;
	*(x_DWORD *)(v4 + 4) = v29;
	*(x_WORD *)(v4 + 8) = v26;
	v30 = v44;
	v31 = sub_B46F0;
	while (v30)
	{
		v11 = v30 & 1;
		v30 >>= 1;
		if (v11)
		{
			v44 = v30;
			v43 = (int)v31;
			LOWORD(v28) = *(x_WORD *)(v4 + 8);
			v32 = v28 << 16;
			LOWORD(v32) = *((x_WORD *)v31 + 4);
			HIDWORD(v33) = *((x_DWORD *)v31 + 1);
			v34 = v32;
			LODWORD(v33) = *(x_DWORD *)v31;
			v28 = sub_B37DA(v33, *(x_DWORD *)(v4 + 4), *(x_DWORD *)v4, v34);
			*(x_DWORD *)v4 = v28;
			*(x_DWORD *)(v4 + 4) = v35;
			*(x_WORD *)(v4 + 8) = v34;
			v31 = (int(*)())v43;
			v30 = v44;
		}
		v31 = (int(*)())((char *)v31 + 10);
	}
	v36 = v45;
	*(x_WORD *)(v4 + 8) += v45;
	return sub_B33A6(v4, v36, 0, 2147483648, 49151);
}
// B46F0: using guessed type int sub_B46F0();

//----- (000B48EC) --------------------------------------------------------
int /*__fastcall*/ sub_B48EC(unsigned __int64 a1)
{
	__int16 v1; // cx
	unsigned int v2; // ebx
	unsigned __int16 v3; // cx
	__int16 v4; // cx
	unsigned int v5; // edi
	__int16 v6; // cx
	__int16 v7; // cx
	unsigned __int8 v8; // tt
	unsigned int v9; // ecx
	unsigned int v10; // esi
	unsigned int v11; // eax
	unsigned int v12; // edx
	unsigned __int64 v13; // rt2
	unsigned int v14; // esi
	int v15; // esi
	unsigned int v16; // ecx
	int v17; // eax
	unsigned __int8 v18; // cf
	unsigned __int8 v19; // tt
	int v20; // eax
	unsigned __int8 v21; // tt
	x_DWORD *v23; // [esp-10h] [ebp-18h]

	v1 = *(x_WORD *)(a1 + 8);
	v2 = *(x_DWORD *)a1;
	if (*(x_DWORD *)a1)
		goto LABEL_7;
	if (*(x_DWORD *)(a1 + 4))
	{
		if (v1 == 0x7FFF)
			return a1;
	LABEL_7:
		if ((v1 & 0x7FFF) == 0x7FFF)
			goto LABEL_5;
		v18 = __CFADD__(v1, v1);
		v3 = 2 * v1;
		if (v18)
			goto LABEL_5;
		v4 = v3 >> 1;
		if (v4 && !__CFADD__(*(x_DWORD *)(a1 + 4), *(x_DWORD *)(a1 + 4)))
		{
		LABEL_4:
			*(x_WORD *)(a1 + 8) = -1;
			*(x_DWORD *)(a1 + 4) = 0;
			*(x_DWORD *)a1 = 0;
		LABEL_5:
			*(x_BYTE *)(a1 + 7) |= 0xC0u;
			return a1;
		}
		HIDWORD(a1) = *(x_DWORD *)(a1 + 4);
		v5 = 0;
		v23 = (x_DWORD *)a1;
		v6 = v4 - 0x3FFF;
		v18 = v6 & 1;
		v7 = v6 >> 1;
		if (!v18)
		{
			v18 = BYTE4(a1) & 1;
			HIDWORD(a1) >>= 1;
			v8 = __CFRCR__(v2, v18);
			v2 = __RCR__(v2, v18);
			v5 = __RCR__(0, v8);
		}
		*(x_WORD *)(a1 + 8) = v7 + 0x3FFF;
		v9 = HIDWORD(a1);
		LODWORD(a1) = v2;
		v10 = __RCR__(HIDWORD(a1)++, 1);
		if (HIDWORD(a1))
		{
			--HIDWORD(a1);
			while (1)
			{
				v13 = a1 % v10;
				v11 = a1 / v10;
				v12 = v13;
				v14 = v10 - 1;
				if (v14 <= v11)
					break;
				v10 = __RCR__(v11 + v14 + 1, __CFADD__(v11, v14 + 1));
				a1 = __PAIR__(v9, v2);
			}
			v15 = v14 + 1;
			v16 = v11;
			v17 = __PAIR__(v12, v5) / (unsigned int)v15;
			v10 = v16 + v15;
		}
		else
		{
			v18 = v2 < v10;
			if (v2 == v10)
			{
			LABEL_21:
				*v23 = a1;
				v23[1] = v10 + v18;
				return a1;
			}
			v17 = __PAIR__(v2, v5) / v10;
		}
		v19 = __CFRCR__(v10, 1);
		v10 = __RCR__(v10, 1);
		v18 = v19;
		v21 = __CFRCR__(v17, v19);
		v20 = __RCR__(v17, v18);
		v18 = __CFADD__(v21, v20);
		LODWORD(a1) = v21 + v20;
		goto LABEL_21;
	}
	if (2 * v1)
		goto LABEL_4;
	return a1;
}

//----- (000B49D8) --------------------------------------------------------
void sub_B49D8(int a1, int a2)
{
	int v2; // edi
	unsigned __int64 v3; // rax
	int v4; // esi
	unsigned __int64 v5; // rax
	unsigned int vars0; // [esp+0h] [ebp+0h]
	unsigned int vars4; // [esp+4h] [ebp+4h]
	__int16 vars8; // [esp+8h] [ebp+8h]
	int varsC; // [esp+Ch] [ebp+Ch]

	//fix it
	vars8 = 0;
	vars0 = 0;
	vars4 = 0;
	varsC = 0;
	//fix it

	v2 = a1;
	v3 = *(_QWORD *)a1;
	LOWORD(a2) = *(x_WORD *)(a1 + 8);
	do
	{
		v4 = __ROL4__(a2, 16);
		LOWORD(v4) = vars8;
		v4 = __ROL4__(v4, 16);
		LODWORD(v5) = sub_B37DA(v3, vars4, vars0, v4);
		v2 += 10;
		v4 = __ROL4__(v4, 16);
		LOWORD(v4) = *(x_WORD *)(v2 + 8);
		a2 = __ROL4__(v4, 16);
		LODWORD(v3) = sub_B33D6(v5, *(x_DWORD *)(v2 + 4), *(x_DWORD *)v2, a2);
		--varsC;
	} while (varsC);
}

//----- (000B4A2A) --------------------------------------------------------
int sub_B4A2A(int *a1, int a2, int a3)
{
	int v3; // ST00_4
	int *v4; // edi
	unsigned __int64 v5; // rax
	int v6; // esi
	unsigned __int64 v7; // rax
	int result; // eax
	int v9; // edx


	//fix it
	v7 = 0;
	v9 = 0;
	//fix it

	v3 = a2;
	v4 = a1;
	LODWORD(v5) = *a1;
	HIDWORD(v5) = v4[1];
	LOWORD(a3) = *((x_WORD *)v4 + 4);
	v6 = a3 << 16;
	LOWORD(v6) = *((x_WORD *)v4 + 4);
	sub_B37DA(v5, v4[1], v5, v6);
	sub_B49D8(v3, v6);
	v6 = __ROL4__(v6, 16);
	LOWORD(v6) = *((x_WORD *)v4 + 4);
	v6 = __ROL4__(v6, 16);
	result = sub_B37DA(v7, v4[1], *v4, v6);
	*v4 = result;
	v4[1] = v9;
	*((x_WORD *)v4 + 4) = v6;
	return result;
}

//----- (000B4F46) --------------------------------------------------------
void /*__spoils<edx,ecx>*/ sub_B4F46()
{
	if (!x_WORD_E7C58 && x_BYTE_E3E28)
	{
		if (x_BYTE_E4CB2)
		{
			if (x_BYTE_E4CB2 == 1)
			{
				_DOS4G_hook_init();
			}
			else if (x_BYTE_E4CB2 == 9)
			{
				_Intel_hook_init();
			}
			else
			{
				_Phar_hook_init();
			}
		}
		else
		{
			_Ergo_hook_init((unsigned __int16)__DS__, (unsigned __int16)__ES__);
		}
		sub_B5000();
	}
}
// B56EA: using guessed type int _Phar_hook_init(void);
// B57DA: using guessed type int _DOS4G_hook_init(void);
// B5820: using guessed type int _Ergo_hook_init(x_DWORD, x_DWORD);
// B5878: using guessed type int _Intel_hook_init(void);
// E3E28: using guessed type char x_BYTE_E3E28;
// E4CB2: using guessed type char x_BYTE_E4CB2;
// E7C58: using guessed type __int16 x_WORD_E7C58;

//----- (000B4FA3) --------------------------------------------------------
void /*__spoils<edx,ecx>*/ sub_B4FA3()
{
	if (x_WORD_E7C58)
	{
		if (x_BYTE_E4CB2)
		{
			if (x_BYTE_E4CB2 == 1)
			{
				_DOS4G_hook_fini();
			}
			else if (x_BYTE_E4CB2 == 9)
			{
				_Intel_hook_fini();
			}
			else
			{
				_Phar_hook_fini();
			}
		}
		else
		{
			_Ergo_hook_fini((unsigned __int16)__DS__);
		}
	}
}
// B57AD: using guessed type int _Phar_hook_fini(void);
// B5807: using guessed type int _DOS4G_hook_fini(void);
// B585E: using guessed type int _Ergo_hook_fini(x_DWORD);
// B58D0: using guessed type int _Intel_hook_fini(void);
// E4CB2: using guessed type char x_BYTE_E4CB2;
// E7C58: using guessed type __int16 x_WORD_E7C58;

//----- (000B5000) --------------------------------------------------------
void sub_B5000()
{
	;
}

//----- (000B5015) --------------------------------------------------------
void /*__noreturn*/ sub_B5015()//fix
{
	/*__outx_BYTE(0x20u, 0x20u);
	__outx_BYTE(0xA0u, 0x20u);
	__outx_BYTE(0xF0u, 0);*/
	sub_B5022();
}

//----- (000B5022) --------------------------------------------------------
void /*__noreturn*/ sub_B5022()
{
	int v1; // [esp-24h] [ebp-40h]
	int v2; // [esp-8h] [ebp-24h]
	int v3; // [esp-4h] [ebp-20h]

	v3 = (unsigned __int16)__DS__;
	v2 = (unsigned __int16)__ES__;
	_EBP = (x_DWORD)&v1;
	/*fix it :__asm
	{
	  fnstenv x_BYTE ptr [ebp+0]
	  fclex
	  fdisi
	}*/
	_enable();
	((void(*)(void))_GETDS)();
}

//----- (000B5128) --------------------------------------------------------
void sub_B5128(__int16 a1, int a2, double *a3, double a4)
{
	bool v4; // zf

	if (a1 != -9734 && a1 != -9743)
	{
		v4 = a1 == -9736;
		if (a1 != -9736)
			v4 = a1 == -9739;
		if (!v4 && (a1 & 0x310) != 784)
		{
			if ((a1 & 0x110) == 272)
			{
				/*__asm
				{
				  fstp    st
				  fldz
				}*/
				if ((a1 & 0xC0) != -64)
					sub_B5250(a1, a3, a4);
				/*if ( a1 & 8 )
				  __asm { fstp    st }*/
			}
			else if ((a1 & 0x130) == 48)
			{
				*(x_WORD *)(a2 + 8);
			}
		}
	}
}
// B516D: inconsistent fpu stack

//----- (000B51B3) --------------------------------------------------------
void sub_B51B3(__int16 a1, int a2, double *a3, __int16 a4, double a5)
{
	__int16 v5; // dx
	double v6; // st7

	if (a1 != -9731)
	{
		if ((a1 & 0x110) == 272)
		{
			v6 = sub_B5205(SHIBYTE(a1), a2, a4, a5);
			if ((a1 & 0xC0) != -64)
				sub_B5250(a1, a3, v6);
			/*if ( a1 & 8 )
			  __asm { fstp    st }*/
		}
		else if ((a1 & 0xC0) == -64)
		{
			HIBYTE(v5) = HIBYTE(a1) & 1;
			LOBYTE(v5) = a1 & 0xC0;
			sub_B522B(v5, a1, (int)&unk_E7C64);
		}
		else
		{
			sub_B5205(SHIBYTE(a1), a2, a4, a5);
		}
	}
}
// B51CB: inconsistent fpu stack

//----- (000B5205) --------------------------------------------------------
double sub_B5205(char a1, int a2, __int16 a3, double a4)
{
	bool v4; // c0
	char v5; // c2
	bool v6; // c3
	double result; // st7

	v4 = a4 < 0.0;
	v5 = 0;
	v6 = a4 == 0.0;
	*(x_WORD *)(a2 + 20) = a3;
	if (a1 & 4)
		result = dbl_E7C6E;
	else
		result = flt_E7C76;
	if (*(x_WORD *)(a2 + 20) & 0x100)
		result = -result;
	return result;
}
// E7C6E: using guessed type double dbl_E7C6E;
// E7C76: using guessed type float flt_E7C76;

//----- (000B522B) --------------------------------------------------------
__int64 sub_B522B(int a1, __int16 a2, int _ESI)
{
	unsigned __int8 v3; // of
	__int64 result; // rax
	int v5; // [esp-4h] [ebp-4h]

	if (a2 & 0x400)
		LOBYTE(a1) = a2 & 7;
	else
		LOBYTE(a1) = 0;
	v5 = a1;
	while (1)
	{
		v3 = __OFSUB__((x_BYTE)a1, 1);
		LOBYTE(a1) = a1 - 1;
		if (((a1 & 0x80u) != 0) ^ v3)
			break;
		// fix it__asm { fincstp }
	}
	/* fix it__asm
	{
	  fstp    st
	  fld     tx_BYTE ptr [esi]
	}*/
	HIDWORD(result) = v5;
	while (1)
	{
		v3 = __OFSUB__(BYTE4(result)--, 1);
		if (((result & 0x8000000000i64) != 0) ^ v3)
			break;
		//fix it: __asm { fdecstp }
	}
	return result;
}
// B523E: inconsistent fpu stack

//----- (000B5250) --------------------------------------------------------
double sub_B5250(char a1, double *a2, double result)
{
	if (a1 & 4)
		*a2 = result;
	else
		*(float *)a2 = result;
	return result;
}

//----- (000B5C5B) --------------------------------------------------------
int sub_B5C5B()
{
	return 0;
}

//----- (000B5C60) --------------------------------------------------------
int sub_B5C60(__int16 a1, __int16 a2)
{
	int v2; // ebx
	int v3; // edx
	int v4; // eax
	int v5; // esi
	int v6; // esi
	int result; // eax
	int v8; // esi
	int v9; // eax
	int v10; // esi
	int v11; // esi
	int v12; // edi

	v2 = HIBYTE(a1);
	BYTE1(v2) = HIBYTE(a2);
	v3 = (unsigned __int8)a2;
	if ((HIBYTE(a1) + HIBYTE(a2)) & 1)
	{
		if (__CFADD__((x_BYTE)v3, (x_BYTE)a1))
		{
			BYTE1(v2) = HIBYTE(a2) + 1;
			v4 = x_BYTE_11B4E0[v2];
			LOBYTE(v2) = v2 + 1;
			v8 = x_BYTE_11B4E0[v2];
			LOBYTE(v3) = ~(x_BYTE)a2;
			BYTE1(v2) = HIBYTE(a2);
			v6 = v3 * (x_BYTE_11B4E0[v2] - v8) + (unsigned __int8)a1 * (v8 - v4);
		}
		else
		{
			v4 = x_BYTE_11B4E0[v2];
			LOBYTE(v2) = v2 + 1;
			v5 = (unsigned __int8)a1 * (x_BYTE_11B4E0[v2] - v4);
			LOBYTE(v2) = v2 - 1;
			BYTE1(v2) = HIBYTE(a2) + 1;
			v6 = (unsigned __int8)a2 * (x_BYTE_11B4E0[v2] - v4) + v5;
		}
		result = (v6 >> 3) + 32 * v4;
	}
	else
	{
		if ((unsigned __int8)a1 <= (unsigned __int8)v3)
		{
			v9 = x_BYTE_11B4E0[v2];
			BYTE1(v2) = HIBYTE(a2) + 1;
			v12 = x_BYTE_11B4E0[v2];
			LOBYTE(v2) = v2 + 1;
			v11 = (unsigned __int8)a2 * (v12 - v9) + (unsigned __int8)a1 * (x_BYTE_11B4E0[v2] - v12);
		}
		else
		{
			v9 = x_BYTE_11B4E0[v2];
			LOBYTE(v2) = v2 + 1;
			v10 = x_BYTE_11B4E0[v2];
			BYTE1(v2) = HIBYTE(a2) + 1;
			v11 = (unsigned __int8)a2 * (x_BYTE_11B4E0[v2] - v10) + (unsigned __int8)a1 * (v10 - v9);
		}
		result = (v11 >> 3) + 32 * v9;
	}
	return result;
}

//----- (000B5D68) --------------------------------------------------------
int sub_B5D68(__int16 a1, __int16 a2)
{
	int v2; // ebx
	int v3; // edx
	int v4; // eax
	int v5; // esi
	int v6; // esi
	int result; // eax
	int v8; // esi
	int v9; // eax
	int v10; // esi
	int v11; // esi
	int v12; // edi

	v2 = HIBYTE(a1);
	BYTE1(v2) = HIBYTE(a2);
	v3 = (unsigned __int8)a2;
	if ((HIBYTE(a1) + HIBYTE(a2)) & 1)
	{
		if (__CFADD__((x_BYTE)v3, (x_BYTE)a1))
		{
			BYTE1(v2) = HIBYTE(a2) + 1;
			v4 = (unsigned __int8)x_BYTE_14B4E0[v2];
			LOBYTE(v2) = v2 + 1;
			v8 = (unsigned __int8)x_BYTE_14B4E0[v2];
			LOBYTE(v3) = ~(x_BYTE)a2;
			BYTE1(v2) = HIBYTE(a2);
			v6 = v3 * ((unsigned __int8)x_BYTE_14B4E0[v2] - v8) + (unsigned __int8)a1 * (v8 - v4);
		}
		else
		{
			v4 = (unsigned __int8)x_BYTE_14B4E0[v2];
			LOBYTE(v2) = v2 + 1;
			v5 = (unsigned __int8)a1 * ((unsigned __int8)x_BYTE_14B4E0[v2] - v4);
			LOBYTE(v2) = v2 - 1;
			BYTE1(v2) = HIBYTE(a2) + 1;
			v6 = (unsigned __int8)a2 * ((unsigned __int8)x_BYTE_14B4E0[v2] - v4) + v5;
		}
		result = (v6 >> 3) + 32 * v4;
	}
	else
	{
		if ((unsigned __int8)a1 <= (unsigned __int8)v3)
		{
			v9 = (unsigned __int8)x_BYTE_14B4E0[v2];
			BYTE1(v2) = HIBYTE(a2) + 1;
			v12 = (unsigned __int8)x_BYTE_14B4E0[v2];
			LOBYTE(v2) = v2 + 1;
			v11 = (unsigned __int8)a2 * (v12 - v9) + (unsigned __int8)a1 * ((unsigned __int8)x_BYTE_14B4E0[v2] - v12);
		}
		else
		{
			v9 = (unsigned __int8)x_BYTE_14B4E0[v2];
			LOBYTE(v2) = v2 + 1;
			v10 = (unsigned __int8)x_BYTE_14B4E0[v2];
			BYTE1(v2) = HIBYTE(a2) + 1;
			v11 = (unsigned __int8)a2 * ((unsigned __int8)x_BYTE_14B4E0[v2] - v10) + (unsigned __int8)a1 * (v10 - v9);
		}
		result = (v11 >> 3) + 32 * v9;
	}
	return result;
}

//----- (000B5E70) --------------------------------------------------------
void /*__spoils<ecx>*/ sub_B5E70_decompress_terrain_map_level(__int16 a1, unsigned __int16 a2, __int16 a3, Bit32s a4)//296e70
{
	Bit16u v3; // ebx
	__int16 v4; // cx
	//char v5; // sf
	//char v6; // of
	Bit8s v7; // [esp+1h] [ebp-3h]
	Bit8s v8; // [esp+1h] [ebp-3h]
	Bit8s v9; // [esp+2h] [ebp-2h]
	Bit8s v10; // [esp+2h] [ebp-2h]
	Bit8s v11; // [esp+3h] [ebp-1h]
	//Bit8u savedregs[20]; // [esp+4h] [ebp+0h]

	x_WORD_15B4E0[a2] = a3;//32c4e0
	v11 = 7;
	do
	{
		v3 = a2;
		v4 = (1 << v11);
		v7 = 1 << (7 - v11);
		do
		{
			v9 = 1 << (7 - v11);
			do
			{
				sub_B5EFA(v4, &v3, a4, &a1);//355220
				v9--;
			} while (v9);
			v3 += (v4 + v4) << 8;
			v7--;
		} while (v7);
		v8 = 1 << (7 - v11);
		do
		{
			v10 = 1 << (7 - v11);
			do
			{
				sub_B5F8F(v4, &v3, a4, &a1);
				v10--;
			} while (v10);
			v3 += (v4 + v4) << 8;
			v8--;
		} while (v8);
		v11--;
		//v6 = __OFSUB__(v11, 1);
		//v5 = (v11-- - 1) < 0;
	} while (v11 >= 0/*!(v5 ^ v6)*/);
}

//----- (000B5EFA) --------------------------------------------------------
void sub_B5EFA(__int16 a1, Bit16u* a2, Bit32s a3, __int16* a4)//296EFA
{
	Bit16s v4; // di
	//__int16 v5; // di
	//__int16 v6; // di
	Bit16u v7; // si
	Bit32u v8; // di
	//__int16 result; // ax

	v4 = x_WORD_15B4E0[*a2];
	LOBYTE(*a2) += (a1 + a1);
	v4 += x_WORD_15B4E0[*a2];
	*a2 += (a1 + a1) << 8;
	v4 += x_WORD_15B4E0[*a2];
	LOBYTE(*a2) -= (a1 + a1);
	v4 += x_WORD_15B4E0[*a2];
	LOBYTE(*a2) += a1;
	*a2 -= a1 << 8;
	v7 = 9377 * *a4 + 9439;
	*a4 = v7;
	v8 = v7 % (Bit16u)(2 * a3 + 1)
		+ v7 % (Bit16u)((a1 << 6) + 1)
		+ (v4 >> 2)
		- 32 * a1
		- a3;
	//result = v8;
	if (!x_WORD_15B4E0[*a2])
		x_WORD_15B4E0[*a2] = v8;
	LOBYTE(*a2) += a1;
	*a2 -= a1 << 8;
	//return result;
}

//----- (000B5F8F) --------------------------------------------------------
void sub_B5F8F(__int16 a1, Bit16u* a2, Bit32s a3, __int16* a4)//296f8f
{
	__int16 v4; // di
	//__int16 v5; // di
	//__int16 v6; // di
	Bit16u v7; // si
	Bit16u v7b; // si
	Bit16u v8; // ax
	Bit16s v9; // di
	//__int16 v10; // di
	//__int16 v11; // di
	Bit32u v12; // di
	//__int16 result; // ax
	Bit16u v14; // [esp-2h] [ebp-2h]

	v4 = x_WORD_15B4E0[*a2];
	v14 = v4;
	LOBYTE(*a2) += a1;
	*a2 -= a1 << 8;
	v4 += x_WORD_15B4E0[*a2];
	LOBYTE(*a2) += a1;
	*a2 += a1 << 8;
	v4 += x_WORD_15B4E0[*a2];
	LOBYTE(*a2) -= a1;
	*a2 += a1 << 8;
	v4 += x_WORD_15B4E0[*a2];
	v7 = 9377 * *a4 + 9439;
	//*a4 = v7;
	//2ae9*24a1
	v8 = v7 % (Bit16u)(2 * a3 + 1)
		+ v7 % (Bit16u)((a1 << 6) + 1)
		+ (Bit16u)(v4 >> 2)
		- 32 * a1
		- a3;
	//(Bit16u)(v4 >> 2)-(a1*32)+v7 % (Bit16u)((a1 << 6) + 1)-a3+v7 % (Bit16u)(2 * a3 + 1)
	v9 = x_WORD_15B4E0[*a2];
	*a2 -= a1 << 8;
	if (!x_WORD_15B4E0[*a2])
		x_WORD_15B4E0[*a2] = v8;
	v9 += v14;
	LOBYTE(*a2) -= (a1 + a1);
	*a2 += a1 << 8;
	v9 += x_WORD_15B4E0[*a2];
	LOBYTE(*a2) += a1;
	*a2 += a1 << 8;
	v9 += x_WORD_15B4E0[*a2];
	*a2 -= a1 << 8;
	v7b = 9377 * v7 + 9439;
	*a4 = v7b;
	v12 = v7b % (unsigned __int16)(2 * a3 + 1)
		+ v7b % (unsigned __int16)((a1 << 6) + 1)
		+ (Bit16u)(v9 >> 2)
		- 32 * a1
		- a3;
	//result = v12;
	if (!x_WORD_15B4E0[*a2])
		x_WORD_15B4E0[*a2] = v12;
	*a2 -= a1 << 8;
	LOBYTE(*a2) += (a1 + a1);
	//return result;
}

//----- (000B6253) --------------------------------------------------------
void /*__spoils<ecx>*/ sub_B6253(x_DWORD *a1, x_DWORD *a2, x_DWORD *a3)
{
	x_DWORD *v3; // esi
	x_DWORD *v4; // edi
	x_DWORD *v5; // ecx
	int v6; // eax
	int v7; // ebx
	int v8; // edx
	int v9; // eax
	int v10; // ebx
	int v11; // ebx
	int v12; // ebx
	int v13; // ebx
	int v14; // eax
	int v15; // ebx
	bool v16; // zf
	bool v17; // sf
	unsigned __int8 v18; // of
	int v19; // ebx
	int v20; // ebx
	int v21; // eax
	int v22; // ebx
	int v23; // ecx
	int v24; // edx
	int v25; // esi
	int v26; // ST48_4
	int v27; // ebx
	x_DWORD *v28; // edi
	int v29; // edi
	int v30; // edi
	unsigned int v31; // eax
	int v32; // eax
	int v33; // ebx
	bool v34; // zf
	int v35; // ebx
	int v36; // ebx
	int v37; // eax
	int v38; // ebx
	int v39; // ecx
	int v40; // edx
	int v41; // ST48_4
	int v42; // ebx
	x_DWORD *v43; // edi
	int v44; // edi
	int v45; // edi
	int v46; // eax
	int v47; // ebx
	bool v48; // zf
	int v49; // ebx
	int v50; // eax
	int v51; // ebx
	int v52; // esi
	int v53; // ST48_4
	int v54; // ebx
	x_DWORD *v55; // edi
	int v56; // edi
	int v57; // edi
	int v58; // eax
	int v59; // ebx
	int v60; // ST48_4
	int v61; // ebx
	x_DWORD *v62; // edi
	int v63; // edi
	int v64; // edi
	int v65; // eax
	int v66; // ebx
	int v67; // ebx
	int v68; // ebx
	int v69; // eax
	int v70; // ebx
	bool v71; // zf
	int v72; // ebx
	int v73; // ebx
	int v74; // eax
	int v75; // ebx
	int v76; // ecx
	int v77; // edx
	int v78; // esi
	int v79; // ST48_4
	int v80; // eax
	int *v81; // edi
	int v82; // edi
	int v83; // edi
	int v84; // eax
	int v85; // ebx
	bool v86; // zf
	int v87; // ebx
	int v88; // ebx
	int v89; // eax
	int v90; // ebx
	int v91; // ecx
	int v92; // edx
	int v93; // ST48_4
	int v94; // eax
	int *v95; // edi
	int v96; // edi
	int v97; // edi
	int v98; // eax
	int v99; // ebx
	bool v100; // zf
	int v101; // ebx
	int v102; // eax
	int v103; // ebx
	int v104; // esi
	int v105; // ST48_4
	int v106; // eax
	int *v107; // edi
	int v108; // edi
	int v109; // edi
	int v110; // eax
	int v111; // ebx
	int v112; // ST48_4
	int v113; // eax
	int *v114; // edi
	int v115; // edi
	int v116; // edi
	int v117; // eax
	int v118; // ebx
	int v119; // ebx
	int v120; // eax
	int v121; // ebx
	int v122; // ecx
	int v123; // edx
	int v124; // esi
	int v125; // edi
	x_DWORD *v126; // edi
	int v127; // ebx
	int v128; // eax
	int v129; // ebx
	int v130; // ecx
	int v131; // edx
	int v132; // edi
	x_DWORD *v133; // edi
	int v134; // eax
	int v135; // ebx
	int v136; // esi
	int v137; // edi
	x_DWORD *v138; // edi
	int v139; // eax
	int v140; // ebx
	int v141; // edi
	x_DWORD *v142; // edi
	int v143; // eax
	int v144; // ebx
	int v145; // ebx
	int v146; // eax
	int v147; // ebx
	int v148; // ecx
	int v149; // edx
	int v150; // esi
	int v151; // edi
	x_DWORD *v152; // edi
	int v153; // ebx
	int v154; // eax
	int v155; // ebx
	int v156; // ecx
	int v157; // edx
	int v158; // edi
	x_DWORD *v159; // edi
	int v160; // eax
	int v161; // ebx
	int v162; // esi
	int v163; // edi
	x_DWORD *v164; // edi
	int v165; // eax
	int v166; // ebx
	int v167; // edi
	x_DWORD *v168; // edi
	unsigned __int16 *v169; // esi
	char *v170; // edx
	char v171; // al
	int v172; // ebx
	signed int v173; // ecx
	char *v174; // edi
	unsigned __int16 *v175; // esi
	int v176; // ecx
	x_BYTE *v177; // edi
	unsigned int v178; // eax
	__int16 v179; // bx
	unsigned __int8 v180; // cf
	unsigned __int16 v181; // bx
	__int16 v182; // bx
	char v183; // ah
	__int16 v184; // cx
	__int16 v185; // bx
	char v186; // ah
	__int16 v187; // cx
	__int16 v188; // bx
	char v189; // ah
	__int16 v190; // cx
	__int16 v191; // bx
	char v192; // ah
	__int16 v193; // cx
	__int16 v194; // bx
	char v195; // ah
	__int16 v196; // cx
	__int16 v197; // bx
	char v198; // ah
	__int16 v199; // cx
	__int16 v200; // bx
	char v201; // ah
	__int16 v202; // cx
	__int16 v203; // bx
	char v204; // ah
	__int16 v205; // cx
	__int16 v206; // bx
	char v207; // ah
	__int16 v208; // cx
	__int16 v209; // bx
	char v210; // ah
	__int16 v211; // cx
	__int16 v212; // bx
	char v213; // ah
	__int16 v214; // cx
	__int16 v215; // bx
	char v216; // ah
	__int16 v217; // cx
	__int16 v218; // bx
	char v219; // ah
	__int16 v220; // cx
	__int16 v221; // bx
	char v222; // ah
	__int16 v223; // cx
	__int16 v224; // bx
	char v225; // ah
	__int16 v226; // cx
	unsigned __int16 *v227; // esi
	int v228; // eax
	int v229; // ebx
	int v230; // ecx
	x_BYTE *v231; // edi
	int v232; // eax
	unsigned int v233; // eax
	int v234; // edx
	unsigned int v235; // eax
	int v236; // esi
	char v237; // al
	int v238; // edx
	__int16 v239; // cx
	char v240; // al
	int v241; // edx
	__int16 v242; // cx
	char v243; // al
	int v244; // edx
	__int16 v245; // cx
	char v246; // al
	int v247; // edx
	__int16 v248; // cx
	char v249; // al
	int v250; // edx
	__int16 v251; // cx
	char v252; // al
	int v253; // edx
	__int16 v254; // cx
	char v255; // al
	int v256; // edx
	__int16 v257; // cx
	char v258; // al
	int v259; // edx
	__int16 v260; // cx
	char v261; // al
	int v262; // edx
	__int16 v263; // cx
	char v264; // al
	int v265; // edx
	__int16 v266; // cx
	char v267; // al
	int v268; // edx
	__int16 v269; // cx
	char v270; // al
	int v271; // edx
	__int16 v272; // cx
	char v273; // al
	int v274; // edx
	__int16 v275; // cx
	char v276; // al
	int v277; // edx
	__int16 v278; // cx
	char v279; // al
	int v280; // edx
	__int16 v281; // cx
	char v282; // al
	unsigned __int16 *v283; // esi
	int v284; // eax
	int v285; // ebx
	int v286; // ecx
	x_BYTE *v287; // edi
	int v288; // eax
	unsigned int v289; // eax
	int v290; // edx
	unsigned int v291; // eax
	int v292; // esi
	char v293; // al
	int v294; // edx
	__int16 v295; // cx
	char v296; // al
	int v297; // edx
	__int16 v298; // cx
	char v299; // al
	int v300; // edx
	__int16 v301; // cx
	char v302; // al
	int v303; // edx
	__int16 v304; // cx
	char v305; // al
	int v306; // edx
	__int16 v307; // cx
	char v308; // al
	int v309; // edx
	__int16 v310; // cx
	char v311; // al
	int v312; // edx
	__int16 v313; // cx
	char v314; // al
	int v315; // edx
	__int16 v316; // cx
	char v317; // al
	int v318; // edx
	__int16 v319; // cx
	char v320; // al
	int v321; // edx
	__int16 v322; // cx
	char v323; // al
	int v324; // edx
	__int16 v325; // cx
	char v326; // al
	int v327; // edx
	__int16 v328; // cx
	char v329; // al
	int v330; // edx
	__int16 v331; // cx
	char v332; // al
	int v333; // edx
	__int16 v334; // cx
	char v335; // al
	int v336; // edx
	__int16 v337; // cx
	char v338; // al
	unsigned __int16 *v339; // esi
	int v340; // ecx
	x_BYTE *v341; // edi
	unsigned int v342; // eax
	__int16 v343; // bx
	unsigned __int16 v344; // bx
	__int16 v345; // bx
	__int16 v346; // cx
	__int16 v347; // bx
	__int16 v348; // cx
	__int16 v349; // bx
	__int16 v350; // cx
	__int16 v351; // bx
	__int16 v352; // cx
	__int16 v353; // bx
	__int16 v354; // cx
	__int16 v355; // bx
	__int16 v356; // cx
	__int16 v357; // bx
	__int16 v358; // cx
	__int16 v359; // bx
	__int16 v360; // cx
	__int16 v361; // bx
	__int16 v362; // cx
	__int16 v363; // bx
	__int16 v364; // cx
	__int16 v365; // bx
	__int16 v366; // cx
	__int16 v367; // bx
	__int16 v368; // cx
	__int16 v369; // bx
	__int16 v370; // cx
	__int16 v371; // bx
	__int16 v372; // cx
	__int16 v373; // bx
	__int16 v374; // cx
	unsigned int v375; // eax
	int v376; // ebx
	char *v377; // esi
	int v378; // ecx
	int v379; // edi
	int v380; // eax
	int v381; // ecx
	unsigned int v382; // eax
	int v383; // edx
	int v384; // ecx
	__int16 v385; // cx
	__int16 v386; // bp
	int v387; // esi
	x_BYTE *v388; // edi
	int v389; // ebp
	unsigned int v390; // eax
	int v391; // ebx
	char *v392; // esi
	int v393; // ecx
	int v394; // edi
	int v395; // eax
	int v396; // ecx
	unsigned int v397; // eax
	int v398; // edx
	int v399; // ecx
	__int16 v400; // cx
	__int16 v401; // bp
	int v402; // esi
	x_BYTE *v403; // edi
	int v404; // ebp
	unsigned __int16 *v405; // esi
	int v406; // eax
	int v407; // ebx
	int v408; // ecx
	x_BYTE *v409; // edi
	int v410; // eax
	unsigned int v411; // eax
	int v412; // edx
	unsigned int v413; // eax
	int v414; // esi
	int v415; // edx
	__int16 v416; // cx
	int v417; // edx
	__int16 v418; // cx
	int v419; // edx
	__int16 v420; // cx
	int v421; // edx
	__int16 v422; // cx
	int v423; // edx
	__int16 v424; // cx
	int v425; // edx
	__int16 v426; // cx
	int v427; // edx
	__int16 v428; // cx
	int v429; // edx
	__int16 v430; // cx
	int v431; // edx
	__int16 v432; // cx
	int v433; // edx
	__int16 v434; // cx
	int v435; // edx
	__int16 v436; // cx
	int v437; // edx
	__int16 v438; // cx
	int v439; // edx
	__int16 v440; // cx
	int v441; // edx
	__int16 v442; // cx
	int v443; // edx
	__int16 v444; // cx
	unsigned __int16 *v445; // esi
	int v446; // eax
	int v447; // ebx
	int v448; // ecx
	x_BYTE *v449; // edi
	int v450; // eax
	unsigned int v451; // eax
	int v452; // edx
	unsigned int v453; // eax
	int v454; // esi
	int v455; // edx
	__int16 v456; // cx
	int v457; // edx
	__int16 v458; // cx
	int v459; // edx
	__int16 v460; // cx
	int v461; // edx
	__int16 v462; // cx
	int v463; // edx
	__int16 v464; // cx
	int v465; // edx
	__int16 v466; // cx
	int v467; // edx
	__int16 v468; // cx
	int v469; // edx
	__int16 v470; // cx
	int v471; // edx
	__int16 v472; // cx
	int v473; // edx
	__int16 v474; // cx
	int v475; // edx
	__int16 v476; // cx
	int v477; // edx
	__int16 v478; // cx
	int v479; // edx
	__int16 v480; // cx
	int v481; // edx
	__int16 v482; // cx
	int v483; // edx
	__int16 v484; // cx
	unsigned __int16 *v485; // esi
	int v486; // eax
	int v487; // ebx
	int v488; // ecx
	x_BYTE *v489; // edi
	int v490; // eax
	unsigned int v491; // eax
	int v492; // edx
	unsigned int v493; // eax
	int v494; // esi
	int v495; // edx
	__int16 v496; // cx
	int v497; // edx
	__int16 v498; // cx
	int v499; // edx
	__int16 v500; // cx
	int v501; // edx
	__int16 v502; // cx
	int v503; // edx
	__int16 v504; // cx
	int v505; // edx
	__int16 v506; // cx
	int v507; // edx
	__int16 v508; // cx
	int v509; // edx
	__int16 v510; // cx
	int v511; // edx
	__int16 v512; // cx
	int v513; // edx
	__int16 v514; // cx
	int v515; // edx
	__int16 v516; // cx
	int v517; // edx
	__int16 v518; // cx
	int v519; // edx
	__int16 v520; // cx
	int v521; // edx
	__int16 v522; // cx
	int v523; // edx
	__int16 v524; // cx
	unsigned __int16 *v525; // esi
	int v526; // eax
	int v527; // ebx
	int v528; // ecx
	x_BYTE *v529; // edi
	int v530; // eax
	unsigned int v531; // eax
	int v532; // edx
	unsigned int v533; // eax
	int v534; // esi
	int v535; // edx
	__int16 v536; // cx
	int v537; // edx
	__int16 v538; // cx
	int v539; // edx
	__int16 v540; // cx
	int v541; // edx
	__int16 v542; // cx
	int v543; // edx
	__int16 v544; // cx
	int v545; // edx
	__int16 v546; // cx
	int v547; // edx
	__int16 v548; // cx
	int v549; // edx
	__int16 v550; // cx
	int v551; // edx
	__int16 v552; // cx
	int v553; // edx
	__int16 v554; // cx
	int v555; // edx
	__int16 v556; // cx
	int v557; // edx
	__int16 v558; // cx
	int v559; // edx
	__int16 v560; // cx
	int v561; // edx
	__int16 v562; // cx
	int v563; // edx
	__int16 v564; // cx
	unsigned __int16 *v565; // esi
	int v566; // eax
	int v567; // ebx
	int v568; // ecx
	x_BYTE *v569; // edi
	int v570; // eax
	unsigned int v571; // eax
	int v572; // edx
	unsigned int v573; // eax
	int v574; // esi
	int v575; // edx
	__int16 v576; // cx
	int v577; // edx
	__int16 v578; // cx
	int v579; // edx
	__int16 v580; // cx
	int v581; // edx
	__int16 v582; // cx
	int v583; // edx
	__int16 v584; // cx
	int v585; // edx
	__int16 v586; // cx
	int v587; // edx
	__int16 v588; // cx
	int v589; // edx
	__int16 v590; // cx
	int v591; // edx
	__int16 v592; // cx
	int v593; // edx
	__int16 v594; // cx
	int v595; // edx
	__int16 v596; // cx
	int v597; // edx
	__int16 v598; // cx
	int v599; // edx
	__int16 v600; // cx
	int v601; // edx
	__int16 v602; // cx
	int v603; // edx
	__int16 v604; // cx
	unsigned __int16 *v605; // esi
	x_BYTE *v606; // edx
	int v607; // eax
	int v608; // ebx
	int v609; // ecx
	x_BYTE *i; // edi
	__int16 v611; // cx
	__int16 v612; // cx
	__int16 v613; // cx
	__int16 v614; // cx
	__int16 v615; // cx
	__int16 v616; // cx
	__int16 v617; // cx
	__int16 v618; // cx
	__int16 v619; // cx
	__int16 v620; // cx
	__int16 v621; // cx
	__int16 v622; // cx
	__int16 v623; // cx
	__int16 v624; // cx
	__int16 v625; // cx
	unsigned __int16 *v626; // esi
	x_BYTE *v627; // edx
	int v628; // eax
	int v629; // ebx
	int v630; // ecx
	x_BYTE *j; // edi
	__int16 v632; // cx
	__int16 v633; // cx
	__int16 v634; // cx
	__int16 v635; // cx
	__int16 v636; // cx
	__int16 v637; // cx
	__int16 v638; // cx
	__int16 v639; // cx
	__int16 v640; // cx
	__int16 v641; // cx
	__int16 v642; // cx
	__int16 v643; // cx
	__int16 v644; // cx
	__int16 v645; // cx
	__int16 v646; // cx
	unsigned __int16 *v647; // esi
	int v648; // edx
	int v649; // ecx
	x_BYTE *v650; // edi
	unsigned int v651; // eax
	__int16 v652; // bx
	unsigned __int16 v653; // bx
	__int16 v654; // bx
	__int16 v655; // cx
	__int16 v656; // bx
	__int16 v657; // cx
	__int16 v658; // bx
	__int16 v659; // cx
	__int16 v660; // bx
	__int16 v661; // cx
	__int16 v662; // bx
	__int16 v663; // cx
	__int16 v664; // bx
	__int16 v665; // cx
	__int16 v666; // bx
	__int16 v667; // cx
	__int16 v668; // bx
	__int16 v669; // cx
	__int16 v670; // bx
	__int16 v671; // cx
	__int16 v672; // bx
	__int16 v673; // cx
	__int16 v674; // bx
	__int16 v675; // cx
	__int16 v676; // bx
	__int16 v677; // cx
	__int16 v678; // bx
	__int16 v679; // cx
	__int16 v680; // bx
	__int16 v681; // cx
	__int16 v682; // bx
	__int16 v683; // cx
	unsigned __int16 *v684; // esi
	int v685; // edx
	int v686; // ecx
	x_BYTE *v687; // edi
	unsigned int v688; // eax
	__int16 v689; // bx
	unsigned __int16 v690; // bx
	__int16 v691; // bx
	__int16 v692; // cx
	__int16 v693; // bx
	__int16 v694; // cx
	__int16 v695; // bx
	__int16 v696; // cx
	__int16 v697; // bx
	__int16 v698; // cx
	__int16 v699; // bx
	__int16 v700; // cx
	__int16 v701; // bx
	__int16 v702; // cx
	__int16 v703; // bx
	__int16 v704; // cx
	__int16 v705; // bx
	__int16 v706; // cx
	__int16 v707; // bx
	__int16 v708; // cx
	__int16 v709; // bx
	__int16 v710; // cx
	__int16 v711; // bx
	__int16 v712; // cx
	__int16 v713; // bx
	__int16 v714; // cx
	__int16 v715; // bx
	__int16 v716; // cx
	__int16 v717; // bx
	__int16 v718; // cx
	__int16 v719; // bx
	__int16 v720; // cx
	unsigned __int16 *v721; // esi
	int v722; // eax
	int v723; // ebx
	int v724; // ecx
	x_BYTE *v725; // edi
	int v726; // eax
	unsigned int v727; // eax
	int v728; // edx
	unsigned int v729; // eax
	int v730; // esi
	int v731; // edx
	__int16 v732; // cx
	int v733; // edx
	__int16 v734; // cx
	int v735; // edx
	__int16 v736; // cx
	int v737; // edx
	__int16 v738; // cx
	int v739; // edx
	__int16 v740; // cx
	int v741; // edx
	__int16 v742; // cx
	int v743; // edx
	__int16 v744; // cx
	int v745; // edx
	__int16 v746; // cx
	int v747; // edx
	__int16 v748; // cx
	int v749; // edx
	__int16 v750; // cx
	int v751; // edx
	__int16 v752; // cx
	int v753; // edx
	__int16 v754; // cx
	int v755; // edx
	__int16 v756; // cx
	int v757; // edx
	__int16 v758; // cx
	int v759; // edx
	__int16 v760; // cx
	unsigned __int16 *v761; // esi
	int v762; // eax
	int v763; // ebx
	int v764; // ecx
	x_BYTE *v765; // edi
	int v766; // eax
	unsigned int v767; // eax
	int v768; // edx
	unsigned int v769; // eax
	int v770; // esi
	int v771; // edx
	__int16 v772; // cx
	int v773; // edx
	__int16 v774; // cx
	int v775; // edx
	__int16 v776; // cx
	int v777; // edx
	__int16 v778; // cx
	int v779; // edx
	__int16 v780; // cx
	int v781; // edx
	__int16 v782; // cx
	int v783; // edx
	__int16 v784; // cx
	int v785; // edx
	__int16 v786; // cx
	int v787; // edx
	__int16 v788; // cx
	int v789; // edx
	__int16 v790; // cx
	int v791; // edx
	__int16 v792; // cx
	int v793; // edx
	__int16 v794; // cx
	int v795; // edx
	__int16 v796; // cx
	int v797; // edx
	__int16 v798; // cx
	int v799; // edx
	__int16 v800; // cx
	unsigned __int16 *v801; // esi
	unsigned int v802; // eax
	int v803; // ebx
	int v804; // ecx
	x_BYTE *v805; // edi
	int v806; // eax
	int v807; // ecx
	unsigned int v808; // eax
	int v809; // edx
	int v810; // ecx
	int v811; // esi
	int v812; // edx
	int v813; // ecx
	int v814; // edx
	int v815; // ecx
	int v816; // edx
	int v817; // ecx
	int v818; // edx
	int v819; // ecx
	int v820; // edx
	int v821; // ecx
	int v822; // edx
	int v823; // ecx
	int v824; // edx
	int v825; // ecx
	int v826; // edx
	int v827; // ecx
	int v828; // edx
	int v829; // ecx
	int v830; // edx
	int v831; // ecx
	int v832; // edx
	int v833; // ecx
	int v834; // edx
	int v835; // ecx
	int v836; // edx
	int v837; // ecx
	int v838; // edx
	int v839; // ecx
	int v840; // edx
	int v841; // ecx
	unsigned __int16 *v842; // esi
	unsigned int v843; // eax
	int v844; // ebx
	int v845; // ecx
	x_BYTE *v846; // edi
	int v847; // eax
	int v848; // ecx
	unsigned int v849; // eax
	int v850; // edx
	int v851; // ecx
	int v852; // esi
	int v853; // edx
	int v854; // ecx
	int v855; // edx
	int v856; // ecx
	int v857; // edx
	int v858; // ecx
	int v859; // edx
	int v860; // ecx
	int v861; // edx
	int v862; // ecx
	int v863; // edx
	int v864; // ecx
	int v865; // edx
	int v866; // ecx
	int v867; // edx
	int v868; // ecx
	int v869; // edx
	int v870; // ecx
	int v871; // edx
	int v872; // ecx
	int v873; // edx
	int v874; // ecx
	int v875; // edx
	int v876; // ecx
	int v877; // edx
	int v878; // ecx
	int v879; // edx
	int v880; // ecx
	int v881; // edx
	int v882; // ecx
	unsigned __int16 *v883; // esi
	int v884; // eax
	int v885; // ebx
	int v886; // ecx
	x_BYTE *v887; // edi
	int v888; // eax
	unsigned int v889; // eax
	int v890; // edx
	unsigned int v891; // eax
	int v892; // esi
	int v893; // edx
	__int16 v894; // cx
	int v895; // edx
	__int16 v896; // cx
	int v897; // edx
	__int16 v898; // cx
	int v899; // edx
	__int16 v900; // cx
	int v901; // edx
	__int16 v902; // cx
	int v903; // edx
	__int16 v904; // cx
	int v905; // edx
	__int16 v906; // cx
	int v907; // edx
	__int16 v908; // cx
	int v909; // edx
	__int16 v910; // cx
	int v911; // edx
	__int16 v912; // cx
	int v913; // edx
	__int16 v914; // cx
	int v915; // edx
	__int16 v916; // cx
	int v917; // edx
	__int16 v918; // cx
	int v919; // edx
	__int16 v920; // cx
	int v921; // edx
	__int16 v922; // cx
	unsigned __int16 *v923; // esi
	int v924; // eax
	int v925; // ebx
	int v926; // ecx
	x_BYTE *v927; // edi
	int v928; // eax
	unsigned int v929; // eax
	int v930; // edx
	unsigned int v931; // eax
	int v932; // esi
	int v933; // edx
	__int16 v934; // cx
	int v935; // edx
	__int16 v936; // cx
	int v937; // edx
	__int16 v938; // cx
	int v939; // edx
	__int16 v940; // cx
	int v941; // edx
	__int16 v942; // cx
	int v943; // edx
	__int16 v944; // cx
	int v945; // edx
	__int16 v946; // cx
	int v947; // edx
	__int16 v948; // cx
	int v949; // edx
	__int16 v950; // cx
	int v951; // edx
	__int16 v952; // cx
	int v953; // edx
	__int16 v954; // cx
	int v955; // edx
	__int16 v956; // cx
	int v957; // edx
	__int16 v958; // cx
	int v959; // edx
	__int16 v960; // cx
	int v961; // edx
	__int16 v962; // cx
	unsigned __int16 *v963; // esi
	unsigned int v964; // eax
	int v965; // ebx
	int v966; // ecx
	x_BYTE *v967; // edi
	int v968; // eax
	int v969; // ecx
	unsigned int v970; // eax
	int v971; // edx
	int v972; // ecx
	int v973; // esi
	int v974; // edx
	int v975; // ecx
	int v976; // edx
	int v977; // ecx
	int v978; // edx
	int v979; // ecx
	int v980; // edx
	int v981; // ecx
	int v982; // edx
	int v983; // ecx
	int v984; // edx
	int v985; // ecx
	int v986; // edx
	int v987; // ecx
	int v988; // edx
	int v989; // ecx
	int v990; // edx
	int v991; // ecx
	int v992; // edx
	int v993; // ecx
	int v994; // edx
	int v995; // ecx
	int v996; // edx
	int v997; // ecx
	int v998; // edx
	int v999; // ecx
	int v1000; // edx
	int v1001; // ecx
	int v1002; // edx
	int v1003; // ecx
	unsigned __int16 *v1004; // esi
	unsigned int v1005; // eax
	int v1006; // ebx
	int v1007; // ecx
	x_BYTE *v1008; // edi
	int v1009; // eax
	int v1010; // ecx
	unsigned int v1011; // eax
	int v1012; // edx
	int v1013; // ecx
	int v1014; // esi
	int v1015; // edx
	int v1016; // ecx
	int v1017; // edx
	int v1018; // ecx
	int v1019; // edx
	int v1020; // ecx
	int v1021; // edx
	int v1022; // ecx
	int v1023; // edx
	int v1024; // ecx
	int v1025; // edx
	int v1026; // ecx
	int v1027; // edx
	int v1028; // ecx
	int v1029; // edx
	int v1030; // ecx
	int v1031; // edx
	int v1032; // ecx
	int v1033; // edx
	int v1034; // ecx
	int v1035; // edx
	int v1036; // ecx
	int v1037; // edx
	int v1038; // ecx
	int v1039; // edx
	int v1040; // ecx
	int v1041; // edx
	int v1042; // ecx
	int v1043; // edx
	int v1044; // ecx
	unsigned __int16 *v1045; // esi
	unsigned int v1046; // eax
	int v1047; // ebx
	int v1048; // ecx
	char *v1049; // edi
	int v1050; // eax
	int v1051; // ecx
	unsigned int v1052; // eax
	int v1053; // edx
	int v1054; // ecx
	int v1055; // esi
	char v1056; // al
	int v1057; // edx
	int v1058; // ecx
	char v1059; // al
	int v1060; // edx
	int v1061; // ecx
	char v1062; // al
	int v1063; // edx
	int v1064; // ecx
	char v1065; // al
	int v1066; // edx
	int v1067; // ecx
	char v1068; // al
	int v1069; // edx
	int v1070; // ecx
	char v1071; // al
	int v1072; // edx
	int v1073; // ecx
	char v1074; // al
	int v1075; // edx
	int v1076; // ecx
	char v1077; // al
	int v1078; // edx
	int v1079; // ecx
	char v1080; // al
	int v1081; // edx
	int v1082; // ecx
	char v1083; // al
	int v1084; // edx
	int v1085; // ecx
	char v1086; // al
	int v1087; // edx
	int v1088; // ecx
	char v1089; // al
	int v1090; // edx
	int v1091; // ecx
	char v1092; // al
	int v1093; // edx
	int v1094; // ecx
	char v1095; // al
	int v1096; // edx
	int v1097; // ecx
	char v1098; // al
	int v1099; // edx
	int v1100; // ecx
	char v1101; // al
	int v1102; // [esp+0h] [ebp-88h]
	int v1103; // [esp+4h] [ebp-84h]
	int v1104; // [esp+4h] [ebp-84h]
	int v1105; // [esp+4h] [ebp-84h]
	int v1106; // [esp+4h] [ebp-84h]
	int v1107; // [esp+8h] [ebp-80h]
	int v1108; // [esp+8h] [ebp-80h]
	int v1109; // [esp+8h] [ebp-80h]
	int v1110; // [esp+8h] [ebp-80h]
	int v1111; // [esp+Ch] [ebp-7Ch]
	int v1112; // [esp+Ch] [ebp-7Ch]
	int v1113; // [esp+10h] [ebp-78h]
	int v1114; // [esp+10h] [ebp-78h]
	int v1115; // [esp+10h] [ebp-78h]
	int v1116; // [esp+10h] [ebp-78h]
	int v1117; // [esp+14h] [ebp-74h]
	int v1118; // [esp+14h] [ebp-74h]
	int v1119; // [esp+18h] [ebp-70h]
	int v1120; // [esp+18h] [ebp-70h]
	int v1121; // [esp+1Ch] [ebp-6Ch]
	int v1122; // [esp+1Ch] [ebp-6Ch]
	int v1123; // [esp+20h] [ebp-68h]
	int v1124; // [esp+24h] [ebp-64h]
	int v1125; // [esp+28h] [ebp-60h]
	int v1126; // [esp+28h] [ebp-60h]
	int v1127; // [esp+28h] [ebp-60h]
	int v1128; // [esp+28h] [ebp-60h]
	int v1129; // [esp+28h] [ebp-60h]
	int v1130; // [esp+28h] [ebp-60h]
	int v1131; // [esp+28h] [ebp-60h]
	int v1132; // [esp+28h] [ebp-60h]
	int v1133; // [esp+2Ch] [ebp-5Ch]
	int v1134; // [esp+2Ch] [ebp-5Ch]
	int v1135; // [esp+30h] [ebp-58h]
	int v1136; // [esp+34h] [ebp-54h]
	int v1137; // [esp+34h] [ebp-54h]
	int v1138; // [esp+34h] [ebp-54h]
	int v1139; // [esp+34h] [ebp-54h]
	int v1140; // [esp+34h] [ebp-54h]
	int v1141; // [esp+34h] [ebp-54h]
	int v1142; // [esp+34h] [ebp-54h]
	int v1143; // [esp+34h] [ebp-54h]
	int v1144; // [esp+38h] [ebp-50h]
	int v1145; // [esp+38h] [ebp-50h]
	int v1146; // [esp+3Ch] [ebp-4Ch]
	int v1147; // [esp+40h] [ebp-48h]
	int v1148; // [esp+40h] [ebp-48h]
	int v1149; // [esp+40h] [ebp-48h]
	int v1150; // [esp+40h] [ebp-48h]
	int v1151; // [esp+40h] [ebp-48h]
	int v1152; // [esp+40h] [ebp-48h]
	int v1153; // [esp+40h] [ebp-48h]
	int v1154; // [esp+40h] [ebp-48h]
	int v1155; // [esp+44h] [ebp-44h]
	int v1156; // [esp+44h] [ebp-44h]
	int v1157; // [esp+48h] [ebp-40h]
	int v1158; // [esp+48h] [ebp-40h]
	int v1159; // [esp+48h] [ebp-40h]
	int v1160; // [esp+48h] [ebp-40h]
	int v1161; // [esp+48h] [ebp-40h]
	int v1162; // [esp+48h] [ebp-40h]
	int v1163; // [esp+48h] [ebp-40h]
	int v1164; // [esp+48h] [ebp-40h]
	int v1165; // [esp+4Ch] [ebp-3Ch]
	int v1166; // [esp+4Ch] [ebp-3Ch]
	int v1167; // [esp+4Ch] [ebp-3Ch]
	int v1168; // [esp+4Ch] [ebp-3Ch]
	int v1169; // [esp+4Ch] [ebp-3Ch]
	int v1170; // [esp+4Ch] [ebp-3Ch]
	int v1171; // [esp+4Ch] [ebp-3Ch]
	int v1172; // [esp+4Ch] [ebp-3Ch]
	int v1173; // [esp+4Ch] [ebp-3Ch]
	int v1174; // [esp+4Ch] [ebp-3Ch]
	int v1175; // [esp+4Ch] [ebp-3Ch]
	int v1176; // [esp+4Ch] [ebp-3Ch]
	int v1177; // [esp+4Ch] [ebp-3Ch]
	int v1178; // [esp+4Ch] [ebp-3Ch]
	int v1179; // [esp+4Ch] [ebp-3Ch]
	int v1180; // [esp+4Ch] [ebp-3Ch]
	int v1181; // [esp+4Ch] [ebp-3Ch]
	int v1182; // [esp+4Ch] [ebp-3Ch]
	int v1183; // [esp+50h] [ebp-38h]
	int v1184; // [esp+50h] [ebp-38h]
	int v1185; // [esp+50h] [ebp-38h]
	int v1186; // [esp+50h] [ebp-38h]
	int v1187; // [esp+50h] [ebp-38h]
	int v1188; // [esp+50h] [ebp-38h]
	int v1189; // [esp+50h] [ebp-38h]
	int v1190; // [esp+54h] [ebp-34h]
	int v1191; // [esp+54h] [ebp-34h]
	int v1192; // [esp+54h] [ebp-34h]
	int v1193; // [esp+54h] [ebp-34h]
	int v1194; // [esp+58h] [ebp-30h]
	int v1195; // [esp+58h] [ebp-30h]
	int v1196; // [esp+58h] [ebp-30h]
	int v1197; // [esp+58h] [ebp-30h]
	int v1198; // [esp+58h] [ebp-30h]
	int v1199; // [esp+58h] [ebp-30h]
	int v1200; // [esp+58h] [ebp-30h]
	int v1201; // [esp+58h] [ebp-30h]
	int v1202; // [esp+58h] [ebp-30h]
	int v1203; // [esp+58h] [ebp-30h]
	int v1204; // [esp+58h] [ebp-30h]
	int v1205; // [esp+58h] [ebp-30h]
	int v1206; // [esp+58h] [ebp-30h]
	int v1207; // [esp+58h] [ebp-30h]
	int v1208; // [esp+58h] [ebp-30h]
	int v1209; // [esp+58h] [ebp-30h]
	int v1210; // [esp+58h] [ebp-30h]
	int v1211; // [esp+58h] [ebp-30h]
	int v1212; // [esp+58h] [ebp-30h]
	int v1213; // [esp+58h] [ebp-30h]
	int v1214; // [esp+58h] [ebp-30h]
	int v1215; // [esp+58h] [ebp-30h]
	int v1216; // [esp+58h] [ebp-30h]
	int v1217; // [esp+58h] [ebp-30h]
	int v1218; // [esp+58h] [ebp-30h]
	int v1219; // [esp+58h] [ebp-30h]
	int v1220; // [esp+58h] [ebp-30h]
	int v1221; // [esp+58h] [ebp-30h]
	int v1222; // [esp+58h] [ebp-30h]
	int v1223; // [esp+58h] [ebp-30h]
	int v1224; // [esp+58h] [ebp-30h]
	int v1225; // [esp+58h] [ebp-30h]
	int v1226; // [esp+58h] [ebp-30h]
	int v1227; // [esp+58h] [ebp-30h]
	int v1228; // [esp+58h] [ebp-30h]
	int v1229; // [esp+58h] [ebp-30h]
	int v1230; // [esp+58h] [ebp-30h]
	int v1231; // [esp+58h] [ebp-30h]
	int v1232; // [esp+58h] [ebp-30h]
	int v1233; // [esp+58h] [ebp-30h]
	int v1234; // [esp+58h] [ebp-30h]
	int v1235; // [esp+58h] [ebp-30h]
	int v1236; // [esp+58h] [ebp-30h]
	int v1237; // [esp+58h] [ebp-30h]
	int v1238; // [esp+58h] [ebp-30h]
	int v1239; // [esp+58h] [ebp-30h]
	int v1240; // [esp+58h] [ebp-30h]
	int v1241; // [esp+58h] [ebp-30h]
	int v1242; // [esp+58h] [ebp-30h]
	int v1243; // [esp+58h] [ebp-30h]
	int v1244; // [esp+58h] [ebp-30h]
	int v1245; // [esp+58h] [ebp-30h]
	int v1246; // [esp+58h] [ebp-30h]
	int v1247; // [esp+58h] [ebp-30h]
	int v1248; // [esp+58h] [ebp-30h]
	int v1249; // [esp+58h] [ebp-30h]
	int v1250; // [esp+58h] [ebp-30h]
	int v1251; // [esp+58h] [ebp-30h]
	int v1252; // [esp+58h] [ebp-30h]
	int v1253; // [esp+58h] [ebp-30h]
	int v1254; // [esp+58h] [ebp-30h]
	int v1255; // [esp+58h] [ebp-30h]
	int v1256; // [esp+58h] [ebp-30h]
	int v1257; // [esp+58h] [ebp-30h]
	int v1258; // [esp+58h] [ebp-30h]
	int v1259; // [esp+58h] [ebp-30h]
	int v1260; // [esp+58h] [ebp-30h]
	int v1261; // [esp+58h] [ebp-30h]
	int v1262; // [esp+58h] [ebp-30h]
	int v1263; // [esp+58h] [ebp-30h]
	int v1264; // [esp+58h] [ebp-30h]
	int v1265; // [esp+58h] [ebp-30h]
	int v1266; // [esp+58h] [ebp-30h]
	int v1267; // [esp+58h] [ebp-30h]
	int v1268; // [esp+58h] [ebp-30h]
	int v1269; // [esp+58h] [ebp-30h]
	int v1270; // [esp+58h] [ebp-30h]
	int v1271; // [esp+58h] [ebp-30h]
	int v1272; // [esp+58h] [ebp-30h]
	int v1273; // [esp+58h] [ebp-30h]
	unsigned __int16 *v1274; // [esp+5Ch] [ebp-2Ch]
	unsigned __int16 *v1275; // [esp+5Ch] [ebp-2Ch]
	char *v1276; // [esp+5Ch] [ebp-2Ch]
	char *v1277; // [esp+5Ch] [ebp-2Ch]
	unsigned __int16 *v1278; // [esp+5Ch] [ebp-2Ch]
	unsigned __int16 *v1279; // [esp+5Ch] [ebp-2Ch]
	unsigned __int16 *v1280; // [esp+5Ch] [ebp-2Ch]
	unsigned __int16 *v1281; // [esp+5Ch] [ebp-2Ch]
	unsigned __int16 *v1282; // [esp+5Ch] [ebp-2Ch]
	unsigned __int16 *v1283; // [esp+5Ch] [ebp-2Ch]
	unsigned __int16 *v1284; // [esp+5Ch] [ebp-2Ch]
	unsigned __int16 *v1285; // [esp+5Ch] [ebp-2Ch]
	unsigned __int16 *v1286; // [esp+5Ch] [ebp-2Ch]
	unsigned __int16 *v1287; // [esp+5Ch] [ebp-2Ch]
	unsigned __int16 *v1288; // [esp+5Ch] [ebp-2Ch]
	unsigned __int16 *v1289; // [esp+5Ch] [ebp-2Ch]
	unsigned __int16 *v1290; // [esp+5Ch] [ebp-2Ch]
	unsigned __int16 *v1291; // [esp+5Ch] [ebp-2Ch]
	char v1292; // [esp+62h] [ebp-26h]
	char v1293; // [esp+62h] [ebp-26h]
	char v1294; // [esp+62h] [ebp-26h]
	char v1295; // [esp+62h] [ebp-26h]
	char v1296; // [esp+63h] [ebp-25h]
	char v1297; // [esp+63h] [ebp-25h]
	bool v1298; // [esp+63h] [ebp-25h]
	bool v1299; // [esp+63h] [ebp-25h]
	bool v1300; // [esp+64h] [ebp-24h]
	bool v1301; // [esp+64h] [ebp-24h]

	//fix it
	v1045 = 0;
	//fix it

	v3 = a1;
	v4 = a2;
	v5 = a3;
	v6 = a1[1];
	v7 = a2[1];
	v8 = a3[1];
	if (v6 == v7)
	{
		if (v6 == v8)
			return;
		if (v6 >= v8)
		{
			if (*a1 <= *a2)
				return;
			v3 = a3;
			v4 = a1;
			v5 = a2;
			goto LABEL_234;
		}
		if (*a2 <= *a1)
			return;
		goto LABEL_277;
	}
	if (v6 <= v7)
	{
		if (v6 != v8)
		{
			if (v6 >= v8)
			{
				v3 = a3;
				v4 = a1;
				v5 = a2;
			LABEL_24:
				v9 = v3[1];
				v1190 = v9;
				if (v9 >= 0)
				{
					if (v9 >= x_DWORD_DE568)
						return;
					v1102 = x_DWORD_DE554 + x_DWORD_DE560 * v9;
					v1292 = 0;
				}
				else
				{
					v1102 = x_DWORD_DE554;
					v1292 = 1;
				}
				v10 = v5[1];
				v1300 = v10 > x_DWORD_DE568;
				v11 = v10 - v9;
				v1113 = v11;
				v1123 = v11;
				v12 = v4[1];
				v1296 = v12 > x_DWORD_DE568;
				v13 = v12 - v9;
				v1117 = v13;
				v1103 = ((*v5 - *v3) << 16) / v1113;
				if (((*v4 - *v3) << 16) / v13 > v1103)
				{
					v1107 = ((*v4 - *v3) << 16) / v13;
					v1111 = ((*v5 - *v4) << 16) / (v5[1] - v4[1]);
					v1119 = v5[1] - v4[1];
					v1121 = *v4 << 16;
					switch (x_BYTE_E126D)
					{
					case 0:
					case 0xE:
					case 0xF:
						v58 = *v3 << 16;
						v59 = *v3 << 16;
						if (!v1292)
						{
							if (v1300)
							{
								v63 = x_DWORD_DE568 - v1190;
								v1123 = x_DWORD_DE568 - v1190;
								if (v1296)
								{
									v1117 = x_DWORD_DE568 - v1190;
								}
								else
								{
									v18 = __OFSUB__(v63, v1117);
									v64 = v63 - v1117;
									v1296 = (v64 < 0) ^ v18 | (v64 == 0);
									v1119 = v64;
								}
							}
							goto LABEL_121;
						}
						v18 = __OFSUB__(v1123, -v1190);
						v16 = v1123 == -v1190;
						v17 = v1123 + v1190 < 0;
						v1123 += v1190;
						if (!((unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16))
						{
							v1160 = -v1190;
							if (-v1190 - v1117 >= 0)
							{
								v1119 -= v1160 - v1117;
								v60 = v1160 - v1117;
								v58 += v1103 * v60 + v1117 * v1103;
								v61 = v1111 * v60 + v1121;
								if (v1300)
								{
									v1119 = x_DWORD_DE568;
									v1123 = x_DWORD_DE568;
								}
								v62 = (x_DWORD*)&unk_DE56C;
								goto LABEL_124;
							}
							v1117 += v1190;
							v58 += v1103 * v1160;
							v59 += v1160 * v1107;
							if (v1300)
							{
								v1123 = x_DWORD_DE568;
								if (v1296)
								{
									v1117 = x_DWORD_DE568;
								}
								else
								{
									v1296 = x_DWORD_DE568 <= v1117;
									v1119 = x_DWORD_DE568 - v1117;
								}
							}
						LABEL_121:
							v62 = (x_DWORD*)&unk_DE56C;
							do
							{
								*v62 = v58;
								v58 += v1103;
								v62[1] = v59;
								v59 += v1107;
								v62 += 5;
								--v1117;
							} while (v1117);
							v61 = v1121;
						LABEL_124:
							if (v1296)
							{
								v31 = (unsigned __int8)x_BYTE_E126D;
							}
							else
							{
								do
								{
									*v62 = v58;
									v58 += v1103;
									v62[1] = v61;
									v61 += v1111;
									v62 += 5;
									--v1119;
								} while (v1119);
								v31 = (unsigned __int8)x_BYTE_E126D;
							}
							goto LABEL_53;
						}
						return;
					case 1:
					case 4:
					case 0x10:
					case 0x11:
						v46 = v13 * (signed __int64)(*v3 - *v5) / v1113;
						v47 = *v4 - *v3;
						v18 = __OFADD__(v46, v47);
						v48 = v46 + v47 == 0;
						v17 = v46 + v47 < 0;
						v49 = v46 + v47;
						if ((unsigned __int8)v17 ^ v18)
							return;
						if (!v48)
							v1146 = (signed int)(v4[4] + (unsigned __int64)(v1117 * (signed __int64)(v3[4] - v5[4]) / v1113) - v3[4])
							/ (v49 + 1);
						v1148 = (v5[4] - v3[4]) / v1113;
						v50 = *v3 << 16;
						v51 = *v3 << 16;
						v52 = v3[4];
						if (v1292)
						{
							v18 = __OFSUB__(v1123, -v1190);
							v16 = v1123 == -v1190;
							v17 = v1123 + v1190 < 0;
							v1123 += v1190;
							if ((unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16)
								return;
							v1159 = -v1190;
							if (-v1190 - v1117 >= 0)
							{
								v1119 -= v1159 - v1117;
								v53 = v1159 - v1117;
								v50 += v1103 * v53 + v1117 * v1103;
								v54 = v1111 * v53 + v1121;
								v52 += v53 * v1148 + v1117 * v1148;
								if (v1300)
								{
									v1119 = x_DWORD_DE568;
									v1123 = x_DWORD_DE568;
								}
								v55 = (x_DWORD*)&unk_DE56C;
							LABEL_102:
								if (v1296)
								{
									v31 = (unsigned __int8)x_BYTE_E126D;
								}
								else
								{
									do
									{
										*v55 = v50;
										v50 += v1103;
										v55[1] = v54;
										v54 += v1111;
										v55[4] = v52;
										v52 += v1148;
										v55 += 5;
										--v1119;
									} while (v1119);
									v31 = (unsigned __int8)x_BYTE_E126D;
								}
								goto LABEL_53;
							}
							v1117 += v1190;
							v50 += v1103 * v1159;
							v51 += v1159 * v1107;
							v52 += v1159 * v1148;
							if (v1300)
							{
								v1123 = x_DWORD_DE568;
								if (v1296)
								{
									v1117 = x_DWORD_DE568;
								}
								else
								{
									v1296 = x_DWORD_DE568 <= v1117;
									v1119 = x_DWORD_DE568 - v1117;
								}
							}
						}
						else if (v1300)
						{
							v56 = x_DWORD_DE568 - v1190;
							v1123 = x_DWORD_DE568 - v1190;
							if (v1296)
							{
								v1117 = x_DWORD_DE568 - v1190;
							}
							else
							{
								v18 = __OFSUB__(v56, v1117);
								v57 = v56 - v1117;
								v1296 = (v57 < 0) ^ v18 | (v57 == 0);
								v1119 = v57;
							}
						}
						v55 = (x_DWORD*)&unk_DE56C;
						do
						{
							*v55 = v50;
							v50 += v1103;
							v55[1] = v51;
							v51 += v1107;
							v55[4] = v52;
							v52 += v1148;
							v55 += 5;
							--v1117;
						} while (v1117);
						v54 = v1121;
						goto LABEL_102;
					case 2:
					case 3:
					case 7:
					case 8:
					case 9:
					case 0xA:
					case 0xB:
					case 0xC:
					case 0xD:
					case 0x12:
					case 0x13:
					case 0x16:
					case 0x17:
						v32 = v13 * (signed __int64)(*v3 - *v5) / v1113;
						v33 = *v4 - *v3;
						v18 = __OFADD__(v32, v33);
						v34 = v32 + v33 == 0;
						v17 = v32 + v33 < 0;
						v35 = v32 + v33;
						if ((unsigned __int8)v17 ^ v18)
							return;
						if (!v34)
						{
							v36 = v35 + 1;
							v1124 = (signed int)(v4[2] + (unsigned __int64)(v1117 * (signed __int64)(v3[2] - v5[2]) / v1113) - v3[2])
								/ v36;
							v1135 = (signed int)(v4[3] + (unsigned __int64)(v1117 * (signed __int64)(v3[3] - v5[3]) / v1113) - v3[3])
								/ v36;
						}
						v1126 = (v5[2] - v3[2]) / v1113;
						v1137 = (v5[3] - v3[3]) / v1113;
						v37 = *v3 << 16;
						v38 = *v3 << 16;
						v39 = v3[2];
						v40 = v3[3];
						if (v1292)
						{
							v18 = __OFSUB__(v1123, -v1190);
							v16 = v1123 == -v1190;
							v17 = v1123 + v1190 < 0;
							v1123 += v1190;
							if ((unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16)
								return;
							v1158 = -v1190;
							if (-v1190 - v1117 >= 0)
							{
								v1119 -= v1158 - v1117;
								v41 = v1158 - v1117;
								v37 += v1103 * v41 + v1117 * v1103;
								v42 = v1111 * v41 + v1121;
								v39 += v41 * v1126 + v1117 * v1126;
								v40 += v41 * v1137 + v1117 * v1137;
								if (v1300)
								{
									v1119 = x_DWORD_DE568;
									v1123 = x_DWORD_DE568;
								}
								v43 = (x_DWORD*)&unk_DE56C;
							LABEL_77:
								if (v1296)
								{
									v31 = (unsigned __int8)x_BYTE_E126D;
								}
								else
								{
									do
									{
										*v43 = v37;
										v37 += v1103;
										v43[1] = v42;
										v42 += v1111;
										v43[2] = v39;
										v39 += v1126;
										v43[3] = v40;
										v40 += v1137;
										v43 += 5;
										--v1119;
									} while (v1119);
									v31 = (unsigned __int8)x_BYTE_E126D;
								}
								goto LABEL_53;
							}
							v1117 += v1190;
							v37 += v1103 * v1158;
							v38 += v1158 * v1107;
							v39 += v1158 * v1126;
							v40 += v1158 * v1137;
							if (v1300)
							{
								v1123 = x_DWORD_DE568;
								if (v1296)
								{
									v1117 = x_DWORD_DE568;
								}
								else
								{
									v1296 = x_DWORD_DE568 <= v1117;
									v1119 = x_DWORD_DE568 - v1117;
								}
							}
						}
						else if (v1300)
						{
							v44 = x_DWORD_DE568 - v1190;
							v1123 = x_DWORD_DE568 - v1190;
							if (v1296)
							{
								v1117 = x_DWORD_DE568 - v1190;
							}
							else
							{
								v18 = __OFSUB__(v44, v1117);
								v45 = v44 - v1117;
								v1296 = (v45 < 0) ^ v18 | (v45 == 0);
								v1119 = v45;
							}
						}
						v43 = (x_DWORD*)&unk_DE56C;
						do
						{
							*v43 = v37;
							v37 += v1103;
							v43[1] = v38;
							v38 += v1107;
							v43[2] = v39;
							v39 += v1126;
							v43[3] = v40;
							v40 += v1137;
							v43 += 5;
							--v1117;
						} while (v1117);
						v42 = v1121;
						goto LABEL_77;
					case 5:
					case 6:
					case 0x14:
					case 0x15:
					case 0x18:
					case 0x19:
					case 0x1A:
						v14 = v13 * (signed __int64)(*v3 - *v5) / v1113;
						v15 = *v4 - *v3;
						v18 = __OFADD__(v14, v15);
						v16 = v14 + v15 == 0;
						v17 = v14 + v15 < 0;
						v19 = v14 + v15;
						if ((unsigned __int8)v17 ^ v18)
							return;
						if (!v16)
						{
							v20 = v19 + 1;
							v1124 = (signed int)(v4[2] + (unsigned __int64)(v1117 * (signed __int64)(v3[2] - v5[2]) / v1113) - v3[2])
								/ v20;
							v1135 = (signed int)(v4[3] + (unsigned __int64)(v1117 * (signed __int64)(v3[3] - v5[3]) / v1113) - v3[3])
								/ v20;
							v1146 = (signed int)(v4[4] + (unsigned __int64)(v1117 * (signed __int64)(v3[4] - v5[4]) / v1113) - v3[4])
								/ v20;
						}
						v1125 = (v5[2] - v3[2]) / v1113;
						v1136 = (v5[3] - v3[3]) / v1113;
						v1147 = (v5[4] - v3[4]) / v1113;
						v21 = *v3 << 16;
						v22 = *v3 << 16;
						v23 = v3[2];
						v24 = v3[3];
						v25 = v3[4];
						if (v1292)
						{
							v18 = __OFSUB__(v1123, -v1190);
							v16 = v1123 == -v1190;
							v17 = v1123 + v1190 < 0;
							v1123 += v1190;
							if ((unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16)
								return;
							v1157 = -v1190;
							if (-v1190 - v1117 >= 0)
							{
								v1119 -= v1157 - v1117;
								v26 = v1157 - v1117;
								v21 += v1103 * v26 + v1117 * v1103;
								v27 = v1111 * v26 + v1121;
								v23 += v26 * v1125 + v1117 * v1125;
								v24 += v26 * v1136 + v1117 * v1136;
								v25 += v26 * v1147 + v1117 * v1147;
								if (v1300)
								{
									v1119 = x_DWORD_DE568;
									v1123 = x_DWORD_DE568;
								}
								v28 = (x_DWORD*)&unk_DE56C;
							LABEL_51:
								if (v1296)
								{
									v31 = (unsigned __int8)x_BYTE_E126D;
								}
								else
								{
									do
									{
										*v28 = v21;
										v21 += v1103;
										v28[1] = v27;
										v27 += v1111;
										v28[2] = v23;
										v23 += v1125;
										v28[3] = v24;
										v24 += v1136;
										v28[4] = v25;
										v25 += v1147;
										v28 += 5;
										--v1119;
									} while (v1119);
									v31 = (unsigned __int8)x_BYTE_E126D;
								}
								goto LABEL_53;
							}
							v1117 += v1190;
							v21 += v1103 * v1157;
							v22 += v1157 * v1107;
							v23 += v1157 * v1125;
							v24 += v1157 * v1136;
							v25 += v1157 * v1147;
							if (v1300)
							{
								v1123 = x_DWORD_DE568;
								if (v1296)
								{
									v1117 = x_DWORD_DE568;
								}
								else
								{
									v1296 = x_DWORD_DE568 <= v1117;
									v1119 = x_DWORD_DE568 - v1117;
								}
							}
						}
						else if (v1300)
						{
							v29 = x_DWORD_DE568 - v1190;
							v1123 = x_DWORD_DE568 - v1190;
							if (v1296)
							{
								v1117 = x_DWORD_DE568 - v1190;
							}
							else
							{
								v18 = __OFSUB__(v29, v1117);
								v30 = v29 - v1117;
								v1296 = (v30 < 0) ^ v18 | (v30 == 0);
								v1119 = v30;
							}
						}
						v28 = (x_DWORD*)&unk_DE56C;
						do
						{
							*v28 = v21;
							v21 += v1103;
							v28[1] = v22;
							v22 += v1107;
							v28[2] = v23;
							v23 += v1125;
							v28[3] = v24;
							v24 += v1136;
							v28[4] = v25;
							v25 += v1147;
							v28 += 5;
							--v1117;
						} while (v1117);
						v27 = v1121;
						goto LABEL_51;
					}
				}
				return;
			}
			if (v7 != v8)
			{
				if (v7 <= v8)
					goto LABEL_24;
				goto LABEL_129;
			}
			if (*a2 <= *a3)
				return;
		LABEL_234:
			v117 = v3[1];
			v1192 = v117;
			if (v117 >= 0)
			{
				if (v117 >= x_DWORD_DE568)
					return;
				v1102 = x_DWORD_DE554 + x_DWORD_DE560 * v117;
				v1294 = 0;
			}
			else
			{
				v1102 = x_DWORD_DE554;
				v1294 = 1;
			}
			v118 = v5[1];
			v1298 = v118 > x_DWORD_DE568;
			v1115 = v118 - v117;
			v1123 = v118 - v117;
			v1105 = ((*v5 - *v3) << 16) / (v118 - v117);
			v1109 = ((*v4 - *v3) << 16) / (v118 - v117);
			switch (x_BYTE_E126D)
			{
			case 0:
			case 0xE:
			case 0xF:
				v139 = *v3 << 16;
				v140 = *v3 << 16;
				if (v1294)
				{
					v141 = -v1192;
					v1115 += v1192;
					v18 = __OFSUB__(v1123, -v1192);
					v16 = v1123 == -v1192;
					v17 = v1123 + v1192 < 0;
					v1123 += v1192;
					if ((unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16)
						return;
					v139 += v1105 * v141;
					v140 += v141 * v1109;
					if (v1298)
					{
						v1123 = x_DWORD_DE568;
						v1115 = x_DWORD_DE568;
					}
				}
				else if (v1298)
				{
					v1123 = x_DWORD_DE568 - v1192;
					v1115 = x_DWORD_DE568 - v1192;
				}
				v142 = (x_DWORD*)&unk_DE56C;
				do
				{
					*v142 = v139;
					v139 += v1105;
					v142[1] = v140;
					v140 += v1109;
					v142 += 5;
					--v1115;
				} while (v1115);
				v31 = (unsigned __int8)x_BYTE_E126D;
				goto LABEL_53;
			case 1:
			case 4:
			case 0x10:
			case 0x11:
				v1146 = (v4[4] - v5[4]) / (*v4 - *v5);
				v1152 = (v5[4] - v3[4]) / v1123;
				v134 = *v3 << 16;
				v135 = *v3 << 16;
				v136 = v3[4];
				if (v1294)
				{
					v137 = -v1192;
					v1115 += v1192;
					v18 = __OFSUB__(v1123, -v1192);
					v16 = v1123 == -v1192;
					v17 = v1123 + v1192 < 0;
					v1123 += v1192;
					if ((unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16)
						return;
					v134 += v1105 * v137;
					v135 += v137 * v1109;
					v136 += v137 * v1152;
					if (v1298)
					{
						v1123 = x_DWORD_DE568;
						v1115 = x_DWORD_DE568;
					}
				}
				else if (v1298)
				{
					v1123 = x_DWORD_DE568 - v1192;
					v1115 = x_DWORD_DE568 - v1192;
				}
				v138 = (x_DWORD*)&unk_DE56C;
				do
				{
					*v138 = v134;
					v134 += v1105;
					v138[1] = v135;
					v135 += v1109;
					v138[4] = v136;
					v136 += v1152;
					v138 += 5;
					--v1115;
				} while (v1115);
				v31 = (unsigned __int8)x_BYTE_E126D;
				goto LABEL_53;
			case 2:
			case 3:
			case 7:
			case 8:
			case 9:
			case 0xA:
			case 0xB:
			case 0xC:
			case 0xD:
			case 0x12:
			case 0x13:
			case 0x16:
			case 0x17:
				v127 = *v4 - *v5;
				v1124 = (v4[2] - v5[2]) / v127;
				v1135 = (v4[3] - v5[3]) / v127;
				v1130 = (v5[2] - v3[2]) / v1123;
				v1141 = (v5[3] - v3[3]) / v1123;
				v128 = *v3 << 16;
				v129 = *v3 << 16;
				v130 = v3[2];
				v131 = v3[3];
				if (v1294)
				{
					v132 = -v1192;
					v1115 += v1192;
					v18 = __OFSUB__(v1123, -v1192);
					v16 = v1123 == -v1192;
					v17 = v1123 + v1192 < 0;
					v1123 += v1192;
					if ((unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16)
						return;
					v128 += v1105 * v132;
					v129 += v132 * v1109;
					v130 += v132 * v1130;
					v131 += v132 * v1141;
					if (v1298)
					{
						v1123 = x_DWORD_DE568;
						v1115 = x_DWORD_DE568;
					}
				}
				else if (v1298)
				{
					v1123 = x_DWORD_DE568 - v1192;
					v1115 = x_DWORD_DE568 - v1192;
				}
				v133 = (x_DWORD*)&unk_DE56C;
				do
				{
					*v133 = v128;
					v128 += v1105;
					v133[1] = v129;
					v129 += v1109;
					v133[2] = v130;
					v130 += v1130;
					v133[3] = v131;
					v131 += v1141;
					v133 += 5;
					--v1115;
				} while (v1115);
				v31 = (unsigned __int8)x_BYTE_E126D;
				goto LABEL_53;
			case 5:
			case 6:
			case 0x14:
			case 0x15:
			case 0x18:
			case 0x19:
			case 0x1A:
				v119 = *v4 - *v5;
				v1124 = (v4[2] - v5[2]) / v119;
				v1135 = (v4[3] - v5[3]) / v119;
				v1146 = (v4[4] - v5[4]) / v119;
				v1129 = (v5[2] - v3[2]) / v1123;
				v1140 = (v5[3] - v3[3]) / v1123;
				v1151 = (v5[4] - v3[4]) / v1123;
				v120 = *v3 << 16;
				v121 = *v3 << 16;
				v122 = v3[2];
				v123 = v3[3];
				v124 = v3[4];
				if (v1294)
				{
					v125 = -v1192;
					v1115 += v1192;
					v18 = __OFSUB__(v1123, -v1192);
					v16 = v1123 == -v1192;
					v17 = v1123 + v1192 < 0;
					v1123 += v1192;
					if ((unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16)
						return;
					v120 += v1105 * v125;
					v121 += v125 * v1109;
					v122 += v125 * v1129;
					v123 += v125 * v1140;
					v124 += v125 * v1151;
					if (v1298)
					{
						v1123 = x_DWORD_DE568;
						v1115 = x_DWORD_DE568;
					}
				}
				else if (v1298)
				{
					v1123 = x_DWORD_DE568 - v1192;
					v1115 = x_DWORD_DE568 - v1192;
				}
				v126 = (x_DWORD*)&unk_DE56C;
				do
				{
					*v126 = v120;
					v120 += v1105;
					v126[1] = v121;
					v121 += v1109;
					v126[2] = v122;
					v122 += v1129;
					v126[3] = v123;
					v123 += v1140;
					v126[4] = v124;
					v124 += v1151;
					v126 += 5;
					--v1115;
				} while (v1115);
				v31 = (unsigned __int8)x_BYTE_E126D;
				goto LABEL_53;
			}
		}
		if (*a1 <= *a3)
			return;
		v3 = a3;
		v4 = a1;
		v5 = a2;
	LABEL_277:
		v143 = v3[1];
		v1193 = v143;
		if (v143 >= 0)
		{
			if (v143 >= x_DWORD_DE568)
				return;
			v1102 = x_DWORD_DE554 + x_DWORD_DE560 * v143;
			v1295 = 0;
		}
		else
		{
			v1102 = x_DWORD_DE554;
			v1295 = 1;
		}
		v144 = v5[1];
		v1299 = v144 > x_DWORD_DE568;
		v1116 = v144 - v143;
		v1123 = v144 - v143;
		v1106 = ((*v5 - *v3) << 16) / (v144 - v143);
		v1110 = ((*v5 - *v4) << 16) / (v144 - v143);
		switch (x_BYTE_E126D)
		{
		case 0:
		case 0xE:
		case 0xF:
			v165 = *v3 << 16;
			v166 = *v4 << 16;
			if (v1295)
			{
				v167 = -v1193;
				v1116 += v1193;
				v18 = __OFSUB__(v1123, -v1193);
				v16 = v1123 == -v1193;
				v17 = v1123 + v1193 < 0;
				v1123 += v1193;
				if ((unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16)
					return;
				v165 += v1106 * v167;
				v166 += v167 * v1110;
				if (v1299)
				{
					v1123 = x_DWORD_DE568;
					v1116 = x_DWORD_DE568;
				}
			}
			else if (v1299)
			{
				v1123 = x_DWORD_DE568 - v1193;
				v1116 = x_DWORD_DE568 - v1193;
			}
			v168 = (x_DWORD*)&unk_DE56C;
			do
			{
				*v168 = v165;
				v165 += v1106;
				v168[1] = v166;
				v166 += v1110;
				v168 += 5;
				--v1116;
			} while (v1116);
			v31 = (unsigned __int8)x_BYTE_E126D;
			goto LABEL_53;
		case 1:
		case 4:
		case 0x10:
		case 0x11:
			v1146 = (v4[4] - v3[4]) / (*v4 - *v3);
			v1154 = (v5[4] - v3[4]) / v1123;
			v160 = *v3 << 16;
			v161 = *v4 << 16;
			v162 = v3[4];
			if (v1295)
			{
				v163 = -v1193;
				v1116 += v1193;
				v18 = __OFSUB__(v1123, -v1193);
				v16 = v1123 == -v1193;
				v17 = v1123 + v1193 < 0;
				v1123 += v1193;
				if ((unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16)
					return;
				v160 += v1106 * v163;
				v161 += v163 * v1110;
				v162 += v163 * v1154;
				if (v1299)
				{
					v1123 = x_DWORD_DE568;
					v1116 = x_DWORD_DE568;
				}
			}
			else if (v1299)
			{
				v1123 = x_DWORD_DE568 - v1193;
				v1116 = x_DWORD_DE568 - v1193;
			}
			v164 = (x_DWORD*)&unk_DE56C;
			do
			{
				*v164 = v160;
				v160 += v1106;
				v164[1] = v161;
				v161 += v1110;
				v164[4] = v162;
				v162 += v1154;
				v164 += 5;
				--v1116;
			} while (v1116);
			v31 = (unsigned __int8)x_BYTE_E126D;
			goto LABEL_53;
		case 2:
		case 3:
		case 7:
		case 8:
		case 9:
		case 0xA:
		case 0xB:
		case 0xC:
		case 0xD:
		case 0x12:
		case 0x13:
		case 0x16:
		case 0x17:
			v153 = *v4 - *v3;
			v1124 = (v4[2] - v3[2]) / v153;
			v1135 = (v4[3] - v3[3]) / v153;
			v1132 = (v5[2] - v3[2]) / v1123;
			v1143 = (v5[3] - v3[3]) / v1123;
			v154 = *v3 << 16;
			v155 = *v4 << 16;
			v156 = v3[2];
			v157 = v3[3];
			if (v1295)
			{
				v158 = -v1193;
				v1116 += v1193;
				v18 = __OFSUB__(v1123, -v1193);
				v16 = v1123 == -v1193;
				v17 = v1123 + v1193 < 0;
				v1123 += v1193;
				if ((unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16)
					return;
				v154 += v1106 * v158;
				v155 += v158 * v1110;
				v156 += v158 * v1132;
				v157 += v158 * v1143;
				if (v1299)
				{
					v1123 = x_DWORD_DE568;
					v1116 = x_DWORD_DE568;
				}
			}
			else if (v1299)
			{
				v1123 = x_DWORD_DE568 - v1193;
				v1116 = x_DWORD_DE568 - v1193;
			}
			v159 = (x_DWORD*)&unk_DE56C;
			do
			{
				*v159 = v154;
				v154 += v1106;
				v159[1] = v155;
				v155 += v1110;
				v159[2] = v156;
				v156 += v1132;
				v159[3] = v157;
				v157 += v1143;
				v159 += 5;
				--v1116;
			} while (v1116);
			v31 = (unsigned __int8)x_BYTE_E126D;
			goto LABEL_53;
		case 5:
		case 6:
		case 0x14:
		case 0x15:
		case 0x18:
		case 0x19:
		case 0x1A:
			v145 = *v4 - *v3;
			v1124 = (v4[2] - v3[2]) / v145;
			v1135 = (v4[3] - v3[3]) / v145;
			v1146 = (v4[4] - v3[4]) / v145;
			v1131 = (v5[2] - v3[2]) / v1123;
			v1142 = (v5[3] - v3[3]) / v1123;
			v1153 = (v5[4] - v3[4]) / v1123;
			v146 = *v3 << 16;
			v147 = *v4 << 16;
			v148 = v3[2];
			v149 = v3[3];
			v150 = v3[4];
			if (v1295)
			{
				v151 = -v1193;
				v1116 += v1193;
				v18 = __OFSUB__(v1123, -v1193);
				v16 = v1123 == -v1193;
				v17 = v1123 + v1193 < 0;
				v1123 += v1193;
				if ((unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16)
					return;
				v146 += v1106 * v151;
				v147 += v151 * v1110;
				v148 += v151 * v1131;
				v149 += v151 * v1142;
				v150 += v151 * v1153;
				if (v1299)
				{
					v1123 = x_DWORD_DE568;
					v1116 = x_DWORD_DE568;
				}
			}
			else if (v1299)
			{
				v1123 = x_DWORD_DE568 - v1193;
				v1116 = x_DWORD_DE568 - v1193;
			}
			v152 = (x_DWORD*)&unk_DE56C;
			do
			{
				*v152 = v146;
				v146 += v1106;
				v152[1] = v147;
				v147 += v1110;
				v152[2] = v148;
				v148 += v1131;
				v152[3] = v149;
				v149 += v1142;
				v152[4] = v150;
				v150 += v1153;
				v152 += 5;
				--v1116;
			} while (v1116);
			v31 = (unsigned __int8)x_BYTE_E126D;
			goto LABEL_53;
		}
	}
	if (v6 == v8)
	{
		if (*a3 <= *a1)
			return;
		v3 = a2;
		v4 = a3;
		v5 = a1;
		goto LABEL_234;
	}
	if (v6 < v8)
	{
		v3 = a2;
		v4 = a3;
		v5 = a1;
		goto LABEL_129;
	}
	if (v7 == v8)
	{
		if (*a3 <= *a2)
			return;
		v3 = a2;
		v4 = a3;
		v5 = a1;
		goto LABEL_277;
	}
	if (v7 < v8)
	{
		v3 = a2;
		v4 = a3;
		v5 = a1;
		goto LABEL_24;
	}
	v3 = a3;
	v4 = a1;
	v5 = a2;
LABEL_129:
	v65 = v3[1];
	v1191 = v65;
	if (v65 >= 0)
	{
		if (v65 >= x_DWORD_DE568)
			return;
		v1102 = x_DWORD_DE554 + x_DWORD_DE560 * v65;
		v1293 = 0;
	}
	else
	{
		v1102 = x_DWORD_DE554;
		v1293 = 1;
	}
	v66 = v5[1];
	v1297 = v66 > x_DWORD_DE568;
	v1114 = v66 - v65;
	v67 = v4[1];
	v1301 = v67 > x_DWORD_DE568;
	v68 = v67 - v65;
	v1118 = v68;
	v1123 = v68;
	v1104 = ((*v5 - *v3) << 16) / v1114;
	if (((*v4 - *v3) << 16) / v68 > v1104)
	{
		v1108 = ((*v4 - *v3) << 16) / v68;
		v1112 = ((*v4 - *v5) << 16) / (v4[1] - v5[1]);
		v1120 = v4[1] - v5[1];
		v1122 = *v5 << 16;
		switch (x_BYTE_E126D)
		{
		case 0:
		case 0xE:
		case 0xF:
			v110 = *v3 << 16;
			v111 = *v3 << 16;
			if (v1293)
			{
				v18 = __OFSUB__(v1123, -v1191);
				v16 = v1123 == -v1191;
				v17 = v1123 + v1191 < 0;
				v1123 += v1191;
				if ((unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16)
					return;
				v1164 = -v1191;
				if (-v1191 - v1114 >= 0)
				{
					v112 = v1164 - v1114;
					v1120 -= v112;
					v113 = v1112 * v112 + v1122;
					v111 += v112 * v1108 + v1114 * v1108;
					if (v1301)
					{
						v1120 = x_DWORD_DE568;
						v1123 = x_DWORD_DE568;
					}
					v114 = (int *)&unk_DE56C;
					goto LABEL_228;
				}
				v1114 += v1191;
				v110 += v1104 * v1164;
				v111 += v1164 * v1108;
				if (v1301)
				{
					v1123 = x_DWORD_DE568;
					if (v1297)
					{
						v1114 = x_DWORD_DE568;
					}
					else
					{
						v1297 = x_DWORD_DE568 <= v1114;
						v1120 = x_DWORD_DE568 - v1114;
					}
				}
			}
			else if (v1301)
			{
				v115 = x_DWORD_DE568 - v1191;
				v1123 = x_DWORD_DE568 - v1191;
				if (v1297)
				{
					v1114 = x_DWORD_DE568 - v1191;
				}
				else
				{
					v18 = __OFSUB__(v115, v1114);
					v116 = v115 - v1114;
					v1297 = (v116 < 0) ^ v18 | (v116 == 0);
					v1120 = v116;
				}
			}
			v114 = (int *)&unk_DE56C;
			do
			{
				*v114 = v110;
				v110 += v1104;
				v114[1] = v111;
				v111 += v1108;
				v114 += 5;
				--v1114;
			} while (v1114);
			v113 = v1122;
		LABEL_228:
			if (v1297)
			{
				v31 = (unsigned __int8)x_BYTE_E126D;
			}
			else
			{
				do
				{
					*v114 = v113;
					v113 += v1112;
					v114[1] = v111;
					v111 += v1108;
					v114 += 5;
					--v1120;
				} while (v1120);
				v31 = (unsigned __int8)x_BYTE_E126D;
			}
			goto LABEL_53;
		case 1:
		case 4:
		case 0x10:
		case 0x11:
			v98 = v1114 * (signed __int64)(*v4 - *v3) / v68;
			v99 = *v3 - *v5;
			v18 = __OFADD__(v98, v99);
			v100 = v98 + v99 == 0;
			v17 = v98 + v99 < 0;
			v101 = v98 + v99;
			if ((unsigned __int8)v17 ^ v18)
				return;
			if (!v100)
				v1146 = (signed int)(v3[4] + (unsigned __int64)(v1114 * (signed __int64)(v4[4] - v3[4]) / v1118) - v5[4])
				/ (v101 + 1);
			v1150 = (v5[4] - v3[4]) / v1114;
			v1156 = (v4[4] - v5[4]) / v1120;
			v102 = *v3 << 16;
			v103 = *v3 << 16;
			v104 = v3[4];
			if (v1293)
			{
				v18 = __OFSUB__(v1123, -v1191);
				v16 = v1123 == -v1191;
				v17 = v1123 + v1191 < 0;
				v1123 += v1191;
				if ((unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16)
					return;
				v1163 = -v1191;
				if (-v1191 - v1114 >= 0)
				{
					v105 = v1163 - v1114;
					v1120 -= v105;
					v106 = v1112 * v105 + v1122;
					v103 += v105 * v1108 + v1114 * v1108;
					v104 += v105 * v1156 + v1114 * v1150;
					if (v1301)
					{
						v1120 = x_DWORD_DE568;
						v1123 = x_DWORD_DE568;
					}
					v107 = (int *)&unk_DE56C;
				LABEL_206:
					if (v1297)
					{
						v31 = (unsigned __int8)x_BYTE_E126D;
					}
					else
					{
						do
						{
							*v107 = v106;
							v106 += v1112;
							v107[1] = v103;
							v103 += v1108;
							v107[4] = v104;
							v104 += v1156;
							v107 += 5;
							--v1120;
						} while (v1120);
						v31 = (unsigned __int8)x_BYTE_E126D;
					}
					goto LABEL_53;
				}
				v1114 += v1191;
				v102 += v1104 * v1163;
				v103 += v1163 * v1108;
				v104 += v1163 * v1150;
				if (v1301)
				{
					v1123 = x_DWORD_DE568;
					if (v1297)
					{
						v1114 = x_DWORD_DE568;
					}
					else
					{
						v1297 = x_DWORD_DE568 <= v1114;
						v1120 = x_DWORD_DE568 - v1114;
					}
				}
			}
			else if (v1301)
			{
				v108 = x_DWORD_DE568 - v1191;
				v1123 = x_DWORD_DE568 - v1191;
				if (v1297)
				{
					v1114 = x_DWORD_DE568 - v1191;
				}
				else
				{
					v18 = __OFSUB__(v108, v1114);
					v109 = v108 - v1114;
					v1297 = (v109 < 0) ^ v18 | (v109 == 0);
					v1120 = v109;
				}
			}
			v107 = (int *)&unk_DE56C;
			do
			{
				*v107 = v102;
				v102 += v1104;
				v107[1] = v103;
				v103 += v1108;
				v107[4] = v104;
				v104 += v1150;
				v107 += 5;
				--v1114;
			} while (v1114);
			v106 = v1122;
			goto LABEL_206;
		case 2:
		case 3:
		case 7:
		case 8:
		case 9:
		case 0xA:
		case 0xB:
		case 0xC:
		case 0xD:
		case 0x12:
		case 0x13:
		case 0x16:
		case 0x17:
			v84 = v1114 * (signed __int64)(*v4 - *v3) / v68;
			v85 = *v3 - *v5;
			v18 = __OFADD__(v84, v85);
			v86 = v84 + v85 == 0;
			v17 = v84 + v85 < 0;
			v87 = v84 + v85;
			if ((unsigned __int8)v17 ^ v18)
				return;
			if (!v86)
			{
				v88 = v87 + 1;
				v1124 = (signed int)(v3[2] + (unsigned __int64)(v1114 * (signed __int64)(v4[2] - v3[2]) / v1118) - v5[2])
					/ v88;
				v1135 = (signed int)(v3[3] + (unsigned __int64)(v1114 * (signed __int64)(v4[3] - v3[3]) / v1118) - v5[3])
					/ v88;
			}
			v1128 = (v5[2] - v3[2]) / v1114;
			v1139 = (v5[3] - v3[3]) / v1114;
			v1134 = (v4[2] - v5[2]) / v1120;
			v1145 = (v4[3] - v5[3]) / v1120;
			v89 = *v3 << 16;
			v90 = *v3 << 16;
			v91 = v3[2];
			v92 = v3[3];
			if (v1293)
			{
				v18 = __OFSUB__(v1123, -v1191);
				v16 = v1123 == -v1191;
				v17 = v1123 + v1191 < 0;
				v1123 += v1191;
				if ((unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16)
					return;
				v1162 = -v1191;
				if (-v1191 - v1114 >= 0)
				{
					v93 = v1162 - v1114;
					v1120 -= v93;
					v94 = v1112 * v93 + v1122;
					v90 += v93 * v1108 + v1114 * v1108;
					v91 += v93 * v1134 + v1114 * v1128;
					v92 += v93 * v1145 + v1114 * v1139;
					if (v1301)
					{
						v1120 = x_DWORD_DE568;
						v1123 = x_DWORD_DE568;
					}
					v95 = (int *)&unk_DE56C;
				LABEL_181:
					if (v1297)
					{
						v31 = (unsigned __int8)x_BYTE_E126D;
					}
					else
					{
						do
						{
							*v95 = v94;
							v94 += v1112;
							v95[1] = v90;
							v90 += v1108;
							v95[2] = v91;
							v91 += v1134;
							v95[3] = v92;
							v92 += v1145;
							v95 += 5;
							--v1120;
						} while (v1120);
						v31 = (unsigned __int8)x_BYTE_E126D;
					}
					goto LABEL_53;
				}
				v1114 += v1191;
				v89 += v1104 * v1162;
				v90 += v1162 * v1108;
				v91 += v1162 * v1128;
				v92 += v1162 * v1139;
				if (v1301)
				{
					v1123 = x_DWORD_DE568;
					if (v1297)
					{
						v1114 = x_DWORD_DE568;
					}
					else
					{
						v1297 = x_DWORD_DE568 <= v1114;
						v1120 = x_DWORD_DE568 - v1114;
					}
				}
			}
			else if (v1301)
			{
				v96 = x_DWORD_DE568 - v1191;
				v1123 = x_DWORD_DE568 - v1191;
				if (v1297)
				{
					v1114 = x_DWORD_DE568 - v1191;
				}
				else
				{
					v18 = __OFSUB__(v96, v1114);
					v97 = v96 - v1114;
					v1297 = (v97 < 0) ^ v18 | (v97 == 0);
					v1120 = v97;
				}
			}
			v95 = (int *)&unk_DE56C;
			do
			{
				*v95 = v89;
				v89 += v1104;
				v95[1] = v90;
				v90 += v1108;
				v95[2] = v91;
				v91 += v1128;
				v95[3] = v92;
				v92 += v1139;
				v95 += 5;
				--v1114;
			} while (v1114);
			v94 = v1122;
			goto LABEL_181;
		case 5:
		case 6:
		case 0x14:
		case 0x15:
		case 0x18:
		case 0x19:
		case 0x1A:
			v69 = v1114 * (signed __int64)(*v4 - *v3) / v68;
			v70 = *v3 - *v5;
			v18 = __OFADD__(v69, v70);
			v71 = v69 + v70 == 0;
			v17 = v69 + v70 < 0;
			v72 = v69 + v70;
			if ((unsigned __int8)v17 ^ v18)
				return;
			if (!v71)
			{
				v73 = v72 + 1;
				v1124 = (signed int)(v3[2] + (unsigned __int64)(v1114 * (signed __int64)(v4[2] - v3[2]) / v1118) - v5[2])
					/ v73;
				v1135 = (signed int)(v3[3] + (unsigned __int64)(v1114 * (signed __int64)(v4[3] - v3[3]) / v1118) - v5[3])
					/ v73;
				v69 = (signed int)(v3[4] + (unsigned __int64)(v1114 * (signed __int64)(v4[4] - v3[4]) / v1118) - v5[4]) / v73;
			}
			v1146 = v69;
			v1127 = (v5[2] - v3[2]) / v1114;
			v1138 = (v5[3] - v3[3]) / v1114;
			v1149 = (v5[4] - v3[4]) / v1114;
			v1133 = (v4[2] - v5[2]) / v1120;
			v1144 = (v4[3] - v5[3]) / v1120;
			v1155 = (v4[4] - v5[4]) / v1120;
			v74 = *v3 << 16;
			v75 = *v3 << 16;
			v76 = v3[2];
			v77 = v3[3];
			v78 = v3[4];
			if (v1293)
			{
				v18 = __OFSUB__(v1123, -v1191);
				v16 = v1123 == -v1191;
				v17 = v1123 + v1191 < 0;
				v1123 += v1191;
				if ((unsigned __int8)(v17 ^ v18) | (unsigned __int8)v16)
					return;
				v1161 = -v1191;
				if (-v1191 - v1114 >= 0)
				{
					v79 = v1161 - v1114;
					v1120 -= v79;
					v80 = v1112 * v79 + v1122;
					v75 += v79 * v1108 + v1114 * v1108;
					v76 += v79 * v1133 + v1114 * v1127;
					v77 += v79 * v1144 + v1114 * v1138;
					v78 += v79 * v1155 + v1114 * v1149;
					if (v1301)
					{
						v1120 = x_DWORD_DE568;
						v1123 = x_DWORD_DE568;
					}
					v81 = (int *)&unk_DE56C;
				LABEL_156:
					if (v1297)
					{
						v31 = (unsigned __int8)x_BYTE_E126D;
					}
					else
					{
						do
						{
							*v81 = v80;
							v80 += v1112;
							v81[1] = v75;
							v75 += v1108;
							v81[2] = v76;
							v76 += v1133;
							v81[3] = v77;
							v77 += v1144;
							v81[4] = v78;
							v78 += v1155;
							v81 += 5;
							--v1120;
						} while (v1120);
						v31 = (unsigned __int8)x_BYTE_E126D;
					}
				LABEL_53:
					switch (x_BYTE_E126D)
					{
					case 0:
						v169 = (unsigned __int16 *)&unk_DE56C;
						v170 = (char *)v1102;
						v171 = x_BYTE_E126C;
						HIWORD(v172) = 0;
						while (1)
						{
							LOWORD(v172) = v169[1];
							v173 = v169[3];
							v170 += x_DWORD_DE560;
							if ((v172 & 0x8000u) == 0)
								break;
							if ((signed __int16)v173 > 0)
							{
								if (v173 > x_DWORD_DE564)
									v173 = x_DWORD_DE564;
								v174 = v170;
							LABEL_328:
								memset(v174, v171, v173);
							}
						LABEL_329:
							v169 += 10;
							if (!--v1123)
								return;
						}
						if (v173 > x_DWORD_DE564)
							v173 = x_DWORD_DE564;
						v18 = __OFSUB__((x_WORD)v173, (x_WORD)v172);
						LOWORD(v173) = v173 - v172;
						if ((unsigned __int8)(((v173 & 0x8000u) != 0) ^ v18) | ((x_WORD)v173 == 0))
							goto LABEL_329;
						v174 = &v170[v172];
						goto LABEL_328;
					case 1:
						v175 = (unsigned __int16 *)&unk_DE56C;
						while (1)
						{
							LOWORD(v31) = v175[1];
							v176 = v175[3];
							v177 = (x_BYTE *)(x_DWORD_DE560 + v1102);
							v1102 += x_DWORD_DE560;
							if ((v31 & 0x8000u) == 0)
								break;
							if ((signed __int16)v176 > 0)
							{
								v178 = v1146 * (unsigned __int16)-(signed __int16)v31;
								v179 = v178;
								v31 = v178 >> 8;
								v180 = __CFADD__(v175[8], v179);
								v181 = v175[8] + v179;
								BYTE1(v31) += *((x_BYTE *)v175 + 18) + v180;
								if (v176 > x_DWORD_DE564)
									LOWORD(v176) = x_DWORD_DE564;
								v31 = (unsigned __int16)v31;
							LABEL_341:
								while (1)
								{
									*v177 = BYTE1(v31);
									v180 = __CFADD__((x_WORD)v1146, v181);
									v182 = v1146 + v181;
									v183 = BYTE2(v1146) + v180 + BYTE1(v31);
									v184 = v176 - 1;
									if (!v184)
										break;
									v177[1] = v183;
									v180 = __CFADD__((x_WORD)v1146, v182);
									v185 = v1146 + v182;
									v186 = BYTE2(v1146) + v180 + v183;
									v187 = v184 - 1;
									if (!v187)
										break;
									v177[2] = v186;
									v180 = __CFADD__((x_WORD)v1146, v185);
									v188 = v1146 + v185;
									v189 = BYTE2(v1146) + v180 + v186;
									v190 = v187 - 1;
									if (!v190)
										break;
									v177[3] = v189;
									v180 = __CFADD__((x_WORD)v1146, v188);
									v191 = v1146 + v188;
									v192 = BYTE2(v1146) + v180 + v189;
									v193 = v190 - 1;
									if (!v193)
										break;
									v177[4] = v192;
									v180 = __CFADD__((x_WORD)v1146, v191);
									v194 = v1146 + v191;
									v195 = BYTE2(v1146) + v180 + v192;
									v196 = v193 - 1;
									if (!v196)
										break;
									v177[5] = v195;
									v180 = __CFADD__((x_WORD)v1146, v194);
									v197 = v1146 + v194;
									v198 = BYTE2(v1146) + v180 + v195;
									v199 = v196 - 1;
									if (!v199)
										break;
									v177[6] = v198;
									v180 = __CFADD__((x_WORD)v1146, v197);
									v200 = v1146 + v197;
									v201 = BYTE2(v1146) + v180 + v198;
									v202 = v199 - 1;
									if (!v202)
										break;
									v177[7] = v201;
									v180 = __CFADD__((x_WORD)v1146, v200);
									v203 = v1146 + v200;
									v204 = BYTE2(v1146) + v180 + v201;
									v205 = v202 - 1;
									if (!v205)
										break;
									v177[8] = v204;
									v180 = __CFADD__((x_WORD)v1146, v203);
									v206 = v1146 + v203;
									v207 = BYTE2(v1146) + v180 + v204;
									v208 = v205 - 1;
									if (!v208)
										break;
									v177[9] = v207;
									v180 = __CFADD__((x_WORD)v1146, v206);
									v209 = v1146 + v206;
									v210 = BYTE2(v1146) + v180 + v207;
									v211 = v208 - 1;
									if (!v211)
										break;
									v177[10] = v210;
									v180 = __CFADD__((x_WORD)v1146, v209);
									v212 = v1146 + v209;
									v213 = BYTE2(v1146) + v180 + v210;
									v214 = v211 - 1;
									if (!v214)
										break;
									v177[11] = v213;
									v180 = __CFADD__((x_WORD)v1146, v212);
									v215 = v1146 + v212;
									v216 = BYTE2(v1146) + v180 + v213;
									v217 = v214 - 1;
									if (!v217)
										break;
									v177[12] = v216;
									v180 = __CFADD__((x_WORD)v1146, v215);
									v218 = v1146 + v215;
									v219 = BYTE2(v1146) + v180 + v216;
									v220 = v217 - 1;
									if (!v220)
										break;
									v177[13] = v219;
									v180 = __CFADD__((x_WORD)v1146, v218);
									v221 = v1146 + v218;
									v222 = BYTE2(v1146) + v180 + v219;
									v223 = v220 - 1;
									if (!v223)
										break;
									v177[14] = v222;
									v180 = __CFADD__((x_WORD)v1146, v221);
									v224 = v1146 + v221;
									v225 = BYTE2(v1146) + v180 + v222;
									v226 = v223 - 1;
									if (!v226)
										break;
									v177[15] = v225;
									v180 = __CFADD__((x_WORD)v1146, v224);
									v181 = v1146 + v224;
									BYTE1(v31) = BYTE2(v1146) + v180 + v225;
									LOWORD(v176) = v226 - 1;
									if (!(x_WORD)v176)
										break;
									v177 += 16;
								}
							}
						LABEL_358:
							v175 += 10;
							if (!--v1123)
								return;
						}
						if (v176 > x_DWORD_DE564)
							LOWORD(v176) = x_DWORD_DE564;
						v18 = __OFSUB__((x_WORD)v176, (x_WORD)v31);
						LOWORD(v176) = v176 - v31;
						if ((unsigned __int8)(((v176 & 0x8000u) != 0) ^ v18) | ((x_WORD)v176 == 0))
							goto LABEL_358;
						v177 += v31;
						v31 = (unsigned __int8)x_BYTE_E126C;
						v181 = v175[8];
						BYTE1(v31) = *((x_BYTE *)v175 + 18);
						goto LABEL_341;
					case 2:
						v227 = (unsigned __int16 *)&unk_DE56C;
						v1165 = v1135 << 16;
						HIWORD(v228) = 0;
						HIWORD(v229) = 0;
						while (1)
						{
							LOWORD(v228) = v227[1];
							v230 = v227[3];
							v231 = (x_BYTE *)(x_DWORD_DE560 + v1102);
							v1102 += x_DWORD_DE560;
							if ((v228 & 0x8000u) == 0)
								break;
							if ((signed __int16)v230 > 0)
							{
								v232 = (unsigned __int16)-(signed __int16)v228;
								v234 = __ROL4__(*((x_DWORD *)v227 + 3) + v1135 * v232, 16);
								BYTE1(v229) = v234;
								v233 = *((x_DWORD *)v227 + 2) + v1124 * v232;
								LOWORD(v234) = v233;
								v235 = v233 >> 8;
								LOBYTE(v229) = BYTE1(v235);
								if (v230 > x_DWORD_DE564)
									LOWORD(v230) = x_DWORD_DE564;
								v228 = (unsigned __int16)v235;
							LABEL_370:
								v1274 = v227;
								v236 = x_DWORD_DE55C;
								while (1)
								{
									v237 = *(x_BYTE *)(v229 + v236);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v234);
									LOWORD(v234) = v1124 + v234;
									LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
									*v231 = v237;
									v180 = __CFADD__(v1165, v234);
									v238 = v1165 + v234;
									BYTE1(v229) += BYTE2(v1135) + v180;
									v239 = v230 - 1;
									if (!v239)
										break;
									v240 = *(x_BYTE *)(v229 + v236);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v238);
									LOWORD(v238) = v1124 + v238;
									LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
									v231[1] = v240;
									v180 = __CFADD__(v1165, v238);
									v241 = v1165 + v238;
									BYTE1(v229) += BYTE2(v1135) + v180;
									v242 = v239 - 1;
									if (!v242)
										break;
									v243 = *(x_BYTE *)(v229 + v236);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v241);
									LOWORD(v241) = v1124 + v241;
									LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
									v231[2] = v243;
									v180 = __CFADD__(v1165, v241);
									v244 = v1165 + v241;
									BYTE1(v229) += BYTE2(v1135) + v180;
									v245 = v242 - 1;
									if (!v245)
										break;
									v246 = *(x_BYTE *)(v229 + v236);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v244);
									LOWORD(v244) = v1124 + v244;
									LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
									v231[3] = v246;
									v180 = __CFADD__(v1165, v244);
									v247 = v1165 + v244;
									BYTE1(v229) += BYTE2(v1135) + v180;
									v248 = v245 - 1;
									if (!v248)
										break;
									v249 = *(x_BYTE *)(v229 + v236);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v247);
									LOWORD(v247) = v1124 + v247;
									LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
									v231[4] = v249;
									v180 = __CFADD__(v1165, v247);
									v250 = v1165 + v247;
									BYTE1(v229) += BYTE2(v1135) + v180;
									v251 = v248 - 1;
									if (!v251)
										break;
									v252 = *(x_BYTE *)(v229 + v236);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v250);
									LOWORD(v250) = v1124 + v250;
									LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
									v231[5] = v252;
									v180 = __CFADD__(v1165, v250);
									v253 = v1165 + v250;
									BYTE1(v229) += BYTE2(v1135) + v180;
									v254 = v251 - 1;
									if (!v254)
										break;
									v255 = *(x_BYTE *)(v229 + v236);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v253);
									LOWORD(v253) = v1124 + v253;
									LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
									v231[6] = v255;
									v180 = __CFADD__(v1165, v253);
									v256 = v1165 + v253;
									BYTE1(v229) += BYTE2(v1135) + v180;
									v257 = v254 - 1;
									if (!v257)
										break;
									v258 = *(x_BYTE *)(v229 + v236);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v256);
									LOWORD(v256) = v1124 + v256;
									LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
									v231[7] = v258;
									v180 = __CFADD__(v1165, v256);
									v259 = v1165 + v256;
									BYTE1(v229) += BYTE2(v1135) + v180;
									v260 = v257 - 1;
									if (!v260)
										break;
									v261 = *(x_BYTE *)(v229 + v236);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v259);
									LOWORD(v259) = v1124 + v259;
									LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
									v231[8] = v261;
									v180 = __CFADD__(v1165, v259);
									v262 = v1165 + v259;
									BYTE1(v229) += BYTE2(v1135) + v180;
									v263 = v260 - 1;
									if (!v263)
										break;
									v264 = *(x_BYTE *)(v229 + v236);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v262);
									LOWORD(v262) = v1124 + v262;
									LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
									v231[9] = v264;
									v180 = __CFADD__(v1165, v262);
									v265 = v1165 + v262;
									BYTE1(v229) += BYTE2(v1135) + v180;
									v266 = v263 - 1;
									if (!v266)
										break;
									v267 = *(x_BYTE *)(v229 + v236);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v265);
									LOWORD(v265) = v1124 + v265;
									LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
									v231[10] = v267;
									v180 = __CFADD__(v1165, v265);
									v268 = v1165 + v265;
									BYTE1(v229) += BYTE2(v1135) + v180;
									v269 = v266 - 1;
									if (!v269)
										break;
									v270 = *(x_BYTE *)(v229 + v236);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v268);
									LOWORD(v268) = v1124 + v268;
									LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
									v231[11] = v270;
									v180 = __CFADD__(v1165, v268);
									v271 = v1165 + v268;
									BYTE1(v229) += BYTE2(v1135) + v180;
									v272 = v269 - 1;
									if (!v272)
										break;
									v273 = *(x_BYTE *)(v229 + v236);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v271);
									LOWORD(v271) = v1124 + v271;
									LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
									v231[12] = v273;
									v180 = __CFADD__(v1165, v271);
									v274 = v1165 + v271;
									BYTE1(v229) += BYTE2(v1135) + v180;
									v275 = v272 - 1;
									if (!v275)
										break;
									v276 = *(x_BYTE *)(v229 + v236);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v274);
									LOWORD(v274) = v1124 + v274;
									LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
									v231[13] = v276;
									v180 = __CFADD__(v1165, v274);
									v277 = v1165 + v274;
									BYTE1(v229) += BYTE2(v1135) + v180;
									v278 = v275 - 1;
									if (!v278)
										break;
									v279 = *(x_BYTE *)(v229 + v236);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v277);
									LOWORD(v277) = v1124 + v277;
									LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
									v231[14] = v279;
									v180 = __CFADD__(v1165, v277);
									v280 = v1165 + v277;
									BYTE1(v229) += BYTE2(v1135) + v180;
									v281 = v278 - 1;
									if (!v281)
										break;
									v282 = *(x_BYTE *)(v229 + v236);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v280);
									LOWORD(v280) = v1124 + v280;
									LOBYTE(v229) = BYTE2(v1124) + v180 + v229;
									v231[15] = v282;
									v180 = __CFADD__(v1165, v280);
									v234 = v1165 + v280;
									BYTE1(v229) += BYTE2(v1135) + v180;
									LOWORD(v230) = v281 - 1;
									if (!(x_WORD)v230)
										break;
									v231 += 16;
								}
								v227 = v1274;
							}
						LABEL_389:
							v227 += 10;
							if (!--v1123)
								return;
						}
						if (v230 > x_DWORD_DE564)
							LOWORD(v230) = x_DWORD_DE564;
						v18 = __OFSUB__((x_WORD)v230, (x_WORD)v228);
						LOWORD(v230) = v230 - v228;
						if ((unsigned __int8)(((v230 & 0x8000u) != 0) ^ v18) | ((x_WORD)v230 == 0))
							goto LABEL_389;
						v231 += v228;
						v234 = __ROL4__(*((x_DWORD *)v227 + 3), 16);
						BYTE1(v229) = v234;
						LOWORD(v234) = v227[4];
						LOBYTE(v229) = *((x_BYTE *)v227 + 10);
						goto LABEL_370;
					case 3:
						v283 = (unsigned __int16 *)&unk_DE56C;
						v1166 = v1135 << 16;
						HIWORD(v284) = 0;
						HIWORD(v285) = 0;
						while (1)
						{
							LOWORD(v284) = v283[1];
							v286 = v283[3];
							v287 = (x_BYTE *)(x_DWORD_DE560 + v1102);
							v1102 += x_DWORD_DE560;
							if ((v284 & 0x8000u) == 0)
								break;
							if ((signed __int16)v286 > 0)
							{
								v288 = (unsigned __int16)-(signed __int16)v284;
								v290 = __ROL4__(*((x_DWORD *)v283 + 3) + v1135 * v288, 16);
								BYTE1(v285) = v290;
								v289 = *((x_DWORD *)v283 + 2) + v1124 * v288;
								LOWORD(v290) = v289;
								v291 = v289 >> 8;
								LOBYTE(v285) = BYTE1(v291);
								if (v286 > x_DWORD_DE564)
									LOWORD(v286) = x_DWORD_DE564;
								v284 = (unsigned __int16)v291;
							LABEL_401:
								v1275 = v283;
								v292 = x_DWORD_DE55C;
								while (1)
								{
									v293 = *(x_BYTE *)(v285 + v292);
									if (v293)
										*v287 = v293;
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v290);
									LOWORD(v290) = v1124 + v290;
									LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
									v180 = __CFADD__(v1166, v290);
									v294 = v1166 + v290;
									BYTE1(v285) += BYTE2(v1135) + v180;
									v295 = v286 - 1;
									if (!v295)
										break;
									v296 = *(x_BYTE *)(v285 + v292);
									if (v296)
										v287[1] = v296;
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v294);
									LOWORD(v294) = v1124 + v294;
									LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
									v180 = __CFADD__(v1166, v294);
									v297 = v1166 + v294;
									BYTE1(v285) += BYTE2(v1135) + v180;
									v298 = v295 - 1;
									if (!v298)
										break;
									v299 = *(x_BYTE *)(v285 + v292);
									if (v299)
										v287[2] = v299;
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v297);
									LOWORD(v297) = v1124 + v297;
									LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
									v180 = __CFADD__(v1166, v297);
									v300 = v1166 + v297;
									BYTE1(v285) += BYTE2(v1135) + v180;
									v301 = v298 - 1;
									if (!v301)
										break;
									v302 = *(x_BYTE *)(v285 + v292);
									if (v302)
										v287[3] = v302;
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v300);
									LOWORD(v300) = v1124 + v300;
									LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
									v180 = __CFADD__(v1166, v300);
									v303 = v1166 + v300;
									BYTE1(v285) += BYTE2(v1135) + v180;
									v304 = v301 - 1;
									if (!v304)
										break;
									v305 = *(x_BYTE *)(v285 + v292);
									if (v305)
										v287[4] = v305;
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v303);
									LOWORD(v303) = v1124 + v303;
									LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
									v180 = __CFADD__(v1166, v303);
									v306 = v1166 + v303;
									BYTE1(v285) += BYTE2(v1135) + v180;
									v307 = v304 - 1;
									if (!v307)
										break;
									v308 = *(x_BYTE *)(v285 + v292);
									if (v308)
										v287[5] = v308;
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v306);
									LOWORD(v306) = v1124 + v306;
									LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
									v180 = __CFADD__(v1166, v306);
									v309 = v1166 + v306;
									BYTE1(v285) += BYTE2(v1135) + v180;
									v310 = v307 - 1;
									if (!v310)
										break;
									v311 = *(x_BYTE *)(v285 + v292);
									if (v311)
										v287[6] = v311;
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v309);
									LOWORD(v309) = v1124 + v309;
									LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
									v180 = __CFADD__(v1166, v309);
									v312 = v1166 + v309;
									BYTE1(v285) += BYTE2(v1135) + v180;
									v313 = v310 - 1;
									if (!v313)
										break;
									v314 = *(x_BYTE *)(v285 + v292);
									if (v314)
										v287[7] = v314;
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v312);
									LOWORD(v312) = v1124 + v312;
									LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
									v180 = __CFADD__(v1166, v312);
									v315 = v1166 + v312;
									BYTE1(v285) += BYTE2(v1135) + v180;
									v316 = v313 - 1;
									if (!v316)
										break;
									v317 = *(x_BYTE *)(v285 + v292);
									if (v317)
										v287[8] = v317;
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v315);
									LOWORD(v315) = v1124 + v315;
									LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
									v180 = __CFADD__(v1166, v315);
									v318 = v1166 + v315;
									BYTE1(v285) += BYTE2(v1135) + v180;
									v319 = v316 - 1;
									if (!v319)
										break;
									v320 = *(x_BYTE *)(v285 + v292);
									if (v320)
										v287[9] = v320;
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v318);
									LOWORD(v318) = v1124 + v318;
									LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
									v180 = __CFADD__(v1166, v318);
									v321 = v1166 + v318;
									BYTE1(v285) += BYTE2(v1135) + v180;
									v322 = v319 - 1;
									if (!v322)
										break;
									v323 = *(x_BYTE *)(v285 + v292);
									if (v323)
										v287[10] = v323;
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v321);
									LOWORD(v321) = v1124 + v321;
									LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
									v180 = __CFADD__(v1166, v321);
									v324 = v1166 + v321;
									BYTE1(v285) += BYTE2(v1135) + v180;
									v325 = v322 - 1;
									if (!v325)
										break;
									v326 = *(x_BYTE *)(v285 + v292);
									if (v326)
										v287[11] = v326;
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v324);
									LOWORD(v324) = v1124 + v324;
									LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
									v180 = __CFADD__(v1166, v324);
									v327 = v1166 + v324;
									BYTE1(v285) += BYTE2(v1135) + v180;
									v328 = v325 - 1;
									if (!v328)
										break;
									v329 = *(x_BYTE *)(v285 + v292);
									if (v329)
										v287[12] = v329;
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v327);
									LOWORD(v327) = v1124 + v327;
									LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
									v180 = __CFADD__(v1166, v327);
									v330 = v1166 + v327;
									BYTE1(v285) += BYTE2(v1135) + v180;
									v331 = v328 - 1;
									if (!v331)
										break;
									v332 = *(x_BYTE *)(v285 + v292);
									if (v332)
										v287[13] = v332;
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v330);
									LOWORD(v330) = v1124 + v330;
									LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
									v180 = __CFADD__(v1166, v330);
									v333 = v1166 + v330;
									BYTE1(v285) += BYTE2(v1135) + v180;
									v334 = v331 - 1;
									if (!v334)
										break;
									v335 = *(x_BYTE *)(v285 + v292);
									if (v335)
										v287[14] = v335;
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v333);
									LOWORD(v333) = v1124 + v333;
									LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
									v180 = __CFADD__(v1166, v333);
									v336 = v1166 + v333;
									BYTE1(v285) += BYTE2(v1135) + v180;
									v337 = v334 - 1;
									if (!v337)
										break;
									v338 = *(x_BYTE *)(v285 + v292);
									if (v338)
										v287[15] = v338;
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v336);
									LOWORD(v336) = v1124 + v336;
									LOBYTE(v285) = BYTE2(v1124) + v180 + v285;
									v180 = __CFADD__(v1166, v336);
									v290 = v1166 + v336;
									BYTE1(v285) += BYTE2(v1135) + v180;
									LOWORD(v286) = v337 - 1;
									if (!(x_WORD)v286)
										break;
									v287 += 16;
								}
								v283 = v1275;
							}
						LABEL_452:
							v283 += 10;
							if (!--v1123)
								return;
						}
						if (v286 > x_DWORD_DE564)
							LOWORD(v286) = x_DWORD_DE564;
						v18 = __OFSUB__((x_WORD)v286, (x_WORD)v284);
						LOWORD(v286) = v286 - v284;
						if ((unsigned __int8)(((v286 & 0x8000u) != 0) ^ v18) | ((x_WORD)v286 == 0))
							goto LABEL_452;
						v287 += v284;
						v290 = __ROL4__(*((x_DWORD *)v283 + 3), 16);
						BYTE1(v285) = v290;
						LOWORD(v290) = v283[4];
						LOBYTE(v285) = *((x_BYTE *)v283 + 10);
						goto LABEL_401;
					case 4:
						v339 = (unsigned __int16 *)&unk_DE56C;
						while (1)
						{
							LOWORD(v31) = v339[1];
							v340 = v339[3];
							v341 = (x_BYTE *)(x_DWORD_DE560 + v1102);
							v1102 += x_DWORD_DE560;
							if ((v31 & 0x8000u) == 0)
								break;
							if ((signed __int16)v340 > 0)
							{
								v342 = v1146 * (unsigned __int16)-(signed __int16)v31;
								v343 = v342;
								v31 = v342 >> 8;
								v180 = __CFADD__(v339[8], v343);
								v344 = v339[8] + v343;
								BYTE1(v31) += *((x_BYTE *)v339 + 18) + v180;
								if (v340 > x_DWORD_DE564)
									LOWORD(v340) = x_DWORD_DE564;
								v31 = (unsigned __int16)v31;
								LOBYTE(v31) = x_BYTE_E126C;
							LABEL_464:
								while (1)
								{
									*v341 = x_BYTE_F6EE0_tables[v31];
									v180 = __CFADD__((x_WORD)v1146, v344);
									v345 = v1146 + v344;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v346 = v340 - 1;
									if (!v346)
										break;
									v341[1] = x_BYTE_F6EE0_tables[v31];
									v180 = __CFADD__((x_WORD)v1146, v345);
									v347 = v1146 + v345;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v348 = v346 - 1;
									if (!v348)
										break;
									v341[2] = x_BYTE_F6EE0_tables[v31];
									v180 = __CFADD__((x_WORD)v1146, v347);
									v349 = v1146 + v347;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v350 = v348 - 1;
									if (!v350)
										break;
									v341[3] = x_BYTE_F6EE0_tables[v31];
									v180 = __CFADD__((x_WORD)v1146, v349);
									v351 = v1146 + v349;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v352 = v350 - 1;
									if (!v352)
										break;
									v341[4] = x_BYTE_F6EE0_tables[v31];
									v180 = __CFADD__((x_WORD)v1146, v351);
									v353 = v1146 + v351;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v354 = v352 - 1;
									if (!v354)
										break;
									v341[5] = x_BYTE_F6EE0_tables[v31];
									v180 = __CFADD__((x_WORD)v1146, v353);
									v355 = v1146 + v353;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v356 = v354 - 1;
									if (!v356)
										break;
									v341[6] = x_BYTE_F6EE0_tables[v31];
									v180 = __CFADD__((x_WORD)v1146, v355);
									v357 = v1146 + v355;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v358 = v356 - 1;
									if (!v358)
										break;
									v341[7] = x_BYTE_F6EE0_tables[v31];
									v180 = __CFADD__((x_WORD)v1146, v357);
									v359 = v1146 + v357;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v360 = v358 - 1;
									if (!v360)
										break;
									v341[8] = x_BYTE_F6EE0_tables[v31];
									v180 = __CFADD__((x_WORD)v1146, v359);
									v361 = v1146 + v359;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v362 = v360 - 1;
									if (!v362)
										break;
									v341[9] = x_BYTE_F6EE0_tables[v31];
									v180 = __CFADD__((x_WORD)v1146, v361);
									v363 = v1146 + v361;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v364 = v362 - 1;
									if (!v364)
										break;
									v341[10] = x_BYTE_F6EE0_tables[v31];
									v180 = __CFADD__((x_WORD)v1146, v363);
									v365 = v1146 + v363;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v366 = v364 - 1;
									if (!v366)
										break;
									v341[11] = x_BYTE_F6EE0_tables[v31];
									v180 = __CFADD__((x_WORD)v1146, v365);
									v367 = v1146 + v365;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v368 = v366 - 1;
									if (!v368)
										break;
									v341[12] = x_BYTE_F6EE0_tables[v31];
									v180 = __CFADD__((x_WORD)v1146, v367);
									v369 = v1146 + v367;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v370 = v368 - 1;
									if (!v370)
										break;
									v341[13] = x_BYTE_F6EE0_tables[v31];
									v180 = __CFADD__((x_WORD)v1146, v369);
									v371 = v1146 + v369;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v372 = v370 - 1;
									if (!v372)
										break;
									v341[14] = x_BYTE_F6EE0_tables[v31];
									v180 = __CFADD__((x_WORD)v1146, v371);
									v373 = v1146 + v371;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v374 = v372 - 1;
									if (!v374)
										break;
									v341[15] = x_BYTE_F6EE0_tables[v31];
									v180 = __CFADD__((x_WORD)v1146, v373);
									v344 = v1146 + v373;
									BYTE1(v31) += BYTE2(v1146) + v180;
									LOWORD(v340) = v374 - 1;
									if (!(x_WORD)v340)
										break;
									v341 += 16;
								}
							}
						LABEL_481:
							v339 += 10;
							if (!--v1123)
								return;
						}
						if (v340 > x_DWORD_DE564)
							LOWORD(v340) = x_DWORD_DE564;
						v18 = __OFSUB__((x_WORD)v340, (x_WORD)v31);
						LOWORD(v340) = v340 - v31;
						if ((unsigned __int8)(((v340 & 0x8000u) != 0) ^ v18) | ((x_WORD)v340 == 0))
							goto LABEL_481;
						v341 += v31;
						v31 = (unsigned __int8)x_BYTE_E126C;
						v344 = v339[8];
						BYTE1(v31) = *((x_BYTE *)v339 + 18);
						goto LABEL_464;
					case 5:
						v1276 = (char *)&unk_DE56C;
						v1167 = v1135 << 16;
						v1183 = v1146 << 16;
						HIWORD(v375) = 0;
						HIWORD(v376) = 0;
						while (1)
						{
							v377 = v1276;
							v1276 += 20;
							LOWORD(v375) = *((x_WORD *)v377 + 1);
							v378 = *((unsigned __int16 *)v377 + 3);
							v379 = x_DWORD_DE560 + v1102;
							v1102 += x_DWORD_DE560;
							if ((v375 & 0x8000u) == 0)
								break;
							if ((signed __int16)v378 > 0)
							{
								v380 = (unsigned __int16)-(signed __int16)v375;
								v381 = v380;
								v383 = __ROL4__(*((x_DWORD *)v377 + 3) + v1135 * v380, 16);
								BYTE1(v376) = v383;
								v382 = *((x_DWORD *)v377 + 2) + v1124 * v380;
								LOWORD(v383) = v382;
								v375 = v382 >> 8;
								LOBYTE(v376) = BYTE1(v375);
								v384 = __ROL4__(*((x_DWORD *)v377 + 4) + v1146 * v381, 16);
								BYTE1(v375) = v384;
								LOWORD(v384) = *((x_WORD *)v377 + 3);
								v375 = (unsigned __int16)v375;
								if ((signed __int16)v384 > (signed __int16)x_DWORD_DE564)
									LOWORD(v384) = x_DWORD_DE564;
							LABEL_493:
								v387 = v384 & 0xF;
								v388 = (x_BYTE *)(x_DWORD_B8845[v387] + v379);
								v389 = x_DWORD_DE55C;
								switch (v387)
								{
								case 0:
									goto LABEL_494;
								case 1:
									goto LABEL_509;
								case 2:
									goto LABEL_508;
								case 3:
									goto LABEL_507;
								case 4:
									goto LABEL_506;
								case 5:
									goto LABEL_505;
								case 6:
									goto LABEL_504;
								case 7:
									goto LABEL_503;
								case 8:
									goto LABEL_502;
								case 9:
									goto LABEL_501;
								case 10:
									goto LABEL_500;
								case 11:
									goto LABEL_499;
								case 12:
									goto LABEL_498;
								case 13:
									goto LABEL_497;
								case 14:
									goto LABEL_496;
								case 15:
									while (1)
									{
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v383);
										LOWORD(v383) = v1124 + v383;
										LOBYTE(v375) = *(x_BYTE *)(v376 + v389);
										LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
										v180 = __CFADD__(v1167, v383);
										v383 += v1167;
										BYTE1(v376) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1183, v384);
										v384 += v1183;
										v388[1] = x_BYTE_F6EE0_tables[v375];
										BYTE1(v375) += BYTE2(v1146) + v180;
									LABEL_496:
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v383);
										LOWORD(v383) = v1124 + v383;
										LOBYTE(v375) = *(x_BYTE *)(v376 + v389);
										LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
										v180 = __CFADD__(v1167, v383);
										v383 += v1167;
										BYTE1(v376) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1183, v384);
										v384 += v1183;
										v388[2] = x_BYTE_F6EE0_tables[v375];
										BYTE1(v375) += BYTE2(v1146) + v180;
									LABEL_497:
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v383);
										LOWORD(v383) = v1124 + v383;
										LOBYTE(v375) = *(x_BYTE *)(v376 + v389);
										LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
										v180 = __CFADD__(v1167, v383);
										v383 += v1167;
										BYTE1(v376) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1183, v384);
										v384 += v1183;
										v388[3] = x_BYTE_F6EE0_tables[v375];
										BYTE1(v375) += BYTE2(v1146) + v180;
									LABEL_498:
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v383);
										LOWORD(v383) = v1124 + v383;
										LOBYTE(v375) = *(x_BYTE *)(v376 + v389);
										LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
										v180 = __CFADD__(v1167, v383);
										v383 += v1167;
										BYTE1(v376) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1183, v384);
										v384 += v1183;
										v388[4] = x_BYTE_F6EE0_tables[v375];
										BYTE1(v375) += BYTE2(v1146) + v180;
									LABEL_499:
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v383);
										LOWORD(v383) = v1124 + v383;
										LOBYTE(v375) = *(x_BYTE *)(v376 + v389);
										LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
										v180 = __CFADD__(v1167, v383);
										v383 += v1167;
										BYTE1(v376) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1183, v384);
										v384 += v1183;
										v388[5] = x_BYTE_F6EE0_tables[v375];
										BYTE1(v375) += BYTE2(v1146) + v180;
									LABEL_500:
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v383);
										LOWORD(v383) = v1124 + v383;
										LOBYTE(v375) = *(x_BYTE *)(v376 + v389);
										LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
										v180 = __CFADD__(v1167, v383);
										v383 += v1167;
										BYTE1(v376) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1183, v384);
										v384 += v1183;
										v388[6] = x_BYTE_F6EE0_tables[v375];
										BYTE1(v375) += BYTE2(v1146) + v180;
									LABEL_501:
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v383);
										LOWORD(v383) = v1124 + v383;
										LOBYTE(v375) = *(x_BYTE *)(v376 + v389);
										LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
										v180 = __CFADD__(v1167, v383);
										v383 += v1167;
										BYTE1(v376) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1183, v384);
										v384 += v1183;
										v388[7] = x_BYTE_F6EE0_tables[v375];
										BYTE1(v375) += BYTE2(v1146) + v180;
									LABEL_502:
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v383);
										LOWORD(v383) = v1124 + v383;
										LOBYTE(v375) = *(x_BYTE *)(v376 + v389);
										LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
										v180 = __CFADD__(v1167, v383);
										v383 += v1167;
										BYTE1(v376) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1183, v384);
										v384 += v1183;
										v388[8] = x_BYTE_F6EE0_tables[v375];
										BYTE1(v375) += BYTE2(v1146) + v180;
									LABEL_503:
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v383);
										LOWORD(v383) = v1124 + v383;
										LOBYTE(v375) = *(x_BYTE *)(v376 + v389);
										LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
										v180 = __CFADD__(v1167, v383);
										v383 += v1167;
										BYTE1(v376) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1183, v384);
										v384 += v1183;
										v388[9] = x_BYTE_F6EE0_tables[v375];
										BYTE1(v375) += BYTE2(v1146) + v180;
									LABEL_504:
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v383);
										LOWORD(v383) = v1124 + v383;
										LOBYTE(v375) = *(x_BYTE *)(v376 + v389);
										LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
										v180 = __CFADD__(v1167, v383);
										v383 += v1167;
										BYTE1(v376) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1183, v384);
										v384 += v1183;
										v388[10] = x_BYTE_F6EE0_tables[v375];
										BYTE1(v375) += BYTE2(v1146) + v180;
									LABEL_505:
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v383);
										LOWORD(v383) = v1124 + v383;
										LOBYTE(v375) = *(x_BYTE *)(v376 + v389);
										LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
										v180 = __CFADD__(v1167, v383);
										v383 += v1167;
										BYTE1(v376) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1183, v384);
										v384 += v1183;
										v388[11] = x_BYTE_F6EE0_tables[v375];
										BYTE1(v375) += BYTE2(v1146) + v180;
									LABEL_506:
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v383);
										LOWORD(v383) = v1124 + v383;
										LOBYTE(v375) = *(x_BYTE *)(v376 + v389);
										LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
										v180 = __CFADD__(v1167, v383);
										v383 += v1167;
										BYTE1(v376) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1183, v384);
										v384 += v1183;
										v388[12] = x_BYTE_F6EE0_tables[v375];
										BYTE1(v375) += BYTE2(v1146) + v180;
									LABEL_507:
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v383);
										LOWORD(v383) = v1124 + v383;
										LOBYTE(v375) = *(x_BYTE *)(v376 + v389);
										LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
										v180 = __CFADD__(v1167, v383);
										v383 += v1167;
										BYTE1(v376) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1183, v384);
										v384 += v1183;
										v388[13] = x_BYTE_F6EE0_tables[v375];
										BYTE1(v375) += BYTE2(v1146) + v180;
									LABEL_508:
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v383);
										LOWORD(v383) = v1124 + v383;
										LOBYTE(v375) = *(x_BYTE *)(v376 + v389);
										LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
										v180 = __CFADD__(v1167, v383);
										v383 += v1167;
										BYTE1(v376) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1183, v384);
										v384 += v1183;
										v388[14] = x_BYTE_F6EE0_tables[v375];
										BYTE1(v375) += BYTE2(v1146) + v180;
									LABEL_509:
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v383);
										LOWORD(v383) = v1124 + v383;
										LOBYTE(v375) = *(x_BYTE *)(v376 + v389);
										LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
										v180 = __CFADD__(v1167, v383);
										v383 += v1167;
										BYTE1(v376) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1183, v384);
										v384 += v1183;
										v388[15] = x_BYTE_F6EE0_tables[v375];
										BYTE1(v375) += BYTE2(v1146) + v180;
										v388 += 16;
										v18 = __OFSUB__((x_WORD)v384, 16);
										LOWORD(v384) = v384 - 16;
										if ((unsigned __int8)(((v384 & 0x8000u) != 0) ^ v18) | ((x_WORD)v384 == 0))
											break;
									LABEL_494:
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v383);
										LOWORD(v383) = v1124 + v383;
										LOBYTE(v375) = *(x_BYTE *)(v376 + v389);
										LOBYTE(v376) = BYTE2(v1124) + v180 + v376;
										v180 = __CFADD__(v1167, v383);
										v383 += v1167;
										BYTE1(v376) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1183, v384);
										v384 += v1183;
										*v388 = x_BYTE_F6EE0_tables[v375];
										BYTE1(v375) += BYTE2(v1146) + v180;
									}
									break;
								}
							}
						LABEL_510:
							if (!--v1123)
								return;
						}
						if (v378 > x_DWORD_DE564)
							LOWORD(v378) = x_DWORD_DE564;
						v18 = __OFSUB__((x_WORD)v378, (x_WORD)v375);
						v385 = v378 - v375;
						if ((unsigned __int8)((v385 < 0) ^ v18) | (v385 == 0))
							goto LABEL_510;
						v379 += v375;
						LOBYTE(v376) = v377[10];
						v383 = __ROL4__(*((x_DWORD *)v377 + 3), 16);
						v386 = v385;
						BYTE1(v376) = v383;
						LOWORD(v383) = *((x_WORD *)v377 + 4);
						v384 = __ROL4__(*((x_DWORD *)v377 + 4), 16);
						BYTE1(v375) = v384;
						LOWORD(v384) = v386;
						goto LABEL_493;
					case 6:
						v1277 = (char *)&unk_DE56C;
						v1168 = v1135 << 16;
						v1184 = v1146 << 16;
						HIWORD(v390) = 0;
						HIWORD(v391) = 0;
						while (1)
						{
							v392 = v1277;
							v1277 += 20;
							LOWORD(v390) = *((x_WORD *)v392 + 1);
							v393 = *((unsigned __int16 *)v392 + 3);
							v394 = x_DWORD_DE560 + v1102;
							v1102 += x_DWORD_DE560;
							if ((v390 & 0x8000u) == 0)
								break;
							if ((signed __int16)v393 > 0)
							{
								v395 = (unsigned __int16)-(signed __int16)v390;
								v396 = v395;
								v398 = __ROL4__(*((x_DWORD *)v392 + 3) + v1135 * v395, 16);
								BYTE1(v391) = v398;
								v397 = *((x_DWORD *)v392 + 2) + v1124 * v395;
								LOWORD(v398) = v397;
								v390 = v397 >> 8;
								LOBYTE(v391) = BYTE1(v390);
								v399 = __ROL4__(*((x_DWORD *)v392 + 4) + v1146 * v396, 16);
								BYTE1(v390) = v399;
								LOWORD(v399) = *((x_WORD *)v392 + 3);
								v390 = (unsigned __int16)v390;
								if ((signed __int16)v399 > (signed __int16)x_DWORD_DE564)
									LOWORD(v399) = x_DWORD_DE564;
							LABEL_522:
								v402 = v399 & 0xF;
								v403 = (x_BYTE *)(x_DWORD_B8845[v402] + v394);
								v404 = x_DWORD_DE55C;
								switch (v402)
								{
								case 0:
									goto LABEL_523;
								case 1:
									goto LABEL_568;
								case 2:
									goto LABEL_565;
								case 3:
									goto LABEL_562;
								case 4:
									goto LABEL_559;
								case 5:
									goto LABEL_556;
								case 6:
									goto LABEL_553;
								case 7:
									goto LABEL_550;
								case 8:
									goto LABEL_547;
								case 9:
									goto LABEL_544;
								case 10:
									goto LABEL_541;
								case 11:
									goto LABEL_538;
								case 12:
									goto LABEL_535;
								case 13:
									goto LABEL_532;
								case 14:
									goto LABEL_529;
								case 15:
									while (1)
									{
										LOBYTE(v390) = *(x_BYTE *)(v391 + v404);
										if ((x_BYTE)v390)
											v403[1] = x_BYTE_F6EE0_tables[v390];
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v398);
										LOWORD(v398) = v1124 + v398;
										LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
										v180 = __CFADD__(v1168, v398);
										v398 += v1168;
										BYTE1(v391) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1184, v399);
										v399 += v1184;
										BYTE1(v390) += BYTE2(v1146) + v180;
									LABEL_529:
										LOBYTE(v390) = *(x_BYTE *)(v391 + v404);
										if ((x_BYTE)v390)
											v403[2] = x_BYTE_F6EE0_tables[v390];
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v398);
										LOWORD(v398) = v1124 + v398;
										LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
										v180 = __CFADD__(v1168, v398);
										v398 += v1168;
										BYTE1(v391) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1184, v399);
										v399 += v1184;
										BYTE1(v390) += BYTE2(v1146) + v180;
									LABEL_532:
										LOBYTE(v390) = *(x_BYTE *)(v391 + v404);
										if ((x_BYTE)v390)
											v403[3] = x_BYTE_F6EE0_tables[v390];
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v398);
										LOWORD(v398) = v1124 + v398;
										LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
										v180 = __CFADD__(v1168, v398);
										v398 += v1168;
										BYTE1(v391) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1184, v399);
										v399 += v1184;
										BYTE1(v390) += BYTE2(v1146) + v180;
									LABEL_535:
										LOBYTE(v390) = *(x_BYTE *)(v391 + v404);
										if ((x_BYTE)v390)
											v403[4] = x_BYTE_F6EE0_tables[v390];
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v398);
										LOWORD(v398) = v1124 + v398;
										LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
										v180 = __CFADD__(v1168, v398);
										v398 += v1168;
										BYTE1(v391) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1184, v399);
										v399 += v1184;
										BYTE1(v390) += BYTE2(v1146) + v180;
									LABEL_538:
										LOBYTE(v390) = *(x_BYTE *)(v391 + v404);
										if ((x_BYTE)v390)
											v403[5] = x_BYTE_F6EE0_tables[v390];
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v398);
										LOWORD(v398) = v1124 + v398;
										LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
										v180 = __CFADD__(v1168, v398);
										v398 += v1168;
										BYTE1(v391) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1184, v399);
										v399 += v1184;
										BYTE1(v390) += BYTE2(v1146) + v180;
									LABEL_541:
										LOBYTE(v390) = *(x_BYTE *)(v391 + v404);
										if ((x_BYTE)v390)
											v403[6] = x_BYTE_F6EE0_tables[v390];
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v398);
										LOWORD(v398) = v1124 + v398;
										LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
										v180 = __CFADD__(v1168, v398);
										v398 += v1168;
										BYTE1(v391) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1184, v399);
										v399 += v1184;
										BYTE1(v390) += BYTE2(v1146) + v180;
									LABEL_544:
										LOBYTE(v390) = *(x_BYTE *)(v391 + v404);
										if ((x_BYTE)v390)
											v403[7] = x_BYTE_F6EE0_tables[v390];
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v398);
										LOWORD(v398) = v1124 + v398;
										LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
										v180 = __CFADD__(v1168, v398);
										v398 += v1168;
										BYTE1(v391) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1184, v399);
										v399 += v1184;
										BYTE1(v390) += BYTE2(v1146) + v180;
									LABEL_547:
										LOBYTE(v390) = *(x_BYTE *)(v391 + v404);
										if ((x_BYTE)v390)
											v403[8] = x_BYTE_F6EE0_tables[v390];
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v398);
										LOWORD(v398) = v1124 + v398;
										LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
										v180 = __CFADD__(v1168, v398);
										v398 += v1168;
										BYTE1(v391) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1184, v399);
										v399 += v1184;
										BYTE1(v390) += BYTE2(v1146) + v180;
									LABEL_550:
										LOBYTE(v390) = *(x_BYTE *)(v391 + v404);
										if ((x_BYTE)v390)
											v403[9] = x_BYTE_F6EE0_tables[v390];
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v398);
										LOWORD(v398) = v1124 + v398;
										LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
										v180 = __CFADD__(v1168, v398);
										v398 += v1168;
										BYTE1(v391) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1184, v399);
										v399 += v1184;
										BYTE1(v390) += BYTE2(v1146) + v180;
									LABEL_553:
										LOBYTE(v390) = *(x_BYTE *)(v391 + v404);
										if ((x_BYTE)v390)
											v403[10] = x_BYTE_F6EE0_tables[v390];
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v398);
										LOWORD(v398) = v1124 + v398;
										LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
										v180 = __CFADD__(v1168, v398);
										v398 += v1168;
										BYTE1(v391) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1184, v399);
										v399 += v1184;
										BYTE1(v390) += BYTE2(v1146) + v180;
									LABEL_556:
										LOBYTE(v390) = *(x_BYTE *)(v391 + v404);
										if ((x_BYTE)v390)
											v403[11] = x_BYTE_F6EE0_tables[v390];
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v398);
										LOWORD(v398) = v1124 + v398;
										LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
										v180 = __CFADD__(v1168, v398);
										v398 += v1168;
										BYTE1(v391) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1184, v399);
										v399 += v1184;
										BYTE1(v390) += BYTE2(v1146) + v180;
									LABEL_559:
										LOBYTE(v390) = *(x_BYTE *)(v391 + v404);
										if ((x_BYTE)v390)
											v403[12] = x_BYTE_F6EE0_tables[v390];
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v398);
										LOWORD(v398) = v1124 + v398;
										LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
										v180 = __CFADD__(v1168, v398);
										v398 += v1168;
										BYTE1(v391) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1184, v399);
										v399 += v1184;
										BYTE1(v390) += BYTE2(v1146) + v180;
									LABEL_562:
										LOBYTE(v390) = *(x_BYTE *)(v391 + v404);
										if ((x_BYTE)v390)
											v403[13] = x_BYTE_F6EE0_tables[v390];
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v398);
										LOWORD(v398) = v1124 + v398;
										LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
										v180 = __CFADD__(v1168, v398);
										v398 += v1168;
										BYTE1(v391) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1184, v399);
										v399 += v1184;
										BYTE1(v390) += BYTE2(v1146) + v180;
									LABEL_565:
										LOBYTE(v390) = *(x_BYTE *)(v391 + v404);
										if ((x_BYTE)v390)
											v403[14] = x_BYTE_F6EE0_tables[v390];
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v398);
										LOWORD(v398) = v1124 + v398;
										LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
										v180 = __CFADD__(v1168, v398);
										v398 += v1168;
										BYTE1(v391) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1184, v399);
										v399 += v1184;
										BYTE1(v390) += BYTE2(v1146) + v180;
									LABEL_568:
										LOBYTE(v390) = *(x_BYTE *)(v391 + v404);
										if ((x_BYTE)v390)
											v403[15] = x_BYTE_F6EE0_tables[v390];
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v398);
										LOWORD(v398) = v1124 + v398;
										LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
										v180 = __CFADD__(v1168, v398);
										v398 += v1168;
										BYTE1(v391) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1184, v399);
										v399 += v1184;
										BYTE1(v390) += BYTE2(v1146) + v180;
										v403 += 16;
										v18 = __OFSUB__((x_WORD)v399, 16);
										LOWORD(v399) = v399 - 16;
										if ((unsigned __int8)(((v399 & 0x8000u) != 0) ^ v18) | ((x_WORD)v399 == 0))
											break;
									LABEL_523:
										LOBYTE(v390) = *(x_BYTE *)(v391 + v404);
										if ((x_BYTE)v390)
											*v403 = x_BYTE_F6EE0_tables[v390];
										v180 = __CFADD__((x_WORD)v1124, (x_WORD)v398);
										LOWORD(v398) = v1124 + v398;
										LOBYTE(v391) = BYTE2(v1124) + v180 + v391;
										v180 = __CFADD__(v1168, v398);
										v398 += v1168;
										BYTE1(v391) += BYTE2(v1135) + v180;
										v180 = __CFADD__(v1184, v399);
										v399 += v1184;
										BYTE1(v390) += BYTE2(v1146) + v180;
									}
									break;
								}
							}
						LABEL_571:
							if (!--v1123)
								return;
						}
						if (v393 > x_DWORD_DE564)
							LOWORD(v393) = x_DWORD_DE564;
						v18 = __OFSUB__((x_WORD)v393, (x_WORD)v390);
						v400 = v393 - v390;
						if ((unsigned __int8)((v400 < 0) ^ v18) | (v400 == 0))
							goto LABEL_571;
						v394 += v390;
						LOBYTE(v391) = v392[10];
						v398 = __ROL4__(*((x_DWORD *)v392 + 3), 16);
						v401 = v400;
						BYTE1(v391) = v398;
						LOWORD(v398) = *((x_WORD *)v392 + 4);
						v399 = __ROL4__(*((x_DWORD *)v392 + 4), 16);
						BYTE1(v390) = v399;
						LOWORD(v399) = v401;
						goto LABEL_522;
					case 7:
					case 0xB:
						v405 = (unsigned __int16 *)&unk_DE56C;
						v1169 = v1135 << 16;
						HIWORD(v406) = 0;
						HIWORD(v407) = 0;
						while (1)
						{
							LOWORD(v406) = v405[1];
							v408 = v405[3];
							v409 = (x_BYTE *)(x_DWORD_DE560 + v1102);
							v1102 += x_DWORD_DE560;
							if ((v406 & 0x8000u) == 0)
								break;
							if ((signed __int16)v408 > 0)
							{
								v410 = (unsigned __int16)-(signed __int16)v406;
								v412 = __ROL4__(*((x_DWORD *)v405 + 3) + v1135 * v410, 16);
								BYTE1(v407) = v412;
								v411 = *((x_DWORD *)v405 + 2) + v1124 * v410;
								LOWORD(v412) = v411;
								v413 = v411 >> 8;
								LOBYTE(v407) = BYTE1(v413);
								if (v408 > x_DWORD_DE564)
									LOWORD(v408) = x_DWORD_DE564;
								v406 = (unsigned __int16)v413;
							LABEL_583:
								v1278 = v405;
								v414 = x_DWORD_DE55C;
								BYTE1(v406) = x_BYTE_E126C;
								while (1)
								{
									LOBYTE(v406) = *(x_BYTE *)(v407 + v414);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v412);
									LOWORD(v412) = v1124 + v412;
									LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
									v180 = __CFADD__(v1169, v412);
									v415 = v1169 + v412;
									*v409 = x_BYTE_F6EE0_tables[v406];
									BYTE1(v407) += BYTE2(v1135) + v180;
									v416 = v408 - 1;
									if (!v416)
										break;
									LOBYTE(v406) = *(x_BYTE *)(v407 + v414);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v415);
									LOWORD(v415) = v1124 + v415;
									LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
									v180 = __CFADD__(v1169, v415);
									v417 = v1169 + v415;
									v409[1] = x_BYTE_F6EE0_tables[v406];
									BYTE1(v407) += BYTE2(v1135) + v180;
									v418 = v416 - 1;
									if (!v418)
										break;
									LOBYTE(v406) = *(x_BYTE *)(v407 + v414);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v417);
									LOWORD(v417) = v1124 + v417;
									LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
									v180 = __CFADD__(v1169, v417);
									v419 = v1169 + v417;
									v409[2] = x_BYTE_F6EE0_tables[v406];
									BYTE1(v407) += BYTE2(v1135) + v180;
									v420 = v418 - 1;
									if (!v420)
										break;
									LOBYTE(v406) = *(x_BYTE *)(v407 + v414);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v419);
									LOWORD(v419) = v1124 + v419;
									LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
									v180 = __CFADD__(v1169, v419);
									v421 = v1169 + v419;
									v409[3] = x_BYTE_F6EE0_tables[v406];
									BYTE1(v407) += BYTE2(v1135) + v180;
									v422 = v420 - 1;
									if (!v422)
										break;
									LOBYTE(v406) = *(x_BYTE *)(v407 + v414);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v421);
									LOWORD(v421) = v1124 + v421;
									LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
									v180 = __CFADD__(v1169, v421);
									v423 = v1169 + v421;
									v409[4] = x_BYTE_F6EE0_tables[v406];
									BYTE1(v407) += BYTE2(v1135) + v180;
									v424 = v422 - 1;
									if (!v424)
										break;
									LOBYTE(v406) = *(x_BYTE *)(v407 + v414);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v423);
									LOWORD(v423) = v1124 + v423;
									LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
									v180 = __CFADD__(v1169, v423);
									v425 = v1169 + v423;
									v409[5] = x_BYTE_F6EE0_tables[v406];
									BYTE1(v407) += BYTE2(v1135) + v180;
									v426 = v424 - 1;
									if (!v426)
										break;
									LOBYTE(v406) = *(x_BYTE *)(v407 + v414);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v425);
									LOWORD(v425) = v1124 + v425;
									LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
									v180 = __CFADD__(v1169, v425);
									v427 = v1169 + v425;
									v409[6] = x_BYTE_F6EE0_tables[v406];
									BYTE1(v407) += BYTE2(v1135) + v180;
									v428 = v426 - 1;
									if (!v428)
										break;
									LOBYTE(v406) = *(x_BYTE *)(v407 + v414);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v427);
									LOWORD(v427) = v1124 + v427;
									LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
									v180 = __CFADD__(v1169, v427);
									v429 = v1169 + v427;
									v409[7] = x_BYTE_F6EE0_tables[v406];
									BYTE1(v407) += BYTE2(v1135) + v180;
									v430 = v428 - 1;
									if (!v430)
										break;
									LOBYTE(v406) = *(x_BYTE *)(v407 + v414);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v429);
									LOWORD(v429) = v1124 + v429;
									LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
									v180 = __CFADD__(v1169, v429);
									v431 = v1169 + v429;
									v409[8] = x_BYTE_F6EE0_tables[v406];
									BYTE1(v407) += BYTE2(v1135) + v180;
									v432 = v430 - 1;
									if (!v432)
										break;
									LOBYTE(v406) = *(x_BYTE *)(v407 + v414);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v431);
									LOWORD(v431) = v1124 + v431;
									LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
									v180 = __CFADD__(v1169, v431);
									v433 = v1169 + v431;
									v409[9] = x_BYTE_F6EE0_tables[v406];
									BYTE1(v407) += BYTE2(v1135) + v180;
									v434 = v432 - 1;
									if (!v434)
										break;
									LOBYTE(v406) = *(x_BYTE *)(v407 + v414);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v433);
									LOWORD(v433) = v1124 + v433;
									LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
									v180 = __CFADD__(v1169, v433);
									v435 = v1169 + v433;
									v409[10] = x_BYTE_F6EE0_tables[v406];
									BYTE1(v407) += BYTE2(v1135) + v180;
									v436 = v434 - 1;
									if (!v436)
										break;
									LOBYTE(v406) = *(x_BYTE *)(v407 + v414);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v435);
									LOWORD(v435) = v1124 + v435;
									LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
									v180 = __CFADD__(v1169, v435);
									v437 = v1169 + v435;
									v409[11] = x_BYTE_F6EE0_tables[v406];
									BYTE1(v407) += BYTE2(v1135) + v180;
									v438 = v436 - 1;
									if (!v438)
										break;
									LOBYTE(v406) = *(x_BYTE *)(v407 + v414);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v437);
									LOWORD(v437) = v1124 + v437;
									LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
									v180 = __CFADD__(v1169, v437);
									v439 = v1169 + v437;
									v409[12] = x_BYTE_F6EE0_tables[v406];
									BYTE1(v407) += BYTE2(v1135) + v180;
									v440 = v438 - 1;
									if (!v440)
										break;
									LOBYTE(v406) = *(x_BYTE *)(v407 + v414);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v439);
									LOWORD(v439) = v1124 + v439;
									LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
									v180 = __CFADD__(v1169, v439);
									v441 = v1169 + v439;
									v409[13] = x_BYTE_F6EE0_tables[v406];
									BYTE1(v407) += BYTE2(v1135) + v180;
									v442 = v440 - 1;
									if (!v442)
										break;
									LOBYTE(v406) = *(x_BYTE *)(v407 + v414);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v441);
									LOWORD(v441) = v1124 + v441;
									LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
									v180 = __CFADD__(v1169, v441);
									v443 = v1169 + v441;
									v409[14] = x_BYTE_F6EE0_tables[v406];
									BYTE1(v407) += BYTE2(v1135) + v180;
									v444 = v442 - 1;
									if (!v444)
										break;
									LOBYTE(v406) = *(x_BYTE *)(v407 + v414);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v443);
									LOWORD(v443) = v1124 + v443;
									LOBYTE(v407) = BYTE2(v1124) + v180 + v407;
									v180 = __CFADD__(v1169, v443);
									v412 = v1169 + v443;
									v409[15] = x_BYTE_F6EE0_tables[v406];
									BYTE1(v407) += BYTE2(v1135) + v180;
									LOWORD(v408) = v444 - 1;
									if (!(x_WORD)v408)
										break;
									v409 += 16;
								}
								v405 = v1278;
							}
						LABEL_602:
							v405 += 10;
							if (!--v1123)
								return;
						}
						if (v408 > x_DWORD_DE564)
							LOWORD(v408) = x_DWORD_DE564;
						v18 = __OFSUB__((x_WORD)v408, (x_WORD)v406);
						LOWORD(v408) = v408 - v406;
						if ((unsigned __int8)(((v408 & 0x8000u) != 0) ^ v18) | ((x_WORD)v408 == 0))
							goto LABEL_602;
						v409 += v406;
						v412 = __ROL4__(*((x_DWORD *)v405 + 3), 16);
						BYTE1(v407) = v412;
						LOWORD(v412) = v405[4];
						LOBYTE(v407) = *((x_BYTE *)v405 + 10);
						goto LABEL_583;
					case 8:
						v445 = (unsigned __int16 *)&unk_DE56C;
						v1170 = v1135 << 16;
						HIWORD(v446) = 0;
						HIWORD(v447) = 0;
						while (1)
						{
							LOWORD(v446) = v445[1];
							v448 = v445[3];
							v449 = (x_BYTE *)(x_DWORD_DE560 + v1102);
							v1102 += x_DWORD_DE560;
							if ((v446 & 0x8000u) == 0)
								break;
							if ((signed __int16)v448 > 0)
							{
								v450 = (unsigned __int16)-(signed __int16)v446;
								v452 = __ROL4__(*((x_DWORD *)v445 + 3) + v1135 * v450, 16);
								BYTE1(v447) = v452;
								v451 = *((x_DWORD *)v445 + 2) + v1124 * v450;
								LOWORD(v452) = v451;
								v453 = v451 >> 8;
								LOBYTE(v447) = BYTE1(v453);
								if (v448 > x_DWORD_DE564)
									LOWORD(v448) = x_DWORD_DE564;
								v446 = (unsigned __int16)v453;
							LABEL_614:
								v1279 = v445;
								v454 = x_DWORD_DE55C;
								BYTE1(v446) = x_BYTE_E126C;
								while (1)
								{
									LOBYTE(v446) = *(x_BYTE *)(v447 + v454);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v452);
									LOWORD(v452) = v1124 + v452;
									LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
									if ((x_BYTE)v446)
										*v449 = x_BYTE_F6EE0_tables[v446];
									v180 = __CFADD__(v1170, v452);
									v455 = v1170 + v452;
									BYTE1(v447) += BYTE2(v1135) + v180;
									v456 = v448 - 1;
									if (!v456)
										break;
									LOBYTE(v446) = *(x_BYTE *)(v447 + v454);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v455);
									LOWORD(v455) = v1124 + v455;
									LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
									if ((x_BYTE)v446)
										v449[1] = x_BYTE_F6EE0_tables[v446];
									v180 = __CFADD__(v1170, v455);
									v457 = v1170 + v455;
									BYTE1(v447) += BYTE2(v1135) + v180;
									v458 = v456 - 1;
									if (!v458)
										break;
									LOBYTE(v446) = *(x_BYTE *)(v447 + v454);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v457);
									LOWORD(v457) = v1124 + v457;
									LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
									if ((x_BYTE)v446)
										v449[2] = x_BYTE_F6EE0_tables[v446];
									v180 = __CFADD__(v1170, v457);
									v459 = v1170 + v457;
									BYTE1(v447) += BYTE2(v1135) + v180;
									v460 = v458 - 1;
									if (!v460)
										break;
									LOBYTE(v446) = *(x_BYTE *)(v447 + v454);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v459);
									LOWORD(v459) = v1124 + v459;
									LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
									if ((x_BYTE)v446)
										v449[3] = x_BYTE_F6EE0_tables[v446];
									v180 = __CFADD__(v1170, v459);
									v461 = v1170 + v459;
									BYTE1(v447) += BYTE2(v1135) + v180;
									v462 = v460 - 1;
									if (!v462)
										break;
									LOBYTE(v446) = *(x_BYTE *)(v447 + v454);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v461);
									LOWORD(v461) = v1124 + v461;
									LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
									if ((x_BYTE)v446)
										v449[4] = x_BYTE_F6EE0_tables[v446];
									v180 = __CFADD__(v1170, v461);
									v463 = v1170 + v461;
									BYTE1(v447) += BYTE2(v1135) + v180;
									v464 = v462 - 1;
									if (!v464)
										break;
									LOBYTE(v446) = *(x_BYTE *)(v447 + v454);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v463);
									LOWORD(v463) = v1124 + v463;
									LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
									if ((x_BYTE)v446)
										v449[5] = x_BYTE_F6EE0_tables[v446];
									v180 = __CFADD__(v1170, v463);
									v465 = v1170 + v463;
									BYTE1(v447) += BYTE2(v1135) + v180;
									v466 = v464 - 1;
									if (!v466)
										break;
									LOBYTE(v446) = *(x_BYTE *)(v447 + v454);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v465);
									LOWORD(v465) = v1124 + v465;
									LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
									if ((x_BYTE)v446)
										v449[6] = x_BYTE_F6EE0_tables[v446];
									v180 = __CFADD__(v1170, v465);
									v467 = v1170 + v465;
									BYTE1(v447) += BYTE2(v1135) + v180;
									v468 = v466 - 1;
									if (!v468)
										break;
									LOBYTE(v446) = *(x_BYTE *)(v447 + v454);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v467);
									LOWORD(v467) = v1124 + v467;
									LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
									if ((x_BYTE)v446)
										v449[7] = x_BYTE_F6EE0_tables[v446];
									v180 = __CFADD__(v1170, v467);
									v469 = v1170 + v467;
									BYTE1(v447) += BYTE2(v1135) + v180;
									v470 = v468 - 1;
									if (!v470)
										break;
									LOBYTE(v446) = *(x_BYTE *)(v447 + v454);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v469);
									LOWORD(v469) = v1124 + v469;
									LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
									if ((x_BYTE)v446)
										v449[8] = x_BYTE_F6EE0_tables[v446];
									v180 = __CFADD__(v1170, v469);
									v471 = v1170 + v469;
									BYTE1(v447) += BYTE2(v1135) + v180;
									v472 = v470 - 1;
									if (!v472)
										break;
									LOBYTE(v446) = *(x_BYTE *)(v447 + v454);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v471);
									LOWORD(v471) = v1124 + v471;
									LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
									if ((x_BYTE)v446)
										v449[9] = x_BYTE_F6EE0_tables[v446];
									v180 = __CFADD__(v1170, v471);
									v473 = v1170 + v471;
									BYTE1(v447) += BYTE2(v1135) + v180;
									v474 = v472 - 1;
									if (!v474)
										break;
									LOBYTE(v446) = *(x_BYTE *)(v447 + v454);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v473);
									LOWORD(v473) = v1124 + v473;
									LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
									if ((x_BYTE)v446)
										v449[10] = x_BYTE_F6EE0_tables[v446];
									v180 = __CFADD__(v1170, v473);
									v475 = v1170 + v473;
									BYTE1(v447) += BYTE2(v1135) + v180;
									v476 = v474 - 1;
									if (!v476)
										break;
									LOBYTE(v446) = *(x_BYTE *)(v447 + v454);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v475);
									LOWORD(v475) = v1124 + v475;
									LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
									if ((x_BYTE)v446)
										v449[11] = x_BYTE_F6EE0_tables[v446];
									v180 = __CFADD__(v1170, v475);
									v477 = v1170 + v475;
									BYTE1(v447) += BYTE2(v1135) + v180;
									v478 = v476 - 1;
									if (!v478)
										break;
									LOBYTE(v446) = *(x_BYTE *)(v447 + v454);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v477);
									LOWORD(v477) = v1124 + v477;
									LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
									if ((x_BYTE)v446)
										v449[12] = x_BYTE_F6EE0_tables[v446];
									v180 = __CFADD__(v1170, v477);
									v479 = v1170 + v477;
									BYTE1(v447) += BYTE2(v1135) + v180;
									v480 = v478 - 1;
									if (!v480)
										break;
									LOBYTE(v446) = *(x_BYTE *)(v447 + v454);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v479);
									LOWORD(v479) = v1124 + v479;
									LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
									if ((x_BYTE)v446)
										v449[13] = x_BYTE_F6EE0_tables[v446];
									v180 = __CFADD__(v1170, v479);
									v481 = v1170 + v479;
									BYTE1(v447) += BYTE2(v1135) + v180;
									v482 = v480 - 1;
									if (!v482)
										break;
									LOBYTE(v446) = *(x_BYTE *)(v447 + v454);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v481);
									LOWORD(v481) = v1124 + v481;
									LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
									if ((x_BYTE)v446)
										v449[14] = x_BYTE_F6EE0_tables[v446];
									v180 = __CFADD__(v1170, v481);
									v483 = v1170 + v481;
									BYTE1(v447) += BYTE2(v1135) + v180;
									v484 = v482 - 1;
									if (!v484)
										break;
									LOBYTE(v446) = *(x_BYTE *)(v447 + v454);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v483);
									LOWORD(v483) = v1124 + v483;
									LOBYTE(v447) = BYTE2(v1124) + v180 + v447;
									if ((x_BYTE)v446)
										v449[15] = x_BYTE_F6EE0_tables[v446];
									v180 = __CFADD__(v1170, v483);
									v452 = v1170 + v483;
									BYTE1(v447) += BYTE2(v1135) + v180;
									LOWORD(v448) = v484 - 1;
									if (!(x_WORD)v448)
										break;
									v449 += 16;
								}
								v445 = v1279;
							}
						LABEL_665:
							v445 += 10;
							if (!--v1123)
								return;
						}
						if (v448 > x_DWORD_DE564)
							LOWORD(v448) = x_DWORD_DE564;
						v18 = __OFSUB__((x_WORD)v448, (x_WORD)v446);
						LOWORD(v448) = v448 - v446;
						if ((unsigned __int8)(((v448 & 0x8000u) != 0) ^ v18) | ((x_WORD)v448 == 0))
							goto LABEL_665;
						v449 += v446;
						v452 = __ROL4__(*((x_DWORD *)v445 + 3), 16);
						BYTE1(v447) = v452;
						LOWORD(v452) = v445[4];
						LOBYTE(v447) = *((x_BYTE *)v445 + 10);
						goto LABEL_614;
					case 9:
					case 0xA:
						v485 = (unsigned __int16 *)&unk_DE56C;
						v1171 = v1135 << 16;
						HIWORD(v486) = 0;
						HIWORD(v487) = 0;
						while (1)
						{
							LOWORD(v486) = v485[1];
							v488 = v485[3];
							v489 = (x_BYTE *)(x_DWORD_DE560 + v1102);
							v1102 += x_DWORD_DE560;
							if ((v486 & 0x8000u) == 0)
								break;
							if ((signed __int16)v488 > 0)
							{
								v490 = (unsigned __int16)-(signed __int16)v486;
								v492 = __ROL4__(*((x_DWORD *)v485 + 3) + v1135 * v490, 16);
								BYTE1(v487) = v492;
								v491 = *((x_DWORD *)v485 + 2) + v1124 * v490;
								LOWORD(v492) = v491;
								v493 = v491 >> 8;
								LOBYTE(v487) = BYTE1(v493);
								if (v488 > x_DWORD_DE564)
									LOWORD(v488) = x_DWORD_DE564;
								v486 = (unsigned __int16)v493;
							LABEL_677:
								v1280 = v485;
								v494 = x_DWORD_DE55C;
								while (1)
								{
									BYTE1(v486) = *(x_BYTE *)(v487 + v494);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v492);
									LOWORD(v492) = v1124 + v492;
									LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
									if (BYTE1(v486))
									{
										LOBYTE(v486) = *v489;
										*v489 = x_BYTE_F6EE0_tables[v486];
									}
									v180 = __CFADD__(v1171, v492);
									v495 = v1171 + v492;
									BYTE1(v487) += BYTE2(v1135) + v180;
									v496 = v488 - 1;
									if (!v496)
										break;
									BYTE1(v486) = *(x_BYTE *)(v487 + v494);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v495);
									LOWORD(v495) = v1124 + v495;
									LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
									if (BYTE1(v486))
									{
										LOBYTE(v486) = v489[1];
										v489[1] = x_BYTE_F6EE0_tables[v486];
									}
									v180 = __CFADD__(v1171, v495);
									v497 = v1171 + v495;
									BYTE1(v487) += BYTE2(v1135) + v180;
									v498 = v496 - 1;
									if (!v498)
										break;
									BYTE1(v486) = *(x_BYTE *)(v487 + v494);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v497);
									LOWORD(v497) = v1124 + v497;
									LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
									if (BYTE1(v486))
									{
										LOBYTE(v486) = v489[2];
										v489[2] = x_BYTE_F6EE0_tables[v486];
									}
									v180 = __CFADD__(v1171, v497);
									v499 = v1171 + v497;
									BYTE1(v487) += BYTE2(v1135) + v180;
									v500 = v498 - 1;
									if (!v500)
										break;
									BYTE1(v486) = *(x_BYTE *)(v487 + v494);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v499);
									LOWORD(v499) = v1124 + v499;
									LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
									if (BYTE1(v486))
									{
										LOBYTE(v486) = v489[3];
										v489[3] = x_BYTE_F6EE0_tables[v486];
									}
									v180 = __CFADD__(v1171, v499);
									v501 = v1171 + v499;
									BYTE1(v487) += BYTE2(v1135) + v180;
									v502 = v500 - 1;
									if (!v502)
										break;
									BYTE1(v486) = *(x_BYTE *)(v487 + v494);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v501);
									LOWORD(v501) = v1124 + v501;
									LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
									if (BYTE1(v486))
									{
										LOBYTE(v486) = v489[4];
										v489[4] = x_BYTE_F6EE0_tables[v486];
									}
									v180 = __CFADD__(v1171, v501);
									v503 = v1171 + v501;
									BYTE1(v487) += BYTE2(v1135) + v180;
									v504 = v502 - 1;
									if (!v504)
										break;
									BYTE1(v486) = *(x_BYTE *)(v487 + v494);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v503);
									LOWORD(v503) = v1124 + v503;
									LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
									if (BYTE1(v486))
									{
										LOBYTE(v486) = v489[5];
										v489[5] = x_BYTE_F6EE0_tables[v486];
									}
									v180 = __CFADD__(v1171, v503);
									v505 = v1171 + v503;
									BYTE1(v487) += BYTE2(v1135) + v180;
									v506 = v504 - 1;
									if (!v506)
										break;
									BYTE1(v486) = *(x_BYTE *)(v487 + v494);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v505);
									LOWORD(v505) = v1124 + v505;
									LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
									if (BYTE1(v486))
									{
										LOBYTE(v486) = v489[6];
										v489[6] = x_BYTE_F6EE0_tables[v486];
									}
									v180 = __CFADD__(v1171, v505);
									v507 = v1171 + v505;
									BYTE1(v487) += BYTE2(v1135) + v180;
									v508 = v506 - 1;
									if (!v508)
										break;
									BYTE1(v486) = *(x_BYTE *)(v487 + v494);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v507);
									LOWORD(v507) = v1124 + v507;
									LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
									if (BYTE1(v486))
									{
										LOBYTE(v486) = v489[7];
										v489[7] = x_BYTE_F6EE0_tables[v486];
									}
									v180 = __CFADD__(v1171, v507);
									v509 = v1171 + v507;
									BYTE1(v487) += BYTE2(v1135) + v180;
									v510 = v508 - 1;
									if (!v510)
										break;
									BYTE1(v486) = *(x_BYTE *)(v487 + v494);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v509);
									LOWORD(v509) = v1124 + v509;
									LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
									if (BYTE1(v486))
									{
										LOBYTE(v486) = v489[8];
										v489[8] = x_BYTE_F6EE0_tables[v486];
									}
									v180 = __CFADD__(v1171, v509);
									v511 = v1171 + v509;
									BYTE1(v487) += BYTE2(v1135) + v180;
									v512 = v510 - 1;
									if (!v512)
										break;
									BYTE1(v486) = *(x_BYTE *)(v487 + v494);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v511);
									LOWORD(v511) = v1124 + v511;
									LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
									if (BYTE1(v486))
									{
										LOBYTE(v486) = v489[9];
										v489[9] = x_BYTE_F6EE0_tables[v486];
									}
									v180 = __CFADD__(v1171, v511);
									v513 = v1171 + v511;
									BYTE1(v487) += BYTE2(v1135) + v180;
									v514 = v512 - 1;
									if (!v514)
										break;
									BYTE1(v486) = *(x_BYTE *)(v487 + v494);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v513);
									LOWORD(v513) = v1124 + v513;
									LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
									if (BYTE1(v486))
									{
										LOBYTE(v486) = v489[10];
										v489[10] = x_BYTE_F6EE0_tables[v486];
									}
									v180 = __CFADD__(v1171, v513);
									v515 = v1171 + v513;
									BYTE1(v487) += BYTE2(v1135) + v180;
									v516 = v514 - 1;
									if (!v516)
										break;
									BYTE1(v486) = *(x_BYTE *)(v487 + v494);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v515);
									LOWORD(v515) = v1124 + v515;
									LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
									if (BYTE1(v486))
									{
										LOBYTE(v486) = v489[11];
										v489[11] = x_BYTE_F6EE0_tables[v486];
									}
									v180 = __CFADD__(v1171, v515);
									v517 = v1171 + v515;
									BYTE1(v487) += BYTE2(v1135) + v180;
									v518 = v516 - 1;
									if (!v518)
										break;
									BYTE1(v486) = *(x_BYTE *)(v487 + v494);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v517);
									LOWORD(v517) = v1124 + v517;
									LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
									if (BYTE1(v486))
									{
										LOBYTE(v486) = v489[12];
										v489[12] = x_BYTE_F6EE0_tables[v486];
									}
									v180 = __CFADD__(v1171, v517);
									v519 = v1171 + v517;
									BYTE1(v487) += BYTE2(v1135) + v180;
									v520 = v518 - 1;
									if (!v520)
										break;
									BYTE1(v486) = *(x_BYTE *)(v487 + v494);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v519);
									LOWORD(v519) = v1124 + v519;
									LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
									if (BYTE1(v486))
									{
										LOBYTE(v486) = v489[13];
										v489[13] = x_BYTE_F6EE0_tables[v486];
									}
									v180 = __CFADD__(v1171, v519);
									v521 = v1171 + v519;
									BYTE1(v487) += BYTE2(v1135) + v180;
									v522 = v520 - 1;
									if (!v522)
										break;
									BYTE1(v486) = *(x_BYTE *)(v487 + v494);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v521);
									LOWORD(v521) = v1124 + v521;
									LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
									if (BYTE1(v486))
									{
										LOBYTE(v486) = v489[14];
										v489[14] = x_BYTE_F6EE0_tables[v486];
									}
									v180 = __CFADD__(v1171, v521);
									v523 = v1171 + v521;
									BYTE1(v487) += BYTE2(v1135) + v180;
									v524 = v522 - 1;
									if (!v524)
										break;
									BYTE1(v486) = *(x_BYTE *)(v487 + v494);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v523);
									LOWORD(v523) = v1124 + v523;
									LOBYTE(v487) = BYTE2(v1124) + v180 + v487;
									if (BYTE1(v486))
									{
										LOBYTE(v486) = v489[15];
										v489[15] = x_BYTE_F6EE0_tables[v486];
									}
									v180 = __CFADD__(v1171, v523);
									v492 = v1171 + v523;
									BYTE1(v487) += BYTE2(v1135) + v180;
									LOWORD(v488) = v524 - 1;
									if (!(x_WORD)v488)
										break;
									v489 += 16;
								}
								v485 = v1280;
							}
						LABEL_728:
							v485 += 10;
							if (!--v1123)
								return;
						}
						if (v488 > x_DWORD_DE564)
							LOWORD(v488) = x_DWORD_DE564;
						v18 = __OFSUB__((x_WORD)v488, (x_WORD)v486);
						LOWORD(v488) = v488 - v486;
						if ((unsigned __int8)(((v488 & 0x8000u) != 0) ^ v18) | ((x_WORD)v488 == 0))
							goto LABEL_728;
						v489 += v486;
						v492 = __ROL4__(*((x_DWORD *)v485 + 3), 16);
						BYTE1(v487) = v492;
						LOWORD(v492) = v485[4];
						LOBYTE(v487) = *((x_BYTE *)v485 + 10);
						goto LABEL_677;
					case 0xC:
						v525 = (unsigned __int16 *)&unk_DE56C;
						v1172 = v1135 << 16;
						HIWORD(v526) = 0;
						HIWORD(v527) = 0;
						while (1)
						{
							LOWORD(v526) = v525[1];
							v528 = v525[3];
							v529 = (x_BYTE *)(x_DWORD_DE560 + v1102);
							v1102 += x_DWORD_DE560;
							if ((v526 & 0x8000u) == 0)
								break;
							if ((signed __int16)v528 > 0)
							{
								v530 = (unsigned __int16)-(signed __int16)v526;
								v532 = __ROL4__(*((x_DWORD *)v525 + 3) + v1135 * v530, 16);
								BYTE1(v527) = v532;
								v531 = *((x_DWORD *)v525 + 2) + v1124 * v530;
								LOWORD(v532) = v531;
								v533 = v531 >> 8;
								LOBYTE(v527) = BYTE1(v533);
								if (v528 > x_DWORD_DE564)
									LOWORD(v528) = x_DWORD_DE564;
								v526 = (unsigned __int16)v533;
							LABEL_740:
								v1281 = v525;
								v534 = x_DWORD_DE55C;
								LOBYTE(v526) = x_BYTE_E126C;
								while (1)
								{
									BYTE1(v526) = *(x_BYTE *)(v527 + v534);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v532);
									LOWORD(v532) = v1124 + v532;
									LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
									v180 = __CFADD__(v1172, v532);
									v535 = v1172 + v532;
									*v529 = x_BYTE_FAEE0[v526];
									BYTE1(v527) += BYTE2(v1135) + v180;
									v536 = v528 - 1;
									if (!v536)
										break;
									BYTE1(v526) = *(x_BYTE *)(v527 + v534);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v535);
									LOWORD(v535) = v1124 + v535;
									LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
									v180 = __CFADD__(v1172, v535);
									v537 = v1172 + v535;
									v529[1] = x_BYTE_FAEE0[v526];
									BYTE1(v527) += BYTE2(v1135) + v180;
									v538 = v536 - 1;
									if (!v538)
										break;
									BYTE1(v526) = *(x_BYTE *)(v527 + v534);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v537);
									LOWORD(v537) = v1124 + v537;
									LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
									v180 = __CFADD__(v1172, v537);
									v539 = v1172 + v537;
									v529[2] = x_BYTE_FAEE0[v526];
									BYTE1(v527) += BYTE2(v1135) + v180;
									v540 = v538 - 1;
									if (!v540)
										break;
									BYTE1(v526) = *(x_BYTE *)(v527 + v534);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v539);
									LOWORD(v539) = v1124 + v539;
									LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
									v180 = __CFADD__(v1172, v539);
									v541 = v1172 + v539;
									v529[3] = x_BYTE_FAEE0[v526];
									BYTE1(v527) += BYTE2(v1135) + v180;
									v542 = v540 - 1;
									if (!v542)
										break;
									BYTE1(v526) = *(x_BYTE *)(v527 + v534);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v541);
									LOWORD(v541) = v1124 + v541;
									LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
									v180 = __CFADD__(v1172, v541);
									v543 = v1172 + v541;
									v529[4] = x_BYTE_FAEE0[v526];
									BYTE1(v527) += BYTE2(v1135) + v180;
									v544 = v542 - 1;
									if (!v544)
										break;
									BYTE1(v526) = *(x_BYTE *)(v527 + v534);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v543);
									LOWORD(v543) = v1124 + v543;
									LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
									v180 = __CFADD__(v1172, v543);
									v545 = v1172 + v543;
									v529[5] = x_BYTE_FAEE0[v526];
									BYTE1(v527) += BYTE2(v1135) + v180;
									v546 = v544 - 1;
									if (!v546)
										break;
									BYTE1(v526) = *(x_BYTE *)(v527 + v534);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v545);
									LOWORD(v545) = v1124 + v545;
									LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
									v180 = __CFADD__(v1172, v545);
									v547 = v1172 + v545;
									v529[6] = x_BYTE_FAEE0[v526];
									BYTE1(v527) += BYTE2(v1135) + v180;
									v548 = v546 - 1;
									if (!v548)
										break;
									BYTE1(v526) = *(x_BYTE *)(v527 + v534);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v547);
									LOWORD(v547) = v1124 + v547;
									LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
									v180 = __CFADD__(v1172, v547);
									v549 = v1172 + v547;
									v529[7] = x_BYTE_FAEE0[v526];
									BYTE1(v527) += BYTE2(v1135) + v180;
									v550 = v548 - 1;
									if (!v550)
										break;
									BYTE1(v526) = *(x_BYTE *)(v527 + v534);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v549);
									LOWORD(v549) = v1124 + v549;
									LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
									v180 = __CFADD__(v1172, v549);
									v551 = v1172 + v549;
									v529[8] = x_BYTE_FAEE0[v526];
									BYTE1(v527) += BYTE2(v1135) + v180;
									v552 = v550 - 1;
									if (!v552)
										break;
									BYTE1(v526) = *(x_BYTE *)(v527 + v534);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v551);
									LOWORD(v551) = v1124 + v551;
									LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
									v180 = __CFADD__(v1172, v551);
									v553 = v1172 + v551;
									v529[9] = x_BYTE_FAEE0[v526];
									BYTE1(v527) += BYTE2(v1135) + v180;
									v554 = v552 - 1;
									if (!v554)
										break;
									BYTE1(v526) = *(x_BYTE *)(v527 + v534);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v553);
									LOWORD(v553) = v1124 + v553;
									LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
									v180 = __CFADD__(v1172, v553);
									v555 = v1172 + v553;
									v529[10] = x_BYTE_FAEE0[v526];
									BYTE1(v527) += BYTE2(v1135) + v180;
									v556 = v554 - 1;
									if (!v556)
										break;
									BYTE1(v526) = *(x_BYTE *)(v527 + v534);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v555);
									LOWORD(v555) = v1124 + v555;
									LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
									v180 = __CFADD__(v1172, v555);
									v557 = v1172 + v555;
									v529[11] = x_BYTE_FAEE0[v526];
									BYTE1(v527) += BYTE2(v1135) + v180;
									v558 = v556 - 1;
									if (!v558)
										break;
									BYTE1(v526) = *(x_BYTE *)(v527 + v534);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v557);
									LOWORD(v557) = v1124 + v557;
									LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
									v180 = __CFADD__(v1172, v557);
									v559 = v1172 + v557;
									v529[12] = x_BYTE_FAEE0[v526];
									BYTE1(v527) += BYTE2(v1135) + v180;
									v560 = v558 - 1;
									if (!v560)
										break;
									BYTE1(v526) = *(x_BYTE *)(v527 + v534);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v559);
									LOWORD(v559) = v1124 + v559;
									LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
									v180 = __CFADD__(v1172, v559);
									v561 = v1172 + v559;
									v529[13] = x_BYTE_FAEE0[v526];
									BYTE1(v527) += BYTE2(v1135) + v180;
									v562 = v560 - 1;
									if (!v562)
										break;
									BYTE1(v526) = *(x_BYTE *)(v527 + v534);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v561);
									LOWORD(v561) = v1124 + v561;
									LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
									v180 = __CFADD__(v1172, v561);
									v563 = v1172 + v561;
									v529[14] = x_BYTE_FAEE0[v526];
									BYTE1(v527) += BYTE2(v1135) + v180;
									v564 = v562 - 1;
									if (!v564)
										break;
									BYTE1(v526) = *(x_BYTE *)(v527 + v534);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v563);
									LOWORD(v563) = v1124 + v563;
									LOBYTE(v527) = BYTE2(v1124) + v180 + v527;
									v180 = __CFADD__(v1172, v563);
									v532 = v1172 + v563;
									v529[15] = x_BYTE_FAEE0[v526];
									BYTE1(v527) += BYTE2(v1135) + v180;
									LOWORD(v528) = v564 - 1;
									if (!(x_WORD)v528)
										break;
									v529 += 16;
								}
								v525 = v1281;
							}
						LABEL_759:
							v525 += 10;
							if (!--v1123)
								return;
						}
						if (v528 > x_DWORD_DE564)
							LOWORD(v528) = x_DWORD_DE564;
						v18 = __OFSUB__((x_WORD)v528, (x_WORD)v526);
						LOWORD(v528) = v528 - v526;
						if ((unsigned __int8)(((v528 & 0x8000u) != 0) ^ v18) | ((x_WORD)v528 == 0))
							goto LABEL_759;
						v529 += v526;
						v532 = __ROL4__(*((x_DWORD *)v525 + 3), 16);
						BYTE1(v527) = v532;
						LOWORD(v532) = v525[4];
						LOBYTE(v527) = *((x_BYTE *)v525 + 10);
						goto LABEL_740;
					case 0xD:
						v565 = (unsigned __int16 *)&unk_DE56C;
						v1173 = v1135 << 16;
						HIWORD(v566) = 0;
						HIWORD(v567) = 0;
						while (1)
						{
							LOWORD(v566) = v565[1];
							v568 = v565[3];
							v569 = (x_BYTE *)(x_DWORD_DE560 + v1102);
							v1102 += x_DWORD_DE560;
							if ((v566 & 0x8000u) == 0)
								break;
							if ((signed __int16)v568 > 0)
							{
								v570 = (unsigned __int16)-(signed __int16)v566;
								v572 = __ROL4__(*((x_DWORD *)v565 + 3) + v1135 * v570, 16);
								BYTE1(v567) = v572;
								v571 = *((x_DWORD *)v565 + 2) + v1124 * v570;
								LOWORD(v572) = v571;
								v573 = v571 >> 8;
								LOBYTE(v567) = BYTE1(v573);
								if (v568 > x_DWORD_DE564)
									LOWORD(v568) = x_DWORD_DE564;
								v566 = (unsigned __int16)v573;
							LABEL_771:
								v1282 = v565;
								v574 = x_DWORD_DE55C;
								BYTE1(v566) = x_BYTE_E126C;
								while (1)
								{
									LOBYTE(v566) = *(x_BYTE *)(v567 + v574);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v572);
									LOWORD(v572) = v1124 + v572;
									LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
									v180 = __CFADD__(v1173, v572);
									v575 = v1173 + v572;
									*v569 = x_BYTE_FAEE0[v566];
									BYTE1(v567) += BYTE2(v1135) + v180;
									v576 = v568 - 1;
									if (!v576)
										break;
									LOBYTE(v566) = *(x_BYTE *)(v567 + v574);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v575);
									LOWORD(v575) = v1124 + v575;
									LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
									v180 = __CFADD__(v1173, v575);
									v577 = v1173 + v575;
									v569[1] = x_BYTE_FAEE0[v566];
									BYTE1(v567) += BYTE2(v1135) + v180;
									v578 = v576 - 1;
									if (!v578)
										break;
									LOBYTE(v566) = *(x_BYTE *)(v567 + v574);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v577);
									LOWORD(v577) = v1124 + v577;
									LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
									v180 = __CFADD__(v1173, v577);
									v579 = v1173 + v577;
									v569[2] = x_BYTE_FAEE0[v566];
									BYTE1(v567) += BYTE2(v1135) + v180;
									v580 = v578 - 1;
									if (!v580)
										break;
									LOBYTE(v566) = *(x_BYTE *)(v567 + v574);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v579);
									LOWORD(v579) = v1124 + v579;
									LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
									v180 = __CFADD__(v1173, v579);
									v581 = v1173 + v579;
									v569[3] = x_BYTE_FAEE0[v566];
									BYTE1(v567) += BYTE2(v1135) + v180;
									v582 = v580 - 1;
									if (!v582)
										break;
									LOBYTE(v566) = *(x_BYTE *)(v567 + v574);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v581);
									LOWORD(v581) = v1124 + v581;
									LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
									v180 = __CFADD__(v1173, v581);
									v583 = v1173 + v581;
									v569[4] = x_BYTE_FAEE0[v566];
									BYTE1(v567) += BYTE2(v1135) + v180;
									v584 = v582 - 1;
									if (!v584)
										break;
									LOBYTE(v566) = *(x_BYTE *)(v567 + v574);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v583);
									LOWORD(v583) = v1124 + v583;
									LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
									v180 = __CFADD__(v1173, v583);
									v585 = v1173 + v583;
									v569[5] = x_BYTE_FAEE0[v566];
									BYTE1(v567) += BYTE2(v1135) + v180;
									v586 = v584 - 1;
									if (!v586)
										break;
									LOBYTE(v566) = *(x_BYTE *)(v567 + v574);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v585);
									LOWORD(v585) = v1124 + v585;
									LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
									v180 = __CFADD__(v1173, v585);
									v587 = v1173 + v585;
									v569[6] = x_BYTE_FAEE0[v566];
									BYTE1(v567) += BYTE2(v1135) + v180;
									v588 = v586 - 1;
									if (!v588)
										break;
									LOBYTE(v566) = *(x_BYTE *)(v567 + v574);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v587);
									LOWORD(v587) = v1124 + v587;
									LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
									v180 = __CFADD__(v1173, v587);
									v589 = v1173 + v587;
									v569[7] = x_BYTE_FAEE0[v566];
									BYTE1(v567) += BYTE2(v1135) + v180;
									v590 = v588 - 1;
									if (!v590)
										break;
									LOBYTE(v566) = *(x_BYTE *)(v567 + v574);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v589);
									LOWORD(v589) = v1124 + v589;
									LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
									v180 = __CFADD__(v1173, v589);
									v591 = v1173 + v589;
									v569[8] = x_BYTE_FAEE0[v566];
									BYTE1(v567) += BYTE2(v1135) + v180;
									v592 = v590 - 1;
									if (!v592)
										break;
									LOBYTE(v566) = *(x_BYTE *)(v567 + v574);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v591);
									LOWORD(v591) = v1124 + v591;
									LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
									v180 = __CFADD__(v1173, v591);
									v593 = v1173 + v591;
									v569[9] = x_BYTE_FAEE0[v566];
									BYTE1(v567) += BYTE2(v1135) + v180;
									v594 = v592 - 1;
									if (!v594)
										break;
									LOBYTE(v566) = *(x_BYTE *)(v567 + v574);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v593);
									LOWORD(v593) = v1124 + v593;
									LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
									v180 = __CFADD__(v1173, v593);
									v595 = v1173 + v593;
									v569[10] = x_BYTE_FAEE0[v566];
									BYTE1(v567) += BYTE2(v1135) + v180;
									v596 = v594 - 1;
									if (!v596)
										break;
									LOBYTE(v566) = *(x_BYTE *)(v567 + v574);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v595);
									LOWORD(v595) = v1124 + v595;
									LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
									v180 = __CFADD__(v1173, v595);
									v597 = v1173 + v595;
									v569[11] = x_BYTE_FAEE0[v566];
									BYTE1(v567) += BYTE2(v1135) + v180;
									v598 = v596 - 1;
									if (!v598)
										break;
									LOBYTE(v566) = *(x_BYTE *)(v567 + v574);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v597);
									LOWORD(v597) = v1124 + v597;
									LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
									v180 = __CFADD__(v1173, v597);
									v599 = v1173 + v597;
									v569[12] = x_BYTE_FAEE0[v566];
									BYTE1(v567) += BYTE2(v1135) + v180;
									v600 = v598 - 1;
									if (!v600)
										break;
									LOBYTE(v566) = *(x_BYTE *)(v567 + v574);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v599);
									LOWORD(v599) = v1124 + v599;
									LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
									v180 = __CFADD__(v1173, v599);
									v601 = v1173 + v599;
									v569[13] = x_BYTE_FAEE0[v566];
									BYTE1(v567) += BYTE2(v1135) + v180;
									v602 = v600 - 1;
									if (!v602)
										break;
									LOBYTE(v566) = *(x_BYTE *)(v567 + v574);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v601);
									LOWORD(v601) = v1124 + v601;
									LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
									v180 = __CFADD__(v1173, v601);
									v603 = v1173 + v601;
									v569[14] = x_BYTE_FAEE0[v566];
									BYTE1(v567) += BYTE2(v1135) + v180;
									v604 = v602 - 1;
									if (!v604)
										break;
									LOBYTE(v566) = *(x_BYTE *)(v567 + v574);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v603);
									LOWORD(v603) = v1124 + v603;
									LOBYTE(v567) = BYTE2(v1124) + v180 + v567;
									v180 = __CFADD__(v1173, v603);
									v572 = v1173 + v603;
									v569[15] = x_BYTE_FAEE0[v566];
									BYTE1(v567) += BYTE2(v1135) + v180;
									LOWORD(v568) = v604 - 1;
									if (!(x_WORD)v568)
										break;
									v569 += 16;
								}
								v565 = v1282;
							}
						LABEL_790:
							v565 += 10;
							if (!--v1123)
								return;
						}
						if (v568 > x_DWORD_DE564)
							LOWORD(v568) = x_DWORD_DE564;
						v18 = __OFSUB__((x_WORD)v568, (x_WORD)v566);
						LOWORD(v568) = v568 - v566;
						if ((unsigned __int8)(((v568 & 0x8000u) != 0) ^ v18) | ((x_WORD)v568 == 0))
							goto LABEL_790;
						v569 += v566;
						v572 = __ROL4__(*((x_DWORD *)v565 + 3), 16);
						BYTE1(v567) = v572;
						LOWORD(v572) = v565[4];
						LOBYTE(v567) = *((x_BYTE *)v565 + 10);
						goto LABEL_771;
					case 0xE:
						v605 = (unsigned __int16 *)&unk_DE56C;
						v606 = (x_BYTE *)v1102;
						HIWORD(v607) = 0;
						BYTE1(v607) = x_BYTE_E126C;
						HIWORD(v608) = 0;
						while (1)
						{
							LOWORD(v608) = v605[1];
							v609 = v605[3];
							v606 += x_DWORD_DE560;
							if ((v608 & 0x8000u) == 0)
								break;
							if ((signed __int16)v609 > 0)
							{
								if (v609 > x_DWORD_DE564)
									LOWORD(v609) = x_DWORD_DE564;
							LABEL_802:
								for (i = v606; ; i += 16)
								{
									LOBYTE(v607) = *i;
									*i = x_BYTE_FAEE0[v607];
									v611 = v609 - 1;
									if (!v611)
										break;
									LOBYTE(v607) = i[1];
									i[1] = x_BYTE_FAEE0[v607];
									v612 = v611 - 1;
									if (!v612)
										break;
									LOBYTE(v607) = i[2];
									i[2] = x_BYTE_FAEE0[v607];
									v613 = v612 - 1;
									if (!v613)
										break;
									LOBYTE(v607) = i[3];
									i[3] = x_BYTE_FAEE0[v607];
									v614 = v613 - 1;
									if (!v614)
										break;
									LOBYTE(v607) = i[4];
									i[4] = x_BYTE_FAEE0[v607];
									v615 = v614 - 1;
									if (!v615)
										break;
									LOBYTE(v607) = i[5];
									i[5] = x_BYTE_FAEE0[v607];
									v616 = v615 - 1;
									if (!v616)
										break;
									LOBYTE(v607) = i[6];
									i[6] = x_BYTE_FAEE0[v607];
									v617 = v616 - 1;
									if (!v617)
										break;
									LOBYTE(v607) = i[7];
									i[7] = x_BYTE_FAEE0[v607];
									v618 = v617 - 1;
									if (!v618)
										break;
									LOBYTE(v607) = i[8];
									i[8] = x_BYTE_FAEE0[v607];
									v619 = v618 - 1;
									if (!v619)
										break;
									LOBYTE(v607) = i[9];
									i[9] = x_BYTE_FAEE0[v607];
									v620 = v619 - 1;
									if (!v620)
										break;
									LOBYTE(v607) = i[10];
									i[10] = x_BYTE_FAEE0[v607];
									v621 = v620 - 1;
									if (!v621)
										break;
									LOBYTE(v607) = i[11];
									i[11] = x_BYTE_FAEE0[v607];
									v622 = v621 - 1;
									if (!v622)
										break;
									LOBYTE(v607) = i[12];
									i[12] = x_BYTE_FAEE0[v607];
									v623 = v622 - 1;
									if (!v623)
										break;
									LOBYTE(v607) = i[13];
									i[13] = x_BYTE_FAEE0[v607];
									v624 = v623 - 1;
									if (!v624)
										break;
									LOBYTE(v607) = i[14];
									i[14] = x_BYTE_FAEE0[v607];
									v625 = v624 - 1;
									if (!v625)
										break;
									LOBYTE(v607) = i[15];
									i[15] = x_BYTE_FAEE0[v607];
									LOWORD(v609) = v625 - 1;
									if (!(x_WORD)v609)
										break;
								}
							}
						LABEL_819:
							v605 += 10;
							if (!--v1123)
								return;
						}
						if (v609 > x_DWORD_DE564)
							LOWORD(v609) = x_DWORD_DE564;
						v18 = __OFSUB__((x_WORD)v609, (x_WORD)v608);
						LOWORD(v609) = v609 - v608;
						if ((unsigned __int8)(((v609 & 0x8000u) != 0) ^ v18) | ((x_WORD)v609 == 0))
							goto LABEL_819;
						i = &v606[v608];
						goto LABEL_802;
					case 0xF:
						v626 = (unsigned __int16 *)&unk_DE56C;
						v627 = (x_BYTE *)v1102;
						v628 = (unsigned __int8)x_BYTE_E126C;
						HIWORD(v629) = 0;
						while (1)
						{
							LOWORD(v629) = v626[1];
							v630 = v626[3];
							v627 += x_DWORD_DE560;
							if ((v629 & 0x8000u) == 0)
								break;
							if ((signed __int16)v630 > 0)
							{
								if (v630 > x_DWORD_DE564)
									LOWORD(v630) = x_DWORD_DE564;
							LABEL_831:
								for (j = v627; ; j += 16)
								{
									BYTE1(v628) = *j;
									*j = x_BYTE_FAEE0[v628];
									v632 = v630 - 1;
									if (!v632)
										break;
									BYTE1(v628) = j[1];
									j[1] = x_BYTE_FAEE0[v628];
									v633 = v632 - 1;
									if (!v633)
										break;
									BYTE1(v628) = j[2];
									j[2] = x_BYTE_FAEE0[v628];
									v634 = v633 - 1;
									if (!v634)
										break;
									BYTE1(v628) = j[3];
									j[3] = x_BYTE_FAEE0[v628];
									v635 = v634 - 1;
									if (!v635)
										break;
									BYTE1(v628) = j[4];
									j[4] = x_BYTE_FAEE0[v628];
									v636 = v635 - 1;
									if (!v636)
										break;
									BYTE1(v628) = j[5];
									j[5] = x_BYTE_FAEE0[v628];
									v637 = v636 - 1;
									if (!v637)
										break;
									BYTE1(v628) = j[6];
									j[6] = x_BYTE_FAEE0[v628];
									v638 = v637 - 1;
									if (!v638)
										break;
									BYTE1(v628) = j[7];
									j[7] = x_BYTE_FAEE0[v628];
									v639 = v638 - 1;
									if (!v639)
										break;
									BYTE1(v628) = j[8];
									j[8] = x_BYTE_FAEE0[v628];
									v640 = v639 - 1;
									if (!v640)
										break;
									BYTE1(v628) = j[9];
									j[9] = x_BYTE_FAEE0[v628];
									v641 = v640 - 1;
									if (!v641)
										break;
									BYTE1(v628) = j[10];
									j[10] = x_BYTE_FAEE0[v628];
									v642 = v641 - 1;
									if (!v642)
										break;
									BYTE1(v628) = j[11];
									j[11] = x_BYTE_FAEE0[v628];
									v643 = v642 - 1;
									if (!v643)
										break;
									BYTE1(v628) = j[12];
									j[12] = x_BYTE_FAEE0[v628];
									v644 = v643 - 1;
									if (!v644)
										break;
									BYTE1(v628) = j[13];
									j[13] = x_BYTE_FAEE0[v628];
									v645 = v644 - 1;
									if (!v645)
										break;
									BYTE1(v628) = j[14];
									j[14] = x_BYTE_FAEE0[v628];
									v646 = v645 - 1;
									if (!v646)
										break;
									BYTE1(v628) = j[15];
									j[15] = x_BYTE_FAEE0[v628];
									LOWORD(v630) = v646 - 1;
									if (!(x_WORD)v630)
										break;
								}
							}
						LABEL_848:
							v626 += 10;
							if (!--v1123)
								return;
						}
						if (v630 > x_DWORD_DE564)
							LOWORD(v630) = x_DWORD_DE564;
						v18 = __OFSUB__((x_WORD)v630, (x_WORD)v629);
						LOWORD(v630) = v630 - v629;
						if ((unsigned __int8)(((v630 & 0x8000u) != 0) ^ v18) | ((x_WORD)v630 == 0))
							goto LABEL_848;
						j = &v627[v629];
						goto LABEL_831;
					case 0x10:
						v647 = (unsigned __int16 *)&unk_DE56C;
						HIWORD(v648) = 0;
						while (1)
						{
							LOWORD(v31) = v647[1];
							v649 = v647[3];
							v650 = (x_BYTE *)(x_DWORD_DE560 + v1102);
							v1102 += x_DWORD_DE560;
							if ((v31 & 0x8000u) == 0)
								break;
							if ((signed __int16)v649 > 0)
							{
								v651 = v1146 * (unsigned __int16)-(signed __int16)v31;
								v652 = v651;
								v31 = v651 >> 8;
								v180 = __CFADD__(v647[8], v652);
								v653 = v647[8] + v652;
								BYTE1(v31) += *((x_BYTE *)v647 + 18) + v180;
								if (v649 > x_DWORD_DE564)
									LOWORD(v649) = x_DWORD_DE564;
								v31 = (unsigned __int16)v31;
								LOBYTE(v31) = x_BYTE_E126C;
							LABEL_860:
								while (1)
								{
									BYTE1(v648) = x_BYTE_F6EE0_tables[v31];
									LOBYTE(v648) = *v650;
									*v650 = x_BYTE_FAEE0[v648];
									v180 = __CFADD__((x_WORD)v1146, v653);
									v654 = v1146 + v653;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v655 = v649 - 1;
									if (!v655)
										break;
									BYTE1(v648) = x_BYTE_F6EE0_tables[v31];
									LOBYTE(v648) = v650[1];
									v650[1] = x_BYTE_FAEE0[v648];
									v180 = __CFADD__((x_WORD)v1146, v654);
									v656 = v1146 + v654;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v657 = v655 - 1;
									if (!v657)
										break;
									BYTE1(v648) = x_BYTE_F6EE0_tables[v31];
									LOBYTE(v648) = v650[2];
									v650[2] = x_BYTE_FAEE0[v648];
									v180 = __CFADD__((x_WORD)v1146, v656);
									v658 = v1146 + v656;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v659 = v657 - 1;
									if (!v659)
										break;
									BYTE1(v648) = x_BYTE_F6EE0_tables[v31];
									LOBYTE(v648) = v650[3];
									v650[3] = x_BYTE_FAEE0[v648];
									v180 = __CFADD__((x_WORD)v1146, v658);
									v660 = v1146 + v658;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v661 = v659 - 1;
									if (!v661)
										break;
									BYTE1(v648) = x_BYTE_F6EE0_tables[v31];
									LOBYTE(v648) = v650[4];
									v650[4] = x_BYTE_FAEE0[v648];
									v180 = __CFADD__((x_WORD)v1146, v660);
									v662 = v1146 + v660;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v663 = v661 - 1;
									if (!v663)
										break;
									BYTE1(v648) = x_BYTE_F6EE0_tables[v31];
									LOBYTE(v648) = v650[5];
									v650[5] = x_BYTE_FAEE0[v648];
									v180 = __CFADD__((x_WORD)v1146, v662);
									v664 = v1146 + v662;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v665 = v663 - 1;
									if (!v665)
										break;
									BYTE1(v648) = x_BYTE_F6EE0_tables[v31];
									LOBYTE(v648) = v650[6];
									v650[6] = x_BYTE_FAEE0[v648];
									v180 = __CFADD__((x_WORD)v1146, v664);
									v666 = v1146 + v664;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v667 = v665 - 1;
									if (!v667)
										break;
									BYTE1(v648) = x_BYTE_F6EE0_tables[v31];
									LOBYTE(v648) = v650[7];
									v650[7] = x_BYTE_FAEE0[v648];
									v180 = __CFADD__((x_WORD)v1146, v666);
									v668 = v1146 + v666;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v669 = v667 - 1;
									if (!v669)
										break;
									BYTE1(v648) = x_BYTE_F6EE0_tables[v31];
									LOBYTE(v648) = v650[8];
									v650[8] = x_BYTE_FAEE0[v648];
									v180 = __CFADD__((x_WORD)v1146, v668);
									v670 = v1146 + v668;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v671 = v669 - 1;
									if (!v671)
										break;
									BYTE1(v648) = x_BYTE_F6EE0_tables[v31];
									LOBYTE(v648) = v650[9];
									v650[9] = x_BYTE_FAEE0[v648];
									v180 = __CFADD__((x_WORD)v1146, v670);
									v672 = v1146 + v670;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v673 = v671 - 1;
									if (!v673)
										break;
									BYTE1(v648) = x_BYTE_F6EE0_tables[v31];
									LOBYTE(v648) = v650[10];
									v650[10] = x_BYTE_FAEE0[v648];
									v180 = __CFADD__((x_WORD)v1146, v672);
									v674 = v1146 + v672;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v675 = v673 - 1;
									if (!v675)
										break;
									BYTE1(v648) = x_BYTE_F6EE0_tables[v31];
									LOBYTE(v648) = v650[11];
									v650[11] = x_BYTE_FAEE0[v648];
									v180 = __CFADD__((x_WORD)v1146, v674);
									v676 = v1146 + v674;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v677 = v675 - 1;
									if (!v677)
										break;
									BYTE1(v648) = x_BYTE_F6EE0_tables[v31];
									LOBYTE(v648) = v650[12];
									v650[12] = x_BYTE_FAEE0[v648];
									v180 = __CFADD__((x_WORD)v1146, v676);
									v678 = v1146 + v676;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v679 = v677 - 1;
									if (!v679)
										break;
									BYTE1(v648) = x_BYTE_F6EE0_tables[v31];
									LOBYTE(v648) = v650[13];
									v650[13] = x_BYTE_FAEE0[v648];
									v180 = __CFADD__((x_WORD)v1146, v678);
									v680 = v1146 + v678;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v681 = v679 - 1;
									if (!v681)
										break;
									BYTE1(v648) = x_BYTE_F6EE0_tables[v31];
									LOBYTE(v648) = v650[14];
									v650[14] = x_BYTE_FAEE0[v648];
									v180 = __CFADD__((x_WORD)v1146, v680);
									v682 = v1146 + v680;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v683 = v681 - 1;
									if (!v683)
										break;
									BYTE1(v648) = x_BYTE_F6EE0_tables[v31];
									LOBYTE(v648) = v650[15];
									v650[15] = x_BYTE_FAEE0[v648];
									v180 = __CFADD__((x_WORD)v1146, v682);
									v653 = v1146 + v682;
									BYTE1(v31) += BYTE2(v1146) + v180;
									LOWORD(v649) = v683 - 1;
									if (!(x_WORD)v649)
										break;
									v650 += 16;
								}
							}
						LABEL_877:
							v647 += 10;
							if (!--v1123)
								return;
						}
						if (v649 > x_DWORD_DE564)
							LOWORD(v649) = x_DWORD_DE564;
						v18 = __OFSUB__((x_WORD)v649, (x_WORD)v31);
						LOWORD(v649) = v649 - v31;
						if ((unsigned __int8)(((v649 & 0x8000u) != 0) ^ v18) | ((x_WORD)v649 == 0))
							goto LABEL_877;
						v650 += v31;
						v31 = (unsigned __int8)x_BYTE_E126C;
						v653 = v647[8];
						BYTE1(v31) = *((x_BYTE *)v647 + 18);
						goto LABEL_860;
					case 0x11:
						v684 = (unsigned __int16 *)&unk_DE56C;
						HIWORD(v685) = 0;
						while (1)
						{
							LOWORD(v31) = v684[1];
							v686 = v684[3];
							v687 = (x_BYTE *)(x_DWORD_DE560 + v1102);
							v1102 += x_DWORD_DE560;
							if ((v31 & 0x8000u) == 0)
								break;
							if ((signed __int16)v686 > 0)
							{
								v688 = v1146 * (unsigned __int16)-(signed __int16)v31;
								v689 = v688;
								v31 = v688 >> 8;
								v180 = __CFADD__(v684[8], v689);
								v690 = v684[8] + v689;
								BYTE1(v31) += *((x_BYTE *)v684 + 18) + v180;
								if (v686 > x_DWORD_DE564)
									LOWORD(v686) = x_DWORD_DE564;
								v31 = (unsigned __int16)v31;
								LOBYTE(v31) = x_BYTE_E126C;
							LABEL_889:
								while (1)
								{
									LOBYTE(v685) = x_BYTE_F6EE0_tables[v31];
									BYTE1(v685) = *v687;
									*v687 = x_BYTE_FAEE0[v685];
									v180 = __CFADD__((x_WORD)v1146, v690);
									v691 = v1146 + v690;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v692 = v686 - 1;
									if (!v692)
										break;
									LOBYTE(v685) = x_BYTE_F6EE0_tables[v31];
									BYTE1(v685) = v687[1];
									v687[1] = x_BYTE_FAEE0[v685];
									v180 = __CFADD__((x_WORD)v1146, v691);
									v693 = v1146 + v691;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v694 = v692 - 1;
									if (!v694)
										break;
									LOBYTE(v685) = x_BYTE_F6EE0_tables[v31];
									BYTE1(v685) = v687[2];
									v687[2] = x_BYTE_FAEE0[v685];
									v180 = __CFADD__((x_WORD)v1146, v693);
									v695 = v1146 + v693;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v696 = v694 - 1;
									if (!v696)
										break;
									LOBYTE(v685) = x_BYTE_F6EE0_tables[v31];
									BYTE1(v685) = v687[3];
									v687[3] = x_BYTE_FAEE0[v685];
									v180 = __CFADD__((x_WORD)v1146, v695);
									v697 = v1146 + v695;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v698 = v696 - 1;
									if (!v698)
										break;
									LOBYTE(v685) = x_BYTE_F6EE0_tables[v31];
									BYTE1(v685) = v687[4];
									v687[4] = x_BYTE_FAEE0[v685];
									v180 = __CFADD__((x_WORD)v1146, v697);
									v699 = v1146 + v697;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v700 = v698 - 1;
									if (!v700)
										break;
									LOBYTE(v685) = x_BYTE_F6EE0_tables[v31];
									BYTE1(v685) = v687[5];
									v687[5] = x_BYTE_FAEE0[v685];
									v180 = __CFADD__((x_WORD)v1146, v699);
									v701 = v1146 + v699;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v702 = v700 - 1;
									if (!v702)
										break;
									LOBYTE(v685) = x_BYTE_F6EE0_tables[v31];
									BYTE1(v685) = v687[6];
									v687[6] = x_BYTE_FAEE0[v685];
									v180 = __CFADD__((x_WORD)v1146, v701);
									v703 = v1146 + v701;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v704 = v702 - 1;
									if (!v704)
										break;
									LOBYTE(v685) = x_BYTE_F6EE0_tables[v31];
									BYTE1(v685) = v687[7];
									v687[7] = x_BYTE_FAEE0[v685];
									v180 = __CFADD__((x_WORD)v1146, v703);
									v705 = v1146 + v703;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v706 = v704 - 1;
									if (!v706)
										break;
									LOBYTE(v685) = x_BYTE_F6EE0_tables[v31];
									BYTE1(v685) = v687[8];
									v687[8] = x_BYTE_FAEE0[v685];
									v180 = __CFADD__((x_WORD)v1146, v705);
									v707 = v1146 + v705;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v708 = v706 - 1;
									if (!v708)
										break;
									LOBYTE(v685) = x_BYTE_F6EE0_tables[v31];
									BYTE1(v685) = v687[9];
									v687[9] = x_BYTE_FAEE0[v685];
									v180 = __CFADD__((x_WORD)v1146, v707);
									v709 = v1146 + v707;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v710 = v708 - 1;
									if (!v710)
										break;
									LOBYTE(v685) = x_BYTE_F6EE0_tables[v31];
									BYTE1(v685) = v687[10];
									v687[10] = x_BYTE_FAEE0[v685];
									v180 = __CFADD__((x_WORD)v1146, v709);
									v711 = v1146 + v709;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v712 = v710 - 1;
									if (!v712)
										break;
									LOBYTE(v685) = x_BYTE_F6EE0_tables[v31];
									BYTE1(v685) = v687[11];
									v687[11] = x_BYTE_FAEE0[v685];
									v180 = __CFADD__((x_WORD)v1146, v711);
									v713 = v1146 + v711;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v714 = v712 - 1;
									if (!v714)
										break;
									LOBYTE(v685) = x_BYTE_F6EE0_tables[v31];
									BYTE1(v685) = v687[12];
									v687[12] = x_BYTE_FAEE0[v685];
									v180 = __CFADD__((x_WORD)v1146, v713);
									v715 = v1146 + v713;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v716 = v714 - 1;
									if (!v716)
										break;
									LOBYTE(v685) = x_BYTE_F6EE0_tables[v31];
									BYTE1(v685) = v687[13];
									v687[13] = x_BYTE_FAEE0[v685];
									v180 = __CFADD__((x_WORD)v1146, v715);
									v717 = v1146 + v715;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v718 = v716 - 1;
									if (!v718)
										break;
									LOBYTE(v685) = x_BYTE_F6EE0_tables[v31];
									BYTE1(v685) = v687[14];
									v687[14] = x_BYTE_FAEE0[v685];
									v180 = __CFADD__((x_WORD)v1146, v717);
									v719 = v1146 + v717;
									BYTE1(v31) += BYTE2(v1146) + v180;
									v720 = v718 - 1;
									if (!v720)
										break;
									LOBYTE(v685) = x_BYTE_F6EE0_tables[v31];
									BYTE1(v685) = v687[15];
									v687[15] = x_BYTE_FAEE0[v685];
									v180 = __CFADD__((x_WORD)v1146, v719);
									v690 = v1146 + v719;
									BYTE1(v31) += BYTE2(v1146) + v180;
									LOWORD(v686) = v720 - 1;
									if (!(x_WORD)v686)
										break;
									v687 += 16;
								}
							}
						LABEL_906:
							v684 += 10;
							if (!--v1123)
								return;
						}
						if (v686 > x_DWORD_DE564)
							LOWORD(v686) = x_DWORD_DE564;
						v18 = __OFSUB__((x_WORD)v686, (x_WORD)v31);
						LOWORD(v686) = v686 - v31;
						if ((unsigned __int8)(((v686 & 0x8000u) != 0) ^ v18) | ((x_WORD)v686 == 0))
							goto LABEL_906;
						v687 += v31;
						v31 = (unsigned __int8)x_BYTE_E126C;
						v690 = v684[8];
						BYTE1(v31) = *((x_BYTE *)v684 + 18);
						goto LABEL_889;
					case 0x12:
						v721 = (unsigned __int16 *)&unk_DE56C;
						v1174 = v1135 << 16;
						HIWORD(v722) = 0;
						HIWORD(v723) = 0;
						while (1)
						{
							LOWORD(v722) = v721[1];
							v724 = v721[3];
							v725 = (x_BYTE *)(x_DWORD_DE560 + v1102);
							v1102 += x_DWORD_DE560;
							if ((v722 & 0x8000u) == 0)
								break;
							if ((signed __int16)v724 > 0)
							{
								v726 = (unsigned __int16)-(signed __int16)v722;
								v728 = __ROL4__(*((x_DWORD *)v721 + 3) + v1135 * v726, 16);
								BYTE1(v723) = v728;
								v727 = *((x_DWORD *)v721 + 2) + v1124 * v726;
								LOWORD(v728) = v727;
								v729 = v727 >> 8;
								LOBYTE(v723) = BYTE1(v729);
								if (v724 > x_DWORD_DE564)
									LOWORD(v724) = x_DWORD_DE564;
								v722 = (unsigned __int16)v729;
							LABEL_918:
								v1283 = v721;
								v730 = x_DWORD_DE55C;
								while (1)
								{
									BYTE1(v722) = *(x_BYTE *)(v723 + v730);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v728);
									LOWORD(v728) = v1124 + v728;
									LOBYTE(v722) = *v725;
									LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
									v180 = __CFADD__(v1174, v728);
									v731 = v1174 + v728;
									*v725 = x_BYTE_FAEE0[v722];
									BYTE1(v723) += BYTE2(v1135) + v180;
									v732 = v724 - 1;
									if (!v732)
										break;
									BYTE1(v722) = *(x_BYTE *)(v723 + v730);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v731);
									LOWORD(v731) = v1124 + v731;
									LOBYTE(v722) = v725[1];
									LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
									v180 = __CFADD__(v1174, v731);
									v733 = v1174 + v731;
									v725[1] = x_BYTE_FAEE0[v722];
									BYTE1(v723) += BYTE2(v1135) + v180;
									v734 = v732 - 1;
									if (!v734)
										break;
									BYTE1(v722) = *(x_BYTE *)(v723 + v730);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v733);
									LOWORD(v733) = v1124 + v733;
									LOBYTE(v722) = v725[2];
									LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
									v180 = __CFADD__(v1174, v733);
									v735 = v1174 + v733;
									v725[2] = x_BYTE_FAEE0[v722];
									BYTE1(v723) += BYTE2(v1135) + v180;
									v736 = v734 - 1;
									if (!v736)
										break;
									BYTE1(v722) = *(x_BYTE *)(v723 + v730);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v735);
									LOWORD(v735) = v1124 + v735;
									LOBYTE(v722) = v725[3];
									LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
									v180 = __CFADD__(v1174, v735);
									v737 = v1174 + v735;
									v725[3] = x_BYTE_FAEE0[v722];
									BYTE1(v723) += BYTE2(v1135) + v180;
									v738 = v736 - 1;
									if (!v738)
										break;
									BYTE1(v722) = *(x_BYTE *)(v723 + v730);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v737);
									LOWORD(v737) = v1124 + v737;
									LOBYTE(v722) = v725[4];
									LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
									v180 = __CFADD__(v1174, v737);
									v739 = v1174 + v737;
									v725[4] = x_BYTE_FAEE0[v722];
									BYTE1(v723) += BYTE2(v1135) + v180;
									v740 = v738 - 1;
									if (!v740)
										break;
									BYTE1(v722) = *(x_BYTE *)(v723 + v730);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v739);
									LOWORD(v739) = v1124 + v739;
									LOBYTE(v722) = v725[5];
									LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
									v180 = __CFADD__(v1174, v739);
									v741 = v1174 + v739;
									v725[5] = x_BYTE_FAEE0[v722];
									BYTE1(v723) += BYTE2(v1135) + v180;
									v742 = v740 - 1;
									if (!v742)
										break;
									BYTE1(v722) = *(x_BYTE *)(v723 + v730);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v741);
									LOWORD(v741) = v1124 + v741;
									LOBYTE(v722) = v725[6];
									LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
									v180 = __CFADD__(v1174, v741);
									v743 = v1174 + v741;
									v725[6] = x_BYTE_FAEE0[v722];
									BYTE1(v723) += BYTE2(v1135) + v180;
									v744 = v742 - 1;
									if (!v744)
										break;
									BYTE1(v722) = *(x_BYTE *)(v723 + v730);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v743);
									LOWORD(v743) = v1124 + v743;
									LOBYTE(v722) = v725[7];
									LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
									v180 = __CFADD__(v1174, v743);
									v745 = v1174 + v743;
									v725[7] = x_BYTE_FAEE0[v722];
									BYTE1(v723) += BYTE2(v1135) + v180;
									v746 = v744 - 1;
									if (!v746)
										break;
									BYTE1(v722) = *(x_BYTE *)(v723 + v730);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v745);
									LOWORD(v745) = v1124 + v745;
									LOBYTE(v722) = v725[8];
									LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
									v180 = __CFADD__(v1174, v745);
									v747 = v1174 + v745;
									v725[8] = x_BYTE_FAEE0[v722];
									BYTE1(v723) += BYTE2(v1135) + v180;
									v748 = v746 - 1;
									if (!v748)
										break;
									BYTE1(v722) = *(x_BYTE *)(v723 + v730);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v747);
									LOWORD(v747) = v1124 + v747;
									LOBYTE(v722) = v725[9];
									LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
									v180 = __CFADD__(v1174, v747);
									v749 = v1174 + v747;
									v725[9] = x_BYTE_FAEE0[v722];
									BYTE1(v723) += BYTE2(v1135) + v180;
									v750 = v748 - 1;
									if (!v750)
										break;
									BYTE1(v722) = *(x_BYTE *)(v723 + v730);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v749);
									LOWORD(v749) = v1124 + v749;
									LOBYTE(v722) = v725[10];
									LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
									v180 = __CFADD__(v1174, v749);
									v751 = v1174 + v749;
									v725[10] = x_BYTE_FAEE0[v722];
									BYTE1(v723) += BYTE2(v1135) + v180;
									v752 = v750 - 1;
									if (!v752)
										break;
									BYTE1(v722) = *(x_BYTE *)(v723 + v730);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v751);
									LOWORD(v751) = v1124 + v751;
									LOBYTE(v722) = v725[11];
									LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
									v180 = __CFADD__(v1174, v751);
									v753 = v1174 + v751;
									v725[11] = x_BYTE_FAEE0[v722];
									BYTE1(v723) += BYTE2(v1135) + v180;
									v754 = v752 - 1;
									if (!v754)
										break;
									BYTE1(v722) = *(x_BYTE *)(v723 + v730);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v753);
									LOWORD(v753) = v1124 + v753;
									LOBYTE(v722) = v725[12];
									LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
									v180 = __CFADD__(v1174, v753);
									v755 = v1174 + v753;
									v725[12] = x_BYTE_FAEE0[v722];
									BYTE1(v723) += BYTE2(v1135) + v180;
									v756 = v754 - 1;
									if (!v756)
										break;
									BYTE1(v722) = *(x_BYTE *)(v723 + v730);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v755);
									LOWORD(v755) = v1124 + v755;
									LOBYTE(v722) = v725[13];
									LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
									v180 = __CFADD__(v1174, v755);
									v757 = v1174 + v755;
									v725[13] = x_BYTE_FAEE0[v722];
									BYTE1(v723) += BYTE2(v1135) + v180;
									v758 = v756 - 1;
									if (!v758)
										break;
									BYTE1(v722) = *(x_BYTE *)(v723 + v730);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v757);
									LOWORD(v757) = v1124 + v757;
									LOBYTE(v722) = v725[14];
									LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
									v180 = __CFADD__(v1174, v757);
									v759 = v1174 + v757;
									v725[14] = x_BYTE_FAEE0[v722];
									BYTE1(v723) += BYTE2(v1135) + v180;
									v760 = v758 - 1;
									if (!v760)
										break;
									BYTE1(v722) = *(x_BYTE *)(v723 + v730);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v759);
									LOWORD(v759) = v1124 + v759;
									LOBYTE(v722) = v725[15];
									LOBYTE(v723) = BYTE2(v1124) + v180 + v723;
									v180 = __CFADD__(v1174, v759);
									v728 = v1174 + v759;
									v725[15] = x_BYTE_FAEE0[v722];
									BYTE1(v723) += BYTE2(v1135) + v180;
									LOWORD(v724) = v760 - 1;
									if (!(x_WORD)v724)
										break;
									v725 += 16;
								}
								v721 = v1283;
							}
						LABEL_937:
							v721 += 10;
							if (!--v1123)
								return;
						}
						if (v724 > x_DWORD_DE564)
							LOWORD(v724) = x_DWORD_DE564;
						v18 = __OFSUB__((x_WORD)v724, (x_WORD)v722);
						LOWORD(v724) = v724 - v722;
						if ((unsigned __int8)(((v724 & 0x8000u) != 0) ^ v18) | ((x_WORD)v724 == 0))
							goto LABEL_937;
						v725 += v722;
						v728 = __ROL4__(*((x_DWORD *)v721 + 3), 16);
						BYTE1(v723) = v728;
						LOWORD(v728) = v721[4];
						LOBYTE(v723) = *((x_BYTE *)v721 + 10);
						goto LABEL_918;
					case 0x13:
						v761 = (unsigned __int16 *)&unk_DE56C;
						v1175 = v1135 << 16;
						HIWORD(v762) = 0;
						HIWORD(v763) = 0;
						while (1)
						{
							LOWORD(v762) = v761[1];
							v764 = v761[3];
							v765 = (x_BYTE *)(x_DWORD_DE560 + v1102);
							v1102 += x_DWORD_DE560;
							if ((v762 & 0x8000u) == 0)
								break;
							if ((signed __int16)v764 > 0)
							{
								v766 = (unsigned __int16)-(signed __int16)v762;
								v768 = __ROL4__(*((x_DWORD *)v761 + 3) + v1135 * v766, 16);
								BYTE1(v763) = v768;
								v767 = *((x_DWORD *)v761 + 2) + v1124 * v766;
								LOWORD(v768) = v767;
								v769 = v767 >> 8;
								LOBYTE(v763) = BYTE1(v769);
								if (v764 > x_DWORD_DE564)
									LOWORD(v764) = x_DWORD_DE564;
								v762 = (unsigned __int16)v769;
							LABEL_949:
								v1284 = v761;
								v770 = x_DWORD_DE55C;
								while (1)
								{
									LOBYTE(v762) = *(x_BYTE *)(v763 + v770);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v768);
									LOWORD(v768) = v1124 + v768;
									BYTE1(v762) = *v765;
									LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
									v180 = __CFADD__(v1175, v768);
									v771 = v1175 + v768;
									*v765 = x_BYTE_FAEE0[v762];
									BYTE1(v763) += BYTE2(v1135) + v180;
									v772 = v764 - 1;
									if (!v772)
										break;
									LOBYTE(v762) = *(x_BYTE *)(v763 + v770);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v771);
									LOWORD(v771) = v1124 + v771;
									BYTE1(v762) = v765[1];
									LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
									v180 = __CFADD__(v1175, v771);
									v773 = v1175 + v771;
									v765[1] = x_BYTE_FAEE0[v762];
									BYTE1(v763) += BYTE2(v1135) + v180;
									v774 = v772 - 1;
									if (!v774)
										break;
									LOBYTE(v762) = *(x_BYTE *)(v763 + v770);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v773);
									LOWORD(v773) = v1124 + v773;
									BYTE1(v762) = v765[2];
									LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
									v180 = __CFADD__(v1175, v773);
									v775 = v1175 + v773;
									v765[2] = x_BYTE_FAEE0[v762];
									BYTE1(v763) += BYTE2(v1135) + v180;
									v776 = v774 - 1;
									if (!v776)
										break;
									LOBYTE(v762) = *(x_BYTE *)(v763 + v770);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v775);
									LOWORD(v775) = v1124 + v775;
									BYTE1(v762) = v765[3];
									LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
									v180 = __CFADD__(v1175, v775);
									v777 = v1175 + v775;
									v765[3] = x_BYTE_FAEE0[v762];
									BYTE1(v763) += BYTE2(v1135) + v180;
									v778 = v776 - 1;
									if (!v778)
										break;
									LOBYTE(v762) = *(x_BYTE *)(v763 + v770);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v777);
									LOWORD(v777) = v1124 + v777;
									BYTE1(v762) = v765[4];
									LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
									v180 = __CFADD__(v1175, v777);
									v779 = v1175 + v777;
									v765[4] = x_BYTE_FAEE0[v762];
									BYTE1(v763) += BYTE2(v1135) + v180;
									v780 = v778 - 1;
									if (!v780)
										break;
									LOBYTE(v762) = *(x_BYTE *)(v763 + v770);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v779);
									LOWORD(v779) = v1124 + v779;
									BYTE1(v762) = v765[5];
									LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
									v180 = __CFADD__(v1175, v779);
									v781 = v1175 + v779;
									v765[5] = x_BYTE_FAEE0[v762];
									BYTE1(v763) += BYTE2(v1135) + v180;
									v782 = v780 - 1;
									if (!v782)
										break;
									LOBYTE(v762) = *(x_BYTE *)(v763 + v770);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v781);
									LOWORD(v781) = v1124 + v781;
									BYTE1(v762) = v765[6];
									LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
									v180 = __CFADD__(v1175, v781);
									v783 = v1175 + v781;
									v765[6] = x_BYTE_FAEE0[v762];
									BYTE1(v763) += BYTE2(v1135) + v180;
									v784 = v782 - 1;
									if (!v784)
										break;
									LOBYTE(v762) = *(x_BYTE *)(v763 + v770);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v783);
									LOWORD(v783) = v1124 + v783;
									BYTE1(v762) = v765[7];
									LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
									v180 = __CFADD__(v1175, v783);
									v785 = v1175 + v783;
									v765[7] = x_BYTE_FAEE0[v762];
									BYTE1(v763) += BYTE2(v1135) + v180;
									v786 = v784 - 1;
									if (!v786)
										break;
									LOBYTE(v762) = *(x_BYTE *)(v763 + v770);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v785);
									LOWORD(v785) = v1124 + v785;
									BYTE1(v762) = v765[8];
									LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
									v180 = __CFADD__(v1175, v785);
									v787 = v1175 + v785;
									v765[8] = x_BYTE_FAEE0[v762];
									BYTE1(v763) += BYTE2(v1135) + v180;
									v788 = v786 - 1;
									if (!v788)
										break;
									LOBYTE(v762) = *(x_BYTE *)(v763 + v770);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v787);
									LOWORD(v787) = v1124 + v787;
									BYTE1(v762) = v765[9];
									LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
									v180 = __CFADD__(v1175, v787);
									v789 = v1175 + v787;
									v765[9] = x_BYTE_FAEE0[v762];
									BYTE1(v763) += BYTE2(v1135) + v180;
									v790 = v788 - 1;
									if (!v790)
										break;
									LOBYTE(v762) = *(x_BYTE *)(v763 + v770);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v789);
									LOWORD(v789) = v1124 + v789;
									BYTE1(v762) = v765[10];
									LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
									v180 = __CFADD__(v1175, v789);
									v791 = v1175 + v789;
									v765[10] = x_BYTE_FAEE0[v762];
									BYTE1(v763) += BYTE2(v1135) + v180;
									v792 = v790 - 1;
									if (!v792)
										break;
									LOBYTE(v762) = *(x_BYTE *)(v763 + v770);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v791);
									LOWORD(v791) = v1124 + v791;
									BYTE1(v762) = v765[11];
									LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
									v180 = __CFADD__(v1175, v791);
									v793 = v1175 + v791;
									v765[11] = x_BYTE_FAEE0[v762];
									BYTE1(v763) += BYTE2(v1135) + v180;
									v794 = v792 - 1;
									if (!v794)
										break;
									LOBYTE(v762) = *(x_BYTE *)(v763 + v770);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v793);
									LOWORD(v793) = v1124 + v793;
									BYTE1(v762) = v765[12];
									LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
									v180 = __CFADD__(v1175, v793);
									v795 = v1175 + v793;
									v765[12] = x_BYTE_FAEE0[v762];
									BYTE1(v763) += BYTE2(v1135) + v180;
									v796 = v794 - 1;
									if (!v796)
										break;
									LOBYTE(v762) = *(x_BYTE *)(v763 + v770);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v795);
									LOWORD(v795) = v1124 + v795;
									BYTE1(v762) = v765[13];
									LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
									v180 = __CFADD__(v1175, v795);
									v797 = v1175 + v795;
									v765[13] = x_BYTE_FAEE0[v762];
									BYTE1(v763) += BYTE2(v1135) + v180;
									v798 = v796 - 1;
									if (!v798)
										break;
									LOBYTE(v762) = *(x_BYTE *)(v763 + v770);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v797);
									LOWORD(v797) = v1124 + v797;
									BYTE1(v762) = v765[14];
									LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
									v180 = __CFADD__(v1175, v797);
									v799 = v1175 + v797;
									v765[14] = x_BYTE_FAEE0[v762];
									BYTE1(v763) += BYTE2(v1135) + v180;
									v800 = v798 - 1;
									if (!v800)
										break;
									LOBYTE(v762) = *(x_BYTE *)(v763 + v770);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v799);
									LOWORD(v799) = v1124 + v799;
									BYTE1(v762) = v765[15];
									LOBYTE(v763) = BYTE2(v1124) + v180 + v763;
									v180 = __CFADD__(v1175, v799);
									v768 = v1175 + v799;
									v765[15] = x_BYTE_FAEE0[v762];
									BYTE1(v763) += BYTE2(v1135) + v180;
									LOWORD(v764) = v800 - 1;
									if (!(x_WORD)v764)
										break;
									v765 += 16;
								}
								v761 = v1284;
							}
						LABEL_968:
							v761 += 10;
							if (!--v1123)
								return;
						}
						if (v764 > x_DWORD_DE564)
							LOWORD(v764) = x_DWORD_DE564;
						v18 = __OFSUB__((x_WORD)v764, (x_WORD)v762);
						LOWORD(v764) = v764 - v762;
						if ((unsigned __int8)(((v764 & 0x8000u) != 0) ^ v18) | ((x_WORD)v764 == 0))
							goto LABEL_968;
						v765 += v762;
						v768 = __ROL4__(*((x_DWORD *)v761 + 3), 16);
						BYTE1(v763) = v768;
						LOWORD(v768) = v761[4];
						LOBYTE(v763) = *((x_BYTE *)v761 + 10);
						goto LABEL_949;
					case 0x14:
						v801 = (unsigned __int16 *)&unk_DE56C;
						v1176 = v1135 << 16;
						v1185 = v1146 << 16;
						HIWORD(v802) = 0;
						HIWORD(v803) = 0;
						while (1)
						{
							LOWORD(v802) = v801[1];
							v804 = v801[3];
							v805 = (x_BYTE *)(x_DWORD_DE560 + v1102);
							v1102 += x_DWORD_DE560;
							if ((v802 & 0x8000u) == 0)
								break;
							if ((signed __int16)v804 > 0)
							{
								if (v804 > x_DWORD_DE564)
									v804 = x_DWORD_DE564;
								v1194 = v804;
								v806 = (unsigned __int16)-(signed __int16)v802;
								v807 = v806;
								v809 = __ROL4__(*((x_DWORD *)v801 + 3) + v1135 * v806, 16);
								BYTE1(v803) = v809;
								v808 = *((x_DWORD *)v801 + 2) + v1124 * v806;
								LOWORD(v809) = v808;
								v802 = v808 >> 8;
								LOBYTE(v803) = BYTE1(v802);
								v810 = __ROL4__(*((x_DWORD *)v801 + 4) + v1146 * v807, 16);
								v802 = (unsigned __int16)v802;
							LABEL_980:
								v1285 = v801;
								v811 = x_DWORD_DE55C;
								while (1)
								{
									LOBYTE(v802) = *(x_BYTE *)(v803 + v811);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v809);
									LOWORD(v809) = v1124 + v809;
									BYTE1(v802) = v810;
									LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
									BYTE1(v802) = x_BYTE_F6EE0_tables[v802];
									v180 = __CFADD__(v1176, v809);
									v812 = v1176 + v809;
									LOBYTE(v802) = *v805;
									BYTE1(v803) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1185, v810);
									v813 = v1185 + v810;
									*v805 = x_BYTE_FAEE0[v802];
									LOBYTE(v813) = BYTE2(v1146) + v180 + v813;
									v1195 = v1194 - 1;
									if (!v1195)
										break;
									LOBYTE(v802) = *(x_BYTE *)(v803 + v811);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v812);
									LOWORD(v812) = v1124 + v812;
									BYTE1(v802) = v813;
									LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
									BYTE1(v802) = x_BYTE_F6EE0_tables[v802];
									v180 = __CFADD__(v1176, v812);
									v814 = v1176 + v812;
									LOBYTE(v802) = v805[1];
									BYTE1(v803) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1185, v813);
									v815 = v1185 + v813;
									v805[1] = x_BYTE_FAEE0[v802];
									LOBYTE(v815) = BYTE2(v1146) + v180 + v815;
									v1196 = v1195 - 1;
									if (!v1196)
										break;
									LOBYTE(v802) = *(x_BYTE *)(v803 + v811);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v814);
									LOWORD(v814) = v1124 + v814;
									BYTE1(v802) = v815;
									LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
									BYTE1(v802) = x_BYTE_F6EE0_tables[v802];
									v180 = __CFADD__(v1176, v814);
									v816 = v1176 + v814;
									LOBYTE(v802) = v805[2];
									BYTE1(v803) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1185, v815);
									v817 = v1185 + v815;
									v805[2] = x_BYTE_FAEE0[v802];
									LOBYTE(v817) = BYTE2(v1146) + v180 + v817;
									v1197 = v1196 - 1;
									if (!v1197)
										break;
									LOBYTE(v802) = *(x_BYTE *)(v803 + v811);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v816);
									LOWORD(v816) = v1124 + v816;
									BYTE1(v802) = v817;
									LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
									BYTE1(v802) = x_BYTE_F6EE0_tables[v802];
									v180 = __CFADD__(v1176, v816);
									v818 = v1176 + v816;
									LOBYTE(v802) = v805[3];
									BYTE1(v803) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1185, v817);
									v819 = v1185 + v817;
									v805[3] = x_BYTE_FAEE0[v802];
									LOBYTE(v819) = BYTE2(v1146) + v180 + v819;
									v1198 = v1197 - 1;
									if (!v1198)
										break;
									LOBYTE(v802) = *(x_BYTE *)(v803 + v811);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v818);
									LOWORD(v818) = v1124 + v818;
									BYTE1(v802) = v819;
									LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
									BYTE1(v802) = x_BYTE_F6EE0_tables[v802];
									v180 = __CFADD__(v1176, v818);
									v820 = v1176 + v818;
									LOBYTE(v802) = v805[4];
									BYTE1(v803) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1185, v819);
									v821 = v1185 + v819;
									v805[4] = x_BYTE_FAEE0[v802];
									LOBYTE(v821) = BYTE2(v1146) + v180 + v821;
									v1199 = v1198 - 1;
									if (!v1199)
										break;
									LOBYTE(v802) = *(x_BYTE *)(v803 + v811);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v820);
									LOWORD(v820) = v1124 + v820;
									BYTE1(v802) = v821;
									LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
									BYTE1(v802) = x_BYTE_F6EE0_tables[v802];
									v180 = __CFADD__(v1176, v820);
									v822 = v1176 + v820;
									LOBYTE(v802) = v805[5];
									BYTE1(v803) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1185, v821);
									v823 = v1185 + v821;
									v805[5] = x_BYTE_FAEE0[v802];
									LOBYTE(v823) = BYTE2(v1146) + v180 + v823;
									v1200 = v1199 - 1;
									if (!v1200)
										break;
									LOBYTE(v802) = *(x_BYTE *)(v803 + v811);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v822);
									LOWORD(v822) = v1124 + v822;
									BYTE1(v802) = v823;
									LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
									BYTE1(v802) = x_BYTE_F6EE0_tables[v802];
									v180 = __CFADD__(v1176, v822);
									v824 = v1176 + v822;
									LOBYTE(v802) = v805[6];
									BYTE1(v803) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1185, v823);
									v825 = v1185 + v823;
									v805[6] = x_BYTE_FAEE0[v802];
									LOBYTE(v825) = BYTE2(v1146) + v180 + v825;
									v1201 = v1200 - 1;
									if (!v1201)
										break;
									LOBYTE(v802) = *(x_BYTE *)(v803 + v811);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v824);
									LOWORD(v824) = v1124 + v824;
									BYTE1(v802) = v825;
									LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
									BYTE1(v802) = x_BYTE_F6EE0_tables[v802];
									v180 = __CFADD__(v1176, v824);
									v826 = v1176 + v824;
									LOBYTE(v802) = v805[7];
									BYTE1(v803) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1185, v825);
									v827 = v1185 + v825;
									v805[7] = x_BYTE_FAEE0[v802];
									LOBYTE(v827) = BYTE2(v1146) + v180 + v827;
									v1202 = v1201 - 1;
									if (!v1202)
										break;
									LOBYTE(v802) = *(x_BYTE *)(v803 + v811);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v826);
									LOWORD(v826) = v1124 + v826;
									BYTE1(v802) = v827;
									LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
									BYTE1(v802) = x_BYTE_F6EE0_tables[v802];
									v180 = __CFADD__(v1176, v826);
									v828 = v1176 + v826;
									LOBYTE(v802) = v805[8];
									BYTE1(v803) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1185, v827);
									v829 = v1185 + v827;
									v805[8] = x_BYTE_FAEE0[v802];
									LOBYTE(v829) = BYTE2(v1146) + v180 + v829;
									v1203 = v1202 - 1;
									if (!v1203)
										break;
									LOBYTE(v802) = *(x_BYTE *)(v803 + v811);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v828);
									LOWORD(v828) = v1124 + v828;
									BYTE1(v802) = v829;
									LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
									BYTE1(v802) = x_BYTE_F6EE0_tables[v802];
									v180 = __CFADD__(v1176, v828);
									v830 = v1176 + v828;
									LOBYTE(v802) = v805[9];
									BYTE1(v803) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1185, v829);
									v831 = v1185 + v829;
									v805[9] = x_BYTE_FAEE0[v802];
									LOBYTE(v831) = BYTE2(v1146) + v180 + v831;
									v1204 = v1203 - 1;
									if (!v1204)
										break;
									LOBYTE(v802) = *(x_BYTE *)(v803 + v811);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v830);
									LOWORD(v830) = v1124 + v830;
									BYTE1(v802) = v831;
									LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
									BYTE1(v802) = x_BYTE_F6EE0_tables[v802];
									v180 = __CFADD__(v1176, v830);
									v832 = v1176 + v830;
									LOBYTE(v802) = v805[10];
									BYTE1(v803) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1185, v831);
									v833 = v1185 + v831;
									v805[10] = x_BYTE_FAEE0[v802];
									LOBYTE(v833) = BYTE2(v1146) + v180 + v833;
									v1205 = v1204 - 1;
									if (!v1205)
										break;
									LOBYTE(v802) = *(x_BYTE *)(v803 + v811);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v832);
									LOWORD(v832) = v1124 + v832;
									BYTE1(v802) = v833;
									LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
									BYTE1(v802) = x_BYTE_F6EE0_tables[v802];
									v180 = __CFADD__(v1176, v832);
									v834 = v1176 + v832;
									LOBYTE(v802) = v805[11];
									BYTE1(v803) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1185, v833);
									v835 = v1185 + v833;
									v805[11] = x_BYTE_FAEE0[v802];
									LOBYTE(v835) = BYTE2(v1146) + v180 + v835;
									v1206 = v1205 - 1;
									if (!v1206)
										break;
									LOBYTE(v802) = *(x_BYTE *)(v803 + v811);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v834);
									LOWORD(v834) = v1124 + v834;
									BYTE1(v802) = v835;
									LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
									BYTE1(v802) = x_BYTE_F6EE0_tables[v802];
									v180 = __CFADD__(v1176, v834);
									v836 = v1176 + v834;
									LOBYTE(v802) = v805[12];
									BYTE1(v803) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1185, v835);
									v837 = v1185 + v835;
									v805[12] = x_BYTE_FAEE0[v802];
									LOBYTE(v837) = BYTE2(v1146) + v180 + v837;
									v1207 = v1206 - 1;
									if (!v1207)
										break;
									LOBYTE(v802) = *(x_BYTE *)(v803 + v811);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v836);
									LOWORD(v836) = v1124 + v836;
									BYTE1(v802) = v837;
									LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
									BYTE1(v802) = x_BYTE_F6EE0_tables[v802];
									v180 = __CFADD__(v1176, v836);
									v838 = v1176 + v836;
									LOBYTE(v802) = v805[13];
									BYTE1(v803) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1185, v837);
									v839 = v1185 + v837;
									v805[13] = x_BYTE_FAEE0[v802];
									LOBYTE(v839) = BYTE2(v1146) + v180 + v839;
									v1208 = v1207 - 1;
									if (!v1208)
										break;
									LOBYTE(v802) = *(x_BYTE *)(v803 + v811);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v838);
									LOWORD(v838) = v1124 + v838;
									BYTE1(v802) = v839;
									LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
									BYTE1(v802) = x_BYTE_F6EE0_tables[v802];
									v180 = __CFADD__(v1176, v838);
									v840 = v1176 + v838;
									LOBYTE(v802) = v805[14];
									BYTE1(v803) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1185, v839);
									v841 = v1185 + v839;
									v805[14] = x_BYTE_FAEE0[v802];
									LOBYTE(v841) = BYTE2(v1146) + v180 + v841;
									v1209 = v1208 - 1;
									if (!v1209)
										break;
									LOBYTE(v802) = *(x_BYTE *)(v803 + v811);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v840);
									LOWORD(v840) = v1124 + v840;
									BYTE1(v802) = v841;
									LOBYTE(v803) = BYTE2(v1124) + v180 + v803;
									BYTE1(v802) = x_BYTE_F6EE0_tables[v802];
									v180 = __CFADD__(v1176, v840);
									v809 = v1176 + v840;
									LOBYTE(v802) = v805[15];
									BYTE1(v803) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1185, v841);
									v810 = v1185 + v841;
									v805[15] = x_BYTE_FAEE0[v802];
									LOBYTE(v810) = BYTE2(v1146) + v180 + v810;
									v1194 = v1209 - 1;
									if (!v1194)
										break;
									v805 += 16;
								}
								v801 = v1285;
							}
						LABEL_999:
							v801 += 10;
							if (!--v1123)
								return;
						}
						if (v804 > x_DWORD_DE564)
							v804 = x_DWORD_DE564;
						v18 = __OFSUB__((x_WORD)v804, (x_WORD)v802);
						LOWORD(v804) = v804 - v802;
						if ((unsigned __int8)(((v804 & 0x8000u) != 0) ^ v18) | ((x_WORD)v804 == 0))
							goto LABEL_999;
						v805 += v802;
						v809 = __ROL4__(*((x_DWORD *)v801 + 3), 16);
						BYTE1(v803) = v809;
						LOWORD(v809) = v801[4];
						LOBYTE(v803) = *((x_BYTE *)v801 + 10);
						v1194 = v804;
						v810 = __ROL4__(*((x_DWORD *)v801 + 4), 16);
						goto LABEL_980;
					case 0x15:
						v842 = (unsigned __int16 *)&unk_DE56C;
						v1177 = v1135 << 16;
						v1186 = v1146 << 16;
						HIWORD(v843) = 0;
						HIWORD(v844) = 0;
						while (1)
						{
							LOWORD(v843) = v842[1];
							v845 = v842[3];
							v846 = (x_BYTE *)(x_DWORD_DE560 + v1102);
							v1102 += x_DWORD_DE560;
							if ((v843 & 0x8000u) == 0)
								break;
							if ((signed __int16)v845 > 0)
							{
								if (v845 > x_DWORD_DE564)
									v845 = x_DWORD_DE564;
								v1210 = v845;
								v847 = (unsigned __int16)-(signed __int16)v843;
								v848 = v847;
								v850 = __ROL4__(*((x_DWORD *)v842 + 3) + v1135 * v847, 16);
								BYTE1(v844) = v850;
								v849 = *((x_DWORD *)v842 + 2) + v1124 * v847;
								LOWORD(v850) = v849;
								v843 = v849 >> 8;
								LOBYTE(v844) = BYTE1(v843);
								v851 = __ROL4__(*((x_DWORD *)v842 + 4) + v1146 * v848, 16);
								v843 = (unsigned __int16)v843;
							LABEL_1011:
								v1286 = v842;
								v852 = x_DWORD_DE55C;
								while (1)
								{
									LOBYTE(v843) = *(x_BYTE *)(v844 + v852);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v850);
									LOWORD(v850) = v1124 + v850;
									BYTE1(v843) = v851;
									LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
									LOBYTE(v843) = x_BYTE_F6EE0_tables[v843];
									v180 = __CFADD__(v1177, v850);
									v853 = v1177 + v850;
									BYTE1(v843) = *v846;
									BYTE1(v844) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1186, v851);
									v854 = v1186 + v851;
									*v846 = x_BYTE_FAEE0[v843];
									LOBYTE(v854) = BYTE2(v1146) + v180 + v854;
									v1211 = v1210 - 1;
									if (!v1211)
										break;
									LOBYTE(v843) = *(x_BYTE *)(v844 + v852);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v853);
									LOWORD(v853) = v1124 + v853;
									BYTE1(v843) = v854;
									LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
									LOBYTE(v843) = x_BYTE_F6EE0_tables[v843];
									v180 = __CFADD__(v1177, v853);
									v855 = v1177 + v853;
									BYTE1(v843) = v846[1];
									BYTE1(v844) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1186, v854);
									v856 = v1186 + v854;
									v846[1] = x_BYTE_FAEE0[v843];
									LOBYTE(v856) = BYTE2(v1146) + v180 + v856;
									v1212 = v1211 - 1;
									if (!v1212)
										break;
									LOBYTE(v843) = *(x_BYTE *)(v844 + v852);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v855);
									LOWORD(v855) = v1124 + v855;
									BYTE1(v843) = v856;
									LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
									LOBYTE(v843) = x_BYTE_F6EE0_tables[v843];
									v180 = __CFADD__(v1177, v855);
									v857 = v1177 + v855;
									BYTE1(v843) = v846[2];
									BYTE1(v844) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1186, v856);
									v858 = v1186 + v856;
									v846[2] = x_BYTE_FAEE0[v843];
									LOBYTE(v858) = BYTE2(v1146) + v180 + v858;
									v1213 = v1212 - 1;
									if (!v1213)
										break;
									LOBYTE(v843) = *(x_BYTE *)(v844 + v852);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v857);
									LOWORD(v857) = v1124 + v857;
									BYTE1(v843) = v858;
									LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
									LOBYTE(v843) = x_BYTE_F6EE0_tables[v843];
									v180 = __CFADD__(v1177, v857);
									v859 = v1177 + v857;
									BYTE1(v843) = v846[3];
									BYTE1(v844) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1186, v858);
									v860 = v1186 + v858;
									v846[3] = x_BYTE_FAEE0[v843];
									LOBYTE(v860) = BYTE2(v1146) + v180 + v860;
									v1214 = v1213 - 1;
									if (!v1214)
										break;
									LOBYTE(v843) = *(x_BYTE *)(v844 + v852);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v859);
									LOWORD(v859) = v1124 + v859;
									BYTE1(v843) = v860;
									LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
									LOBYTE(v843) = x_BYTE_F6EE0_tables[v843];
									v180 = __CFADD__(v1177, v859);
									v861 = v1177 + v859;
									BYTE1(v843) = v846[4];
									BYTE1(v844) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1186, v860);
									v862 = v1186 + v860;
									v846[4] = x_BYTE_FAEE0[v843];
									LOBYTE(v862) = BYTE2(v1146) + v180 + v862;
									v1215 = v1214 - 1;
									if (!v1215)
										break;
									LOBYTE(v843) = *(x_BYTE *)(v844 + v852);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v861);
									LOWORD(v861) = v1124 + v861;
									BYTE1(v843) = v862;
									LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
									LOBYTE(v843) = x_BYTE_F6EE0_tables[v843];
									v180 = __CFADD__(v1177, v861);
									v863 = v1177 + v861;
									BYTE1(v843) = v846[5];
									BYTE1(v844) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1186, v862);
									v864 = v1186 + v862;
									v846[5] = x_BYTE_FAEE0[v843];
									LOBYTE(v864) = BYTE2(v1146) + v180 + v864;
									v1216 = v1215 - 1;
									if (!v1216)
										break;
									LOBYTE(v843) = *(x_BYTE *)(v844 + v852);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v863);
									LOWORD(v863) = v1124 + v863;
									BYTE1(v843) = v864;
									LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
									LOBYTE(v843) = x_BYTE_F6EE0_tables[v843];
									v180 = __CFADD__(v1177, v863);
									v865 = v1177 + v863;
									BYTE1(v843) = v846[6];
									BYTE1(v844) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1186, v864);
									v866 = v1186 + v864;
									v846[6] = x_BYTE_FAEE0[v843];
									LOBYTE(v866) = BYTE2(v1146) + v180 + v866;
									v1217 = v1216 - 1;
									if (!v1217)
										break;
									LOBYTE(v843) = *(x_BYTE *)(v844 + v852);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v865);
									LOWORD(v865) = v1124 + v865;
									BYTE1(v843) = v866;
									LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
									LOBYTE(v843) = x_BYTE_F6EE0_tables[v843];
									v180 = __CFADD__(v1177, v865);
									v867 = v1177 + v865;
									BYTE1(v843) = v846[7];
									BYTE1(v844) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1186, v866);
									v868 = v1186 + v866;
									v846[7] = x_BYTE_FAEE0[v843];
									LOBYTE(v868) = BYTE2(v1146) + v180 + v868;
									v1218 = v1217 - 1;
									if (!v1218)
										break;
									LOBYTE(v843) = *(x_BYTE *)(v844 + v852);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v867);
									LOWORD(v867) = v1124 + v867;
									BYTE1(v843) = v868;
									LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
									LOBYTE(v843) = x_BYTE_F6EE0_tables[v843];
									v180 = __CFADD__(v1177, v867);
									v869 = v1177 + v867;
									BYTE1(v843) = v846[8];
									BYTE1(v844) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1186, v868);
									v870 = v1186 + v868;
									v846[8] = x_BYTE_FAEE0[v843];
									LOBYTE(v870) = BYTE2(v1146) + v180 + v870;
									v1219 = v1218 - 1;
									if (!v1219)
										break;
									LOBYTE(v843) = *(x_BYTE *)(v844 + v852);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v869);
									LOWORD(v869) = v1124 + v869;
									BYTE1(v843) = v870;
									LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
									LOBYTE(v843) = x_BYTE_F6EE0_tables[v843];
									v180 = __CFADD__(v1177, v869);
									v871 = v1177 + v869;
									BYTE1(v843) = v846[9];
									BYTE1(v844) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1186, v870);
									v872 = v1186 + v870;
									v846[9] = x_BYTE_FAEE0[v843];
									LOBYTE(v872) = BYTE2(v1146) + v180 + v872;
									v1220 = v1219 - 1;
									if (!v1220)
										break;
									LOBYTE(v843) = *(x_BYTE *)(v844 + v852);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v871);
									LOWORD(v871) = v1124 + v871;
									BYTE1(v843) = v872;
									LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
									LOBYTE(v843) = x_BYTE_F6EE0_tables[v843];
									v180 = __CFADD__(v1177, v871);
									v873 = v1177 + v871;
									BYTE1(v843) = v846[10];
									BYTE1(v844) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1186, v872);
									v874 = v1186 + v872;
									v846[10] = x_BYTE_FAEE0[v843];
									LOBYTE(v874) = BYTE2(v1146) + v180 + v874;
									v1221 = v1220 - 1;
									if (!v1221)
										break;
									LOBYTE(v843) = *(x_BYTE *)(v844 + v852);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v873);
									LOWORD(v873) = v1124 + v873;
									BYTE1(v843) = v874;
									LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
									LOBYTE(v843) = x_BYTE_F6EE0_tables[v843];
									v180 = __CFADD__(v1177, v873);
									v875 = v1177 + v873;
									BYTE1(v843) = v846[11];
									BYTE1(v844) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1186, v874);
									v876 = v1186 + v874;
									v846[11] = x_BYTE_FAEE0[v843];
									LOBYTE(v876) = BYTE2(v1146) + v180 + v876;
									v1222 = v1221 - 1;
									if (!v1222)
										break;
									LOBYTE(v843) = *(x_BYTE *)(v844 + v852);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v875);
									LOWORD(v875) = v1124 + v875;
									BYTE1(v843) = v876;
									LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
									LOBYTE(v843) = x_BYTE_F6EE0_tables[v843];
									v180 = __CFADD__(v1177, v875);
									v877 = v1177 + v875;
									BYTE1(v843) = v846[12];
									BYTE1(v844) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1186, v876);
									v878 = v1186 + v876;
									v846[12] = x_BYTE_FAEE0[v843];
									LOBYTE(v878) = BYTE2(v1146) + v180 + v878;
									v1223 = v1222 - 1;
									if (!v1223)
										break;
									LOBYTE(v843) = *(x_BYTE *)(v844 + v852);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v877);
									LOWORD(v877) = v1124 + v877;
									BYTE1(v843) = v878;
									LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
									LOBYTE(v843) = x_BYTE_F6EE0_tables[v843];
									v180 = __CFADD__(v1177, v877);
									v879 = v1177 + v877;
									BYTE1(v843) = v846[13];
									BYTE1(v844) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1186, v878);
									v880 = v1186 + v878;
									v846[13] = x_BYTE_FAEE0[v843];
									LOBYTE(v880) = BYTE2(v1146) + v180 + v880;
									v1224 = v1223 - 1;
									if (!v1224)
										break;
									LOBYTE(v843) = *(x_BYTE *)(v844 + v852);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v879);
									LOWORD(v879) = v1124 + v879;
									BYTE1(v843) = v880;
									LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
									LOBYTE(v843) = x_BYTE_F6EE0_tables[v843];
									v180 = __CFADD__(v1177, v879);
									v881 = v1177 + v879;
									BYTE1(v843) = v846[14];
									BYTE1(v844) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1186, v880);
									v882 = v1186 + v880;
									v846[14] = x_BYTE_FAEE0[v843];
									LOBYTE(v882) = BYTE2(v1146) + v180 + v882;
									v1225 = v1224 - 1;
									if (!v1225)
										break;
									LOBYTE(v843) = *(x_BYTE *)(v844 + v852);
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v881);
									LOWORD(v881) = v1124 + v881;
									BYTE1(v843) = v882;
									LOBYTE(v844) = BYTE2(v1124) + v180 + v844;
									LOBYTE(v843) = x_BYTE_F6EE0_tables[v843];
									v180 = __CFADD__(v1177, v881);
									v850 = v1177 + v881;
									BYTE1(v843) = v846[15];
									BYTE1(v844) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1186, v882);
									v851 = v1186 + v882;
									v846[15] = x_BYTE_FAEE0[v843];
									LOBYTE(v851) = BYTE2(v1146) + v180 + v851;
									v1210 = v1225 - 1;
									if (!v1210)
										break;
									v846 += 16;
								}
								v842 = v1286;
							}
						LABEL_1030:
							v842 += 10;
							if (!--v1123)
								return;
						}
						if (v845 > x_DWORD_DE564)
							v845 = x_DWORD_DE564;
						v18 = __OFSUB__((x_WORD)v845, (x_WORD)v843);
						LOWORD(v845) = v845 - v843;
						if ((unsigned __int8)(((v845 & 0x8000u) != 0) ^ v18) | ((x_WORD)v845 == 0))
							goto LABEL_1030;
						v846 += v843;
						v850 = __ROL4__(*((x_DWORD *)v842 + 3), 16);
						BYTE1(v844) = v850;
						LOWORD(v850) = v842[4];
						LOBYTE(v844) = *((x_BYTE *)v842 + 10);
						v1210 = v845;
						v851 = __ROL4__(*((x_DWORD *)v842 + 4), 16);
						goto LABEL_1011;
					case 0x16:
						v883 = (unsigned __int16 *)&unk_DE56C;
						v1178 = v1135 << 16;
						HIWORD(v884) = 0;
						HIWORD(v885) = 0;
						while (1)
						{
							LOWORD(v884) = v883[1];
							v886 = v883[3];
							v887 = (x_BYTE *)(x_DWORD_DE560 + v1102);
							v1102 += x_DWORD_DE560;
							if ((v884 & 0x8000u) == 0)
								break;
							if ((signed __int16)v886 > 0)
							{
								v888 = (unsigned __int16)-(signed __int16)v884;
								v890 = __ROL4__(*((x_DWORD *)v883 + 3) + v1135 * v888, 16);
								BYTE1(v885) = v890;
								v889 = *((x_DWORD *)v883 + 2) + v1124 * v888;
								LOWORD(v890) = v889;
								v891 = v889 >> 8;
								LOBYTE(v885) = BYTE1(v891);
								if (v886 > x_DWORD_DE564)
									LOWORD(v886) = x_DWORD_DE564;
								v884 = (unsigned __int16)v891;
							LABEL_1042:
								v1287 = v883;
								v892 = x_DWORD_DE55C;
								while (1)
								{
									BYTE1(v884) = *(x_BYTE *)(v885 + v892);
									if (BYTE1(v884))
									{
										LOBYTE(v884) = *v887;
										*v887 = x_BYTE_FAEE0[v884];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v890);
									LOWORD(v890) = v1124 + v890;
									LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
									v180 = __CFADD__(v1178, v890);
									v893 = v1178 + v890;
									BYTE1(v885) += BYTE2(v1135) + v180;
									v894 = v886 - 1;
									if (!v894)
										break;
									BYTE1(v884) = *(x_BYTE *)(v885 + v892);
									if (BYTE1(v884))
									{
										LOBYTE(v884) = v887[1];
										v887[1] = x_BYTE_FAEE0[v884];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v893);
									LOWORD(v893) = v1124 + v893;
									LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
									v180 = __CFADD__(v1178, v893);
									v895 = v1178 + v893;
									BYTE1(v885) += BYTE2(v1135) + v180;
									v896 = v894 - 1;
									if (!v896)
										break;
									BYTE1(v884) = *(x_BYTE *)(v885 + v892);
									if (BYTE1(v884))
									{
										LOBYTE(v884) = v887[2];
										v887[2] = x_BYTE_FAEE0[v884];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v895);
									LOWORD(v895) = v1124 + v895;
									LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
									v180 = __CFADD__(v1178, v895);
									v897 = v1178 + v895;
									BYTE1(v885) += BYTE2(v1135) + v180;
									v898 = v896 - 1;
									if (!v898)
										break;
									BYTE1(v884) = *(x_BYTE *)(v885 + v892);
									if (BYTE1(v884))
									{
										LOBYTE(v884) = v887[3];
										v887[3] = x_BYTE_FAEE0[v884];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v897);
									LOWORD(v897) = v1124 + v897;
									LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
									v180 = __CFADD__(v1178, v897);
									v899 = v1178 + v897;
									BYTE1(v885) += BYTE2(v1135) + v180;
									v900 = v898 - 1;
									if (!v900)
										break;
									BYTE1(v884) = *(x_BYTE *)(v885 + v892);
									if (BYTE1(v884))
									{
										LOBYTE(v884) = v887[4];
										v887[4] = x_BYTE_FAEE0[v884];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v899);
									LOWORD(v899) = v1124 + v899;
									LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
									v180 = __CFADD__(v1178, v899);
									v901 = v1178 + v899;
									BYTE1(v885) += BYTE2(v1135) + v180;
									v902 = v900 - 1;
									if (!v902)
										break;
									BYTE1(v884) = *(x_BYTE *)(v885 + v892);
									if (BYTE1(v884))
									{
										LOBYTE(v884) = v887[5];
										v887[5] = x_BYTE_FAEE0[v884];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v901);
									LOWORD(v901) = v1124 + v901;
									LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
									v180 = __CFADD__(v1178, v901);
									v903 = v1178 + v901;
									BYTE1(v885) += BYTE2(v1135) + v180;
									v904 = v902 - 1;
									if (!v904)
										break;
									BYTE1(v884) = *(x_BYTE *)(v885 + v892);
									if (BYTE1(v884))
									{
										LOBYTE(v884) = v887[6];
										v887[6] = x_BYTE_FAEE0[v884];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v903);
									LOWORD(v903) = v1124 + v903;
									LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
									v180 = __CFADD__(v1178, v903);
									v905 = v1178 + v903;
									BYTE1(v885) += BYTE2(v1135) + v180;
									v906 = v904 - 1;
									if (!v906)
										break;
									BYTE1(v884) = *(x_BYTE *)(v885 + v892);
									if (BYTE1(v884))
									{
										LOBYTE(v884) = v887[7];
										v887[7] = x_BYTE_FAEE0[v884];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v905);
									LOWORD(v905) = v1124 + v905;
									LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
									v180 = __CFADD__(v1178, v905);
									v907 = v1178 + v905;
									BYTE1(v885) += BYTE2(v1135) + v180;
									v908 = v906 - 1;
									if (!v908)
										break;
									BYTE1(v884) = *(x_BYTE *)(v885 + v892);
									if (BYTE1(v884))
									{
										LOBYTE(v884) = v887[8];
										v887[8] = x_BYTE_FAEE0[v884];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v907);
									LOWORD(v907) = v1124 + v907;
									LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
									v180 = __CFADD__(v1178, v907);
									v909 = v1178 + v907;
									BYTE1(v885) += BYTE2(v1135) + v180;
									v910 = v908 - 1;
									if (!v910)
										break;
									BYTE1(v884) = *(x_BYTE *)(v885 + v892);
									if (BYTE1(v884))
									{
										LOBYTE(v884) = v887[9];
										v887[9] = x_BYTE_FAEE0[v884];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v909);
									LOWORD(v909) = v1124 + v909;
									LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
									v180 = __CFADD__(v1178, v909);
									v911 = v1178 + v909;
									BYTE1(v885) += BYTE2(v1135) + v180;
									v912 = v910 - 1;
									if (!v912)
										break;
									BYTE1(v884) = *(x_BYTE *)(v885 + v892);
									if (BYTE1(v884))
									{
										LOBYTE(v884) = v887[10];
										v887[10] = x_BYTE_FAEE0[v884];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v911);
									LOWORD(v911) = v1124 + v911;
									LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
									v180 = __CFADD__(v1178, v911);
									v913 = v1178 + v911;
									BYTE1(v885) += BYTE2(v1135) + v180;
									v914 = v912 - 1;
									if (!v914)
										break;
									BYTE1(v884) = *(x_BYTE *)(v885 + v892);
									if (BYTE1(v884))
									{
										LOBYTE(v884) = v887[11];
										v887[11] = x_BYTE_FAEE0[v884];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v913);
									LOWORD(v913) = v1124 + v913;
									LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
									v180 = __CFADD__(v1178, v913);
									v915 = v1178 + v913;
									BYTE1(v885) += BYTE2(v1135) + v180;
									v916 = v914 - 1;
									if (!v916)
										break;
									BYTE1(v884) = *(x_BYTE *)(v885 + v892);
									if (BYTE1(v884))
									{
										LOBYTE(v884) = v887[12];
										v887[12] = x_BYTE_FAEE0[v884];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v915);
									LOWORD(v915) = v1124 + v915;
									LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
									v180 = __CFADD__(v1178, v915);
									v917 = v1178 + v915;
									BYTE1(v885) += BYTE2(v1135) + v180;
									v918 = v916 - 1;
									if (!v918)
										break;
									BYTE1(v884) = *(x_BYTE *)(v885 + v892);
									if (BYTE1(v884))
									{
										LOBYTE(v884) = v887[13];
										v887[13] = x_BYTE_FAEE0[v884];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v917);
									LOWORD(v917) = v1124 + v917;
									LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
									v180 = __CFADD__(v1178, v917);
									v919 = v1178 + v917;
									BYTE1(v885) += BYTE2(v1135) + v180;
									v920 = v918 - 1;
									if (!v920)
										break;
									BYTE1(v884) = *(x_BYTE *)(v885 + v892);
									if (BYTE1(v884))
									{
										LOBYTE(v884) = v887[14];
										v887[14] = x_BYTE_FAEE0[v884];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v919);
									LOWORD(v919) = v1124 + v919;
									LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
									v180 = __CFADD__(v1178, v919);
									v921 = v1178 + v919;
									BYTE1(v885) += BYTE2(v1135) + v180;
									v922 = v920 - 1;
									if (!v922)
										break;
									BYTE1(v884) = *(x_BYTE *)(v885 + v892);
									if (BYTE1(v884))
									{
										LOBYTE(v884) = v887[15];
										v887[15] = x_BYTE_FAEE0[v884];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v921);
									LOWORD(v921) = v1124 + v921;
									LOBYTE(v885) = BYTE2(v1124) + v180 + v885;
									v180 = __CFADD__(v1178, v921);
									v890 = v1178 + v921;
									BYTE1(v885) += BYTE2(v1135) + v180;
									LOWORD(v886) = v922 - 1;
									if (!(x_WORD)v886)
										break;
									v887 += 16;
								}
								v883 = v1287;
							}
						LABEL_1093:
							v883 += 10;
							if (!--v1123)
								return;
						}
						if (v886 > x_DWORD_DE564)
							LOWORD(v886) = x_DWORD_DE564;
						v18 = __OFSUB__((x_WORD)v886, (x_WORD)v884);
						LOWORD(v886) = v886 - v884;
						if ((unsigned __int8)(((v886 & 0x8000u) != 0) ^ v18) | ((x_WORD)v886 == 0))
							goto LABEL_1093;
						v887 += v884;
						v890 = __ROL4__(*((x_DWORD *)v883 + 3), 16);
						BYTE1(v885) = v890;
						LOWORD(v890) = v883[4];
						LOBYTE(v885) = *((x_BYTE *)v883 + 10);
						goto LABEL_1042;
					case 0x17:
						v923 = (unsigned __int16 *)&unk_DE56C;
						v1179 = v1135 << 16;
						HIWORD(v924) = 0;
						HIWORD(v925) = 0;
						while (1)
						{
							LOWORD(v924) = v923[1];
							v926 = v923[3];
							v927 = (x_BYTE *)(x_DWORD_DE560 + v1102);
							v1102 += x_DWORD_DE560;
							if ((v924 & 0x8000u) == 0)
								break;
							if ((signed __int16)v926 > 0)
							{
								v928 = (unsigned __int16)-(signed __int16)v924;
								v930 = __ROL4__(*((x_DWORD *)v923 + 3) + v1135 * v928, 16);
								BYTE1(v925) = v930;
								v929 = *((x_DWORD *)v923 + 2) + v1124 * v928;
								LOWORD(v930) = v929;
								v931 = v929 >> 8;
								LOBYTE(v925) = BYTE1(v931);
								if (v926 > x_DWORD_DE564)
									LOWORD(v926) = x_DWORD_DE564;
								v924 = (unsigned __int16)v931;
							LABEL_1105:
								v1288 = v923;
								v932 = x_DWORD_DE55C;
								while (1)
								{
									LOBYTE(v924) = *(x_BYTE *)(v925 + v932);
									if ((x_BYTE)v924)
									{
										BYTE1(v924) = *v927;
										*v927 = x_BYTE_FAEE0[v924];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v930);
									LOWORD(v930) = v1124 + v930;
									LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
									v180 = __CFADD__(v1179, v930);
									v933 = v1179 + v930;
									BYTE1(v925) += BYTE2(v1135) + v180;
									v934 = v926 - 1;
									if (!v934)
										break;
									LOBYTE(v924) = *(x_BYTE *)(v925 + v932);
									if ((x_BYTE)v924)
									{
										BYTE1(v924) = v927[1];
										v927[1] = x_BYTE_FAEE0[v924];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v933);
									LOWORD(v933) = v1124 + v933;
									LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
									v180 = __CFADD__(v1179, v933);
									v935 = v1179 + v933;
									BYTE1(v925) += BYTE2(v1135) + v180;
									v936 = v934 - 1;
									if (!v936)
										break;
									LOBYTE(v924) = *(x_BYTE *)(v925 + v932);
									if ((x_BYTE)v924)
									{
										BYTE1(v924) = v927[2];
										v927[2] = x_BYTE_FAEE0[v924];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v935);
									LOWORD(v935) = v1124 + v935;
									LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
									v180 = __CFADD__(v1179, v935);
									v937 = v1179 + v935;
									BYTE1(v925) += BYTE2(v1135) + v180;
									v938 = v936 - 1;
									if (!v938)
										break;
									LOBYTE(v924) = *(x_BYTE *)(v925 + v932);
									if ((x_BYTE)v924)
									{
										BYTE1(v924) = v927[3];
										v927[3] = x_BYTE_FAEE0[v924];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v937);
									LOWORD(v937) = v1124 + v937;
									LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
									v180 = __CFADD__(v1179, v937);
									v939 = v1179 + v937;
									BYTE1(v925) += BYTE2(v1135) + v180;
									v940 = v938 - 1;
									if (!v940)
										break;
									LOBYTE(v924) = *(x_BYTE *)(v925 + v932);
									if ((x_BYTE)v924)
									{
										BYTE1(v924) = v927[4];
										v927[4] = x_BYTE_FAEE0[v924];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v939);
									LOWORD(v939) = v1124 + v939;
									LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
									v180 = __CFADD__(v1179, v939);
									v941 = v1179 + v939;
									BYTE1(v925) += BYTE2(v1135) + v180;
									v942 = v940 - 1;
									if (!v942)
										break;
									LOBYTE(v924) = *(x_BYTE *)(v925 + v932);
									if ((x_BYTE)v924)
									{
										BYTE1(v924) = v927[5];
										v927[5] = x_BYTE_FAEE0[v924];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v941);
									LOWORD(v941) = v1124 + v941;
									LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
									v180 = __CFADD__(v1179, v941);
									v943 = v1179 + v941;
									BYTE1(v925) += BYTE2(v1135) + v180;
									v944 = v942 - 1;
									if (!v944)
										break;
									LOBYTE(v924) = *(x_BYTE *)(v925 + v932);
									if ((x_BYTE)v924)
									{
										BYTE1(v924) = v927[6];
										v927[6] = x_BYTE_FAEE0[v924];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v943);
									LOWORD(v943) = v1124 + v943;
									LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
									v180 = __CFADD__(v1179, v943);
									v945 = v1179 + v943;
									BYTE1(v925) += BYTE2(v1135) + v180;
									v946 = v944 - 1;
									if (!v946)
										break;
									LOBYTE(v924) = *(x_BYTE *)(v925 + v932);
									if ((x_BYTE)v924)
									{
										BYTE1(v924) = v927[7];
										v927[7] = x_BYTE_FAEE0[v924];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v945);
									LOWORD(v945) = v1124 + v945;
									LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
									v180 = __CFADD__(v1179, v945);
									v947 = v1179 + v945;
									BYTE1(v925) += BYTE2(v1135) + v180;
									v948 = v946 - 1;
									if (!v948)
										break;
									LOBYTE(v924) = *(x_BYTE *)(v925 + v932);
									if ((x_BYTE)v924)
									{
										BYTE1(v924) = v927[8];
										v927[8] = x_BYTE_FAEE0[v924];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v947);
									LOWORD(v947) = v1124 + v947;
									LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
									v180 = __CFADD__(v1179, v947);
									v949 = v1179 + v947;
									BYTE1(v925) += BYTE2(v1135) + v180;
									v950 = v948 - 1;
									if (!v950)
										break;
									LOBYTE(v924) = *(x_BYTE *)(v925 + v932);
									if ((x_BYTE)v924)
									{
										BYTE1(v924) = v927[9];
										v927[9] = x_BYTE_FAEE0[v924];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v949);
									LOWORD(v949) = v1124 + v949;
									LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
									v180 = __CFADD__(v1179, v949);
									v951 = v1179 + v949;
									BYTE1(v925) += BYTE2(v1135) + v180;
									v952 = v950 - 1;
									if (!v952)
										break;
									LOBYTE(v924) = *(x_BYTE *)(v925 + v932);
									if ((x_BYTE)v924)
									{
										BYTE1(v924) = v927[10];
										v927[10] = x_BYTE_FAEE0[v924];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v951);
									LOWORD(v951) = v1124 + v951;
									LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
									v180 = __CFADD__(v1179, v951);
									v953 = v1179 + v951;
									BYTE1(v925) += BYTE2(v1135) + v180;
									v954 = v952 - 1;
									if (!v954)
										break;
									LOBYTE(v924) = *(x_BYTE *)(v925 + v932);
									if ((x_BYTE)v924)
									{
										BYTE1(v924) = v927[11];
										v927[11] = x_BYTE_FAEE0[v924];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v953);
									LOWORD(v953) = v1124 + v953;
									LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
									v180 = __CFADD__(v1179, v953);
									v955 = v1179 + v953;
									BYTE1(v925) += BYTE2(v1135) + v180;
									v956 = v954 - 1;
									if (!v956)
										break;
									LOBYTE(v924) = *(x_BYTE *)(v925 + v932);
									if ((x_BYTE)v924)
									{
										BYTE1(v924) = v927[12];
										v927[12] = x_BYTE_FAEE0[v924];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v955);
									LOWORD(v955) = v1124 + v955;
									LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
									v180 = __CFADD__(v1179, v955);
									v957 = v1179 + v955;
									BYTE1(v925) += BYTE2(v1135) + v180;
									v958 = v956 - 1;
									if (!v958)
										break;
									LOBYTE(v924) = *(x_BYTE *)(v925 + v932);
									if ((x_BYTE)v924)
									{
										BYTE1(v924) = v927[13];
										v927[13] = x_BYTE_FAEE0[v924];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v957);
									LOWORD(v957) = v1124 + v957;
									LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
									v180 = __CFADD__(v1179, v957);
									v959 = v1179 + v957;
									BYTE1(v925) += BYTE2(v1135) + v180;
									v960 = v958 - 1;
									if (!v960)
										break;
									LOBYTE(v924) = *(x_BYTE *)(v925 + v932);
									if ((x_BYTE)v924)
									{
										BYTE1(v924) = v927[14];
										v927[14] = x_BYTE_FAEE0[v924];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v959);
									LOWORD(v959) = v1124 + v959;
									LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
									v180 = __CFADD__(v1179, v959);
									v961 = v1179 + v959;
									BYTE1(v925) += BYTE2(v1135) + v180;
									v962 = v960 - 1;
									if (!v962)
										break;
									LOBYTE(v924) = *(x_BYTE *)(v925 + v932);
									if ((x_BYTE)v924)
									{
										BYTE1(v924) = v927[15];
										v927[15] = x_BYTE_FAEE0[v924];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v961);
									LOWORD(v961) = v1124 + v961;
									LOBYTE(v925) = BYTE2(v1124) + v180 + v925;
									v180 = __CFADD__(v1179, v961);
									v930 = v1179 + v961;
									BYTE1(v925) += BYTE2(v1135) + v180;
									LOWORD(v926) = v962 - 1;
									if (!(x_WORD)v926)
										break;
									v927 += 16;
								}
								v923 = v1288;
							}
						LABEL_1156:
							v923 += 10;
							if (!--v1123)
								return;
						}
						if (v926 > x_DWORD_DE564)
							LOWORD(v926) = x_DWORD_DE564;
						v18 = __OFSUB__((x_WORD)v926, (x_WORD)v924);
						LOWORD(v926) = v926 - v924;
						if ((unsigned __int8)(((v926 & 0x8000u) != 0) ^ v18) | ((x_WORD)v926 == 0))
							goto LABEL_1156;
						v927 += v924;
						v930 = __ROL4__(*((x_DWORD *)v923 + 3), 16);
						BYTE1(v925) = v930;
						LOWORD(v930) = v923[4];
						LOBYTE(v925) = *((x_BYTE *)v923 + 10);
						goto LABEL_1105;
					case 0x18:
						v963 = (unsigned __int16 *)&unk_DE56C;
						v1180 = v1135 << 16;
						v1187 = v1146 << 16;
						HIWORD(v964) = 0;
						HIWORD(v965) = 0;
						while (1)
						{
							LOWORD(v964) = v963[1];
							v966 = v963[3];
							v967 = (x_BYTE *)(x_DWORD_DE560 + v1102);
							v1102 += x_DWORD_DE560;
							if ((v964 & 0x8000u) == 0)
								break;
							if ((signed __int16)v966 > 0)
							{
								if (v966 > x_DWORD_DE564)
									v966 = x_DWORD_DE564;
								v1226 = v966;
								v968 = (unsigned __int16)-(signed __int16)v964;
								v969 = v968;
								v971 = __ROL4__(*((x_DWORD *)v963 + 3) + v1135 * v968, 16);
								BYTE1(v965) = v971;
								v970 = *((x_DWORD *)v963 + 2) + v1124 * v968;
								LOWORD(v971) = v970;
								v964 = v970 >> 8;
								LOBYTE(v965) = BYTE1(v964);
								v972 = __ROL4__(*((x_DWORD *)v963 + 4) + v1146 * v969, 16);
								v964 = (unsigned __int16)v964;
							LABEL_1168:
								v1289 = v963;
								v973 = x_DWORD_DE55C;
								while (1)
								{
									LOBYTE(v964) = *(x_BYTE *)(v965 + v973);
									if ((x_BYTE)v964)
									{
										BYTE1(v964) = v972;
										BYTE1(v964) = x_BYTE_F6EE0_tables[v964];
										LOBYTE(v964) = *v967;
										*v967 = x_BYTE_FAEE0[v964];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v971);
									LOWORD(v971) = v1124 + v971;
									LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
									v180 = __CFADD__(v1180, v971);
									v974 = v1180 + v971;
									BYTE1(v965) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1187, v972);
									v975 = v1187 + v972;
									LOBYTE(v975) = BYTE2(v1146) + v180 + v975;
									v1227 = v1226 - 1;
									if (!v1227)
										break;
									LOBYTE(v964) = *(x_BYTE *)(v965 + v973);
									if ((x_BYTE)v964)
									{
										BYTE1(v964) = v975;
										BYTE1(v964) = x_BYTE_F6EE0_tables[v964];
										LOBYTE(v964) = v967[1];
										v967[1] = x_BYTE_FAEE0[v964];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v974);
									LOWORD(v974) = v1124 + v974;
									LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
									v180 = __CFADD__(v1180, v974);
									v976 = v1180 + v974;
									BYTE1(v965) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1187, v975);
									v977 = v1187 + v975;
									LOBYTE(v977) = BYTE2(v1146) + v180 + v977;
									v1228 = v1227 - 1;
									if (!v1228)
										break;
									LOBYTE(v964) = *(x_BYTE *)(v965 + v973);
									if ((x_BYTE)v964)
									{
										BYTE1(v964) = v977;
										BYTE1(v964) = x_BYTE_F6EE0_tables[v964];
										LOBYTE(v964) = v967[2];
										v967[2] = x_BYTE_FAEE0[v964];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v976);
									LOWORD(v976) = v1124 + v976;
									LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
									v180 = __CFADD__(v1180, v976);
									v978 = v1180 + v976;
									BYTE1(v965) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1187, v977);
									v979 = v1187 + v977;
									LOBYTE(v979) = BYTE2(v1146) + v180 + v979;
									v1229 = v1228 - 1;
									if (!v1229)
										break;
									LOBYTE(v964) = *(x_BYTE *)(v965 + v973);
									if ((x_BYTE)v964)
									{
										BYTE1(v964) = v979;
										BYTE1(v964) = x_BYTE_F6EE0_tables[v964];
										LOBYTE(v964) = v967[3];
										v967[3] = x_BYTE_FAEE0[v964];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v978);
									LOWORD(v978) = v1124 + v978;
									LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
									v180 = __CFADD__(v1180, v978);
									v980 = v1180 + v978;
									BYTE1(v965) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1187, v979);
									v981 = v1187 + v979;
									LOBYTE(v981) = BYTE2(v1146) + v180 + v981;
									v1230 = v1229 - 1;
									if (!v1230)
										break;
									LOBYTE(v964) = *(x_BYTE *)(v965 + v973);
									if ((x_BYTE)v964)
									{
										BYTE1(v964) = v981;
										BYTE1(v964) = x_BYTE_F6EE0_tables[v964];
										LOBYTE(v964) = v967[4];
										v967[4] = x_BYTE_FAEE0[v964];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v980);
									LOWORD(v980) = v1124 + v980;
									LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
									v180 = __CFADD__(v1180, v980);
									v982 = v1180 + v980;
									BYTE1(v965) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1187, v981);
									v983 = v1187 + v981;
									LOBYTE(v983) = BYTE2(v1146) + v180 + v983;
									v1231 = v1230 - 1;
									if (!v1231)
										break;
									LOBYTE(v964) = *(x_BYTE *)(v965 + v973);
									if ((x_BYTE)v964)
									{
										BYTE1(v964) = v983;
										BYTE1(v964) = x_BYTE_F6EE0_tables[v964];
										LOBYTE(v964) = v967[5];
										v967[5] = x_BYTE_FAEE0[v964];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v982);
									LOWORD(v982) = v1124 + v982;
									LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
									v180 = __CFADD__(v1180, v982);
									v984 = v1180 + v982;
									BYTE1(v965) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1187, v983);
									v985 = v1187 + v983;
									LOBYTE(v985) = BYTE2(v1146) + v180 + v985;
									v1232 = v1231 - 1;
									if (!v1232)
										break;
									LOBYTE(v964) = *(x_BYTE *)(v965 + v973);
									if ((x_BYTE)v964)
									{
										BYTE1(v964) = v985;
										BYTE1(v964) = x_BYTE_F6EE0_tables[v964];
										LOBYTE(v964) = v967[6];
										v967[6] = x_BYTE_FAEE0[v964];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v984);
									LOWORD(v984) = v1124 + v984;
									LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
									v180 = __CFADD__(v1180, v984);
									v986 = v1180 + v984;
									BYTE1(v965) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1187, v985);
									v987 = v1187 + v985;
									LOBYTE(v987) = BYTE2(v1146) + v180 + v987;
									v1233 = v1232 - 1;
									if (!v1233)
										break;
									LOBYTE(v964) = *(x_BYTE *)(v965 + v973);
									if ((x_BYTE)v964)
									{
										BYTE1(v964) = v987;
										BYTE1(v964) = x_BYTE_F6EE0_tables[v964];
										LOBYTE(v964) = v967[7];
										v967[7] = x_BYTE_FAEE0[v964];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v986);
									LOWORD(v986) = v1124 + v986;
									LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
									v180 = __CFADD__(v1180, v986);
									v988 = v1180 + v986;
									BYTE1(v965) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1187, v987);
									v989 = v1187 + v987;
									LOBYTE(v989) = BYTE2(v1146) + v180 + v989;
									v1234 = v1233 - 1;
									if (!v1234)
										break;
									LOBYTE(v964) = *(x_BYTE *)(v965 + v973);
									if ((x_BYTE)v964)
									{
										BYTE1(v964) = v989;
										BYTE1(v964) = x_BYTE_F6EE0_tables[v964];
										LOBYTE(v964) = v967[8];
										v967[8] = x_BYTE_FAEE0[v964];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v988);
									LOWORD(v988) = v1124 + v988;
									LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
									v180 = __CFADD__(v1180, v988);
									v990 = v1180 + v988;
									BYTE1(v965) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1187, v989);
									v991 = v1187 + v989;
									LOBYTE(v991) = BYTE2(v1146) + v180 + v991;
									v1235 = v1234 - 1;
									if (!v1235)
										break;
									LOBYTE(v964) = *(x_BYTE *)(v965 + v973);
									if ((x_BYTE)v964)
									{
										BYTE1(v964) = v991;
										BYTE1(v964) = x_BYTE_F6EE0_tables[v964];
										LOBYTE(v964) = v967[9];
										v967[9] = x_BYTE_FAEE0[v964];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v990);
									LOWORD(v990) = v1124 + v990;
									LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
									v180 = __CFADD__(v1180, v990);
									v992 = v1180 + v990;
									BYTE1(v965) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1187, v991);
									v993 = v1187 + v991;
									LOBYTE(v993) = BYTE2(v1146) + v180 + v993;
									v1236 = v1235 - 1;
									if (!v1236)
										break;
									LOBYTE(v964) = *(x_BYTE *)(v965 + v973);
									if ((x_BYTE)v964)
									{
										BYTE1(v964) = v993;
										BYTE1(v964) = x_BYTE_F6EE0_tables[v964];
										LOBYTE(v964) = v967[10];
										v967[10] = x_BYTE_FAEE0[v964];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v992);
									LOWORD(v992) = v1124 + v992;
									LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
									v180 = __CFADD__(v1180, v992);
									v994 = v1180 + v992;
									BYTE1(v965) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1187, v993);
									v995 = v1187 + v993;
									LOBYTE(v995) = BYTE2(v1146) + v180 + v995;
									v1237 = v1236 - 1;
									if (!v1237)
										break;
									LOBYTE(v964) = *(x_BYTE *)(v965 + v973);
									if ((x_BYTE)v964)
									{
										BYTE1(v964) = v995;
										BYTE1(v964) = x_BYTE_F6EE0_tables[v964];
										LOBYTE(v964) = v967[11];
										v967[11] = x_BYTE_FAEE0[v964];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v994);
									LOWORD(v994) = v1124 + v994;
									LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
									v180 = __CFADD__(v1180, v994);
									v996 = v1180 + v994;
									BYTE1(v965) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1187, v995);
									v997 = v1187 + v995;
									LOBYTE(v997) = BYTE2(v1146) + v180 + v997;
									v1238 = v1237 - 1;
									if (!v1238)
										break;
									LOBYTE(v964) = *(x_BYTE *)(v965 + v973);
									if ((x_BYTE)v964)
									{
										BYTE1(v964) = v997;
										BYTE1(v964) = x_BYTE_F6EE0_tables[v964];
										LOBYTE(v964) = v967[12];
										v967[12] = x_BYTE_FAEE0[v964];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v996);
									LOWORD(v996) = v1124 + v996;
									LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
									v180 = __CFADD__(v1180, v996);
									v998 = v1180 + v996;
									BYTE1(v965) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1187, v997);
									v999 = v1187 + v997;
									LOBYTE(v999) = BYTE2(v1146) + v180 + v999;
									v1239 = v1238 - 1;
									if (!v1239)
										break;
									LOBYTE(v964) = *(x_BYTE *)(v965 + v973);
									if ((x_BYTE)v964)
									{
										BYTE1(v964) = v999;
										BYTE1(v964) = x_BYTE_F6EE0_tables[v964];
										LOBYTE(v964) = v967[13];
										v967[13] = x_BYTE_FAEE0[v964];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v998);
									LOWORD(v998) = v1124 + v998;
									LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
									v180 = __CFADD__(v1180, v998);
									v1000 = v1180 + v998;
									BYTE1(v965) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1187, v999);
									v1001 = v1187 + v999;
									LOBYTE(v1001) = BYTE2(v1146) + v180 + v1001;
									v1240 = v1239 - 1;
									if (!v1240)
										break;
									LOBYTE(v964) = *(x_BYTE *)(v965 + v973);
									if ((x_BYTE)v964)
									{
										BYTE1(v964) = v1001;
										BYTE1(v964) = x_BYTE_F6EE0_tables[v964];
										LOBYTE(v964) = v967[14];
										v967[14] = x_BYTE_FAEE0[v964];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1000);
									LOWORD(v1000) = v1124 + v1000;
									LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
									v180 = __CFADD__(v1180, v1000);
									v1002 = v1180 + v1000;
									BYTE1(v965) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1187, v1001);
									v1003 = v1187 + v1001;
									LOBYTE(v1003) = BYTE2(v1146) + v180 + v1003;
									v1241 = v1240 - 1;
									if (!v1241)
										break;
									LOBYTE(v964) = *(x_BYTE *)(v965 + v973);
									if ((x_BYTE)v964)
									{
										BYTE1(v964) = v1003;
										BYTE1(v964) = x_BYTE_F6EE0_tables[v964];
										LOBYTE(v964) = v967[15];
										v967[15] = x_BYTE_FAEE0[v964];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1002);
									LOWORD(v1002) = v1124 + v1002;
									LOBYTE(v965) = BYTE2(v1124) + v180 + v965;
									v180 = __CFADD__(v1180, v1002);
									v971 = v1180 + v1002;
									BYTE1(v965) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1187, v1003);
									v972 = v1187 + v1003;
									LOBYTE(v972) = BYTE2(v1146) + v180 + v972;
									v1226 = v1241 - 1;
									if (!v1226)
										break;
									v967 += 16;
								}
								v963 = v1289;
							}
						LABEL_1219:
							v963 += 10;
							if (!--v1123)
								return;
						}
						if (v966 > x_DWORD_DE564)
							v966 = x_DWORD_DE564;
						v18 = __OFSUB__((x_WORD)v966, (x_WORD)v964);
						LOWORD(v966) = v966 - v964;
						if ((unsigned __int8)(((v966 & 0x8000u) != 0) ^ v18) | ((x_WORD)v966 == 0))
							goto LABEL_1219;
						v967 += v964;
						v971 = __ROL4__(*((x_DWORD *)v963 + 3), 16);
						BYTE1(v965) = v971;
						LOWORD(v971) = v963[4];
						LOBYTE(v965) = *((x_BYTE *)v963 + 10);
						v1226 = v966;
						v972 = __ROL4__(*((x_DWORD *)v963 + 4), 16);
						goto LABEL_1168;
					case 0x19:
						v1004 = (unsigned __int16 *)&unk_DE56C;
						v1181 = v1135 << 16;
						v1188 = v1146 << 16;
						HIWORD(v1005) = 0;
						HIWORD(v1006) = 0;
						while (1)
						{
							LOWORD(v1005) = v1004[1];
							v1007 = v1004[3];
							v1008 = (x_BYTE *)(x_DWORD_DE560 + v1102);
							v1102 += x_DWORD_DE560;
							if ((v1005 & 0x8000u) == 0)
								break;
							if ((signed __int16)v1007 > 0)
							{
								if (v1007 > x_DWORD_DE564)
									v1007 = x_DWORD_DE564;
								v1242 = v1007;
								v1009 = (unsigned __int16)-(signed __int16)v1005;
								v1010 = v1009;
								v1012 = __ROL4__(*((x_DWORD *)v1004 + 3) + v1135 * v1009, 16);
								BYTE1(v1006) = v1012;
								v1011 = *((x_DWORD *)v1004 + 2) + v1124 * v1009;
								LOWORD(v1012) = v1011;
								v1005 = v1011 >> 8;
								LOBYTE(v1006) = BYTE1(v1005);
								v1013 = __ROL4__(*((x_DWORD *)v1004 + 4) + v1146 * v1010, 16);
								v1005 = (unsigned __int16)v1005;
							LABEL_1231:
								v1290 = v1004;
								v1014 = x_DWORD_DE55C;
								while (1)
								{
									LOBYTE(v1005) = *(x_BYTE *)(v1006 + v1014);
									if ((x_BYTE)v1005)
									{
										BYTE1(v1005) = v1013;
										LOBYTE(v1005) = x_BYTE_F6EE0_tables[v1005];
										BYTE1(v1005) = *v1008;
										*v1008 = x_BYTE_FAEE0[v1005];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1012);
									LOWORD(v1012) = v1124 + v1012;
									LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
									v180 = __CFADD__(v1181, v1012);
									v1015 = v1181 + v1012;
									BYTE1(v1006) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1188, v1013);
									v1016 = v1188 + v1013;
									LOBYTE(v1016) = BYTE2(v1146) + v180 + v1016;
									v1243 = v1242 - 1;
									if (!v1243)
										break;
									LOBYTE(v1005) = *(x_BYTE *)(v1006 + v1014);
									if ((x_BYTE)v1005)
									{
										BYTE1(v1005) = v1016;
										LOBYTE(v1005) = x_BYTE_F6EE0_tables[v1005];
										BYTE1(v1005) = v1008[1];
										v1008[1] = x_BYTE_FAEE0[v1005];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1015);
									LOWORD(v1015) = v1124 + v1015;
									LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
									v180 = __CFADD__(v1181, v1015);
									v1017 = v1181 + v1015;
									BYTE1(v1006) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1188, v1016);
									v1018 = v1188 + v1016;
									LOBYTE(v1018) = BYTE2(v1146) + v180 + v1018;
									v1244 = v1243 - 1;
									if (!v1244)
										break;
									LOBYTE(v1005) = *(x_BYTE *)(v1006 + v1014);
									if ((x_BYTE)v1005)
									{
										BYTE1(v1005) = v1018;
										LOBYTE(v1005) = x_BYTE_F6EE0_tables[v1005];
										BYTE1(v1005) = v1008[2];
										v1008[2] = x_BYTE_FAEE0[v1005];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1017);
									LOWORD(v1017) = v1124 + v1017;
									LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
									v180 = __CFADD__(v1181, v1017);
									v1019 = v1181 + v1017;
									BYTE1(v1006) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1188, v1018);
									v1020 = v1188 + v1018;
									LOBYTE(v1020) = BYTE2(v1146) + v180 + v1020;
									v1245 = v1244 - 1;
									if (!v1245)
										break;
									LOBYTE(v1005) = *(x_BYTE *)(v1006 + v1014);
									if ((x_BYTE)v1005)
									{
										BYTE1(v1005) = v1020;
										LOBYTE(v1005) = x_BYTE_F6EE0_tables[v1005];
										BYTE1(v1005) = v1008[3];
										v1008[3] = x_BYTE_FAEE0[v1005];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1019);
									LOWORD(v1019) = v1124 + v1019;
									LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
									v180 = __CFADD__(v1181, v1019);
									v1021 = v1181 + v1019;
									BYTE1(v1006) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1188, v1020);
									v1022 = v1188 + v1020;
									LOBYTE(v1022) = BYTE2(v1146) + v180 + v1022;
									v1246 = v1245 - 1;
									if (!v1246)
										break;
									LOBYTE(v1005) = *(x_BYTE *)(v1006 + v1014);
									if ((x_BYTE)v1005)
									{
										BYTE1(v1005) = v1022;
										LOBYTE(v1005) = x_BYTE_F6EE0_tables[v1005];
										BYTE1(v1005) = v1008[4];
										v1008[4] = x_BYTE_FAEE0[v1005];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1021);
									LOWORD(v1021) = v1124 + v1021;
									LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
									v180 = __CFADD__(v1181, v1021);
									v1023 = v1181 + v1021;
									BYTE1(v1006) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1188, v1022);
									v1024 = v1188 + v1022;
									LOBYTE(v1024) = BYTE2(v1146) + v180 + v1024;
									v1247 = v1246 - 1;
									if (!v1247)
										break;
									LOBYTE(v1005) = *(x_BYTE *)(v1006 + v1014);
									if ((x_BYTE)v1005)
									{
										BYTE1(v1005) = v1024;
										LOBYTE(v1005) = x_BYTE_F6EE0_tables[v1005];
										BYTE1(v1005) = v1008[5];
										v1008[5] = x_BYTE_FAEE0[v1005];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1023);
									LOWORD(v1023) = v1124 + v1023;
									LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
									v180 = __CFADD__(v1181, v1023);
									v1025 = v1181 + v1023;
									BYTE1(v1006) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1188, v1024);
									v1026 = v1188 + v1024;
									LOBYTE(v1026) = BYTE2(v1146) + v180 + v1026;
									v1248 = v1247 - 1;
									if (!v1248)
										break;
									LOBYTE(v1005) = *(x_BYTE *)(v1006 + v1014);
									if ((x_BYTE)v1005)
									{
										BYTE1(v1005) = v1026;
										LOBYTE(v1005) = x_BYTE_F6EE0_tables[v1005];
										BYTE1(v1005) = v1008[6];
										v1008[6] = x_BYTE_FAEE0[v1005];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1025);
									LOWORD(v1025) = v1124 + v1025;
									LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
									v180 = __CFADD__(v1181, v1025);
									v1027 = v1181 + v1025;
									BYTE1(v1006) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1188, v1026);
									v1028 = v1188 + v1026;
									LOBYTE(v1028) = BYTE2(v1146) + v180 + v1028;
									v1249 = v1248 - 1;
									if (!v1249)
										break;
									LOBYTE(v1005) = *(x_BYTE *)(v1006 + v1014);
									if ((x_BYTE)v1005)
									{
										BYTE1(v1005) = v1028;
										LOBYTE(v1005) = x_BYTE_F6EE0_tables[v1005];
										BYTE1(v1005) = v1008[7];
										v1008[7] = x_BYTE_FAEE0[v1005];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1027);
									LOWORD(v1027) = v1124 + v1027;
									LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
									v180 = __CFADD__(v1181, v1027);
									v1029 = v1181 + v1027;
									BYTE1(v1006) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1188, v1028);
									v1030 = v1188 + v1028;
									LOBYTE(v1030) = BYTE2(v1146) + v180 + v1030;
									v1250 = v1249 - 1;
									if (!v1250)
										break;
									LOBYTE(v1005) = *(x_BYTE *)(v1006 + v1014);
									if ((x_BYTE)v1005)
									{
										BYTE1(v1005) = v1030;
										LOBYTE(v1005) = x_BYTE_F6EE0_tables[v1005];
										BYTE1(v1005) = v1008[8];
										v1008[8] = x_BYTE_FAEE0[v1005];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1029);
									LOWORD(v1029) = v1124 + v1029;
									LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
									v180 = __CFADD__(v1181, v1029);
									v1031 = v1181 + v1029;
									BYTE1(v1006) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1188, v1030);
									v1032 = v1188 + v1030;
									LOBYTE(v1032) = BYTE2(v1146) + v180 + v1032;
									v1251 = v1250 - 1;
									if (!v1251)
										break;
									LOBYTE(v1005) = *(x_BYTE *)(v1006 + v1014);
									if ((x_BYTE)v1005)
									{
										BYTE1(v1005) = v1032;
										LOBYTE(v1005) = x_BYTE_F6EE0_tables[v1005];
										BYTE1(v1005) = v1008[9];
										v1008[9] = x_BYTE_FAEE0[v1005];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1031);
									LOWORD(v1031) = v1124 + v1031;
									LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
									v180 = __CFADD__(v1181, v1031);
									v1033 = v1181 + v1031;
									BYTE1(v1006) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1188, v1032);
									v1034 = v1188 + v1032;
									LOBYTE(v1034) = BYTE2(v1146) + v180 + v1034;
									v1252 = v1251 - 1;
									if (!v1252)
										break;
									LOBYTE(v1005) = *(x_BYTE *)(v1006 + v1014);
									if ((x_BYTE)v1005)
									{
										BYTE1(v1005) = v1034;
										LOBYTE(v1005) = x_BYTE_F6EE0_tables[v1005];
										BYTE1(v1005) = v1008[10];
										v1008[10] = x_BYTE_FAEE0[v1005];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1033);
									LOWORD(v1033) = v1124 + v1033;
									LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
									v180 = __CFADD__(v1181, v1033);
									v1035 = v1181 + v1033;
									BYTE1(v1006) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1188, v1034);
									v1036 = v1188 + v1034;
									LOBYTE(v1036) = BYTE2(v1146) + v180 + v1036;
									v1253 = v1252 - 1;
									if (!v1253)
										break;
									LOBYTE(v1005) = *(x_BYTE *)(v1006 + v1014);
									if ((x_BYTE)v1005)
									{
										BYTE1(v1005) = v1036;
										LOBYTE(v1005) = x_BYTE_F6EE0_tables[v1005];
										BYTE1(v1005) = v1008[11];
										v1008[11] = x_BYTE_FAEE0[v1005];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1035);
									LOWORD(v1035) = v1124 + v1035;
									LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
									v180 = __CFADD__(v1181, v1035);
									v1037 = v1181 + v1035;
									BYTE1(v1006) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1188, v1036);
									v1038 = v1188 + v1036;
									LOBYTE(v1038) = BYTE2(v1146) + v180 + v1038;
									v1254 = v1253 - 1;
									if (!v1254)
										break;
									LOBYTE(v1005) = *(x_BYTE *)(v1006 + v1014);
									if ((x_BYTE)v1005)
									{
										BYTE1(v1005) = v1038;
										LOBYTE(v1005) = x_BYTE_F6EE0_tables[v1005];
										BYTE1(v1005) = v1008[12];
										v1008[12] = x_BYTE_FAEE0[v1005];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1037);
									LOWORD(v1037) = v1124 + v1037;
									LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
									v180 = __CFADD__(v1181, v1037);
									v1039 = v1181 + v1037;
									BYTE1(v1006) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1188, v1038);
									v1040 = v1188 + v1038;
									LOBYTE(v1040) = BYTE2(v1146) + v180 + v1040;
									v1255 = v1254 - 1;
									if (!v1255)
										break;
									LOBYTE(v1005) = *(x_BYTE *)(v1006 + v1014);
									if ((x_BYTE)v1005)
									{
										BYTE1(v1005) = v1040;
										LOBYTE(v1005) = x_BYTE_F6EE0_tables[v1005];
										BYTE1(v1005) = v1008[13];
										v1008[13] = x_BYTE_FAEE0[v1005];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1039);
									LOWORD(v1039) = v1124 + v1039;
									LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
									v180 = __CFADD__(v1181, v1039);
									v1041 = v1181 + v1039;
									BYTE1(v1006) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1188, v1040);
									v1042 = v1188 + v1040;
									LOBYTE(v1042) = BYTE2(v1146) + v180 + v1042;
									v1256 = v1255 - 1;
									if (!v1256)
										break;
									LOBYTE(v1005) = *(x_BYTE *)(v1006 + v1014);
									if ((x_BYTE)v1005)
									{
										BYTE1(v1005) = v1042;
										LOBYTE(v1005) = x_BYTE_F6EE0_tables[v1005];
										BYTE1(v1005) = v1008[14];
										v1008[14] = x_BYTE_FAEE0[v1005];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1041);
									LOWORD(v1041) = v1124 + v1041;
									LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
									v180 = __CFADD__(v1181, v1041);
									v1043 = v1181 + v1041;
									BYTE1(v1006) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1188, v1042);
									v1044 = v1188 + v1042;
									LOBYTE(v1044) = BYTE2(v1146) + v180 + v1044;
									v1257 = v1256 - 1;
									if (!v1257)
										break;
									LOBYTE(v1005) = *(x_BYTE *)(v1006 + v1014);
									if ((x_BYTE)v1005)
									{
										BYTE1(v1005) = v1044;
										LOBYTE(v1005) = x_BYTE_F6EE0_tables[v1005];
										BYTE1(v1005) = v1008[15];
										v1008[15] = x_BYTE_FAEE0[v1005];
									}
									v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1043);
									LOWORD(v1043) = v1124 + v1043;
									LOBYTE(v1006) = BYTE2(v1124) + v180 + v1006;
									v180 = __CFADD__(v1181, v1043);
									v1012 = v1181 + v1043;
									BYTE1(v1006) += BYTE2(v1135) + v180;
									v180 = __CFADD__(v1188, v1044);
									v1013 = v1188 + v1044;
									LOBYTE(v1013) = BYTE2(v1146) + v180 + v1013;
									v1242 = v1257 - 1;
									if (!v1242)
										break;
									v1008 += 16;
								}
								v1004 = v1290;
							}
						LABEL_1282:
							v1004 += 10;
							if (!--v1123)
								return;
						}
						if (v1007 > x_DWORD_DE564)
							v1007 = x_DWORD_DE564;
						v18 = __OFSUB__((x_WORD)v1007, (x_WORD)v1005);
						LOWORD(v1007) = v1007 - v1005;
						if ((unsigned __int8)(((v1007 & 0x8000u) != 0) ^ v18) | ((x_WORD)v1007 == 0))
							goto LABEL_1282;
						v1008 += v1005;
						v1012 = __ROL4__(*((x_DWORD *)v1004 + 3), 16);
						BYTE1(v1006) = v1012;
						LOWORD(v1012) = v1004[4];
						LOBYTE(v1006) = *((x_BYTE *)v1004 + 10);
						v1242 = v1007;
						v1013 = __ROL4__(*((x_DWORD *)v1004 + 4), 16);
						goto LABEL_1231;
					case 0x1A:
						v1045 = (unsigned __int16 *)&unk_DE56C;
						v1182 = v1135 << 16;
						v1189 = v1146 << 16;
						HIWORD(v1046) = 0;
						HIWORD(v1047) = 0;
						break;
					}
					while (1)
					{
						LOWORD(v1046) = v1045[1];
						v1048 = v1045[3];
						v1049 = (char *)(x_DWORD_DE560 + v1102);
						v1102 += x_DWORD_DE560;
						if ((v1046 & 0x8000u) == 0)
							break;
						if ((signed __int16)v1048 > 0)
						{
							if (v1048 > x_DWORD_DE564)
								v1048 = x_DWORD_DE564;
							v1258 = v1048;
							v1050 = (unsigned __int16)-(signed __int16)v1046;
							v1051 = v1050;
							v1053 = __ROL4__(*((x_DWORD *)v1045 + 3) + v1135 * v1050, 16);
							BYTE1(v1047) = v1053;
							v1052 = *((x_DWORD *)v1045 + 2) + v1124 * v1050;
							LOWORD(v1053) = v1052;
							v1046 = v1052 >> 8;
							LOBYTE(v1047) = BYTE1(v1046);
							v1054 = __ROL4__(*((x_DWORD *)v1045 + 4) + v1146 * v1051, 16);
							v1046 = (unsigned __int16)v1046;
						LABEL_1294:
							v1291 = v1045;
							v1055 = x_DWORD_DE55C;
							while (1)
							{
								LOBYTE(v1046) = *(x_BYTE *)(v1047 + v1055);
								v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1053);
								LOWORD(v1053) = v1124 + v1053;
								BYTE1(v1046) = v1054;
								LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
								if ((unsigned __int8)v1046 >= 0xCu)
								{
									v1056 = x_BYTE_F6EE0_tables[v1046];
								}
								else
								{
									LOBYTE(v1046) = x_BYTE_F6EE0_tables[v1046];
									BYTE1(v1046) = *v1049;
									v1056 = x_BYTE_FAEE0[v1046];
								}
								v180 = __CFADD__(v1182, v1053);
								v1057 = v1182 + v1053;
								BYTE1(v1047) += BYTE2(v1135) + v180;
								v180 = __CFADD__(v1189, v1054);
								v1058 = v1189 + v1054;
								*v1049 = v1056;
								LOBYTE(v1058) = BYTE2(v1146) + v180 + v1058;
								v1259 = v1258 - 1;
								if (!v1259)
									break;
								LOBYTE(v1046) = *(x_BYTE *)(v1047 + v1055);
								v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1057);
								LOWORD(v1057) = v1124 + v1057;
								BYTE1(v1046) = v1058;
								LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
								if ((unsigned __int8)v1046 >= 0xCu)
								{
									v1059 = x_BYTE_F6EE0_tables[v1046];
								}
								else
								{
									LOBYTE(v1046) = x_BYTE_F6EE0_tables[v1046];
									BYTE1(v1046) = v1049[1];
									v1059 = x_BYTE_FAEE0[v1046];
								}
								v180 = __CFADD__(v1182, v1057);
								v1060 = v1182 + v1057;
								BYTE1(v1047) += BYTE2(v1135) + v180;
								v180 = __CFADD__(v1189, v1058);
								v1061 = v1189 + v1058;
								v1049[1] = v1059;
								LOBYTE(v1061) = BYTE2(v1146) + v180 + v1061;
								v1260 = v1259 - 1;
								if (!v1260)
									break;
								LOBYTE(v1046) = *(x_BYTE *)(v1047 + v1055);
								v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1060);
								LOWORD(v1060) = v1124 + v1060;
								BYTE1(v1046) = v1061;
								LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
								if ((unsigned __int8)v1046 >= 0xCu)
								{
									v1062 = x_BYTE_F6EE0_tables[v1046];
								}
								else
								{
									LOBYTE(v1046) = x_BYTE_F6EE0_tables[v1046];
									BYTE1(v1046) = v1049[2];
									v1062 = x_BYTE_FAEE0[v1046];
								}
								v180 = __CFADD__(v1182, v1060);
								v1063 = v1182 + v1060;
								BYTE1(v1047) += BYTE2(v1135) + v180;
								v180 = __CFADD__(v1189, v1061);
								v1064 = v1189 + v1061;
								v1049[2] = v1062;
								LOBYTE(v1064) = BYTE2(v1146) + v180 + v1064;
								v1261 = v1260 - 1;
								if (!v1261)
									break;
								LOBYTE(v1046) = *(x_BYTE *)(v1047 + v1055);
								v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1063);
								LOWORD(v1063) = v1124 + v1063;
								BYTE1(v1046) = v1064;
								LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
								if ((unsigned __int8)v1046 >= 0xCu)
								{
									v1065 = x_BYTE_F6EE0_tables[v1046];
								}
								else
								{
									LOBYTE(v1046) = x_BYTE_F6EE0_tables[v1046];
									BYTE1(v1046) = v1049[3];
									v1065 = x_BYTE_FAEE0[v1046];
								}
								v180 = __CFADD__(v1182, v1063);
								v1066 = v1182 + v1063;
								BYTE1(v1047) += BYTE2(v1135) + v180;
								v180 = __CFADD__(v1189, v1064);
								v1067 = v1189 + v1064;
								v1049[3] = v1065;
								LOBYTE(v1067) = BYTE2(v1146) + v180 + v1067;
								v1262 = v1261 - 1;
								if (!v1262)
									break;
								LOBYTE(v1046) = *(x_BYTE *)(v1047 + v1055);
								v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1066);
								LOWORD(v1066) = v1124 + v1066;
								BYTE1(v1046) = v1067;
								LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
								if ((unsigned __int8)v1046 >= 0xCu)
								{
									v1068 = x_BYTE_F6EE0_tables[v1046];
								}
								else
								{
									LOBYTE(v1046) = x_BYTE_F6EE0_tables[v1046];
									BYTE1(v1046) = v1049[4];
									v1068 = x_BYTE_FAEE0[v1046];
								}
								v180 = __CFADD__(v1182, v1066);
								v1069 = v1182 + v1066;
								BYTE1(v1047) += BYTE2(v1135) + v180;
								v180 = __CFADD__(v1189, v1067);
								v1070 = v1189 + v1067;
								v1049[4] = v1068;
								LOBYTE(v1070) = BYTE2(v1146) + v180 + v1070;
								v1263 = v1262 - 1;
								if (!v1263)
									break;
								LOBYTE(v1046) = *(x_BYTE *)(v1047 + v1055);
								v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1069);
								LOWORD(v1069) = v1124 + v1069;
								BYTE1(v1046) = v1070;
								LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
								if ((unsigned __int8)v1046 >= 0xCu)
								{
									v1071 = x_BYTE_F6EE0_tables[v1046];
								}
								else
								{
									LOBYTE(v1046) = x_BYTE_F6EE0_tables[v1046];
									BYTE1(v1046) = v1049[5];
									v1071 = x_BYTE_FAEE0[v1046];
								}
								v180 = __CFADD__(v1182, v1069);
								v1072 = v1182 + v1069;
								BYTE1(v1047) += BYTE2(v1135) + v180;
								v180 = __CFADD__(v1189, v1070);
								v1073 = v1189 + v1070;
								v1049[5] = v1071;
								LOBYTE(v1073) = BYTE2(v1146) + v180 + v1073;
								v1264 = v1263 - 1;
								if (!v1264)
									break;
								LOBYTE(v1046) = *(x_BYTE *)(v1047 + v1055);
								v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1072);
								LOWORD(v1072) = v1124 + v1072;
								BYTE1(v1046) = v1073;
								LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
								if ((unsigned __int8)v1046 >= 0xCu)
								{
									v1074 = x_BYTE_F6EE0_tables[v1046];
								}
								else
								{
									LOBYTE(v1046) = x_BYTE_F6EE0_tables[v1046];
									BYTE1(v1046) = v1049[6];
									v1074 = x_BYTE_FAEE0[v1046];
								}
								v180 = __CFADD__(v1182, v1072);
								v1075 = v1182 + v1072;
								BYTE1(v1047) += BYTE2(v1135) + v180;
								v180 = __CFADD__(v1189, v1073);
								v1076 = v1189 + v1073;
								v1049[6] = v1074;
								LOBYTE(v1076) = BYTE2(v1146) + v180 + v1076;
								v1265 = v1264 - 1;
								if (!v1265)
									break;
								LOBYTE(v1046) = *(x_BYTE *)(v1047 + v1055);
								v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1075);
								LOWORD(v1075) = v1124 + v1075;
								BYTE1(v1046) = v1076;
								LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
								if ((unsigned __int8)v1046 >= 0xCu)
								{
									v1077 = x_BYTE_F6EE0_tables[v1046];
								}
								else
								{
									LOBYTE(v1046) = x_BYTE_F6EE0_tables[v1046];
									BYTE1(v1046) = v1049[7];
									v1077 = x_BYTE_FAEE0[v1046];
								}
								v180 = __CFADD__(v1182, v1075);
								v1078 = v1182 + v1075;
								BYTE1(v1047) += BYTE2(v1135) + v180;
								v180 = __CFADD__(v1189, v1076);
								v1079 = v1189 + v1076;
								v1049[7] = v1077;
								LOBYTE(v1079) = BYTE2(v1146) + v180 + v1079;
								v1266 = v1265 - 1;
								if (!v1266)
									break;
								LOBYTE(v1046) = *(x_BYTE *)(v1047 + v1055);
								v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1078);
								LOWORD(v1078) = v1124 + v1078;
								BYTE1(v1046) = v1079;
								LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
								if ((unsigned __int8)v1046 >= 0xCu)
								{
									v1080 = x_BYTE_F6EE0_tables[v1046];
								}
								else
								{
									LOBYTE(v1046) = x_BYTE_F6EE0_tables[v1046];
									BYTE1(v1046) = v1049[8];
									v1080 = x_BYTE_FAEE0[v1046];
								}
								v180 = __CFADD__(v1182, v1078);
								v1081 = v1182 + v1078;
								BYTE1(v1047) += BYTE2(v1135) + v180;
								v180 = __CFADD__(v1189, v1079);
								v1082 = v1189 + v1079;
								v1049[8] = v1080;
								LOBYTE(v1082) = BYTE2(v1146) + v180 + v1082;
								v1267 = v1266 - 1;
								if (!v1267)
									break;
								LOBYTE(v1046) = *(x_BYTE *)(v1047 + v1055);
								v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1081);
								LOWORD(v1081) = v1124 + v1081;
								BYTE1(v1046) = v1082;
								LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
								if ((unsigned __int8)v1046 >= 0xCu)
								{
									v1083 = x_BYTE_F6EE0_tables[v1046];
								}
								else
								{
									LOBYTE(v1046) = x_BYTE_F6EE0_tables[v1046];
									BYTE1(v1046) = v1049[9];
									v1083 = x_BYTE_FAEE0[v1046];
								}
								v180 = __CFADD__(v1182, v1081);
								v1084 = v1182 + v1081;
								BYTE1(v1047) += BYTE2(v1135) + v180;
								v180 = __CFADD__(v1189, v1082);
								v1085 = v1189 + v1082;
								v1049[9] = v1083;
								LOBYTE(v1085) = BYTE2(v1146) + v180 + v1085;
								v1268 = v1267 - 1;
								if (!v1268)
									break;
								LOBYTE(v1046) = *(x_BYTE *)(v1047 + v1055);
								v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1084);
								LOWORD(v1084) = v1124 + v1084;
								BYTE1(v1046) = v1085;
								LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
								if ((unsigned __int8)v1046 >= 0xCu)
								{
									v1086 = x_BYTE_F6EE0_tables[v1046];
								}
								else
								{
									LOBYTE(v1046) = x_BYTE_F6EE0_tables[v1046];
									BYTE1(v1046) = v1049[10];
									v1086 = x_BYTE_FAEE0[v1046];
								}
								v180 = __CFADD__(v1182, v1084);
								v1087 = v1182 + v1084;
								BYTE1(v1047) += BYTE2(v1135) + v180;
								v180 = __CFADD__(v1189, v1085);
								v1088 = v1189 + v1085;
								v1049[10] = v1086;
								LOBYTE(v1088) = BYTE2(v1146) + v180 + v1088;
								v1269 = v1268 - 1;
								if (!v1269)
									break;
								LOBYTE(v1046) = *(x_BYTE *)(v1047 + v1055);
								v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1087);
								LOWORD(v1087) = v1124 + v1087;
								BYTE1(v1046) = v1088;
								LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
								if ((unsigned __int8)v1046 >= 0xCu)
								{
									v1089 = x_BYTE_F6EE0_tables[v1046];
								}
								else
								{
									LOBYTE(v1046) = x_BYTE_F6EE0_tables[v1046];
									BYTE1(v1046) = v1049[11];
									v1089 = x_BYTE_FAEE0[v1046];
								}
								v180 = __CFADD__(v1182, v1087);
								v1090 = v1182 + v1087;
								BYTE1(v1047) += BYTE2(v1135) + v180;
								v180 = __CFADD__(v1189, v1088);
								v1091 = v1189 + v1088;
								v1049[11] = v1089;
								LOBYTE(v1091) = BYTE2(v1146) + v180 + v1091;
								v1270 = v1269 - 1;
								if (!v1270)
									break;
								LOBYTE(v1046) = *(x_BYTE *)(v1047 + v1055);
								v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1090);
								LOWORD(v1090) = v1124 + v1090;
								BYTE1(v1046) = v1091;
								LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
								if ((unsigned __int8)v1046 >= 0xCu)
								{
									v1092 = x_BYTE_F6EE0_tables[v1046];
								}
								else
								{
									LOBYTE(v1046) = x_BYTE_F6EE0_tables[v1046];
									BYTE1(v1046) = v1049[12];
									v1092 = x_BYTE_FAEE0[v1046];
								}
								v180 = __CFADD__(v1182, v1090);
								v1093 = v1182 + v1090;
								BYTE1(v1047) += BYTE2(v1135) + v180;
								v180 = __CFADD__(v1189, v1091);
								v1094 = v1189 + v1091;
								v1049[12] = v1092;
								LOBYTE(v1094) = BYTE2(v1146) + v180 + v1094;
								v1271 = v1270 - 1;
								if (!v1271)
									break;
								LOBYTE(v1046) = *(x_BYTE *)(v1047 + v1055);
								v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1093);
								LOWORD(v1093) = v1124 + v1093;
								BYTE1(v1046) = v1094;
								LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
								if ((unsigned __int8)v1046 >= 0xCu)
								{
									v1095 = x_BYTE_F6EE0_tables[v1046];
								}
								else
								{
									LOBYTE(v1046) = x_BYTE_F6EE0_tables[v1046];
									BYTE1(v1046) = v1049[13];
									v1095 = x_BYTE_FAEE0[v1046];
								}
								v180 = __CFADD__(v1182, v1093);
								v1096 = v1182 + v1093;
								BYTE1(v1047) += BYTE2(v1135) + v180;
								v180 = __CFADD__(v1189, v1094);
								v1097 = v1189 + v1094;
								v1049[13] = v1095;
								LOBYTE(v1097) = BYTE2(v1146) + v180 + v1097;
								v1272 = v1271 - 1;
								if (!v1272)
									break;
								LOBYTE(v1046) = *(x_BYTE *)(v1047 + v1055);
								v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1096);
								LOWORD(v1096) = v1124 + v1096;
								BYTE1(v1046) = v1097;
								LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
								if ((unsigned __int8)v1046 >= 0xCu)
								{
									v1098 = x_BYTE_F6EE0_tables[v1046];
								}
								else
								{
									LOBYTE(v1046) = x_BYTE_F6EE0_tables[v1046];
									BYTE1(v1046) = v1049[14];
									v1098 = x_BYTE_FAEE0[v1046];
								}
								v180 = __CFADD__(v1182, v1096);
								v1099 = v1182 + v1096;
								BYTE1(v1047) += BYTE2(v1135) + v180;
								v180 = __CFADD__(v1189, v1097);
								v1100 = v1189 + v1097;
								v1049[14] = v1098;
								LOBYTE(v1100) = BYTE2(v1146) + v180 + v1100;
								v1273 = v1272 - 1;
								if (!v1273)
									break;
								LOBYTE(v1046) = *(x_BYTE *)(v1047 + v1055);
								v180 = __CFADD__((x_WORD)v1124, (x_WORD)v1099);
								LOWORD(v1099) = v1124 + v1099;
								BYTE1(v1046) = v1100;
								LOBYTE(v1047) = BYTE2(v1124) + v180 + v1047;
								if ((unsigned __int8)v1046 >= 0xCu)
								{
									v1101 = x_BYTE_F6EE0_tables[v1046];
								}
								else
								{
									LOBYTE(v1046) = x_BYTE_F6EE0_tables[v1046];
									BYTE1(v1046) = v1049[15];
									v1101 = x_BYTE_FAEE0[v1046];
								}
								v180 = __CFADD__(v1182, v1099);
								v1053 = v1182 + v1099;
								BYTE1(v1047) += BYTE2(v1135) + v180;
								v180 = __CFADD__(v1189, v1100);
								v1054 = v1189 + v1100;
								v1049[15] = v1101;
								LOBYTE(v1054) = BYTE2(v1146) + v180 + v1054;
								v1258 = v1273 - 1;
								if (!v1258)
									break;
								v1049 += 16;
							}
							v1045 = v1291;
						}
					LABEL_1361:
						v1045 += 10;
						if (!--v1123)
							return;
					}
					if (v1048 > x_DWORD_DE564)
						v1048 = x_DWORD_DE564;
					v18 = __OFSUB__((x_WORD)v1048, (x_WORD)v1046);
					LOWORD(v1048) = v1048 - v1046;
					if ((unsigned __int8)(((v1048 & 0x8000u) != 0) ^ v18) | ((x_WORD)v1048 == 0))
						goto LABEL_1361;
					v1049 += v1046;
					v1053 = __ROL4__(*((x_DWORD *)v1045 + 3), 16);
					BYTE1(v1047) = v1053;
					LOWORD(v1053) = v1045[4];
					LOBYTE(v1047) = *((x_BYTE *)v1045 + 10);
					v1258 = v1048;
					v1054 = __ROL4__(*((x_DWORD *)v1045 + 4), 16);
					goto LABEL_1294;
				}
				v1114 += v1191;
				v74 += v1104 * v1161;
				v75 += v1161 * v1108;
				v76 += v1161 * v1127;
				v77 += v1161 * v1138;
				v78 += v1161 * v1149;
				if (v1301)
				{
					v1123 = x_DWORD_DE568;
					if (v1297)
					{
						v1114 = x_DWORD_DE568;
					}
					else
					{
						v1297 = x_DWORD_DE568 <= v1114;
						v1120 = x_DWORD_DE568 - v1114;
					}
				}
			}
			else if (v1301)
			{
				v82 = x_DWORD_DE568 - v1191;
				v1123 = x_DWORD_DE568 - v1191;
				if (v1297)
				{
					v1114 = x_DWORD_DE568 - v1191;
				}
				else
				{
					v18 = __OFSUB__(v82, v1114);
					v83 = v82 - v1114;
					v1297 = (v83 < 0) ^ v18 | (v83 == 0);
					v1120 = v83;
				}
			}
			v81 = (int *)&unk_DE56C;
			do
			{
				*v81 = v74;
				v74 += v1104;
				v81[1] = v75;
				v75 += v1108;
				v81[2] = v76;
				v76 += v1127;
				v81[3] = v77;
				v77 += v1138;
				v81[4] = v78;
				v78 += v1149;
				v81 += 5;
				--v1114;
			} while (v1114);
			v80 = v1122;
			goto LABEL_156;
		}
	}
}
// B8845: using guessed type int x_DWORD_B8845[];
// DE554: using guessed type int x_DWORD_DE554;
// DE55C: using guessed type int x_DWORD_DE55C;
// DE560: using guessed type int x_DWORD_DE560;
// DE564: using guessed type int x_DWORD_DE564;
// DE568: using guessed type int x_DWORD_DE568;
// E126C: using guessed type char x_BYTE_E126C;
// E126D: using guessed type char x_BYTE_E126D;

//----- (000BCD45) --------------------------------------------------------
void /*__spoils<>*/ sub_BCD45(int a1, int a2, int a3, int a4, int a5)
{
	if (a3)
		x_DWORD_DE560 = a3;
	if (a1)
	{
		x_DWORD_DE558 = a1;
		x_DWORD_DE554 = a1 - x_DWORD_DE560;
	}
	if (a2)
		x_DWORD_DE55C = a2;
	if (a5)
		x_DWORD_DE568 = a5;
	if (a4)
		x_DWORD_DE564 = a4;
}
// DE554: using guessed type int x_DWORD_DE554;
// DE558: using guessed type int x_DWORD_DE558;
// DE55C: using guessed type int x_DWORD_DE55C;
// DE560: using guessed type int x_DWORD_DE560;
// DE564: using guessed type int x_DWORD_DE564;
// DE568: using guessed type int x_DWORD_DE568;

//----- (000BD1B6) --------------------------------------------------------
void /*__spoils<ecx>*/ sub_BD1B6(int a1)
{
	int v1; // ecx
	int v2; // eax
	x_BYTE *v3; // edx
	x_BYTE *v4; // ecx
	int v5; // ST04_4
	x_BYTE *v6; // ST08_4
	x_BYTE *v7; // ST0C_4
	int v8; // eax
	x_BYTE *v9; // edx
	x_BYTE *v10; // ecx
	int v11; // ST04_4
	x_BYTE *v12; // ST08_4
	x_BYTE *v13; // ST0C_4
	int v14; // eax
	x_BYTE *v15; // edx
	x_BYTE *v16; // ecx
	int v17; // ST04_4
	x_BYTE *v18; // ST08_4
	x_BYTE *v19; // ST0C_4
	int v20; // eax
	x_BYTE *v21; // edx
	x_BYTE *v22; // ecx
	int v23; // ST04_4
	x_BYTE *v24; // ST08_4
	x_BYTE *v25; // ST0C_4
	int v26; // eax
	x_BYTE *v27; // edx
	x_BYTE *v28; // ecx
	int v29; // ST04_4
	x_BYTE *v30; // ST08_4
	x_BYTE *v31; // ST0C_4
	int v32; // eax
	x_BYTE *v33; // edx
	x_BYTE *v34; // ecx
	int v35; // ST04_4
	x_BYTE *v36; // ST08_4
	x_BYTE *v37; // ST0C_4
	int v38; // eax
	x_BYTE *v39; // edx
	x_BYTE *v40; // ecx
	int v41; // ST04_4
	x_BYTE *v42; // ST08_4
	x_BYTE *v43; // ST0C_4
	int v44; // eax
	x_BYTE *v45; // edx
	x_BYTE *v46; // ecx
	int v47; // ST04_4
	x_BYTE *v48; // ST08_4
	x_BYTE *v49; // ST0C_4
	int v50; // eax
	x_BYTE *v51; // edx
	x_BYTE *v52; // ecx
	int v53; // ST04_4
	x_BYTE *v54; // ST08_4
	x_BYTE *v55; // ST0C_4
	int v56; // [esp-Ch] [ebp-18h]
	int v57; // [esp+8h] [ebp-4h]
	int savedregs; // [esp+Ch] [ebp+0h]

	//fix it
	v1 = 0;
	v3 = 0;
	v4 = 0;
	v9 = 0;
	v10 = 0;
	v15 = 0;
	v16 = 0;
	v19 = 0;
	v21 = 0;
	v22 = 0;
	v27 = 0;
	v28 = 0;
	v33 = 0;
	v34 = 0;
	v39 = 0;
	v40 = 0;
	v45 = 0;
	v46 = 0;
	v51 = 0;
	v52 = 0;
	//fix it

	v56 = v1;
	sub_9951B(0);
	v57 = 4096;
	v2 = sub_BD320(0, (x_BYTE *)x_DWORD_180628b_screen_buffer, (x_BYTE *)x_DWORD_E9C3C, 0, (int)&savedregs, a1);
	v7 = v4;
	v6 = v3;
	v5 = v2;
	sub_9951B(1);
	v57 = 4096;
	v8 = sub_BD320(v5, v6, v7, 0, (int)&savedregs, a1);
	v13 = v10;
	v12 = v9;
	v11 = v8;
	sub_9951B(2);
	v57 = 4096;
	v14 = sub_BD320(v11, v12, v13, 0, (int)&savedregs, a1);
	v19 = v16;
	v18 = v15;
	v17 = v14;
	sub_9951B(3);
	v57 = 4096;
	v20 = sub_BD320(v17, v18, v19, 0, (int)&savedregs, a1);
	v25 = v22;
	v24 = v21;
	v23 = v20;
	sub_9951B(4);
	v57 = 4096;
	v26 = sub_BD320(v23, v24, v25, 0, (int)&savedregs, a1);
	v31 = v28;
	v30 = v27;
	v29 = v26;
	sub_9951B(5);
	v57 = 4096;
	v32 = sub_BD320(v29, v30, v31, 0, (int)&savedregs, a1);
	v37 = v34;
	v36 = v33;
	v35 = v32;
	sub_9951B(6);
	v57 = 4096;
	v38 = sub_BD320(v35, v36, v37, 0, (int)&savedregs, a1);
	v43 = v40;
	v42 = v39;
	v41 = v38;
	sub_9951B(7);
	v57 = 4096;
	v44 = sub_BD320(v41, v42, v43, 0, (int)&savedregs, a1);
	v49 = v46;
	v48 = v45;
	v47 = v44;
	sub_9951B(8);
	v57 = 4096;
	v50 = sub_BD320(v47, v48, v49, 0, (int)&savedregs, a1);
	v55 = v52;
	v54 = v51;
	v53 = v50;
	sub_9951B(9);
	v57 = 1536;
	sub_BD320(v53, v54, v55, 0, (int)&savedregs, a1);
}
// E9C3C: using guessed type int x_DWORD_E9C3C;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;

//----- (000BD2CB) --------------------------------------------------------
void /*__spoils<ecx>*/ sub_BD2CB(int a1)
{
	int v1; // ecx
	int v2; // eax
	x_BYTE *v3; // edx
	x_BYTE *v4; // ecx
	int v5; // ST04_4
	x_BYTE *v6; // ST08_4
	x_BYTE *v7; // ST0C_4
	int v8; // [esp-Ch] [ebp-18h]
	int v9; // [esp+8h] [ebp-4h]
	int savedregs; // [esp+Ch] [ebp+0h]

	//fix it
	v1 = 0;
	v3 = 0;
	v4 = 0;
	//fix it

	v8 = v1;
	sub_9951B(0);
	v9 = 4096;
	v2 = sub_BD320(0, (x_BYTE *)x_DWORD_180628b_screen_buffer, (x_BYTE *)x_DWORD_E9C3C, 0, (int)&savedregs, a1);
	v7 = v4;
	v6 = v3;
	v5 = v2;
	sub_9951B(1);
	v9 = 3904;
	sub_BD320(v5, v6, v7, 0, (int)&savedregs, a1);
}
// E9C3C: using guessed type int x_DWORD_E9C3C;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;

//----- (000BD320) --------------------------------------------------------
int sub_BD320(int result, x_BYTE *a2, x_BYTE *a3, int a4, int a5, int a6)
{
	int *v6; // edi
	int v7; // eax

	v6 = (int *)&loc_A0000_vga_buffer;
	do
	{
		LOBYTE(a4) = a3[1];
		LOWORD(result) = *(x_WORD *)(a6 + 2 * a4);
		LOBYTE(a4) = a2[1];
		LOWORD(result) = *(x_WORD *)(a6 + 2 * a4 + 512) + result;
		v7 = result << 16;
		LOBYTE(a4) = *a3;
		LOWORD(v7) = *(x_WORD *)(a6 + 2 * a4);
		LOBYTE(a4) = *a2;
		LOWORD(v7) = *(x_WORD *)(a6 + 2 * a4 + 512) + v7;
		*v6 = v7;
		LOBYTE(a4) = a3[3];
		LOWORD(v7) = *(x_WORD *)(a6 + 2 * a4);
		LOBYTE(a4) = a2[3];
		LOWORD(v7) = *(x_WORD *)(a6 + 2 * a4 + 512) + v7;
		v7 <<= 16;
		LOBYTE(a4) = a3[2];
		LOWORD(v7) = *(x_WORD *)(a6 + 2 * a4);
		LOBYTE(a4) = a2[2];
		LOWORD(v7) = *(x_WORD *)(a6 + 2 * a4 + 512) + v7;
		v6[1] = v7;
		LOBYTE(a4) = a3[5];
		LOWORD(v7) = *(x_WORD *)(a6 + 2 * a4);
		LOBYTE(a4) = a2[5];
		LOWORD(v7) = *(x_WORD *)(a6 + 2 * a4 + 512) + v7;
		v7 <<= 16;
		LOBYTE(a4) = a3[4];
		LOWORD(v7) = *(x_WORD *)(a6 + 2 * a4);
		LOBYTE(a4) = a2[4];
		LOWORD(v7) = *(x_WORD *)(a6 + 2 * a4 + 512) + v7;
		v6[2] = v7;
		LOBYTE(a4) = a3[7];
		LOWORD(v7) = *(x_WORD *)(a6 + 2 * a4);
		LOBYTE(a4) = a2[7];
		LOWORD(v7) = *(x_WORD *)(a6 + 2 * a4 + 512) + v7;
		result = v7 << 16;
		LOBYTE(a4) = a3[6];
		LOWORD(result) = *(x_WORD *)(a6 + 2 * a4);
		LOBYTE(a4) = a2[6];
		LOWORD(result) = *(x_WORD *)(a6 + 2 * a4 + 512) + result;
		v6[3] = result;
		a3 += 8;
		a2 += 8;
		v6 += 4;
	} while ((*(x_DWORD *)(a5 - 4))-- != 1);
	return result;
}

//----- (000BD3DD) --------------------------------------------------------
void sub_BD3DD()
{
	char *v0; // edi
	char *v1; // esi
	signed int v2; // edx
	char *v3; // esi
	char *v4; // esi
	char *v5; // edi
	signed int v6; // edx
	char *v7; // esi
	char *v8; // esi
	char *v9; // edi
	signed int v10; // edx
	char *v11; // edi
	signed int v12; // edx
	char *v13; // edi
	signed int v14; // edx

	if (!x_BYTE_E3766)
		sub_8CACD_draw_cursor2();
	sub_9951B(0);
	v0 = (char *)&loc_A0000_vga_buffer + 51200;
	v1 = (char *)x_DWORD_180628b_screen_buffer;
	v2 = 11;
	do
	{
		qmemcpy(v0, v1, 0x280u);
		v1 += 1280;
		v0 += 1280;
		--v2;
	} while (v2);
	qmemcpy(v0, v1, 0x100u);
	v3 = v1 + 256;
	sub_9951B(1);
	qmemcpy(&loc_A0000_vga_buffer, v3, 0x180u);
	v4 = v3 + 1024;
	v5 = (char *)&loc_A0000_vga_buffer + 1024;
	v6 = 50;
	do
	{
		qmemcpy(v5, v4, 0x280u);
		v4 += 1280;
		v5 += 1280;
		--v6;
	} while (v6);
	qmemcpy(v5, v4, 0x200u);
	v7 = v4 + 512;
	sub_9951B(2);
	qmemcpy(&loc_A0000_vga_buffer, v7, 0x80u);
	v8 = v7 + 768;
	v9 = (char *)&loc_A0000_vga_buffer + 768;
	v10 = 51;
	do
	{
		qmemcpy(v9, v8, 0x280u);
		v8 += 1280;
		v9 += 1280;
		--v10;
	} while (v10);
	sub_9951B(3);
	v11 = (char *)&loc_A0000_vga_buffer + 512;
	v12 = 51;
	do
	{
		qmemcpy(v11, v8, 0x280u);
		v8 += 1280;
		v11 += 1280;
		--v12;
	} while (v12);
	sub_9951B(4);
	v13 = (char *)&loc_A0000_vga_buffer + 256;
	v14 = 34;
	do
	{
		qmemcpy(v13, v8, 0x280u);
		v8 += 1280;
		v13 += 1280;
		--v14;
	} while (v14);
	if (!x_BYTE_E3766)
		sub_8CB1F();
}
// E3766: using guessed type char x_BYTE_E3766;
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;

//----- (000BD524) --------------------------------------------------------
void sub_BD524(__int16 a1, __int16 a2, __int16 a3, __int16 a4)
{
	JUMPOUT((int*)&loc_BD550);
}

//----- (000BD542) --------------------------------------------------------
void /*__spoils<ecx>*/ sub_BD542(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4, char a5)
{
	signed __int16 v5; // bx
	unsigned __int16 v6; // cx
	unsigned __int16 v7; // cx
	unsigned __int16 v8; // ax
	unsigned __int16 v9; // ax
	x_BYTE *v10; // edi
	int v11; // esi
	unsigned __int16 v12; // ax
	unsigned __int16 v13; // cx
	unsigned __int16 v14; // si
	__int16 v15; // dx
	__int16 v16; // bx
	__int16 v17; // cx
	int v18; // edi
	unsigned int v19; // ecx
	unsigned __int16 v20; // ax
	int v21; // eax
	int v22; // ecx
	__int16 v23; // cx
	x_BYTE *v24; // edi
	int v25; // [esp+0h] [ebp-Ch]
	signed int v26; // [esp+4h] [ebp-8h]
	int v27; // [esp+8h] [ebp-4h]

	v27 = (int)x_DWORD_180628b_screen_buffer + x_DWORD_18063C_sprite_sizex + x_DWORD_18062C_resolution_x * x_DWORD_180650_positiony;
	v5 = a2;
	if ((a2 & 0x8000u) == 0)
	{
		v7 = a4;
		if ((a4 & 0x8000u) == 0)
		{
			if (a2 == a4)
			{
				if ((signed __int16)a2 >= (signed __int16)x_DWORD_180644_map_resolution2_y)
					return;
				v18 = a1;
				v19 = a3;
				if (a3 < a1)
				{
					LOWORD(v19) = a1;
					LOWORD(v18) = a3;
				}
				v20 = x_DWORD_180648_map_resolution2_x - 1;
				if ((v18 & 0x8000u) == 0)
				{
					if ((signed __int16)v18 > (signed __int16)v20)
						return;
					if ((unsigned __int16)v19 > v20)
						LOWORD(v19) = x_DWORD_180648_map_resolution2_x - 1;
				}
				else
				{
					if ((signed __int16)v19 <= 0)
						return;
					LOWORD(v18) = 0;
					if ((unsigned __int16)v19 > v20)
						LOWORD(v19) = x_DWORD_180648_map_resolution2_x - 1;
				}
				LOWORD(v19) = v19 - v18;
				goto LABEL_54;
			}
			if ((signed __int16)(a2 - a4) < 0)
			{
				if ((signed __int16)a2 >= (signed __int16)x_DWORD_180644_map_resolution2_y)
					return;
				if ((signed __int16)a4 >= (signed __int16)x_DWORD_180644_map_resolution2_y)
					goto LABEL_5;
			}
			else
			{
				if ((signed __int16)a4 >= (signed __int16)x_DWORD_180644_map_resolution2_y)
					return;
				a4 = a2;
				a2 = v7;
				v9 = a1;
				a1 = a3;
				a3 = v9;
				if (v5 >= (signed __int16)x_DWORD_180644_map_resolution2_y)
					goto LABEL_5;
			}
			goto LABEL_15;
		}
		a4 = a2;
		v5 = v7;
		v6 = a2;
		v8 = a1;
		a1 = a3;
		a3 = v8;
	}
	else
	{
		v6 = a4;
	}
	if ((v6 & 0x8000u) != 0)
		return;
	a1 += (signed __int16)-v5 * (signed __int16)(a3 - a1) / (signed __int16)(v6 - v5);
	a2 = 0;
	if ((signed __int16)(a4 - x_DWORD_180644_map_resolution2_y) >= 0)
	{
	LABEL_5:
		a3 = a1
			+ (unsigned int)((signed __int16)(x_DWORD_180644_map_resolution2_y - a2) * (signed __int16)(a3 - a1) / (signed __int16)(a4 - a2));
		a4 = x_DWORD_180644_map_resolution2_y - 1;
	}
LABEL_15:
	if ((a1 & 0x8000u) == 0)
	{
		if ((signed __int16)(a1 - x_DWORD_180648_map_resolution2_x) < 0)
		{
			if ((a3 & 0x8000u) == 0)
			{
				if ((signed __int16)(a3 - x_DWORD_180648_map_resolution2_x) < 0)
				{
					v26 = 1;
					if (a1 == a3)
					{
						v21 = a2;
						v22 = a4;
						if (a4 >= a2)
						{
							v23 = a4 - a2;
						}
						else
						{
							LOWORD(v21) = a4;
							v23 = a2 - a4;
						}
						v24 = (x_BYTE *)(v27 + x_DWORD_18062C_resolution_x * v21 + a1);
						LOWORD(v22) = v23 + 1;
						do
						{
							*v24 = a5;
							v24 += x_DWORD_18062C_resolution_x;
							--v22;
						} while (v22);
						return;
					}
					if ((signed __int16)(a1 - a3) >= 0)
						v26 = -1;
				}
				else
				{
					v26 = 1;
					a4 = a2
						+ (unsigned int)((signed __int16)(x_DWORD_180648_map_resolution2_x - a1) * (signed __int16)(a4 - a2) / (signed __int16)(a3 - a1));
					a3 = x_DWORD_180648_map_resolution2_x - 1;
				}
			}
			else
			{
				v26 = -1;
				a4 = a2 + (unsigned int)((signed __int16)a1 * (signed __int16)(a4 - a2) / (signed __int16)(a1 - a3));
				a3 = 0;
			}
		}
		else
		{
			if ((signed __int16)a3 >= (signed __int16)x_DWORD_180648_map_resolution2_x)
				return;
			v26 = -1;
			a2 += (signed __int16)(a1 - x_DWORD_180648_map_resolution2_x) * (signed __int16)(a4 - a2) / (signed __int16)(a1 - a3);
			a1 = x_DWORD_180648_map_resolution2_x - 1;
			if ((a3 & 0x8000u) != 0)
			{
				a4 -= (signed __int16)-a3 * (signed __int16)(a4 - a2) / (signed __int16)(a1 - a3);
				a3 = 0;
			}
		}
	}
	else
	{
		if ((a3 & 0x8000u) != 0)
			return;
		v26 = 1;
		a2 += (signed __int16)-a1 * (signed __int16)(a4 - a2) / (signed __int16)(a3 - a1);
		a1 = 0;
		if ((signed __int16)(a3 - x_DWORD_180648_map_resolution2_x) >= 0)
		{
			a4 = a2 + (unsigned int)((signed __int16)x_DWORD_180648_map_resolution2_x * (signed __int16)(a4 - a2) / (signed __int16)a3);
			a3 = x_DWORD_180648_map_resolution2_x - 1;
		}
	}
	v10 = (x_BYTE *)(v27 + x_DWORD_18062C_resolution_x * a2 + a1);
	v11 = v26;
	v12 = v26 * (a3 - a1);
	v13 = a4 - a2;
	if (a4 == a2)
	{
		v18 = a1;
		v19 = a3;
		if (a3 >= a1)
		{
			LOWORD(v19) = a3 - a1;
		}
		else
		{
			LOWORD(v18) = a3;
			LOWORD(v19) = a1 - a3;
		}
	LABEL_54:
		LOWORD(v19) = v19 + 1;
		memset((void *)(v27 + x_DWORD_18062C_resolution_x * a2 + v18), a5, v19);
		return;
	}
	if (v13 <= v12)
	{
		v25 = x_DWORD_18062C_resolution_x;
	}
	else
	{
		v12 = a4 - a2;
		v13 = v26 * (a3 - a1);
		v26 = x_DWORD_18062C_resolution_x;
		v25 = v11;
	}
	v14 = v12;
	v15 = 2 * v13;
	v16 = 2 * v13 - v12;
	v17 = 2 * (v13 - v12);
	*v10 = a5;
	do
	{
		while (1)
		{
			v10 += v26;
			if (v16 >= 0)
				break;
			v16 += v15;
			*v10 = a5;
			if (!--v14)
				return;
		}
		v10 += v25;
		v16 += v17;
		*v10 = a5;
		--v14;
	} while (v14);
}
// 180628: using guessed type int x_DWORD_180628b_screen_buffer;
// 18062C: using guessed type int x_DWORD_18062C_resolution_x;
// 18063C: using guessed type int x_DWORD_18063C_sprite_sizex;
// 180644: using guessed type int x_DWORD_180644_map_resolution2_y;
// 180648: using guessed type int x_DWORD_180648_map_resolution2_x;
// 180650: using guessed type int x_DWORD_180650_positiony;

//----- (000BF123) --------------------------------------------------------
int sub_BF123()
{
	return x_DWORD_E4C94;
}
// E4C94: using guessed type int x_DWORD_E4C94;

//----- (000C0113) --------------------------------------------------------
//#error "C0113: only 32bit functions can be decompiled (funcsize=0)"

//----- (000C0117) --------------------------------------------------------
//#error "C0117: only 32bit functions can be decompiled (funcsize=0)"

//#error "There were 12 decompilation failure(s) on 2390 function(s)"

//RNC utilites begin


/** Return the big-endian longword at p. */
//----- (00098AE0) --------------------------------------------------------
Bit32u sub_98AE0_blong(Bit8u *p)
{
	Bit32u n;
	n = p[0];
	n = (n << 8) + p[1];
	n = (n << 8) + p[2];
	n = (n << 8) + p[3];
	return n;
	/*int v1; // eax
	char v2; // t0

	v1 = *a1;
	v2 = BYTE1(v1);
	BYTE1(v1) = *a1;
	LOBYTE(v1) = v2;
	v1 = __ROL4__(v1, 16);
	return BYTE1(v1);*/
	/*Bit32u result = (a1[0] << 16) + (a1[1] << 24) + (a1[2] << 8) + (a1[3]);
	//2 je ok
	//3 je ok
	return result;*/

	/*
	1234
	1243
	2431
	2413

	BC000000
	000000BC
	*/
}

//----- (0009894C) --------------------------------------------------------
int sub_9894C_decompress_orig(Bit8u* a1, Bit8u* a2)
{
	//Bit8u* v2; // esi
	//int v3; // eax
	//int v4; // eax
	Bit8u* v5; // esi
	Bit8u* v6; // edx
	Bit8u* v7; // ebx
	Bit8u* v8; // esi
	Bit8u* v9; // edi
	unsigned int i; // ecx
	Bit8u* v11; // esi
	Bit8u* v12; // edi
	Bit8u* v13; // esi
	Bit8u* v14; // edi
	char *v15; // edi
	unsigned __int16 v16; // cx
	unsigned __int16 v17; // ST02_2
	unsigned int v18; // ecx
	int v19; // eax
	unsigned int v20; // ecx
	__int16 v21; // bx
	__int16 v22; // ax
	__int16 v23; // dx
	__int16 v24; // ax

				 //fix it
	v16 = 0;
	v18 = 0;
	v20 = 0;
	//fix it

	if (*(Bit16u *)&(a1[0]) != 0x4e52 || *(Bit16u *)&(a1[2]) != 0x143)//sign
		return 0;

	//LOBYTE(v3) = sub_98AE0_blong(&a1[4]);//279974 - 279ae0
	x_DWORD_E3B40 = sub_98AE0_blong(&a1[4]);//input size
									  //LOBYTE(v4) = sub_98AE0_blong(&a1[4]);
	x_DWORD_E3B44 = sub_98AE0_blong(&a1[8]);//packed size

									  /*x_BYTE_E3B50 = *(x_BYTE *)(a1 + 9);
									  v5 = (x_WORD *)(a1 + 0xa);
									  v6 = x_DWORD_E3B40 + 0x12 + (unsigned int)a1;
									  */
	x_BYTE_E3B50 = *(Bit8u *)(a1 + 0x12);//ok
	v5 = (Bit8u *)(a1 + 0x16);
	v6 = &a1[x_DWORD_E3B44 + 0x12];
	//a2 = (v6 + a1);
	/*
	v5 = (int16*)(_WORD *)(a1 + 0xa);
	v6 = x_DWORD_E3B44 + 0x12;
	v5 = (int16*)(v6 + a1);*/
	/*
	mov     dword_E3B40, eax
	mov     dword_E3B44, eax
	cseg01:00098988                 mov     bl, [esi+5] //esi=pointer+12
	cseg01:0009898B                 mov     byte_E3B50, bl
	cseg01:00098991                 add     esi, 6
	cseg01:00098994                 add     eax, 12h//eax=x_DWORD_E3B44
	cseg01:00098997                 mov     edx, [ebp+arg_0]//buffer1 a1
	cseg01:0009899A                 mov     ebx, [ebp+arg_4]//buffer1 a2
	cseg01:0009899D                 add     edx, eax
	cseg01:0009899F                 cmp     edx, ebx

	byte_E3B50=a1+12

	esi=a1+12+6

	edx=x_DWORD_E3B44+12+a1

	//ebx=a2





	*/

	if (v6 > a2)
	{
		v7 = &a2[x_DWORD_E3B40 + *(Bit8u *)(a1 + 0x10)];
		if (v7 > v6)
		{
			v8 = v6 - 4;
			v9 = v7 - 4;
			for (i = (unsigned int)x_DWORD_E3B44 >> 2; i; --i)
			{
				*(Bit32u*)v9 = *(Bit32u*)v8;
				v8 -= 4;
				v9 -= 4;
			}
			v11 = (v8 + 4);
			v12 = (v9 + 4);
			i = x_DWORD_E3B44 & 3;
			if (x_DWORD_E3B44 & 3)
			{
				v13 = (v11 - 1);
				v14 = (v12 - 1);
				while (i)
				{
					*v14-- = *v13--;
					--i;
				}
				v12 = (v14 + 1);
			}
			v5 = v12;
		}
	}//kopie bez hlavicky
	v15 = (char*)a2;
	x_BYTE_E3B51 = 0;
	x_WORD_E3B4C = *(Bit16u*)v5;
	sub_98B2C(2u, (int)v5);//?crc //proc_16 proc_18 //proc_19
						   /*
						   if (crc_block(v->input, v->input_offset, v->packed_size) != v->packed_crc)
						   return 4;
						   */
						   /*
						   v->unpacked_crc = read_word_be(v->input, &v->input_offset);
						   v->packed_crc = read_word_be(v->input, &v->input_offset);

						   read_byte(v->input, &v->input_offset);
						   read_byte(v->input, &v->input_offset);
						   */
	do
	{
		sub_98BAF_read_huftable((int)v5);//make_huftable(v, v->raw_table, _countof(v->raw_table)); 
		sub_98BAF_read_huftable((int)v5);//make_huftable(v, v->len_table, _countof(v->len_table)); 
		sub_98BAF_read_huftable((int)v5);//make_huftable(v, v->pos_table, _countof(v->pos_table)); 
		x_WORD_E3B4A = sub_98B2C(0x10u, (int)v5);//int subchunks = input_bits_m1(v, 16);
		while (1)//while (subchunks--) 
		{
			sub_98AE9((__int16 *)&unk_E39C0, (int)v5);//uint32 data_length = decode_table_data(v, v->raw_table);
													  //v->processed_size += data_length; 
			if ((x_WORD)v20)//if (data_length) 
			{
				qmemcpy(v15, v5, v20);
				v5 = (Bit8u*)((char *)v5 + v20);
				v15 += v20;
				v21 = *v5;
				v22 = __ROL2__(*v5, x_BYTE_E3B51);
				v23 = (1 << x_BYTE_E3B51) - 1;
				x_WORD_E3B4C &= v23;
				v24 = v22 & v23 | (v5[1] << x_BYTE_E3B51);
				x_WORD_E3B4C |= v21 << x_BYTE_E3B51;
				x_WORD_E3B4E = v24;
			}
			if (!--x_WORD_E3B4A)//if (subchunks) 
				break;
			sub_98AE9((__int16 *)&unk_E3A40, (int)v5);//v->match_offset = decode_table_data(v, v->len_table) + 1; 
			v17 = v16;
			sub_98AE9((__int16 *)&unk_E3AC0, (int)v5);//v->match_count = decode_table_data(v, v->pos_table) + 2;
													  //v->processed_size += v->match_count;
			LOWORD(v18) = v18 + 2;
			v19 = v17;
			LOWORD(v19) = v17 + 1;
			qmemcpy(v15, &v15[-v19], v18);
			//while (v->match_count--)
			//write_decoded_byte(v, v->window[-v->match_offset]);
			v15 += v18;
		}
		--x_BYTE_E3B50;
	} while (x_BYTE_E3B50);//while (v->processed_size < v->input_size) 
	return x_DWORD_E3B40;
}
// E3B40: using guessed type int x_DWORD_E3B40;
// E3B44: using guessed type int x_DWORD_E3B44;
// E3B4A: using guessed type __int16 x_WORD_E3B4A;
// E3B4C: using guessed type __int16 x_WORD_E3B4C;
// E3B4E: using guessed type __int16 x_WORD_E3B4E;
// E3B50: using guessed type char x_BYTE_E3B50;
// E3B51: using guessed type char x_BYTE_E3B51;


typedef struct huftable_s {
	uint32 l1; // +0
	uint16 l2; // +4
	uint32 l3; // +6
	uint16 bit_depth; // +A
} huftable_t;

typedef struct vars_s {
	uint16 max_matches;
	uint16 enc_key;
	uint32 pack_block_size;
	uint16 dict_size;
	uint32 method;
	uint32 pus_mode;
	uint32 input_size;
	uint32 file_size;

	// inner
	uint32 bytes_left;
	uint32 packed_size;
	uint32 processed_size;
	uint32 v7;
	uint32 pack_block_pos;
	uint16 pack_token, bit_count, v11;
	uint16 last_min_offset;
	uint32 v17;
	uint32 pack_block_left_size;
	uint16 match_count;
	uint16 match_offset;
	uint32 v20, v21;
	uint32 bit_buffer;

	uint32 unpacked_size;
	uint32 rnc_data_size;
	uint16 unpacked_crc, unpacked_crc_real;
	uint16 packed_crc;
	uint32 leeway;
	uint32 chunks_count;

	uint8 *mem1;
	uint8 *pack_block_start;
	uint8 *pack_block_max;
	uint8 *pack_block_end;
	uint16 *mem2;
	uint16 *mem3;
	uint16 *mem4;
	uint16 *mem5;

	uint8 *decoded;
	uint8 *window;

	size_t read_start_offset, write_start_offset;
	uint8 *input, *output, *temp;
	size_t input_offset, output_offset, temp_offset;

	uint8 tmp_crc_data[2048];
	huftable_t raw_table[16];
	huftable_t pos_table[16];
	huftable_t len_table[16];
} vars_t;

#define RNC_SIGN 0x524E43 // RNC
#define RNC_HEADER_SIZE 0x12
#define MAX_BUF_SIZE 0x100000

uint8 read_byte(uint8 *buf, size_t *offset)
{
	return buf[(*offset)++];
}

uint16 read_word_be(uint8 *buf, size_t *offset)
{
	uint8 b1 = read_byte(buf, offset);
	uint8 b2 = read_byte(buf, offset);

	return (b1 << 8) | b2;
}

uint32 read_dword_be(uint8 *buf, size_t *offset)
{
	uint16 w1 = read_word_be(buf, offset);
	uint16 w2 = read_word_be(buf, offset);

	return (w1 << 16) | w2;
}

static const uint16 crc_table[] = {
	0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,
	0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
	0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,
	0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,
	0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,
	0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,
	0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,
	0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,
	0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,
	0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,
	0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,
	0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,
	0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,
	0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,
	0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,
	0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,
	0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,
	0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,
	0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,
	0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,
	0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,
	0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,
	0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,
	0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,
	0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,
	0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
	0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,
	0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,
	0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,
	0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
	0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,
	0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
};

uint16 crc_block(uint8 *buf, size_t offset, int size)
{
	uint16 crc = 0;

	while (size--)
	{
		crc ^= read_byte(buf, &offset);
		crc = (crc >> 8) ^ crc_table[crc & 0xFF];
	}

	return crc;
}

void read_buf(uint8 *dest, uint8 *source, size_t *offset, int size)
{
	memmove(dest, &source[*offset], size);
	*offset += size;
}

uint8 read_source_byte(vars_t *v)
{
	if (v->pack_block_start == &v->mem1[0xFFFD])
	{
		int left_size = v->file_size - v->input_offset;

		int size_to_read;
		if (left_size <= 0xFFFD)
			size_to_read = left_size;
		else
			size_to_read = 0xFFFD;

		v->pack_block_start = v->mem1;

		read_buf(v->pack_block_start, v->input, &v->input_offset, size_to_read);

		if (left_size - size_to_read > 2)
			left_size = 2;

		read_buf(&v->mem1[size_to_read], v->input, &v->input_offset, left_size);
		v->input_offset -= left_size;
	}

	return *v->pack_block_start++;
}

uint32 input_bits_m2(vars_t *v, short count)
{
	uint32 bits = 0;

	while (count--)
	{
		if (!v->bit_count)
		{
			v->bit_buffer = read_source_byte(v);
			v->bit_count = 8;
		}

		bits <<= 1;

		if (v->bit_buffer & 0x80)
			bits |= 1;

		v->bit_buffer <<= 1;
		v->bit_count--;
	}

	return bits;
}



uint32 input_bits_m1(vars_t *v, short count)
{
	uint32 bits = 0;
	uint32 prev_bits = 1;

	while (count--)
	{
		if (!v->bit_count)
		{
			uint8 b1 = read_source_byte(v);
			uint8 b2 = read_source_byte(v);
			v->bit_buffer = (v->pack_block_start[1] << 24) | (v->pack_block_start[0] << 16) | (b2 << 8) | b1;

			v->bit_count = 16;
		}

		if (v->bit_buffer & 1)
			bits |= prev_bits;

		v->bit_buffer >>= 1;
		prev_bits <<= 1;
		v->bit_count--;
	}

	return bits;
}

int input_bits(vars_t *v, short count)
{
	if (v->method != 2)
		return input_bits_m1(v, count);
	else
		return input_bits_m2(v, count);
}

void clear_table(huftable_t *data, int count)
{
	for (int i = 0; i < count; ++i)
	{
		data[i].l1 = 0;
		data[i].l2 = 0xFFFF;
		data[i].l3 = 0;
		data[i].bit_depth = 0;
	}
}

uint32 inverse_bits(uint32 value, int count)
{
	int i = 0;
	while (count--)
	{
		i <<= 1;

		if (value & 1)
			i |= 1;

		value >>= 1;
	}

	return i;
}

void proc_20(huftable_t *data, int count)
{
	int val = 0;
	uint32 div = 0x80000000;
	int bits_count = 1;

	while (bits_count <= 16)
	{
		int i = 0;

		while (1)
		{
			if (i >= count)
			{
				bits_count++;
				div >>= 1;
				break;
			}

			if (data[i].bit_depth == bits_count)
			{
				data[i].l3 = inverse_bits(val / div, bits_count);
				val += div;
			}

			i++;
		}
	}
}

void make_huftable(vars_t *v, huftable_t *data, int count)
{
	clear_table(data, count);

	int leaf_nodes = input_bits_m1(v, 5);

	if (leaf_nodes)
	{
		if (leaf_nodes > 16)
			leaf_nodes = 16;

		for (int i = 0; i < leaf_nodes; ++i)
			data[i].bit_depth = input_bits_m1(v, 4);

		proc_20(data, leaf_nodes);
	}
}

uint32 decode_table_data(vars_t *v, huftable_t *data)
{
	uint32 i = 0;

	while (1)
	{
		if (data[i].bit_depth && (data[i].l3 == (v->bit_buffer & ((1 << data[i].bit_depth) - 1))))
		{
			input_bits_m1(v, data[i].bit_depth);

			if (i < 2)
				return i;

			return input_bits_m1(v, i - 1) | (1 << (i - 1));
		}

		i++;
	}
}

void write_buf(uint8 *dest, size_t *offset, uint8 *source, int size)
{
	memmove(&dest[*offset], source, size);
	*offset += size;
}

void write_decoded_byte(vars_t *v, uint8 b)
{
	if (&v->decoded[0xFFFF] == v->window)
	{
		write_buf(v->output, &v->output_offset, &v->decoded[v->dict_size], 0xFFFF - v->dict_size);
		memmove(v->decoded, &v->window[-v->dict_size], v->dict_size);
		v->window = &v->decoded[v->dict_size];
	}

	*v->window++ = b;
	v->unpacked_crc_real = crc_table[(v->unpacked_crc_real ^ b) & 0xFF] ^ (v->unpacked_crc_real >> 8);
}

void ror_w(uint16 *x)
{
	if (*x & 1)
		*x = 0x8000 | (*x >> 1);
	else
		*x >>= 1;
}

int unpack_data_m1(vars_t *v)
{
	while (v->processed_size < v->input_size)
	{
		make_huftable(v, v->raw_table, _countof(v->raw_table));
		make_huftable(v, v->len_table, _countof(v->len_table));
		make_huftable(v, v->pos_table, _countof(v->pos_table));

		int subchunks = input_bits_m1(v, 16);

		while (subchunks--)
		{
			uint32 data_length = decode_table_data(v, v->raw_table);
			v->processed_size += data_length;

			if (data_length)
			{
				while (data_length--)
					write_decoded_byte(v, (v->enc_key ^ read_source_byte(v)) & 0xFF);

				ror_w(&v->enc_key);

				v->bit_buffer = (((v->pack_block_start[2] << 16) | (v->pack_block_start[1] << 8) | v->pack_block_start[0]) << v->bit_count) | (v->bit_buffer & ((1 << v->bit_count) - 1));
			}

			if (subchunks)
			{
				v->match_offset = decode_table_data(v, v->len_table) + 1;
				v->match_count = decode_table_data(v, v->pos_table) + 2;
				v->processed_size += v->match_count;

				while (v->match_count--)
					write_decoded_byte(v, v->window[-v->match_offset]);
			}
		}
	}

	write_buf(v->output, &v->output_offset, &v->decoded[v->dict_size], v->window - &v->decoded[v->dict_size]);
	return 0;
}

void decode_match_count(vars_t *v)
{
	v->match_count = input_bits_m2(v, 1) + 4;

	if (input_bits_m2(v, 1))
		v->match_count = ((v->match_count - 1) << 1) + input_bits_m2(v, 1);
}

void decode_match_offset(vars_t *v)
{
	v->match_offset = 0;
	if (input_bits_m2(v, 1))
	{
		v->match_offset = input_bits_m2(v, 1);

		if (input_bits_m2(v, 1))
		{
			v->match_offset = ((v->match_offset << 1) | input_bits_m2(v, 1)) | 4;

			if (!input_bits_m2(v, 1))
				v->match_offset = (v->match_offset << 1) | input_bits_m2(v, 1);
		}
		else if (!v->match_offset)
			v->match_offset = input_bits_m2(v, 1) + 2;
	}

	v->match_offset = ((v->match_offset << 8) | read_source_byte(v)) + 1;
}

int unpack_data_m2(vars_t *v)
{
	while (v->processed_size < v->input_size)
	{
		while (1)
		{
			if (!input_bits_m2(v, 1))
			{
				write_decoded_byte(v, (v->enc_key ^ read_source_byte(v)) & 0xFF);

				ror_w(&v->enc_key);

				v->processed_size++;
			}
			else
			{
				if (input_bits_m2(v, 1))
				{
					if (input_bits_m2(v, 1))
					{
						if (input_bits_m2(v, 1))
						{
							v->match_count = read_source_byte(v) + 8;

							if (v->match_count == 8)
							{
								input_bits_m2(v, 1);
								break;
							}
						}
						else
							v->match_count = 3;

						decode_match_offset(v);
					}
					else
					{
						v->match_count = 2;
						v->match_offset = read_source_byte(v) + 1;
					}

					v->processed_size += v->match_count;

					while (v->match_count--)
						write_decoded_byte(v, v->window[-v->match_offset]);
				}
				else
				{
					decode_match_count(v);

					if (v->match_count != 9)
					{
						decode_match_offset(v);
						v->processed_size += v->match_count;

						while (v->match_count--)
							write_decoded_byte(v, v->window[-v->match_offset]);
					}
					else
					{
						uint32 data_length = (input_bits_m2(v, 4) << 2) + 12;
						v->processed_size += data_length;

						while (data_length--)
							write_decoded_byte(v, (v->enc_key ^ read_source_byte(v)) & 0xFF);

						ror_w(&v->enc_key);
					}
				}
			}
		}
	}

	write_buf(v->output, &v->output_offset, &v->decoded[v->dict_size], v->window - &v->decoded[v->dict_size]);
	return 0;
}

int do_unpack_data(vars_t *v)
{
	int start_pos = v->input_offset;

	uint32 sign = read_dword_be(v->input, &v->input_offset);
	if ((sign >> 8) != RNC_SIGN)
		return 6;

	v->method = sign & 3;
	v->input_size = read_dword_be(v->input, &v->input_offset);
	v->packed_size = read_dword_be(v->input, &v->input_offset);
	if (v->file_size < v->packed_size)
		return 7;
	v->unpacked_crc = read_word_be(v->input, &v->input_offset);
	v->packed_crc = read_word_be(v->input, &v->input_offset);

	/*v->leeway = */read_byte(v->input, &v->input_offset);
	/*v->chunks_count = */read_byte(v->input, &v->input_offset);

	if (crc_block(v->input, v->input_offset, v->packed_size) != v->packed_crc)
		return 4;

	v->mem1 = (uint8*)malloc(0xFFFF);
	v->decoded = (uint8*)malloc(0xFFFF);
	v->pack_block_start = &v->mem1[0xFFFD];
	v->window = &v->decoded[v->dict_size];

	v->unpacked_crc_real = 0;
	v->bit_count = 0;
	v->bit_buffer = 0;
	v->processed_size = 0;

	uint16 specified_key = v->enc_key;

	int error_code = 0;
	if (input_bits(v, 1) && !v->pus_mode)
		error_code = 9;

	if (!error_code)
	{
		if (input_bits(v, 1) && !v->enc_key) // key is needed, but not specified as argument
			error_code = 10;
	}

	if (!error_code)
	{
		switch (v->method)
		{
		case 1: error_code = unpack_data_m1(v); break;
		case 2: error_code = unpack_data_m2(v); break;
		}
	}

	v->enc_key = specified_key;

	free(v->mem1);
	free(v->decoded);

	v->input_offset = start_pos + v->packed_size + RNC_HEADER_SIZE;

	if (error_code)
		return error_code;

	if (v->unpacked_crc != v->unpacked_crc_real)
		return 5;

	return 0;
}

int do_unpack(vars_t *v)
{
	v->packed_size = v->file_size;

	if (v->file_size < RNC_HEADER_SIZE)
		return 6;

	int result = do_unpack_data(v); // data
	if (result == 0)return v->input_size;
	return -result;
}

vars_t *init_vars()
{
	vars_t *v = (vars_t*)malloc(sizeof(vars_t));
	v->enc_key = 0;
	v->max_matches = 0x1000;
	v->unpacked_crc_real = 0;
	v->pack_block_size = 0x3000;
	v->dict_size = 0xFFFF;
	v->method = 1;
	v->pus_mode = 0;

	v->read_start_offset = 0;
	v->write_start_offset = 0;
	v->input_offset = 0;
	v->output_offset = 0;
	v->temp_offset = 0;

	memset(v->tmp_crc_data, 0, sizeof(v->tmp_crc_data));
	memset(v->raw_table, 0, sizeof(v->raw_table));
	memset(v->pos_table, 0, sizeof(v->pos_table));
	memset(v->len_table, 0, sizeof(v->len_table));

	return v;
}

int sub_9894C_decompress(Bit8u* a1, Bit8u* a2) {
	vars_t *v = init_vars();
	if (v->method == 1)
	{
		if (v->dict_size > 0x8000)
			v->dict_size = 0x8000;
		v->max_matches = 0x1000;
	}
	else if (v->method == 2)
	{
		if (v->dict_size > 0x1000)
			v->dict_size = 0x1000;
		v->max_matches = 0xFF;
	}

	v->file_size = MAX_BUF_SIZE;
	v->input = (uint8*)malloc(MAX_BUF_SIZE);

	Bit32u signature = a1[0] + (a1[1] << 8) + (a1[2] << 16);
	if (signature == 0x434e52)
	{
		Bit32u inputsize = a1[11] + (a1[10] << 8) + (a1[9] << 16) + (a1[8] << 24);
		memmove(v->input, a1, inputsize + 0x12);
	}
	else
	{
		v->input[0] = 0;
	}
	//v->input = a1;

	v->output = a2;
	v->temp = (uint8*)malloc(MAX_BUF_SIZE);

	int error_code = 0;
	/*switch (v->pus_mode)
	{
	case 0: error_code = do_pack(v); break;
	case 1: error_code = do_unpack(v); break;
	case 2: error_code = do_search(v); break;
	}*/
	error_code = do_unpack(v);

	if (v->pus_mode == 2)
	{
		free(v->input);
		free(v->output);
		free(v->temp);
		free(v->input);
		free(v);

		return error_code;
	}

	/*if (error_code)
	 {
		switch (error_code) {
		case 4: printf("Corrupted input data.\n"); break;
		case 5: printf("CRC check failed.\n"); break;
		case 6:
		case 7:
			printf("Wrong RNC header.\n"); break;
		case 10: printf("No RNC archives were found.\n"); break;
		default: printf("Cannot process file. Error code: %x\n", error_code); break;
		}
	}*/

	//free(v->input);
	//free(v->output);
	free(v->temp);
	free(v);
	if (error_code == -6)return 0;
	//if (error_code == 0)return 0;
	return error_code;
}

//RNC utilites END