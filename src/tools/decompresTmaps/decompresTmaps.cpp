// decompresTmaps.cpp : Tento soubor obsahuje funkci main. Provádění programu se tam zahajuje a ukončuje.
//

#include <iostream>

typedef unsigned char Bit8u;
typedef          int    int32;
typedef unsigned int Bit32u;
typedef   signed int Bit32s;
typedef          char   int8;
typedef   signed char   sint8;
typedef unsigned char   uint8;
typedef          short  int16;
typedef   signed short  sint16;
typedef unsigned short  uint16;
typedef          int    int32;
typedef   signed int    sint32;
typedef unsigned int    uint32;
#define x_DWORD int32
#define x_WORD int16
#define x_BYTE int8
typedef unsigned short Bit16u;

#define RNC_SIGN 0x524E43 // RNC
#define RNC_HEADER_SIZE 0x12
#define MAX_BUF_SIZE 0x100000


FILE* x_DWORD_DB73C_tmapsfile;//x_DWORD_DAF50[0x7ec]
Bit8u* TMAPS00TAB_BEGIN_BUFFER = 0;//2c7ed0
Bit32s mylseek(FILE* filedesc, x_DWORD position, char type) {
	return fseek(filedesc, position, type);
};
x_DWORD x_lseek(FILE* filedesc, x_DWORD position, char type) {
	return mylseek(filedesc, position, type);
};
int sub_9891E_seek(FILE* filedecs, int position, char type)//27991e
{
	return x_lseek(filedecs, position, type);
}
// AA7C0: using guessed type x_DWORD lseek(x_DWORD, x_DWORD, char);
size_t x_read(FILE* descriptor, Bit8u* data, Bit32u size) {
	size_t result = fread(data, 1, size, descriptor);
	return result;
};
size_t sub_988A7_read(FILE* a1, Bit8u* a2, int a3)//2798a7
{

	return x_read(a1, a2, a3);
}

typedef struct huftable_s {
	uint32 l1; // +0
	uint16 l2; // +4
	uint32 l3; // +6
	uint16 bit_depth; // +A
} huftable_t;

typedef struct vars_s {
	uint16 max_matches;
	uint16 enc_key;
	uint32 pack_block_size;
	uint16 dict_size;
	uint32 method;
	uint32 pus_mode;
	uint32 input_size;
	uint32 file_size;

	// inner
	uint32 bytes_left;
	uint32 packed_size;
	uint32 processed_size;
	uint32 v7;
	uint32 pack_block_pos;
	uint16 pack_token, bit_count, v11;
	uint16 last_min_offset;
	uint32 v17;
	uint32 pack_block_left_size;
	uint16 match_count;
	uint16 match_offset;
	uint32 v20, v21;
	uint32 bit_buffer;

	uint32 unpacked_size;
	uint32 rnc_data_size;
	uint16 unpacked_crc, unpacked_crc_real;
	uint16 packed_crc;
	uint32 leeway;
	uint32 chunks_count;

	uint8* mem1;
	uint8* pack_block_start;
	uint8* pack_block_max;
	uint8* pack_block_end;
	uint16* mem2;
	uint16* mem3;
	uint16* mem4;
	uint16* mem5;

	uint8* decoded;
	uint8* window;

	size_t read_start_offset, write_start_offset;
	uint8* input, * output, * temp;
	size_t input_offset, output_offset, temp_offset;

	uint8 tmp_crc_data[2048];
	huftable_t raw_table[16];
	huftable_t pos_table[16];
	huftable_t len_table[16];
} vars_t;

#define RNC_SIGN 0x524E43 // RNC
#define RNC_HEADER_SIZE 0x12
#define MAX_BUF_SIZE 0x100000

uint8 read_byte(uint8* buf, size_t* offset)
{
	return buf[(*offset)++];
}

uint16 read_word_be(uint8* buf, size_t* offset)
{
	uint8 b1 = read_byte(buf, offset);
	uint8 b2 = read_byte(buf, offset);

	return (b1 << 8) | b2;
}

uint32 read_dword_be(uint8 * buf, size_t * offset)
{
	uint16 w1 = read_word_be(buf, offset);
	uint16 w2 = read_word_be(buf, offset);

	return (w1 << 16) | w2;
}

static const uint16 crc_table[] = {
	0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,
	0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
	0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,
	0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,
	0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,
	0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,
	0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,
	0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,
	0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,
	0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,
	0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,
	0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,
	0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,
	0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,
	0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,
	0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,
	0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,
	0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,
	0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,
	0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,
	0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,
	0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,
	0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,
	0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,
	0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,
	0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
	0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,
	0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,
	0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,
	0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
	0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,
	0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
};

uint16 crc_block(uint8 * buf, size_t offset, int size)
{
	uint16 crc = 0;

	while (size--)
	{
		crc ^= read_byte(buf, &offset);
		crc = (crc >> 8) ^ crc_table[crc & 0xFF];
	}

	return crc;
}

void read_buf(uint8 * dest, uint8 * source, size_t * offset, int size)
{
	memmove(dest, &source[*offset], size);
	*offset += size;
}

uint8 read_source_byte(vars_t * v)
{
	if (v->pack_block_start == &v->mem1[0xFFFD])
	{
		int left_size = v->file_size - v->input_offset;

		int size_to_read;
		if (left_size <= 0xFFFD)
			size_to_read = left_size;
		else
			size_to_read = 0xFFFD;

		v->pack_block_start = v->mem1;

		read_buf(v->pack_block_start, v->input, &v->input_offset, size_to_read);

		if (left_size - size_to_read > 2)
			left_size = 2;

		read_buf(&v->mem1[size_to_read], v->input, &v->input_offset, left_size);
		v->input_offset -= left_size;
	}

	return *v->pack_block_start++;
}

uint32 input_bits_m2(vars_t * v, short count)
{
	uint32 bits = 0;

	while (count--)
	{
		if (!v->bit_count)
		{
			v->bit_buffer = read_source_byte(v);
			v->bit_count = 8;
		}

		bits <<= 1;

		if (v->bit_buffer & 0x80)
			bits |= 1;

		v->bit_buffer <<= 1;
		v->bit_count--;
	}

	return bits;
}



uint32 input_bits_m1(vars_t * v, short count)
{
	uint32 bits = 0;
	uint32 prev_bits = 1;

	while (count--)
	{
		if (!v->bit_count)
		{
			uint8 b1 = read_source_byte(v);
			uint8 b2 = read_source_byte(v);
			v->bit_buffer = (v->pack_block_start[1] << 24) | (v->pack_block_start[0] << 16) | (b2 << 8) | b1;

			v->bit_count = 16;
		}

		if (v->bit_buffer & 1)
			bits |= prev_bits;

		v->bit_buffer >>= 1;
		prev_bits <<= 1;
		v->bit_count--;
	}

	return bits;
}

int input_bits(vars_t * v, short count)
{
	if (v->method != 2)
		return input_bits_m1(v, count);
	else
		return input_bits_m2(v, count);
}

void clear_table(huftable_t * data, int count)
{
	for (int i = 0; i < count; ++i)
	{
		data[i].l1 = 0;
		data[i].l2 = 0xFFFF;
		data[i].l3 = 0;
		data[i].bit_depth = 0;
	}
}

uint32 inverse_bits(uint32 value, int count)
{
	int i = 0;
	while (count--)
	{
		i <<= 1;

		if (value & 1)
			i |= 1;

		value >>= 1;
	}

	return i;
}

void proc_20(huftable_t * data, int count)
{
	int val = 0;
	uint32 div = 0x80000000;
	int bits_count = 1;

	while (bits_count <= 16)
	{
		int i = 0;

		while (1)
		{
			if (i >= count)
			{
				bits_count++;
				div >>= 1;
				break;
			}

			if (data[i].bit_depth == bits_count)
			{
				data[i].l3 = inverse_bits(val / div, bits_count);
				val += div;
			}

			i++;
		}
	}
}

void make_huftable(vars_t * v, huftable_t * data, int count)
{
	clear_table(data, count);

	int leaf_nodes = input_bits_m1(v, 5);

	if (leaf_nodes)
	{
		if (leaf_nodes > 16)
			leaf_nodes = 16;

		for (int i = 0; i < leaf_nodes; ++i)
			data[i].bit_depth = input_bits_m1(v, 4);

		proc_20(data, leaf_nodes);
	}
}

uint32 decode_table_data(vars_t * v, huftable_t * data)
{
	uint32 i = 0;

	while (1)
	{
		if (data[i].bit_depth && (data[i].l3 == (v->bit_buffer & ((1 << data[i].bit_depth) - 1))))
		{
			input_bits_m1(v, data[i].bit_depth);

			if (i < 2)
				return i;

			return input_bits_m1(v, i - 1) | (1 << (i - 1));
		}

		i++;
	}
}

void write_buf(uint8 * dest, size_t * offset, uint8 * source, int size)
{
	memmove(&dest[*offset], source, size);
	*offset += size;
}

void write_decoded_byte(vars_t * v, uint8 b)
{
	if (&v->decoded[0xFFFF] == v->window)
	{
		write_buf(v->output, &v->output_offset, &v->decoded[v->dict_size], 0xFFFF - v->dict_size);
		memmove(v->decoded, &v->window[-v->dict_size], v->dict_size);
		v->window = &v->decoded[v->dict_size];
	}

	*v->window++ = b;
	v->unpacked_crc_real = crc_table[(v->unpacked_crc_real ^ b) & 0xFF] ^ (v->unpacked_crc_real >> 8);
}

void ror_w(uint16 * x)
{
	if (*x & 1)
		* x = 0x8000 | (*x >> 1);
	else
		*x >>= 1;
}

int unpack_data_m1(vars_t * v)
{
	while (v->processed_size < v->input_size)
	{
		make_huftable(v, v->raw_table, _countof(v->raw_table));
		make_huftable(v, v->len_table, _countof(v->len_table));
		make_huftable(v, v->pos_table, _countof(v->pos_table));

		int subchunks = input_bits_m1(v, 16);

		while (subchunks--)
		{
			uint32 data_length = decode_table_data(v, v->raw_table);
			v->processed_size += data_length;

			if (data_length)
			{
				while (data_length--)
					write_decoded_byte(v, (v->enc_key ^ read_source_byte(v)) & 0xFF);

				ror_w(&v->enc_key);

				v->bit_buffer = (((v->pack_block_start[2] << 16) | (v->pack_block_start[1] << 8) | v->pack_block_start[0]) << v->bit_count) | (v->bit_buffer & ((1 << v->bit_count) - 1));
			}

			if (subchunks)
			{
				v->match_offset = decode_table_data(v, v->len_table) + 1;
				v->match_count = decode_table_data(v, v->pos_table) + 2;
				v->processed_size += v->match_count;

				while (v->match_count--)
					write_decoded_byte(v, v->window[-v->match_offset]);
			}
		}
	}

	write_buf(v->output, &v->output_offset, &v->decoded[v->dict_size], v->window - &v->decoded[v->dict_size]);
	return 0;
}

void decode_match_count(vars_t * v)
{
	v->match_count = input_bits_m2(v, 1) + 4;

	if (input_bits_m2(v, 1))
		v->match_count = ((v->match_count - 1) << 1) + input_bits_m2(v, 1);
}

void decode_match_offset(vars_t * v)
{
	v->match_offset = 0;
	if (input_bits_m2(v, 1))
	{
		v->match_offset = input_bits_m2(v, 1);

		if (input_bits_m2(v, 1))
		{
			v->match_offset = ((v->match_offset << 1) | input_bits_m2(v, 1)) | 4;

			if (!input_bits_m2(v, 1))
				v->match_offset = (v->match_offset << 1) | input_bits_m2(v, 1);
		}
		else if (!v->match_offset)
			v->match_offset = input_bits_m2(v, 1) + 2;
	}

	v->match_offset = ((v->match_offset << 8) | read_source_byte(v)) + 1;
}

int unpack_data_m2(vars_t * v)
{
	while (v->processed_size < v->input_size)
	{
		while (1)
		{
			if (!input_bits_m2(v, 1))
			{
				write_decoded_byte(v, (v->enc_key ^ read_source_byte(v)) & 0xFF);

				ror_w(&v->enc_key);

				v->processed_size++;
			}
			else
			{
				if (input_bits_m2(v, 1))
				{
					if (input_bits_m2(v, 1))
					{
						if (input_bits_m2(v, 1))
						{
							v->match_count = read_source_byte(v) + 8;

							if (v->match_count == 8)
							{
								input_bits_m2(v, 1);
								break;
							}
						}
						else
							v->match_count = 3;

						decode_match_offset(v);
					}
					else
					{
						v->match_count = 2;
						v->match_offset = read_source_byte(v) + 1;
					}

					v->processed_size += v->match_count;

					while (v->match_count--)
						write_decoded_byte(v, v->window[-v->match_offset]);
				}
				else
				{
					decode_match_count(v);

					if (v->match_count != 9)
					{
						decode_match_offset(v);
						v->processed_size += v->match_count;

						while (v->match_count--)
							write_decoded_byte(v, v->window[-v->match_offset]);
					}
					else
					{
						uint32 data_length = (input_bits_m2(v, 4) << 2) + 12;
						v->processed_size += data_length;

						while (data_length--)
							write_decoded_byte(v, (v->enc_key ^ read_source_byte(v)) & 0xFF);

						ror_w(&v->enc_key);
					}
				}
			}
		}
	}

	write_buf(v->output, &v->output_offset, &v->decoded[v->dict_size], v->window - &v->decoded[v->dict_size]);
	return 0;
}

int do_unpack_data(vars_t* v)
{
	int start_pos = v->input_offset;

	uint32 sign = read_dword_be(v->input, &v->input_offset);
	if ((sign >> 8) != RNC_SIGN)
		return 6;

	v->method = sign & 3;
	v->input_size = read_dword_be(v->input, &v->input_offset);
	v->packed_size = read_dword_be(v->input, &v->input_offset);
	if (v->file_size < v->packed_size)
		return 7;
	v->unpacked_crc = read_word_be(v->input, &v->input_offset);
	v->packed_crc = read_word_be(v->input, &v->input_offset);

	/*v->leeway = */read_byte(v->input, &v->input_offset);
	/*v->chunks_count = */read_byte(v->input, &v->input_offset);

	if (crc_block(v->input, v->input_offset, v->packed_size) != v->packed_crc)
		return 4;

	v->mem1 = (uint8*)malloc(0xFFFF);
	v->decoded = (uint8*)malloc(0xFFFF);
	v->pack_block_start = &v->mem1[0xFFFD];
	v->window = &v->decoded[v->dict_size];

	v->unpacked_crc_real = 0;
	v->bit_count = 0;
	v->bit_buffer = 0;
	v->processed_size = 0;

	uint16 specified_key = v->enc_key;

	int error_code = 0;
	if (input_bits(v, 1) && !v->pus_mode)
		error_code = 9;

	if (!error_code)
	{
		if (input_bits(v, 1) && !v->enc_key) // key is needed, but not specified as argument
			error_code = 10;
	}

	if (!error_code)
	{
		switch (v->method)
		{
		case 1: error_code = unpack_data_m1(v); break;
		case 2: error_code = unpack_data_m2(v); break;
		}
	}

	v->enc_key = specified_key;

	free(v->mem1);
	free(v->decoded);

	v->input_offset = start_pos + v->packed_size + RNC_HEADER_SIZE;

	if (error_code)
		return error_code;

	if (v->unpacked_crc != v->unpacked_crc_real)
		return 5;

	return 0;
}

int do_unpack(vars_t* v)
{
	v->packed_size = v->file_size;

	if (v->file_size < RNC_HEADER_SIZE)
		return 6;

	int result = do_unpack_data(v); // data
	if (result == 0)return v->input_size;
	return -result;
}

vars_t* init_vars()
{
	vars_t* v = (vars_t*)malloc(sizeof(vars_t));
	v->enc_key = 0;
	v->max_matches = 0x1000;
	v->unpacked_crc_real = 0;
	v->pack_block_size = 0x3000;
	v->dict_size = 0xFFFF;
	v->method = 1;
	v->pus_mode = 0;

	v->read_start_offset = 0;
	v->write_start_offset = 0;
	v->input_offset = 0;
	v->output_offset = 0;
	v->temp_offset = 0;

	memset(v->tmp_crc_data, 0, sizeof(v->tmp_crc_data));
	memset(v->raw_table, 0, sizeof(v->raw_table));
	memset(v->pos_table, 0, sizeof(v->pos_table));
	memset(v->len_table, 0, sizeof(v->len_table));

	return v;
}

int sub_9894C_decompress(Bit8u* a1, Bit8u* a2) {
	vars_t* v = init_vars();
	if (v->method == 1)
	{
		if (v->dict_size > 0x8000)
			v->dict_size = 0x8000;
		v->max_matches = 0x1000;
	}
	else if (v->method == 2)
	{
		if (v->dict_size > 0x1000)
			v->dict_size = 0x1000;
		v->max_matches = 0xFF;
	}

	v->file_size = MAX_BUF_SIZE;
	v->input = (uint8*)malloc(MAX_BUF_SIZE);

	Bit32u signature = a1[0] + (a1[1] << 8) + (a1[2] << 16);
	if (signature == 0x434e52)
	{
		Bit32u inputsize = a1[11] + (a1[10] << 8) + (a1[9] << 16) + (a1[8] << 24);
		memmove(v->input, a1, inputsize + 0x12);
	}
	else
	{
		v->input[0] = 0;
	}
	//v->input = a1;

	v->output = a2;
	v->temp = (uint8*)malloc(MAX_BUF_SIZE);

	int error_code = 0;
	/*switch (v->pus_mode)
	{
	case 0: error_code = do_pack(v); break;
	case 1: error_code = do_unpack(v); break;
	case 2: error_code = do_search(v); break;
	}*/
	error_code = do_unpack(v);

	if (v->pus_mode == 2)
	{
		free(v->input);
		free(v->output);
		free(v->temp);
		free(v->input);
		free(v);

		return error_code;
	}

	/*if (error_code)
	 {
		switch (error_code) {
		case 4: printf("Corrupted input data.\n"); break;
		case 5: printf("CRC check failed.\n"); break;
		case 6:
		case 7:
			printf("Wrong RNC header.\n"); break;
		case 10: printf("No RNC archives were found.\n"); break;
		default: printf("Cannot process file. Error code: %x\n", error_code); break;
		}
	}*/

	//free(v->input);
	//free(v->output);
	free(v->temp);
	free(v);
	if (error_code == -6)return 0;
	//if (error_code == 0)return 0;
	return error_code;
}
int sub_70C60_decompress_tmap(unsigned __int16 a1, Bit8u* a2)//251c60
{
	//int v2; // edi
	int v3; // ebx
	int result; // eax

	if (x_DWORD_DB73C_tmapsfile == NULL)
		return (int)x_DWORD_DB73C_tmapsfile;
	//v2 = 10 * a1;
	sub_9891E_seek(x_DWORD_DB73C_tmapsfile, *(x_DWORD*)(10 * a1 + TMAPS00TAB_BEGIN_BUFFER + 4), 0);//lseek
	v3 = *(Bit32u*)& TMAPS00TAB_BEGIN_BUFFER[10 * (a1 + 1) + 4] - *(Bit32u*)& TMAPS00TAB_BEGIN_BUFFER[10 * a1 + 4];
	if (sub_988A7_read(x_DWORD_DB73C_tmapsfile, a2, v3) != v3)
		return -1;
	result = sub_9894C_decompress(a2, a2);
	if (result >= 0)
	{
		if (!result)
			result = v3;
	}
	else
	{
		printf("ERROR decompressing tmap%03d\n");
		result = -2;
	}
	return result;
}

signed int sub_71CD0(int a1)//252cd0
{
	int i; // edx

	for (i = 0; (signed __int16)i < (signed int) * (unsigned __int16*)(a1 + 22); i++)
	{
		if (!*(x_DWORD*)(14 * (signed __int16)i + *(x_DWORD*)(a1 + 8) + 4))
			return i;
	}
	return -1;
}

int sub_71E70(int a1, unsigned int a2, __int16 a3)//252e70
{
	signed __int16 v3; // si
	signed __int16 v4; // ax
	signed __int16 v5; // dx
	int v6; // ecx
	int v7; // eax
	int result; // eax

	v3 = -1;
	if (a2 < *(x_DWORD*)(a1 + 4))
	{
		v4 = sub_71CD0(a1);
		v5 = v4;
		v6 = v4;
		v3 = v4;
		if (v4 > -1)
		{
			v7 = 14 * v4;
			*(x_WORD*)(*(x_DWORD*)(a1 + 8) + v7 + 10) = v5;
			*(x_DWORD*)(*(x_DWORD*)(a1 + 8) + v7 + 4) = a2;
			*(x_DWORD*)(*(x_DWORD*)(a1 + 8) + v7) = *(x_DWORD*)a1 + *(x_DWORD*)(a1 + 16) - *(x_DWORD*)(a1 + 4);
			*(x_WORD*)(*(x_DWORD*)(a1 + 8) + v7 + 12) = a3;
			*(x_DWORD*)(a1 + 4) -= a2;
			*(x_WORD*)(*(x_DWORD*)(a1 + 8) + v7 + 8) = *(x_WORD*)(a1 + 20);
			*(x_DWORD*)(*(x_DWORD*)(a1 + 12) + 4 * (unsigned __int16)(*(x_WORD*)(a1 + 20))++) = *(x_DWORD*)(a1 + 8) + 14 * v6;
		}
	}
	if (v3 <= -1)
		result = 0;
	else
		result = 14 * v3 + *(x_DWORD*)(a1 + 8);
	return result;
}

int x_DWORD_F66F0[504]; // idb//2c76f0
int x_DWORD_F5730[504]; // idb
int x_DWORD_F5F10[504]; // idb
int x_DWORD_E9C28; // weak
int x_DWORD_E9C08; // weak

int sub_721C0(unsigned __int16* a1, int* a2, __int16 a3)//2531c0
{
	signed __int16 v3; // cx
	signed __int16 v4; // si
	signed __int16 i; // bx
	x_DWORD* v6; // edx
	int v7; // ebx
	int v8; // ecx
	__int16 v9; // ST08_2
	int v10; // edx
	signed __int16 v12; // [esp+Ch] [ebp-4h]

	v3 = -1;
	v4 = -1;
	if (!*a1)
		return 0;
	for (i = 0; i < (signed int)* a1; i++)
	{
		v6 = (x_DWORD*)(28 * i + *(x_DWORD*)(a1 + 1));
		if (v6[1])
		{
			if (!*v6)
				v4 = i;
		}
		else
		{
			v3 = i;
		}
	}
	v12 = v3 <= 0 ? v4 : v3;
	if (v12 <= -1)
		return 0;
	v7 = *a2;
	v8 = *(unsigned __int16*)(*a2 + 4) * *(unsigned __int16*)(*a2 + 2);
	v9 = *(x_WORD*)(v8 + *a2 + 6);
	v10 = 28 * v12;
	*(x_DWORD*)(v10 + *(x_DWORD*)(a1 + 1) + 4) = (x_DWORD)a2;
	*(x_WORD*)(v10 + *(x_DWORD*)(a1 + 1) + 12) = 6;
	*(x_WORD*)(v10 + *(x_DWORD*)(a1 + 1) + 14) = v8 + 6;
	*(x_WORD*)(v10 + *(x_DWORD*)(a1 + 1) + 16) = v9;
	*(x_WORD*)(v10 + *(x_DWORD*)(a1 + 1) + 18) = *(x_WORD*)(v7 + 2);
	*(x_WORD*)(v10 + *(x_DWORD*)(a1 + 1) + 20) = *(x_WORD*)(v7 + 4);
	*(x_DWORD*)(v10 + *(x_DWORD*)(a1 + 1) + 8) = v8 + 6;
	*(x_WORD*)(v10 + *(x_DWORD*)(a1 + 1) + 22) = 1;
	*(x_DWORD*)(v10 + *(x_DWORD*)(a1 + 1)) = 1;
	*(x_WORD*)(v10 + *(x_DWORD*)(a1 + 1) + 24) = v12;
	*(x_WORD*)(v10 + *(x_DWORD*)(a1 + 1) + 26) = a3;
	return v10 + *(x_DWORD*)(a1 + 1);
}

void sub_70F50(unsigned __int16 a1)//251f50
{
	int index; // eax
	unsigned __int16 v2; // bx
	unsigned __int16 i; // si
	int v4; // edi
	int v5; // [esp+0h] [ebp-Ch]
	int v6; // [esp+8h] [ebp-4h]

	v5 = 0;// x_D41A0_BYTEARRAY_4_struct.byteindex_26;
	//index = (int)TMAPS00TAB_BEGIN_BUFFER;
	v2 = *(x_WORD*)(10 * a1 + TMAPS00TAB_BEGIN_BUFFER + 8);
	for (i = *(x_WORD*)(10 * a1 + TMAPS00TAB_BEGIN_BUFFER + 8); i < 0x1F8u; i++)
	{
		index = 10 * i + (int)TMAPS00TAB_BEGIN_BUFFER;
		if (v2 != *(x_WORD*)(index + 8))
			break;
		v6 = i;
		if (!x_DWORD_F66F0[i])
		{
			index = sub_71E70(x_DWORD_E9C28, (unsigned __int16)(4 * ((unsigned int)(*(x_DWORD*)index + 13) >> 2)), i);
			v4 = index;
			if (index)
			{
				index = sub_70C60_decompress_tmap(i, *(Bit8u * *)index);
				if (index != -1)
				{
					x_DWORD_F5F10[v6] = v4;
					x_DWORD_F66F0[v6] = v4;
					x_DWORD_F5730[v6] = v5;
					index = x_DWORD_F66F0[v6];
					if (**(x_BYTE * *)index & 1)
						index = sub_721C0((unsigned __int16*)x_DWORD_E9C08, (int*)index, i);
					if (v2 < 0x1E0u)
					{
						if (v2 != 311)
							continue;
					LABEL_14:
						index = *(x_DWORD*)x_DWORD_F66F0[i];
						*(x_BYTE*)index |= 0x20u;
						continue;
					}
					if (v2 <= 0x1E0u || v2 >= 0x1E8u && (v2 <= 0x1E8u || v2 == 496))
						goto LABEL_14;
				}
			}
		}
	}
	//	return result;
}

char printbuffer[512];
FILE* x_DWORD_DB740_tmaps00file;//x_DWORD_DAF50[0x7f0]
FILE* x_DWORD_DB744_tmaps10file;//x_DWORD_DAF50[0x7f4]
FILE* x_DWORD_DB748_tmaps20file;//x_DWORD_DAF50[0x7f8]
int myclose(FILE* descriptor) {
	return fclose(descriptor);
};
FILE* mycreate(char* path, Bit32u flags) {
	FILE* fp;
	char path2[512] = "\0";
	//pathfix(path, path2);//only for DOSBOX version
	//fp = fopen(path2, "wb+");
	fopen_s(&fp,path, "wb+");
	return fp;
};
FILE* x_creat(char* path, Bit32u flags) {
	return mycreate(path, flags);
	/*FILE *fp;
	char path2[512] = "\0";
	pathfix(path, path2);//only for DOSBOX version
	fp = fopen(path2, "wb+");
	return fp;*/
};// weak
int x_close(FILE* descriptor) {
	return myclose(descriptor);
};
FILE* myopen(char* path, int pmode, Bit32u flags) {
	//bool localDrive::FileOpen(DOS_File * * file, const char * name, Bit32u flags) {
	const char* type;
	if ((pmode == 0x222) && (flags == 0x40))type = "rb+";
	else if ((pmode == 0x200) && (flags == 0x40))type = "rb+";
	else
		exit(1);//error - DOSSetError(DOSERR_ACCESS_CODE_INVALID);
	FILE * fp;
	char path2[512] = "\0";
	//pathfix(path, path2);//only for DOSBOX version
	//if(file_exists(path2))

	fopen_s(&fp, path, type);
	return fp;
};
FILE* x_sopen(char* path, int pmode, Bit32u flags) {
	return myopen(path, pmode, flags);
};
FILE* sub_98817_open(char* pathname, int __pmode)//279817
{
	FILE* file; // ST10_4


	if (__pmode == 0x222)
	{
		file = x_creat(pathname, 0x1c0);
		//x_setmode(v2, 0x200);
		x_close(file);
	}
	return x_sopen(pathname, __pmode, 0x40);
}
int sub_98882_close(FILE* a1)//279882
{
	return x_close(a1);
}

void sub_70A60_open_tmaps()//251a60
{
	//char printbuffer[512];//char v1; // [esp+0h] [ebp-40h]

	sprintf_s(printbuffer, 512, "%s%s/%s/%s.dat", "c:/prenos/Magic2/mc2-orig", "/netherw", "cdata", "tmaps0-0");
	x_DWORD_DB740_tmaps00file = sub_98817_open(printbuffer, 512);
	if (x_DWORD_DB740_tmaps00file == NULL)
	{
		sprintf_s(printbuffer, 512, "data/%s.dat", "tmaps0-0");
		x_DWORD_DB740_tmaps00file = sub_98817_open(printbuffer, 512);
	}
	sprintf_s(printbuffer, 512, "%s%s/%s/%s.dat", "c:/prenos/Magic2/mc2-orig", "/netherw", "cdata", "tmaps1-0");
	x_DWORD_DB744_tmaps10file = sub_98817_open(printbuffer, 512);
	if (x_DWORD_DB744_tmaps10file == NULL)
	{
		sprintf_s(printbuffer, 512, "data/%s.dat", "tmaps1-0");
		x_DWORD_DB744_tmaps10file = sub_98817_open(printbuffer, 512);
	}
	sprintf_s(printbuffer, 512, "%s%s/%s/%s.dat", "c:/prenos/Magic2/mc2-orig", "/netherw", "cdata", "tmaps2-0");
	x_DWORD_DB748_tmaps20file = sub_98817_open(printbuffer, 512);
	if (x_DWORD_DB748_tmaps20file == NULL)
	{
		sprintf_s(printbuffer, 512, "data/%s.dat", "tmaps2-0");
		x_DWORD_DB748_tmaps20file = sub_98817_open(printbuffer, 512);
	}
	x_DWORD_DB73C_tmapsfile = x_DWORD_DB740_tmaps00file;
	//return 1;
}

Bit16u x_WORD_D951C[0x980] = {//2aa51c
0x0008, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000,
0x000B, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000,
0x000E, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000,
0x000E, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000,
0x000E, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000,
0x000E, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000,
0x0026, 0x212C, 0x002A, 0x0000, 0x00FA, 0xFF00, 0x0000,
0x003C, 0x212C, 0x002A, 0x0000, 0x0096, 0xFF00, 0x0000,
0x003F, 0x212C, 0x002A, 0x0000, 0x0032, 0x0102, 0x0000,
0x003F, 0x212C, 0x002A, 0x0000, 0x0064, 0x0102, 0x0000,
0x003F, 0x212C, 0x002A, 0x0000, 0x0096, 0x0102, 0x0000,
0x003F, 0x212C, 0x002A, 0x0000, 0x00C8, 0x0102, 0x0000,
0x003F, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0102, 0x0000,
0x003F, 0x212C, 0x002A, 0x0000, 0x012C, 0x0102, 0x0000,
0x003F, 0x212C, 0x002A, 0x0000, 0x015E, 0x0102, 0x0000,
0x003F, 0x212C, 0x002A, 0x0000, 0x0190, 0x0102, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000,
0x003D, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x0096, 0xFF00, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x00A5, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x00B9, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x00C8, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x00D2, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x00D2, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x00C8, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x00BE, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x00AA, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x00A0, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x0082, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x006E, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x005A, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x0046, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x003C, 0x0100, 0x0000,
0x004C, 0x212C, 0x002A, 0x0000, 0x0320, 0x0300, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000,
0x004F, 0x212C, 0x002A, 0x0000, 0x0190, 0x0100, 0x0000,
0x0016, 0x212C, 0x002A, 0x0000, 0x0118, 0x0100, 0x0000,
0x0036, 0x212C, 0x002A, 0x0000, 0x00FA, 0xFF00, 0x0000,
0x0037, 0x212C, 0x002A, 0x0000, 0x0082, 0xFF00, 0x0000,
0x0052, 0x212C, 0x002A, 0x0000, 0x0096, 0xFF00, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x00C8, 0xFF00, 0x0000,
0x003E, 0x212C, 0x002A, 0x0000, 0x0096, 0xFF00, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x012C, 0x0100, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x0064, 0x0100, 0x0000, 0x0000,
0x212C, 0x002A, 0x0000, 0x012C, 0x0100, 0x0000, 0x0000, 0x212C,
0x002A, 0x0000, 0x0064, 0x0100, 0x0000, 0x0041, 0x212C, 0x002A,
0x0000, 0x0096, 0xFF00, 0x0000, 0x003A, 0x212C, 0x002A, 0x0000,
0x0032, 0xFF00, 0x0000, 0x003A, 0x212C, 0x002A, 0x0000, 0x0064,
0x0100, 0x0000, 0x003A, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100,
0x0000, 0x003A, 0x212C, 0x002A, 0x0000, 0x00C8, 0x0100, 0x0000,
0x003A, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x003A,
0x212C, 0x002A, 0x0000, 0x012C, 0x0100, 0x0000, 0x003A, 0x212C,
0x002A, 0x0000, 0x015E, 0x0100, 0x0000, 0x003A, 0x212C, 0x002A,
0x0000, 0x0190, 0x0100, 0x0000, 0x0053, 0x212C, 0x002A, 0x0000,
0x0320, 0x0400, 0x0000, 0x0054, 0x212C, 0x002A, 0x0000, 0x0320,
0x0400, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100,
0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x0064, 0x0100, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000, 0x0051,
0x212C, 0x002A, 0x0000, 0x00C8, 0xFF00, 0x0000, 0x0050, 0x212C,
0x002A, 0x0000, 0x00C8, 0x0100, 0x0000, 0x0039, 0x212C, 0x002A,
0x0000, 0x0032, 0xFF02, 0x0000, 0x0039, 0x212C, 0x002A, 0x0000,
0x0064, 0x0102, 0x0000, 0x0039, 0x212C, 0x002A, 0x0000, 0x0096,
0x0102, 0x0000, 0x0039, 0x212C, 0x002A, 0x0000, 0x00C8, 0x0102,
0x0000, 0x0039, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0102, 0x0000,
0x0039, 0x212C, 0x002A, 0x0000, 0x012C, 0x0102, 0x0000, 0x0039,
0x212C, 0x002A, 0x0000, 0x015E, 0x0102, 0x0000, 0x0039, 0x212C,
0x002A, 0x0000, 0x0190, 0x0102, 0x0000, 0x0000, 0x212C, 0x002A,
0x0000, 0x0096, 0x0100, 0x0000, 0x0040, 0x212C, 0x002A, 0x0000,
0x015E, 0x0100, 0x0000, 0x003B, 0x212C, 0x002A, 0x0000, 0x0096,
0xFF00, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x0096, 0x0103,
0x0000, 0x004E, 0x212C, 0x002A, 0x0000, 0x01F4, 0xFF00, 0x0000,
0x0056, 0x212C, 0x002A, 0x0000, 0x0096, 0xFF00, 0x0000, 0x0055,
0x212C, 0x002A, 0x0000, 0x0096, 0xFF00, 0x0000, 0x0000, 0x212C,
0x002A, 0x0000, 0x0096, 0x0100, 0x0000, 0x004B, 0x212C, 0x002A,
0x0000, 0x0320, 0x0400, 0x0000, 0x0057, 0x212C, 0x002A, 0x0000,
0x0320, 0x0400, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x0064, 0x0100,
0x0000, 0x001E, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000,
0x001E, 0x212C, 0x002A, 0x0000, 0x00B4, 0x0100, 0x0000, 0x0042,
0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000, 0x0042, 0x212C,
0x002A, 0x0000, 0x00A5, 0x0100, 0x0000, 0x0042, 0x212C, 0x002A,
0x0000, 0x00B9, 0x0100, 0x0000, 0x0042, 0x212C, 0x002A, 0x0000,
0x00C8, 0x0100, 0x0000, 0x0042, 0x212C, 0x002A, 0x0000, 0x00D2,
0x0100, 0x0000, 0x0042, 0x212C, 0x002A, 0x0000, 0x00D2, 0x0100,
0x0000, 0x0042, 0x212C, 0x002A, 0x0000, 0x00C8, 0x0100, 0x0000,
0x0042, 0x212C, 0x002A, 0x0000, 0x00BE, 0x0100, 0x0000, 0x0042,
0x212C, 0x002A, 0x0000, 0x00AA, 0x0100, 0x0000, 0x0042, 0x212C,
0x002A, 0x0000, 0x00A0, 0x0100, 0x0000, 0x0042, 0x212C, 0x002A,
0x0000, 0x0096, 0x0100, 0x0000, 0x0042, 0x212C, 0x002A, 0x0000,
0x0082, 0x0100, 0x0000, 0x0042, 0x212C, 0x002A, 0x0000, 0x006E,
0x0100, 0x0000, 0x0042, 0x212C, 0x002A, 0x0000, 0x005A, 0x0100,
0x0000, 0x0042, 0x212C, 0x002A, 0x0000, 0x0046, 0x0100, 0x0000,
0x0042, 0x212C, 0x002A, 0x0000, 0x003C, 0x0100, 0x0000, 0x0043,
0x212C, 0x002A, 0x0000, 0x0032, 0xFF00, 0x0000, 0x0043, 0x212C,
0x002A, 0x0000, 0x0064, 0x0100, 0x0000, 0x0043, 0x212C, 0x002A,
0x0000, 0x0096, 0x0100, 0x0000, 0x0043, 0x212C, 0x002A, 0x0000,
0x00C8, 0x0100, 0x0000, 0x0043, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x0043, 0x212C, 0x002A, 0x0000, 0x012C, 0x0100,
0x0000, 0x0043, 0x212C, 0x002A, 0x0000, 0x015E, 0x0100, 0x0000,
0x0043, 0x212C, 0x002A, 0x0000, 0x0190, 0x0100, 0x0000, 0x0044,
0x212C, 0x002A, 0x0000, 0x0032, 0xFF00, 0x0000, 0x0044, 0x212C,
0x002A, 0x0000, 0x0064, 0x0100, 0x0000, 0x0044, 0x212C, 0x002A,
0x0000, 0x0096, 0x0100, 0x0000, 0x0044, 0x212C, 0x002A, 0x0000,
0x00C8, 0x0100, 0x0000, 0x0044, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x0044, 0x212C, 0x002A, 0x0000, 0x012C, 0x0100,
0x0000, 0x0044, 0x212C, 0x002A, 0x0000, 0x015E, 0x0100, 0x0000,
0x0044, 0x212C, 0x002A, 0x0000, 0x0190, 0x0100, 0x0000, 0x0045,
0x212C, 0x002A, 0x0000, 0x0032, 0xFF00, 0x0000, 0x0045, 0x212C,
0x002A, 0x0000, 0x0064, 0x0100, 0x0000, 0x0045, 0x212C, 0x002A,
0x0000, 0x0096, 0x0100, 0x0000, 0x0045, 0x212C, 0x002A, 0x0000,
0x00C8, 0x0100, 0x0000, 0x0045, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x0045, 0x212C, 0x002A, 0x0000, 0x012C, 0x0100,
0x0000, 0x0045, 0x212C, 0x002A, 0x0000, 0x015E, 0x0100, 0x0000,
0x0045, 0x212C, 0x002A, 0x0000, 0x0190, 0x0100, 0x0000, 0x0046,
0x212C, 0x002A, 0x0000, 0x0032, 0xFF00, 0x0000, 0x0046, 0x212C,
0x002A, 0x0000, 0x0064, 0x0100, 0x0000, 0x0046, 0x212C, 0x002A,
0x0000, 0x0096, 0x0100, 0x0000, 0x0046, 0x212C, 0x002A, 0x0000,
0x00C8, 0x0100, 0x0000, 0x0046, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x0046, 0x212C, 0x002A, 0x0000, 0x012C, 0x0100,
0x0000, 0x0046, 0x212C, 0x002A, 0x0000, 0x015E, 0x0100, 0x0000,
0x0046, 0x212C, 0x002A, 0x0000, 0x0190, 0x0100, 0x0000, 0x0047,
0x212C, 0x002A, 0x0000, 0x0032, 0xFF00, 0x0000, 0x0047, 0x212C,
0x002A, 0x0000, 0x0064, 0x0100, 0x0000, 0x0047, 0x212C, 0x002A,
0x0000, 0x0096, 0x0100, 0x0000, 0x0047, 0x212C, 0x002A, 0x0000,
0x00C8, 0x0100, 0x0000, 0x0047, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x0047, 0x212C, 0x002A, 0x0000, 0x012C, 0x0100,
0x0000, 0x0047, 0x212C, 0x002A, 0x0000, 0x015E, 0x0100, 0x0000,
0x0047, 0x212C, 0x002A, 0x0000, 0x0190, 0x0100, 0x0000, 0x0048,
0x212C, 0x002A, 0x0000, 0x0032, 0xFF00, 0x0000, 0x0048, 0x212C,
0x002A, 0x0000, 0x0064, 0x0100, 0x0000, 0x0048, 0x212C, 0x002A,
0x0000, 0x0096, 0x0100, 0x0000, 0x0048, 0x212C, 0x002A, 0x0000,
0x00C8, 0x0100, 0x0000, 0x0048, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x0048, 0x212C, 0x002A, 0x0000, 0x012C, 0x0100,
0x0000, 0x0048, 0x212C, 0x002A, 0x0000, 0x015E, 0x0100, 0x0000,
0x0048, 0x212C, 0x002A, 0x0000, 0x0190, 0x0100, 0x0000, 0x0049,
0x212C, 0x002A, 0x0000, 0x0032, 0xFF00, 0x0000, 0x0049, 0x212C,
0x002A, 0x0000, 0x0064, 0x0100, 0x0000, 0x0049, 0x212C, 0x002A,
0x0000, 0x0096, 0x0100, 0x0000, 0x0049, 0x212C, 0x002A, 0x0000,
0x00C8, 0x0100, 0x0000, 0x0049, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x0049, 0x212C, 0x002A, 0x0000, 0x012C, 0x0100,
0x0000, 0x0049, 0x212C, 0x002A, 0x0000, 0x015E, 0x0100, 0x0000,
0x0049, 0x212C, 0x002A, 0x0000, 0x0190, 0x0100, 0x0000, 0x004A,
0x212C, 0x002A, 0x0000, 0x0032, 0xFF00, 0x0000, 0x004A, 0x212C,
0x002A, 0x0000, 0x0064, 0x0100, 0x0000, 0x004A, 0x212C, 0x002A,
0x0000, 0x0096, 0x0100, 0x0000, 0x004A, 0x212C, 0x002A, 0x0000,
0x00C8, 0x0100, 0x0000, 0x004A, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x004A, 0x212C, 0x002A, 0x0000, 0x012C, 0x0100,
0x0000, 0x004A, 0x212C, 0x002A, 0x0000, 0x015E, 0x0100, 0x0000,
0x004A, 0x212C, 0x002A, 0x0000, 0x0190, 0x0100, 0x0000, 0x0058,
0x212C, 0x002A, 0x0000, 0x0320, 0xF000, 0x0000, 0x0059, 0x212C,
0x002A, 0x0000, 0x0320, 0xF000, 0x0000, 0x005A, 0x212C, 0x002A,
0x0000, 0x0320, 0xF000, 0x0000, 0x005B, 0x212C, 0x002A, 0x0000,
0x0320, 0x0100, 0x0000, 0x005C, 0x212C, 0x002A, 0x0000, 0x0320,
0x0100, 0x0000, 0x005D, 0x212C, 0x002A, 0x0000, 0x0320, 0x0100,
0x0000, 0x005E, 0x212C, 0x002A, 0x0000, 0x0320, 0x0100, 0x0000,
0x005F, 0x212C, 0x002A, 0x0000, 0x0320, 0x0100, 0x0000, 0x0060,
0x212C, 0x002A, 0x0000, 0x0190, 0xFF00, 0x0000, 0x0061, 0x212C,
0x002A, 0x0000, 0x0190, 0xFF00, 0x0000, 0x0062, 0x212C, 0x002A,
0x0000, 0x0190, 0xFF00, 0x0000, 0x0063, 0x212C, 0x002A, 0x0000,
0x0190, 0x0100, 0x0000, 0x0064, 0x212C, 0x002A, 0x0000, 0x0190,
0x0100, 0x0000, 0x0065, 0x212C, 0x002A, 0x0000, 0x0190, 0x0100,
0x0000, 0x0066, 0x212C, 0x002A, 0x0000, 0x0190, 0x0100, 0x0000,
0x0067, 0x212C, 0x002A, 0x0000, 0x0190, 0x0100, 0x0000, 0x0000,
0x212C, 0x002A, 0x0000, 0x0050, 0x0100, 0x0000, 0x0000, 0x212C,
0x002A, 0x0000, 0x008C, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A,
0x0000, 0x00C8, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000,
0x0118, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x0168,
0x0100, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x01B8, 0x0100,
0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x0208, 0x0100, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x0258, 0x0100, 0x0000, 0x0000,
0x212C, 0x002A, 0x0000, 0x0032, 0x0100, 0x0000, 0x0000, 0x212C,
0x002A, 0x0000, 0x0064, 0x0100, 0x0000, 0x0069, 0x212C, 0x002A,
0x0000, 0x003C, 0xFF00, 0x0000, 0x003C, 0x212C, 0x002A, 0x0000,
0x0064, 0xFF00, 0x0000, 0x0068, 0x212C, 0x002A, 0x0000, 0x0064,
0xFF00, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100,
0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x0190, 0x0100, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x0100, 0x0100, 0x0000, 0x006E,
0x212C, 0x002A, 0x0000, 0x0100, 0x0100, 0x0000, 0x0071, 0x212C,
0x002A, 0x0000, 0x0100, 0x0100, 0x0000, 0x0074, 0x212C, 0x002A,
0x0000, 0x003C, 0xFF00, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000,
0x0100, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x0100,
0x0100, 0x0000, 0x0079, 0x212C, 0x002A, 0x0000, 0x00F0, 0x0100,
0x0000, 0x007C, 0x212C, 0x002A, 0x0000, 0x05DC, 0x0100, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x012C, 0x0100, 0x0000, 0x0090,
0x212C, 0x002A, 0x0000, 0x0096, 0xFF03, 0x0000, 0x0091, 0x212C,
0x002A, 0x0000, 0x0096, 0xFF00, 0x0000, 0x0092, 0x212C, 0x002A,
0x0000, 0x0096, 0xFF00, 0x0000, 0x0093, 0x212C, 0x002A, 0x0000,
0x0096, 0xFF00, 0x0000, 0x0094, 0x212C, 0x002A, 0x0000, 0x0096,
0xFF00, 0x0000, 0x0095, 0x212C, 0x002A, 0x0000, 0x0096, 0xFF00,
0x0000, 0x0096, 0x212C, 0x002A, 0x0000, 0x0096, 0xFF00, 0x0000,
0x0097, 0x212C, 0x002A, 0x0000, 0x0032, 0xFF03, 0x0000, 0x0084,
0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x0087, 0x212C,
0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x008A, 0x212C, 0x002A,
0x0000, 0x00FA, 0x0100, 0x0000, 0x009E, 0x212C, 0x002A, 0x0000,
0x007D, 0x0100, 0x0000, 0x008D, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x009F, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100,
0x0000, 0x00A8, 0x212C, 0x002A, 0x0000, 0x01F4, 0x0100, 0x0000,
0x00A8, 0x212C, 0x002A, 0x0000, 0x01F4, 0x0103, 0x0000, 0x00A8,
0x212C, 0x002A, 0x0000, 0x01F4, 0x0100, 0x0000, 0x00B2, 0x212C,
0x002A, 0x0000, 0x0320, 0x0400, 0x0000, 0x00B3, 0x212C, 0x002A,
0x0000, 0x0320, 0x0400, 0x0000, 0x004D, 0x212C, 0x002A, 0x0000,
0x0032, 0xFF00, 0x0000, 0x004D, 0x212C, 0x002A, 0x0000, 0x0096,
0x0100, 0x0000, 0x004D, 0x212C, 0x002A, 0x0000, 0x012C, 0x0100,
0x0000, 0x004D, 0x212C, 0x002A, 0x0000, 0x01C2, 0x0100, 0x0000,
0x004D, 0x212C, 0x002A, 0x0000, 0x0258, 0x0100, 0x0000, 0x004D,
0x212C, 0x002A, 0x0000, 0x02BC, 0x0100, 0x0000, 0x004D, 0x212C,
0x002A, 0x0000, 0x0320, 0x0100, 0x0000, 0x004D, 0x212C, 0x002A,
0x0000, 0x03B6, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000,
0x00FA, 0x0100, 0x0000, 0x00A9, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x0098, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100,
0x0000, 0x009B, 0x212C, 0x002A, 0x0000, 0x00C8, 0xFF00, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x00B4,
0x212C, 0x002A, 0x0000, 0x00FA, 0xFF00, 0x0000, 0x00B7, 0x212C,
0x002A, 0x0000, 0x00FA, 0xFF00, 0x0000, 0x0000, 0x212C, 0x002A,
0x0000, 0x00FA, 0x0100, 0x0000, 0x00BA, 0x212C, 0x002A, 0x0000,
0x012C, 0xFF00, 0x0000, 0x00C5, 0x212C, 0x002A, 0x0000, 0x00A0,
0xFF00, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100,
0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x0000,
0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x0000, 0x212C,
0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A,
0x0000, 0x00FA, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000,
0x00FA, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100,
0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x0000,
0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x0000, 0x212C,
0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A,
0x0000, 0x00FA, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000,
0x00FA, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100,
0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x0000,
0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x0000, 0x212C,
0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A,
0x0000, 0x00FA, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000,
0x00FA, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x00C6, 0x212C, 0x002A, 0x0000, 0x0190, 0x0100,
0x0000, 0x00C7, 0x212C, 0x002A, 0x0000, 0x012C, 0xFF00, 0x0000,
0x00CA, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x00D3,
0x212C, 0x002A, 0x0000, 0x00C8, 0xFF00, 0x0000, 0x00F3, 0x212C,
0x002A, 0x0000, 0x00C8, 0xFF00, 0x0000, 0x00CB, 0x212C, 0x002A,
0x0000, 0x00C8, 0x0100, 0x0000, 0x00FB, 0x212C, 0x002A, 0x0000,
0x00C8, 0x0100, 0x0000, 0x00EB, 0x212C, 0x002A, 0x0000, 0x00C8,
0x0100, 0x0000, 0x00E3, 0x212C, 0x002A, 0x0000, 0x00C8, 0x0100,
0x0000, 0x00DB, 0x212C, 0x002A, 0x0000, 0x00C8, 0x0100, 0x0000,
0x0103, 0x212C, 0x002A, 0x0000, 0x004B, 0xFF00, 0x0000, 0x0104,
0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000, 0x0105, 0x212C,
0x002A, 0x0000, 0x0096, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A,
0x0000, 0x0096, 0x0100, 0x0000, 0x0106, 0x212C, 0x002A, 0x0000,
0x0096, 0x0100, 0x0000, 0x0107, 0x212C, 0x002A, 0x0000, 0x010E,
0x0100, 0x0000, 0x010F, 0x212C, 0x002A, 0x0000, 0x02BC, 0x0100,
0x0000, 0x0117, 0x212C, 0x002A, 0x0000, 0x00C8, 0x0100, 0x0000,
0x011F, 0x212C, 0x002A, 0x0000, 0x00C8, 0x0100, 0x0000, 0x0127,
0x212C, 0x002A, 0x0000, 0x0230, 0x0100, 0x0000, 0x012F, 0x212C,
0x002A, 0x0000, 0x0352, 0x0100, 0x0000, 0x0137, 0x212C, 0x002A,
0x0000, 0x0258, 0x0100, 0x0000, 0x013F, 0x212C, 0x002A, 0x0000,
0x003C, 0x0100, 0x0000, 0x0147, 0x212C, 0x002A, 0x0000, 0x0046,
0x0102, 0x0000, 0x0147, 0x212C, 0x002A, 0x0000, 0x0050, 0x0102,
0x0000, 0x0147, 0x212C, 0x002A, 0x0000, 0x005A, 0x0102, 0x0000,
0x0147, 0x212C, 0x002A, 0x0000, 0x0064, 0x0102, 0x0000, 0x0147,
0x212C, 0x002A, 0x0000, 0x006E, 0x0102, 0x0000, 0x0147, 0x212C,
0x002A, 0x0000, 0x0078, 0x0102, 0x0000, 0x0147, 0x212C, 0x002A,
0x0000, 0x0082, 0x0102, 0x0000, 0x0147, 0x212C, 0x002A, 0x0000,
0x0096, 0x0102, 0x0000, 0x0147, 0x212C, 0x002A, 0x0000, 0x00B4,
0x0102, 0x0000, 0x0147, 0x212C, 0x002A, 0x0000, 0x00DC, 0x0102,
0x0000, 0x0147, 0x212C, 0x002A, 0x0000, 0x0118, 0x0102, 0x0000,
0x0147, 0x212C, 0x002A, 0x0000, 0x0168, 0x0102, 0x0000, 0x0148,
0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x0150, 0x212C,
0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x0158, 0x212C, 0x002A,
0x0000, 0x00FA, 0x0100, 0x0000, 0x0160, 0x212C, 0x002A, 0x0000,
0x00FA, 0x0100, 0x0000, 0x0168, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x0170, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100,
0x0000, 0x0178, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000,
0x0180, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000, 0x0188,
0x212C, 0x002A, 0x0000, 0x0078, 0x0100, 0x0000, 0x0189, 0x212C,
0x002A, 0x0000, 0x003C, 0x0100, 0x0000, 0x018A, 0x212C, 0x002A,
0x0000, 0x0320, 0x0100, 0x0000, 0x0192, 0x212C, 0x002A, 0x0000,
0x0104, 0x0100, 0x0000, 0x019A, 0x212C, 0x002A, 0x0000, 0x0078,
0x0100, 0x0000, 0x019B, 0x212C, 0x002A, 0x0000, 0x0140, 0x0100,
0x0000, 0x01A3, 0x212C, 0x002A, 0x0000, 0x00A0, 0x0100, 0x0000,
0x01A4, 0x212C, 0x002A, 0x0000, 0x0078, 0x0100, 0x0000, 0x01A5,
0x212C, 0x002A, 0x0000, 0x0078, 0x0100, 0x0000, 0x01A6, 0x212C,
0x002A, 0x0000, 0x00C8, 0x0100, 0x0000, 0x01A7, 0x212C, 0x002A,
0x0000, 0x00C8, 0x0100, 0x0000, 0x01A8, 0x212C, 0x002A, 0x0000,
0x0064, 0x0100, 0x0000, 0x01A8, 0x212C, 0x002A, 0x0000, 0x0096,
0x0100, 0x0000, 0x01A8, 0x212C, 0x002A, 0x0000, 0x00C8, 0x0100,
0x0000, 0x01A8, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000,
0x01A9, 0x212C, 0x002A, 0x0000, 0x00AF, 0x0100, 0x0000, 0x01A9,
0x212C, 0x002A, 0x0000, 0x0106, 0x0100, 0x0000, 0x01A9, 0x212C,
0x002A, 0x0000, 0x015E, 0x0100, 0x0000, 0x01A9, 0x212C, 0x002A,
0x0000, 0x01B5, 0x0100, 0x0000, 0x01AA, 0x212C, 0x002A, 0x0000,
0x003C, 0xFF00, 0x0000, 0x01AA, 0x212C, 0x002A, 0x0000, 0x0064,
0xFF00, 0x0000, 0x01AA, 0x212C, 0x002A, 0x0000, 0x008C, 0xFF00,
0x0000, 0x01B5, 0x212C, 0x002A, 0x0000, 0x01C2, 0x0100, 0x0000,
0x01BD, 0x212C, 0x002A, 0x0000, 0x01C2, 0x0100, 0x0000, 0x01C5,
0x212C, 0x002A, 0x0000, 0x0320, 0x0100, 0x0000, 0x01CD, 0x212C,
0x002A, 0x0000, 0x02BC, 0x0100, 0x0000, 0x01CE, 0x212C, 0x002A,
0x0000, 0x03E8, 0x0100, 0x0000, 0x01CF, 0x212C, 0x002A, 0x0000,
0x0064, 0x0100, 0x0000, 0x01D0, 0x212C, 0x002A, 0x0000, 0x04B0,
0x0100, 0x0000, 0x01D8, 0x212C, 0x002A, 0x0000, 0x04B0, 0x0100,
0x0000, 0x01E0, 0x212C, 0x002A, 0x0000, 0x04B0, 0x0100, 0x0000,
0x01E8, 0x212C, 0x002A, 0x0000, 0x04B0, 0x0100, 0x0000, 0x01F0,
0x212C, 0x002A, 0x0000, 0x04B0, 0x0100, 0x0000, 0x0000, 0x0000,
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xFF00, 0x0003, 0x00FA };

void sub_70BF0_close_tmaps()//251bf0
{
	//int result; // eax

	if (x_DWORD_DB740_tmaps00file != NULL)
	{
		sub_98882_close(x_DWORD_DB740_tmaps00file);
		x_DWORD_DB740_tmaps00file = NULL;
	}
	if (x_DWORD_DB744_tmaps10file != NULL)
	{
		sub_98882_close(x_DWORD_DB744_tmaps10file);
		x_DWORD_DB744_tmaps10file = NULL;
	}
	if (x_DWORD_DB748_tmaps20file != NULL)
	{
		sub_98882_close(x_DWORD_DB748_tmaps20file);
		x_DWORD_DB748_tmaps20file = NULL;
	}
	x_DWORD_DB73C_tmapsfile = NULL;
	//return result;
}

Bit8u x_DWORD_180628b_screen_buffer[640*480];
void sub_71410_process_tmaps()//252410
{
	Bit16u* v0; // esi
	Bit8u* v1; // ebx
	Bit16u v2; // di

	sub_70A60_open_tmaps();
	v0 = x_WORD_D951C;
	v1 = x_DWORD_180628b_screen_buffer;
	while (v0[3] || v0[4])
	{
		v2 = *v0;
		memset((void*)v1, 0, *(Bit32u*)& TMAPS00TAB_BEGIN_BUFFER[10 * (*v0 + 1) + 4] - *(Bit32u*)& TMAPS00TAB_BEGIN_BUFFER[10 * *v0 + 4]);
		if (sub_70C60_decompress_tmap(v2, v1) == -1)
		{
			*(x_WORD*)(v1 + 2) = 255;
			*(x_WORD*)(v1 + 4) = 255;
			*(x_BYTE*)(v1 + 1) = 1;
		}
		if (!*(x_WORD*)(v1 + 4) || !*(x_WORD*)(v1 + 2))
		{
			*(x_WORD*)(v1 + 2) = 255;
			*(x_WORD*)(v1 + 4) = 255;
			*(x_BYTE*)(v1 + 1) = 1;
		}
		if (v0[3])
		{
			if (!v0[4])
				v0[4] = *(unsigned __int16*)(v1 + 4) * v0[3] / *(unsigned __int16*)(v1 + 2);
		}
		else
		{
			v0[3] = *(unsigned __int16*)(v1 + 2) * v0[4] / *(unsigned __int16*)(v1 + 4);
		}
		v0 += 7;
		*((x_BYTE*)v0 - 2) = *(x_BYTE*)(v1 + 1);
	}
	sub_70BF0_close_tmaps();
}

void main2()
{
	unsigned __int16 v0; // bx
	//__int16 result; // ax

	v0 = 0;
	do
	{
		//result = v0;
		//if (x_BYTE_F5340[v0])
			/*result = */sub_70F50(v0);
		v0++;
	} while (v0 < 0x1F8u);
    std::cout << "Hello World!\n"; 
}
typedef struct {
	char path[512];
	Bit8u** var28_begin_buffer;//1C // asi buffer
	Bit8u** var32_end_buffer;//20 // asi buffer
	Bit32u var36_size_buffer;//24 //asi file size
	Bit32u var40_alloc_type;//28
} Pathstruct;
Pathstruct pstrx = { "c:/prenos/Magic2/mc2-orig/netherw/cdata/tmaps0-0.tab",&TMAPS00TAB_BEGIN_BUFFER,NULL,1389610,NULL };

Bit8u* sub_9A2F5(Pathstruct path)//27B2f5
{
	Bit8u* result; // eax
	//2bac30
	result = *path.var28_begin_buffer;//fix it 2bac30
	//result = 0;//fix it
	if (result)
	{
		//sub_83E80_freemem4(*path.var28_begin_buffer);
		result = *path.var28_begin_buffer;
		*result = 0;
	}
	return result;
}

void* sub_83D70_malloc1(int a1)//264d70
{
	return malloc(a1);
}
void* sub_83CD0_malloc2(size_t a1)//264cd0
{
	return malloc(a1);
}
Bit32s myfseek(FILE* filedesc, x_DWORD position, char type) {
	return fseek(filedesc, position, type);
};

long myftell(FILE* decriptor) {
	return ftell(decriptor);
};
long x_filelength(FILE* decriptor) {
	long size;
	myfseek(decriptor, 0, SEEK_END); // seek to end of file
	size = myftell(decriptor); // get current file pointer
	myfseek(decriptor, 0, SEEK_SET); // seek back to beginning of file
	return size;
};
signed int sub_AB9E1_get_file_unpack_size(char* a1)//28c9e1
{
	Bit8u v2[10]; // [esp+0h] [ebp-1Ch]
	unsigned __int8 v3; // [esp+4h] [ebp-18h]
	unsigned __int8 v4; // [esp+5h] [ebp-17h]
	unsigned __int8 v5; // [esp+6h] [ebp-16h]
	unsigned __int8 v6; // [esp+7h] [ebp-15h]
	//char v7; // [esp+8h] [ebp-14h]
	//char v8; // [esp+9h] [ebp-13h]
	char v9; // [esp+Ah] [ebp-12h]
	char v10; // [esp+Bh] [ebp-11h]
	//char v11; // [esp+Ch] [ebp-10h]
	int ret_size; // [esp+14h] [ebp-8h]
	FILE* file; // [esp+18h] [ebp-4h]

	//fix it
	v3 = 0;
	v4 = 0;
	v5 = 0;
	v6 = 0;
	v9 = 0;
	v10 = 0;
	//fix it

	ret_size = -1;
	//v7 = 'R';
	//v8 = 'N';
	//v9 = 'C';
	//v10 = 1;
	//v11 = 0;
	file = sub_98817_open(a1, 512);
	if (file == NULL)
		return -1;
	sub_988A7_read(file, v2, 8);
	if (!strncmp((const char*)v2, (const char*)"RNC\1", 4))
	{
		ret_size = v2[4] << 8;//reverse size in rnc format
		ret_size += v2[5];
		ret_size <<= 8;
		ret_size += v2[6];
		ret_size <<= 8;
		ret_size += v2[7];
	}
	else
	{
		ret_size = x_filelength(file);
	}
	sub_98882_close(file);
	return ret_size;
}
int sub_53E60_readfile_and_decompress(const char* path, Bit8u** a2)//234E60
{
	x_DWORD result; // eax
	FILE* file; // ebx
	Bit32u v4; // esi
	file = sub_98817_open((char*)path, 0x200);//234E72 - 279817
	result = (x_DWORD)file;
	if (result != NULL)
	{
		v4 = x_filelength(file);//234E82 - 2798DA
		sub_988A7_read(file, *a2, v4);//234E8F - 2798A7
		sub_98882_close(file);//234E98 - 279882
		result = (x_DWORD)sub_9894C_decompress(*a2, *a2);//234ea2 - 27994c
		if (result >= 0)
		{
			if (!result)
				result = v4;
		}
		else
		{
			printf("ERROR decompressing %s\n");
			result = -2;
		}
	}
	return result;
}
signed int sub_9A32D_malloc_open_unpack(Pathstruct path)//27B32d
{
	//int v1; // edx
	//int *v2; // eax
	//void* v3; // edx
	//int *v4; // eax
	//void* (*v6)(int); // [esp+0h] [ebp-8h]

	//sub_85070();
	/*if (path.var40_alloc_type & 1 )
	  v6 = sub_83D70_malloc1;
	else
	  v6 = sub_83CD0_malloc2;*/
	sub_9A2F5(path);
	if (path.path[0] == 0x2A)//fix
	{
		if (path.var40_alloc_type & 1)
		{
			*(path.var28_begin_buffer) = (Bit8u*)sub_83D70_malloc1(path.var36_size_buffer);
			memset(*(path.var28_begin_buffer), 0, path.var36_size_buffer);
		}
		else
		{
			*(path.var28_begin_buffer) = (Bit8u*)sub_83CD0_malloc2(path.var36_size_buffer);
			memset(*(path.var28_begin_buffer), 0, path.var36_size_buffer);
		}
		//v2 = *(int *)(path.var28_begin_buffer);
		//*v2 = v1;
		if (!(*(path.var28_begin_buffer)))
			return 0;
	}
	else
	{
		path.var36_size_buffer = (int)sub_AB9E1_get_file_unpack_size(path.path);
		if (path.var36_size_buffer <= 0)
			return 0;
		if (path.var40_alloc_type & 1)
		{
			*(path.var28_begin_buffer) = (Bit8u*)sub_83D70_malloc1(path.var36_size_buffer);//asi init a malloc bufferu
			memset(*(path.var28_begin_buffer), 0, path.var36_size_buffer);
		}
		else
		{
			*(path.var28_begin_buffer) = (Bit8u*)sub_83CD0_malloc2(path.var36_size_buffer);//asi init a malloc bufferu
			memset(*(path.var28_begin_buffer), 0, path.var36_size_buffer);
		}
		//v4 = *(int **)path.var28_begin_buffer;
		//*v4 = v3;
		if (!(*(path.var28_begin_buffer)))
			return -1;
		if (sub_53E60_readfile_and_decompress(path.path, path.var28_begin_buffer) != path.var36_size_buffer)
		{
			path.var28_begin_buffer = 0;
			path.var32_end_buffer = 0;
			path.var36_size_buffer = 0;
			return 0;
		}
	}
	if (path.var32_end_buffer)
		(*path.var32_end_buffer) = (*path.var28_begin_buffer) + path.var36_size_buffer;//fix ma byt 1
	return 1;
}

int main() {
	//Bit8u* begin;
	//Bit8u* end;
	//pstrx.var28_begin_buffer = &begin;
	//pstrx.var32_end_buffer = &end;
	sub_9A32D_malloc_open_unpack(pstrx);
	sub_71410_process_tmaps();
	unsigned __int16 v0; // bx
	//__int16 result; // ax

	v0 = 0;
	do
	{
		//result = v0;
		//if (x_BYTE_F5340[v0])
		/*result = */sub_70F50(v0);
		v0++;
	} while (v0 < 0x1F8u);
	std::cout << "Hello World!\n";
}

// Spuštění programu: Ctrl+F5 nebo nabídka Ladit > Spustit bez ladění
// Ladění programu: F5 nebo nabídka Ladit > Spustit ladění

// Tipy pro zahájení práce:
//   1. K přidání nebo správě souborů použijte okno Průzkumník řešení.
//   2. Pro připojení ke správě zdrojového kódu použijte okno Team Explorer.
//   3. K zobrazení výstupu sestavení a dalších zpráv použijte okno Výstup.
//   4. K zobrazení chyb použijte okno Seznam chyb.
//   5. Pokud chcete vytvořit nové soubory kódu, přejděte na Projekt > Přidat novou položku. Pokud chcete přidat do projektu existující soubory kódu, přejděte na Projekt > Přidat existující položku.
//   6. Pokud budete chtít v budoucnu znovu otevřít tento projekt, přejděte na Soubor > Otevřít > Projekt a vyberte příslušný soubor .sln.
